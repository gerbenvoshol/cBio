1,5c1,16
< /*
< ** This is free software; you can redistribute it and/or
< ** modify it under the terms of the GNU Library General Public License
< ** as published by the Free Software Foundation; either version 2
< ** of the License, or (at your option) any later version.
---
> /* @source ajseqread **********************************************************
> **
> ** AJAX sequence reading functions
> **
> ** These functions control all aspects of AJAX sequence reading
> **
> ** @author Copyright (C) 2001 Peter Rice
> ** @version $Revision: 1.334 $
> ** @modified 2001-2011 pmr
> ** @modified $Date: 2013/07/15 20:57:32 $ by $Author: rice $
> ** @@
> **
> ** This library is free software; you can redistribute it and/or
> ** modify it under the terms of the GNU Lesser General Public
> ** License as published by the Free Software Foundation; either
> ** version 2.1 of the License, or (at your option) any later version.
7c18
< ** This program is distributed in the hope that it will be useful,
---
> ** This library is distributed in the hope that it will be useful,
9,10c20,26
< ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< ** GNU General Public License for more details.
---
> ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> ** Lesser General Public License for more details.
> **
> ** You should have received a copy of the GNU Lesser General Public
> ** License along with this library; if not, write to the Free Software
> ** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
> ** MA  02110-1301,  USA.
12,14d27
< ** You should have received a copy of the GNU Library General Public License
< ** along with this program; if not, write to the Free Software
< ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
17c30,53
< #include "ajax.h"
---
> #include "ajlib.h"
> 
> #include "ajseqread.h"
> #include "ajseq.h"
> #include "ajseqabi.h"
> #include "ajseqtype.h"
> #include "ajfeat.h"
> #include "ajfeatread.h"
> #include "ajcall.h"
> #include "ajmath.h"
> #include "ajlist.h"
> #include "ajtable.h"
> #include "ajquery.h"
> #include "ajutil.h"
> #include "ajbase.h"
> #include "ajnexus.h"
> #include "ajdom.h"
> #include "ajseqbam.h"
> #include "ajreg.h"
> #include "ajtext.h"
> #include "ajtextread.h"
> #include "ajfileio.h"
> #include "ajnam.h"
> 
22d57
< #include "ajseqbam.h"
26c61,64
< #endif
---
> #endif /* WIN32 */
> 
> #define SCF_MAGIC (((((((ajuint)'.'<<8)+(ajuint)'s')<<8) \
>                      +(ajuint)'c')<<8)+(ajuint)'f')
30c68,80
< static ajint seqMaxGcglines = 5000;
---
> static AjPStr    seqAppendTmpstr = NULL;
> static AjPStrTok seqHandle  = NULL;
> static AjPStrTok seqHandle2  = NULL;
> static AjPStrTok seqHandleSplit = NULL;
> static AjPStr    seqToken = NULL;
> static AjPStr    seqToken2 = NULL;
> static AjPStr    seqTokenSplit = NULL;
> static AjPStr    seqName = NULL;
> static AjPStr    seqChain = NULL;
> 
> static char* seqAppendFilter = NULL;
> 
> static ajint     seqMaxGcglines = 5000;
96,134c146,163
< static float seqQualPhred[] = { 0.0,
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 1-8 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 9-16 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 17-24 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 25-32 */
<    0.0,  1.0,  2.0,  3.0,  4.0,  5.0,  6.0,  7.0,   8.0,  9.0, /* 33-42 */
<   10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0,  18.0, 19.0, /* 43-52 */
<   20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0,  28.0, 29.0, /* 53-62 */
<   30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0,  38.0, 39.0, /* 63-72 */
<   40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0,  48.0, 49.0, /* 73-82 */
<   50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,  58.0, 59.0, /* 83-92 */
<   60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0,  68.0, 69.0, /* 93-102 */
<   70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0,  78.0, 79.0, /* 103-112 */
<   80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,  88.0, 89.0, /* 113-122 */
<   90.0, 91.0, 92.0, 93.0};	/* 123-126 */
< 
< static double seqQualSolexa[] = {
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 0-7 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 8-15 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 16-23 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 24-31 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 32-39 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 40-47 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 48-55 */
<    0.0,  0.0,  0.0, 1.193310,                     /* 56-59 */
<   1.455405,  1.764349,  2.124426,  2.539019,  3.010300, /* 60-64 */
<   3.539019,  4.124426,  4.764349,  5.455405,  6.193310, /* 65-69 */
<   6.973228,  7.790097,  8.638920,  9.514969, 10.413927, /* 70-74 */
<  11.331956, 12.265724, 13.212384, 14.169543, 15.135209, /* 75-79 */
<  16.107742, 17.085800, 18.068291, 19.054333, 20.043214, /* 80-84 */
<  21.034361, 22.027316, 23.021712, 24.017255, 25.013712, /* 85-89 */
<  26.010895, 27.008657, 28.006878, 29.005464, 30.004341, /* 90-94 */
<  31.003448, 32.002739, 33.002176, 34.001729, 35.001373, /* 95-99 */
<  36.001091, 37.000866, 38.000688, 39.000547, 40.000434, /* 100-104 */
<  41.000345, 42.000274, 43.000218, 44.000173, 45.000137, /* 105-109 */
<  46.000109, 47.000087, 48.000069, 49.000055, 50.000043, /* 110-114 */
<  51.000034, 52.000027, 53.000022, 54.000017, 55.000014, /* 115-119 */
<  56.000011, 57.000009, 58.000007, 59.000005, 60.000004, /* 120-124 */
<  61.000003, 62.000003};	/* 125-126 */
---
> static float seqQualPhred[] =
> {
>     0.0,
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*   1-8 */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*   9-16 */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  17-24 */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  25-32 */
>     0.0,  1.0,  2.0,  3.0,  4.0,  5.0,  6.0,  7.0,   8.0,  9.0,  /*  33-42 */
>     10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0,  18.0, 19.0, /*  43-52 */
>     20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0,  28.0, 29.0, /*  53-62 */
>     30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0,  38.0, 39.0, /*  63-72 */
>     40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0,  48.0, 49.0, /*  73-82 */
>     50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,  58.0, 59.0, /*  83-92 */
>     60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0,  68.0, 69.0, /*  93-102 */
>     70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0,  78.0, 79.0, /* 103-112 */
>     80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,  88.0, 89.0, /* 113-122 */
>     90.0, 91.0, 92.0, 93.0                                       /* 123-126 */
> };
135a165,211
> static double seqQualSolexa[] =
> {
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*   0-7   */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*   8-15  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*  16-23  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*  24-31  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*  32-39  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*  40-47  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,         /*  48-55  */
>     0.0,  0.0,  0.0, 1.193310,                             /*  56-59  */
>     1.455405,  1.764349,  2.124426,  2.539019,  3.010300,  /*  60-64  */
>     3.539019,  4.124426,  4.764349,  5.455405,  6.193310,  /*  65-69  */
>     6.973228,  7.790097,  8.638920,  9.514969, 10.413927,  /*  70-74  */
>     11.331956, 12.265724, 13.212384, 14.169543, 15.135209, /*  75-79  */
>     16.107742, 17.085800, 18.068291, 19.054333, 20.043214, /*  80-84  */
>     21.034361, 22.027316, 23.021712, 24.017255, 25.013712, /*  85-89  */
>     26.010895, 27.008657, 28.006878, 29.005464, 30.004341, /*  90-94  */
>     31.003448, 32.002739, 33.002176, 34.001729, 35.001373, /*  95-99  */
>     36.001091, 37.000866, 38.000688, 39.000547, 40.000434, /* 100-104 */
>     41.000345, 42.000274, 43.000218, 44.000173, 45.000137, /* 105-109 */
>     46.000109, 47.000087, 48.000069, 49.000055, 50.000043, /* 110-114 */
>     51.000034, 52.000027, 53.000022, 54.000017, 55.000014, /* 115-119 */
>     56.000011, 57.000009, 58.000007, 59.000005, 60.000004, /* 120-124 */
>     61.000003, 62.000003                                   /* 125-126 */
> };
> 
> 
> 
> 
> static float seqQualIllumina[] =
> {
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*   0-7   */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*   8-15  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  16-23  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  24-31  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  32-39  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  40-47  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  48-55  */
>     0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,               /*  56-63  */
>     0.0,  1.0,  2.0,  3.0,  4.0,  5.0,  6.0,  7.0,   8.0,  9.0,  /*  64-73  */
>     10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0,  18.0, 19.0, /*  74-83  */
>     20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0,  28.0, 29.0, /*  84-93  */
>     30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0,  38.0, 39.0, /*  94-103 */
>     40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0,  48.0, 49.0, /* 104-113 */
>     50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,  58.0, 59.0, /* 114-123 */
>     60.0, 61.0, 62.0                                             /* 124-126 */
> };
137,153d212
<     
< static float seqQualIllumina[] = {
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 0-7 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 8-15 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 16-23 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 24-31 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 32-39 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 40-47 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 48-55 */
<    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, /* 56-63 */
<    0.0,  1.0,  2.0,  3.0,  4.0,  5.0,  6.0,  7.0,   8.0,  9.0, /* 64-73 */
<   10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0,  18.0, 19.0, /* 74-83 */
<   20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0,  28.0, 29.0, /* 84-93 */
<   30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0,  38.0, 39.0, /* 94-103 */
<   40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0,  48.0, 49.0, /* 104-113 */
<   50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,  58.0, 59.0, /* 114-123 */
<   60.0, 61.0, 62.0};	/* 124-126 */
175c234
< ** @attr Read [(AjBool*)] Input function, returns ajTrue on success
---
> ** @attr Read [AjBool function] Input function, returns ajTrue on success
255,268c314,327
<  **
<  ** MSF alignment output individual sequence data
<  **
<  ** @alias SeqSMsfItem
<  ** @alias SeqOMsfItem
<  **
<  ** @attr Name [AjPStr] Sequence name
<  ** @attr Desc [AjPStr] Sequence description
<  ** @attr Len [ajuint] Sequence length
<  ** @attr Check [ajuint] Sequence GCG checksum
<  ** @attr Seq [AjPStr] Sequence
<  ** @attr Weight [float] Weight (default 1.0)
<  ** @attr Padding [char[4]] Padding to alignment boundary
<  ** @@
---
> **
> ** MSF alignment output individual sequence data
> **
> ** @alias SeqSMsfItem
> ** @alias SeqOMsfItem
> **
> ** @attr Name [AjPStr] Sequence name
> ** @attr Desc [AjPStr] Sequence description
> ** @attr Len [ajuint] Sequence length
> ** @attr Check [ajuint] Sequence GCG checksum
> ** @attr Seq [AjPStr] Sequence
> ** @attr Weight [float] Weight (default 1.0)
> ** @attr Padding [char[4]] Padding to alignment boundary
> ** @@
437c496
< }SeqOSelexseq;
---
> } SeqOSelexseq;
539a599,681
> typedef struct SeqSScfHeader
> {
>     ajuint magic_number;
>     ajuint samples;          /* Number of elements in Samples matrix */
>     ajuint samples_offset;   /* Byte offset from start of file */
>     ajuint bases;            /* Number of bases in Bases matrix */
>     ajuint bases_left_clip;  /* OBSOLETE: No. bases in left clip (vector) */
>     ajuint bases_right_clip; /* OBSOLETE: No. bases in right clip (qual) */
>     ajuint bases_offset;     /* Byte offset from start of file */
>     ajuint comments_size;    /* Number of bytes in Comment section */
>     ajuint comments_offset;  /* Byte offset from start of file */
>     char version[4];         /* "version.revision", eg '3' '.' '0' '0' */
>     ajuint sample_size;      /* Size of samples in bytes 1=8bits, 2=16bits*/
>     ajuint code_set;         /* code set used (but ignored!)*/
>     ajuint private_size;     /* No. of bytes of Private data, 0 if none */
>     ajuint private_offset;   /* Byte offset from start of file */
>     ajuint spare[18];        /* Unused */
> } SeqOScfHeader;
> 
> #define SeqPScfHeader SeqOScfHeader*
> 
> 
> 
> 
> typedef struct SeqSScfUncertainty
> {
>     ajuint code;
>     const char* name;
> } SeqOScfUncertainty;
> 
> #define SeqPScfUncertainty SeqOScfUncertainty*
> 
> 
> 
> 
> static SeqOScfUncertainty SeqScfUncertainCodes[] = {
>     {0,       "{A,C,G,T,-}"},
>     {1,       "Staden"},
>     {2,       "IUPAC (NC-IUB)"},
>     {3,       "Pharmacia A.L.F. (NC-IUB)"},
>     {4,       "{A,C,G,T,N}   (ABI 373A)"},
>     {5,       "IBI/Pustell"},
>     {6,       "DNA*"},
>     {7,       "DNASIS"},
>     {8,       "IG/PC-Gene"},
>     {9,       "MicroGenie"},
> };
> 
> 
> 
> 
> /*
>  * Type definition for the sequence data
>  */
> typedef struct SeqSScfBase {
>     ajuint    peak_index;  /* Index into Samples matrix for base posn */
>     unsigned char prob_A;  /* Probability of it being an A */
>     unsigned char prob_C;  /* Probability of it being an C */
>     unsigned char prob_G;  /* Probability of it being an G */
>     unsigned char prob_T;  /* Probability of it being an T */
>     char base;             /* Called base character */
>     char spare[3];         /* Spare */
> } SeqOScfBase;
> 
> #define SeqPScfBase SeqOScfBase*
> 
> 
> 
> 
> typedef struct SeqSScfData
> {
>     SeqOScfHeader header;
> } SeqOScfData;
> 
> 
> 
> 
> 
> #define SeqPScfData SeqOScfData*
> 
> 
> 
> 
554a697
> ** @attr Fpos [ajulong] Start position offset
567a711
>     ajulong Fpos;
576a721,927
> /* @enumstatic SeqEPrefixGenbank **********************************************
> **
> ** Genbank/Refseq/GenPept/Codata record type
> **
> ** @value GB_UNK Unknown prefix
> ** @value GB_AC Accession
> ** @value GB_BASE Base count
> ** @value GB_CC Comment
> ** @value GB_DEF Definition
> ** @value GB_FEAT Feature
> ** @value GB_ID Locus
> ** @value GB_KEY Keywords
> ** @value GB_ORI Origin
> ** @value GB_REF Reference
> ** @value GB_SRC Source organism
> ** @value GB_SQ Sequence
> ** @value GB_VER Version
> ** @value GB_WP GCG header
> ** @value GB_END Final // record
> ** @value GB_MORE Blank continuation
> ** @value GB_MAX Beyond last value
> ******************************************************************************/
> 
> typedef enum
> {
>     GB_UNK,
>     GB_AC,
>     GB_BASE,
>     GB_CC,
>     GB_DEF,
>     GB_FEAT,
>     GB_ID,
>     GB_KEY,
>     GB_ORI,
>     GB_REF,
>     GB_SRC,
>     GB_SQ, 
>     GB_VER,
>     GB_WP,
>     GB_END,
>     GB_MORE,
>     GB_MAX
> } SeqEPrefixGenbank;
> 
> 
> 
> 
> /* @enumstatic SeqEPrefixGenbankMore ******************************************
> **
> ** Genbank/Refseq/GenPept/Codata subrecord type
> **
> ** @value GB_MORE_UNK Unknown prefix
> ** @value GB_MORE_STD Standard (non-prefix) line
> ** @value GB_MORE_AUT AUTHORS
> ** @value GB_MORE_JNL JOURNAL
> ** @value GB_MORE_ORG ORGANISM
> ** @value GB_MORE_TIT TITLE
> ** @value GB_MORE_MORE Blank prefix of at least 10 characters
> ** @value GB_MORE_MAX Beyond last value
> ******************************************************************************/
> 
> typedef enum
> {
>     GB_MORE_UNK,
>     GB_MORE_STD,
>     GB_MORE_AUT,
>     GB_MORE_JNL,
>     GB_MORE_ORG,
>     GB_MORE_TIT,
>     GB_MORE_MORE,
>     GB_MORE_MAX
> } SeqEPrefixGenbankMore;
> 
> 
> 
> 
> /* @enumstatic SeqEPrefixSwiss ************************************************
> **
> ** SwissProt/EMBL 2-character line prefix
> **
> ** @value SWISS_UNK Unknown prefix
> ** @value SWISS_AC Accession
> ** @value SWISS_AS EMBL AS line
> ** @value SWISS_AV Staden experiment AV line
> ** @value SWISS_CC Comment
> ** @value SWISS_CO EMBL contig entry
> ** @value SWISS_DE Description
> ** @value SWISS_DR Database reference
> ** @value SWISS_DT Date
> ** @value SWISS_EX Staden experiment data
> ** @value SWISS_FH EMBL feature header
> ** @value SWISS_FT Feature
> ** @value SWISS_GN Gene name
> ** @value SWISS_ID Identifier line
> ** @value SWISS_IV EMBL IV record
> ** @value SWISS_KW Keyword
> ** @value SWISS_OC Organism classification
> ** @value SWISS_OG Organelle
> ** @value SWISS_OH Organism host
> ** @value SWISS_OS Species
> ** @value SWISS_OX NCBI TaxID
> ** @value SWISS_PE Swissprot evidence
> ** @value SWISS_RA Reference authors
> ** @value SWISS_RC Reference comment
> ** @value SWISS_RG Reference RG
> ** @value SWISS_RL Reference location
> ** @value SWISS_RN Reference number
> ** @value SWISS_RP Reference RP
> ** @value SWISS_RT Reference RT
> ** @value SWISS_RX Reference RX
> ** @value SWISS_SQ Sequence
> ** @value SWISS_SV SeqVersion
> ** @value SWISS_WP GCG header
> ** @value SWISS_XX Spacer
> ** @value SWISS_END Final // record
> ** @value SWISS_MORE Blank continuation (sequence)
> ** @value SWISS_MAX Beyond last value
> ******************************************************************************/
> 
> typedef enum
> {
>     SWISS_UNK,
>     SWISS_AC, SWISS_AS, SWISS_AV,
>     SWISS_CC, SWISS_CO,
>     SWISS_DE, SWISS_DR, SWISS_DT,
>     SWISS_EX,
>     SWISS_FH, SWISS_FT,
>     SWISS_GN,
>     SWISS_ID, SWISS_IV,
>     SWISS_KW,
>     SWISS_OC, SWISS_OG, SWISS_OH, SWISS_OS, SWISS_OX,
>     SWISS_PE,
>     SWISS_RA, SWISS_RC, SWISS_RG, SWISS_RL,
>     SWISS_RN, SWISS_RP, SWISS_RT, SWISS_RX,
>     SWISS_SQ, SWISS_SV,
>     SWISS_WP,
>     SWISS_XX,
>     SWISS_END,
>     SWISS_MORE,
>     SWISS_MAX
> } SeqEPrefixSwiss;
> 
> 
> 
> 
> /* @enumstatic SeqEDesSwiss ***************************************************
> **
> ** SwissProt description codes
> **
> ** @value SWISS_DES_UNK  Unknown code
> ** @value SWISS_DES_ALT  AltName:
> ** @value SWISS_DES_CONT Contains:
> ** @value SWISS_DES_FLG  Flags:
> ** @value SWISS_DES_INC  Includes:
> ** @value SWISS_DES_REC  RecName:
> ** @value SWISS_DES_SUB  SubName:
> ** @value SWISS_DES_MAX  Beyond last value
> ******************************************************************************/
> 
> typedef enum
> {
>     SWISS_DES_UNK,
>     SWISS_DES_ALT, SWISS_DES_CONT, SWISS_DES_FLG,
>     SWISS_DES_INC, SWISS_DES_REC, SWISS_DES_SUB,
>     SWISS_DES_MAX
> } SeqEDesSwiss;
> 
> 
> 
> 
> /* @enumstatic SeqESubSwiss ***************************************************
> **
> ** SwissProt description subcodes
> **
> ** @value SWISS_SUB_UNK     Unknown code
> ** @value SWISS_SUB_ALLER   Allergen=
> ** @value SWISS_SUB_BIOTECH Biotech=
> ** @value SWISS_SUB_CDA     CD_antigen=
> ** @value SWISS_SUB_EC      EC=
> ** @value SWISS_SUB_FULL    Full=
> ** @value SWISS_SUB_INN     INN=
> ** @value SWISS_SUB_SHORT   Short=
> ** @value SWISS_SUB_MAX     Beyond last value
> ******************************************************************************/
> 
> typedef enum
> {
>     SWISS_SUB_UNK,
>     SWISS_SUB_ALLER,
>     SWISS_SUB_BIOTECH,
>     SWISS_SUB_CDA,
>     SWISS_SUB_EC,
>     SWISS_SUB_FULL,
>     SWISS_SUB_INN,
>     SWISS_SUB_SHORT,
>     SWISS_SUB_MAX
> } SeqESubSwiss;
> 
> 
> 
> 
> static SeqEDesSwiss      seqDesSwiss(const AjPStr str);
> static SeqESubSwiss      seqDessubSwiss(AjPStr *Pstr); 
> static SeqEPrefixGenbank seqPrefixGenbank(const AjPStr str); 
> static SeqEPrefixGenbankMore seqPrefixGenbankMore(const AjPStr str); 
> static SeqEPrefixSwiss   seqPrefixSwiss(const AjPStr str); 
> 
582c933,934
< static const AjPStr seqAppendWarn(AjPStr* seq, const AjPStr line);
---
> static const AjPStr seqAppendWarn(AjPStr* seq, const AjPStr line,
>                                   ajuint informat);
584c936
< 				     const AjPStr line);
---
>                                      const AjPStr line);
586c938
< 				    const AjPTable msftable);
---
>                                     const AjPTable msftable);
591c943
< 			     AjPStr* pline, ajuint maxlines, ajuint *len);
---
>                              AjPStr* pline, ajuint maxlines, ajuint *len);
594,595c946,947
< 				AjPStr* pline,
< 				ajuint maxlines, ajuint *len);
---
>                                 AjPStr* pline,
>                                 ajuint maxlines, ajuint *len);
598c950
< 				   const AjPTable msftable);
---
>                                    const AjPTable msftable);
600c952
< 				     const AjPTable msftable);
---
>                                      const AjPTable msftable);
604c956
< 				 const AjPStr usa);
---
>                                    const AjPStr usa);
611,613c963,965
< 				   const AjPTable phytable,
< 				   const AjPStr token,
< 				   ajuint len, ajuint* ilen, AjBool* done);
---
>                                    const AjPTable phytable,
>                                    const AjPStr token,
>                                    ajuint len, ajuint* ilen, AjBool* done);
635c987
< 			     ajuint format);
---
>                              ajuint format);
636a989
> static AjBool     seqReadGde(AjPSeq thys, AjPSeqin seqin);
644a998
> static AjBool     seqReadIguspto(AjPSeq thys, AjPSeqin seqin);
651a1006
> static AjBool     seqReadNibble(AjPSeq thys, AjPSeqin seqin);
661a1017
> static AjBool     seqReadScf(AjPSeq thys, AjPSeqin seqin);
670c1026
< 				 ajuint end);
---
>                                  ajuint end);
673c1029
< 				 AjBool *named, ajuint *sqcnt);
---
>                                  AjBool *named, ajuint *sqcnt);
676,677c1032
< 				    AjPStr *line, AjPFilebuff buff,
< 				    AjBool store, AjPStr *astr);
---
>                                     AjPStr *line, AjPSeqin seqin, AjPStr *astr);
705,709c1060,1064
< static SeqPStockholmdata stockholmdataNew(void);
< static void         stockholmdataDel(SeqPStockholmdata *thys);
< static SeqPSelexdata seqSelexClone(const SeqPSelexdata thys);
< static SeqPSelexdata selexdataNew(void);
< static void         selexdataDel(SeqPSelexdata *thys);
---
>   static SeqPStockholmdata stockholmdataNew(void);
>   static void         stockholmdataDel(SeqPStockholmdata *thys);
>   static SeqPSelexdata seqSelexClone(const SeqPSelexdata thys);
>   static SeqPSelexdata selexdataNew(void);
>   static void         selexdataDel(SeqPSelexdata *thys);
741,816c1096,1198
< /* "Name",      "Obo"      "Description" */
< /*     Alias,   Try,     Nucleotide, Protein   */
< /*     Feature  Gap,     ReadFunction, Multiset, Binary */
<   {"unknown",   "0000000", "Unknown format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadText, AJFALSE, AJFALSE}, /* alias for text */
<   {"gcg",         "0001935", "GCG sequence format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadGcg, AJFALSE, AJFALSE}, /* do 1st,
<                                                            headers mislead */
<   {"gcg8",        "0001935", "GCG old (version 8) sequence format",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadGcg, AJFALSE, AJFALSE}, /* alias for gcg
<                                                            (8.x too) */
<   {"embl",        "0001927", "EMBL entry format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadEmbl, AJFALSE, AJFALSE},
<   {"em",          "0001927", "EMBL entry format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadEmbl, AJFALSE, AJFALSE}, /* alias for embl */
<   {"swiss",       "0001963", "Swissprot entry format",
<        AJFALSE, AJTRUE,  AJFALSE, AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadSwiss, AJFALSE, AJFALSE},
<   {"sw",          "0001963", "Swissprot entry format (alias)",
<        AJTRUE,  AJFALSE, AJFALSE, AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadSwiss, AJFALSE, AJFALSE}, /* alias for swiss */
<   {"swissprot",   "0001963", "Swissprot entry format(alias)",
<        AJTRUE,  AJFALSE, AJFALSE, AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadSwiss, AJFALSE, AJFALSE},
<   {"nbrf",        "0001948", "NBRF/PIR entry format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadNbrf, AJFALSE, AJFALSE}, /* test before NCBI */
<   {"pir",         "0001948", "NBRF/PIR entry format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadNbrf, AJFALSE, AJFALSE}, /* alias for nbrf */
<   {"pdb",         "0001950", "PDB protein databank format ATOM lines",
<        AJFALSE, AJTRUE,  AJFALSE, AJTRUE,
<        AJFALSE, AJFALSE, seqReadPdb, AJFALSE, AJFALSE},
<   {"pdbseq",      "0001953", "PDB protein databank format SEQRES lines",
<        AJFALSE, AJFALSE, AJFALSE, AJTRUE,
<        AJFALSE, AJFALSE, seqReadPdbseq, AJFALSE, AJFALSE},
<   {"pdbnuc",      "0001951", "PDB protein databank format nucleotide ATOM lines",
<        AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadPdbnuc, AJFALSE, AJFALSE},
<   {"pdbnucseq",   "0001952", "PDB protein databank format nucleotide SEQRES lines",
<        AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadPdbnucseq, AJFALSE, AJFALSE},
<   {"fasta",       "0001929", "FASTA format including NCBI-style IDs",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadNcbi, AJFALSE, AJFALSE}, /* alias for ncbi,
< 						    preferred name */
<   {"ncbi",        "0001929", "FASTA format including NCBI-style IDs (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadNcbi, AJFALSE, AJFALSE}, /* test before
<                                                             pearson */
<   {"gifasta",     "0001940", "FASTA format including NCBI-style GIs (alias)",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadGifasta, AJFALSE, AJFALSE}, /* NCBI with GI
<                                                                as ID*/
<   {"pearson",     "0001954", "Plain old fasta format with IDs not parsed further",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadFasta, AJFALSE, AJFALSE}, /* plain fasta - off
<                                                              by default, can
<                                                              read bad files */
<   {"fastq",       "0001930", "FASTQ short read format ignoring quality scores",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadFastq, AJFALSE, AJFALSE},
<   {"fastq-sanger", "0001932", "FASTQ short read format with phred quality",
<        AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadFastqSanger, AJFALSE, AJFALSE},
<   {"fastq-illumina","0001931", "FASTQ Illumina 1.3 short read format",
<        AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadFastqIllumina, AJFALSE, AJFALSE},
<   {"fastq-solexa",  "0001933", "FASTQ Solexa/Illumina 1.0 short read format",
<        AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
<        AJFALSE, AJFALSE, seqReadFastqSolexa, AJFALSE, AJFALSE},
---
> /*   "Name",
>      "Obo"      "Description" */
> /*   Alias,   Try,     Nucleotide, Protein   */
> /*   Feature  Gap,     ReadFunction,  Multiset, Binary */
>     {"unknown",
>      "0000", "Unknown format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadText, AJFALSE, AJFALSE}, /* alias for text */
>     {"gcg",
>      "1935", "GCG sequence format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadGcg, AJFALSE, AJFALSE}, /* do 1st,
>                                                          headers mislead */
>     {"gcg8",
>      "1935", "GCG old (version 8) sequence format",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadGcg, AJFALSE, AJFALSE}, /* alias for gcg
>                                                          (8.x too) */
>     {"embl",
>      "1927", "EMBL format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadEmbl, AJFALSE, AJFALSE},
>     {"em",
>      "1927", "EMBL format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadEmbl, AJFALSE, AJFALSE}, /* alias for embl */
>     {"swiss",
>      "1963", "Swissprot entry format",
>      AJFALSE, AJTRUE,  AJFALSE, AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadSwiss, AJFALSE, AJFALSE},
>     {"sw",
>      "1963", "Swissprot entry format (alias)",
>      AJTRUE,  AJFALSE, AJFALSE, AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadSwiss, AJFALSE, AJFALSE}, /* alias for swiss */
>     {"swissprot",
>      "1963", "Swissprot entry format (alias)",
>      AJTRUE,  AJFALSE, AJFALSE, AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadSwiss, AJFALSE, AJFALSE},
>     {"uniprot",
>      "2188", "Swissprot entry format (alias)",
>      AJTRUE,  AJFALSE, AJFALSE, AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadSwiss, AJFALSE, AJFALSE},
>     {"nbrf",
>      "1948", "NBRF/PIR entry format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadNbrf, AJFALSE, AJFALSE}, /* test before NCBI */
>     {"pir",
>      "1948", "NBRF/PIR entry format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadNbrf, AJFALSE, AJFALSE}, /* alias for nbrf */
>     {"pdb",
>      "1950", "PDB protein databank format ATOM lines",
>      AJFALSE, AJTRUE,  AJFALSE, AJTRUE,
>      AJFALSE, AJFALSE, &seqReadPdb, AJFALSE, AJFALSE},
>     {"pdbseq",
>      "1953", "PDB protein databank format SEQRES lines",
>      AJFALSE, AJFALSE, AJFALSE, AJTRUE,
>      AJFALSE, AJFALSE, &seqReadPdbseq, AJFALSE, AJFALSE},
>     {"pdbnuc",
>      "1951", "PDB protein databank format nucleotide ATOM lines",
>      AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadPdbnuc, AJFALSE, AJFALSE},
>     {"pdbnucseq",
>      "1952", "PDB protein databank format nucleotide SEQRES lines",
>      AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadPdbnucseq, AJFALSE, AJFALSE},
>     {"fasta",
>      "1929", "FASTA format including NCBI-style IDs",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadNcbi, AJFALSE, AJFALSE}, /* alias for ncbi,
>                                                           preferred name */
>     {"ncbi",
>      "1929", "FASTA format including NCBI-style IDs (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadNcbi, AJFALSE, AJFALSE}, /* test before
>                                                           pearson */
>     {"gifasta",
>      "1940", "FASTA format including NCBI-style GIs (alias)",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadGifasta, AJFALSE, AJFALSE}, /* NCBI with GI
>                                                              as ID*/
>     {"pearson",
>      "1954", "Plain old fasta format with IDs not parsed further",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadFasta, AJFALSE, AJFALSE}, /* plain fasta - off
>                                                            by default, can
>                                                            read bad files */
>     {"fastq",
>      "1930", "FASTQ short read format ignoring quality scores",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadFastq, AJFALSE, AJFALSE},
>     {"fastq-sanger",
>      "1932", "FASTQ short read format with phred quality",
>      AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadFastqSanger, AJFALSE, AJFALSE},
>     {"fastq-illumina",
>      "1931", "FASTQ Illumina 1.3 short read format",
>      AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadFastqIllumina, AJFALSE, AJFALSE},
>     {"fastq-solexa",
>      "1933", "FASTQ Solexa/Illumina 1.0 short read format",
>      AJFALSE, AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadFastqSolexa, AJFALSE, AJFALSE},
822,969c1204,1418
<   {"sam",         "0002573", "Sequence Alignment/Map (SAM) format", /* biomart also tsv */
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE, seqReadSam, AJFALSE, AJFALSE},
<   {"genbank",     "0001936", "Genbank entry format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadGenbank, AJFALSE, AJFALSE},
<   {"gb",          "0001936", "Genbank entry format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadGenbank, AJFALSE, AJFALSE}, /* alias for
<                                                                genbank */
<   {"ddbj",        "0001936", "Genbank/DDBJ entry format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadGenbank, AJFALSE, AJFALSE}, /* alias for
<                                                                genbank */
<   {"refseq",      "0000000", "Refseq entry format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
<        AJTRUE,  AJTRUE,  seqReadRefseq, AJFALSE, AJFALSE}, /* alias for
<                                                               genbank */
<   {"refseqp",     "0001958", "Refseq protein entry format",
<        AJFALSE, AJFALSE, AJFALSE, AJTRUE,       /* genbank format proteins */
<        AJTRUE,  AJTRUE,  seqReadRefseqp, AJFALSE, AJFALSE},
<   {"genpept",     "0001937", "Refseq protein entry format (alias)",
<        AJFALSE, AJFALSE, AJFALSE, AJTRUE,
<        AJFALSE, AJTRUE,  seqReadGenpept, AJFALSE, AJFALSE},
<   {"codata",      "0001925", "Codata entry format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadCodata, AJFALSE, AJFALSE},
<   {"strider",     "0001962", "DNA strider output format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE,  seqReadStrider, AJFALSE, AJFALSE},
<   {"clustal",     "0001924", "Clustalw output format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadClustal, AJFALSE, AJFALSE},
<   {"aln",         "0001924", "Clustalw output format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadClustal, AJFALSE, AJFALSE}, /* alias for
<                                                                clustal */
<   {"phylip",      "0001955", "Phylip interleaved and non-interleaved formats",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadPhylip, AJTRUE, AJFALSE},
<   {"phylipnon",   "0001956", "Phylip non-interleaved format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadPhylipnon, AJTRUE, AJFALSE}, /* tried by
<                                                                 phylip */
<   {"ace",         "0003001", "ACE sequence format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE,  seqReadAce, AJFALSE, AJFALSE},
<   {"consed",      "0003001", "ACE sequence format",
<        AJTRUE,  AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE,  seqReadAce, AJFALSE, AJFALSE}, /* alias for ace */
<   {"acedb",       "0001923", "ACEDB sequence format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadAcedb, AJFALSE, AJFALSE},
<   {"dbid",        "0001926", "Fasta format variant with database name before ID",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadDbId, AJFALSE, AJFALSE}, /* odd fasta with id as
<                                                             second token */
<   {"msf",         "0001947", "GCG MSF (multiple sequence file) file format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadMsf, AJFALSE, AJFALSE},
<   {"hennig86",    "0001941", "Hennig86 output format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadHennig86, AJFALSE, AJFALSE},
<   {"jackknifer",  "0001944", "Jackknifer interleaved and non-interleaved formats",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadJackknifer, AJFALSE, AJFALSE},
<   {"nexus",       "0001949", "Nexus/paup interleaved format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadNexus, AJFALSE, AJFALSE},
<   {"paup",        "0001949", "Nexus/paup interleaved format (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadNexus, AJFALSE, AJFALSE}, /* alias for nexus */
<   {"treecon",     "0001965", "Treecon output format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadTreecon, AJFALSE, AJFALSE},
<   {"mega",        "0001946 0001971", "Mega interleaved and non-interleaved formats",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadMega, AJFALSE, AJFALSE},
<   {"igstrict",    "0001943", "Intelligenetics sequence format strict parser",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadIgstrict, AJFALSE, AJFALSE},
<   {"ig",          "0001942", "Intelligenetics sequence format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadIg, AJFALSE, AJFALSE}, /* can read almost
<                                                           anything */
<   {"staden",      "0001960", "Old staden package sequence format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadStaden, AJFALSE, AJFALSE},/* original staden
<                                                              format */
<   {"textonly",    "0001964", "Plain text",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadText, AJFALSE, AJFALSE},/* can read almost
<                                                            anything */
<   {"plain",       "0001964", "Plain text (alias)",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadText, AJFALSE, AJFALSE}, /* alias for text */
<   {"asis",        "0001964", "Data as commandline string",
<        AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadText, AJFALSE, AJFALSE}, /* one line only */
<   {"gff2",        "0001938",  "GFF feature file with sequence in the header",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadGff2, AJFALSE, AJFALSE},
<   {"gff3",        "0001939",  "GFF3 feature file with sequence",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadGff3, AJFALSE, AJFALSE},
<   {"gff",        "0001939",  "GFF3 feature file with sequence",
<        AJTRUE,  AJFALSE,  AJTRUE,  AJTRUE,
<        AJTRUE,  AJTRUE,  seqReadGff3, AJFALSE, AJFALSE},
<   {"stockholm",  "0001961",  "Stockholm (pfam) format",
<        AJFALSE, AJTRUE,  AJFALSE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadStockholm, AJFALSE, AJFALSE},
<   {"pfam",       "0001961",  "Stockholm (pfam) format (alias)",
<        AJTRUE,  AJTRUE,  AJFALSE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadStockholm, AJFALSE, AJFALSE},
<   {"selex",      "0001959",  "Selex format",                /* can read almost anything */
<        AJFALSE, AJFALSE, AJTRUE,   AJTRUE,
<        AJFALSE, AJTRUE,  seqReadSelex, AJFALSE, AJFALSE},
<   {"fitch",      "0001934",  "Fitch program format",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadFitch, AJFALSE, AJFALSE},
<   {"biomart",    "0000000", "Biomart tab-delimited results", /* may clash with SAM */
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadBiomart, AJFALSE, AJFALSE},
<   {"mase",        "0001945", "Mase program format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJFALSE, AJTRUE,  seqReadMase, AJFALSE, AJFALSE}, /* like ig - off by
<                                                             default */
<   {"experiment",  "0001960", "Staden experiment file",
<        AJFALSE, AJTRUE, AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE,  seqReadExperiment, AJFALSE, AJFALSE},
<   {"raw",         "0001957", "Raw sequence with no non-sequence characters",
<        AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
<        AJFALSE, AJFALSE, seqReadRaw, AJFALSE, AJTRUE}, /* OK - only sequence
<                                                           chars allowed - but
<                                                           binary so not piped */
<   {"abi",         "0001628", "ABI trace file",
<        AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE,  seqReadAbi, AJFALSE, AJTRUE},
<   {"bam",         "0002572", "Binary Sequence Alignment/Map (BAM) format",
<        AJFALSE, AJTRUE, AJTRUE,  AJFALSE,
<        AJFALSE, AJTRUE, seqReadBam, AJFALSE, AJTRUE},
<   {"ensembl",     "0000000", "Ensembl SQL format",
<        AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<        AJTRUE, AJTRUE, seqReadEnsembl, AJFALSE, AJFALSE},
<   {"das",         "0001967", "DAS sequence format",
<         AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
<         AJTRUE, AJTRUE, seqReadDAS, AJFALSE, AJFALSE},
<   {NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, NULL, 0, 0}
---
>     {"sam",
>      "2573", "Sequence Alignment/Map (SAM) format", /* biomart also tsv */
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE, &seqReadSam, AJFALSE, AJFALSE},
>     {"genbank",
>      "1936", "Genbank entry format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadGenbank, AJFALSE, AJFALSE},
>     {"gb",
>      "1936", "Genbank entry format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadGenbank, AJFALSE, AJFALSE}, /* alias for
>                                                              genbank */
>     {"ddbj",
>      "1936", "Genbank/DDBJ entry format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadGenbank, AJFALSE, AJFALSE}, /* alias for
>                                                              genbank */
>     {"refseq",
>      "1936", "Refseq entry format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
>      AJTRUE,  AJTRUE,  &seqReadRefseq, AJFALSE, AJFALSE}, /* alias for
>                                                             genbank */
>     {"refseqp",
>      "1958", "Refseq protein entry format",
>      AJFALSE, AJFALSE, AJFALSE, AJTRUE,       /* genbank format proteins */
>      AJTRUE,  AJTRUE,  &seqReadRefseqp, AJFALSE, AJFALSE},
>     {"genpept",     "1937", "Refseq protein entry format (alias)",
>      AJFALSE, AJFALSE, AJFALSE, AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadGenpept, AJFALSE, AJFALSE},
>     {"codata",
>      "1925", "Codata entry format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadCodata, AJFALSE, AJFALSE},
>     {"strider",
>      "1962", "DNA strider output format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE,  &seqReadStrider, AJFALSE, AJFALSE},
>     {"clustal",
>      "1924", "Clustalw output format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadClustal, AJFALSE, AJFALSE},
>     {"aln",
>      "1924", "Clustalw output format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadClustal, AJFALSE, AJFALSE}, /* alias for
>                                                              clustal */
>     {"phylip",
>      "1955", "Phylip interleaved and non-interleaved formats",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadPhylip, AJTRUE, AJFALSE},
>     {"phylipnon",
>      "1956", "Phylip non-interleaved format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadPhylipnon, AJTRUE, AJFALSE}, /* tried by
>                                                               phylip */
>     {"ace",
>      "3001", "ACE sequence format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE,  &seqReadAce, AJFALSE, AJFALSE},
>     {"consed",
>      "3001", "ACE sequence format",
>      AJTRUE,  AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE,  &seqReadAce, AJFALSE, AJFALSE}, /* alias for ace */
>     {"acedb",
>      "1923", "ACEDB sequence format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadAcedb, AJFALSE, AJFALSE},
>     {"dbid",
>      "1926", "Fasta format variant with database name before ID",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadDbId, AJFALSE, AJFALSE}, /* odd fasta with id as
>                                                           second token */
>     {"msf",
>      "1947", "GCG MSF (multiple sequence file) file format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadMsf, AJFALSE, AJFALSE},
>     {"hennig86",
>      "1941", "Hennig86 output format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadHennig86, AJFALSE, AJFALSE},
>     {"jackknifer",
>      "1944", "Jackknifer interleaved and non-interleaved formats",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadJackknifer, AJFALSE, AJFALSE},
>     {"nexus",
>      "1949", "Nexus/paup interleaved format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadNexus, AJFALSE, AJFALSE},
>     {"paup",
>      "1949", "Nexus/paup interleaved format (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadNexus, AJFALSE, AJFALSE}, /* alias for nexus */
>     {"treecon",
>      "1965", "Treecon output format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadTreecon, AJFALSE, AJFALSE},
>     {"mega",
>      "1946 1971", "Mega interleaved and non-interleaved formats",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadMega, AJFALSE, AJFALSE},
>     {"igstrict",
>      "1943", "Intelligenetics sequence format strict parser",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadIgstrict, AJFALSE, AJFALSE},
>     {"iguspto",
>      "1942", "US patent office multi-line Intelligenetics sequence format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadIguspto, AJFALSE, AJFALSE},
>     {"ig",
>      "1942", "Intelligenetics sequence format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadIg, AJFALSE, AJFALSE}, /* can read almost
>                                                         anything */
>     {"staden",
>      "1960", "Old staden package sequence format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadStaden, AJFALSE, AJFALSE},/* original staden
>                                                            format */
>     {"textonly",
>      "1964", "Plain text",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadText, AJFALSE, AJFALSE},/* can read almost
>                                                          anything */
>     {"plain",
>      "1964", "Plain text (alias)",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadText, AJFALSE, AJFALSE}, /* alias for text */
>     {"asis",
>      "1964", "Data as commandline string",
>      AJTRUE,  AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadText, AJFALSE, AJFALSE}, /* one line only */
>     {"gff2",
>      "1938",  "GFF feature file with sequence in the header",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadGff2, AJFALSE, AJFALSE},
>     {"gff3",
>      "1939",  "GFF3 feature file with sequence",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadGff3, AJFALSE, AJFALSE},
>     {"gff",
>      "1939",  "GFF3 feature file with sequence",
>      AJTRUE,  AJFALSE,  AJTRUE,  AJTRUE,
>      AJTRUE,  AJTRUE,  &seqReadGff3, AJFALSE, AJFALSE},
>     {"stockholm",
>      "1961",  "Stockholm (pfam) format",
>      AJFALSE, AJTRUE,  AJFALSE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadStockholm, AJFALSE, AJFALSE},
>     {"pfam",
>      "1961",  "Stockholm (pfam) format (alias)",
>      AJTRUE,  AJTRUE,  AJFALSE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadStockholm, AJFALSE, AJFALSE},
>     {"selex",
>      "1959",  "Selex format",                /* can read almost anything */
>      AJFALSE, AJFALSE, AJTRUE,   AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadSelex, AJFALSE, AJFALSE},
>     {"fitch",
>      "1934",  "Fitch program format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadFitch, AJFALSE, AJFALSE},
>     {"biomart",
>      "0000", "Biomart tab-delimited results", /* may clash with SAM */
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadBiomart, AJFALSE, AJFALSE},
>     {"mase",
>      "1945", "Mase program format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadMase, AJFALSE, AJFALSE}, /* like ig - off by
>                                                           default */
>     {"experiment",
>      "1928", "Staden experiment file",
>      AJFALSE, AJTRUE, AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE,  &seqReadExperiment, AJFALSE, AJFALSE},
>     {"gde",
>      "0000", "GDE program format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJTRUE,  &seqReadGde, AJFALSE, AJFALSE},
>      {"raw",
>      "1957", "Raw sequence with no non-sequence characters",
>      AJFALSE, AJTRUE,  AJTRUE,  AJTRUE,
>      AJFALSE, AJFALSE, &seqReadRaw, AJFALSE, AJTRUE}, /* OK - only sequence
>                                                         chars allowed - but
>                                                         binary so not piped */
>     {"nibble",
>      "0000", "Nibble format",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadNibble, AJFALSE, AJTRUE},
>     {"nib",
>      "0000", "Nibble format",
>      AJTRUE,  AJFALSE, AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadNibble, AJFALSE, AJTRUE},
>     {"abi",
>      "1628", "ABI trace file",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJFALSE, &seqReadAbi, AJFALSE, AJTRUE},
>     {"bam",
>      "2572", "Binary Sequence Alignment/Map (BAM) format",
>      AJFALSE, AJTRUE, AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE, &seqReadBam, AJFALSE, AJTRUE},
>     {"ensembl",
>      "0000", "Ensembl SQL format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJTRUE, AJTRUE, &seqReadEnsembl, AJFALSE, AJFALSE},
>     {"das",
>      "1967", "DAS sequence format",
>      AJFALSE, AJFALSE, AJTRUE,  AJTRUE,
>      AJTRUE, AJTRUE, &seqReadDAS, AJFALSE, AJFALSE},
>     {"scf",
>      "2057", "SCF trace file",
>      AJFALSE, AJTRUE,  AJTRUE,  AJFALSE,
>      AJFALSE, AJTRUE,  &seqReadScf, AJFALSE, AJTRUE},
>     {NULL,
>      NULL, NULL,
>      0, 0, 0, 0,
>      0, 0, NULL, 0, 0}
999a1449,1450
> **
> ** @release 1.0.0
1041a1493,1538
> /* @func ajSeqinNewQueryC ******************************************************
> **
> ** Creates a new sequence input object.
> **
> ** @param [r] qrytxt [const char*] Query string
> ** @return [AjPSeqin] New sequence input object.
> ** @category new [AjPSeqin] Default constructor
> **
> ** @release 1.0.0
> ** @@
> ******************************************************************************/
> 
> AjPSeqin ajSeqinNewQueryC(const char* qrytxt)
> {
>     AjPSeqin thys = ajSeqinNew();
> 
>     ajStrAssignC(&thys->Input->Qry, qrytxt);
>     return thys;
> }
> 
> 
> 
> 
> /* @func ajSeqinNewQueryS ******************************************************
> **
> ** Creates a new sequence input object.
> **
> ** @param [r] qry [const AjPStr] Query string
> ** @return [AjPSeqin] New sequence input object.
> ** @category new [AjPSeqin] Default constructor
> **
> ** @release 1.0.0
> ** @@
> ******************************************************************************/
> 
> AjPSeqin ajSeqinNewQueryS(const AjPStr qry)
> {
>     AjPSeqin thys = ajSeqinNew();
> 
>     ajStrAssignS(&thys->Input->Qry, qry);
>     return thys;
> }
> 
> 
> 
> 
1065a1563,1564
> **
> ** @release 1.0.0
1105,1108c1604,1607
< 	ajListPop(thys->Usalist, (void**) &node);
< 	ajStrDel(&node->Usa);
< 	ajStrDel(&node->Formatstr);
< 	AJFREE(node);
---
>         ajListPop(thys->Usalist, (void**) &node);
>         ajStrDel(&node->Usa);
>         ajStrDel(&node->Formatstr);
>         AJFREE(node);
1114c1613
< 	ajFeattableDel(&thys->Fttable);
---
>         ajFeattableDel(&thys->Fttable);
1116c1615
<     if(thys->Ftquery)		/* this deletes filebuff stuff above anyway */
---
>     if(thys->Ftquery)           /* this deletes filebuff stuff above anyway */
1152a1652,1653
> **
> ** @release 1.0.0
1161c1662
< 	thys = *pthis = ajSeqinNew();
---
>         thys = *pthis = ajSeqinNew();
1164,1165c1665,1666
< 	thys = *pthis;
< 	ajSeqinClear(thys);
---
>         thys = *pthis;
>         ajSeqinClear(thys);
1181a1683,1684
> **
> ** @release 1.0.0
1200a1704,1705
> **
> ** @release 1.0.0
1222a1728,1729
> **
> ** @release 1.0.0
1229c1736
< 	seqin->Begin = ibegin;
---
>         seqin->Begin = ibegin;
1232c1739
< 	seqin->End = iend;
---
>         seqin->End = iend;
1290a1798,1799
> **
> ** @release 1.0.0
1303,1308c1812,1817
< 	/* we need a copy of the formatlist */
< 	if(ajNamGetValueC("format", &tmpformat))
< 	{
< 	    seqSetInFormat(tmpformat);
< 	    ajDebug("seqSetInFormat '%S' from EMBOSS_FORMAT\n", tmpformat);
< 	}
---
>         /* we need a copy of the formatlist */
>         if(ajNamGetValueC("format", &tmpformat))
>         {
>             seqSetInFormat(tmpformat);
>             ajDebug("seqSetInFormat '%S' from EMBOSS_FORMAT\n", tmpformat);
>         }
1310,1311c1819,1820
< 	ajStrDel(&tmpformat);
< 	seqinFormatIsset = ajTrue;
---
>         ajStrDel(&tmpformat);
>         seqinFormatIsset = ajTrue;
1316,1319c1825,1831
< 	/* First call. No file open yet ... */
< 	if(!seqinUsaProcess(seqin, thys) /* ... so process the USA */
< 	   && !ajListGetLength(seqin->Usalist))  /* not list with bad 1st item */
< 	    return ajFalse; /* if this fails, we read no sequence at all */
---
>         /* First call. No file open yet ... */
>         if(!seqinUsaProcess(seqin, thys) /* ... so process the USA */
>            && !ajListGetLength(seqin->Usalist))  /* not list with bad 1st item */
>             return ajFalse; /* if this fails, we read no sequence at all */
> 
>         if(ajListGetLength(seqin->Usalist))
>             listdata = ajTrue;
1321,1322c1833
< 	if(ajListGetLength(seqin->Usalist))
< 	    listdata = ajTrue;
---
>         ajTextinClearNewfile(seqin->Input);
1328c1839
<     if(ret)			/* clone any specified DB or entryname */
---
>     if(ret)                     /* clone any specified DB or entryname */
1330,1342c1841,1846
< 	if (ajStrGetLen(seqin->Input->Db))
< 	{
< 	    ajDebug("++ajSeqallRead set db: '%S' => '%S'\n",
< 		    seqin->Input->Db, thys->Db);
< 	    ajStrAssignS(&thys->Db, seqin->Input->Db);
< 	}
< 
< 	if (ajStrGetLen(seqin->Entryname))
< 	{
< 	    ajDebug("++ajSeqallRead set entryname: '%S' => '%S'\n",
< 		    seqin->Entryname, thys->Entryname);
< 	    ajStrAssignS(&thys->Entryname, seqin->Entryname);
< 	}
---
>         if (ajStrGetLen(seqin->Input->Db))
>         {
>             ajDebug("++ajSeqallRead set db: '%S' => '%S'\n",
>                     seqin->Input->Db, thys->Db);
>             ajStrAssignS(&thys->Db, seqin->Input->Db);
>         }
1344,1345c1848,1856
< 	if(!ajStrGetLen(thys->Type)) /* make sure the type is set */
< 	    ajSeqType(thys);
---
>         if (ajStrGetLen(seqin->Entryname))
>         {
>             ajDebug("++ajSeqallRead set entryname: '%S' => '%S'\n",
>                     seqin->Entryname, thys->Entryname);
>             ajStrAssignS(&thys->Entryname, seqin->Entryname);
>         }
> 
>         if(!ajStrGetLen(thys->Type)) /* make sure the type is set */
>             ajSeqType(thys);
1350c1861
< 	/* Failed, but we have a list still - keep trying it */
---
>         /* Failed, but we have a list still - keep trying it */
1354,1364c1865,1877
< 	ajListPop(seqin->Usalist, (void**) &node);
< 	ajDebug("++try again: pop from list '%S'\n", node->Usa);
< 	ajSeqinUsa(&seqin, node->Usa);
< 	ajDebug("++SAVE (AGAIN) SEQIN '%S' %d..%d(%b) '%S' %d\n",
< 		seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
< 		seqin->Input->Formatstr, seqin->Input->Format);
< 	seqUsaRestore(seqin, node);
< 
< 	ajStrDel(&node->Usa);
< 	ajStrDel(&node->Formatstr);
< 	AJFREE(node);
---
>         ajListPop(seqin->Usalist, (void**) &node);
>         ajDebug("++try again: pop from list '%S'\n", node->Usa);
>         ajSeqinUsa(&seqin, node->Usa);
>         ajDebug("++SAVE (AGAIN) SEQIN '%S' %d..%d(%b) '%S' %d\n",
>                 seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
>                 seqin->Input->Formatstr, seqin->Input->Format);
>         seqUsaRestore(seqin, node);
> 
>         ajStrDel(&node->Usa);
>         ajStrDel(&node->Formatstr);
>         AJFREE(node);
> 
>         /* must exit if this fails ... for bad list USAs */
1366c1879,1880
< 	/* must exit if this fails ... for bad list USAs */
---
>         if(!seqinUsaProcess(seqin, thys))
>             continue;
1368,1369c1882
< 	if(!seqinUsaProcess(seqin, thys))
< 	    continue;
---
>         ajTextinClearNewfile(seqin->Input);
1371c1884
<  	ret = seqRead(thys, seqin);
---
>         ret = seqRead(thys, seqin);
1376,1377c1889,1890
<       if(listdata)
< 	ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
---
>         if(listdata)
>             ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
1379c1892
<       return ajFalse;
---
>         return ajFalse;
1383c1896
< 	ajSeqinClearPos(seqin);
---
>         ajSeqinClearPos(seqin);
1399a1913,1914
> **
> ** @release 1.13.0
1420c1935
< 	ajSeqallDel(&seqall);
---
>         ajSeqallDel(&seqall);
1422c1937
< 	return NULL;
---
>         return NULL;
1443a1959,1960
> **
> ** @release 1.0.0
1451c1968
< 	seqall->Count = 1;
---
>         seqall->Count = 1;
1453,1456c1970,1973
< 	if(seqall->Rev)
< 	    ajSeqSetRangeRev(seqall->Seq, seqall->Begin, seqall->End);
< 	else
< 	    ajSeqSetRange(seqall->Seq, seqall->Begin, seqall->End);
---
>         if(seqall->Rev)
>             ajSeqSetRangeRev(seqall->Seq, seqall->Begin, seqall->End);
>         else
>             ajSeqSetRange(seqall->Seq, seqall->Begin, seqall->End);
1458,1461c1975,1978
< 	/*
< 	seqall->Seq->Begin = seqall->Begin;
< 	seqall->Seq->End   = seqall->End;
< 	*/
---
>         /*
>           seqall->Seq->Begin = seqall->Begin;
>           seqall->Seq->End   = seqall->End;
>         */
1463,1464c1980,1981
< 	seqall->Totseqs++;
< 	seqall->Totlength += ajSeqGetLenTrimmed(seqall->Seq);;
---
>         seqall->Totseqs++;
>         seqall->Totlength += ajSeqGetLenTrimmed(seqall->Seq);;
1466,1467c1983,1984
< 	*retseq = seqall->Seq;
< 	seqall->Returned = ajTrue;
---
>         *retseq = seqall->Seq;
>         seqall->Returned = ajTrue;
1469c1986
< 	return ajTrue;
---
>         return ajTrue;
1475c1992
< 	seqall->Count++;
---
>         seqall->Count++;
1477,1480c1994,1997
< 	if(seqall->Rev)
< 	    ajSeqSetRangeRev(seqall->Seq, seqall->Begin, seqall->End);
< 	else
< 	    ajSeqSetRange(seqall->Seq, seqall->Begin, seqall->End);
---
>         if(seqall->Rev)
>             ajSeqSetRangeRev(seqall->Seq, seqall->Begin, seqall->End);
>         else
>             ajSeqSetRange(seqall->Seq, seqall->Begin, seqall->End);
1482,1483c1999,2000
< 	seqall->Totseqs++;
< 	seqall->Totlength += ajSeqGetLenTrimmed(seqall->Seq);;
---
>         seqall->Totseqs++;
>         seqall->Totlength += ajSeqGetLenTrimmed(seqall->Seq);;
1485,1486c2002,2003
< 	*retseq = seqall->Seq;
< 	seqall->Returned = ajTrue;
---
>         *retseq = seqall->Seq;
>         seqall->Returned = ajTrue;
1488c2005
< 	ajDebug("ajSeqallNext success\n");
---
>         ajDebug("ajSeqallNext success\n");
1490c2007
< 	return ajTrue;
---
>         return ajTrue;
1509a2027,2028
> **
> ** @release 2.9.0
1532a2052,2053
> **
> ** @release 1.0.0
1566c2087
< 	ajFeattableDel(&thys->Fttable);
---
>         ajFeattableDel(&thys->Fttable);
1569c2090
<     if(thys->Ftquery)  		/* this clears filebuff stuff above anyway */
---
>     if(thys->Ftquery)           /* this clears filebuff stuff above anyway */
1636a2158,2159
> **
> ** @release 1.0.0
1649,1654c2172,2177
< 	/* we need a copy of the formatlist */
< 	if(ajNamGetValueC("format", &tmpformat))
< 	{
< 	    seqSetInFormat(tmpformat);
< 	    ajDebug("seqSetInFormat '%S' from EMBOSS_FORMAT\n", tmpformat);
< 	}
---
>         /* we need a copy of the formatlist */
>         if(ajNamGetValueC("format", &tmpformat))
>         {
>             seqSetInFormat(tmpformat);
>             ajDebug("seqSetInFormat '%S' from EMBOSS_FORMAT\n", tmpformat);
>         }
1656,1657c2179,2180
< 	ajStrDel(&tmpformat);
< 	seqinFormatIsset = ajTrue;
---
>         ajStrDel(&tmpformat);
>         seqinFormatIsset = ajTrue;
1662,1667c2185,2190
< 	/* (a) if file still open, keep reading */
< 	ajDebug("ajSeqRead: input file '%F' still there, try again\n",
< 		seqin->Input->Filebuff->File);
< 	ret = seqRead(thys, seqin);
< 	ajDebug("ajSeqRead: open buffer  usa: '%S' returns: %B\n",
< 		seqin->Input->Qry, ret);
---
>         /* (a) if file still open, keep reading */
>         ajDebug("ajSeqRead: input file '%F' still there, try again\n",
>                 seqin->Input->Filebuff->File);
>         ret = seqRead(thys, seqin);
>         ajDebug("ajSeqRead: open buffer  usa: '%S' returns: %B\n",
>                 seqin->Input->Qry, ret);
1671,1686c2194,2209
< 	/* (b) if we have a list, try the next USA in the list */
< 	if(ajListGetLength(seqin->Usalist))
< 	{
< 	    listdata = ajTrue;
< 	    ajListPop(seqin->Usalist, (void**) &node);
< 
< 	    ajDebug("++pop from list '%S'\n", node->Usa);
< 	    ajSeqinUsa(&seqin, node->Usa);
< 	    ajDebug("++SAVE SEQIN '%S' %d..%d(%b) '%S' %d\n",
< 		    seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
< 		    seqin->Input->Formatstr, seqin->Input->Format);
< 	    seqUsaRestore(seqin, node);
< 
< 	    ajStrDel(&node->Usa);
< 	    ajStrDel(&node->Formatstr);
< 	    AJFREE(node);
---
>         /* (b) if we have a list, try the next USA in the list */
>         if(ajListGetLength(seqin->Usalist))
>         {
>             listdata = ajTrue;
>             ajListPop(seqin->Usalist, (void**) &node);
> 
>             ajDebug("++pop from list '%S'\n", node->Usa);
>             ajSeqinUsa(&seqin, node->Usa);
>             ajDebug("++SAVE SEQIN '%S' %d..%d(%b) '%S' %d\n",
>                     seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
>                     seqin->Input->Formatstr, seqin->Input->Format);
>             seqUsaRestore(seqin, node);
> 
>             ajStrDel(&node->Usa);
>             ajStrDel(&node->Formatstr);
>             AJFREE(node);
1688c2211
< 	    ajDebug("ajSeqRead: open list, try '%S'\n", seqin->Input->Qry);
---
>             ajDebug("ajSeqRead: open list, try '%S'\n", seqin->Input->Qry);
1690c2213
< 	    if(!seqinUsaProcess(seqin, thys) &&
---
>             if(!seqinUsaProcess(seqin, thys) &&
1692c2215,2217
< 		return ajFalse;
---
>                 return ajFalse;
> 
>             ajTextinClearNewfile(seqin->Input);
1694,1700c2219,2225
< 	    ret = seqRead(thys, seqin);
< 	    ajDebug("ajSeqRead: list usa: '%S' returns: %B\n",
< 		    seqin->Input->Qry, ret);
< 	}
< 	else
< 	{
< 	    ajDebug("ajSeqRead: no file yet - test USA '%S'\n",
---
>             ret = seqRead(thys, seqin);
>             ajDebug("ajSeqRead: list usa: '%S' returns: %B\n",
>                     seqin->Input->Qry, ret);
>         }
>         else
>         {
>             ajDebug("ajSeqRead: no file yet - test USA '%S'\n",
1703,1704c2228,2229
< 	    /* (c) Must be a USA - decode it */
< 	    if(!seqinUsaProcess(seqin, thys) &&
---
>             /* (c) Must be a USA - decode it */
>             if(!seqinUsaProcess(seqin, thys) &&
1706c2231,2234
< 		return ajFalse;
---
>                 return ajFalse;
> 
>             if(ajListGetLength(seqin->Usalist)) /* could be a new list */
>                 listdata = ajTrue;
1708,1709c2236
< 	    if(ajListGetLength(seqin->Usalist)) /* could be a new list */
< 		listdata = ajTrue;
---
>             ajTextinClearNewfile(seqin->Input);
1711,1714c2238,2241
< 	    ret = seqRead(thys, seqin);
< 	    ajDebug("ajSeqRead: new usa: '%S' returns: %B\n",
< 		    seqin->Input->Qry, ret);
< 	}
---
>             ret = seqRead(thys, seqin);
>             ajDebug("ajSeqRead: new usa: '%S' returns: %B\n",
>                     seqin->Input->Qry, ret);
>         }
1721c2248
< 	/* Failed, but we have a list still - keep trying it */
---
>         /* Failed, but we have a list still - keep trying it */
1723c2250
< 	    ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
---
>             ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
1725,1743c2252,2272
< 	listdata = ajTrue;
< 	ajListPop(seqin->Usalist,(void**) &node);
< 	ajDebug("++try again: pop from list '%S'\n", node->Usa);
< 	ajSeqinUsa(&seqin, node->Usa);
< 	ajDebug("++SAVE (AGAIN) SEQIN '%S' %d..%d(%b) '%S' %d\n",
< 		seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
< 		seqin->Input->Formatstr, seqin->Input->Format);
< 	seqUsaRestore(seqin, node);
< 
< 	ajStrDel(&node->Usa);
< 	ajStrDel(&node->Formatstr);
< 	AJFREE(node);
< 
< 	if(!seqinUsaProcess(seqin, thys))
< 	    continue;
< 
< 	ret = seqRead(thys, seqin);
< 	ajDebug("ajSeqRead: list retry usa: '%S' returns: %B\n",
< 		seqin->Input->Qry, ret);
---
>         listdata = ajTrue;
>         ajListPop(seqin->Usalist,(void**) &node);
>         ajDebug("++try again: pop from list '%S'\n", node->Usa);
>         ajSeqinUsa(&seqin, node->Usa);
>         ajDebug("++SAVE (AGAIN) SEQIN '%S' %d..%d(%b) '%S' %d\n",
>                 seqin->Input->Qry, seqin->Begin, seqin->End, seqin->Rev,
>                 seqin->Input->Formatstr, seqin->Input->Format);
>         seqUsaRestore(seqin, node);
> 
>         ajStrDel(&node->Usa);
>         ajStrDel(&node->Formatstr);
>         AJFREE(node);
> 
>         if(!seqinUsaProcess(seqin, thys))
>             continue;
> 
>         ajTextinClearNewfile(seqin->Input);
> 
>         ret = seqRead(thys, seqin);
>         ajDebug("ajSeqRead: list retry usa: '%S' returns: %B\n",
>                 seqin->Input->Qry, ret);
1748,1749c2277,2278
< 	if(listdata)
< 	    ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
---
>         if(listdata)
>             ajErr("Failed to read sequence '%S'", seqin->Input->Qry);
1751c2280
< 	return ajFalse;
---
>         return ajFalse;
1797a2327,2328
> **
> ** @release 1.0.0
1813c2344,2346
< 	return ajFalse;
---
>         return ajFalse;
> 
>     ajTextinClearNewfile(seqin->Input);
1823c2356
< 	    seqin->Input->Formatstr, seq->Formatstr, seqin->Begin, seqin->End);
---
>             seqin->Input->Formatstr, seq->Formatstr, seqin->Begin, seqin->End);
1827,1840c2360,2373
< 	if (seqin->Usalist)
< 	    ajSeqinClearPos(seqin);
< 	/*ajDebug("read name '%S' length %d format '%S' '%S' seqindata: %x\n",
< 	  seq->Entryname, ajSeqGetLen(seq),
< 	  seqin->Input->Formatstr, seq->Formatstr, seqin->SeqData);*/
< 	ajStrAssignEmptyS(&seq->Db, seqin->Input->Db);
< 
< 	if(!ajStrGetLen(seq->Type))
< 	    ajSeqType(seq);
< 
< 	if(thys->Rev)
< 	    ajSeqSetRangeRev(seq, thys->Begin, thys->End);
< 	else
< 	    ajSeqSetRange(seq, thys->Begin, thys->End);
---
>         if (seqin->Usalist)
>             ajSeqinClearPos(seqin);
>         /*ajDebug("read name '%S' length %d format '%S' '%S' seqindata: %x\n",
>           seq->Entryname, ajSeqGetLen(seq),
>           seqin->Input->Formatstr, seq->Formatstr, seqin->SeqData);*/
>         ajStrAssignEmptyS(&seq->Db, seqin->Input->Db);
> 
>         if(!ajStrGetLen(seq->Type))
>             ajSeqType(seq);
> 
>         if(thys->Rev)
>             ajSeqSetRangeRev(seq, thys->Begin, thys->End);
>         else
>             ajSeqSetRange(seq, thys->Begin, thys->End);
1842c2375
< 	ajDebug ("ajSeqsetRead read sequence %d %x '%S' %d..%d (%d) "
---
>         ajDebug ("ajSeqsetRead read sequence %d %x '%S' %d..%d (%d) "
1844,1846c2377,2379
< 		 iseq, seq, ajSeqGetNameS(seq),
< 		 seq->Begin, seq->End, ajSeqGetLen(seq),
< 		 seq->Rev, seq->Reversed);
---
>                  iseq, seq, ajSeqGetNameS(seq),
>                  seq->Begin, seq->End, ajSeqGetLen(seq),
>                  seq->Rev, seq->Reversed);
1848,1849c2381,2382
< 	/*ajSeqTrace(seq);*/
< 	iseq++;
---
>         /*ajSeqTrace(seq);*/
>         iseq++;
1851c2384
< 	ajListPushAppend(setlist, seq);
---
>         ajListPushAppend(setlist, seq);
1853c2386
< 	/*ajDebug("appended to list\n");*/
---
>         /*ajDebug("appended to list\n");*/
1855c2388
< 	/* add to a list of sequences */
---
>         /* add to a list of sequences */
1857,1858c2390,2391
< 	seq = ajSeqNew();
< 	seqinFormatSet(seqin, seq);
---
>         seq = ajSeqNew();
>         seqinFormatSet(seqin, seq);
1864c2397
< 	return ajFalse;
---
>         return ajFalse;
1897a2431,2432
> **
> ** @release 2.8.0
1914,1915c2449
< 	return ajFalse;
< 
---
>         return ajFalse;
1916a2451
>     ajTextinClearNewfile(seqin->Input);
1919c2454
< 	    seqin->Input->Formatstr, seq->Formatstr, seqin->Begin, seqin->End);
---
>             seqin->Input->Formatstr, seq->Formatstr, seqin->Begin, seqin->End);
1923,1964c2458,2499
< 	ajDebug("read name '%S' length %d format '%S' '%S' "
< 		"seqindata: %x multidone: %B\n",
< 		seq->Entryname, ajSeqGetLen(seq),
< 		seqin->Input->Formatstr, seq->Formatstr,
< 		seqin->SeqData, seqin->Multidone);
< 	ajStrAssignEmptyS(&seq->Db, seqin->Input->Db);
< 
< 	if(!ajStrGetLen(seq->Type))
< 	    ajSeqType(seq);
< 
< 	/*ajDebug ("ajSeqsetallRead read sequence %d '%s' %d..%d\n",
< 	  iseq, ajSeqGetNameC(seq), seq->Begin, seq->End);*/
< 	/*ajSeqTrace(seq);*/
< 	iseq++;
< 
< 	if(!setlist)
< 	    setlist = ajListNew();
< 
< 	ajListPushAppend(setlist, seq);
< 
< 	/*ajDebug("appended to list\n");*/
< 
< 	/* add to a list of sequences */
< 
< 	seq = ajSeqNew();
< 	seqinFormatSet(seqin, seq);
< 
< 	if(seqin->Multidone)
< 	{
< 	    seqset = ajSeqsetNew();
< 	    ajStrAssignS(&seqset->Usa, seqin->Input->Qry);
< 	    ajStrAssignS(&seqset->Ufo, seqin->Ufo);
< 	    seqset->Begin = seqin->Begin;
< 	    seqset->End = seqin->End;
< 
< 	    ajSeqsetFromList(seqset, setlist);
< 	    ajListFree(&setlist);
< 	    ajListPushAppend(thys, seqset);
< 	    ajDebug("ajSeqsetallRead multidone save set %u of %u sequences\n",
< 		    ajListGetLength(thys), ajSeqsetGetSize(seqset));
< 	    seqset = NULL;
< 	}
---
>         ajDebug("read name '%S' length %d format '%S' '%S' "
>                 "seqindata: %x multidone: %B\n",
>                 seq->Entryname, ajSeqGetLen(seq),
>                 seqin->Input->Formatstr, seq->Formatstr,
>                 seqin->SeqData, seqin->Multidone);
>         ajStrAssignEmptyS(&seq->Db, seqin->Input->Db);
> 
>         if(!ajStrGetLen(seq->Type))
>             ajSeqType(seq);
> 
>         /*ajDebug ("ajSeqsetallRead read sequence %d '%s' %d..%d\n",
>           iseq, ajSeqGetNameC(seq), seq->Begin, seq->End);*/
>         /*ajSeqTrace(seq);*/
>         iseq++;
> 
>         if(!setlist)
>             setlist = ajListNew();
> 
>         ajListPushAppend(setlist, seq);
> 
>         /*ajDebug("appended to list\n");*/
> 
>         /* add to a list of sequences */
> 
>         seq = ajSeqNew();
>         seqinFormatSet(seqin, seq);
> 
>         if(seqin->Multidone)
>         {
>             seqset = ajSeqsetNew();
>             ajStrAssignS(&seqset->Usa, seqin->Input->Qry);
>             ajStrAssignS(&seqset->Ufo, seqin->Ufo);
>             seqset->Begin = seqin->Begin;
>             seqset->End = seqin->End;
> 
>             ajSeqsetFromList(seqset, setlist);
>             ajListFree(&setlist);
>             ajListPushAppend(thys, seqset);
>             ajDebug("ajSeqsetallRead multidone save set %Lu of %u sequences\n",
>                     ajListGetLength(thys), ajSeqsetGetSize(seqset));
>             seqset = NULL;
>         }
1970c2505
< 	return ajFalse;
---
>         return ajFalse;
1976,1985c2511,2520
< 	seqset = ajSeqsetNew();
< 	ajStrAssignS(&seqset->Usa, seqin->Input->Qry);
< 	ajStrAssignS(&seqset->Ufo, seqin->Ufo);
< 	seqset->Begin = seqin->Begin;
< 	seqset->End = seqin->End;
< 
< 	ajSeqsetFromList(seqset, setlist);
< 	ajListFree(&setlist);
< 	ajListPushAppend(thys, seqset);
< 	seqset = NULL;
---
>         seqset = ajSeqsetNew();
>         ajStrAssignS(&seqset->Usa, seqin->Input->Qry);
>         ajStrAssignS(&seqset->Ufo, seqin->Ufo);
>         seqset->Begin = seqin->Begin;
>         seqset->End = seqin->End;
> 
>         ajSeqsetFromList(seqset, setlist);
>         ajListFree(&setlist);
>         ajListPushAppend(thys, seqset);
>         seqset = NULL;
1988,1989c2523,2524
<     ajDebug("ajSeqsetallRead total %d sets of %d sequences\n",
< 	    ajListGetLength(thys), iseq);
---
>     ajDebug("ajSeqsetallRead total %Lu sets of %d sequences\n",
>             ajListGetLength(thys), iseq);
2003a2539,2540
> **
> ** @release 2.1.0
2013c2550
<     ajDebug("ajSeqsetFromList length: %d\n", ajListGetLength(list));
---
>     ajDebug("ajSeqsetFromList length: %Lu\n", ajListGetLength(list));
2017c2554
<     thys->Size      = ajListGetLength(list);
---
>     thys->Size      = (ajuint) ajListGetLength(list);
2027,2047c2564,2584
< 	if(!i)
< 	{
< 	    thys->EType = seq->EType;
< 	    ajStrAssignS(&thys->Type, seq->Type);
< 	    thys->Format = seq->Format;
< 	    ajStrAssignS(&thys->Formatstr, seq->Formatstr);
< 	    ajStrAssignS(&thys->Filename, seq->Filename);
< 	    ajStrAssignS(&thys->Full, seq->Full);
< 	}
< 
< 	thys->Seqweight[i] = seq->Weight;
< 	thys->Seq[i] = seq;
< 	thys->Totweight += seq->Weight;
< 
< 	if(ajSeqGetLen(seq) > thys->Len)
< 	    thys->Len = ajSeqGetLen(seq);
< 
< 	/*	ajDebug("seq %d '%x'\n", i, seq);*/
< 	ajDebug("seq '%x' len: %d weight: %.3f\n",
< 		seq->Name, ajSeqGetLen(seq), thys->Seq[i]->Weight);
< 	i++;
---
>         if(!i)
>         {
>             thys->EType = seq->EType;
>             ajStrAssignS(&thys->Type, seq->Type);
>             thys->Format = seq->Format;
>             ajStrAssignS(&thys->Formatstr, seq->Formatstr);
>             ajStrAssignS(&thys->Filename, seq->Filename);
>             ajStrAssignS(&thys->Full, seq->Full);
>         }
> 
>         thys->Seqweight[i] = seq->Weight;
>         thys->Seq[i] = seq;
>         thys->Totweight += seq->Weight;
> 
>         if(ajSeqGetLen(seq) > thys->Len)
>             thys->Len = ajSeqGetLen(seq);
> 
>         /*      ajDebug("seq %d '%x'\n", i, seq);*/
>         ajDebug("seq '%x' len: %d weight: %.3f\n",
>                 seq->Name, ajSeqGetLen(seq), thys->Seq[i]->Weight);
>         i++;
2064a2602,2603
> **
> ** @release 2.1.0
2085a2625,2626
> **
> ** @release 2.1.0
2095,2096c2636,2637
< 	    thys->Full, thys->Size, thys->Len,
< 	    seq->Full, ajSeqGetLen(seq));
---
>             thys->Full, thys->Size, thys->Len,
>             seq->Full, ajSeqGetLen(seq));
2104,2109c2645,2650
< 	thys->EType = seq->EType;
< 	ajStrAssignEmptyS(&thys->Type, seq->Type);
< 	thys->Format = seq->Format;
< 	ajStrAssignEmptyS(&thys->Formatstr, seq->Formatstr);
< 	ajStrAssignEmptyS(&thys->Filename, seq->Filename);
< 	ajStrAssignEmptyS(&thys->Full, seq->Full);
---
>         thys->EType = seq->EType;
>         ajStrAssignEmptyS(&thys->Type, seq->Type);
>         thys->Format = seq->Format;
>         ajStrAssignEmptyS(&thys->Formatstr, seq->Formatstr);
>         ajStrAssignEmptyS(&thys->Filename, seq->Filename);
>         ajStrAssignEmptyS(&thys->Full, seq->Full);
2117c2658
< 	thys->Len = ajSeqGetLen(seq);
---
>         thys->Len = ajSeqGetLen(seq);
2120c2661
< 	    thys->Full, thys->Size, thys->Len);
---
>             thys->Full, thys->Size, thys->Len);
2140a2682,2683
> **
> ** @release 1.0.0
2154c2697
< 			ajuint format)
---
>                          ajuint format)
2157,2158c2700,2701
< 	    format, seqinFormatDef[format].Name,
< 	    seqin->Input->Qry, seqin->Features);
---
>             format, seqinFormatDef[format].Name,
>             seqin->Input->Qry, seqin->Features);
2160c2703
<     seqin->Input->Records = 0;
---
>     ajTextinClearNewinput(seqin->Input);
2163c2706
<     if(seqinFormatDef[format].Read(thys, seqin))
---
>     if((*seqinFormatDef[format].Read)(thys, seqin))
2165,2166c2708,2709
< 	ajDebug("seqReadFmt success with format %d (%s)\n",
< 		format, seqinFormatDef[format].Name);
---
>         ajDebug("seqReadFmt success with format %d (%s)\n",
>                 format, seqinFormatDef[format].Name);
2169,2183c2712,2730
< 	seqin->Input->Format = format;
< 	ajStrAssignC(&seqin->Input->Formatstr, seqinFormatDef[format].Name);
< 	ajStrAssignC(&thys->Formatstr, seqinFormatDef[format].Name);
< 	ajStrAssignEmptyS(&thys->Db, seqin->Input->Db);
< 	ajStrAssignS(&thys->Entryname, seqin->Entryname);
< 	ajStrAssignS(&thys->Filename, seqin->Input->Filename);
< 
< 	if(seqQueryMatch(seqin->Input->Query, thys))
< 	{
< 	    ajStrAssignEmptyS(&thys->Entryname, thys->Name);
< 
< 	    if(seqin->Features && !thys->Fttable)
< 	    {
< 		ajStrAssignEmptyS(&seqin->Ftquery->Seqname, thys->Entryname);
< 		seqin->Fttable = ajFeattableNewReadUfo(seqin->Ftquery,
---
>         seqin->Input->Format = format;
>         ajStrAssignC(&seqin->Input->Formatstr, seqinFormatDef[format].Name);
>         ajStrAssignC(&thys->Formatstr, seqinFormatDef[format].Name);
>         ajStrAssignEmptyS(&thys->Db, seqin->Input->Db);
>         ajStrAssignS(&thys->Entryname, seqin->Entryname);
>         ajStrAssignS(&thys->Filename, seqin->Input->Filename);
> 
>         if(seqQueryMatch(seqin->Input->Query, thys))
>         {
>             ajStrAssignEmptyS(&thys->Entryname, thys->Name);
> 
>             ajDebug("seqQueryMatch Features:%B FtTable: %x (%u)\n",
>                     seqin->Features, thys->Fttable,
>                     ajFeattableGetSize(thys->Fttable));
> 
>             if(seqin->Features && !thys->Fttable)
>             {
>                 ajStrAssignEmptyS(&seqin->Ftquery->Seqname, thys->Entryname);
>                 seqin->Fttable = ajFeattableNewReadUfo(seqin->Ftquery,
2185,2195c2732,2742
< 		if (!seqin->Fttable)
< 		{
< 		    ajDebug("seqReadFmt features input failed UFO: '%S'\n",
< 			    seqin->Ufo);
< 		    /*
< 		    **  GWW 21 Aug 2000 - don't warn about missing feature
< 		    **  tables
< 		    **/
< 		}
< 		else
< 		{
---
>                 if (!seqin->Fttable)
>                 {
>                     ajDebug("seqReadFmt features input failed UFO: '%S'\n",
>                             seqin->Ufo);
>                     /*
>                     **  GWW 21 Aug 2000 - don't warn about missing feature
>                     **  tables
>                     **/
>                 }
>                 else
>                 {
2198,2203c2745,2750
< 		    ajFeattableDel(&thys->Fttable);
< 		    /* ajFeattableTrace(seqin->Fttable); */
< 		    thys->Fttable = seqin->Fttable;
< 		    seqin->Fttable = NULL;
< 		}
< 	    }
---
>                     ajFeattableDel(&thys->Fttable);
>                     /* ajFeattableTrace(seqin->Fttable); */
>                     thys->Fttable = seqin->Fttable;
>                     seqin->Fttable = NULL;
>                 }
>             }
2208,2209c2755,2756
< 	    if(ajSeqTypeCheckIn(thys, seqin))
< 	    {
---
>             if(ajSeqTypeCheckIn(thys, seqin))
>             {
2213,2215c2760,2762
< 		/* ajSeqinTrace(seqin); */
< 		if(seqin->Upper)
< 		    ajSeqFmtUpper(thys);
---
>                 /* ajSeqinTrace(seqin); */
>                 if(seqin->Upper)
>                     ajSeqFmtUpper(thys);
2217,2218c2764,2765
< 		if(seqin->Lower)
< 		    ajSeqFmtLower(thys);
---
>                 if(seqin->Lower)
>                     ajSeqFmtLower(thys);
2220,2221c2767,2768
< 		if(seqin->Begin)
< 		    thys->Begin = seqin->Begin;
---
>                 if(seqin->Begin)
>                     thys->Begin = seqin->Begin;
2223,2224c2770,2771
< 		if(seqin->End)
< 		    thys->End = seqin->End;
---
>                 if(seqin->End)
>                     thys->End = seqin->End;
2226,2227c2773,2774
< 		if(seqin->Rev)
< 		    thys->Rev = seqin->Rev;
---
>                 if(seqin->Rev)
>                     thys->Rev = seqin->Rev;
2229,2233c2776,2780
< 		return FMT_OK;
< 	    }
< 	    else
< 		return FMT_BADTYPE;
< 	}
---
>                 return FMT_OK;
>             }
>             else
>                 return FMT_BADTYPE;
>         }
2235,2236c2782,2783
< 	ajDebug("query match failed, continuing ...\n");
< 	ajSeqClear(thys);
---
>         ajDebug("query match failed, continuing ...\n");
>         ajSeqClear(thys);
2238c2785,2788
< 	return FMT_NOMATCH;
---
>         if(seqinFormatDef[format].Binary)
>             return FMT_FAIL; /* do not reread - will read whole file again */
>         else
>             return FMT_NOMATCH;
2242,2254c2792,2803
< 	ajDebug("Testing input buffer: IsBuff: %B Eof: %B\n",
< 		ajFilebuffIsBuffered(seqin->Input->Filebuff),
< 		ajFilebuffIsEof(seqin->Input->Filebuff));
< 
< 	if (!ajFilebuffIsBuffered(seqin->Input->Filebuff) &&
< 	    ajFilebuffIsEof(seqin->Input->Filebuff))
< 	    return FMT_EOF;
< 
< 	ajFilebuffResetStore(seqin->Input->Filebuff, seqin->Input->Text,
<                              &thys->TextPtr);
< 	ajDebug("Format %d (%s) failed, file buffer reset by seqReadFmt\n",
< 		format, seqinFormatDef[format].Name);
< 	/* ajFilebuffTraceFull(seqin->Input->Filebuff, 10, 10);*/
---
>         ajDebug("Testing input buffer: IsBuff: %B Eof: %B\n",
>                 ajFilebuffIsBuffered(seqin->Input->Filebuff),
>                 ajFilebuffIsEof(seqin->Input->Filebuff));
> 
>         if (!ajFilebuffIsBuffered(seqin->Input->Filebuff) &&
>             ajFilebuffIsEof(seqin->Input->Filebuff))
>             return FMT_EOF;
> 
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajDebug("Format %d (%s) failed, file buffer reset by seqReadFmt\n",
>                 format, seqinFormatDef[format].Name);
>         /* ajFilebuffTraceFull(seqin->Input->Filebuff, 10, 10);*/
2272a2822,2823
> **
> ** @release 1.0.0
2292,2310c2843,2861
<             "TextData:%p QryData:%p\n",
<             textin->Single, textin->Count,
<             seqin->SeqData, textin->TextData,
<             qry->QryData);
< 
<     if(textin->Single && textin->Count)
<     {
< 	/*
< 	** One sequence at a time is read.
< 	** The first sequence was read by ACD
< 	** for the following ones we need to reset the AjPSeqin
< 	**
< 	** Single is set by the access method
< 	*/
< 
< 	ajDebug("seqRead: single access - count %d - lines %d call access"
< 		" routine again\n",
< 		textin->Count, textin->Records);
< 	/* Calling funclist seqAccess() */
---
>             "TextData:%p\n",
>             textin->Single, ajTextinGetCount(textin),
>             seqin->SeqData, textin->TextData);
> 
>     if(textin->Single && ajTextinGetCount(textin))
>     {
>         /*
>         ** One sequence at a time is read.
>         ** The first sequence was read by ACD
>         ** for the following ones we need to reset the AjPSeqin
>         **
>         ** Single is set by the access method
>         */
> 
>         ajDebug("seqRead: single access - count %u - lines %u (total %u) "
>                 "call access routine again\n",
>                 ajTextinGetCount(textin),
>                 ajTextinGetRecords(textin), ajTextinGetTotrecords(textin));
>         /* Calling funclist seqAccess() */
2313,2323c2864,2867
< 	if(textaccess && !textaccess->Access(textin))
< 	{
< 	    ajDebug("seqRead: TextAccess->Access(seqin->Input) "
< 		    "*failed*\n");
< 
< 	    return ajFalse;
< 	}
<  	if(seqaccess && !seqaccess->Access(seqin))
< 	{
< 	    ajDebug("seqRead: Access->Access(seqin) "
< 		    "*failed*\n");
---
>         if(textaccess && !(*textaccess->Access)(textin))
>         {
>             ajDebug("seqRead: (*textaccess->Access)(seqin->Input) "
>                     "*failed*\n");
2325,2326c2869,2877
< 	    return ajFalse;
< 	}
---
>             return ajFalse;
>         }
>         if(seqaccess && !(*seqaccess->Access)(seqin))
>         {
>             ajDebug("seqRead: (*seqaccess->Access)(seqin) "
>                     "*failed*\n");
> 
>             return ajFalse;
>         }
2331c2882
< 	    textin->Formatstr);
---
>             textin->Formatstr);
2336c2887
< 	return ajFalse;
---
>         return ajFalse;
2343c2894
<         {				/* skip blank lines */
---
>         {                               /* skip blank lines */
2345,2346c2896,2897
<             
<             if(!ajStrIsWhite(seqReadLine))
---
> 
>             if(ok && !ajStrIsWhite(seqReadLine))
2355c2906
<     {			   /* no format specified, try all defaults */
---
>     {                      /* no format specified, try all defaults */
2359,2362c2910,2913
< 	for(i = 1; seqinFormatDef[i].Name; i++)
< 	{
< 	    if(!seqinFormatDef[i].Try)	/* skip if Try is ajFalse */
< 		continue;
---
>         for(i = 1; seqinFormatDef[i].Name; i++)
>         {
>             if(!seqinFormatDef[i].Try)  /* skip if Try is ajFalse */
>                 continue;
2371,2382c2922,2929
< 	    ajDebug("seqRead:try format %d (%s) records: %u seqdata: %p\n",
< 		    i, seqinFormatDef[i].Name,
<                     textin->Records, seqin->SeqData);
< 
< 	    istat = seqReadFmt(thys, seqin, i);
< 
< 	    switch(istat)
< 	    {
< 	    case FMT_OK:
< 		ajDebug("++seqRead OK (1), set format %d\n",
<                         textin->Format);
< 		seqDefine(thys, seqin);
---
>             ajDebug("seqRead:try format %d (%s) records: %u (total %u) "
>                     "seqdata: %p\n",
>                     i, seqinFormatDef[i].Name,
>                     ajTextinGetRecords(textin),
>                     ajTextinGetTotrecords(textin),
>                     seqin->SeqData);
> 
>             ajTextinClearNewinput(seqin->Input);
2384,2405c2931,2961
< 		return ajTrue;
< 	    case FMT_BADTYPE:
< 		ajDebug("seqRead: (a1) seqReadFmt stat == BADTYPE *failed*\n");
< 
< 		return ajFalse;
< 	    case FMT_FAIL:
< 		ajDebug("seqRead: (b1) seqReadFmt stat == FAIL *failed*\n");
< 		break;			/* we can try next format */
< 	    case FMT_NOMATCH:
< 		ajDebug("seqRead: (c1) seqReadFmt stat==NOMATCH try again\n");
< 		break;
< 	    case FMT_EOF:
< 		ajDebug("seqRead: (d1) seqReadFmt stat == EOF *failed*\n");
< 		return ajFalse;			/* EOF and unbuffered */
< 	    case FMT_EMPTY:
< 		ajWarn("Sequence '%S' has zero length, ignored",
< 		       ajSeqGetUsaS(thys));
< 		ajDebug("seqRead: (e1) seqReadFmt stat==EMPTY try again\n");
< 		break;
< 	    default:
< 		ajDebug("unknown code %d from seqReadFmt\n", stat);
< 	    }
---
>             istat = seqReadFmt(thys, seqin, i);
> 
>             switch(istat)
>             {
>                 case FMT_OK:
>                     ajDebug("++seqRead OK (1), set format %d\n",
>                             textin->Format);
>                     seqDefine(thys, seqin);
> 
>                     return ajTrue;
>                 case FMT_BADTYPE:
>                     ajDebug("seqRead: (a1) seqReadFmt stat == BADTYPE *failed*\n");
> 
>                     return ajFalse;
>                 case FMT_FAIL:
>                     ajDebug("seqRead: (b1) seqReadFmt stat == FAIL *failed*\n");
>                     break;                  /* we can try next format */
>                 case FMT_NOMATCH:
>                     ajDebug("seqRead: (c1) seqReadFmt stat==NOMATCH try again\n");
>                     break;
>                 case FMT_EOF:
>                     ajDebug("seqRead: (d1) seqReadFmt stat == EOF *failed*\n");
>                     return ajFalse;                 /* EOF and unbuffered */
>                 case FMT_EMPTY:
>                     ajWarn("Sequence '%S' has zero length, ignored",
>                            ajSeqGetUsaS(thys));
>                     ajDebug("seqRead: (e1) seqReadFmt stat==EMPTY try again\n");
>                     break;
>                 default:
>                     ajDebug("unknown code %d from seqReadFmt\n", stat);
>             }
2407c2963
< 	    ajSeqClear(thys);
---
>             ajSeqClear(thys);
2409,2410c2965,2966
< 	    if(textin->Format)
< 		break;			/* we read something */
---
>             if(textin->Format)
>                 break;                  /* we read something */
2413c2969
< 	}
---
>         }
2415,2417c2971,2973
< 	if(!textin->Format)
< 	{		     /* all default formats failed, give up */
< 	    ajDebug("seqRead:all default formats failed, give up\n");
---
>         if(!textin->Format)
>         {                    /* all default formats failed, give up */
>             ajDebug("seqRead:all default formats failed, give up\n");
2419,2420c2975,2976
< 	    return ajFalse;
< 	}
---
>             return ajFalse;
>         }
2422c2978
< 	ajDebug("++seqRead set format %d\n", textin->Format);
---
>         ajDebug("++seqRead set format %d\n", textin->Format);
2425,2437c2981,2997
<     {					/* one format specified */
< 	ajDebug("seqRead: one format specified\n");
< 	ajFilebuffSetUnbuffered(textin->Filebuff);
< 
< 	ajDebug("++seqRead known format %d\n", textin->Format);
< 	istat = seqReadFmt(thys, seqin, textin->Format);
< 
< 	switch(istat)
< 	{
< 	case FMT_OK:
<             ajDebug("++seqRead OK (2), set format %d\n",
<                     textin->Format);
< 	    seqDefine(thys, seqin);
---
>     {                                   /* one format specified */
>         ajDebug("seqRead: one format specified\n");
>         ajFilebuffSetUnbuffered(textin->Filebuff);
> 
>         ajDebug("++seqRead known format %d\n", textin->Format);
>         istat = seqReadFmt(thys, seqin, textin->Format);
> 
>         switch(istat)
>         {
>             case FMT_OK:
>                 ajDebug("++seqRead OK (2), set format %d\n",
>                         textin->Format);
>                 seqDefine(thys, seqin);
> 
>                 return ajTrue;
>             case FMT_BADTYPE:
>                 ajDebug("seqRead: (a2) seqReadFmt stat == BADTYPE *failed*\n");
2439,2470c2999,3004
< 	    return ajTrue;
< 	case FMT_BADTYPE:
< 	    ajDebug("seqRead: (a2) seqReadFmt stat == BADTYPE *failed*\n");
< 
< 	    return ajFalse;
< 
<         case FMT_FAIL:
< 	    ajDebug("seqRead: (b2) seqReadFmt stat == FAIL *failed*\n");
< 
< 	    return ajFalse;
< 
<         case FMT_NOMATCH:
< 	    ajDebug("seqRead: (c2) seqReadFmt stat == NOMATCH *try again*\n");
< 	    break;
< 	case FMT_EOF:
< 	    ajDebug("seqRead: (d2) seqReadFmt stat == EOF *try again*\n");
<             if(textin->Records)
<                 ajErr("Error reading file '%F' with format '%s': "
<                       "end-of-file before end of data "
<                       "(read %u records)",
<                       ajFilebuffGetFile(textin->Filebuff),
<                       seqinFormatDef[textin->Format].Name,
<                       textin->Records);
< 	    break;		     /* simply end-of-file */
< 	case FMT_EMPTY:
< 	    ajWarn("Sequence '%S' has zero length, ignored",
< 		   ajSeqGetUsaS(thys));
< 	    ajDebug("seqRead: (e2) seqReadFmt stat == EMPTY *try again*\n");
< 	    break;
< 	default:
< 	    ajDebug("unknown code %d from seqReadFmt\n", stat);
< 	}
---
>                 return ajFalse;
> 
>             case FMT_FAIL:
>                 ajDebug("seqRead: (b2) seqReadFmt stat == FAIL *failed*\n");
> 
>                 return ajFalse;
2472c3006,3029
< 	ajSeqClear(thys); /* 1 : read, failed to match id/acc/query */
---
>             case FMT_NOMATCH:
>                 ajDebug("seqRead: (c2) seqReadFmt stat == NOMATCH *try again*\n");
>                 break;
>             case FMT_EOF:
>                 ajDebug("seqRead: (d2) seqReadFmt stat == EOF *try again*\n");
>                 if(ajTextinGetRecords(textin))
>                     ajErr("Error reading file '%F' with format '%s': "
>                           "end-of-file before end of data "
>                           "(read %u records, total %u)",
>                           ajFilebuffGetFile(textin->Filebuff),
>                           seqinFormatDef[textin->Format].Name,
>                           ajTextinGetRecords(textin),
>                           ajTextinGetTotrecords(textin));
>                 break;                   /* simply end-of-file */
>             case FMT_EMPTY:
>                 ajWarn("Sequence '%S' has zero length, ignored",
>                        ajSeqGetUsaS(thys));
>                 ajDebug("seqRead: (e2) seqReadFmt stat == EMPTY *try again*\n");
>                 break;
>             default:
>                 ajDebug("unknown code %d from seqReadFmt\n", stat);
>         }
> 
>         ajSeqClear(thys); /* 1 : read, failed to match id/acc/query */
2478c3035
< 	    textin->Format, seqinFormatDef[textin->Format].Name, istat);
---
>             textin->Format, seqinFormatDef[textin->Format].Name, istat);
2481c3038
< 	    textin->Search, textin->ChunkEntries,
---
>             textin->Search, textin->ChunkEntries,
2486c3043
< 	if(textaccess && !textaccess->Access(textin))
---
>         if(textaccess && !(*textaccess->Access)(textin))
2488c3045
< 	else if(seqaccess && !seqaccess->Access(seqin))
---
>         else if(seqaccess && !(*seqaccess->Access)(seqin))
2498c3055
< 	jstat = seqReadFmt(thys, seqin, textin->Format);
---
>         jstat = seqReadFmt(thys, seqin, textin->Format);
2500,2505c3057,3062
< 	switch(jstat)
< 	{
< 	case FMT_OK:
<             ajDebug("++seqRead OK (3), set format %d\n",
<                     textin->Format);
< 	    seqDefine(thys, seqin);
---
>         switch(jstat)
>         {
>             case FMT_OK:
>                 ajDebug("++seqRead OK (3), set format %d\n",
>                         textin->Format);
>                 seqDefine(thys, seqin);
2507c3064
< 	    return ajTrue;
---
>                 return ajTrue;
2509,2510c3066,3067
<         case FMT_BADTYPE:
< 	    ajDebug("seqRead: (a3) seqReadFmt stat == BADTYPE *failed*\n");
---
>             case FMT_BADTYPE:
>                 ajDebug("seqRead: (a3) seqReadFmt stat == BADTYPE *failed*\n");
2512c3069
< 	    return ajFalse;
---
>                 return ajFalse;
2514,2515c3071,3072
<         case FMT_FAIL:
< 	    ajDebug("seqRead: (b3) seqReadFmt stat == FAIL *failed*\n");
---
>             case FMT_FAIL:
>                 ajDebug("seqRead: (b3) seqReadFmt stat == FAIL *failed*\n");
2517,2523c3074
< 	    return ajFalse;
<             
< 	case FMT_NOMATCH:
< 	    ajDebug("seqRead: (c3) seqReadFmt stat == NOMATCH *try again*\n");
< 	    break;
< 	case FMT_EOF:
< 	    ajDebug("seqRead: (d3) seqReadFmt stat == EOF *failed*\n");
---
>                 return ajFalse;
2525c3076,3080
< 	    return ajFalse;			/* we already tried again */
---
>             case FMT_NOMATCH:
>                 ajDebug("seqRead: (c3) seqReadFmt stat == NOMATCH *try again*\n");
>                 break;
>             case FMT_EOF:
>                 ajDebug("seqRead: (d3) seqReadFmt stat == EOF *failed*\n");
2527,2532c3082
<         case FMT_EMPTY:
< 	    if(istat != FMT_EMPTY)
<                 ajWarn("Sequence '%S' has zero length, ignored",
<                        ajSeqGetUsaS(thys));
< 	    ajDebug("seqRead: (e3) seqReadFmt stat == EMPTY *try again*\n");
< 	    break;
---
>                 return ajFalse;                     /* we already tried again */
2534,2536c3084,3093
<         default:
< 	    ajDebug("unknown code %d from seqReadFmt\n", stat);
< 	}
---
>             case FMT_EMPTY:
>                 if(istat != FMT_EMPTY)
>                     ajWarn("Sequence '%S' has zero length, ignored",
>                            ajSeqGetUsaS(thys));
>                 ajDebug("seqRead: (e3) seqReadFmt stat == EMPTY *try again*\n");
>                 break;
> 
>             default:
>                 ajDebug("unknown code %d from seqReadFmt\n", stat);
>         }
2538c3095
< 	ajSeqClear(thys); /* 1 : read, failed to match id/acc/query */
---
>         ajSeqClear(thys); /* 1 : read, failed to match id/acc/query */
2542,2543c3099,3100
< 	ajDebug("seqRead: *failed* to read sequence %S using format %s\n",
< 		textin->Qry, seqinFormatDef[textin->Format].Name);
---
>         ajDebug("seqRead: *failed* to read sequence %S using format %s\n",
>                 textin->Qry, seqinFormatDef[textin->Format].Name);
2545,2546c3102,3103
< 	ajDebug("seqRead: *failed* to read sequence %S using any format\n",
< 		textin->Qry);
---
>         ajDebug("seqRead: *failed* to read sequence %S using any format\n",
>                 textin->Qry);
2561a3119,3120
> **
> ** @release 1.0.0
2586,2587c3145
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2589c3147
< 	return ajFalse;
---
>         return ajFalse;
2591c3149
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
2598,2601c3156,3159
< 	ajStrAssignSubS(&tmpline,seqReadLine, 4, -1);
< 	ajFmtPrintS(&seqReadLine, ">%S",tmpline);
< 	ajDebug("PIR format changed line to %S\n", seqReadLine);
< 	ajStrDel(&tmpline);
---
>         ajStrAssignSubS(&tmpline,seqReadLine, 4, -1);
>         ajFmtPrintS(&seqReadLine, ">%S",tmpline);
>         ajDebug("PIR format changed line to %S\n", seqReadLine);
>         ajStrDel(&tmpline);
2608,2609c3166,3167
< 	ajDebug("first line is not FASTA\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line is not FASTA\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2611c3169
< 	return ajFalse;
---
>         return ajFalse;
2616c3174
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2618c3176
< 	return ajFalse;
---
>         return ajFalse;
2628c3186
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
2631c3189
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
2640c3198
<     {				       /* we have a sequence to use */
---
>     {                                  /* we have a sequence to use */
2642,2644c3200,3202
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
< 	if(seqin->Input->Text)
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
---
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
>         if(seqin->Input->Text)
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
2646c3204
< 	ajFilebuffClear(buff, 0);
---
>         ajFilebuffClear(buff, 0);
2650,2669c3208,3225
< 	ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
< 	while(ok && !ajStrPrefixC(seqReadLine, ">"))
< 	{
< 	    badstr = seqAppendWarn(&thys->Seq, seqReadLine);
< 
< 	    if(badstr)
< 		ajWarn("Sequence '%S' has bad character(s) '%S'",
< 			   thys->Name, badstr);
< 	    seqin->Input->Records++;
< 	    ajDebug("++fasta append line '%S'\n", seqReadLine);
< 	    ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				     seqin->Input->Text, &thys->TextPtr);
< 	}
< 
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 seqReadLine, seqin->Input->Text, &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         while(ok && !ajStrPrefixC(seqReadLine, ">"))
>         {
>             badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                    seqin->Input->Format);
> 
>             if(badstr)
>                 ajWarn("Sequence '%S' has bad character(s) '%S'",
>                        thys->Name, badstr);
> 
>             ajDebug("++fasta append line '%S'\n", seqReadLine);
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
2692a3249,3250
> **
> ** @release 6.1.0
2722,2723c3280
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2725c3282
< 	return ajFalse;
---
>         return ajFalse;
2727c3284
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
2735,2736c3292,3293
< 	ajDebug("first line is not FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line is not FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2738c3295
< 	return ajFalse;
---
>         return ajFalse;
2743,2744c3300,3301
< 	ajDebug("first line did not parse as FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line did not parse as FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2746c3303
< 	return ajFalse;
---
>         return ajFalse;
2752c3309
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
2755c3312
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
2763,2764c3320
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2768c3324,3325
<         badstr = seqAppendWarn(&thys->Seq, seqReadLine);
---
>         badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                seqin->Input->Format);
2773c3330
<         seqin->Input->Records++;
---
> 
2775,2776c3332
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2783,2784c3339,3340
< 	ajDebug("failed to find quality scores\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("failed to find quality scores\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2786c3342
< 	return ajFalse;
---
>         return ajFalse;
2791,2792c3347
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2802d3356
<         seqin->Input->Records++;
2804,2805c3358
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2816c3369
< 	ajDebug("length mismatch seq: %u quality: %u\n",
---
>         ajDebug("length mismatch seq: %u quality: %u\n",
2818c3371
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2820c3373
< 	return ajFalse;
---
>         return ajFalse;
2824,2825c3377
<         ajFilebuffClearStore(buff, 1,
<                              seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
2850a3403,3404
> **
> ** @release 6.1.0
2873d3426
<     ajlong fposb    = 0;
2891,2892c3444
<     ok = ajBuffreadLinePosStore(buff, &seqSaveLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqSaveLine, &thys->TextPtr);
2894c3446
< 	return ajFalse;
---
>         return ajFalse;
2896c3448
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
2905c3457
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2907c3459
< 	return ajFalse;
---
>         return ajFalse;
2913c3465
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2915c3467
< 	return ajFalse;
---
>         return ajFalse;
2921c3473
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
2924c3476
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
2939,2941c3491,3492
<     
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
> 
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2946c3497,3498
<         badstr = seqAppendWarn(&thys->Seq, seqReadLine);
---
>         badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                seqin->Input->Format);
2951c3503
<         seqin->Input->Records++;
---
> 
2953,2954c3505
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
2956c3507
< 	           ajStrGetLen(thys->Seq), thys->Seq); */
---
>            ajStrGetLen(thys->Seq), thys->Seq); */
2962c3513
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
2964c3515
< 	return ajFalse;
---
>         return ajFalse;
2976c3527
< 		   seqSaveLine,
---
>                    seqSaveLine,
2978,2979c3529,3530
< 		   seqReadLine);
<         }        
---
>                    seqReadLine);
>         }
2981c3532
<     
---
> 
2990,2991c3541
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3003c3553
<         
---
> 
3007d3556
<         seqin->Input->Records++;
3009,3010c3558
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3012c3560
< 	           ajStrGetLen(seqQualStr), seqQualStr); */
---
>            ajStrGetLen(seqQualStr), seqQualStr); */
3023c3571
<       	ajWarn("FASTQ quality length mismatch '%F' '%S' "
---
>         ajWarn("FASTQ quality length mismatch '%F' '%S' "
3025,3026c3573,3574
< 	       ajFilebuffGetFile(buff), thys->Name,
< 	       seqlen, ajStrGetLen(seqQualStr));
---
>                ajFilebuffGetFile(buff), thys->Name,
>                seqlen, ajStrGetLen(seqQualStr));
3042c3590
<     
---
> 
3045,3046c3593
<         ajFilebuffClearStore(buff, 1,
<                              seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
3055,3056c3602,3603
<                (ajint) minqual, (ajint) maxqual, (ajint) comqual); */
<     
---
>        (ajint) minqual, (ajint) maxqual, (ajint) comqual); */
> 
3080c3627
< 	{
---
>         {
3086c3633
< 	}
---
>         }
3088,3089c3635,3636
< 	{
< 	    ajWarn("FASTQ-SANGER '%F' sequence '%S' "
---
>         {
>             ajWarn("FASTQ-SANGER '%F' sequence '%S' "
3093c3640
< 	    iqual = qmax;
---
>             iqual = qmax;
3128,3294c3675,3835
< static AjBool seqReadFastqInt(AjPSeq thys, AjPSeqin seqin)
< {
<     AjPFilebuff buff;
<     AjPStrTok handle  = NULL;
<     AjPStr id   = NULL;
<     AjPStr acc  = NULL;
<     AjPStr sv   = NULL;
<     AjPStr desc = NULL;
< 
<     ajuint seqlen = 0;
<     AjPStr qualstr = NULL;
< 
<     const char *cp;
<     ajlong fpos     = 0;
<     ajlong fposb    = 0;
<     AjBool ok       = ajTrue;
< 
<     const AjPStr badstr = NULL;
< 
<     ajuint i;
<     AjBool badwarn = ajFalse;
<     double sval;
<     double pval;
<     double qval;
< 
<     ajDebug("seqReadFastqInt\n");
< 
<     buff = seqin->Input->Filebuff;
< 
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
<     if(!ok)
< 	return ajFalse;
< 
<     seqin->Input->Records++;
< 
<     ajDebug("First line: %S\n", seqReadLine);
< 
<     cp = ajStrGetPtr(seqReadLine);
< 
<     if(*cp != '@')
<     {
< 	ajDebug("first line is not FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	return ajFalse;
<     }
< 
<     if(!ajSeqParseFastq(seqReadLine, &id, &desc))
<     {
< 	ajDebug("first line did not parse as FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	return ajFalse;
<     }
< 
<     seqSetNameNospace(&thys->Name, id);
< 
<     if(ajStrGetLen(sv))
< 	seqSvSave(thys, sv);
< 
<     if(ajStrGetLen(acc))
< 	seqAccSave(thys, acc);
< 
<     ajStrAssignS(&thys->Desc, desc);
<     ajStrDel(&id);
<     ajStrDel(&acc);
<     ajStrDel(&sv);
<     ajStrDel(&desc);
< 
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
<     while(ok &&
<           !ajStrPrefixC(seqReadLine, "+"))
<     {
<         badstr = seqAppendWarn(&thys->Seq, seqReadLine);
< 
<         if(badstr)
<             ajWarn("Sequence '%S' has bad character(s) '%S'",
<                    thys->Name, badstr);
<         seqin->Input->Records++;
<         ajDebug("++fastq append line '%S'\n", seqReadLine);
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
<         ajDebug("++fastq sequence %4u '%S'\n",
<                 ajStrGetLen(thys->Seq), thys->Seq);
<     }
< 
<     if(!ok)
<     {
< 	ajDebug("failed to find quality scores\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	return ajFalse;
<     }
< 
<     seqlen = ajStrGetLen(thys->Seq);
< 
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
< 
<     i=0;
<     if(seqlen > thys->Qualsize)
<     {
<         AJCRESIZE(thys->Accuracy, seqlen);
<         thys->Qualsize = seqlen;
<     }
< 
<     ajStrAssignClear(&seqQualStr);
<     while(ok &&
<           (!ajStrPrefixC(seqReadLine, "@")))
<     {
< 	ajStrTokenAssignC(&handle, seqReadLine, " ,\n\r\t");
<         while(ajStrTokenNextParse(&handle, &seqQualStr))
<         {
<             if(i >= seqlen){
<                 if(!badwarn)
<                     ajWarn("Bad quality '%S' for base %d "
<                        "in fastq-int format\n",
<                        qualstr, i);
<                 badwarn = ajTrue;
<             }
<             else if(!ajStrToDouble(seqQualStr, &sval))
<             {
<                 if(!badwarn)
<                     ajWarn("Bad quality '%S' for base %d "
< 			   "in fastq-int format\n",
< 			   qualstr, i);
<                 badwarn = ajTrue;
<                 i++;
<             }
<             else
<             {
<                 pval = pow(10.0, (sval / -10.0));
<                 qval = pval / (1.0 + pval);
<                 thys->Accuracy[i++] = -10.0 * log10(qval);
<             }
<         }
<         seqin->Input->Records++;
<         ajDebug("++fastq append qualities '%S'\n", seqReadLine);
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
<     }
< 
<     if(i != seqlen)
<     {
< 	ajWarn("length mismatch seq: %u quality: %u\n",
<                 seqlen, i);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	return ajFalse;
<     }
< 
<     if(ok)
<         ajFilebuffClearStore(buff, 1,
<                              seqReadLine, seqin->Input->Text, &thys->TextPtr);
<     else
<         ajFilebuffClear(buff, 0);
< 
<     thys->Fpos = fpos;
< 
<     ajDebug("started at fpos %Ld ok: %B fposb: %Ld\n", fpos, ok, fposb);
< 
<     ajStrTokenDel(&handle);
< 
<     return ajTrue;
< }
---
> //static AjBool seqReadFastqInt(AjPSeq thys, AjPSeqin seqin)
> //{
> //    AjPFilebuff buff;
> //    AjPStr id   = NULL;
> //    AjPStr acc  = NULL;
> //    AjPStr sv   = NULL;
> //    AjPStr desc = NULL;
> //
> //    ajuint seqlen = 0;
> //    AjPStr qualstr = NULL;
> //
> //    const char *cp;
> //    ajlong fpos     = 0;
> //    ajlong fposb    = 0;
> //    AjBool ok       = ajTrue;
> //
> //    const AjPStr badstr = NULL;
> //
> //    ajuint i;
> //    AjBool badwarn = ajFalse;
> //    double sval;
> //    double pval;
> //    double qval;
> //
> //    ajDebug("seqReadFastqInt\n");
> //
> //    buff = seqin->Input->Filebuff;
> //
> //    ok = ajTextinStoreReadline(seqin->Input, &seqReadLine,  &thys->TextPtr);
> //    if(!ok)
> //      return ajFalse;
> //
> //    fpos = ajTextinGetFpos(seqin->Input);
> //
> //    ajDebug("First line: %S\n", seqReadLine);
> //
> //    cp = ajStrGetPtr(seqReadLine);
> //
> //    if(*cp != '@')
> //    {
> //      ajDebug("first line is not FASTQ\n");
> //      ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> //
> //      return ajFalse;
> //    }
> //
> //    if(!ajSeqParseFastq(seqReadLine, &id, &desc))
> //    {
> //      ajDebug("first line did not parse as FASTQ\n");
> //      ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> //
> //      return ajFalse;
> //    }
> //
> //    seqSetNameNospace(&thys->Name, id);
> //
> //    if(ajStrGetLen(sv))
> //      seqSvSave(thys, sv);
> //
> //    if(ajStrGetLen(acc))
> //      seqAccSave(thys, acc);
> //
> //    ajStrAssignS(&thys->Desc, desc);
> //    ajStrDel(&id);
> //    ajStrDel(&acc);
> //    ajStrDel(&sv);
> //    ajStrDel(&desc);
> //
> //    ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> //    while(ok &&
> //          !ajStrPrefixC(seqReadLine, "+"))
> //    {
> //        badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                  seqin->Input->Format);
> //
> //        if(badstr)
> //            ajWarn("Sequence '%S' has bad character(s) '%S'",
> //                   thys->Name, badstr);
> //
> //        ajDebug("++fastq append line '%S'\n", seqReadLine);
> //        ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> //        ajDebug("++fastq sequence %4u '%S'\n",
> //                ajStrGetLen(thys->Seq), thys->Seq);
> //    }
> //
> //    if(!ok)
> //    {
> //      ajDebug("failed to find quality scores\n");
> //      ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> //
> //      return ajFalse;
> //    }
> //
> //    seqlen = ajStrGetLen(thys->Seq);
> //
> //    ok = ajTextinStoreReadline(seqin->Input, &seqReadLine,  &thys->TextPtr);
> //
> //    i=0;
> //    if(seqlen > thys->Qualsize)
> //    {
> //        AJCRESIZE(thys->Accuracy, seqlen);
> //        thys->Qualsize = seqlen;
> //    }
> //
> //    ajStrAssignClear(&seqQualStr);
> //    while(ok &&
> //          (!ajStrPrefixC(seqReadLine, "@")))
> //    {
> //      ajStrTokenAssignC(&handle, seqReadLine, " ,\n\r\t");
> //        while(ajStrTokenNextParse(seqHandle, &seqQualStr))
> //        {
> //            if(i >= seqlen){
> //                if(!badwarn)
> //                    ajWarn("Bad quality '%S' for base %d "
> //                       "in fastq-int format\n",
> //                       qualstr, i);
> //                badwarn = ajTrue;
> //            }
> //            else if(!ajStrToDouble(seqQualStr, &sval))
> //            {
> //                if(!badwarn)
> //                    ajWarn("Bad quality '%S' for base %d "
> //                         "in fastq-int format\n",
> //                         qualstr, i);
> //                badwarn = ajTrue;
> //                i++;
> //            }
> //            else
> //            {
> //                pval = pow(10.0, (sval / -10.0));
> //                qval = pval / (1.0 + pval);
> //                thys->Accuracy[i++] = -10.0 * log10(qval);
> //            }
> //        }
> //
> //        ajDebug("++fastq append qualities '%S'\n", seqReadLine);
> //        ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> //    }
> //
> //    if(i != seqlen)
> //    {
> //      ajWarn("length mismatch seq: %u quality: %u\n",
> //                seqlen, i);
> //      ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> //
> //      return ajFalse;
> //    }
> //
> //    if(ok)
> //        ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
> //    else
> //        ajFilebuffClear(buff, 0);
> //
> //    thys->Fpos = fpos;
> //
> //    ajDebug("started at fpos %Ld ok: %B fposb: %Ld\n", fpos, ok, fposb);
> //
> //    ajStrTokenDel(&handle);
> //
> //    return ajTrue;
> //}
3300c3841
< /* @funcstatic seqReadFastqIllumina ********************************************
---
> /* @funcstatic seqReadFastqIllumina *******************************************
3308a3850,3851
> **
> ** @release 6.1.0
3331d3873
<     ajlong fposb    = 0;
3346,3347c3888
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3349c3890
< 	return ajFalse;
---
>         return ajFalse;
3351c3892
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
3359,3360c3900,3901
< 	ajDebug("first line is not FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line is not FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3362c3903
< 	return ajFalse;
---
>         return ajFalse;
3367,3368c3908,3909
< 	ajDebug("first line did not parse as FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line did not parse as FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3370c3911
< 	return ajFalse;
---
>         return ajFalse;
3376c3917
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
3379c3920
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
3387,3388c3928
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3392c3932,3933
<         badstr = seqAppendWarn(&thys->Seq, seqReadLine);
---
>         badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                seqin->Input->Format);
3397c3938
<         seqin->Input->Records++;
---
> 
3399,3400c3940
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3407,3408c3947,3948
< 	ajDebug("failed to find quality scores\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("failed to find quality scores\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3410c3950
< 	return ajFalse;
---
>         return ajFalse;
3415,3416c3955
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3426d3964
<         seqin->Input->Records++;
3428,3429c3966
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3442c3979
< 	ajDebug("length mismatch seq: %u quality: %u\n",
---
>         ajDebug("length mismatch seq: %u quality: %u\n",
3444c3981
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3446c3983
< 	return ajFalse;
---
>         return ajFalse;
3450,3451c3987
<         ajFilebuffClearStore(buff, 1,
<                              seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
3461c3997
<     
---
> 
3466c4002
< 	AJCRESIZE(thys->Accuracy, seqlen);
---
>         AJCRESIZE(thys->Accuracy, seqlen);
3482c4018
< 	{
---
>         {
3487c4023
< 	}
---
>         }
3489,3490c4025,4026
< 	{
< 	    ajWarn("FASTQ-ILLUMINA quality value too high '%F' '%S' '%c'",
---
>         {
>             ajWarn("FASTQ-ILLUMINA quality value too high '%F' '%S' '%c'",
3493c4029
< 	    iqual = qmax;
---
>             iqual = qmax;
3514c4050
< /* @funcstatic seqReadFastqSolexa ********************************************
---
> /* @funcstatic seqReadFastqSolexa *********************************************
3521a4058,4059
> **
> ** @release 6.1.0
3545d4082
<     ajlong fposb    = 0;
3565,3566c4102
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3568c4104
< 	return ajFalse;
---
>         return ajFalse;
3570c4106
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
3578,3579c4114,4115
< 	ajDebug("first line is not FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line is not FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3581c4117
< 	return ajFalse;
---
>         return ajFalse;
3586,3587c4122,4123
< 	ajDebug("first line did not parse as FASTQ\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line did not parse as FASTQ\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3589c4125
< 	return ajFalse;
---
>         return ajFalse;
3595c4131
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
3598c4134
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
3606,3607c4142
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3611c4146,4147
<         badstr = seqAppendWarn(&thys->Seq, seqReadLine);
---
>         badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                seqin->Input->Format);
3616c4152
<         seqin->Input->Records++;
---
> 
3618,3619c4154
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3626,3627c4161,4162
< 	ajDebug("failed to find quality scores\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("failed to find quality scores\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3629c4164
< 	return ajFalse;
---
>         return ajFalse;
3634,3635c4169
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3645d4178
<         seqin->Input->Records++;
3647,3648c4180
<         ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
<                                     seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3661c4193
< 	ajDebug("length mismatch seq: %u quality: %u\n",
---
>         ajDebug("length mismatch seq: %u quality: %u\n",
3663c4195
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3665c4197
< 	return ajFalse;
---
>         return ajFalse;
3669,3670c4201
<         ajFilebuffClearStore(buff, 1,
<                              seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
3680c4211
<     
---
> 
3706c4237
< 	{
---
>         {
3711c4242
< 	}
---
>         }
3713,3714c4244,4245
< 	{
< 	    ajWarn("FASTQ-SOLEXA quality value too high '%F' '%S' '%c'",
---
>         {
>             ajWarn("FASTQ-SOLEXA quality value too high '%F' '%S' '%c'",
3717c4248
< 	    iqual = qmax;
---
>             iqual = qmax;
3743a4275,4276
> **
> ** @release 1.0.0
3749,3750d4281
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
3764,3765c4295
<     ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fpos,
< 			     seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
3767c4297
< 	return ajFalse;
---
>         return ajFalse;
3769c4299
<     seqin->Input->Records++;
---
>     fpos = ajTextinGetFpos(seqin->Input);
3773c4303
< 	return ajFalse;
---
>         return ajFalse;
3779,3780c4309,4310
< 	ajDebug("first line is not FASTA\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line is not FASTA\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3782c4312
< 	return ajFalse;
---
>         return ajFalse;
3785,3788c4315,4318
<     ajStrTokenAssignC(&handle, seqReadLine, "> ");
<     ajStrTokenNextParseC(&handle, " \t\n\r", &token);
<     ajStrTokenNextParseC(&handle, " \t\n\r", &token);
<     seqSetName(thys, token);
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, "> ");
>     ajStrTokenStepC(seqHandle, " \t\n\r");
>     ajStrTokenNextParseC(seqHandle, " \t\n\r", &seqToken);
>     seqSetName(thys, seqToken);
3790c4320
<     ajStrTokenNextParse(&handle, &token);
---
>     ajStrTokenNextParse(seqHandle, &seqToken);
3792c4322
<     vacc = ajSeqtestIsSeqversion(token);
---
>     vacc = ajSeqtestIsSeqversion(seqToken);
3795,3797c4325,4327
< 	seqSvSave(thys, token);
< 	seqAccSave(thys, vacc);
< 	ajStrTokenNextParseC(&handle, "\n\r", &thys->Desc);
---
>         seqSvSave(thys, seqToken);
>         seqAccSave(thys, vacc);
>         ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc);
3799c4329
<     else if(ajSeqtestIsAccession(token))
---
>     else if(ajSeqtestIsAccession(seqToken))
3801,3802c4331,4332
< 	seqAccSave(thys, token);
< 	ajStrTokenNextParseC(&handle, "\n\r", &thys->Desc);
---
>         seqAccSave(thys, seqToken);
>         ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc);
3806c4336
< 	ajStrAssignS(&thys->Desc, token);
---
>         ajStrAssignS(&thys->Desc, seqToken);
3808,3812c4338,4342
< 	if(ajStrTokenNextParseC(&handle, "\n\r", &token))
< 	{
< 	    ajStrAppendC(&thys->Desc, " ");
< 	    ajStrAppendS(&thys->Desc, token);
< 	}
---
>         if(ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken))
>         {
>             ajStrAppendC(&thys->Desc, " ");
>             ajStrAppendS(&thys->Desc, seqToken);
>         }
3815,3816c4345,4346
<     ajStrDel(&token);
<     ajStrTokenDel(&handle);
---
>     ajStrDelStatic(&seqToken);
>     ajStrTokenReset(seqHandle);
3819,3820c4349,4350
<     {				       /* we have a sequence to use */
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
---
>     {                                  /* we have a sequence to use */
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
3822,3823c4352,4353
< 	if(seqin->Input->Text)
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
---
>         if(seqin->Input->Text)
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
3825c4355
< 	ajFilebuffClear(buff, 0);
---
>         ajFilebuffClear(buff, 0);
3833,3848c4363,4374
< 	ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				 seqin->Input->Text, &thys->TextPtr);
< 	while(ok && !ajStrPrefixC(seqReadLine, ">"))
< 	{
< 	    seqAppend(&thys->Seq, seqReadLine);
< 	    seqin->Input->Records++;
< 	    ok = ajBuffreadLinePosStore(buff, &seqReadLine, &fposb,
< 				     seqin->Input->Text, &thys->TextPtr);
< 	}
< 
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 seqReadLine, seqin->Input->Text,
<                                  &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         while(ok && !ajStrPrefixC(seqReadLine, ">"))
>         {
>             seqAppend(&thys->Seq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
3860a4387,4469
> /* @funcstatic seqReadGde *****************************************************
> **
> ** Given data in a sequence structure, tries to read everything needed
> ** using the GDE format
> **
> ** @param [w] thys [AjPSeq] Sequence object
> ** @param [u] seqin [AjPSeqin] Sequence input object
> ** @return [AjBool] ajTrue on success
> **
> ** @release 6.6.0
> ** @@
> ******************************************************************************/
> 
> static AjBool seqReadGde(AjPSeq thys, AjPSeqin seqin)
> {
>     AjPFilebuff buff;
> 
>     const char *cp;
>     AjBool ok       = ajTrue;
>     const AjPStr badstr = NULL;
>     ajlong fpos;
> 
>     ajDebug("seqReadGde\n");
> 
>     buff = seqin->Input->Filebuff;
> 
>     /* ajFilebuffTrace(buff); */
> 
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     if(!ok)
>         return ajFalse;
> 
>     fpos = ajTextinGetFpos(seqin->Input);
> 
>     ajDebug("First line: %S\n", seqReadLine);
> 
>     cp = ajStrGetPtr(seqReadLine);
> 
>     if(*cp != '#')
>     {
>         ajDebug("first line is not GDE\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>         return ajFalse;
>     }
> 
>     ajStrCutStart(&seqReadLine, 1);
> 
>     ajStrTokenAssign(&seqHandle, seqReadLine);
>     ajStrTokenNextParse(seqHandle, &seqToken);
> 
>     seqSetNameNospace(&thys->Name, seqToken);
> 
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     while(ok &&
>           !ajStrPrefixC(seqReadLine, "#"))
>     {
>         badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                seqin->Input->Format);
> 
>         if(badstr)
>             ajWarn("Sequence '%S' has bad character(s) '%S'",
>                    thys->Name, badstr);
> 
>         ajDebug("++fastq append line '%S'\n", seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ajDebug("++fastq sequence %4u '%S'\n",
>                 ajStrGetLen(thys->Seq), thys->Seq);
>     }
> 
>     if(ok)
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>     else
>         ajFilebuffClear(buff, 0);
> 
>     thys->Fpos = fpos;
> 
>     return ajTrue;
> }
> 
> 
> 
> 
3868a4478,4479
> **
> ** @release 1.0.0
3874d4484
<     AjPStr token  = NULL;
3878,3881c4488,4489
<     AjBool dofeat       = ajFalse;
< 
<     AjPStrTok handle2 = NULL;
<     AjPStr    token2  = NULL;
---
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
3892c4500
<     if(!token2)
---
>     if(!seqToken2)
3894,3895c4502,4503
< 	token2 = ajStrNew();
< 	seqReadLine2 = ajStrNew();
---
>         seqToken2 = ajStrNew();
>         seqReadLine2 = ajStrNew();
3899c4507
< 	ajStrAssignC(&seqFtFmtPir, "pir");
---
>         ajStrAssignC(&seqFtFmtPir, "pir");
3902c4510
< 	seqRegNbrfId = ajRegCompC("^>(..)[>;]([^ \t\n]+)");
---
>         seqRegNbrfId = ajRegCompC("^>(..)[>;]([^ \t\n]+)");
3907,3908c4515
<         if(!ajBuffreadLineStore(buff, &seqReadLine,
<                                 seqin->Input->Text, &thys->TextPtr))
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
3914c4521
<     
---
> 
3919,3920c4526,4527
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
3923c4530
<     ajRegSubI(seqRegNbrfId, 1, &token);
---
>     ajRegSubI(seqRegNbrfId, 1, &seqToken);
3926c4533
< 	    thys->Name, token, ajStrGetCharFirst(token));
---
>             thys->Name, seqToken, ajStrGetCharFirst(seqToken));
3930,3933c4537,4540
<      ** token has the NBRF 2-char type. First char is the type
<      ** and second char is Linear, Circular, or 1
<      ** or, for GCG databases, this is just '>>'
<      */
---
>     ** token has the NBRF 2-char type. First char is the type
>     ** and second char is Linear, Circular, or 1
>     ** or, for GCG databases, this is just '>>'
>     */
3935c4542
<     switch(toupper((ajint) ajStrGetCharFirst(token)))
---
>     switch(toupper((ajint) ajStrGetCharFirst(seqToken)))
3940,3943c4547,4550
<             break;
<         case 'B':				/* used by DIANA */
<         case 'D':				/* DNA */
<         case 'R':				/* RNA */
---
>         break;
>         case 'B':                               /* used by DIANA */
>         case 'D':                               /* DNA */
>         case 'R':                               /* RNA */
3945c4552
<             break;
---
>         break;
3947c4554
<             ajWarn("Unknown NBRF sequence type '%S'", token);
---
>             ajWarn("Unknown NBRF sequence type '%S'", seqToken);
3952,3953c4559
<     if(!ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
<                             &thys->TextPtr))
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
3955c4561
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
3957c4563
< 	return ajFalse;
---
>         return ajFalse;
3963c4569
< 	ajStrCutEnd(&thys->Desc, 1);
---
>         ajStrCutEnd(&thys->Desc, 1);
3967,3968c4573,4576
<     ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
<                              &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>     dofeat = ajFalse;
>     tryfeat = seqinUfoLocal(seqin);
3972,4055c4580,4656
< 	if(ajStrGetCharPos(seqReadLine, 1) != ';')
< 	    seqAppend(&thys->Seq, seqReadLine);
< 	else
< 	{
< 	    if(ajStrPrefixC(seqReadLine, "C;Accession:"))
< 	    {
< 		ajStrAssignC(&seqReadLine2,ajStrGetPtr(seqReadLine)+13);
< 		ajStrTokenAssignC(&handle2,seqReadLine2, " ;\n\r");
< 
< 		while(ajStrTokenNextParse(&handle2, &token2))
< 		    seqAccSave(thys, token2);
< 	    }
< 
< 	    if(ajStrPrefixC(seqReadLine, "C;Species:"))
< 	    {
< 		ajStrAssignC(&seqReadLine2,ajStrGetPtr(seqReadLine)+11);
< 		ajStrTokenAssignC(&handle2,seqReadLine2, ";.\n\r");
< 
< 		while(ajStrTokenNextParse(&handle2, &token2))
< 		    seqTaxSave(thys, token2, 1);
< 	    }
< 
< 	    if(ajStrGetCharFirst(seqReadLine) == 'R')
< 	    {		     /* skip reference lines with no prefix */
< 		while((ok=ajBuffreadLineStore(buff,&seqReadLine,
< 					     seqin->Input->Text, &thys->TextPtr)))
< 		    if(ajStrGetCharPos(seqReadLine,1)==';' ||
< 		       ajStrGetCharFirst(seqReadLine)=='>')
< 			break;		/* X; line or next sequence */
< 
< 		if(ok)
< 		    continue;
< 	    }
< 	    else if(ajStrGetCharFirst(seqReadLine) == 'F')
< 	    {				/* feature lines */
< 		if(seqinUfoLocal(seqin))
< 		{
< 		    if(!dofeat)
< 		    {
< 			dofeat = ajTrue;
< 			ajFeattabinDel(&seqin->Ftquery);
< 			seqin->Ftquery = ajFeattabinNewSS(seqFtFmtPir,
< 							  thys->Name,
< 							  "N");
< 			ajDebug("seqin->Ftquery Filebuff %x\n",
< 				seqin->Ftquery->Input->Filebuff);
< 		    }
< 
< 		    ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
<                                     seqReadLine);
< 		    /* ajDebug("NBRF FEAT saved line:\n%S", seqReadLine); */
< 		}
< 	    }
< 	}
< 	if(ok)
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 
< 	/* SRS 7 and SRS 8.0 put an extra ID line in here */
< 
< 	/* SRS 8.1 is even worse - it has a peculiar bug that repeats
< 	   the ID line but with a few digits in front, and then repeats the
< 	   description */
< 
< 	/* just for another oddity ... the extra ID line always starts >P1;
< 	   even if the protein is a fragment */
< 
< 	if(ok && !ajStrGetLen(thys->Seq) &&
< 	   (ajStrFindAnyK(seqReadLine, '>') != -1))
< 	{
< 	    ajStrAssignS(&tmpline, seqReadLine);
< 	    ajStrTrimStartC(&tmpline,"0123456789");
< 	    ajStrCutStart(&tmpline, 4);
< 
< 	    if(ajStrMatchS(tmpline, idline))
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 
< 		if(!ajStrIsWhite(seqReadLine)) /* SRS 8.1 description line */
< 		    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					    seqin->Input->Text, &thys->TextPtr);
< 	    }
< 	}
---
>         if(ajStrGetCharPos(seqReadLine, 1) != ';')
>             seqAppend(&thys->Seq, seqReadLine);
>         else
>         {
>             if(ajStrPrefixC(seqReadLine, "C;Accession:"))
>             {
>                 ajStrAssignC(&seqReadLine2,ajStrGetPtr(seqReadLine)+13);
>                 ajStrTokenAssignC(&seqHandle2,seqReadLine2, " ;\n\r");
> 
>                 while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>                     seqAccSave(thys, seqToken2);
>             }
> 
>             if(ajStrPrefixC(seqReadLine, "C;Species:"))
>             {
>                 ajStrAssignC(&seqReadLine2,ajStrGetPtr(seqReadLine)+11);
>                 ajStrTokenAssignC(&seqHandle2,seqReadLine2, ";.\n\r");
> 
>                 while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>                     seqTaxSave(thys, seqToken2, 1);
>             }
> 
>             if(ajStrGetCharFirst(seqReadLine) == 'R')
>             {                /* skip reference lines with no prefix */
>                 while((ok=ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr)))
>                     if(ajStrGetCharPos(seqReadLine,1)==';' ||
>                        ajStrGetCharFirst(seqReadLine)=='>')
>                         break;          /* X; line or next sequence */
> 
>                 if(ok)
>                     continue;
>             }
>             else if(tryfeat && ajStrGetCharFirst(seqReadLine) == 'F')
>             {                           /* feature lines */
>                 if(!dofeat)
>                 {
>                     dofeat = ajTrue;
>                     ajFeattabinDel(&seqin->Ftquery);
>                     seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtPir,
>                                                            thys->Name, "N");
>                     ajDebug("seqin->Ftquery Filebuff %x\n",
>                             seqin->Ftquery->Input->Filebuff);
>                 }
> 
>                 ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
>                                 seqReadLine);
>                 /* ajDebug("NBRF FEAT saved line:\n%S", seqReadLine); */
>             }
>         }
> 
>         if(ok)
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         /* SRS 7 and SRS 8.0 put an extra ID line in here */
> 
>         /* SRS 8.1 is even worse - it has a peculiar bug that repeats
>            the ID line but with a few digits in front, and then repeats the
>            description */
> 
>         /* just for another oddity ... the extra ID line always starts >P1;
>            even if the protein is a fragment */
> 
>         if(ok && !ajStrGetLen(thys->Seq) &&
>            (ajStrFindAnyK(seqReadLine, '>') != -1))
>         {
>             ajStrAssignS(&tmpline, seqReadLine);
>             ajStrTrimStartC(&tmpline,"0123456789");
>             ajStrCutStart(&tmpline, 4);
> 
>             if(ajStrMatchS(tmpline, idline))
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>                 if(ok && !ajStrIsWhite(seqReadLine)) /* SRS 8.1 desc line */
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
4060c4661
< 	ajStrCutEnd(&thys->Seq, 1);
---
>         ajStrCutEnd(&thys->Seq, 1);
4063,4064c4664
< 	ajFilebuffClearStore(buff, 1,
< 			     seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
4066c4666
< 	ajFilebuffClear(buff, 0);
---
>         ajFilebuffClear(buff, 0);
4070,4073c4670,4673
< 	ajDebug("seqin->Ftquery Filebuff %x\n",
< 		seqin->Ftquery->Input->Filebuff);
< 	ajFeattableDel(&seqin->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
---
>         ajDebug("seqin->Ftquery Filebuff %x\n",
>                 seqin->Ftquery->Input->Filebuff);
>         ajFeattableDel(&seqin->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
4076,4077c4676,4677
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>         /* ajFeattableTrace(thys->Fttable); */
>         ajFeattabinClear(seqin->Ftquery);
4083,4085c4683,4818
<     ajStrTokenDel(&handle2);
<     ajStrDel(&token);
<     ajStrDel(&token2);
---
>     ajStrTokenReset(seqHandle2);
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
> 
>     return ajTrue;
> }
> 
> 
> 
> 
> /* @funcstatic seqReadNibble **************************************************
> **
> ** Given data in a sequence structure, tries to read everything needed
> ** using the half-byte comressed nibble format
> **
> ** @param [w] thys [AjPSeq] Sequence object
> ** @param [u] seqin [AjPSeqin] Sequence input object
> ** @return [AjBool] ajTrue on success
> **
> ** @release 6.6.0
> ** @@
> ******************************************************************************/
> 
> static AjBool seqReadNibble(AjPSeq thys, AjPSeqin seqin)
> {
>     AjPFilebuff buff;
>     AjPFile fp;
> 
>     ajulong filestat = 0L;
>     AjBool ok       = ajTrue;
>     union lbytes
>     {
>         char chars[4];
>         ajuint i;
>     } seqbyte;
> 
>     ajuint seqlen = 0;
>     ajuint buflen;
>     ajuint base1;
>     ajuint base2;
>     AjPStr buf = NULL;
>     char *cbuf;
>     ajuint i;
>     ajuint j;
> 
>     AjBool doreverse = AJFALSE;
>     const char *nibblechars = "TCAGNNNNTCAGNNNN";
> 
>     ajDebug("seqReadNibble\n");
> 
>     buff = seqin->Input->Filebuff;
>     fp = ajFilebuffGetFile(buff);
> 
>     if(ajFilebuffIsEnded(buff))
>     {
>         ajDebug("seqReadNibble buffer already ended\n");
>        
>         return ajFalse;
>     }
> 
>     filestat = ajFileSeek(fp, 0L, SEEK_SET);
> 
>     if(filestat)
>     {
>         ajDebug("seqReadNibble rewind failed errno %d: %s\n",
>                 errno, strerror(errno));
>         return ajFalse;
>     }
>     else
>     {
>         if(ajFilebuffIsEnded(buff))
>         {
>             ajFileSeek(fp, 0L, SEEK_END);
>             return ajFalse;
>         }
> 
>         ajReadbinUint4(fp, &seqbyte.i);
>         if(seqbyte.i == 0x6BE9eD3A)
>         {
>             ajDebug("seqReadNibble: Magic number found\n");
>         }
>         else if(seqbyte.i == 0x3AEDE96B)
>         {
>             ajDebug("seqReadNibble: Magic number is reversed\n");
>             doreverse = ajTrue;
>         }
>         else
>         {
>             ajDebug("seqReadNibble: Magic number not found (%x)\n", seqbyte.i);
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrAssignClear(&thys->Seq);
> 
>             return ajFalse;
>         }
> 
>         ajReadbinUint4(fp, &seqlen);
>         if(doreverse)
>             ajByteRevUint(&seqlen);
> 
>         buflen = (1+seqlen)/2;
>         buf = ajStrNewRes(buflen);
>         ajStrSetValidLen(&buf, buflen);
>         cbuf = ajStrGetuniquePtr(&buf);
> 
>         ajReadbinBinary(fp, buflen, 1, cbuf);
> 
>         j = 0;
>         for(i=0; i < buflen; i++) 
>         {
>             seqbyte.chars[0] = cbuf[i];
>             base2 = seqbyte.chars[0] & 0x0F;
>             base1 = (seqbyte.chars[0] >> 4);
>             seqAppendK(&thys->Seq, nibblechars[base1]);
>             if(++j < seqlen)
>                 seqAppendK(&thys->Seq, nibblechars[base2]);
>             ++j;
>         }
>         
>         if(!ok)
>         {
>             ajFileSeek(fp,(ajlong) filestat,0);
> 
>             if(seqin->Input->Text)
>                 ajStrAssignC(&thys->TextPtr, "");
> 
>             ajFilebuffResetPos(buff);
> 
>             return ajFalse;
>         }
>     }
> 
>     ajFilebuffClear(buff, -1);
>     buff->File->End = ajTrue;   /* set to avoid rereading */
> 
>     if(!ajTextinGetRecords(seqin->Input))
>         return ajFalse;
4100a4834,4835
> **
> ** @release 1.0.0
4115,4116c4850,4851
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
4118,4121c4853,4856
<         ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                  seqin->Input->Text, &thys->TextPtr);
<     if(!ok)
< 	return ajFalse;
---
>     {
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     }
4123c4858,4859
<     seqin->Input->Records++;
---
>     if(!ok)
>         return ajFalse;
4131c4867
< 	ajSeqSetNuc(thys);
---
>         ajSeqSetNuc(thys);
4133c4869
< 	ajSeqSetProt(thys);
---
>         ajSeqSetProt(thys);
4137,4138c4873,4874
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
4145,4153c4881,4887
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(ok)
< 	{
< 	    seqin->Input->Records++;
< 	    seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
< 	    ajDebug("line %d seqlen: %d ok: %B\n",
< 		    seqin->Input->Records, ajSeqGetLen(thys), ok);
< 	}
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(ok)
>         {
>             seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
>             ajDebug("line %d seqlen: %d ok: %B\n",
>                     ajTextinGetRecords(seqin->Input), ajSeqGetLen(thys), ok);
>         }
4157c4891
< 	    seqin->Input->Records, ajSeqGetLen(thys), len, ok);
---
>             ajTextinGetRecords(seqin->Input), ajSeqGetLen(thys), len, ok);
4161d4894
< 
4175a4909,4910
> **
> ** @release 1.0.0
4181d4915
<     AjPStrTok handle = NULL;
4196,4197c4930
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
4199c4932
< 	return ajFalse;
---
>         return ajFalse;
4210,4216c4943,4949
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrDel(&id);
< 	ajStrDel(&acc);
< 	ajStrDel(&sv);
< 	ajStrDel(&gi);
< 	ajStrDel(&db);
< 	ajStrDel(&desc);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrDel(&id);
>         ajStrDel(&acc);
>         ajStrDel(&sv);
>         ajStrDel(&gi);
>         ajStrDel(&db);
>         ajStrDel(&desc);
4218c4951
< 	return ajFalse;
---
>         return ajFalse;
4222c4955
< 	    id, acc, sv, gi, db, thys->Setdb, desc);
---
>             id, acc, sv, gi, db, thys->Setdb, desc);
4228c4961
< 	ajStrAssignS(&thys->Gi, gi);
---
>         ajStrAssignS(&thys->Gi, gi);
4231c4964
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
4234c4967
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
4241,4242c4974,4975
<     {				       /* we have a sequence to use */
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
---
>     {                                  /* we have a sequence to use */
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
4244,4245c4977,4978
< 	if(seqin->Input->Text)
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
---
>         if(seqin->Input->Text)
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
4247,4248c4980
< 	ajFilebuffClearStore(buff, 1,
< 			     seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
4256,4275c4988,5004
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	while(ok && !ajStrPrefixC(seqReadLine, ">"))
< 	{
< 	    badstr = seqAppendWarn(&thys->Seq, seqReadLine);
< 
< 	    if(badstr)
< 		ajWarn("Sequence '%S' has bad character(s) '%S'",
< 			   thys->Name, badstr);
< 	    seqin->Input->Records++;
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
< 
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 seqReadLine, seqin->Input->Text,
<                                  &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         while(ok && !ajStrPrefixC(seqReadLine, ">"))
>         {
>             badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                    seqin->Input->Format);
> 
>             if(badstr)
>                 ajWarn("Sequence '%S' has bad character(s) '%S'",
>                        thys->Name, badstr);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
4279d5007
<     ajStrTokenDel(&handle);
4301a5030,5031
> **
> ** @release 4.1.0
4307d5036
<     AjPStrTok handle = NULL;
4322,4323c5051
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
4325c5053
< 	return ajFalse;
---
>         return ajFalse;
4337,4343c5065,5071
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrDel(&id);
< 	ajStrDel(&db);
< 	ajStrDel(&acc);
< 	ajStrDel(&sv);
< 	ajStrDel(&gi);
< 	ajStrDel(&desc);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrDel(&id);
>         ajStrDel(&db);
>         ajStrDel(&acc);
>         ajStrDel(&sv);
>         ajStrDel(&gi);
>         ajStrDel(&desc);
4345c5073
< 	return ajFalse;
---
>         return ajFalse;
4349c5077
< 	    id, acc, sv, gi, db, thys->Setdb, desc);
---
>             id, acc, sv, gi, db, thys->Setdb, desc);
4352c5080
<     
---
> 
4357c5085
< 	seqSvSave(thys, sv);
---
>         seqSvSave(thys, sv);
4360c5088
< 	seqAccSave(thys, acc);
---
>         seqAccSave(thys, acc);
4367,4368c5095,5096
<     {				       /* we have a sequence to use */
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
---
>     {                                  /* we have a sequence to use */
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
4370,4371c5098,5099
< 	if(seqin->Input->Text)
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
---
>         if(seqin->Input->Text)
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
4373,4374c5101
< 	ajFilebuffClearStore(buff, 1,
< 			     seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
4382,4383c5109
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
4387,4393c5113,5118
< 	while(ok && !ajStrPrefixC(seqReadLine, ">"))
< 	{
< 	    seqAppend(&thys->Seq, seqReadLine);
< 	    seqin->Input->Records++;
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
---
>         while(ok && !ajStrPrefixC(seqReadLine, ">"))
>         {
>             seqAppend(&thys->Seq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
4395,4399c5120,5123
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 seqReadLine, seqin->Input->Text, &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
---
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
4402d5125
<     ajStrTokenDel(&handle);
4429a5153,5154
> **
> ** @release 2.3.0
4453c5178
< 	selex = seqin->SeqData;
---
>         selex = seqin->SeqData;
4456c5181,5234
< 	ajFilebuffSetBuffered(buff);    /* must buffer to test sequences */
---
>         ajFilebuffSetBuffered(buff);    /* must buffer to test sequences */
> 
>         /* First count the sequences, and get any header information */
>         while(!isseq && (ok=ajBuffreadLine(buff,&line)))
>         {
>             if(first)
>             {
>                 first=ajFalse;
> 
>                 if(!ajStrPrefixC(line,"#"))
>                 {
>                     ajStrDel(&line);
>                     ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>                     return ajFalse;
>                 }
>             }
> 
>             ajStrRemoveWhiteExcess(&line);
>             p = ajStrGetPtr(line);
> 
>             if(!*p || *p=='#')
>                 continue;
>             else
>                 isseq = ajTrue;
>         }
> 
>         if(!ok && !isseq)
>             return ajFalse;
>         ++n;
> 
>         ok = ajTrue;
> 
>         while(ok && ajBuffreadLine(buff,&line))
>         {
>             ajStrRemoveWhiteExcess(&line);
>             p = ajStrGetPtr(line);
> 
>             if(*p=='#')
>                 continue;
> 
>             if(!*p)
>                 ok = ajFalse;
>             else
>                 ++n;
>         }
> 
>         ajFilebuffClear(buff,-1);
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         buff->Fpos = 0;
>         ajFileSeek(buff->File, 0L, 0);
>         selex = selexNew(n);
> 
>         /* now read it for real */
4458,4549c5236,5265
< 	/* First count the sequences, and get any header information */
< 	while(!isseq && (ok=ajBuffreadLine(buff,&line)))
< 	{
< 	    if(first)
< 	    {
< 		first=ajFalse;
< 
< 		if(!ajStrPrefixC(line,"#"))
< 		{
< 		    ajStrDel(&line);
< 		    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 		    return ajFalse;
< 		}
< 	    }
< 
< 	    ajStrRemoveWhiteExcess(&line);
< 	    p = ajStrGetPtr(line);
< 
< 	    if(!*p || *p=='#')
< 		continue;
< 	    else
< 		isseq = ajTrue;
< 	}
< 
< 	if(!ok && !isseq)
< 	    return ajFalse;
< 	++n;
< 
< 	ok = ajTrue;
< 
< 	while(ok && ajBuffreadLine(buff,&line))
< 	{
< 	    ajStrRemoveWhiteExcess(&line);
< 	    p = ajStrGetPtr(line);
< 
< 	    if(*p=='#')
< 		continue;
< 
< 	    if(!*p)
< 		ok = ajFalse;
< 	    else
< 		++n;
< 	}
< 
< 	ajFilebuffClear(buff,-1);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	buff->Fpos = 0;
< 	ajFileSeek(buff->File, 0L, 0);
< 	selex = selexNew(n);
< 
< 	/* now read it for real */
< 
< 	while(head && ajBuffreadLineStore(buff,&line,
< 					 seqin->Input->Text, &thys->TextPtr))
< 	{
< 	    if(ajStrPrefixC(line,"#=RF") ||ajStrPrefixC(line,"#=CS"))
< 		break;
< 
< 	    if(ajStrPrefixC(line,"#="))
< 	    {
< 		head=seqSelexHeader(&selex,line,&named,&sqcnt);
< 		continue;
< 	    }
< 
< 	    c = *ajStrGetPtr(line);
< 
< 	    if(c>='0')
< 		head = ajFalse;
< 	}
< 
< 	/* Should now be at start of first block, whether RF or sequence */
< 	ajDebug("First Block Line: %S",line);
< 
< 	ok = ajTrue;
< 
< 	while(ok && !ajStrPrefixC(line, "# ID"))
< 	{
< 	    seqSelexReadBlock(&selex,&named,n,&line,buff,
< 			      seqin->Input->Text, &thys->TextPtr);
< 	    ok = ajBuffreadLineStore(buff,&line,
< 				     seqin->Input->Text, &thys->TextPtr);
< 	    ajDebug("... in loop ok: %B\n", ok);
< 	}
< 
< 	ajDebug(" Block done. More data (ok): %B\n", ok);
< 
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 line, seqin->Input->Text, &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
---
>         while(head && ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr))
>         {
>             if(ajStrPrefixC(line,"#=RF") ||ajStrPrefixC(line,"#=CS"))
>                 break;
> 
>             if(ajStrPrefixC(line,"#="))
>             {
>                 head=seqSelexHeader(&selex,line,&named,&sqcnt);
>                 continue;
>             }
> 
>             c = *ajStrGetPtr(line);
> 
>             if(c>='0')
>                 head = ajFalse;
>         }
> 
>         /* Should now be at start of first block, whether RF or sequence */
>         ajDebug("First Block Line: %S",line);
> 
>         ok = ajTrue;
> 
>         while(ok && !ajStrPrefixC(line, "# ID"))
>         {
>             seqSelexReadBlock(&selex,&named,n,&line,seqin, &thys->TextPtr);
>             ok = ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr);
>             ajDebug("... in loop ok: %B\n", ok);
>         }
> 
>         ajDebug(" Block done. More data (ok): %B\n", ok);
4551c5267,5272
< 	seqin->SeqData = selex;
---
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, line, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
> 
>         seqin->SeqData = selex;
4558,4560c5279,5281
< 	selexDel(&selex);
< 	seqin->SeqData = NULL;
< 	ajStrDel(&line);
---
>         selexDel(&selex);
>         seqin->SeqData = NULL;
>         ajStrDel(&line);
4562c5283
< 	return ajFalse;
---
>         return ajFalse;
4587a5309,5310
> **
> ** @release 2.3.0
4596d5318
<     AjPStr      token = NULL;
4617c5339
< 	    ajFilebuffIsEof(buff), seqin->SeqData);
---
>             ajFilebuffIsEof(buff), seqin->SeqData);
4619c5341
< 	stock = seqin->SeqData;
---
>         stock = seqin->SeqData;
4622,4623c5344,5345
< 	ajFilebuffSetBuffered(buff); /* must buffer to test sequences */
< 	ok=ajBuffreadLineStore(buff, &line, seqin->Input->Text, &thys->TextPtr);
---
>         ajFilebuffSetBuffered(buff); /* must buffer to test sequences */
>         ok=ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr);
4626,4647c5348,5369
< 	if(!ok || !ajStrPrefixC(line,"# STOCKHOLM 1."))
< 	{
< 	    if (ok)
< 		ajDebug("Stockholm: bad first line: %S", line);
< 	    else
< 		ajDebug("Stockholm: no first line\n");
< 
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    ajStrDel(&line);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajDebug("Stockholm: good first line: %S", line);
< 
< 	while(ok && (ajStrPrefixC(line, "#") || !ajStrGetLen(line)))
< 	{
< 	    if(ajStrPrefixC(line,"#=GF SQ"))
< 	    {
< 		ajFmtScanS(line,"%*s%*s%d",&n);
< 		ajDebug("Stockholm: parsed SQ line of %d sequences\n", n);
< 	    }
---
>         if(!ok || !ajStrPrefixC(line,"# STOCKHOLM 1."))
>         {
>             if (ok)
>                 ajDebug("Stockholm: bad first line: %S", line);
>             else
>                 ajDebug("Stockholm: no first line\n");
> 
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrDel(&line);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("Stockholm: good first line: %S", line);
> 
>         while(ok && (ajStrPrefixC(line, "#") || !ajStrGetLen(line)))
>         {
>             if(ajStrPrefixC(line,"#=GF SQ"))
>             {
>                 ajFmtScanS(line,"%*s%*s%d",&n);
>                 ajDebug("Stockholm: parsed SQ line of %d sequences\n", n);
>             }
4649c5371
< 	    ok=ajBuffreadLineStore(buff, &line, seqin->Input->Text, &thys->TextPtr);
---
>             ok=ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr);
4651,4652c5373,5374
< 	    ajDebug("Stockholm: SQ search: %S\n", line);
< 	}
---
>             ajDebug("Stockholm: SQ search: %S\n", line);
>         }
4654,4658c5376,5380
< 	if (!n)				/* no SQ line, count first block */
< 	{
< 	    while(ok && ajStrGetLen(line))
< 	    {
< 		if(!ajStrPrefixC(line, "#") &&
---
>         if (!n)                         /* no SQ line, count first block */
>         {
>             while(ok && ajStrGetLen(line))
>             {
>                 if(!ajStrPrefixC(line, "#") &&
4662,4663c5384
< 		ok=ajBuffreadLineStore(buff,&line,
<                                        seqin->Input->Text, &thys->TextPtr);
---
>                 ok=ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr);
4665,4666c5386,5387
< 		ajDebug("Stockholm: block %d read: %S\n", n, line);
< 	    }
---
>                 ajDebug("Stockholm: block %d read: %S\n", n, line);
>             }
4668,4669c5389,5390
< 	    ajDebug("Stockholm: read block of %d sequences\n", n);
< 	}
---
>             ajDebug("Stockholm: read block of %d sequences\n", n);
>         }
4671c5392
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
4673,4674c5394
< 	ok=ajBuffreadLineStore(buff,&line,
< 			       seqin->Input->Text, &thys->TextPtr);
---
>         ok=ajTextinStoreReadline(seqin->Input, &line, &thys->TextPtr);
4676c5396
< 	stock = stockholmNew(n);
---
>         stock = stockholmNew(n);
4678c5398
< 	ajDebug("Created stockholm data object size: %d\n", n);
---
>         ajDebug("Created stockholm data object size: %d\n", n);
4680,4682c5400,5402
< 	word  = ajStrNew();
< 	token = ajStrNew();
< 	post  = ajStrNew();
---
>         word  = ajStrNew();
>         post  = ajStrNew();
>         ajStrAssignClear(&seqToken);
4684,4685c5404,5405
< 	if(!seqRegStockholmSeq)
< 	    seqRegStockholmSeq = ajRegCompC("^([^ \t\n]+)[ \t]+"
---
>         if(!seqRegStockholmSeq)
>             seqRegStockholmSeq = ajRegCompC("^([^ \t\n]+)[ \t]+"
4687,4694c5407,5414
< 	while(ok && !ajStrPrefixC(line,"//"))
< 	{
< 	    if(ajRegExec(seqRegStockholmSeq,line))
< 	    {
< 		ajRegSubI(seqRegStockholmSeq,1,&word);
< 		ajRegSubI(seqRegStockholmSeq,2,&token);
< 		ajRegPost(seqRegStockholmSeq,&post);
< 		ajStrRemoveLastNewline(&post);
---
>         while(ok && !ajStrPrefixC(line,"//"))
>         {
>             if(ajRegExec(seqRegStockholmSeq,line))
>             {
>                 ajRegSubI(seqRegStockholmSeq,1,&word);
>                 ajRegSubI(seqRegStockholmSeq,2,&seqToken);
>                 ajRegPost(seqRegStockholmSeq,&post);
>                 ajStrRemoveLastNewline(&post);
4697,4797c5417,5517
<                         word, token, post);
< 		if(!ajStrCmpC(word,"#=GF"))
< 		{
< 		    if(!ajStrCmpC(token,"ID"))
< 			ajStrAssignS(&stock->id,post);
< 		    else if(!ajStrCmpC(token,"AC"))
< 			ajStrAssignS(&stock->ac,post);
< 		    else if(!ajStrCmpC(token,"DE"))
< 			ajStrAssignS(&stock->de,post);
< 		    else if(!ajStrCmpC(token,"AU"))
< 			ajStrAssignS(&stock->au,post);
< 		    else if(!ajStrCmpC(token,"AL"))
< 			ajStrAssignS(&stock->al,post);
< 		    else if(!ajStrCmpC(token,"SE"))
< 			ajStrAssignS(&stock->se,post);
< 		    else if(!ajStrCmpC(token,"TP"))
< 			ajStrAssignS(&stock->se,post);
< 		    else if(!ajStrCmpC(token,"GA"))
< 			ajFmtScanS(post,"%d%d",&stock->ga[0],
< 				   &stock->ga[1]);
< 		    else if(!ajStrCmpC(token,"TC"))
< 			ajFmtScanS(post,"%f%f",&stock->tc[0],
< 				   &stock->tc[1]);
< 		    else if(!ajStrCmpC(token,"NC"))
< 			ajFmtScanS(post,"%f%f",&stock->nc[0],
< 				   &stock->nc[1]);
< 		    else if(!ajStrCmpC(token,"BM"))
< 		    {
< 			if(bmf)
< 			{
< 			    bmf = ajFalse;
< 			    ajStrAssignS(&stock->bm,line);
< 			}
< 			else
< 			    ajStrAppendS(&stock->bm,line);
< 		    }
< 		    else if(!ajStrCmpC(token,"DC"))
< 		    {
< 			if(dcf)
< 			{
< 			    dcf = ajFalse;
< 			    ajStrAssignS(&stock->dc,line);
< 			}
< 			else
< 			    ajStrAppendS(&stock->dc,line);
< 		    }
< 		    else if(!ajStrCmpC(token,"DR"))
< 		    {
< 			if(drf)
< 			{
< 			    drf = ajFalse;
< 			    ajStrAssignS(&stock->dr,line);
< 			}
< 			else
< 			    ajStrAppendS(&stock->dr,line);
< 		    }
< 		    else if(!ajStrCmpC(token,"CC"))
< 		    {
< 			if(ccf)
< 			{
< 			    ccf = ajFalse;
< 			    ajStrAssignS(&stock->cc,line);
< 			}
< 			else
< 			    ajStrAppendS(&stock->cc,line);
< 		    }
< 		    else if(*ajStrGetPtr(token)=='R')
< 		    {
< 			if(reff)
< 			{
< 			    reff = ajFalse;
< 			    ajStrAssignS(&stock->ref,line);
< 			}
< 			else
< 			    ajStrAppendS(&stock->ref,line);
< 		    }
< 		}
< 
< 		else if(!ajStrCmpC(word,"#=GS"))
< 		{
< 		    if(gsf)
< 		    {
< 			gsf = ajFalse;
< 			ajStrAssignS(&stock->gs,line);
< 		    }
< 		    else
< 			ajStrAppendS(&stock->gs,line);
< 		}
< 
< 		else if(!ajStrCmpC(word,"#=GC"))
< 		{
< 		    if(!ajStrCmpC(token,"SS_cons"))
< 			ajStrAssignS(&stock->sscons,post);
< 		    else if(!ajStrCmpC(token,"SA_cons"))
< 			ajStrAssignS(&stock->sacons,post);
< 		    else if(!ajStrCmpC(token,"seq_cons"))
< 			ajStrAssignS(&stock->sqcons,post);
< 		}
< 	    }
< 	    else if (ajStrGetLen(line))
< 	    {
---
>                         word, seqToken, post);
>                 if(!ajStrCmpC(word,"#=GF"))
>                 {
>                     if(!ajStrCmpC(seqToken,"ID"))
>                         ajStrAssignS(&stock->id,post);
>                     else if(!ajStrCmpC(seqToken,"AC"))
>                         ajStrAssignS(&stock->ac,post);
>                     else if(!ajStrCmpC(seqToken,"DE"))
>                         ajStrAssignS(&stock->de,post);
>                     else if(!ajStrCmpC(seqToken,"AU"))
>                         ajStrAssignS(&stock->au,post);
>                     else if(!ajStrCmpC(seqToken,"AL"))
>                         ajStrAssignS(&stock->al,post);
>                     else if(!ajStrCmpC(seqToken,"SE"))
>                         ajStrAssignS(&stock->se,post);
>                     else if(!ajStrCmpC(seqToken,"TP"))
>                         ajStrAssignS(&stock->se,post);
>                     else if(!ajStrCmpC(seqToken,"GA"))
>                         ajFmtScanS(post,"%d%d",&stock->ga[0],
>                                    &stock->ga[1]);
>                     else if(!ajStrCmpC(seqToken,"TC"))
>                         ajFmtScanS(post,"%f%f",&stock->tc[0],
>                                    &stock->tc[1]);
>                     else if(!ajStrCmpC(seqToken,"NC"))
>                         ajFmtScanS(post,"%f%f",&stock->nc[0],
>                                    &stock->nc[1]);
>                     else if(!ajStrCmpC(seqToken,"BM"))
>                     {
>                         if(bmf)
>                         {
>                             bmf = ajFalse;
>                             ajStrAssignS(&stock->bm,line);
>                         }
>                         else
>                             ajStrAppendS(&stock->bm,line);
>                     }
>                     else if(!ajStrCmpC(seqToken,"DC"))
>                     {
>                         if(dcf)
>                         {
>                             dcf = ajFalse;
>                             ajStrAssignS(&stock->dc,line);
>                         }
>                         else
>                             ajStrAppendS(&stock->dc,line);
>                     }
>                     else if(!ajStrCmpC(seqToken,"DR"))
>                     {
>                         if(drf)
>                         {
>                             drf = ajFalse;
>                             ajStrAssignS(&stock->dr,line);
>                         }
>                         else
>                             ajStrAppendS(&stock->dr,line);
>                     }
>                     else if(!ajStrCmpC(seqToken,"CC"))
>                     {
>                         if(ccf)
>                         {
>                             ccf = ajFalse;
>                             ajStrAssignS(&stock->cc,line);
>                         }
>                         else
>                             ajStrAppendS(&stock->cc,line);
>                     }
>                     else if(*ajStrGetPtr(seqToken)=='R')
>                     {
>                         if(reff)
>                         {
>                             reff = ajFalse;
>                             ajStrAssignS(&stock->ref,line);
>                         }
>                         else
>                             ajStrAppendS(&stock->ref,line);
>                     }
>                 }
> 
>                 else if(!ajStrCmpC(word,"#=GS"))
>                 {
>                     if(gsf)
>                     {
>                         gsf = ajFalse;
>                         ajStrAssignS(&stock->gs,line);
>                     }
>                     else
>                         ajStrAppendS(&stock->gs,line);
>                 }
> 
>                 else if(!ajStrCmpC(word,"#=GC"))
>                 {
>                     if(!ajStrCmpC(seqToken,"SS_cons"))
>                         ajStrAssignS(&stock->sscons,post);
>                     else if(!ajStrCmpC(seqToken,"SA_cons"))
>                         ajStrAssignS(&stock->sacons,post);
>                     else if(!ajStrCmpC(seqToken,"seq_cons"))
>                         ajStrAssignS(&stock->sqcons,post);
>                 }
>             }
>             else if (ajStrGetLen(line))
>             {
4827,4828d5546
<                 
< 	    }
4830,4831c5548,5550
< 	    ok = ajBuffreadLineStore(buff,&line,
< 				     seqin->Input->Text, &thys->TextPtr);
---
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input,&line, &thys->TextPtr);
4833c5552
< 	}
---
>         }
4835,4850c5554,5568
< 	while(ok && !ajStrPrefixC(line, "# STOCKHOLM 1."))
< 	    ok = ajBuffreadLineStore(buff,&line,
< 				     seqin->Input->Text, &thys->TextPtr);
< 
< 	if(ok)
< 	    ajFilebuffClearStore(buff, 1,
< 				 line, seqin->Input->Text, &thys->TextPtr);
< 	else
< 	    ajFilebuffClear(buff, 0);
< 
< 	ajStrDel(&word);
< 	ajStrDel(&token);
< 	ajStrDel(&post);
< 	ajStrDel(&namstr);
< 	ajStrDel(&seqstr);
< 	seqin->SeqData = stock;
---
>         while(ok && !ajStrPrefixC(line, "# STOCKHOLM 1."))
>             ok = ajTextinStoreReadline(seqin->Input,&line, &thys->TextPtr);
> 
>         if(ok)
>             ajTextinStoreClear(seqin->Input, 1, line, &thys->TextPtr);
>         else
>             ajFilebuffClear(buff, 0);
> 
>         ajStrDel(&word);
>         ajStrDel(&post);
>         ajStrDel(&namstr);
>         ajStrDel(&seqstr); 
>         ajStrDelStatic(&seqToken);
> 
>         seqin->SeqData = stock;
4859,4862c5577,5580
< 	ajDebug("Stockholm count %d: All done\n", stock->Count);
< 	stockholmDel(&stock);
< 	seqin->SeqData = NULL;
< 	ajStrDel(&line);
---
>         ajDebug("Stockholm count %d: All done\n", stock->Count);
>         stockholmDel(&stock);
>         seqin->SeqData = NULL;
>         ajStrDel(&line);
4864c5582
< 	return ajFalse;
---
>         return ajFalse;
4892a5611,5612
> **
> ** @release 2.0.1
4907,4908c5627,5628
<     if(!(*thys)->Selexdata)
< 	(*thys)->Selexdata = selexdataNew();
---
>   if(!(*thys)->Selexdata)
>   (*thys)->Selexdata = selexdataNew();
4910c5630
<     sdata = (*thys)->Selexdata;
---
>   sdata = (*thys)->Selexdata;
4912,4938c5632,5658
<     ajStrAssignS(&sdata->id,selex->id);
<     ajStrAssignS(&sdata->ac,selex->ac);
<     ajStrAssignS(&sdata->de,selex->de);
<     ajStrAssignS(&sdata->au,selex->au);
<     ajStrAssignS(&sdata->cs,selex->cs);
<     ajStrAssignS(&sdata->rf,selex->rf);
<     ajStrAssignS(&sdata->name,selex->name[n]);
<     ajStrAssignS(&sdata->str,selex->str[n]);
<     ajStrAssignS(&sdata->ss,selex->ss[n]);
< 
<     sdata->ga[0] = selex->ga[0];
<     sdata->ga[1] = selex->ga[1];
<     sdata->tc[0] = selex->tc[0];
<     sdata->tc[1] = selex->tc[1];
<     sdata->nc[0] = selex->nc[0];
<     sdata->nc[1] = selex->nc[1];
< 
<     ajStrAssignS(&sdata->sq->name,selex->sq[n]->name);
< 
<     ajStrAssignS(&sdata->sq->ac,selex->sq[n]->ac);
<     ajStrAssignS(&sdata->sq->source,selex->sq[n]->source);
<     ajStrAssignS(&sdata->sq->de,selex->sq[n]->de);
< 
<     sdata->sq->wt    = selex->sq[n]->wt;
<     sdata->sq->start = selex->sq[n]->start;
<     sdata->sq->stop  = selex->sq[n]->stop;
<     sdata->sq->len   = selex->sq[n]->len;
---
>   ajStrAssignS(&sdata->id,selex->id);
>   ajStrAssignS(&sdata->ac,selex->ac);
>   ajStrAssignS(&sdata->de,selex->de);
>   ajStrAssignS(&sdata->au,selex->au);
>   ajStrAssignS(&sdata->cs,selex->cs);
>   ajStrAssignS(&sdata->rf,selex->rf);
>   ajStrAssignS(&sdata->name,selex->name[n]);
>   ajStrAssignS(&sdata->str,selex->str[n]);
>   ajStrAssignS(&sdata->ss,selex->ss[n]);
> 
>   sdata->ga[0] = selex->ga[0];
>   sdata->ga[1] = selex->ga[1];
>   sdata->tc[0] = selex->tc[0];
>   sdata->tc[1] = selex->tc[1];
>   sdata->nc[0] = selex->nc[0];
>   sdata->nc[1] = selex->nc[1];
> 
>   ajStrAssignS(&sdata->sq->name,selex->sq[n]->name);
> 
>   ajStrAssignS(&sdata->sq->ac,selex->sq[n]->ac);
>   ajStrAssignS(&sdata->sq->source,selex->sq[n]->source);
>   ajStrAssignS(&sdata->sq->de,selex->sq[n]->de);
> 
>   sdata->sq->wt    = selex->sq[n]->wt;
>   sdata->sq->start = selex->sq[n]->start;
>   sdata->sq->stop  = selex->sq[n]->stop;
>   sdata->sq->len   = selex->sq[n]->len;
4954a5675,5676
> **
> ** @release 2.3.0
4969,4970c5691,5692
<     if(!(*thys)->Stock)
< 	(*thys)->Stock = stockholmdataNew();
---
>   if(!(*thys)->Stock)
>   (*thys)->Stock = stockholmdataNew();
4972c5694
<     sdata = (*thys)->Stock;
---
>   sdata = (*thys)->Stock;
4974,4994c5696,5716
<     ajStrAssignS(&sdata->id,stock->id);
<     ajStrAssignS(&sdata->ac,stock->ac);
<     ajStrAssignS(&sdata->de,stock->de);
<     ajStrAssignS(&sdata->au,stock->au);
<     ajStrAssignS(&sdata->al,stock->al);
<     ajStrAssignS(&sdata->tp,stock->tp);
<     ajStrAssignS(&sdata->se,stock->se);
<     ajStrAssignS(&sdata->gs,stock->gs);
<     ajStrAssignS(&sdata->dc,stock->dc);
<     ajStrAssignS(&sdata->dr,stock->dr);
<     ajStrAssignS(&sdata->cc,stock->cc);
<     ajStrAssignS(&sdata->ref,stock->ref);
<     ajStrAssignS(&sdata->sacons,stock->sacons);
<     ajStrAssignS(&sdata->sqcons,stock->sqcons);
<     ajStrAssignS(&sdata->sscons,stock->sscons);
<     sdata->ga[0] = stock->ga[0];
<     sdata->ga[1] = stock->ga[1];
<     sdata->tc[0] = stock->tc[0];
<     sdata->tc[1] = stock->tc[1];
<     sdata->nc[0] = stock->nc[0];
<     sdata->nc[1] = stock->nc[1];
---
>   ajStrAssignS(&sdata->id,stock->id);
>   ajStrAssignS(&sdata->ac,stock->ac);
>   ajStrAssignS(&sdata->de,stock->de);
>   ajStrAssignS(&sdata->au,stock->au);
>   ajStrAssignS(&sdata->al,stock->al);
>   ajStrAssignS(&sdata->tp,stock->tp);
>   ajStrAssignS(&sdata->se,stock->se);
>   ajStrAssignS(&sdata->gs,stock->gs);
>   ajStrAssignS(&sdata->dc,stock->dc);
>   ajStrAssignS(&sdata->dr,stock->dr);
>   ajStrAssignS(&sdata->cc,stock->cc);
>   ajStrAssignS(&sdata->ref,stock->ref);
>   ajStrAssignS(&sdata->sacons,stock->sacons);
>   ajStrAssignS(&sdata->sqcons,stock->sqcons);
>   ajStrAssignS(&sdata->sscons,stock->sscons);
>   sdata->ga[0] = stock->ga[0];
>   sdata->ga[1] = stock->ga[1];
>   sdata->tc[0] = stock->tc[0];
>   sdata->tc[1] = stock->tc[1];
>   sdata->nc[0] = stock->nc[0];
>   sdata->nc[1] = stock->nc[1];
5011a5734,5735
> **
> ** @release 2.0.1
5016c5740
< 			   ajuint beg, ajuint end)
---
>                            ajuint beg, ajuint end)
5028c5752
< 	    ajStrGetLen(src), beg, end, src);
---
>             ajStrGetLen(src), beg, end, src);
5032,5033c5756,5757
< 	for(i=0;i<len;++i)
< 	    ajStrAppendK(dest,'-');
---
>         for(i=0;i<len;++i)
>             ajStrAppendK(dest,'-');
5035c5759
< 	return;
---
>         return;
5043,5044c5767,5768
< 	if(c=='.' || c=='_' || c==' ')
< 	    c='-';
---
>         if(c=='.' || c=='_' || c==' ')
>             c='-';
5046,5047c5770,5771
< 	ajStrAppendK(dest,c);
< 	++p;
---
>         ajStrAppendK(dest,c);
>         ++p;
5051c5775
< 	ajStrAppendK(dest,'-');
---
>         ajStrAppendK(dest,'-');
5067a5792,5793
> **
> ** @release 2.0.1
5072c5798
< 			     AjBool *named, ajuint *sqcnt)
---
>                              AjBool *named, ajuint *sqcnt)
5075,5077d5800
<     AjPStrTok token = NULL;
<     AjPStr handle   = NULL;
< 
5084c5807
< 	ajFmtScanS(line,"#=ID %S",&pthis->id);
---
>         ajFmtScanS(line,"#=ID %S",&pthis->id);
5086c5809
< 	return ajTrue;
---
>         return ajTrue;
5090c5813
< 	ajFmtScanS(line,"#=AC %S",&pthis->ac);
---
>         ajFmtScanS(line,"#=AC %S",&pthis->ac);
5092c5815
< 	return ajTrue;
---
>         return ajTrue;
5096,5097c5819,5820
< 	ajStrAssignC(&pthis->de,ajStrGetPtr(line)+5);
< 	ajStrRemoveWhiteExcess(&pthis->de);
---
>         ajStrAssignC(&pthis->de,ajStrGetPtr(line)+5);
>         ajStrRemoveWhiteExcess(&pthis->de);
5099c5822
< 	return ajTrue;
---
>         return ajTrue;
5103,5104c5826,5827
< 	ajStrAssignC(&pthis->au,ajStrGetPtr(line)+5);
< 	ajStrRemoveWhiteExcess(&pthis->au);
---
>         ajStrAssignC(&pthis->au,ajStrGetPtr(line)+5);
>         ajStrRemoveWhiteExcess(&pthis->au);
5106c5829
< 	return ajTrue;
---
>         return ajTrue;
5110c5833
< 	ajFmtScanS(line,"%*s %f %f",&pthis->ga[0],&pthis->ga[1]);
---
>         ajFmtScanS(line,"%*s %f %f",&pthis->ga[0],&pthis->ga[1]);
5112c5835
< 	return ajTrue;
---
>         return ajTrue;
5116c5839
< 	ajFmtScanS(line,"%*s %f %f",&pthis->tc[0],&pthis->tc[1]);
---
>         ajFmtScanS(line,"%*s %f %f",&pthis->tc[0],&pthis->tc[1]);
5118c5841
< 	return ajTrue;
---
>         return ajTrue;
5122c5845
< 	ajFmtScanS(line,"%*s %f %f",&pthis->nc[0],&pthis->nc[1]);
---
>         ajFmtScanS(line,"%*s %f %f",&pthis->nc[0],&pthis->nc[1]);
5124c5847
< 	return ajTrue;
---
>         return ajTrue;
5128,5130c5851,5852
< 	handle = ajStrNew();
< 	token = ajStrTokenNewC(line," \t\n");
< 	ajStrTokenNextParse(&token,&handle);
---
>         ajStrTokenAssignC(&seqHandle,line," \t\n");
>         ajStrTokenStep(seqHandle);
5132,5133c5854,5855
< 	ajStrTokenNextParse(&token,&pthis->sq[*sqcnt]->name);
< 	ajStrAssignS(&pthis->name[*sqcnt],pthis->sq[*sqcnt]->name);
---
>         ajStrTokenNextParse(seqHandle,&pthis->sq[*sqcnt]->name);
>         ajStrAssignS(&pthis->name[*sqcnt],pthis->sq[*sqcnt]->name);
5135,5136c5857,5858
< 	ajStrTokenNextParse(&token,&handle);
< 	ajStrToFloat(handle,&pthis->sq[*sqcnt]->wt);
---
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         ajStrToFloat(seqToken,&pthis->sq[*sqcnt]->wt);
5138,5139c5860
< 	ajStrTokenNextParse(&token,&handle);
< 	ajStrAssignS(&pthis->sq[*sqcnt]->source,handle);
---
>         ajStrTokenNextParse(seqHandle,&pthis->sq[*sqcnt]->source);
5141,5142c5862
< 	ajStrTokenNextParse(&token,&handle);
< 	ajStrAssignS(&pthis->sq[*sqcnt]->ac,handle);
---
>         ajStrTokenNextParse(seqHandle, &pthis->sq[*sqcnt]->ac);
5144,5146c5864,5866
< 	ajStrTokenNextParse(&token,&handle);
< 	ajFmtScanS(handle,"%d..%d:%d",&pthis->sq[*sqcnt]->start,
< 		   &pthis->sq[*sqcnt]->stop,&pthis->sq[*sqcnt]->len);
---
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         ajFmtScanS(seqToken,"%d..%d:%d",&pthis->sq[*sqcnt]->start,
>                    &pthis->sq[*sqcnt]->stop,&pthis->sq[*sqcnt]->len);
5148,5149c5868
< 	ajStrTokenNextParseC(&token,"\n",&handle);
< 	ajStrAssignS(&pthis->sq[*sqcnt]->de,handle);
---
>         ajStrTokenNextParseC(seqHandle,"\n",&pthis->sq[*sqcnt]->de);
5151,5154c5870,5872
< 	ajStrTokenDel(&token);
< 	ajStrDel(&handle);
< 	*named = ajTrue;
< 	++(*sqcnt);
---
>         ajStrDelStatic(&seqToken);
>         *named = ajTrue;
>         ++(*sqcnt);
5156c5874
< 	return ajTrue;
---
>         return ajTrue;
5173a5892,5893
> **
> ** @release 2.0.1
5188c5908
<      */
---
>     */
5192c5912
<     if(!len) 
---
>     if(!len)
5199c5919
<     
---
> 
5205c5925
< 	++p;
---
>         ++p;
5208c5928
< 	++p;
---
>         ++p;
5211c5931
< 	pos = p - ajStrGetPtr(line);
---
>         pos = p - ajStrGetPtr(line);
5232,5233c5952
< ** @param [u] buff  [AjPFilebuff] Selex file buffer
< ** @param [r] store [AjBool] store if ajTrue
---
> ** @param [u] seqin  [AjPSeqin] Sequence input objext
5235a5955,5956
> **
> ** @release 2.0.1
5240,5241c5961
< 				AjPStr *line, AjPFilebuff buff,
< 				AjBool store, AjPStr *astr)
---
>                                 AjPStr *line, AjPSeqin seqin, AjPStr *astr)
5272,5273c5992,5993
< 	seqs[i] = ajStrNew();
< 	ss[i]  = ajStrNew();
---
>         seqs[i] = ajStrNew();
>         ss[i]  = ajStrNew();
5281,5282c6001,6002
<         ok = ajBuffreadLineStore(buff,line, store, astr);
<    
---
>         ok = ajTextinStoreReadline(seqin->Input, line, astr);
> 
5285c6005,6011
< 	seqSelexPos(*line,&begin,&end);
---
>         seqSelexPos(*line,&begin,&end);
> 
>         if(ajStrPrefixC(*line,"#=RF"))
>         {
>             haverf=ajTrue;
>             ajStrAssignS(&rf,*line);
>         }
5287,5315c6013,6024
< 	if(ajStrPrefixC(*line,"#=RF"))
< 	{
< 	    haverf=ajTrue;
< 	    ajStrAssignS(&rf,*line);
< 	}
< 
< 	if(ajStrPrefixC(*line,"#=CS"))
< 	{
< 	    havecs=ajTrue;
< 	    ajStrAssignS(&cs,*line);
< 	}
< 
< 	if(ajStrPrefixC(*line,"#=SS"))
< 	{
< 	    havess=ajTrue;
< 	    ajStrAssignS(&ss[--cnt],*line);
< 	    ++cnt;
< 	}
< 
< 	if(!ajStrPrefixC(*line,"#"))
< 	{
< 	    if(!*named)
< 	    {
< 		ajFmtScanS(*line,"%S",&pthis->name[cnt]);
< 		ajStrAssignS(&pthis->sq[cnt]->name,pthis->name[cnt]);
< 	    }
< 	    else
< 	    {
< 		ajFmtScanS(*line,"%S",&tmp);
---
>         if(ajStrPrefixC(*line,"#=CS"))
>         {
>             havecs=ajTrue;
>             ajStrAssignS(&cs,*line);
>         }
> 
>         if(ajStrPrefixC(*line,"#=SS"))
>         {
>             havess=ajTrue;
>             ajStrAssignS(&ss[--cnt],*line);
>             ++cnt;
>         }
5317,5318c6026,6038
< 		if(!ajStrPrefixS(pthis->name[cnt],tmp))
< 		    ajWarn("Selex format sequence names do not match "
---
>         if(!ajStrPrefixC(*line,"#"))
>         {
>             if(!*named)
>             {
>                 ajFmtScanS(*line,"%S",&pthis->name[cnt]);
>                 ajStrAssignS(&pthis->sq[cnt]->name,pthis->name[cnt]);
>             }
>             else
>             {
>                 ajFmtScanS(*line,"%S",&tmp);
> 
>                 if(!ajStrPrefixS(pthis->name[cnt],tmp))
>                     ajWarn("Selex format sequence names do not match "
5320,5321c6040,6041
< 			   pthis->name[cnt],tmp);
< 	    }
---
>                            pthis->name[cnt],tmp);
>             }
5323,5325c6043,6045
< 	    ajStrAssignS(&seqs[cnt],*line);
< 	    ++cnt;
< 	}
---
>             ajStrAssignS(&seqs[cnt],*line);
>             ++cnt;
>         }
5327c6047
< 	ok = ajBuffreadLineStore(buff,line, store, astr);
---
>         ok = ajTextinStoreReadline(seqin->Input,line, astr);
5329,5330c6049,6050
< 	if(ajStrPrefixC(*line,"\n"))
< 	    ok = ajFalse;
---
>         if(ajStrPrefixC(*line,"\n"))
>             ok = ajFalse;
5334c6054
< 	    *line, n, haverf, havecs, havess);
---
>             *line, n, haverf, havecs, havess);
5343c6063
< 	seqSelexAppend(rf,&pthis->rf,begin,end);
---
>         seqSelexAppend(rf,&pthis->rf,begin,end);
5346c6066
< 	seqSelexAppend(cs,&pthis->cs,begin,end);
---
>         seqSelexAppend(cs,&pthis->cs,begin,end);
5350,5352c6070,6072
< 	seqSelexAppend(seqs[i],&pthis->str[i],begin,end);
< 	if(havess)
< 	    seqSelexAppend(ss[i],&pthis->ss[i],begin,end);
---
>         seqSelexAppend(seqs[i],&pthis->str[i],begin,end);
>         if(havess)
>             seqSelexAppend(ss[i],&pthis->ss[i],begin,end);
5358,5359c6078,6079
< 	ajStrDel(&seqs[i]);
< 	ajStrDel(&ss[i]);
---
>         ajStrDel(&seqs[i]);
>         ajStrDel(&ss[i]);
5384a6105,6106
> **
> ** @release 1.0.0
5390d6111
<     AjPStr token  = NULL;
5398,5402c6119
< 	seqRegStadenId = ajRegCompC("^[<]([^>-]+)[-]*[>]");
< 
<     if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			   seqin->Input->Text, &thys->TextPtr))
< 	return ajFalse;
---
>         seqRegStadenId = ajRegCompC("^[<]([^>-]+)[-]*[>]");
5404c6121,6122
<     seqin->Input->Records++;
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         return ajFalse;
5408,5414c6126,6132
< 	ajRegSubI(seqRegStadenId, 1, &token);
< 	seqSetName(thys, token);
< 	ajDebug("seqReadStaden name '%S' token '%S'\n",
< 		thys->Name, token);
< 	ajRegPost(seqRegStadenId, &token);
< 	seqAppendCommented(&thys->Seq, &incomment, token);
< 	ajStrDel(&token);
---
>         ajRegSubI(seqRegStadenId, 1, &seqToken);
>         seqSetName(thys, seqToken);
>         ajDebug("seqReadStaden name '%S' token '%S'\n",
>                 thys->Name, seqToken);
>         ajRegPost(seqRegStadenId, &seqToken);
>         seqAppendCommented(&thys->Seq, &incomment, seqToken);
>         ajStrDelStatic(&seqToken);
5420,5422c6138,6140
< 	seqSetName(thys, tmpname);
< 	seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
< 	ajStrDel(&tmpname);
---
>         seqSetName(thys, tmpname);
>         seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
>         ajStrDel(&tmpname);
5425,5426c6143
<     while(ajBuffreadLineStore(buff, &seqReadLine,
< 			     seqin->Input->Text, &thys->TextPtr))
---
>     while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
5428,5429c6145
< 	seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
< 	seqin->Input->Records++;
---
>         seqAppendCommented(&thys->Seq, &incomment, seqReadLine);
5432c6148
<     if(!seqin->Input->Records)         /* but we have read at least 1 line */
---
>     if(!ajTextinGetRecords(seqin->Input)) /* but we have read at least 1 line */
5450a6167,6168
> **
> ** @release 1.0.0
5462,5463c6180
<     while(ajBuffreadLineStore(buff, &seqReadLine,
< 			     seqin->Input->Text, &thys->TextPtr))
---
>     while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
5465,5467c6182,6183
< 	ajDebug("read '%S'\n", seqReadLine);
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
---
>         ajDebug("read '%S'\n", seqReadLine);
>         seqAppend(&thys->Seq, seqReadLine);
5470c6186
<     ajDebug("read %d lines\n", seqin->Input->Records);
---
>     ajDebug("read %d lines\n", ajTextinGetRecords(seqin->Input));
5473,5474c6189,6190
<     if(!seqin->Input->Records)
< 	return ajFalse;
---
>     if(!ajTextinGetRecords(seqin->Input))
>         return ajFalse;
5493a6210,6211
> **
> ** @release 1.0.0
5499a6218
>     const char* cp;
5508a6228
>     size_t iread;
5510,5511c6230
<     if(!seqRegRawNonseq)
< 	seqRegRawNonseq = ajRegCompC("[^A-Za-z0-9 \t\n\r*-]");
---
>     ajDebug("seqReadRaw\n");
5516c6235,6236
<     ajDebug("seqReadRaw\n");
---
>     if(!seqRegRawNonseq)
>         seqRegRawNonseq = ajRegCompC("[^A-Za-z0-9 \t\n\r*-]");
5519c6239,6244
< 	return ajFalse;
---
>     {
>         ajDebug("seqReadRaw filebuff already ended\n");
>         return ajFalse;
>     }
>     
>     filestat = ajFileSeek(fp, 0L, SEEK_CUR);
5521,5527c6246,6248
<     buf = ajStrNewRes(4096);
<     ajStrSetValidLen(&buf, inc);
<     cbuf = ajStrGetuniquePtr(&buf);
< 
<     filestat = ajFileSeek(fp, 0L, SEEK_END);
<     filesize = ajFileResetPos(fp);
<     filestat = ajFileSeek(fp, (ajlong) filestat, 0);
---
>     if(filestat)
>     {
>         ajDebug("filestat %Lu\n", filestat);
5529c6250,6261
<     ok = ajTrue;
---
>         /* not a file - cannot use binary, so we can only read the buffer */
>         while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         {
>             ajDebug("read '%S'\n", seqReadLine);
> 
>             cp = ajStrGetPtr(seqReadLine);
>             if(strlen(cp) != ajStrGetLen(seqReadLine))
>             {
>                 ajDebug("seqReadRaw: Null character found in line: %S\n",
>                         seqReadLine);
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 ajStrAssignClear(&thys->Seq);
5531c6263,6279
<     for(i=0; i < filesize; i += inc)
---
>                 return ajFalse;
>             }
> 
>             if(ajRegExec(seqRegRawNonseq, seqReadLine))
>             {
>                 ajDebug("seqReadRaw: Bad character found in line: %S\n",
>                         seqReadLine);
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 ajStrAssignClear(&thys->Seq);
> 
>                 return ajFalse;
>             }
>             seqAppend(&thys->Seq, seqReadLine);
>             ajDebug("read %d lines\n", ajTextinGetRecords(seqin->Input));
>         }
>     }
>     else
5533c6281
<         if((i+inc) > filesize)
---
>         if(ajFilebuffIsEnded(buff))
5535,5536c6283,6285
< 	  inc = (ajuint) (filesize - i);
<             ajStrSetValidLen(&buf, inc);
---
>             ajDebug("seqReadRaw filebuff ended\n");
>             ajFileSeek(fp, 0L, SEEK_END);
>             return ajFalse;
5539,5540c6288,6294
<         ajReadbinBinary(fp, inc, 1, cbuf);
<         cbuf[inc] = '\0';
---
>         buf = ajStrNewRes(4096);
>         ajStrSetValidLen(&buf, inc);
>         cbuf = ajStrGetuniquePtr(&buf);
> 
>         filestat = ajFileSeek(fp, 0L, SEEK_END);
>         filesize = ajFileResetPos(fp);
>         filestat = ajFileSeek(fp, 0L, SEEK_SET);
5542c6296
<         if(strlen(cbuf) != inc)
---
>         if(!filesize)
5544,5547c6298,6300
< 	    ajDebug("seqReadRaw: Null character found in line: %s\n",
< 		    cbuf);
<             ok = ajFalse;
<             break;
---
>             ajDebug("seqReadRaw filesize zero\n");
>             ajFileSeek(fp,(ajlong) filesize, SEEK_SET);
>             return ajFalse;
5550,5555c6303,6340
< 	if(ajRegExec(seqRegRawNonseq, buf))
< 	{
< 	    ajDebug("seqReadRaw: Bad character found in line: %s\n",
< 		    cbuf);
<             ok = ajFalse;
<             break;
---
>         ok = ajTrue;
> 
>         for(i=0; i < filesize; i += inc)
>         {
>             if((i+inc) > filesize)
>             {
>                 inc = (ajuint) (filesize - i);
>                 ajStrSetValidLen(&buf, inc);
>             }
> 
>             iread = ajReadbinBinary(fp, inc, 1, cbuf);
>             cbuf[inc] = '\0';
> 
>             if(strlen(cbuf) != iread)
>             {
>                 ajDebug("seqReadRaw: Null character found in line: %s\n",
>                         cbuf);
>                 ok = ajFalse;
>                 break;
>             }
> 
>             if(ajRegExec(seqRegRawNonseq, buf))
>             {
>                 ajDebug("seqReadRaw: Bad character found in line: %S\n",
>                         seqReadLine);
>                 ok = ajFalse;
>                 break;
>             }
> 
>             ajStrAssignC(&tmpseq, cbuf);
> 
>             if(seqin->Input->Text)
>                 ajStrAppendS(&thys->TextPtr, tmpseq);
>             
>             seqAppend(&thys->Seq, tmpseq);
>             seqin->Input->Records++;
>             
>             ajDebug("read %d lines\n", ajTextinGetRecords(seqin->Input));
5558c6343,6344
<         ajStrAssignC(&tmpseq, cbuf);
---
>         ajStrDel(&buf);
>         ajStrDel(&tmpseq);
5560,5561c6346,6348
<         if(seqin->Input->Text)
<             ajStrAppendS(&thys->TextPtr, tmpseq);
---
>         if(!ok)
>         {
>             ajDebug("seqReadRaw input OK failed\n");
5563,5566c6350
< 	seqAppend(&thys->Seq, tmpseq);
< 	seqin->Input->Records++;
<         ajDebug("read %d lines\n", seqin->Input->Records);
<     }
---
>             ajFileSeek(fp,(ajlong) filestat,0);
5568,5569c6352,6356
<     ajStrDel(&buf);
<     ajStrDel(&tmpseq);
---
>             if(seqin->Input->Text)
>             {
>                 ajStrAssignC(&thys->TextPtr, "");
>                 seqin->Input->Records = 0;
>             }
5571,5573c6358
<     if(!ok)
<     {
<         ajFileSeek(fp,(ajlong) filestat,0);
---
>             ajFilebuffResetPos(buff);
5575,5576c6360,6363
<         if(seqin->Input->Text)
<             ajStrAssignC(&thys->TextPtr, "");
---
>             return ajFalse;
>         }
> 
>     }
5578c6365
< 	ajFilebuffResetPos(buff);
---
>     buff->File->End = ajTrue;
5580c6367,6371
< 	return ajFalse;
---
>     if(!ajTextinGetRecords(seqin->Input))
>     {
>         ajDebug("seqReadRaw no records read\n");
>         ajTextinStoreClear(seqin->Input, -1, seqReadLine, &thys->TextPtr);
>         return ajFalse;
5584d6374
<     buff->File->End=ajTrue;
5585a6376,6377
>     ajDebug("seqReadRaw success\n");
>     
5592c6384
< /* @funcstatic seqReadIgstrict *************************************************
---
> /* @funcstatic seqReadIgstrict ************************************************
5601a6394,6395
> **
> ** @release 6.1.0
5615c6409,6410
<         if(seqin->Input->Records){
---
>         if(ajTextinGetRecords(seqin->Input))
>         {
5622,5626c6417,6418
< 	/* skip comments with ';' prefix */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(ok)
<             seqin->Input->Records++;
---
>         /* skip comments with ';' prefix */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
5631,5632c6423,6424
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
5636d6427
<     seqin->Input->Records++;
5638,5640c6429,6430
<     while(ajBuffreadLineStore(buff, &seqReadLine,
< 			     seqin->Input->Text, &thys->TextPtr) &&
< 	  !ajStrPrefixC(seqReadLine, ";"))
---
>     while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr) &&
>           !ajStrPrefixC(seqReadLine, ";"))
5649,5650c6439
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
---
>         seqAppend(&thys->Seq, seqReadLine);
5655c6444
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
5658c6447
<     
---
> 
5660c6449
<         ajFilebuffClear(buff, 1);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
5677a6467,6468
> **
> ** @release 1.0.0
5690c6481,6482
<         if(seqin->Input->Records){
---
>         if(ajTextinGetRecords(seqin->Input))
>         {
5697,5701c6489,6490
< 	/* skip comments with ';' prefix */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(ok)
<             seqin->Input->Records++;
---
>         /* skip comments with ';' prefix */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
5706,5707c6495,6496
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
5715d6503
<     seqin->Input->Records++;
5717,5719c6505,6506
<     while(ajBuffreadLineStore(buff, &seqReadLine,
< 			     seqin->Input->Text, &thys->TextPtr) &&
< 	  !ajStrPrefixC(seqReadLine, ";"))
---
>     while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr) &&
>           !ajStrPrefixC(seqReadLine, ";"))
5721,5722c6508
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
---
>         seqAppend(&thys->Seq, seqReadLine);
5726c6512,6717
<         ajFilebuffClear(buff, 1);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
>     else
>         ajFilebuffClear(buff, 0);
> 
>     return ajTrue;
> }
> 
> 
> 
> 
> /* @funcstatic seqReadIguspto *************************************************
> **
> ** Given data in a sequence structure, tries to read everything needed
> ** using the US patent office multi-line IntelliGenetics format.
> **
> ** Requires a trailing number at the end of the sequence
> ** and allows for a trailing control-L at the end of the entry.
> **
> ** @param [w] thys [AjPSeq] Sequence object
> ** @param [u] seqin [AjPSeqin] Sequence input object
> ** @return [AjBool] ajTrue on success
> **
> ** @release 6.6.0
> ** @@
> ******************************************************************************/
> 
> static AjBool seqReadIguspto(AjPSeq thys, AjPSeqin seqin)
> {
>     AjPFilebuff buff;
>     const AjPStr badstr = NULL;
>     AjBool endnum = ajFalse;
>     AjBool ok = ajTrue;
>     AjBool seqok = ajFalse;
>     AjBool isheader = ajTrue;
>     AjBool firstline = ajTrue;
>     AjBool firstgood = ajTrue;
>     ajlong ipos;
> 
>     buff = seqin->Input->Filebuff;
> 
>     while(ok && !seqok)
>     {
>         if(!ajStrPrefixC(seqReadLine, ";"))
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         if(firstline)
>         {
>             firstline = ajFalse;
>             firstgood = ajTrue;
> 
>             if(!ajStrPrefixC(seqReadLine, "; Sequence "))
>             {
>                 ajFmtPrintS(&seqToken,
>                             "'; Sequence ' not found");
>                 firstgood = ajFalse;
>             }
> 
>             if(firstgood)
>             {
>                 ipos = ajStrFindC(seqReadLine, ", Application ");
>                 if(ipos < 1)
>                 {
>                     ajFmtPrintS(&seqToken2,
>                                 "', Application ' not found");
>                     firstgood = ajFalse;
>                 }
>             }
> 
>             if(firstgood)
>             {
>                 ajStrAssignSubS(&seqToken, seqReadLine, 11, ipos-1);
>                 if(!ajStrIsInt(seqToken))
>                 {
>                     ajFmtPrintS(&seqToken2,
>                                 "Sequence number '%S' not an integer",
>                                 seqToken);
>                     firstgood = ajFalse;
>                 }
>             }
> 
>             if(firstgood)
>             {
>                 ajStrAssignSubS(&seqToken, seqReadLine, ipos+14, -2);
>                 if(!ajStrIsWord(seqToken))
>                 {
>                     ajFmtPrintS(&seqToken2,
>                                 "Application id '%S' not a word",
>                                 seqToken);
>                     firstgood = ajFalse;
>                 }
>             }
> 
>             if(!firstgood)
>             {
>                 if(seqin->Input->Format)
>                 {
>                     ajStrAssignS(&seqToken, seqReadLine);
>                     ajStrTrimWhiteEnd(&seqToken);
>                     ajWarn("Iguspto: bad first line (%S): %S",
>                            seqToken2, seqToken);
> 
>                     
>                 }
>                 else 
>                 {
>                     return ajFalse;
>                 }
>             }
>         }
> 
>         if(!thys->Fulldesc)
>             thys->Fulldesc = ajSeqdescNew();
> 
>         do
>         {
>             if(ajTextinGetRecords(seqin->Input))
>             {
>                 ajStrRemoveLastNewline(&seqReadLine);
>                 ajStrCutStart(&seqReadLine, 1); /* trim the semi colon */
>                 if(ajStrGetCharFirst(seqReadLine) == ' ')
>                     ajStrCutStart(&seqReadLine, 1);
>                 ajListstrPushAppend(thys->Fulldesc->Multi,
>                                     ajStrNewS(seqReadLine));
> 
>                 if(ajStrPrefixC(seqReadLine, "GENERAL INFORMATION"))
>                     isheader = ajFalse;
> 
>                 if(isheader)
>                 {
>                     if(ajStrGetLen(thys->Desc))
>                         ajStrAppendC(&thys->Desc, "; ");
>                     ajStrAppendS(&thys->Desc, seqReadLine);
>                 }
>             }
>             /* skip comments with ';' prefix */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         } while(ok && ajStrPrefixC(seqReadLine, ";"));
> 
>         if(!ok)
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             return ajFalse;
>         }
> 
>         seqSetName(thys, seqReadLine);
> 
>         endnum = ajFalse;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         while(ok &&
>               !ajStrPrefixC(seqReadLine, ";") &&
>               !endnum)
>         {
>             ajStrRemoveWhiteExcess(&seqReadLine);
>             if(ajStrSuffixC(seqReadLine, "1"))
>                 endnum = ajTrue;
>             else if(ajStrSuffixC(seqReadLine, "2"))
>                 endnum = ajTrue;
>             else
>                 endnum = ajFalse;
> 
>             if(endnum)
>                 ajStrCutEnd(&seqReadLine, 1);
> 
>             badstr = seqAppendWarn(&thys->Seq, seqReadLine,
>                                    seqin->Input->Format);
>             if(badstr)
>                 ajWarn("Sequence '%S' has bad character(s) '%S'",
>                        thys->Name, badstr);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if(endnum)
>             seqok = ajTrue;
>         else
>         {
>             if(seqin->Input->Format)
>                 ajWarn("Sequence '%S' has bad iguspto sequence format",
>                        thys->Name);
>             ajSeqClear(thys);
>         }
>     }
>     
>     /* test for, but do not store, the trailing space and ^L character */
> 
>     if(ok)
>     {
>         ajStrRemoveWhiteExcess(&seqReadLine);
>         while(ok &&
>               (!ajStrGetLen(seqReadLine) || ajStrMatchC(seqReadLine, "\014")))
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>             if(ok)
>             {
>                 ajStrRemoveWhiteExcess(&seqReadLine);
>             }
>         }
>     }
> 
>     if(ajStrPrefixC(seqReadLine, ";"))
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
5736c6727
< /* @funcstatic seqReadPdb **************************************************
---
> /* @funcstatic seqReadPdb *****************************************************
5745a6737,6738
> **
> ** @release 6.0.0
5751,5752d6743
<     AjPFilebuff buff;
<     AjPStr name  = NULL;
5754,5755d6744
<     AjPStr token = NULL;
<     AjPStr chain = NULL;
5770,5771d6758
<     buff = seqin->Input->Filebuff;
< 
5775,5780c6762,6763
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
5782,5784c6765
< 	if(!ajStrPrefixC(seqReadLine, "HEADER    "))
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line:\n'%S'\n", seqReadLine);
5786,5787c6767,6769
< 	    return ajFalse;
< 	}
---
>         if(!ajStrPrefixC(seqReadLine, "HEADER    "))
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
5789,5790c6771,6772
< 	ajStrAssignSubS(&name,seqReadLine, 62, 71);
< 	ajStrTrimWhite(&name);
---
>             return ajFalse;
>         }
5792c6774,6775
< 	ajDebug("first line OK name '%S'\n", name);
---
>         ajStrAssignSubS(&seqName,seqReadLine, 62, 71);
>         ajStrTrimWhite(&seqName);
5794,5797c6777
< 	seqin->SeqData = AJNEW0(alndata);
< 	alndata->Table = alntable = ajTablestrNew(1000);
< 	alnlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
---
>         ajDebug("first line OK name '%S'\n", seqName);
5799,5800c6779,6782
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqin->SeqData = AJNEW0(alndata);
>         alndata->Table = alntable = ajTablestrNew(1000);
>         alnlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
5802,5804c6784
< 	while(ok && !ajStrMatchC(seqReadLine, "END"))
< 	{
< 	    seqin->Input->Records++;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
5806,5807c6786,6789
< 	    if(ajStrPrefixC(seqReadLine, "MODEL"))
< 	    {
---
>         while(ok && !ajStrMatchC(seqReadLine, "END"))
>         {
>             if(ajStrPrefixC(seqReadLine, "MODEL"))
>             {
5811,5828c6793,6796
< 	    else if(ajStrPrefixC(seqReadLine, "ATOM"))
< 	    {
< 		if(!alnitem)
< 		    AJNEW0(alnitem);
< 
< 		ajStrKeepRange(&seqReadLine, 0,71);
< 
< 		ajStrAssignSubS(&aa3, seqReadLine, 17, 19);
< 		ajStrAssignSubS(&chain, seqReadLine, 21, 21);
< 		ajStrAssignSubS(&token, seqReadLine, 22, 25);
< 		ajStrToUint(token, &iaa);
< 
< 		if(iaa > lastaa)
< 		{
< 		    if(ajResidueFromTriplet(aa3,&aa))
< 			seqAppendK(&alnitem->Seq, aa);
< 		    lastaa = iaa;
< 		}
---
>             else if(ajStrPrefixC(seqReadLine, "ATOM"))
>             {
>                 if(!alnitem)
>                     AJNEW0(alnitem);
5830c6798
< 	    }
---
>                 ajStrKeepRange(&seqReadLine, 0,71);
5832,5833c6800,6815
< 	    else if(ajStrPrefixC(seqReadLine, "TER"))
< 	    {
---
>                 ajStrAssignSubS(&aa3, seqReadLine, 17, 19);
>                 ajStrAssignSubS(&seqChain, seqReadLine, 21, 21);
>                 ajStrAssignSubS(&seqToken, seqReadLine, 22, 25);
>                 ajStrToUint(seqToken, &iaa);
> 
>                 if(iaa > lastaa)
>                 {
>                     if(ajResidueFromTriplet(aa3,&aa))
>                         seqAppendK(&alnitem->Seq, aa);
>                     lastaa = iaa;
>                 }
> 
>             }
> 
>             else if(ajStrPrefixC(seqReadLine, "TER"))
>             {
5841c6823
<                 else 
---
>                 else
5844c6826
<                     ajFmtPrintS(&token, "%S_%S", name, chain);
---
>                     ajFmtPrintS(&seqToken, "%S_%S", seqName, seqChain);
5847c6829
<                         ajStrAppendS(&token, model);
---
>                         ajStrAppendS(&seqToken, model);
5849c6831
<                     seqitemSetName(alnitem, token);
---
>                     seqitemSetName(alnitem, seqToken);
5859c6841
< 	    }
---
>             }
5861,5863c6843,6844
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
5865,5867c6846,6848
<         ajStrDel(&token);
<         ajStrDel(&name);
<         ajStrDel(&chain);
---
>         ajStrDelStatic(&seqToken);
>         ajStrDelStatic(&seqName);
>         ajStrDelStatic(&seqChain);
5874c6855,6863
<             ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("PDB Entry has %d sequences\n", nseq);
>         ajListstrTrace(alnlist);
>         ajTableTrace(alntable);
>         ajTableMap(alntable, &seqMsfTabList, NULL);
5876,5877c6865
< 	    return ajFalse;
< 	}
---
>         alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
5879,5898c6867,6880
< 	ajDebug("PDB Entry has %d sequences\n", nseq);
< 	ajListstrTrace(alnlist);
< 	ajTableTrace(alntable);
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 
< 	alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
< 
< 	for(i=0; i < nseq; i++)
< 	{
< 	    ajListstrPop(alnlist, &alndata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&alnlist);
< 
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 	alndata->Nseq = nseq;
< 	alndata->Count = 0;
< 	alndata->Bufflines = seqin->Input->Records;
< 	ajDebug("PDB format read %d lines\n", seqin->Input->Records);
---
>         for(i=0; i < nseq; i++)
>         {
>             ajListstrPop(alnlist, &alndata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
>         }
> 
>         ajListstrFreeData(&alnlist);
> 
>         ajTableMap(alntable, &seqMsfTabList, NULL);
>         alndata->Nseq = nseq;
>         alndata->Count = 0;
>         alndata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("PDB format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
5905,5907c6887,6889
<     {					/* all done */
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>     {                                   /* all done */
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
5909c6891
< 	return ajFalse;
---
>         return ajFalse;
5938a6921,6922
> **
> ** @release 6.0.0
5945d6928
<     AjPStrTok handle = NULL;
5948d6930
<     AjPStr token = NULL;
5965c6947
<     if(seqin->SeqData) 
---
>     if(seqin->SeqData)
5970c6952
<         {					/* try next entry */
---
>         {                                       /* try next entry */
5977c6959
<     
---
> 
5979,5981c6961,6962
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
5984c6965
<             ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
5987,5990d6967
<         
< 	seqin->Input->Records++;
< 
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
5992,5994c6969
< 	if(!ajStrPrefixC(seqReadLine, "HEADER    "))
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line:\n'%S'\n", seqReadLine);
5996,5997c6971,6973
< 	    return ajFalse;
< 	}
---
>         if(!ajStrPrefixC(seqReadLine, "HEADER    "))
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
5999,6000c6975,6976
< 	ajStrAssignSubS(&name,seqReadLine, 62, 71);
< 	ajStrTrimWhite(&name);
---
>             return ajFalse;
>         }
6002c6978,6979
< 	ajDebug("first line OK name '%S'\n", name);
---
>         ajStrAssignSubS(&name,seqReadLine, 62, 71);
>         ajStrTrimWhite(&name);
6004,6007c6981
< 	seqin->SeqData = AJNEW0(alndata);
< 	alndata->Table = alntable = ajTablestrNew(1000);
< 	alnlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
---
>         ajDebug("first line OK name '%S'\n", name);
6009,6010c6983,6986
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqin->SeqData = AJNEW0(alndata);
>         alndata->Table = alntable = ajTablestrNew(1000);
>         alnlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
6012,6014c6988
< 	while(ok && !ajStrMatchC(seqReadLine, "END"))
< 	{
< 	    seqin->Input->Records++;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
6016,6020c6990,6996
< 	    if(ajStrPrefixC(seqReadLine, "SEQRES"))
< 	    {
< 		ajStrKeepRange(&seqReadLine, 0,71);
< 		ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 		ajStrTokenNextParse(&handle, &token);	/* 'SEQRES' */
---
>         while(ok && !ajStrMatchC(seqReadLine, "END"))
>         {
>             if(ajStrPrefixC(seqReadLine, "SEQRES"))
>             {
>                 ajStrKeepRange(&seqReadLine, 0,71);
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle);   /* 'SEQRES' */
6022,6023c6998,6999
< 		ajStrTokenNextParse(&handle, &token);	/* number */
< 		ajStrToUint(token, &iseq);
---
>                 ajStrTokenNextParse(seqHandle, &seqToken);   /* number */
>                 ajStrToUint(seqToken, &iseq);
6025c7001
< 		ajStrTokenNextParse(&handle, &chain);	/* chain letter */
---
>                 ajStrTokenNextParse(seqHandle, &chain);   /* chain letter */
6027,6028c7003,7004
< 		if(iseq == 1)
< 		{
---
>                 if(iseq == 1)
>                 {
6038,6040c7014,7016
<                     
< 		    nseq++;
< 		    ajFmtPrintS(&token, "%S_%S", name, chain);
---
> 
>                     nseq++;
>                     ajFmtPrintS(&seqToken, "%S_%S", name, chain);
6042,6057c7018,7032
< 		    seqitemSetName(alnitem, token);
< 		    ajStrAssignS(&alnname, alnitem->Name);
< 		    alnitem->Weight = 1.0;
< 		    ajTablePut(alntable, alnname, alnitem);
< 		    alnname = NULL;
< 		    ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
< 		}
< 
< 		while(ajStrTokenNextParse(&handle, &token))
< 		    if(ajResidueFromTriplet(token,&aa))
< 			seqAppendK(&alnitem->Seq, aa);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
---
>                     seqitemSetName(alnitem, seqToken);
>                     ajStrAssignS(&alnname, alnitem->Name);
>                     alnitem->Weight = 1.0;
>                     ajTablePut(alntable, alnname, alnitem);
>                     alnname = NULL;
>                     ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
>                 }
> 
>                 while(ajStrTokenNextParse(seqHandle, &seqToken))
>                     if(ajResidueFromTriplet(seqToken,&aa))
>                         seqAppendK(&alnitem->Seq, aa);
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
6069,6071c7044,7046
< 	if(!nseq)
< 	{
<             ajStrDel(&token);
---
>         if(!nseq)
>         {
>             ajStrDelStatic(&seqToken);
6075c7050
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
6077,6078c7052,7053
< 	    return ajFalse;
< 	}
---
>             return ajFalse;
>         }
6080,6100c7055,7076
<         
< 	ajDebug("PDB Entry has %d sequences\n", nseq);
< 	ajListstrTrace(alnlist);
< 	ajTableTrace(alntable);
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 
< 	alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
< 
< 	for(i=0; i < nseq; i++)
< 	{
< 	    ajListstrPop(alnlist, &alndata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&alnlist);
< 
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 	alndata->Nseq = nseq;
< 	alndata->Count = 0;
< 	alndata->Bufflines = seqin->Input->Records;
< 	ajDebug("PDBSEQ format read %d lines\n", seqin->Input->Records);
---
> 
>         ajDebug("PDB Entry has %d sequences\n", nseq);
>         ajListstrTrace(alnlist);
>         ajTableTrace(alntable);
>         ajTableMap(alntable, &seqMsfTabList, NULL);
> 
>         alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
> 
>         for(i=0; i < nseq; i++)
>         {
>             ajListstrPop(alnlist, &alndata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
>         }
> 
>         ajListstrFreeData(&alnlist);
> 
>         ajTableMap(alntable, &seqMsfTabList, NULL);
>         alndata->Nseq = nseq;
>         alndata->Count = 0;
>         alndata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("PDBSEQ format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
6115c7091
<     ajStrDel(&token);
---
>     ajStrDelStatic(&seqToken);
6136a7113,7114
> **
> ** @release 6.1.0
6142d7119
<     AjPFilebuff buff;
6161,6162d7137
<     buff = seqin->Input->Filebuff;
< 
6166,6169c7141,7142
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
6171,6175c7144
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
< 
< 	if(!ajStrPrefixC(seqReadLine, "HEADER    "))
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line:\n'%S'\n", seqReadLine);
6177,6178c7146,7148
< 	    return ajFalse;
< 	}
---
>         if(!ajStrPrefixC(seqReadLine, "HEADER    "))
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
6180,6181c7150,7151
< 	ajStrAssignSubS(&name,seqReadLine, 62, 71);
< 	ajStrTrimWhite(&name);
---
>             return ajFalse;
>         }
6183c7153,7154
< 	ajDebug("first line OK name '%S'\n", name);
---
>         ajStrAssignSubS(&name,seqReadLine, 62, 71);
>         ajStrTrimWhite(&name);
6185,6188c7156
< 	seqin->SeqData = AJNEW0(alndata);
< 	alndata->Table = alntable = ajTablestrNew(1000);
< 	alnlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
---
>         ajDebug("first line OK name '%S'\n", name);
6190,6191c7158,7161
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqin->SeqData = AJNEW0(alndata);
>         alndata->Table = alntable = ajTablestrNew(1000);
>         alnlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
6193,6195c7163
< 	while(ok && !ajStrMatchC(seqReadLine, "END"))
< 	{
< 	    seqin->Input->Records++;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
6197,6198c7165,7168
< 	    if(ajStrPrefixC(seqReadLine, "MODEL"))
< 	    {
---
>         while(ok && !ajStrMatchC(seqReadLine, "END"))
>         {
>             if(ajStrPrefixC(seqReadLine, "MODEL"))
>             {
6202,6212c7172,7182
< 	    else if(ajStrPrefixC(seqReadLine, "ATOM"))
< 	    {
< 		if(!alnitem)
< 		    AJNEW0(alnitem);
< 
< 		ajStrKeepRange(&seqReadLine, 0,71);
< 
< 		ajStrAssignSubS(&aa3, seqReadLine, 18, 19);
< 		ajStrAssignSubS(&chain, seqReadLine, 21, 21);
< 		ajStrAssignSubS(&token, seqReadLine, 22, 25);
< 		ajStrToUint(token, &iaa);
---
>             else if(ajStrPrefixC(seqReadLine, "ATOM"))
>             {
>                 if(!alnitem)
>                     AJNEW0(alnitem);
> 
>                 ajStrKeepRange(&seqReadLine, 0,71);
> 
>                 ajStrAssignSubS(&aa3, seqReadLine, 18, 19);
>                 ajStrAssignSubS(&chain, seqReadLine, 21, 21);
>                 ajStrAssignSubS(&token, seqReadLine, 22, 25);
>                 ajStrToUint(token, &iaa);
6215,6217c7185,7187
< 		{
< 		    if(ajBaseFromDoublet(aa3,&aa))
< 			seqAppendK(&alnitem->Seq, aa);
---
>                 {
>                     if(ajBaseFromDoublet(aa3,&aa))
>                         seqAppendK(&alnitem->Seq, aa);
6219,6220c7189,7190
< 		    lastaa = iaa;
< 		}
---
>                     lastaa = iaa;
>                 }
6222c7192
< 	    }
---
>             }
6224,6225c7194,7195
< 	    else if(ajStrPrefixC(seqReadLine, "TER"))
< 	    {
---
>             else if(ajStrPrefixC(seqReadLine, "TER"))
>             {
6228c7198
<                     ajDebug("TER seqlen zero\n"); 
---
>                     ajDebug("TER seqlen zero\n");
6234c7204
<                 else 
---
>                 else
6249c7219
<                  }
---
>                 }
6251c7221
< 	    }
---
>             }
6253,6255c7223,7224
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
6275c7244,7260
<             ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("PDB Entry has %d sequences\n", nseq);
>         ajListstrTrace(alnlist);
>         ajTableTrace(alntable);
>         ajTableMap(alntable, &seqMsfTabList, NULL);
> 
>         alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
> 
>         for(i=0; i < nseq; i++)
>         {
>             ajListstrPop(alnlist, &alndata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
>         }
6277,6278c7262
< 	    return ajFalse;
< 	}
---
>         ajListstrFreeData(&alnlist);
6280,6299c7264,7269
< 	ajDebug("PDB Entry has %d sequences\n", nseq);
< 	ajListstrTrace(alnlist);
< 	ajTableTrace(alntable);
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 
< 	alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
< 
< 	for(i=0; i < nseq; i++)
< 	{
< 	    ajListstrPop(alnlist, &alndata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&alnlist);
< 
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 	alndata->Nseq = nseq;
< 	alndata->Count = 0;
< 	alndata->Bufflines = seqin->Input->Records;
< 	ajDebug("PDB format read %d lines\n", seqin->Input->Records);
---
>         ajTableMap(alntable, &seqMsfTabList, NULL);
>         alndata->Nseq = nseq;
>         alndata->Count = 0;
>         alndata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("PDB format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
6306,6308c7276,7278
<     {					/* all done */
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>     {                                   /* all done */
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
6310c7280
< 	return ajFalse;
---
>         return ajFalse;
6340a7311,7312
> **
> ** @release 6.1.0
6346,6347d7317
<     AjPFilebuff buff;
<     AjPStrTok handle = NULL;
6363,6364d7332
<     buff = seqin->Input->Filebuff;
< 
6368,6371c7336,7337
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
6373,6377c7339
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
< 
< 	if(!ajStrPrefixC(seqReadLine, "HEADER    "))
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("first line:\n'%S'\n", seqReadLine);
6379,6380c7341,7343
< 	    return ajFalse;
< 	}
---
>         if(!ajStrPrefixC(seqReadLine, "HEADER    "))
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
6382,6383c7345,7346
< 	ajStrAssignSubS(&name,seqReadLine, 62, 71);
< 	ajStrTrimWhite(&name);
---
>             return ajFalse;
>         }
6385c7348,7349
< 	ajDebug("first line OK name '%S'\n", name);
---
>         ajStrAssignSubS(&name,seqReadLine, 62, 71);
>         ajStrTrimWhite(&name);
6387,6390c7351
< 	seqin->SeqData = AJNEW0(alndata);
< 	alndata->Table = alntable = ajTablestrNew(1000);
< 	alnlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
---
>         ajDebug("first line OK name '%S'\n", name);
6392,6393c7353,7356
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqin->SeqData = AJNEW0(alndata);
>         alndata->Table = alntable = ajTablestrNew(1000);
>         alnlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
6395,6397c7358
< 	while(ok && !ajStrMatchC(seqReadLine, "END"))
< 	{
< 	    seqin->Input->Records++;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
6399,6403c7360,7366
< 	    if(ajStrPrefixC(seqReadLine, "SEQRES"))
< 	    {
< 		ajStrKeepRange(&seqReadLine, 0,71);
< 		ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 		ajStrTokenNextParse(&handle, &token);	/* 'SEQRES' */
---
>         while(ok && !ajStrMatchC(seqReadLine, "END"))
>         {
>             if(ajStrPrefixC(seqReadLine, "SEQRES"))
>             {
>                 ajStrKeepRange(&seqReadLine, 0,71);
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle);   /* 'SEQRES' */
6405,6406c7368,7369
< 		ajStrTokenNextParse(&handle, &token);	/* number */
< 		ajStrToUint(token, &iseq);
---
>                 ajStrTokenNextParse(seqHandle, &seqToken);   /* number */
>                 ajStrToUint(seqToken, &iseq);
6408c7371
< 		ajStrTokenNextParse(&handle, &chain);	/* chain letter */
---
>                 ajStrTokenNextParse(seqHandle, &chain);   /* chain letter */
6410,6411c7373,7374
< 		if(iseq == 1)
< 		{
---
>                 if(iseq == 1)
>                 {
6421,6423c7384,7386
<                     
< 		    nseq++;
< 		    ajFmtPrintS(&token, "%S_%S", name, chain);
---
> 
>                     nseq++;
>                     ajFmtPrintS(&token, "%S_%S", name, chain);
6425,6440c7388,7402
< 		    seqitemSetName(alnitem, token);
< 		    ajStrAssignS(&alnname, alnitem->Name);
< 		    alnitem->Weight = 1.0;
< 		    ajTablePut(alntable, alnname, alnitem);
< 		    alnname = NULL;
< 		    ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
< 		}
< 
< 		while(ajStrTokenNextParse(&handle, &token))
< 		    if(ajBaseFromDoublet(token,&aa))
< 			seqAppendK(&alnitem->Seq, aa);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	}
---
>                     seqitemSetName(alnitem, token);
>                     ajStrAssignS(&alnname, alnitem->Name);
>                     alnitem->Weight = 1.0;
>                     ajTablePut(alntable, alnname, alnitem);
>                     alnname = NULL;
>                     ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
>                 }
> 
>                 while(ajStrTokenNextParse(seqHandle, &seqToken))
>                     if(ajBaseFromDoublet(seqToken,&aa))
>                         seqAppendK(&alnitem->Seq, aa);
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
6452,6453c7414,7415
< 	if(!nseq)
< 	{
---
>         if(!nseq)
>         {
6458c7420
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
6460,6461c7422,7423
< 	    return ajFalse;
< 	}
---
>             return ajFalse;
>         }
6463,6483c7425,7446
<         
< 	ajDebug("PDB Entry has %d sequences\n", nseq);
< 	ajListstrTrace(alnlist);
< 	ajTableTrace(alntable);
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 
< 	alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
< 
< 	for(i=0; i < nseq; i++)
< 	{
< 	    ajListstrPop(alnlist, &alndata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&alnlist);
< 
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 	alndata->Nseq = nseq;
< 	alndata->Count = 0;
< 	alndata->Bufflines = seqin->Input->Records;
< 	ajDebug("PDBNUCSEQ format read %d lines\n", seqin->Input->Records);
---
> 
>         ajDebug("PDB Entry has %d sequences\n", nseq);
>         ajListstrTrace(alnlist);
>         ajTableTrace(alntable);
>         ajTableMap(alntable, &seqMsfTabList, NULL);
> 
>         alndata->Names = AJCALLOC(nseq, sizeof(*alndata->Names));
> 
>         for(i=0; i < nseq; i++)
>         {
>             ajListstrPop(alnlist, &alndata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
>         }
> 
>         ajListstrFreeData(&alnlist);
> 
>         ajTableMap(alntable, &seqMsfTabList, NULL);
>         alndata->Nseq = nseq;
>         alndata->Count = 0;
>         alndata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("PDBNUCSEQ format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
6490,6492c7453,7455
<     {					/* all done */
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>     {                                   /* all done */
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
6494c7457
< 	return ajFalse;
---
>         return ajFalse;
6523a7487,7488
> **
> ** @release 1.0.0
6533d7497
<     AjPFilebuff buff     = seqin->Input->Filebuff;
6545,6639c7509,7595
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 
< 	if(!ok)
< 	    return ajFalse;
< 
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
< 
< 	if(!ajStrPrefixC(seqReadLine, "CLUSTAL"))
< 	{
< 	    /* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajDebug("first line OK: '%S'\n", seqReadLine);
< 
< 	while(ok)
< 	{				/* skip blank lines */
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 
< 	    if(!ajStrIsWhite(seqReadLine))
< 		break;
< 	}
< 
< 	if(!ok)
< 	{
< 	    ajDebug("FAIL (blank lines only)\n");
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	seqin->SeqData = AJNEW0(alndata);
< 	alndata->Table = alntable = ajTablestrNew(1000);
< 	alnlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 
< 	/* first set - create table */
< 	ok = ajTrue;
< 
< 	while(ok && ajStrExtractFirst(seqReadLine, &seqstr, &name))
< 	{
< 	    AJNEW0(alnitem);
< 	    ajStrAssignS(&alnitem->Name, name);
< 	    alnitem->Weight = 1.0;
< 	    seqAppend(&alnitem->Seq, seqstr);
< 
< 	    iseq++;
< 	    ajDebug("first set %d: '%S'\n line: '%S'\n",
< 		    iseq, name, seqReadLine);
< 
< 	    ajTablePut(alntable, name, alnitem);
< 	    name = NULL;
< 	    ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 	}
< 
< 	ajStrDel(&seqstr);
< 
< 	ajDebug("Header has %d sequences\n", iseq);
< 	ajListstrTrace(alnlist);
< 	ajTableTrace(alntable);
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 
< 	alndata->Names = AJCALLOC(iseq, sizeof(*alndata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(alnlist, &alndata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&alnlist);
< 
< 	while(ajBuffreadLineStore(buff, &seqReadLine,
< 				 seqin->Input->Text, &thys->TextPtr))
< 	{				/* now read the rest */
< 	    seqin->Input->Records++;
< 	    seqClustalReadseq(seqReadLine, alntable);
< 	}
< 
< 	ajTableMap(alntable, seqMsfTabList, NULL);
< 	alndata->Nseq = iseq;
< 	alndata->Count = 0;
< 	alndata->Bufflines = seqin->Input->Records;
< 	ajDebug("ALN format read %d lines\n", seqin->Input->Records);
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         if(!ok)
>             return ajFalse;
> 
>         ajDebug("first line:\n'%S'\n", seqReadLine);
> 
>         if(!ajStrPrefixC(seqReadLine, "CLUSTAL"))
>         {
>             /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("first line OK: '%S'\n", seqReadLine);
> 
>         while(ok)
>         {                               /* skip blank lines */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             if(ok && !ajStrIsWhite(seqReadLine))
>                 break;
>         }
> 
>         if(!ok)
>         {
>             ajDebug("FAIL (blank lines only)\n");
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         seqin->SeqData = AJNEW0(alndata);
>         alndata->Table = alntable = ajTablestrNew(1000);
>         alnlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
> 
>         /* first set - create table */
>         ok = ajTrue;
> 
>         while(ok && ajStrExtractFirst(seqReadLine, &seqstr, &name))
>         {
>             AJNEW0(alnitem);
>             ajStrAssignS(&alnitem->Name, name);
>             alnitem->Weight = 1.0;
>             seqAppend(&alnitem->Seq, seqstr);
> 
>             iseq++;
>             ajDebug("first set %d: '%S'\n line: '%S'\n",
>                     iseq, name, seqReadLine);
> 
>             ajTablePut(alntable, name, alnitem);
>             name = NULL;
>             ajListstrPushAppend(alnlist, ajStrNewS(alnitem->Name));
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         ajStrDel(&seqstr);
> 
>         ajDebug("Header has %d sequences\n", iseq);
>         ajListstrTrace(alnlist);
>         ajTableTrace(alntable);
>         ajTableMap(alntable, &seqMsfTabList, NULL);
> 
>         alndata->Names = AJCALLOC(iseq, sizeof(*alndata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(alnlist, &alndata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, alndata->Names[i]);
>         }
> 
>         ajListstrFreeData(&alnlist);
> 
>         while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         {                               /* now read the rest */
>             seqClustalReadseq(seqReadLine, alntable);
>         }
> 
>         ajTableMap(alntable, &seqMsfTabList, NULL);
>         alndata->Nseq = iseq;
>         alndata->Count = 0;
>         alndata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("ALN format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
6646,6648c7602,7604
<     {					/* all done */
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>     {                                   /* all done */
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
6650c7606
< 	return ajFalse;
---
>         return ajFalse;
6676a7633,7634
> **
> ** @release 1.0.0
6687c7645
< 	return ajFalse;
---
>         return ajFalse;
6694c7652
< 	ajStrDel(&seqstr);
---
>         ajStrDel(&seqstr);
6696c7654
< 	return ajFalse;
---
>         return ajFalse;
6714a7673,7674
> **
> ** @release 3.0.0
6727d7686
<     AjPFilebuff buff;
6738,6739d7696
<     buff = seqin->Input->Filebuff;
< 
6741c7698
< 	seqRegPhylipTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
---
>         seqRegPhylipTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
6744c7701
< 	seqRegPhylipHead = ajRegCompC("^(..........) ?"); /* 10 chars */
---
>         seqRegPhylipHead = ajRegCompC("^(..........) ?"); /* 10 chars */
6747,6884c7704,7835
<     {					/* start of file */
< 	seqin->Multidone = ajFalse;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	ajDebug("first line:\n'%-20.20S'\n", seqReadLine);
< 
< 	if(!ajRegExec(seqRegPhylipTop, seqReadLine))
< 	{				/* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajRegSubI(seqRegPhylipTop, 1, &tmpstr);
< 	ajStrToUint(tmpstr, &iseq);
< 	ajDebug("seqRegPhylipTop1 '%S' %d\n", tmpstr, iseq);
< 	ajRegSubI(seqRegPhylipTop, 2, &tmpstr);
< 	ajStrToUint(tmpstr, &len);
< 	ajDebug("seqRegPhylipTop2 '%S' %d\n", tmpstr,len);
< 	ajDebug("first line OK: '%S' iseq: %d len: %d\n",
< 		seqReadLine, iseq, len);
< 	ajStrDel(&tmpstr);
< 
< 	seqin->SeqData = AJNEW0(phydata);
< 	phydata->Table = phytable = ajTablestrNew(1000);
< 	phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
< 	seqin->Input->Filecount = 0;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 	ilen = 0;
< 
< 	while(ok && (jseq < iseq))
< 	{
< 	    /* first set - create table */
< 	    if(!ajRegExec(seqRegPhylipHead, seqReadLine))
< 	    {
< 		ajDebug("FAIL (not seqRegPhylipHead): '%S'\n", seqReadLine);
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 
< 		return ajFalse;
< 	    }
< 
< 	    ajDebug("line: '%S'\n", seqReadLine);
< 	    ajRegSubI(seqRegPhylipHead, 1, &tmpstr);
< 
< 	    if(!ajStrIsWhite(tmpstr))
<             {
< 		/* check previous sequence */
< 		if(jseq)
< 		{
< 		    if(ilen != len)
< 		    {
< 			ajDebug("phylipnon format length mismatch at %d "
< 				"(length %d)\n",
< 				len, ilen);
< 			seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 			ajStrDel(&tmpstr);
< 			return ajFalse;
< 		    }
< 		}
< 
< 		/* new sequence */
< 		AJNEW0(phyitem);
< 		seqitemSetName(phyitem, tmpstr);
< 		ajStrAssignS(&phydata->Names[jseq], phyitem->Name);
< 		ajDebug("name: '%S' => '%S'\n", tmpstr, phyitem->Name);
< 		phyitem->Weight = 1.0;
< 		ajRegPost(seqRegPhylipHead, &seqstr);
< 		seqAppend(&phyitem->Seq, seqstr);
< 		ajStrDel(&seqstr);
< 		ilen = ajStrGetLen(phyitem->Seq);
< 
< 		if(ilen == len)
< 		    done = ajTrue;
< 		else if(ilen > len)
< 		{
< 		    ajDebug("Phylipnon format: sequence %S "
< 			    "header size %d exceeded\n",
< 			    phyitem->Name, len);
< 		    seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 		    seqMsfItemDel(&phyitem);
< 		    ajStrDel(&tmpstr);
< 
< 		    return ajFalse;
< 		}
< 
< 		ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
< 		ajDebug("seq %d: (%d) '%-20.20S'\n", jseq, ilen, seqReadLine);
< 	    }
< 	    else
<             {
< 		/* more sequence to append */
< 		if(seqPhylipReadseq(seqReadLine, phytable, phyitem->Name,
< 				    len, &ilen, &done))
< 		{
< 		    ajDebug("read to len %d\n", ilen);
< 
< 		    if (done)
< 			jseq++;
< 		}
< 
< 	    }
< 	    ajStrDel(&tmpstr);
< 
< 	    if(jseq < iseq)
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		seqin->Input->Records++;
< 	    }
< 	}
< 
< 	if(ilen != len)
< 	{
< 	    ajDebug("phylipnon format final length mismatch at %d "
< 		    "(length %d)\n",
< 		    len, ilen);
< 	    seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajDebug("Header has %d sequences\n", jseq);
< 	ajTableTrace(phytable);
< 	ajTableMap(phytable, seqMsfTabList, NULL);
< 
< 	phydata->Nseq = iseq;
< 	phydata->Count = 0;
< 	phydata->Bufflines = seqin->Input->Records;
< 	ajDebug("PHYLIP format read %d lines\n", seqin->Input->Records);
---
>     {                                   /* start of file */
>         seqin->Multidone = ajFalse;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(!ok)
>             return ajFalse;
> 
>         ajDebug("first line:\n'%-20.20S'\n", seqReadLine);
> 
>         if(!ajRegExec(seqRegPhylipTop, seqReadLine))
>         {                               /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajRegSubI(seqRegPhylipTop, 1, &tmpstr);
>         ajStrToUint(tmpstr, &iseq);
>         ajDebug("seqRegPhylipTop1 '%S' %d\n", tmpstr, iseq);
>         ajRegSubI(seqRegPhylipTop, 2, &tmpstr);
>         ajStrToUint(tmpstr, &len);
>         ajDebug("seqRegPhylipTop2 '%S' %d\n", tmpstr,len);
>         ajDebug("first line OK: '%S' iseq: %d len: %d\n",
>                 seqReadLine, iseq, len);
>         ajStrDel(&tmpstr);
> 
>         seqin->SeqData = AJNEW0(phydata);
>         phydata->Table = phytable = ajTablestrNew(1000);
>         phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
>         seqin->Input->Filecount = 0;
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ilen = 0;
> 
>         while(ok && (jseq < iseq))
>         {
>             /* first set - create table */
>             if(!ajRegExec(seqRegPhylipHead, seqReadLine))
>             {
>                 ajDebug("FAIL (not seqRegPhylipHead): '%S'\n", seqReadLine);
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
> 
>                 return ajFalse;
>             }
> 
>             ajDebug("line: '%S'\n", seqReadLine);
>             ajRegSubI(seqRegPhylipHead, 1, &tmpstr);
> 
>             if(!ajStrIsWhite(tmpstr))
>             {
>                 /* check previous sequence */
>                 if(jseq)
>                 {
>                     if(ilen != len)
>                     {
>                         ajDebug("phylipnon format length mismatch at %d "
>                                 "(length %d)\n",
>                                 len, ilen);
>                         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                         ajStrDel(&tmpstr);
>                         return ajFalse;
>                     }
>                 }
> 
>                 /* new sequence */
>                 AJNEW0(phyitem);
>                 seqitemSetName(phyitem, tmpstr);
>                 ajStrAssignS(&phydata->Names[jseq], phyitem->Name);
>                 ajDebug("name: '%S' => '%S'\n", tmpstr, phyitem->Name);
>                 phyitem->Weight = 1.0;
>                 ajRegPost(seqRegPhylipHead, &seqstr);
>                 seqAppend(&phyitem->Seq, seqstr);
>                 ajStrDel(&seqstr);
>                 ilen = ajStrGetLen(phyitem->Seq);
> 
>                 if(ilen == len)
>                     done = ajTrue;
>                 else if(ilen > len)
>                 {
>                     ajDebug("Phylipnon format: sequence %S "
>                             "header size %d exceeded\n",
>                             phyitem->Name, len);
>                     seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                     seqMsfItemDel(&phyitem);
>                     ajStrDel(&tmpstr);
> 
>                     return ajFalse;
>                 }
> 
>                 ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
>                 ajDebug("seq %d: (%d) '%-20.20S'\n", jseq, ilen, seqReadLine);
>             }
>             else
>             {
>                 /* more sequence to append */
>                 if(seqPhylipReadseq(seqReadLine, phytable, phyitem->Name,
>                                     len, &ilen, &done))
>                 {
>                     ajDebug("read to len %d\n", ilen);
> 
>                     if (done)
>                         jseq++;
>                 }
> 
>             }
>             ajStrDel(&tmpstr);
> 
>             if(jseq < iseq)
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         if(ilen != len)
>         {
>             ajDebug("phylipnon format final length mismatch at %d "
>                     "(length %d)\n",
>                     len, ilen);
>             seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("Header has %d sequences\n", jseq);
>         ajTableTrace(phytable);
>         ajTableMap(phytable, &seqMsfTabList, NULL);
> 
>         phydata->Nseq = iseq;
>         phydata->Count = 0;
>         phydata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("PHYLIP format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
6903,6906c7854,7857
< 	seqin->Multidone = ajTrue;
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	ajDebug("seqReadPhylip multidone\n");
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         ajDebug("seqReadPhylip multidone\n");
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
6925a7877,7878
> **
> ** @release 1.0.0
6955c7908
< 	seqRegPhylipTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
---
>         seqRegPhylipTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
6958c7911
< 	seqRegPhylipHead = ajRegCompC("^(..........) ?"); /* 10 chars */
---
>         seqRegPhylipHead = ajRegCompC("^(..........) ?"); /* 10 chars */
6961c7914
< 	seqRegPhylipSeq = ajRegCompC("^[ \t\n\r]*$");
---
>         seqRegPhylipSeq = ajRegCompC("^[ \t\n\r]*$");
6964,7046c7917,7993
<     {					/* start of file */
< 	seqin->Multidone = ajFalse;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	while (ok && ajStrIsWhite(seqReadLine))
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	/* ajDebug("first line:\n'%-20.20S'\n", seqReadLine);*/
< 
< 	if(!ajRegExec(seqRegPhylipTop, seqReadLine))
< 	{				/* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajRegSubI(seqRegPhylipTop, 1, &tmpstr);
< 	ajStrToUint(tmpstr, &iseq);
< 	ajRegSubI(seqRegPhylipTop, 2, &tmpstr);
< 	ajStrToUint(tmpstr, &len);
< 	ajStrDel(&tmpstr);
< 	/*ajDebug("first line OK: '%S' iseq: %d len: %d\n",
< 		seqReadLine, iseq, len);*/
< 
< 	seqin->SeqData = AJNEW0(phydata);
< 	phydata->Table = phytable = ajTablestrNew(1000);
< 	phylist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 	ilen = 0;
< 
< 	while(ok && (jseq < iseq))
< 	{
< 	    /* first set - create table */
< 	    if(!ajRegExec(seqRegPhylipHead, seqReadLine))
< 	    {
< 		ajDebug("FAIL (not seqRegPhylipHead): '%S'\n", seqReadLine);
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 
< 		return ajFalse;
< 	    }
< 
< 	    /* ajDebug("line: '%S'\n", seqReadLine); */
< 	    AJNEW0(phyitem);
< 	    ajRegSubI(seqRegPhylipHead, 1, &tmpstr);
< 	    seqitemSetName(phyitem, tmpstr);
< 	    ajStrDel(&tmpstr);
< 	    /* ajDebug("name: '%S' => '%S'\n", tmpstr, phyitem->Name); */
< 	    phyitem->Weight = 1.0;
< 	    ajRegPost(seqRegPhylipHead, &seqstr);
< 	    seqAppend(&phyitem->Seq, seqstr);
< 	    ajStrDel(&seqstr);
< 	    ilen = ajStrGetLen(phyitem->Seq);
< 
< 	    if(ilen == len)
< 		done = ajTrue;
< 	    else if(ilen > len)
< 	    {
< 		ajDebug("Phylip format: sequence %S header size %d exceeded\n",
< 			phyitem->Name, len);
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 		seqMsfItemDel(&phyitem);
< 
< 		ajListstrFreeData(&phylist);
< 
< 		return ajFalse;
< 	    }
< 
< 	    if(ajStrIsWhite(phyitem->Name) ||
< 	       ajTableFetchS(phytable, phyitem->Name))
< 	    {
---
>     {                                   /* start of file */
>         seqin->Multidone = ajFalse;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         while (ok && ajStrIsWhite(seqReadLine))
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         if(!ok)
>             return ajFalse;
> 
>         /* ajDebug("first line:\n'%-20.20S'\n", seqReadLine);*/
> 
>         if(!ajRegExec(seqRegPhylipTop, seqReadLine))
>         {                               /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajRegSubI(seqRegPhylipTop, 1, &tmpstr);
>         ajStrToUint(tmpstr, &iseq);
>         ajRegSubI(seqRegPhylipTop, 2, &tmpstr);
>         ajStrToUint(tmpstr, &len);
>         ajStrDel(&tmpstr);
>         /*ajDebug("first line OK: '%S' iseq: %d len: %d\n",
>           seqReadLine, iseq, len);*/
> 
>         seqin->SeqData = AJNEW0(phydata);
>         phydata->Table = phytable = ajTablestrNew(1000);
>         phylist = ajListstrNew();
>         seqin->Input->Filecount = 0;
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ilen = 0;
> 
>         while(ok && (jseq < iseq))
>         {
>             /* first set - create table */
>             if(!ajRegExec(seqRegPhylipHead, seqReadLine))
>             {
>                 ajDebug("FAIL (not seqRegPhylipHead): '%S'\n", seqReadLine);
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
> 
>                 return ajFalse;
>             }
> 
>             /* ajDebug("line: '%S'\n", seqReadLine); */
>             AJNEW0(phyitem);
>             ajRegSubI(seqRegPhylipHead, 1, &tmpstr);
>             seqitemSetName(phyitem, tmpstr);
>             ajStrDel(&tmpstr);
>             /* ajDebug("name: '%S' => '%S'\n", tmpstr, phyitem->Name); */
>             phyitem->Weight = 1.0;
>             ajRegPost(seqRegPhylipHead, &seqstr);
>             seqAppend(&phyitem->Seq, seqstr);
>             ajStrDel(&seqstr);
>             ilen = ajStrGetLen(phyitem->Seq);
> 
>             if(ilen == len)
>                 done = ajTrue;
>             else if(ilen > len)
>             {
>                 ajDebug("Phylip format: sequence %S header size %d exceeded\n",
>                         phyitem->Name, len);
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                 seqMsfItemDel(&phyitem);
> 
>                 ajListstrFreeData(&phylist);
> 
>                 return ajFalse;
>             }
> 
>             if(ajStrIsWhite(phyitem->Name) ||
>                ajTableFetchS(phytable, phyitem->Name))
>             {
7048,7083c7995,8030
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		ajDebug("phytable repeated name '%S'\n",
< 			phyitem->Name);
< 
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 		seqMsfItemDel(&phyitem);
< 
< 		ajListstrFreeData(&phylist);
< 
< 		return seqReadPhylipnon(thys, seqin);
< 	    }
< 
< 	    ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
< 	    ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
< 	    ajDebug("added '%S' list:%u table:%u\n",
< 		    phyitem->Name, ajListGetLength(phylist),
< 		    ajTableGetLength(phytable));
< 
< 	    if(!jseq)
< 		maxlen = ilen;
< 	    else
< 	    {
< 		if(ilen != maxlen)
< 		{
< 		    ajDebug("phylip format length mismatch in header "
< 			    "iseq: %d jseq: %d ilen: %d maxlen: %d\n",
< 			    iseq, jseq, ilen, maxlen);
< 		    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		    ajDebug("phytable deleted size:%u\n",
< 			    ajTableGetLength(phytable));
< 		    seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 		    ajListstrFreeData(&phylist);
< 
< 		    if(seqReadPhylipnon(thys, seqin))
< 			return ajTrue;
< 		    else
---
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 ajDebug("phytable repeated name '%S'\n",
>                         phyitem->Name);
> 
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                 seqMsfItemDel(&phyitem);
> 
>                 ajListstrFreeData(&phylist);
> 
>                 return seqReadPhylipnon(thys, seqin);
>             }
> 
>             ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
>             ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
>             ajDebug("added '%S' list:%Lu table:%Lu\n",
>                     phyitem->Name, ajListGetLength(phylist),
>                     ajTableGetLength(phytable));
> 
>             if(!jseq)
>                 maxlen = ilen;
>             else
>             {
>                 if(ilen != maxlen)
>                 {
>                     ajDebug("phylip format length mismatch in header "
>                             "iseq: %d jseq: %d ilen: %d maxlen: %d\n",
>                             iseq, jseq, ilen, maxlen);
>                     ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                     ajDebug("phytable deleted size:%Lu\n",
>                             ajTableGetLength(phytable));
>                     seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                     ajListstrFreeData(&phylist);
> 
>                     if(seqReadPhylipnon(thys, seqin))
>                         return ajTrue;
>                     else
7085c8032,8066
< 			ajWarn("phylip format length mismatch in header");
---
>                         ajWarn("phylip format length mismatch in header");
> 
>                         return ajFalse;
>                     }
>                 }
>             }
> 
>             jseq++;
>             /* ajDebug("first set %d: (%d) '%-20.20S'\n",
>                jseq, ilen, seqReadLine); */
> 
>             if(jseq < iseq)
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         /* ajDebug("Header has %d sequences\n", jseq);*/
>         ajListstrTrace(phylist);
>         ajTableTrace(phytable);
>         ajTableMap(phytable, &seqMsfTabList, NULL);
> 
>         phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(phylist, &phydata->Names[i]);
>             /* ajDebug("list [%d] '%S'\n", i, phydata->Names[i]); */
>         }
> 
>         ajListstrFreeData(&phylist);
> 
>         if(ilen < len)
>         {
>             jseq=0;
7087,7141c8068,8084
< 			return ajFalse;
< 		    }
< 		}
< 	    }
< 
< 	    jseq++;
< 	    /* ajDebug("first set %d: (%d) '%-20.20S'\n",
< 	       jseq, ilen, seqReadLine); */
< 
< 	    if(jseq < iseq)
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		seqin->Input->Records++;
< 	    }
< 	}
< 
< 	/* ajDebug("Header has %d sequences\n", jseq);*/
< 	ajListstrTrace(phylist);
< 	ajTableTrace(phytable);
< 	ajTableMap(phytable, seqMsfTabList, NULL);
< 
< 	phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(phylist, &phydata->Names[i]);
< 	    /* ajDebug("list [%d] '%S'\n", i, phydata->Names[i]); */
< 	}
< 
< 	ajListstrFreeData(&phylist);
< 
< 	if(ilen < len)
< 	{
< 	    jseq=0;
< 
< 	    while(ajBuffreadLineStore(buff, &seqReadLine,
< 				     seqin->Input->Text, &thys->TextPtr))
< 	    {				/* now read the rest */
< 		/* ajDebug("seqReadPhylip line '%S\n", seqReadLine); */
< 		seqin->Input->Records++;
< 
< 		if(seqPhylipReadseq(seqReadLine, phytable,
< 				    phydata->Names[jseq],
< 				    len, &ilen, &done))
< 		{
< 		    if(!jseq)
< 			maxlen = ilen;
< 		    else
< 		    {
< 			if(ilen != maxlen)
< 			{
< 			    ajDebug("phylip format length mismatch at %d "
< 				    "(length %d)\n",
< 				    maxlen, ilen);
---
>             while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             {                           /* now read the rest */
>                 /* ajDebug("seqReadPhylip line '%S\n", seqReadLine); */
> 
>                 if(seqPhylipReadseq(seqReadLine, phytable,
>                                     phydata->Names[jseq],
>                                     len, &ilen, &done))
>                 {
>                     if(!jseq)
>                         maxlen = ilen;
>                     else
>                     {
>                         if(ilen != maxlen)
>                         {
>                             ajDebug("phylip format length mismatch at %d "
>                                     "(length %d)\n",
>                                     maxlen, ilen);
7143,7150c8086,8088
< 			    ajFilebuffResetStore(buff,
< 						 seqin->Input->Text, &thys->TextPtr);
< 			    seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
< 			    ajDebug("File reset, try seqReadPhylipnon\n");
< 
< 			    return seqReadPhylipnon(thys, seqin);
< 			}
< 		    }
---
>                             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                             seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
>                             ajDebug("File reset, try seqReadPhylipnon\n");
7152c8090,8092
< 		    jseq++;
---
>                             return seqReadPhylipnon(thys, seqin);
>                         }
>                     }
7154c8094,8096
< 		    if(jseq == iseq)
---
>                     jseq++;
> 
>                     if(jseq == iseq)
7157,7168c8099,8110
< 		    if(!jseq && done)
< 		    {
< 			/* ajDebug("seqReadPhylip set done\n"); */
< 			break;
< 		    }
< 		    done = ajTrue;	/* for end-of-file */
< 		}
< 	    }
< 
< 	    if(!done)
< 	    {
< 		ajDebug("seqReadPhylip read failed, try seqReadPhylipnon\n");
---
>                     if(!jseq && done)
>                     {
>                         /* ajDebug("seqReadPhylip set done\n"); */
>                         break;
>                     }
>                     done = ajTrue;      /* for end-of-file */
>                 }
>             }
> 
>             if(!done)
>             {
>                 ajDebug("seqReadPhylip read failed, try seqReadPhylipnon\n");
7170,7171c8112,8113
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
7173,7174c8115,8116
< 		return seqReadPhylipnon(thys, seqin);
< 	    }
---
>                 return seqReadPhylipnon(thys, seqin);
>             }
7176,7179c8118,8121
< 	    if(jseq)
< 	    {
< 		ajDebug("Phylip format %d sequences partly read at end\n",
< 			iseq-jseq);
---
>             if(jseq)
>             {
>                 ajDebug("Phylip format %d sequences partly read at end\n",
>                         iseq-jseq);
7181,7182c8123,8124
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                 seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
7184,7192c8126,8135
< 		return seqReadPhylipnon(thys, seqin);
< 	    }
< 	}
< 
< 	ajTableMap(phytable, seqMsfTabList, NULL);
< 	phydata->Nseq = iseq;
< 	phydata->Count = 0;
< 	phydata->Bufflines = seqin->Input->Records;
< 	/* ajDebug("PHYLIP format read %d lines\n", seqin->Input->Records);*/
---
>                 return seqReadPhylipnon(thys, seqin);
>             }
>         }
> 
>         ajTableMap(phytable, &seqMsfTabList, NULL);
>         phydata->Nseq = iseq;
>         phydata->Count = 0;
>         phydata->Bufflines = ajTextinGetRecords(seqin->Input);
>         /* ajDebug("PHYLIP format read %d lines\n",
>                    ajTextinGetRecords(seqin->Input));*/
7210,7213c8153,8156
< 	seqin->Multidone = ajTrue;
< 	ajDebug("seqReadPhylip multidone\n");
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajDebug("seqReadPhylip multidone\n");
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
7235a8179,8180
> **
> ** @release 1.0.0
7240,7241c8185,8186
< 			       const AjPStr token,
< 			       ajuint len, ajuint* ilen, AjBool* done)
---
>                                const AjPStr token,
>                                ajuint len, ajuint* ilen, AjBool* done)
7248c8193
< 	seqRegPhylipSeq2 = ajRegCompC("[^ \t\n\r]");
---
>         seqRegPhylipSeq2 = ajRegCompC("[^ \t\n\r]");
7251c8196
< 	return ajFalse;
---
>         return ajFalse;
7257,7258c8202,8203
< 	ajDebug("seqPhylipReadseq failed to find '%S' in phytable\n",
< 		token);
---
>         ajDebug("seqPhylipReadseq failed to find '%S' in phytable\n",
>                 token);
7260c8205
< 	return ajFalse;
---
>         return ajFalse;
7267c8212
< 	*done = ajTrue;
---
>         *done = ajTrue;
7270,7271c8215,8216
< 	ajDebug("Phylip format error, sequence %S length %d exceeded\n",
< 		token, len);
---
>         ajDebug("Phylip format error, sequence %S length %d exceeded\n",
>                 token, len);
7273c8218
< 	return ajFalse;
---
>         return ajFalse;
7277c8222
< 	    token, len, *ilen, *done);
---
>             token, len, *ilen, *done);
7291a8237,8238
> **
> ** @release 1.0.0
7302d8248
<     AjPFilebuff buff;
7315,7316d8260
<     buff = seqin->Input->Filebuff;
< 
7318c8262
< 	seqRegHennigHead = ajRegCompC("[^1-4? \t]");
---
>         seqRegHennigHead = ajRegCompC("[^1-4? \t]");
7321c8265
< 	seqRegHennigTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
---
>         seqRegHennigTop = ajRegCompC("^ *([0-9]+) +([0-9]+)");
7324c8268
< 	seqRegHennigBlank = ajRegCompC("^[ \t\n\r]*$");
---
>         seqRegHennigBlank = ajRegCompC("^[ \t\n\r]*$");
7327c8271
< 	seqRegHennigSeq = ajRegCompC("^([^ \t\n\r]+)");
---
>         seqRegHennigSeq = ajRegCompC("^([^ \t\n\r]+)");
7331,7458c8275,8388
< 	/* start: load in file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	ajDebug("first line:\n'%S'\n", seqReadLine);
< 
< 	if(!ajStrPrefixC(seqReadLine, "xread"))
< 	{
< 	    /* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajDebug("first line OK: '%S'\n", seqReadLine);
< 
< 	/* skip title line */
< 	for(i=0; i<2; i++)
< 	{
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 
< 	    if(!ok)
< 	    {
< 		ajDebug("FAIL (bad header)\n");
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 		return ajFalse;
< 	    }
< 	}
< 
< 	if(!ajRegExec(seqRegHennigTop, seqReadLine))	/* first line test */
< 	    return ajFalse;
< 
< 	ajRegSubI(seqRegHennigTop, 1, &tmpstr);
< 	ajStrToUint(tmpstr, &iseq);
< 	ajRegSubI(seqRegHennigTop, 2, &tmpstr);
< 	ajStrToUint(tmpstr, &len);
< 	ajDebug("first line OK: '%S' iseq: %d len: %d\n",
< 		seqReadLine, iseq, len);
< 	ajStrDel(&tmpstr);
< 
< 	seqin->SeqData = AJNEW0(fmtdata);
< 	fmtdata->Table = fmttable = ajTablestrNew(1000);
< 	fmtlist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 
< 	while(ok && (jseq < iseq))
< 	{				/* first set - create table */
< 	    if(!ajRegExec(seqRegHennigHead, seqReadLine))
< 	    {
< 		ajDebug("FAIL (not seqRegHennigHead): '%S'\n", seqReadLine);
< 
< 		return ajFalse;
< 	    }
< 
< 	    AJNEW0(fmtitem);
< 	    ajStrAssignS(&fmtitem->Name, seqReadLine);
< 	    fmtitem->Weight = 1.0;
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 
< 	    while(ok && ajRegExec(seqRegHennigSeq, seqReadLine))
< 	    {
< 		ajRegPost(seqRegHennigSeq, &seqstr);
< 
< 		for(cp = ajStrGetuniquePtr(&seqstr); cp; cp++)
< 		    switch(*cp)
< 		    {
< 		    case 0: *cp = 'A';break;
< 		    case 1: *cp = 'T';break;
< 		    case 2: *cp = 'G';break;
< 		    case 3: *cp = 'C';break;
< 		    default: *cp = '.';break;
< 		    }
< 
< 		seqAppend(&fmtitem->Seq, seqstr);
< 	    }
< 
< 	    ajStrDel(&seqstr);
< 
< 	    ajTablePut(fmttable, ajStrNewS(fmtitem->Name), fmtitem);
< 	    ajListstrPushAppend(fmtlist, ajStrNewS(fmtitem->Name));
< 	    jseq++;
< 	    ajDebug("first set %d: '%S'\n", jseq, seqReadLine);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 	}
< 
< 	ajDebug("Header has %d sequences\n", iseq);
< 	ajListstrTrace(fmtlist);
< 	ajTableTrace(fmttable);
< 	ajTableMap(fmttable, seqMsfTabList, NULL);
< 
< 	fmtdata->Names = AJCALLOC(iseq, sizeof(*fmtdata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(fmtlist, &fmtdata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, fmtdata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&fmtlist);
< 
< 	while(ajBuffreadLineStore(buff, &seqReadLine,
< 				 seqin->Input->Text, &thys->TextPtr))
< 	{				/* now read the rest */
< 	    seqin->Input->Records++;
< 	    seqHennig86Readseq(seqReadLine, fmttable);
< 	}
< 
< 	ajTableMap(fmttable, seqMsfTabList, NULL);
< 	fmtdata->Nseq = iseq;
< 	fmtdata->Count = 0;
< 	fmtdata->Bufflines = seqin->Input->Records;
< 	ajDebug("... format read %d lines\n", seqin->Input->Records);
---
>         /* start: load in file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(!ok)
>             return ajFalse;
> 
>         ajDebug("first line:\n'%S'\n", seqReadLine);
> 
>         if(!ajStrPrefixC(seqReadLine, "xread"))
>         {
>             /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("first line OK: '%S'\n", seqReadLine);
> 
>         /* skip title line */
>         for(i=0; i<2; i++)
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             if(!ok)
>             {
>                 ajDebug("FAIL (bad header)\n");
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>                 return ajFalse;
>             }
>         }
> 
>         if(!ajRegExec(seqRegHennigTop, seqReadLine))    /* first line test */
>             return ajFalse;
> 
>         ajRegSubI(seqRegHennigTop, 1, &tmpstr);
>         ajStrToUint(tmpstr, &iseq);
>         ajRegSubI(seqRegHennigTop, 2, &tmpstr);
>         ajStrToUint(tmpstr, &len);
>         ajDebug("first line OK: '%S' iseq: %d len: %d\n",
>                 seqReadLine, iseq, len);
>         ajStrDel(&tmpstr);
> 
>         seqin->SeqData = AJNEW0(fmtdata);
>         fmtdata->Table = fmttable = ajTablestrNew(1000);
>         fmtlist = ajListstrNew();
>         seqin->Input->Filecount = 0;
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         while(ok && (jseq < iseq))
>         {                               /* first set - create table */
>             if(!ajRegExec(seqRegHennigHead, seqReadLine))
>             {
>                 ajDebug("FAIL (not seqRegHennigHead): '%S'\n", seqReadLine);
> 
>                 return ajFalse;
>             }
> 
>             AJNEW0(fmtitem);
>             ajStrAssignS(&fmtitem->Name, seqReadLine);
>             fmtitem->Weight = 1.0;
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             while(ok && ajRegExec(seqRegHennigSeq, seqReadLine))
>             {
>                 ajRegPost(seqRegHennigSeq, &seqstr);
> 
>                 for(cp = ajStrGetuniquePtr(&seqstr); cp; cp++)
>                     switch(*cp)
>                     {
>                         case 0: *cp = 'A';break;
>                         case 1: *cp = 'T';break;
>                         case 2: *cp = 'G';break;
>                         case 3: *cp = 'C';break;
>                         default: *cp = '.';break;
>                     }
> 
>                 seqAppend(&fmtitem->Seq, seqstr);
>             }
> 
>             ajStrDel(&seqstr);
> 
>             ajTablePut(fmttable, ajStrNewS(fmtitem->Name), fmtitem);
>             ajListstrPushAppend(fmtlist, ajStrNewS(fmtitem->Name));
>             jseq++;
>             ajDebug("first set %d: '%S'\n", jseq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         ajDebug("Header has %d sequences\n", iseq);
>         ajListstrTrace(fmtlist);
>         ajTableTrace(fmttable);
>         ajTableMap(fmttable, &seqMsfTabList, NULL);
> 
>         fmtdata->Names = AJCALLOC(iseq, sizeof(*fmtdata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(fmtlist, &fmtdata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, fmtdata->Names[i]);
>         }
> 
>         ajListstrFreeData(&fmtlist);
> 
>         while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         {                               /* now read the rest */
>             seqHennig86Readseq(seqReadLine, fmttable);
>         }
> 
>         ajTableMap(fmttable, &seqMsfTabList, NULL);
>         fmtdata->Nseq = iseq;
>         fmtdata->Count = 0;
>         fmtdata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("... format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
7467,7473c8397,8403
<     {					/* all done */
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	ajTableMapDel(fmttable, seqMsfTabDel, NULL);
< 	ajTableFree(&fmttable);
< 	AJFREE(fmtdata->Names);
< 	AJFREE(fmtdata);
< 	seqin->SeqData = NULL;
---
>     {                                   /* all done */
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         ajTableMapDel(fmttable, &seqMsfTabDel, NULL);
>         ajTableFree(&fmttable);
>         AJFREE(fmtdata->Names);
>         AJFREE(fmtdata);
>         seqin->SeqData = NULL;
7475c8405
< 	return ajFalse;
---
>         return ajFalse;
7501a8432,8433
> **
> ** @release 1.0.0
7512c8444
< 	seqRegHennigSeq = ajRegCompC("^[^ \t\n\r]+"); /* must be line start */
---
>         seqRegHennigSeq = ajRegCompC("^[^ \t\n\r]+"); /* must be line start */
7515c8447
< 	return ajFalse;
---
>         return ajFalse;
7522c8454
< 	return ajFalse;
---
>         return ajFalse;
7548a8481,8482
> **
> ** @release 2.0.0
7560d8493
<     AjPFilebuff buff;
7568,7569d8500
<     buff = seqin->Input->Filebuff;
< 
7571c8502
< 	seqRegTreeconTop = ajRegCompC("^ *([0-9]+)");
---
>         seqRegTreeconTop = ajRegCompC("^ *([0-9]+)");
7573c8504
<     if(!seqin->SeqData)			/* first time - read the data */
---
>     if(!seqin->SeqData)                 /* first time - read the data */
7575,7605c8506,8531
< 	iseq = 0;
< 	seqin->Multidone = ajFalse;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                  seqin->Input->Text, &thys->TextPtr);
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	if(!ajRegExec(seqRegTreeconTop, seqReadLine))
< 	{				/* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajRegSubI(seqRegTreeconTop, 1, &tmpstr);
< 	ajStrToInt(tmpstr, &len);
< 	ajDebug("first line OK: len: %d\n",
< 		len);
< 	ajStrDel(&tmpstr);
< 
< 	seqin->SeqData = AJNEW0(phydata);
< 	phydata->Table = phytable = ajTablestrNew(1000);
< 	phylist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 	ilen = UINT_MAX;
---
>         iseq = 0;
>         seqin->Multidone = ajFalse;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(!ok)
>             return ajFalse;
> 
>         if(!ajRegExec(seqRegTreeconTop, seqReadLine))
>         {                               /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajRegSubI(seqRegTreeconTop, 1, &tmpstr);
>         ajStrToInt(tmpstr, &len);
>         ajDebug("first line OK: len: %d\n",
>                 len);
>         ajStrDel(&tmpstr);
> 
>         seqin->SeqData = AJNEW0(phydata);
>         phydata->Table = phytable = ajTablestrNew(1000);
>         phylist = ajListstrNew();
>         seqin->Input->Filecount = 0;
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ilen = UINT_MAX;
7609c8535,8587
<             ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
> 
>             return ajFalse;
>         }
> 
>         while (ok)
>         {
>             if (ilen < 0)
>             {
>                 ajStrRemoveWhiteExcess(&seqReadLine);
> 
>                 if (!ajStrGetLen(seqReadLine))   /* empty line after sequence */
>                 {
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     continue;
>                 }
> 
>                 AJNEW0(phyitem);
>                 phyitem->Weight = 1.0;
>                 seqitemSetName(phyitem, seqReadLine);
>                 ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
>                 ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
>                 iseq++;
>                 ilen = 0;
>             }
>             else
>             {
>                 ajStrRemoveWhite(&seqReadLine);
>                 ilen += ajStrGetLen(seqReadLine);
>                 seqAppend(&phyitem->Seq, seqReadLine);
> 
>                 if (ilen > len)
>                 {
>                     ajDebug("Treecon format: '%S' too long, read %d/%d\n",
>                             phyitem->Name, ilen, len);
>                     ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                     seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
> 
>                     return ajFalse;
>                 }
> 
>                 if (ilen == len)
>                     ilen = -1;
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if (ilen >= 0)
>         {
>             ajDebug("Treecon format: unfinished sequence '%S' read %d/%d\n",
>                     phyitem->Name, ilen, len);
7615,7681c8593,8606
< 	while (ok)
< 	{
< 	   if (ilen < 0)
< 	   {
< 	       ajStrRemoveWhiteExcess(&seqReadLine);
< 
< 	       if (!ajStrGetLen(seqReadLine))	/* empty line after sequence */
< 	       {
< 		   ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					   seqin->Input->Text, &thys->TextPtr);
< 		   continue;
< 	       }
< 
< 	       AJNEW0(phyitem);
< 	       phyitem->Weight = 1.0;
< 	       seqitemSetName(phyitem, seqReadLine);
< 	       ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
< 	       ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
< 	       iseq++;
< 	       ilen = 0;
< 	   }
< 	   else
< 	   {
< 	       ajStrRemoveWhite(&seqReadLine);
< 	       ilen += ajStrGetLen(seqReadLine);
< 	       seqAppend(&phyitem->Seq, seqReadLine);
< 	       
< 	       if (ilen > len)
< 	       {
< 		   ajDebug("Treecon format: '%S' too long, read %d/%d\n",
< 		    phyitem->Name, ilen, len);
< 		ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 		seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
< 
< 		return ajFalse;
< 	       }
< 
< 	       if (ilen == len)
< 		   ilen = -1;
< 	   }
< 
< 	   ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				   seqin->Input->Text, &thys->TextPtr);
< 	}
< 
< 	if (ilen >= 0)
< 	{
< 	    ajDebug("Treecon format: unfinished sequence '%S' read %d/%d\n",
< 		    phyitem->Name, ilen, len);
< 	    seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
< 
< 	    return ajFalse;
< 	}
< 
< 	phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(phylist, &phydata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, phydata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&phylist);
< 	phydata->Nseq = iseq;
< 	phydata->Count = 0;
< 	phydata->Bufflines = seqin->Input->Records;
< 	ajDebug("Treecon format read %d lines\n", seqin->Input->Records);
---
>         phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(phylist, &phydata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, phydata->Names[i]);
>         }
> 
>         ajListstrFreeData(&phylist);
>         phydata->Nseq = iseq;
>         phydata->Count = 0;
>         phydata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("Treecon format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
7699,7702c8624,8627
< 	seqin->Multidone = ajTrue;
< 	ajDebug("seqReadTreecon multidone\n");
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajDebug("seqReadTreecon multidone\n");
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
7716c8641
< ** implements the jackknife method to test the reliability of branches. 
---
> ** implements the jackknife method to test the reliability of branches.
7728a8654,8655
> **
> ** @release 2.0.0
7739d8665
<     AjPFilebuff buff;
7747,7748d8672
<     buff = seqin->Input->Filebuff;
< 
7750c8674
< 	seqRegJackTop = ajRegCompC("^'(.*)'\\s*$");
---
>         seqRegJackTop = ajRegCompC("^'(.*)'\\s*$");
7753c8677
< 	seqRegJackSeq = ajRegCompC("^[(]([^)]+)(.*)$");
---
>         seqRegJackSeq = ajRegCompC("^[(]([^)]+)(.*)$");
7755c8679
<     if(!seqin->SeqData)			/* first time - read the data */
---
>     if(!seqin->SeqData)                 /* first time - read the data */
7757,7845c8681,8764
< 	iseq = 0;
< 	seqin->Multidone = ajFalse;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	if(!ajRegExec(seqRegJackTop, seqReadLine))
< 	{				/* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 
< 	    return ajFalse;
< 	}
< 
< 	ajDebug("JackKnifer format: First line ok '%S'\n", seqReadLine);
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 
< 	seqin->SeqData = AJNEW0(phydata);
< 	phydata->Table = phytable = ajTablestrNew(1000);
< 	phylist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 
< 	while (ok)
< 	{
< 	    if (!ajStrGetLen(seqReadLine))	/* empty line after sequence */
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		continue;
< 	    }
< 
< 	    if (ajStrPrefixC(seqReadLine, ";"))
< 		break;			/* done */
< 
< 	    if (ajStrPrefixC(seqReadLine, "("))
< 	    {
< 		if (!ajRegExec(seqRegJackSeq, seqReadLine))
< 		{
< 		    ajDebug("JackKnifer format: bad (id) line\n");
< 		    seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
< 
< 		    return ajFalse;
< 		}
< 
< 		ajRegSubI(seqRegJackSeq, 1, &tmpstr);
< 		seqnameSetName(&tmpname, tmpstr);
< 		phyitem = ajTableFetchmodS(phytable, tmpname);
< 
< 		if (!phyitem)
< 		{
< 		    ajDebug("JackKnifer format: new (id) '%S'\n", tmpname);
< 		    AJNEW0(phyitem);
< 		    phyitem->Weight = 1.0;
< 		    ajStrAssignS(&phyitem->Name,tmpname);
< 		    ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
< 		    ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
< 		    iseq++;
< 		}
< 		else
< 		    ajDebug("JackKnifer format: More for (id) '%S'\n",
< 			    tmpname);
< 
< 		ajRegSubI(seqRegJackSeq, 2, &tmpstr);
< 		ajStrAssignS(&seqReadLine, tmpstr);
< 	    }
< 
< 	    seqAppend(&phyitem->Seq, seqReadLine);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				   seqin->Input->Text, &thys->TextPtr);
< 	}
< 
< 	phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(phylist, &phydata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, phydata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&phylist);
< 	phydata->Nseq = iseq;
< 	phydata->Count = 0;
< 	phydata->Bufflines = seqin->Input->Records;
< 	ajDebug("JackKnifer format read %d lines\n", seqin->Input->Records);
---
>         iseq = 0;
>         seqin->Multidone = ajFalse;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(!ok)
>             return ajFalse;
> 
>         if(!ajRegExec(seqRegJackTop, seqReadLine))
>         {                               /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
> 
>         ajDebug("JackKnifer format: First line ok '%S'\n", seqReadLine);
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         seqin->SeqData = AJNEW0(phydata);
>         phydata->Table = phytable = ajTablestrNew(1000);
>         phylist = ajListstrNew();
>         seqin->Input->Filecount = 0;
> 
>         while (ok)
>         {
>             if (!ajStrGetLen(seqReadLine))      /* empty line after sequence */
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 continue;
>             }
> 
>             if (ajStrPrefixC(seqReadLine, ";"))
>                 break;                  /* done */
> 
>             if (ajStrPrefixC(seqReadLine, "("))
>             {
>                 if (!ajRegExec(seqRegJackSeq, seqReadLine))
>                 {
>                     ajDebug("JackKnifer format: bad (id) line\n");
>                     seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
> 
>                     return ajFalse;
>                 }
> 
>                 ajRegSubI(seqRegJackSeq, 1, &tmpstr);
>                 seqnameSetName(&tmpname, tmpstr);
>                 phyitem = ajTableFetchmodS(phytable, tmpname);
> 
>                 if (!phyitem)
>                 {
>                     ajDebug("JackKnifer format: new (id) '%S'\n", tmpname);
>                     AJNEW0(phyitem);
>                     phyitem->Weight = 1.0;
>                     ajStrAssignS(&phyitem->Name,tmpname);
>                     ajTablePut(phytable, ajStrNewS(phyitem->Name), phyitem);
>                     ajListstrPushAppend(phylist, ajStrNewS(phyitem->Name));
>                     iseq++;
>                 }
>                 else
>                     ajDebug("JackKnifer format: More for (id) '%S'\n",
>                             tmpname);
> 
>                 ajRegSubI(seqRegJackSeq, 2, &tmpstr);
>                 ajStrAssignS(&seqReadLine, tmpstr);
>             }
> 
>             seqAppend(&phyitem->Seq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         phydata->Names = AJCALLOC(iseq, sizeof(*phydata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(phylist, &phydata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, phydata->Names[i]);
>         }
> 
>         ajListstrFreeData(&phylist);
>         phydata->Nseq = iseq;
>         phydata->Count = 0;
>         phydata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("JackKnifer format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
7867,7870c8786,8789
< 	seqin->Multidone = ajTrue;
< 	ajDebug("seqReadJackKnifer multidone\n");
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajDebug("seqReadJackKnifer multidone\n");
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
7890a8810,8811
> **
> ** @release 2.0.0
7900a8822
>     AjPStr* names = NULL;
7907c8829
<     if(!seqin->SeqData)			/* first time - read the data */
---
>     if(!seqin->SeqData)                 /* first time - read the data */
7909,7911c8831
< 	seqin->Multidone = ajFalse;
< 
< 	ajFilebuffSetBuffered(buff);
---
>         seqin->Multidone = ajFalse;
7913,7915c8833
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	ajDebug("Nexus format: Testing first line '%S'\n", seqReadLine);
---
>         ajFilebuffSetBuffered(buff);
7917,7918c8835,8836
< 	if(!ok)
< 	    return ajFalse;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ajDebug("Nexus format: Testing first line '%S'\n", seqReadLine);
7920c8838,8839
< 	seqin->Input->Records++;
---
>         if(!ok)
>             return ajFalse;
7922,7926c8841,8845
< 	if(!ajStrPrefixCaseC(seqReadLine, "#NEXUS"))
< 	{				/* first line test */
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    return ajFalse;
< 	}
---
>         if(!ajStrPrefixCaseC(seqReadLine, "#NEXUS"))
>         {                               /* first line test */
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             return ajFalse;
>         }
7928c8847
< 	ajDebug("Nexus format: First line ok '%S'\n", seqReadLine);
---
>         ajDebug("Nexus format: First line ok '%S'\n", seqReadLine);
7930,7931c8849
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
7933,7935c8851,8852
< 	while(ok && !ajStrPrefixCaseC(seqReadLine, "#NEXUS"))
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
---
>         while(ok && !ajStrPrefixCaseC(seqReadLine, "#NEXUS"))
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
7937c8854
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
7939,7940c8856,8857
< 	AJNEW0(phydata);
< 	phydata->Nexus = ajNexusParse(buff);
---
>         AJNEW0(phydata);
>         phydata->Nexus = ajNexusParse(buff);
7942,7945c8859,8862
< 	if (!phydata->Nexus)
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    ajDebug("Failed to parse in nexus format\n");
---
>         if (!phydata->Nexus)
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajDebug("Failed to parse in nexus format\n");
7947,7948c8864,8865
< 	    return ajFalse;
< 	}
---
>             return ajFalse;
>         }
7950,7954c8867,8871
< 	phydata->Count = 0;
< 	phydata->Nseq = ajNexusGetNtaxa(phydata->Nexus);
< 	/* GetTaxa may fail if names are only defined in the sequences */
< 	seqs = ajNexusGetTaxa(phydata->Nexus);
< 	phydata->Names = AJCALLOC(phydata->Nseq, sizeof(*phydata->Names));
---
>         phydata->Count = 0;
>         phydata->Nseq = ajNexusGetNtaxa(phydata->Nexus);
>         /* GetTaxa may fail if names are only defined in the sequences */
>         seqs = ajNexusGetTaxa(phydata->Nexus);
>         phydata->Names = AJCALLOC(phydata->Nseq, sizeof(*phydata->Names));
7956,7957c8873,8877
< 	for(j=0;j<phydata->Nseq;j++)
< 	    ajStrAssignS(&phydata->Names[j], seqs[j]);
---
>         if(seqs)
>         {
>             for(j=0;j<phydata->Nseq;j++)
>                 ajStrAssignS(&phydata->Names[j], seqs[j]);
>         }
7959,7960c8879,8880
< 	seqin->SeqData = phydata;
< 	ajDebug("Nexus parsed %d sequences\n", phydata->Nseq);
---
>         seqin->SeqData = phydata;
>         ajDebug("Nexus parsed %d sequences\n", phydata->Nseq);
7969d8888
< 
7972c8891
< 	seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
---
>         seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
7974c8893
< 	return ajFalse;
---
>         return ajFalse;
7977c8896,8902
<     if (!phydata->Names)		/* finally set from the sequences */
---
>     thys->Weight = 1.0;
>     ajStrAssignS(&thys->Seq, seqs[i]);
> 
>     if (!phydata->Names)
>         phydata->Names = AJCALLOC(phydata->Nseq, sizeof(*phydata->Names));
> 
>     if (!phydata->Names[0])             /* finally set from the sequences */
7979,7980c8904
< 	seqs = ajNexusGetTaxa(phydata->Nexus);
< 	phydata->Names = AJCALLOC(phydata->Nseq, sizeof(*phydata->Names));
---
>         names = ajNexusGetTaxa(phydata->Nexus);
7982,7983c8906,8907
< 	for(j=0;j<phydata->Nseq;j++)
< 	    ajStrAssignS(&phydata->Names[j], seqs[j]);
---
>         for(j=0;j<phydata->Nseq;j++)
>             ajStrAssignS(&phydata->Names[j], names[j]);
7990,7992d8913
<     thys->Weight = 1.0;
<     ajStrAssignS(&thys->Seq, seqs[i]);
< 
7997,8000c8918,8921
< 	seqin->Multidone = ajTrue;
< 	ajDebug("seqReadNexus multidone\n");
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajDebug("seqReadNexus multidone\n");
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
8021a8943,8944
> **
> ** @release 2.0.0
8035d8957
<     AjPFilebuff buff;
8049c8971
<     
---
> 
8070,8071d8991
<     buff = seqin->Input->Filebuff;
< 
8073c8993
< 	seqRegMegaCommand = ajRegCompC("([^ =!]+)=([^ ;]+)");
---
>         seqRegMegaCommand = ajRegCompC("([^ =!]+)=([^ ;]+)");
8076c8996
< 	seqRegMegaFeat = ajRegCompC("^(.*)\"[^\"]*\"(.*)$");
---
>         seqRegMegaFeat = ajRegCompC("^(.*)\"[^\"]*\"(.*)$");
8079c8999
< 	seqRegMegaSeq = ajRegCompC("^#([^ \t\n\r]+)(.*)$");
---
>         seqRegMegaSeq = ajRegCompC("^#([^ \t\n\r]+)(.*)$");
8091,8092c9011,9012
< 	iseq = 0;
< 	seqin->Multidone = ajFalse;
---
>         iseq = 0;
>         seqin->Multidone = ajFalse;
8096,8097c9016
<             ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8103,8104d9021
<             seqin->Input->Records++;
< 
8106,8107c9023,9024
<             {				/* first line test */
<                 ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             {                           /* first line test */
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
8114,8115c9031
<             ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                      seqin->Input->Text, &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8119,8120d9034
<             seqin->Input->Records++;
< 
8123,8124c9037,9038
<             {				/* first line test */
<                 ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>             {                           /* first line test */
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
8138c9052
<         
---
> 
8145c9059
<             {				/* skip comments in header */
---
>             {                           /* skip comments in header */
8193c9107
<                     
---
> 
8197c9111
<             
---
> 
8210,8211c9124,9125
< 				    ajDebug("command: Gene='%S'\n",
< 					    formatValue);
---
>                                     ajDebug("command: Gene='%S'\n",
>                                             formatValue);
8213c9127
<                     
---
> 
8217,8218c9131,9132
< 				    ajDebug("command: Domain='%S'\n",
< 					    formatValue);
---
>                                     ajDebug("command: Domain='%S'\n",
>                                             formatValue);
8229,8230c9143
<                 ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text, &thys->TextPtr);
---
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8232d9144
<                 seqin->Input->Records++;
8238c9150
<                 ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>                 ajTextinStoreReset(seqin->Input, &thys->TextPtr);
8265,8266c9177
<             ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text, &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8268d9178
<             seqin->Input->Records++;
8271c9181
<             ajTableMapDel(phydata->Table, seqMsfTabDel, NULL);
---
>             ajTableMapDel(phydata->Table, &seqMsfTabDel, NULL);
8280,8281c9190,9191
< 	while (ok)
< 	{
---
>         while (ok)
>         {
8299c9209
<                     
---
> 
8309c9219
<             
---
> 
8311,8316c9221,9225
< 	    if (!ajStrGetLen(seqReadLine))
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		continue;
< 	    }
---
>             if (!ajStrGetLen(seqReadLine))
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 continue;
>             }
8318c9227
< 	    if (ajStrPrefixC(seqReadLine, "!"))
---
>             if (ajStrPrefixC(seqReadLine, "!"))
8367,8368c9276,9277
< 		ajDebug("Append '%S' len %u\n",
< 			phyitem->Name, ajStrGetLen(phyitem->Seq));
---
>                 ajDebug("Append '%S' len %u\n",
>                         phyitem->Name, ajStrGetLen(phyitem->Seq));
8384,8385c9293,9294
< 			ajDebug("command: Gene='%S'\n",
< 				formatValue);
---
>                         ajDebug("command: Gene='%S'\n",
>                                 formatValue);
8393,8394c9302,9303
< 			ajDebug("command: Domain='%S'\n",
< 				formatValue);
---
>                         ajDebug("command: Domain='%S'\n",
>                                 formatValue);
8401c9310
<             
---
> 
8405,8409c9314,9315
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				   seqin->Input->Text, &thys->TextPtr);
<             seqin->Input->Records++;
< 
< 	}
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
8416,8424c9322,9330
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(phylist, &phydata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&phylist);
< 	phydata->Nseq = iseq;
< 	phydata->Count = 0;
< 	phydata->Bufflines = seqin->Input->Records;
---
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(phylist, &phydata->Names[i]);
>         }
> 
>         ajListstrFreeData(&phylist);
>         phydata->Nseq = iseq;
>         phydata->Count = 0;
>         phydata->Bufflines = ajTextinGetRecords(seqin->Input);
8483c9389
<     while(*cp) 
---
>     while(*cp)
8493c9399
<     
---
> 
8498c9404
< 	seqin->Multidone = ajTrue;
---
>         seqin->Multidone = ajTrue;
8528a9435,9436
> **
> ** @release 1.0.0
8534,8535d9441
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
8538c9444
< 
---
>     AjBool done = ajFalse;
8542,8546c9448,9449
<     if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			   seqin->Input->Text, &thys->TextPtr))
< 	return ajFalse;
< 
<     seqin->Input->Records++;
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         return ajFalse;
8552c9455
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
8554c9457
< 	return ajFalse;
---
>         return ajFalse;
8557,8559c9460,9462
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
<     ajStrTokenNextParse(&handle, &token);	/* 'ENTRY' */
<     ajStrTokenNextParse(&handle, &token);	/* entry name */
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>     ajStrTokenStep(seqHandle);       /* 'ENTRY' */
>     ajStrTokenNextParse(seqHandle, &seqToken);       /* entry name */
8561c9464
<     seqSetName(thys, token);
---
>     seqSetName(thys, seqToken);
8563,8564c9466
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8568c9470,9484
< 	seqin->Input->Records++;
---
>         done = ajFalse;
> 
>         if(ajStrPrefixC(seqReadLine, "ACCESSION "))
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'ACCESSION' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* accnum */
>             seqAccSave(thys, seqToken);
>         }
> 
>         if(ajStrPrefixC(seqReadLine, "TITLE "))
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'TITLE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc); /* desc */
8570,8594c9486,9487
< 	if(ajStrPrefixC(seqReadLine, "ACCESSION "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'AC' */
< 	    ajStrTokenNextParse(&handle, &token); /* accnum */
< 	    seqAccSave(thys, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "TITLE "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 		ajStrTokenNextParseC(&handle, "\n\r", &token);
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 	    }
< 	}
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
8596,8597c9489,9500
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken);
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         if(!done)
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8600,8601c9503
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8605,8608c9507,9508
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8613,8614c9513,9514
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
8622c9522
< /* @funcstatic seqReadAce ***************************************************
---
> /* @funcstatic seqReadAce *****************************************************
8629a9530,9531
> **
> ** @release 6.2.0
8635,8636d9536
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
8651,8653c9551,9552
<     {					/* start of file */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                  seqin->Input->Text, &thys->TextPtr);
---
>     {                                   /* start of file */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8655c9554
< 	    return ajFalse;
---
>             return ajFalse;
8659,8661c9558,9560
<         ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
<         ajStrTokenNextParseC(&handle, " \t", &token); /* 'AS ncontig nseq' */
<         ajDebug("Token 1 '%S'\n", token);
---
>         ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>         ajStrTokenNextParseC(seqHandle, " \t", &seqToken); /* 'AS ncontig nseq' */
>         ajDebug("Token 1 '%S'\n", seqToken);
8663c9562
<         if(!ajStrMatchCaseC(token, "AS"))
---
>         if(!ajStrMatchCaseC(seqToken, "AS"))
8665,8667c9564,9566
<             ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
<             ajStrDel(&token);
<             ajStrTokenDel(&handle);
---
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrDelStatic(&seqToken);
>             ajStrTokenDel(&seqHandle);
8671,8674c9570,9573
<         ajStrTokenNextParseC(&handle, " \t", &token); /* number of contigs */
<         ajStrToUint(token, &icontig);
<         ajStrTokenNextParseC(&handle, " \t", &token); /* number of reads */
<         ajStrToUint(token, &iseq);
---
>         ajStrTokenNextParseC(seqHandle, " \t", &seqToken); /* number of contigs */
>         ajStrToUint(seqToken, &icontig);
>         ajStrTokenNextParseC(seqHandle, " \t", &seqToken); /* number of reads */
>         ajStrToUint(seqToken, &iseq);
8687c9586
<     
---
> 
8703,8706c9602,9605
< 	seqin->Multidone = ajTrue;
< 	ajDebug("seqReadAce Multidone\n");
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
---
>         seqin->Multidone = ajTrue;
>         ajDebug("seqReadAce Multidone\n");
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*) &seqin->SeqData);
8710c9609
<     
---
> 
8713,8714c9612,9613
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
8729a9629,9630
> **
> ** @release 1.0.0
8735,8736d9635
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
8746,8749c9645
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(ok)
<             seqin->Input->Records++;
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8751c9647
< 	    (ajStrPrefixC(seqReadLine, "//") ||
---
>             (ajStrPrefixC(seqReadLine, "//") ||
8756c9652
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
8758c9654
< 	return ajFalse;
---
>         return ajFalse;
8764,8766c9660,9662
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
<     ajStrTokenNextParseC(&handle, " \t", &token); /* 'DNA' or 'Peptide'*/
<     ajDebug("Token 1 '%S'\n", token);
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>     ajStrTokenNextParseC(seqHandle, " \t", &seqToken); /* 'DNA' or 'Peptide'*/
>     ajDebug("Token 1 '%S'\n", seqToken);
8768c9664
<     if(ajStrMatchCaseC(token, "Peptide"))
---
>     if(ajStrMatchCaseC(seqToken, "Peptide"))
8770,8771c9666,9667
< 	ajDebug("Protein\n");
< 	ajSeqSetProt(thys);
---
>         ajDebug("Protein\n");
>         ajSeqSetProt(thys);
8773c9669
<     else if(ajStrMatchCaseC(token, "DNA"))
---
>     else if(ajStrMatchCaseC(seqToken, "DNA"))
8775,8776c9671,9672
< 	ajDebug("DNA\n");
< 	ajSeqSetNuc(thys);
---
>         ajDebug("DNA\n");
>         ajSeqSetNuc(thys);
8780,8783c9676,9679
< 	ajDebug("unknown - failed\n");
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrTokenDel(&handle);
< 	ajStrDel(&token);
---
>         ajDebug("unknown - failed\n");
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrTokenReset(seqHandle);
>         ajStrDelStatic(&seqToken);
8785c9681
< 	return ajFalse;
---
>         return ajFalse;
8788c9684
<     ajStrTokenNextParseC(&handle, " \t\"", &token); /* : */
---
>     ajStrTokenNextParseC(seqHandle, " \t\"", &seqToken); /* : */
8790c9686
<     if(!ajStrMatchC(token, ":"))
---
>     if(!ajStrMatchC(seqToken, ":"))
8792,8794c9688,9690
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrTokenDel(&handle);
< 	ajStrDel(&token);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrTokenReset(seqHandle);
>         ajStrDelStatic(&seqToken);
8796c9692
< 	return ajFalse;
---
>         return ajFalse;
8799c9695
<     ajStrTokenNextParseC(&handle, "\"", &token);	/* name */
---
>     ajStrTokenNextParseC(seqHandle, "\"", &seqToken);        /* name */
8801c9697
<     if(!ajStrGetLen(token))
---
>     if(!ajStrGetLen(seqToken))
8803,8805c9699,9701
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrTokenDel(&handle);
< 	ajStrDel(&token);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrTokenReset(seqHandle);
>         ajStrDelStatic(&seqToken);
8807c9703
< 	return ajFalse;
---
>         return ajFalse;
8814c9710
<     seqSetName(thys, token);
---
>     seqSetName(thys, seqToken);
8818,8819c9714
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8822,8825c9717,9718
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8830,8831c9723,9724
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
8846a9740,9741
> **
> ** @release 6.3.0
8852d9746
<     AjPStr token     = NULL;
8854d9747
<     AjPStrTok handle = NULL;
8861,8862c9754
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
8871c9763
<     
---
> 
8874c9766
<     if(ifields < 2) 
---
>     if(ifields < 2)
8877,8879c9769
<     seqin->Input->Records++;
<     
<     ajStrTokenAssignC(&handle, seqReadLine, "\t\n");
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, "\t\n");
8881,8882c9771,9772
<     ajStrTokenNextParseNoskip(&handle,&token); /* sequence */
<     seqAppend(&thys->Seq, token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* sequence */
>     seqAppend(&thys->Seq, seqToken);
8884,8885c9774,9775
<     ajStrTokenNextParseNoskip(&handle,&token); /* identifier*/
<     seqSetName(thys, token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* identifier*/
>     seqSetName(thys, seqToken);
8889c9779
<         ajStrTokenNextParseNoskip(&handle,&token); /* non-sequence*/
---
>         ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* non-sequence*/
8891c9781
<         if(ajStrGetLen(token))
---
>         if(ajStrGetLen(seqToken))
8896c9786
<             ajStrAppendS(&thys->Desc, token);
---
>             ajStrAppendS(&thys->Desc, seqToken);
8902,8904c9792,9794
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
< 	   
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
> 
8911c9801
< /* @funcstatic seqReadDAS ****************************************************
---
> /* @funcstatic seqReadDAS *****************************************************
8917a9808,9809
> **
> ** @release 6.4.0
8938c9830
<     r = seqin->Input->Count;
---
>     r = ajTextinGetCount(seqin->Input);
8942c9834
< 	doc = ajDomImplementationCreateDocument(NULL,NULL,NULL);
---
>         doc = ajDomImplementationCreateDocument(NULL,NULL,NULL);
8944,8948c9836,9840
< 	if (ajDomReadFilebuff(doc,buff) == -1)
< 	{
< 	    ajDomDocumentDestroyNode(doc,doc);
< 	    return AJFALSE;
< 	}
---
>         if (ajDomReadFilebuff(doc,buff) == -1)
>         {
>             ajDomDocumentDestroyNode(doc,&doc);
>             return AJFALSE;
>         }
8950,8951c9842,9843
< 	ajFilebuffClear(buff, 0);
< 	seqin->SeqData = doc;
---
>         ajFilebuffClear(buff, 0);
>         seqin->SeqData = doc;
8954c9846
< 	doc = seqin->SeqData;
---
>         doc = seqin->SeqData;
8961,8963c9853,9855
< 	ajDomDocumentDestroyNodeList(doc,segments,AJDOMKEEP);
< 	ajDomDocumentDestroyNode(doc,doc);
< 	return AJFALSE;
---
>         ajDomDocumentDestroyNodeList(doc,&segments,AJDOMKEEP);
>         ajDomDocumentDestroyNode(doc,&doc);
>         return AJFALSE;
8975,8978c9867,9870
< 	ajStrDel(&attval);
< 	ajDomDocumentDestroyNodeList(doc,segments,AJDOMKEEP);
< 	ajDomDocumentDestroyNode(doc,doc);
< 	return AJFALSE;
---
>         ajStrDel(&attval);
>         ajDomDocumentDestroyNodeList(doc,&segments,AJDOMKEEP);
>         ajDomDocumentDestroyNode(doc,&doc);
>         return AJFALSE;
8985,8986c9877,9878
< 	ajFmtPrintS(&seqname,"%S %u,%u",
< 	            attval, seqin->Begin, seqin->End);
---
>         ajFmtPrintS(&seqname,"%S %u,%u",
>                     attval, seqin->Begin, seqin->End);
8988c9880
< 	seqSetName(thys, seqname);
---
>         seqSetName(thys, seqname);
8990c9882
< 	ajStrDel(&seqname);
---
>         ajStrDel(&seqname);
9009,9035c9901,9927
<     if(seqin->Features)
<     {
< 	AjPStr ftq, host, port, fqpath;
< 	ajFeattabInDel(&seqin->Ftquery);
< 	ajFilebuffClear(seqin->Input->Filebuff, -1);
< 
< 	// get sequence query url
< 
< 	// construct features query url based on sequence query url
< 
< 	ajDasdbQueryGet(seqin, host, port, fqpath);
< 
< 	seqin->Ftquery = ajFeattabInNewCSF("das", thys->Name,
< 	                                   ajStrGetPtr(seqin->Type),
< 	                                   seqin->Input->Filebuff);
< 	ajDebug("GFF FEAT TabIn %x\n", seqin->Ftquery);
< 	//ftfile = NULL;		  // now copied to seqin->FeattabIn
< 	ajFeattableDel(&seqin->Fttable);
< 	seqin->Fttable = ajFeattableNewRead(seqin->Ftquery);
<         if(seqin->Fttable)
<             ajFeattableSetLength(seqin->Fttable, ajStrGetLen(thys->Seq));
< 	ajFeattableTrace(seqin->Fttable);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = seqin->Fttable;
< 	seqin->Fttable = NULL;
<     }
<      */
---
>       if(seqin->Features)
>       {
>       AjPStr ftq, host, port, fqpath;
>       ajFeattabInDel(&seqin->Ftquery);
>       ajFilebuffClear(seqin->Input->Filebuff, -1);
> 
>       // get sequence query url
> 
>       // construct features query url based on sequence query url
> 
>       ajDasdbQueryGet(seqin, host, port, fqpath);
> 
>       seqin->Ftquery = ajFeattabInNewCSF("das", thys->Name,
>       ajStrGetPtr(seqin->Type),
>       seqin->Input->Filebuff);
>       ajDebug("GFF FEAT TabIn %x\n", seqin->Ftquery);
>       //ftfile = NULL;                  // now copied to seqin->FeattabIn
>       ajFeattableDel(&seqin->Fttable);
>       seqin->Fttable = ajFeattableNewRead(seqin->Ftquery);
>       if(seqin->Fttable)
>       ajFeattableSetLength(seqin->Fttable, ajStrGetLen(thys->Seq));
>       ajFeattableTrace(seqin->Fttable);
>       ajFeattableDel(&thys->Fttable);
>       thys->Fttable = seqin->Fttable;
>       seqin->Fttable = NULL;
>       }
>     */
9037c9929
<     ajDomDocumentDestroyNodeList(doc,segments,AJDOMKEEP);
---
>     ajDomDocumentDestroyNodeList(doc,&segments,AJDOMKEEP);
9046c9938
< /* @funcstatic seqReadFitch *************************************************
---
> /* @funcstatic seqReadFitch ***************************************************
9053a9946,9947
> **
> ** @release 2.8.0
9064,9065c9958,9959
<    if (!seqRegFitchHead)
< 	seqRegFitchHead = ajRegCompC("^(\\S+),\\s+(\\d+)\\s+bases\n");
---
>     if (!seqRegFitchHead)
>         seqRegFitchHead = ajRegCompC("^(\\S+),\\s+(\\d+)\\s+bases\n");
9069,9070c9963
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9076c9969
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
9078c9971
< 	return ajFalse;
---
>         return ajFalse;
9094,9095c9987
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9099,9101c9991,9992
< 	seqAppend(&thys->Seq, seqReadLine);
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9126a10018,10019
> **
> ** @release 2.8.0
9138c10031
< 	seqRegMaseHead = ajRegCompC("^(;+)");
---
>         seqRegMaseHead = ajRegCompC("^(;+)");
9142,9143c10035
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9146c10038
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
9148c10040
< 	return ajFalse;
---
>         return ajFalse;
9157,9159c10049,10051
< 	if(ajRegLenI(seqRegMaseHead, 1) == 1)
< 	{
< 	    ajRegPost(seqRegMaseHead, &token);
---
>         if(ajRegLenI(seqRegMaseHead, 1) == 1)
>         {
>             ajRegPost(seqRegMaseHead, &token);
9161,9162c10053,10054
< 	    if(des)
< 		ajStrAppendK(&des, ' ');
---
>             if(des)
>                 ajStrAppendK(&des, ' ');
9164,9165c10056,10057
< 	    ajStrAppendS(&des, token);
< 	}
---
>             ajStrAppendS(&des, token);
>         }
9167,9168c10059
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9176,9177c10067
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9180,9182c10070,10071
< 	seqAppend(&thys->Seq, seqReadLine);
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9189,9190c10078
< 	ajFilebuffClearStore(buff, 1,
< 			     seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
9192c10080
< 	ajFilebuffClear(buff, 0);
---
>         ajFilebuffClear(buff, 0);
9200c10088
< /* @funcstatic seqReadBam ****************************************************
---
> /* @funcstatic seqReadBam *****************************************************
9207a10096,10097
> **
> ** @release 6.3.0
9211d10100
< 
9217,9224d10105
<     ajuint ilen;
<     ajuint ntargets;
<     char bambuf [4] = "   ";
<     char* refname;
<     char** targetname;
<     ajuint *targetlen;
<     int status;
<     ajuint namelen = 0;
9247a10129
>     AjPSeqBamHeader header = NULL;
9249a10132
> 
9254c10137
<         ajDebug("ajSeqReadBam bam bigendian: %B\n", bigendian);
---
>         ajDebug("seqReadBam bam bigendian: %B\n", bigendian);
9264d10146
<         AJNEW0(bamdata);
9268a10151,10160
>         if(filestat != 0)
>         {
>             ajDebug("seqReadBam rewind failed errno %d: %s\n",
>                     errno, strerror(errno));
>             return ajFalse;
>         }
>         
>         AJNEW0(bamdata);
> 
>         bamdata->gzfile = ajSeqBamBgzfNew(ajFilebuffGetFileptr(buff),"r");
9270,9272d10161
<         /* reopen BAM file as a BGZF file */
<         bamdata->gzfile =ajSeqBamBgzfOpenfd(fileno(ajFilebuffGetFileptr(buff)),
<                                             "rb");
9283d10171
< 	status = ajSeqBamBgzfEof(bamdata->gzfile);
9285,9292c10173,10177
< 	if (status < 0 && (errno == ESPIPE))
<         {
<             /*
<             ** If the file is a pipe, checking the EOF marker will *always* fail
<             ** with ESPIPE.  Suppress the error message in this case.
<             */
< 	}
< 	else if (status <= 0)
---
>         /* BAM header */
> 
>         /* read plain text and the number of reference sequences */
>         header = ajSeqBamHeaderRead(bamdata->gzfile);
>         if (!header)
9294c10179
<             /* seqReadBam EOF marker is absent */
---
>             ajDebug("failed ajSeqBamHeaderRead, seqReadBam returns ajFalse\n");
9304,9376c10189
<         status = ajSeqBamBgzfRead(bamdata->gzfile, bambuf, 4);
< 
<         if(status < 0)
<         {
<             ajSeqBamBgzfClose(bamdata->gzfile);
<             AJFREE(bamdata);
<             ajFileSeek(infile,filestat,0);
<             ajFilebuffResetPos(buff);
<             return ajFalse;
<         }
< 
<         ajDebug("gzfile %x  fd:%d file:%x ubs:%d cbs:%d blen:%d "
<                "boff:%d cache:%d open:'%c'\n",
<                bamdata->gzfile, bamdata->gzfile->file_descriptor,
<                bamdata->gzfile->file,
<                bamdata->gzfile->uncompressed_block_size,
<                bamdata->gzfile->compressed_block_size,
<                bamdata->gzfile->block_length,
<                bamdata->gzfile->block_offset, bamdata->gzfile->cache_size,
<                bamdata->gzfile->open_mode);
< 
<         if (strncmp(bambuf, "BAM\001", 4))
<         {
<             ajSeqBamBgzfClose(bamdata->gzfile);
<             AJFREE(bamdata);
<             ajFileSeek(infile,filestat,0);
<             ajFilebuffResetPos(buff);
<             return ajFalse;
<         }
< 
<         /* BAM header */
< 
< 	/* read plain text and the number of reference sequences */
<         status = ajSeqBamBgzfRead(bamdata->gzfile, &ilen, 4);
< 
<         if(status != 4)
<             ajErr("seqReadBam failed to read reference length %F", infile);
< 
<         if(bigendian)
<             ajByteRevUint(&ilen);
< 
<         refname = ajCharNewRes(ilen+1);
<         ajSeqBamBgzfRead(bamdata->gzfile, refname, ilen);
<         ajDebug("bam text %u '%s'\n", ilen, refname);
< 
<         ajSeqBamBgzfRead(bamdata->gzfile, &ntargets, 4);
< 
<         if(bigendian)
<             ajByteRevUint(&ntargets);
< 
<         ajDebug("bam targets %u\n", ntargets);
<         bamdata->Nref = ntargets;
< 
<         /* read reference sequence names and lengths */
<         targetname = AJCALLOC(ntargets, sizeof(char*));
<         targetlen = AJCALLOC(ntargets, sizeof(ajuint));
< 
<         for(i=0; i < ntargets; i++) 
<         {
<             ajSeqBamBgzfRead(bamdata->gzfile, &namelen, 4);
< 
<             if(bigendian)
<                 ajByteRevUint(&namelen);
< 
<             targetname[i] = ajCharNewRes(namelen+1);
<             ajSeqBamBgzfRead(bamdata->gzfile, targetname[i], namelen);
<             ajSeqBamBgzfRead(bamdata->gzfile, &targetlen[i], 4);
< 
<             if(bigendian)
<                 ajByteRevUint(&targetlen[i]);
< 
<             ajDebug("bam target[%u] %u '%s'\n", i, targetlen[i], targetname[i]);
<         }
---
>         ajSeqBamHeaderDel(&header);
9393,9394c10206,10207
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	/*seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);*/
---
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         /*seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);*/
9398c10211
< 	return ajFalse;
---
>         return ajFalse;
9413a10227
>     ajStrDel(&namestr);
9430a10245
>     ajStrDel(&cigarstr);
9441c10256,10257
<     ajStrAssignS(&thys->Seq, seqstr);
---
>     ajStrAssignRef(&thys->Seq, seqstr);
>     ajStrDel(&seqstr);
9448c10264
<         dpos++;
---
>         dpos += c->l_qseq;
9466a10283
>         ajStrDel(&qualstr);
9480a10298,10299
>         ajDebug("tag type: '%c\n",dp);
> 
9543,9544c10362
< 
<     seqin->Input->Records++;
---
>     ajStrDel(&tagstr);
9555c10373
< /* @funcstatic seqReadSam ****************************************************
---
> /* @funcstatic seqReadSam *****************************************************
9562a10381,10382
> **
> ** @release 6.2.0
9571,9572d10390
<     AjPStrTok handle = NULL;
<     AjPStr token = NULL;
9587,9589d10404
<     
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
9591c10406,10408
<     if(seqin->Input->Count == 1)
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>     if(ajTextinGetCount(seqin->Input) == 1)
9595,9597c10412,10414
<             ajStrTokenAssignC(&handle, seqReadLine, "\t");
<             ajStrTokenNextParse(&handle,&token);
<             switch(ajStrGetCharPos(token, 1))
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, "\t");
>             ajStrTokenNextParse(seqHandle,&seqToken);
>             switch(ajStrGetCharPos(seqToken, 1))
9600c10417,10420
<                     if(!ajStrMatchC(token, "@HD"))
---
>                     /* @HD header VN:
>                     **
>                     */
>                     if(!ajStrMatchC(seqToken, "@HD"))
9604c10424,10427
<                     if(!ajStrMatchC(token, "@SQ"))
---
>                     /* @SQ sequence dictionary SN: LN:
>                     **
>                     */
>                     if(!ajStrMatchC(seqToken, "@SQ"))
9608c10431,10434
<                     if(!ajStrMatchC(token, "@RG"))
---
>                     /* @RG read group ID: SM:
>                     **
>                     */
>                     if(!ajStrMatchC(seqToken, "@RG"))
9612c10438,10441
<                     if(!ajStrMatchC(token, "@PG"))
---
>                     /* @PG program name ID:
>                     **
>                     */
>                     if(!ajStrMatchC(seqToken, "@PG"))
9616c10445,10448
<                     if(!ajStrMatchC(token, "@CO"))
---
>                     /* @CO comment
>                     **
>                     */
>                     if(!ajStrMatchC(seqToken, "@CO"))
9623c10455
<             if(badformat) 
---
>             if(badformat)
9628,9629c10460
<             ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                      seqin->Input->Text, &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9635a10467,10468
>     /* === alignment section === */
> 
9639,9641c10472
<     seqin->Input->Records++;
< 
<     ajStrTokenAssignC(&handle, seqReadLine, "\t\n");
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, "\t\n");
9643,9645c10474,10476
<     ajStrTokenNextParseNoskip(&handle,&token); /* QNAME */
<     seqSetNameNospace(&thys->Name, token);
<     ajDebug("QNAME '%S' '%S'\n", token, thys->Name);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* QNAME */
>     seqSetNameNospace(&thys->Name, seqToken);
>     ajDebug("QNAME '%S' '%S'\n", seqToken, thys->Name);
9647,9648c10478,10479
<     ajStrTokenNextParseNoskip(&handle,&token); /* FLAG */
<     ajDebug("FLAG  '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* FLAG */
>     ajDebug("FLAG  '%S'\n", seqToken);
9650c10481
<     if(ajStrGetLen(token))
---
>     if(ajStrGetLen(seqToken))
9652c10483
<         if(!ajStrToUint(token, &flags))
---
>         if(!ajStrToUint(seqToken, &flags))
9655c10486
<                    infile, thys->Name, token);
---
>                   infile, thys->Name, seqToken);
9661,9663c10492,10494
<     
<     ajStrTokenNextParseNoskip(&handle,&token); /* RNAME */
<     ajDebug("RNAME '%S'\n", token);
---
> 
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* RNAME */
>     ajDebug("RNAME '%S'\n", seqToken);
9666,9667c10497,10498
<     if(ajStrGetLen(token))
<         seqAccSave(thys, token);
---
>       if(ajStrGetLen(seqToken))
>       seqAccSave(thys, seqToken);
9670,9671c10501,10502
<     ajStrTokenNextParseNoskip(&handle,&token); /* POS */
<     ajDebug("POS   '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* POS */
>     ajDebug("POS   '%S'\n", seqToken);
9673c10504
<     if(ajStrGetLen(token))
---
>     if(ajStrGetLen(seqToken))
9675c10506
<         if(!ajStrToUint(token, &flags))
---
>         if(!ajStrToUint(seqToken, &flags))
9678c10509
<                    infile, thys->Name, token);
---
>                   infile, thys->Name, seqToken);
9683,9684c10514,10515
<     ajStrTokenNextParseNoskip(&handle,&token); /* MAPQ */
<     ajDebug("MAPQ  '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* MAPQ */
>     ajDebug("MAPQ  '%S'\n", seqToken);
9686,9687c10517,10518
<     ajStrTokenNextParseNoskip(&handle,&token); /* CIGAR */
<     ajDebug("CIGAR '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* CIGAR */
>     ajDebug("CIGAR '%S'\n", seqToken);
9689,9690c10520,10521
<     ajStrTokenNextParseNoskip(&handle,&token); /* MRNM */
<     ajDebug("MRNM  '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* MRNM */
>     ajDebug("MRNM  '%S'\n", seqToken);
9692,9693c10523,10524
<     ajStrTokenNextParseNoskip(&handle,&token); /* MPOS */
<     ajDebug("MPOS  '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* MPOS */
>     ajDebug("MPOS  '%S'\n", seqToken);
9695c10526
<     if(ajStrGetLen(token))
---
>     if(ajStrGetLen(seqToken))
9697c10528
<         if(!ajStrToUint(token, &flags))
---
>         if(!ajStrToUint(seqToken, &flags))
9700c10531
<                    infile, thys->Name, token);
---
>                   infile, thys->Name, seqToken);
9705,9706c10536,10537
<     ajStrTokenNextParseNoskip(&handle,&token); /* ISIZE */
<     ajDebug("ISIZE '%S'\n", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* ISIZE */
>     ajDebug("ISIZE '%S'\n", seqToken);
9708c10539
<     if(ajStrGetLen(token))
---
>     if(ajStrGetLen(seqToken))
9710c10541
<         if(!ajStrToInt(token, &iflags))
---
>         if(!ajStrToInt(seqToken, &iflags))
9713c10544
<                    infile, thys->Name, token);
---
>                   infile, thys->Name, seqToken);
9719,9722c10550,10553
<     ajStrTokenNextParseNoskip(&handle,&token); /* SEQ */
<     ajDebug("SEQ   '%S'\n", token);
<     seqAppend(&thys->Seq, token);
<     seqlen = MAJSTRGETLEN(token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* SEQ */
>     ajDebug("SEQ   '%S'\n", seqToken);
>     seqAppend(&thys->Seq, seqToken);
>     seqlen = MAJSTRGETLEN(seqToken);
9724,9725c10555,10556
<     ajStrTokenNextParseNoskip(&handle,&token); /* QUAL */
<     ajDebug("QUAL  '%S'", token);
---
>     ajStrTokenNextParseNoskip(seqHandle,&seqToken); /* QUAL */
>     ajDebug("QUAL  '%S'", seqToken);
9727c10558
<     if(ajStrCmpC(token,"*")!=0)
---
>     if(ajStrCmpC(seqToken,"*")!=0)
9729c10560
<         if(MAJSTRGETLEN(token) != seqlen)
---
>         if(MAJSTRGETLEN(seqToken) != seqlen)
9734c10565
<                   seqlen, ajStrGetLen(seqQualStr), thys->Seq, token);
---
>                   seqlen, ajStrGetLen(seqQualStr), thys->Seq, seqToken);
9737,9738c10568,10569
<     
<         cp = MAJSTRGETPTR(token);
---
> 
>         cp = MAJSTRGETPTR(seqToken);
9746c10577
<         if(MAJSTRGETLEN(token) > thys->Qualsize)
---
>         if(MAJSTRGETLEN(seqToken) > thys->Qualsize)
9757c10588
<                        (ajint) (cp - MAJSTRGETPTR(token)), (char) iqual);
---
>                        (ajint) (cp - MAJSTRGETPTR(seqToken)), (char) iqual);
9771a10603
>     /* 11 fields then (tag:vtype:value)... */
9773,9775c10605,10606
< /* @HD header VN:
<     ** 
<     */
---
>     ajStrDelStatic(&seqToken);
>     ajStrTokenReset(seqHandle);
9776a10608,10609
>     return ajTrue;
> }
9780,9782d10612
< /* @SQ sequence dictionary SN: LN:
<     **
<     */
9783a10614,10625
> /* @funcstatic seqReadScf *****************************************************
> **
> ** Given data in a sequence structure, tries to read everything needed
> ** using stored chromatogram format (SCF)
> **
> ** @param [w] thys [AjPSeq] Sequence object
> ** @param [u] seqin [AjPSeqin] Sequence input object
> ** @return [AjBool] ajTrue on success
> **
> ** @release 6.2.0
> ** @@
> ******************************************************************************/
9784a10627,10649
> static AjBool seqReadScf(AjPSeq thys, AjPSeqin seqin)
> {
>     AjPFilebuff buff;
>     AjPFile infile = NULL;
>     ajuint i;
>     ajulong filestat = 0L;
>     size_t status;
>     SeqOScfData scfdata;
>     ajuint magicnum = SCF_MAGIC;
>     ajuint seqlen;
>     ajuint iqual;
>     AjBool revint = ajFalse;
>     AjBool hasqual = ajFalse;
>     SeqOScfBase scfbase;
>     AjPStr tmpstr = NULL;
>     ajuint scfversion = 0;
>     ajuint *iprob = NULL;
>     ajuint *peakoffset = NULL;
>     unsigned char *probA = NULL;
>     unsigned char *probC = NULL;
>     unsigned char *probG = NULL;
>     unsigned char *probT = NULL;
>     char *bases = NULL;
9785a10651,10652
>     buff = seqin->Input->Filebuff;
>     infile = ajFilebuffGetFile(buff);
9787,9789c10654,10655
< /* @RG read group ID: SM:
<     **
<     */
---
>     if(ajFilebuffIsEnded(buff))
>         return ajFalse;
9790a10657,10665
>     filestat = ajFileSeek(infile, 0L, SEEK_SET);
>     if(filestat != 0)
>     {
>         ajDebug("seqReadScf rewind failed errno %d: %s\n",
>                 errno, strerror(errno));
>         return ajFalse;
>     }
>         
>     /* === header section === */
9791a10667,10669
>     status = ajReadbinBinary(infile, 1, 128, &scfdata.header);
>     if(!status)
>         return ajFalse;
9792a10671,10679
>     if(scfdata.header.magic_number != magicnum)
>     {
>         ajByteRevLen4u(&scfdata.header.magic_number);
>         if(scfdata.header.magic_number != magicnum)
>         {
>             ajDebug("SCF magic number expected '%x' reversed '%x'\n",
>                     magicnum, scfdata.header.magic_number);
>             return ajFalse;
>         }
9794,9796c10681,10730
< /* @PG program name ID:
<     **
<     */
---
>         ajDebug("SCF magic number '%x' reversed Bigendian: %B\n",
>                 scfdata.header.magic_number,
>                 ajUtilGetBigendian());
> 
>         revint = ajTrue;
> 
>         ajByteRevLen4u(&scfdata.header.samples);
>         ajByteRevLen4u(&scfdata.header.samples_offset);
>         ajByteRevLen4u(&scfdata.header.bases);
>         ajByteRevLen4u(&scfdata.header.bases_left_clip);
>         ajByteRevLen4u(&scfdata.header.bases_right_clip);
>         ajByteRevLen4u(&scfdata.header.bases_offset);
>         ajByteRevLen4u(&scfdata.header.comments_size);
>         ajByteRevLen4u(&scfdata.header.comments_offset);
>         ajByteRevLen4u(&scfdata.header.sample_size);
>         ajByteRevLen4u(&scfdata.header.code_set);
>         ajByteRevLen4u(&scfdata.header.private_size);
>         ajByteRevLen4u(&scfdata.header.private_offset);
>         for(i=0; i < 18; i++)
>             ajByteRevLen4u(&scfdata.header.spare[i]);
>     }
> 
>     scfversion = scfdata.header.version[0] - '0';
> 
>     ajDebug("version %u '%c%c%c%c' uncertainty %u '%s' precision %u %ubit\n",
>             scfversion, scfdata.header.version[0],
>             scfdata.header.version[1],
>             scfdata.header.version[2],
>             scfdata.header.version[3],
>             scfdata.header.code_set,
>             SeqScfUncertainCodes[scfdata.header.code_set].name,
>             scfdata.header.sample_size,
>             (scfdata.header.sample_size - 1) ? 8 : 16
>             );
> 
>     ajDebug("%u samples at %u\n",
>             scfdata.header.samples,
>             scfdata.header.samples_offset);
> 
>     ajDebug("%u bases at %u\n",
>             scfdata.header.bases,
>             scfdata.header.bases_offset);
> 
>     ajDebug("%u char comment at %u\n",
>             scfdata.header.comments_size,
>             scfdata.header.comments_offset);
> 
>     ajDebug("%u private records at %u\n",
>             scfdata.header.private_size,
>             scfdata.header.private_offset);
9798a10733,10739
>     filestat = ajFileSeek(infile, scfdata.header.bases_offset, SEEK_SET);
>     if(filestat != 0)
>     {
>         ajDebug("seqReadScf seek failed errno %d: %s\n",
>                 errno, strerror(errno));
>         return ajFalse;
>     }
9799a10741,10744
>     seqlen = scfdata.header.bases;
>     AJCNEW(bases, seqlen+1);
>     AJCNEW(iprob, seqlen);
>     bases[seqlen] = '\0';
9801,9803c10746,10796
< /* @CO comment
<     **
<     */
---
>     if(scfversion < 3)
>     {
>         for(i=0; i < seqlen; i++)
>         {
>             ajReadbinBinary(infile, 1, 12, &scfbase);
>             if(revint)
>             {
>                 if(revint)
>                     ajByteRevLen4u(&scfbase.peak_index);
>                 bases[i] = scfbase.base;
>                 switch(scfbase.base) 
>                 {
>                     case 'A':
>                     case 'a':
>                         iqual = scfbase.prob_A;
>                         break;
>                     case 'C':
>                     case 'c':
>                         iqual = scfbase.prob_C;
>                         break;
>                     case 'G':
>                     case 'g':
>                         iqual = scfbase.prob_G;
>                         break;
>                     case 'T':
>                     case 't':
>                         iqual = scfbase.prob_T;
>                         break;
>                     default:
>                         bases[i] = 'N';
>                         iqual = 0;
>                 }
>                 if(iqual)
>                     hasqual = ajTrue;
>                 iprob[i] = iqual;
>             }
>         }
>     }
>     else if (scfversion == 3)
>     {
>         AJCNEW(peakoffset, seqlen);
>         AJCNEW(probA, seqlen);
>         AJCNEW(probC, seqlen);
>         AJCNEW(probG, seqlen);
>         AJCNEW(probT, seqlen);
>         ajReadbinBinary(infile, seqlen, 4, peakoffset);
>         ajReadbinBinary(infile, seqlen, 1, probA);
>         ajReadbinBinary(infile, seqlen, 1, probC);
>         ajReadbinBinary(infile, seqlen, 1, probG);
>         ajReadbinBinary(infile, seqlen, 1, probT);
>         ajReadbinBinary(infile, seqlen, 1, bases);
9805c10798,10837
<     /* === alignment section === */
---
>         for(i=0; i < seqlen; i++)
>         {
>             if(revint)
>                 ajByteRevLen4u(&peakoffset[i]);
>             switch(bases[i]) 
>             {
>                 case 'A':
>                 case 'a':
>                     iqual = probA[i];
>                     break;
>                 case 'C':
>                 case 'c':
>                     iqual = probC[i];
>                     break;
>                 case 'G':
>                 case 'g':
>                     iqual = probG[i];
>                     break;
>                 case 'T':
>                 case 't':
>                     iqual = probT[i];
>                     break;
>                 default:
>                     bases[i] = 'N';
>                     iqual = 0;
>             }
>             if(iqual)
>                 hasqual = ajTrue;
>             iprob[i] = iqual;
>         }
>     }
>     else
>     {
>         ajDebug("Unknown SCF version '%c%c%c%c'",
>                scfdata.header.version[0],
>                scfdata.header.version[1],
>                scfdata.header.version[2],
>                scfdata.header.version[3]);
>         return ajFalse;
>     }
9807c10839,10846
<     /* 11 fields then (tag:vtype:value)... */
---
>     filestat = ajFileSeek(infile, scfdata.header.comments_offset, SEEK_SET);
>     if(filestat != 0)
>     {
>         ajDebug("seqReadScf seek failed errno %d: %s\n",
>                 errno, strerror(errno));
>         return ajFalse;
>     }
>     ajReadbinStr(infile, scfdata.header.comments_size, &tmpstr);
9809,9810c10848,10871
<     ajStrDel(&token);
<     ajStrTokenDel(&handle);
---
>     ajStrExchangeCC(&tmpstr, "\r", "\n");
>     ajStrExchangeCC(&tmpstr, "\n\n", "\n");
>     ajStrExchangeCC(&tmpstr, "\n", "; ");
>     ajStrExchangeCC(&tmpstr, " ;", ";");
>     ajStrTrimWhiteEnd(&tmpstr);
>     ajStrAssignS(&thys->Desc, tmpstr);
> 
>     ajStrAssignC(&tmpstr, bases);
>     seqAppendWarn(&thys->Seq, tmpstr,
>                   seqin->Input->Format);
>     if(hasqual)
>     {
>         AJCRESIZE(thys->Accuracy, seqlen);
>         thys->Qualsize = seqlen;
>         for(i=0; i < seqlen; i++)
>             thys->Accuracy[i] = seqQualPhred[iprob[i]];
>     }
> 
>     ajStrDel(&tmpstr);
>     
>     seqSetNameFile(thys, seqin);
> 
>     ajFilebuffClear(buff, 0);
>     buff->File->End = ajTrue;
9825a10887,10888
> **
> ** @release 1.0.0
9831,9832d10893
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
9840,9841c10901
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9843c10903
< 	if(ok)
---
>         if(ok)
9845d10904
<             seqin->Input->Records++;
9848,9851c10907,10910
<                 ajStrTokenAssignC(&handle, seqReadLine, " ;\t,\n");
<                 ajStrTokenNextParse(&handle, &token); /* 'DNA' */
<                 ajStrTokenNextParse(&handle, &token); /* sequence */
<                 ajStrTokenNextParse(&handle, &token); /* entry name */
---
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\t,\n");
>                 ajStrTokenStep(seqHandle); /* 'DNA' */
>                 ajStrTokenStep(seqHandle); /* sequence */
>                 ajStrTokenNextParse(seqHandle, &seqToken); /* entry name */
9854c10913
<         
---
> 
9857c10916
<     ajStrTokenDel(&handle);
---
>     ajStrTokenReset(seqHandle);
9859c10918
<     if(!ok || !ajStrGetLen(token))
---
>     if(!ok || !ajStrGetLen(seqToken))
9861,9862c10920,10921
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	ajStrDel(&token);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         ajStrDelStatic(&seqToken);
9864c10923
< 	return ajFalse;
---
>         return ajFalse;
9871c10930
<     seqSetName(thys, token);
---
>     seqSetName(thys, seqToken);
9877,9880c10936,10937
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
9884c10941
<     ajStrDel(&token);
---
>     ajStrDelStatic(&seqToken);
9899a10957,10958
> **
> ** @release 1.0.0
9924,9943c10983,10990
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	if(!ok)
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
< 
< 	if(ajStrPrefixC(seqReadLine, "!!"))
< 	{
< 	    if(ajStrPrefixC(seqReadLine, "!!AA_MULTIPLE_ALIGNMENT"))
< 		ajSeqSetProt(thys);
< 
< 	    if(ajStrPrefixC(seqReadLine, "!!NA_MULTIPLE_ALIGNMENT"))
< 		ajSeqSetNuc(thys);
< 	}
< 
< 	if(!seqGcgMsfDots(thys, seqin, &seqReadLine, seqMaxGcglines, &len))
< 	{
< 	    ajDebug("seqGcgMsfDots failed\n");
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         if(!ok)
>             return ajFalse;
> 
>         if(ajStrPrefixC(seqReadLine, "!!"))
>         {
>             if(ajStrPrefixC(seqReadLine, "!!AA_MULTIPLE_ALIGNMENT"))
>                 ajSeqSetProt(thys);
9945,9946c10992,11002
< 	    return ajFalse;
< 	}
---
>             if(ajStrPrefixC(seqReadLine, "!!NA_MULTIPLE_ALIGNMENT"))
>                 ajSeqSetNuc(thys);
>         }
> 
>         if(!seqGcgMsfDots(thys, seqin, &seqReadLine, seqMaxGcglines, &len))
>         {
>             ajDebug("seqGcgMsfDots failed\n");
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
> 
>             return ajFalse;
>         }
9952,10000c11008,11050
< 	seqin->SeqData = AJNEW0(msfdata);
< 	msfdata->Table = msftable = ajTablestrNew(1000);
< 	msflist = ajListstrNew();
< 	seqin->Input->Filecount = 0;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	seqin->Input->Records++;
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 	    seqin->Input->Records++;
< 
< 	    if(seqGcgMsfHeader(seqReadLine, &msfitem))
< 	    {
< 		ajTablePut(msftable, ajStrNewS(msfitem->Name), msfitem);
< 		ajListstrPushAppend(msflist, ajStrNewS(msfitem->Name));
< 		iseq++;
< 	    }
< 	}
< 
< 	ajDebug("Header has %d sequences\n", iseq);
< 	ajListstrTrace(msflist);
< 	ajTableTrace(msftable);
< 	ajTableMap(msftable, seqMsfTabList, NULL);
< 
< 	msfdata->Names = AJCALLOC(iseq, sizeof(*msfdata->Names));
< 
< 	for(i=0; i < iseq; i++)
< 	{
< 	    ajListstrPop(msflist, &msfdata->Names[i]);
< 	    ajDebug("list [%d] '%S'\n", i, msfdata->Names[i]);
< 	}
< 
< 	ajListstrFreeData(&msflist);
< 
< 	while(ajBuffreadLineStore(buff, &seqReadLine,
< 				 seqin->Input->Text, &thys->TextPtr))
< 	{
< 	    seqin->Input->Records++;
< 	    seqGcgMsfReadseq(seqReadLine, msftable);
< 	}
< 
< 	ajTableMap(msftable, seqMsfTabList, NULL);
< 	msfdata->Nseq = iseq;
< 	msfdata->Count = 0;
< 	msfdata->Bufflines = seqin->Input->Records;
< 	ajDebug("MSF format read %d lines\n", seqin->Input->Records);
---
>         seqin->SeqData = AJNEW0(msfdata);
>         msfdata->Table = msftable = ajTablestrNew(1000);
>         msflist = ajListstrNew();
>         seqin->Input->Filecount = 0;
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         while(ok && !ajStrPrefixC(seqReadLine, "//"))
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             if(seqGcgMsfHeader(seqReadLine, &msfitem))
>             {
>                 ajTablePut(msftable, ajStrNewS(msfitem->Name), msfitem);
>                 ajListstrPushAppend(msflist, ajStrNewS(msfitem->Name));
>                 iseq++;
>             }
>         }
> 
>         ajDebug("Header has %d sequences\n", iseq);
>         ajListstrTrace(msflist);
>         ajTableTrace(msftable);
>         ajTableMap(msftable, &seqMsfTabList, NULL);
> 
>         msfdata->Names = AJCALLOC(iseq, sizeof(*msfdata->Names));
> 
>         for(i=0; i < iseq; i++)
>         {
>             ajListstrPop(msflist, &msfdata->Names[i]);
>             ajDebug("list [%d] '%S'\n", i, msfdata->Names[i]);
>         }
> 
>         ajListstrFreeData(&msflist);
> 
>         while(ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         {
>             seqGcgMsfReadseq(seqReadLine, msftable);
>         }
> 
>         ajTableMap(msftable, &seqMsfTabList, NULL);
>         msfdata->Nseq = iseq;
>         msfdata->Count = 0;
>         msfdata->Bufflines = ajTextinGetRecords(seqin->Input);
>         ajDebug("MSF format read %d lines\n",
>                 ajTextinGetRecords(seqin->Input));
10008,10009c11058,11059
< 	ajFilebuffClear(seqin->Input->Filebuff, 0);
< 	seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
---
>         ajFilebuffClear(seqin->Input->Filebuff, 0);
>         seqMsfDataDel((SeqPMsfData*)&seqin->SeqData);
10011c11061
< 	return ajFalse;
---
>         return ajFalse;
10037a11088,11089
> **
> ** @release 1.0.0
10052,10053c11104,11105
< 	ajStrDel(&token);
< 	ajStrDel(&seqstr);
---
>         ajStrDel(&token);
>         ajStrDel(&seqstr);
10055c11107
< 	return ajFalse;
---
>         return ajFalse;
10064,10065c11116,11117
< 	ajStrDel(&token);
< 	ajStrDel(&seqstr);
---
>         ajStrDel(&token);
>         ajStrDel(&seqstr);
10067c11119
< 	return ajFalse;
---
>         return ajFalse;
10086a11139,11140
> **
> ** @release 4.1.0
10103,10105c11157,11159
<     ajDebug("seqMsfDataDel Nseq:%u Count:%u Table:%u Nexus:%u\n",
< 	    thys->Nseq, thys->Count, ajTableGetLength(thys->Table),
< 	    ajNexusGetNtaxa(thys->Nexus));
---
>     ajDebug("seqMsfDataDel Nseq:%u Count:%u Table:%u Nexus:%Lu\n",
>             thys->Nseq, thys->Count, ajTableGetLength(thys->Table),
>             ajNexusGetNtaxa(thys->Nexus));
10109c11163
< 	ajStrDel(&thys->Names[i]);
---
>         ajStrDel(&thys->Names[i]);
10112c11166
<     
---
> 
10120c11174
<     ajTableMapDel(thys->Table, seqMsfTabDel, NULL);
---
>     ajTableMapDel(thys->Table, &seqMsfTabDel, NULL);
10136a11191,11192
> **
> ** @release 4.1.0
10173a11230,11231
> **
> ** @release 1.0.0
10186c11244
< 	    key, msfitem->Name, ajStrGetLen(msfitem->Seq));
---
>             key, msfitem->Name, ajStrGetLen(msfitem->Seq));
10199a11258,11259
> **
> ** @release 4.1.0
10209,10210c11269,11270
< 	ajDebug("seqMsfDataTrace <null>\n");
< 	return;
---
>         ajDebug("seqMsfDataTrace <null>\n");
>         return;
10213,10215c11273,11275
<     ajDebug("seqMsfDataTrace Nseq:%u Count:%u Table:%u Nexus:%u\n",
< 	    thys->Nseq, thys->Count, ajTableGetLength(thys->Table),
< 	    ajNexusGetNtaxa(thys->Nexus));
---
>     ajDebug("seqMsfDataTrace Nseq:%u Count:%u Table:%u Nexus:%Lu\n",
>             thys->Nseq, thys->Count, ajTableGetLength(thys->Table),
>             ajNexusGetNtaxa(thys->Nexus));
10218,10221c11278,11281
< 	if(i < thys->Count)
< 	    ajDebug("* [%u] '%S'\n", i, thys->Names[i]);
< 	else
< 	    ajDebug("  [%u] '%S'\n", i, thys->Names[i]);
---
>         if(i < thys->Count)
>             ajDebug("* [%u] '%S'\n", i, thys->Names[i]);
>         else
>             ajDebug("  [%u] '%S'\n", i, thys->Names[i]);
10223c11283
<     ajTableMap(thys->Table, seqMsfTabList, NULL);
---
>     ajTableMap(thys->Table, &seqMsfTabList, NULL);
10238a11299,11300
> **
> ** @release 1.0.0
10272a11335,11336
> **
> ** @release 1.0.0
10278,10279d11341
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
10282,10284c11344,11347
<     AjPStr tmpstr = NULL;
<     AjBool dofeat        = ajFalse;
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjBool dodes = ajFalse;
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
>     AjPStr liststr;                     /* for lists, do not delete */
10289c11352
<     AjPStr cmtstr = NULL;		/* stored in AjPSeq - do not delete */
---
>     AjPStr cmtstr = NULL;               /* stored in AjPSeq - do not delete */
10301a11365
>     const AjPStr tmpstr = NULL;
10302a11367
>     ajuint itaxtype = 0;
10307a11373
>     SeqEPrefixSwiss lineprefix = SWISS_UNK;
10322c11388
<     
---
> 
10326c11392
< 	ajStrAssignC(&seqFtFmtSwiss, "swissprot");
---
>         ajStrAssignC(&seqFtFmtSwiss, "swissprot");
10328,10330c11394,11395
<     if(!ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
<                             &thys->TextPtr))
< 	return ajFalse;
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         return ajFalse;
10332c11397
<     seqin->Input->Records++;
---
>     lineprefix = seqPrefixSwiss(seqReadLine);
10336c11401
<     while(ajStrPrefixC(seqReadLine, "WP "))
---
>     while(lineprefix == SWISS_WP) /* "WP" */
10338,10340c11403,11404
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
10342c11406
< 	seqin->Input->Records++;
---
>         lineprefix = seqPrefixSwiss(seqReadLine);
10349,10351c11413,11414
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
10353c11416
< 	seqin->Input->Records++;
---
>         lineprefix = seqPrefixSwiss(seqReadLine);
10358c11421
<     if(!ajStrPrefixC(seqReadLine, "ID   "))
---
>     if(lineprefix != SWISS_ID)  /* "ID" */
10360c11423
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
10362c11425
< 	return ajFalse;
---
>         return ajFalse;
10365,10367c11428,11430
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
<     ajStrTokenNextParse(&handle, &token);	/* 'ID' */
<     ajStrTokenNextParse(&handle, &token);	/* entry name */
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>     ajStrTokenStep(seqHandle);       /* 'ID' */
>     ajStrTokenNextParse(seqHandle, &seqToken);       /* entry name */
10369,10370c11432
<     seqSetName(thys, token);
<     ajStrDel(&token);
---
>     seqSetName(thys, seqToken);
10372,10373c11434,11435
<     ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
<                              &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixSwiss(seqReadLine);
10375c11437
<     if(!thys->Fulldesc)
---
>     if(!seqin->Minimal && !thys->Fulldesc)
10378c11440,11446
<     while(ok && !ajStrPrefixC(seqReadLine, "SQ   "))
---
>     if(seqin->Minimal)
>         dodes = ajTrue;
> 
>     dofeat = ajFalse;
>     tryfeat = seqinUfoLocal(seqin);
> 
>     while(ok && lineprefix != SWISS_SQ) /* read until "SQ" */
10380c11448
< 	seqin->Input->Records++;
---
>         /* check for Staden Experiment format instead */
10382,10389c11450,11454
< 	/* check for Staden Experiment format instead */
< 	if(ajStrPrefixC(seqReadLine, "EN   ") ||
< 	   ajStrPrefixC(seqReadLine, "TN   ") ||
< 	   ajStrPrefixC(seqReadLine, "EX   ") )
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    ajStrTokenDel(&handle);
< 	    ajStrDel(&token);
---
>         if(lineprefix == SWISS_EX) /* EN/EX/TN */
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrTokenReset(seqHandle);
>             ajStrDelStatic(&seqToken);
10391,10392c11456,11457
< 	    return ajFalse;;
< 	}
---
>             return ajFalse;;
>         }
10394,10397c11459,11462
< 	else if(ajStrPrefixC(seqReadLine, "AC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'AC' */
---
>         else if(lineprefix == SWISS_AC) /* AC */
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'AC' */
10399,10401c11464,11466
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
---
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
10403,10405c11468,11470
< 	else if(ajStrPrefixC(seqReadLine, "DE   "))
< 	{
<             if(!desctop)
---
>         if(tryfeat && lineprefix == SWISS_FT) /* FT */
>         {
>             if(!dofeat)         /* set up feature buffer */
10407,10409c11472,11477
<                 desctop = thys->Fulldesc;
<                 descmaster = thys->Fulldesc;
<                 Pdescstr = &thys->Desc;
---
>                 dofeat = ajTrue;
>                 ajFeattabinDel(&seqin->Ftquery);
>                 seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtSwiss,
>                                                        thys->Name, "N");
>                 ajDebug("seqin->Ftquery ftfile %x\n",
>                         seqin->Ftquery->Input->Filebuff);
10412,10413c11480,11482
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DE' */
---
>             ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
>             /* ajDebug("SWISS FEAT saved line:\n%S", seqReadLine); */
>         }
10415c11484,11492
< 	    while(ajStrTokenNextParseC(&handle, " ;\n\r", &token))
---
>         if(seqin->Minimal)
>         {
>             /*
>             ** only simple description needed
>             ** test DE line, extract basic text if any
>             ** then go to next record
>            */
> 
>             if(lineprefix == SWISS_DE) /* DE minimal processing */
10417,10419c11494,11495
<                 if(ajStrGetCharLast(token) == ':')
<                 {
<                     isdescflag = ajFalse;
---
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'DE' */
10421c11497,11499
<                     if(ajStrPrefixC(token, "RecName:"))
---
>                 while(ajStrTokenNextParseC(seqHandle, " ;\n\r", &seqToken))
>                 {
>                     if(MAJSTRGETCHARLAST(seqToken) == ':')
10423,10424c11501,11520
<                         Pdescstr = &descmaster->Name;
<                         descistop = ajTrue;
---
>                         switch(seqDesSwiss(seqToken))
>                         {
>                             case SWISS_DES_REC:
>                                 dodes = ajTrue;
>                                 break;
> 
>                             case SWISS_DES_UNK:
>                                 if(dodes)
>                                 {
>                                     if(MAJSTRGETLEN(thys->Desc))
>                                         ajStrAppendK(&thys->Desc, ' ');
>                                     ajStrAppendS(&thys->Desc, seqToken);
>                                 }
>                                 break;
> 
>                             default:
>                                 if(MAJSTRGETLEN(thys->Desc))
>                                     dodes = ajFalse;
>                                 break;
>                         }
10426c11522
<                     else if(ajStrPrefixC(token, "AltName:"))
---
>                     else if(ajStrFindK(seqToken, '=') > 0)
10428,10431c11524,11541
<                         subdesc = ajSeqsubdescNew();
<                         descistop = ajFalse;
<                         Pdescstr = &subdesc->Name;
<                         ajListPushAppend(descmaster->AltNames, subdesc);
---
>                         switch(seqDessubSwiss(&seqToken))
>                         {
>                             case SWISS_SUB_FULL:
>                                 if(!MAJSTRGETLEN(thys->Desc))
>                                     dodes = ajTrue;
>                                 break;
>                             case SWISS_SUB_UNK:
>                                 break;
>                             default:
>                                 dodes = ajFalse;
>                                 break;
>                         }
>                         if(dodes)
>                         {
>                             if(MAJSTRGETLEN(thys->Desc))
>                                 ajStrAppendK(&thys->Desc, ' ');
>                             ajStrAppendS(&thys->Desc, seqToken);
>                         }
10433c11543
<                     else if(ajStrPrefixC(token, "SubName:"))
---
>                     else 
10435,10440c11545,11575
<                         subdesc = ajSeqsubdescNew();
<                         descistop = ajFalse;
<                         Pdescstr = &subdesc->Name;
<                         ajListPushAppend(descmaster->SubNames, subdesc);
<                    }
<                     else if(ajStrPrefixC(token, "Includes:"))
---
>                         if(dodes)
>                         {
>                             if(MAJSTRGETLEN(thys->Desc))
>                                 ajStrAppendK(&thys->Desc, ' ');
>                             ajStrAppendS(&thys->Desc, seqToken);
>                         }
>                     }
>                 }
>             }
>             
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixSwiss(seqReadLine);
>             continue;
>         }
> 
>         switch(lineprefix)      /* all other line types */
>         {
>             case SWISS_DE:
>                 if(!desctop)
>                 {
>                     desctop = thys->Fulldesc;
>                     descmaster = thys->Fulldesc;
>                     Pdescstr = &thys->Desc;
>                 }
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'DE' */
> 
>                 while(ajStrTokenNextParseC(seqHandle, " ;\n\r", &seqToken))
>                 {
>                     if(ajStrGetCharLast(seqToken) == ':')
10442,10445c11577,11629
<                         descmaster = ajSeqdescNew();
<                         descistop = ajTrue;
<                         ajListPushAppend(thys->Fulldesc->Includes, descmaster);
<                         Pdescstr = &descmaster->Name;
---
>                         isdescflag = ajFalse;
> 
>                         switch(seqDesSwiss(seqToken))
>                         {
>                             case SWISS_DES_REC:
>                                 Pdescstr = &descmaster->Name;
>                                 descistop = ajTrue;
>                                 break;
> 
>                             case SWISS_DES_ALT:
>                                 subdesc = ajSeqsubdescNew();
>                                 descistop = ajFalse;
>                                 Pdescstr = &subdesc->Name;
>                                 ajListPushAppend(descmaster->AltNames, subdesc);
>                                 break;
> 
>                             case SWISS_DES_SUB:
>                                 subdesc = ajSeqsubdescNew();
>                                 descistop = ajFalse;
>                                 Pdescstr = &subdesc->Name;
>                                 ajListPushAppend(descmaster->SubNames, subdesc);
>                                 break;
> 
>                             case SWISS_DES_INC:
>                                 descmaster = ajSeqdescNew();
>                                 descistop = ajTrue;
>                                 ajListPushAppend(thys->Fulldesc->Includes,
>                                                  descmaster);
>                                 Pdescstr = &descmaster->Name;
>                                 break;
> 
>                             case SWISS_DES_CONT:
>                                 descmaster = ajSeqdescNew();
>                                 descistop = ajTrue;
>                                 ajListPushAppend(thys->Fulldesc->Contains,
>                                                  descmaster);
>                                 Pdescstr = &descmaster->Name;
>                                 break;
> 
>                             case SWISS_DES_FLG:
>                                 isdescflag = ajTrue;
>                                 break;
> 
>                             default:
>                                 ajDebug("Swissprot DE line"
>                                         "UNKNOWN token '%S'\n",
>                                         seqToken);
> 
>                                 if(ajStrGetLen(*Pdescstr))
>                                     ajStrAppendK(Pdescstr, ' ');
> 
>                                 ajStrAppendS(Pdescstr, seqToken);
>                         }
10447c11631,11632
<                     else if(ajStrPrefixC(token, "Contains:"))
---
> 
>                     else if(ajStrFindK(seqToken, '=') > 0)
10449,10452c11634,11730
<                         descmaster = ajSeqdescNew();
<                         descistop = ajTrue;
<                         ajListPushAppend(thys->Fulldesc->Contains, descmaster);
<                         Pdescstr = &descmaster->Name;
---
>                         switch(seqDessubSwiss(&seqToken))
>                         {
>                             case SWISS_SUB_FULL:
>                                 if(descistop)
>                                 {
>                                     Pdescstr = &descmaster->Name;
>                                 }
>                                 else
>                                 {
>                                     Pdescstr = &subdesc->Name;
>                                 }
> 
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 break;
> 
>                             case SWISS_SUB_SHORT:
>                                 newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
> 
>                                 if(descistop)
>                                     ajListstrPushAppend(descmaster->Short,
>                                                         newdescstr);
>                                 else
>                                     ajListstrPushAppend(subdesc->Short,
>                                                         newdescstr);
> 
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 break;
> 
>                             case SWISS_SUB_EC:
>                                 newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
> 
>                                 if(descistop)
>                                     ajListstrPushAppend(descmaster->EC,
>                                                         newdescstr);
>                                 else
>                                     ajListstrPushAppend(subdesc->EC,
>                                                         newdescstr);
> 
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 xref = ajSeqxrefNewDbC(*Pdescstr, "ENZYME",
>                                                        XREF_EC);
>                                 ajSeqAddXref(thys, xref);
>                                 xref = NULL;
>                                 break;
> 
>                             case SWISS_SUB_ALLER:
>                                 newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
>                                 ajListstrPushAppend(subdesc->Allergen,
>                                                     newdescstr);
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 xref = ajSeqxrefNewDbC(*Pdescstr, "Allergen",
>                                                        XREF_DESC);
>                                 ajSeqAddXref(thys, xref);
>                                 xref = NULL;
>                                 break;
> 
>                             case SWISS_SUB_BIOTECH:
>                                     newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
>                                 ajListstrPushAppend(subdesc->Biotech,
>                                                     newdescstr);
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 break;
> 
>                             case SWISS_SUB_CDA:
>                                 newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
>                                 ajListstrPushAppend(subdesc->Cdantigen,
>                                                     newdescstr);
>                                 ajStrAssignS(Pdescstr, seqToken);
>                                 xref = ajSeqxrefNewDbC(*Pdescstr, "CD_Antigen",
>                                                        XREF_DESC);
>                                 ajSeqAddXref(thys, xref);
>                                 xref = NULL;
>                                 break;
> 
>                             case SWISS_SUB_INN:
>                                 newdescstr = ajStrNewC("");
>                                 Pdescstr = &newdescstr;
>                                 ajListstrPushAppend(subdesc->Inn, newdescstr);
>                                 ajStrAssignSubS(Pdescstr, seqToken, 4, -1);
>                                 break;
> 
>                             default:
>                                 ajDebug("Swissprot DE line "
>                                         "UNKNOWN subtoken '%S'\n",
>                                         seqToken);
> 
>                                 if(ajStrGetLen(*Pdescstr))
>                                     ajStrAppendK(Pdescstr, ' ');
> 
>                                 ajStrAppendS(Pdescstr, seqToken);
>                                 break;
>                         }
10454,10455d11731
<                     else if(ajStrPrefixC(token, "Flags:"))
<                         isdescflag = ajTrue;
10458,10459c11734,11747
<                         ajDebug("Swissprot DE line UNKNOWN token '%S'\n",
<                                 token);
---
>                         if(isdescflag)
>                         {
>                             if(ajStrMatchC(seqToken,"Precursor"))
>                                 thys->Fulldesc->Precursor = ajTrue;
>                             else if(ajStrMatchC(seqToken,"Fragments"))
>                                 thys->Fulldesc->Fragments = 2;
>                             else if(ajStrMatchC(seqToken,"Fragment"))
>                                 thys->Fulldesc->Fragments = 1;
>                             else
>                             {
>                                 ajDebug("unknown description flag text '%S'\n",
>                                         seqToken);
>                                 if(ajStrGetLen(*Pdescstr))
>                                     ajStrAppendK(Pdescstr, ' ');
10461,10462c11749,11757
<                         if(ajStrGetLen(*Pdescstr))
<                             ajStrAppendK(Pdescstr, ' ');
---
>                                 ajStrAppendC(Pdescstr, "Flags: ");
>                                 ajStrAppendS(Pdescstr, seqToken);
>                             }
>                             
>                         }
>                         else
>                         {
>                             if(ajStrGetLen(*Pdescstr))
>                                 ajStrAppendK(Pdescstr, ' ');
10464c11759,11760
<                         ajStrAppendS(Pdescstr, token);
---
>                             ajStrAppendS(Pdescstr, seqToken);
>                         }
10467c11763,11785
<                 else if(ajStrPrefixC(token, "Full="))
---
>                 break;
> 
>                 /* needs a little work for wrapped lines - save token and
>                 ** append rather than set at the current level
>                 */
> 
>             case SWISS_GN:
>                 if(!seqgene)
>                 {
>                     isnewgene = ajTrue;
>                     seqgene = ajSeqgeneNew();
>                 }
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'GN' */
>                 ajStrTokenNextParseC(seqHandle, ";=\n\r", &seqToken);
> 
>                 if(ajStrMatchC(seqToken, "and")) /* test 'and' between genes */
>                 {
>                     isnewgene = ajTrue;
>                     seqgene = ajSeqgeneNew();
>                 }
>                 else
10469c11787
<                     if(descistop)
---
>                     while(ajStrGetLen(seqToken))
10471c11789,11836
<                         Pdescstr = &descmaster->Name;
---
>                         isgenetoken = ajTrue;
>                         ajStrTrimWhite(&seqToken);
>                         
>                         if(ajStrMatchC(seqToken, "Name"))
>                         {
>                             ajStrTokenNextParseC(seqHandle, ";\n\r",
>                                                  &seqToken2);
>                             ajSeqgeneSetName(seqgene, seqToken2);
>                         }
>                         else if (ajStrMatchC(seqToken, "Synonyms"))
>                         {
>                             ajStrTokenNextParseC(seqHandle, ";\n\r",
>                                                  &seqToken2);
>                             ajSeqgeneSetSynonyms(seqgene, seqToken2);
>                         }
>                         else if (ajStrMatchC(seqToken, "OrderedLocusNames"))
>                         {
>                             ajStrTokenNextParseC(seqHandle, ";\n\r",
>                                                  &seqToken2);
>                             ajSeqgeneSetOln(seqgene, seqToken2);
>                         }
>                         else if (ajStrMatchC(seqToken, "ORFNames"))
>                         {
>                             ajStrTokenNextParseC(seqHandle, ";\n\r",
>                                                  &seqToken2);
>                             ajSeqgeneSetOrf(seqgene, seqToken2);
>                         }
>                         else
>                         {
>                             isgenetoken = ajFalse;
>                             ajDebug("Swissnew GN line unexpected '%S' (%S)",
>                                     seqToken, genetoken);
> 
>                             if(ajStrMatchC(genetoken, "Name"))
>                                 ajSeqgeneAppendName(seqgene, seqToken);
>                             else if (ajStrMatchC(genetoken, "Synonyms"))
>                                 ajSeqgeneAppendSynonyms(seqgene, seqToken);
>                             else if (ajStrMatchC(genetoken,
>                                                  "OrderedLocusNames"))
>                                 ajSeqgeneAppendOln(seqgene, seqToken);
>                             else if (ajStrMatchC(genetoken, "ORFNames"))
>                                 ajSeqgeneAppendOrf(seqgene, seqToken);
>                         }
> 
>                         ajStrTokenNextParseC(seqHandle, "=;\n\r", &seqToken);
> 
>                         if(isgenetoken)
>                             ajStrAssignS(&genetoken, seqToken);
10473c11838,11839
<                     else
---
> 
>                     if(isnewgene)
10475c11841,11842
<                         Pdescstr = &subdesc->Name;
---
>                         isnewgene = ajFalse;
>                         ajSeqAddGene(thys, seqgene);
10477,10478c11844
< 
<                     ajStrAssignSubS(Pdescstr, token, 5, -1);
---
>                     /* keep seqgene so we can add to it if the line wraps */
10480c11846,11861
<                 else if(ajStrPrefixC(token, "Short="))
---
>                 break;
> 
>             case SWISS_PE:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* PE */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken);
> 
>                 if(ajStrGetLen(seqToken))
>                     ajStrAssignS(&thys->Evidence, seqToken);
>                 break;    
> 
>             case SWISS_KW:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'KW' */
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
10482,10483c11863,11868
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
---
>                     liststr = ajStrNewS(seqToken);
>                     ajStrTrimWhite(&liststr);
>                     ajSeqAddKey(thys, liststr);
>                     liststr = NULL;
>                 }
>                 break;
10485,10488c11870,11877
<                     if(descistop)
<                         ajListstrPushAppend(descmaster->Short, newdescstr);
<                     else
<                         ajListstrPushAppend(subdesc->Short, newdescstr);
---
>             case SWISS_OS:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'OS' */
> 
>                 while(ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken))
>                 {
>                     if(ajStrGetLen(taxstr))
>                         ajStrAppendK(&taxstr, ' ');
10490c11879
<                     ajStrAssignSubS(Pdescstr, token, 6, -1);
---
>                     ajStrAppendS(&taxstr, seqToken);
10492c11881,11887
<                 else if(ajStrPrefixC(token, "EC="))
---
>                 break;
> 
>             case SWISS_OC:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'OC' */
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
10494,10495c11889,11892
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
---
>                     ajStrTrimWhite(&seqToken);
>                     seqTaxSave(thys, seqToken, 0);
>                 }
>                 break;
10497,10500c11894,11897
<                     if(descistop)
<                         ajListstrPushAppend(descmaster->EC, newdescstr);
<                     else
<                         ajListstrPushAppend(subdesc->EC, newdescstr);
---
>             case SWISS_OG:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'OG' */
>                 ajStrTokenNextParse(seqHandle, &seqToken2);
10502,10505c11899,11902
<                     ajStrAssignSubS(Pdescstr, token, 3, -1);
<                     xref = ajSeqxrefNewDbC(*Pdescstr, "ENZYME", XREF_EC);
<                     ajSeqAddXref(thys, xref);
<                     xref = NULL;
---
>                 while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 {
>                     ajStrAppendK(&seqToken2, ' ');
>                     ajStrAppendS(&seqToken2, seqToken);
10507c11904,11916
<                 else if(ajStrPrefixC(token, "Allergen="))
---
> 
>                 if(ajStrGetCharLast(seqToken2) == '.')
>                     ajStrCutEnd(&seqToken2, 1);
> 
>                 seqTaxSave(thys, seqToken2, 2);
>                 break;
> 
>             case SWISS_OH:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " =;\n\r");
>                 ajStrTokenStep(seqHandle); /* 'OH' */
>                 ajStrTokenNextParse(seqHandle, &seqToken);
> 
>                 if(ajStrMatchC(seqToken, "NCBI_TaxID"))
10509,10513c11918,11920
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
<                     ajListstrPushAppend(subdesc->Allergen, newdescstr);
<                     ajStrAssignSubS(Pdescstr, token, 9, -1);
<                     xref = ajSeqxrefNewDbC(*Pdescstr, "Allergen", XREF_DESC);
---
>                     ajStrTokenNextParse(seqHandle, &seqToken2);
>                     seqTaxidSaveS(thys, seqToken2);
>                     xref = ajSeqxrefNewDbC(seqToken2, "taxon", XREF_TAX);
10517c11924,11931
<                 else if(ajStrPrefixC(token, "Biotech="))
---
>                 break;
> 
>             case SWISS_OX:
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " =;\n\r");
>                 ajStrTokenStep(seqHandle); /* 'OX' */
>                 ajStrTokenNextParse(seqHandle, &seqToken);
> 
>                 if(ajStrMatchC(seqToken, "NCBI_TaxID"))
10519,10530c11933,11935
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
<                     ajListstrPushAppend(subdesc->Biotech, newdescstr);
<                     ajStrAssignSubS(Pdescstr, token, 8, -1);
<                 }
<                 else if(ajStrPrefixC(token, "CD_antigen="))
<                 {
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
<                     ajListstrPushAppend(subdesc->Cdantigen, newdescstr);
<                     ajStrAssignSubS(Pdescstr, token, 11, -1);
<                     xref = ajSeqxrefNewDbC(*Pdescstr, "CD_Antigen", XREF_DESC);
---
>                     ajStrTokenNextParse(seqHandle, &seqToken2);
>                     seqTaxidSaveS(thys, seqToken2);
>                     xref = ajSeqxrefNewDbC(seqToken2, "taxon", XREF_TAX);
10534,10541c11939,11944
<                 else if(ajStrPrefixC(token, "INN="))
<                 {
<                     newdescstr = ajStrNewC("");
<                     Pdescstr = &newdescstr;
<                     ajListstrPushAppend(subdesc->Inn, newdescstr);
<                     ajStrAssignSubS(Pdescstr, token, 4, -1);
<                 }
<                 else 
---
>                 break;
> 
>             case SWISS_CC:
>                 ajStrAssignSubS(&seqToken, seqReadLine, 5, -1);
> 
>                 if(ajStrGetLen(cmtstr))
10543,10558c11946
<                     if(isdescflag)
<                     {
<                         if(ajStrMatchC(token,"Precursor"))
<                             thys->Fulldesc->Precursor = ajTrue;
<                         else if(ajStrMatchC(token,"Fragments"))
<                             thys->Fulldesc->Fragments = 2;
<                         else if(ajStrMatchC(token,"Fragment"))
<                             thys->Fulldesc->Fragments = 1;
<                         else
<                             ajDebug("unknown description flag text '%S'\n",
<                                     token);
<                     }
<                     else 
<                     {
<                         if(ajStrGetLen(*Pdescstr))
<                             ajStrAppendK(Pdescstr, ' ');
---
>                     ajStrAppendC(&cmtstr, "\n");
10560c11948,11953
<                         ajStrAppendS(Pdescstr, token);
---
>                     if(ajStrPrefixC(seqToken, "-!- ") ||
>                        (ajStrPrefixC(seqToken, "--------") &&
>                         ajStrPrefixC(cmtstr, "-!- ")))
>                     {
>                         ajSeqAddCmt(thys, cmtstr);
>                         cmtstr = NULL;
10563,10568d11955
<             }
<         }
< 
<         /* needs a little work for wrapped lines - save token and
<         ** append rather than set at the current level
<         */
10570,10576c11957,11958
< 	else if(ajStrPrefixC(seqReadLine, "GN   "))
< 	{
<             if(!seqgene)
<             {
<                 isnewgene = ajTrue;
<                 seqgene = ajSeqgeneNew();
<             }
---
>                 ajStrAppendS(&cmtstr, seqToken);
>                 break;
10578,10580c11960,11969
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'GN' */
< 	    ajStrTokenNextParseC(&handle, ";=\n\r", &token);
---
>             case SWISS_DR:
>                 AJNEW0(xref);
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>                 ajStrTokenStep(seqHandle); /* 'DR' */
>                 ajStrTokenNextParseC(seqHandle, ";\n\r",
>                                      &xref->Db); /* dbname */
>                 ajStrTrimWhite(&xref->Db);
>                 ajStrTokenNextParse(seqHandle, &xref->Id); /* primary */
>                 ajStrTrimWhite(&xref->Id);
>                 ajStrTokenNextParse(seqHandle, &seqToken); /* secondary*/
10582,10589c11971
<             if(ajStrMatchC(token, "and")) /* test 'and' between genes */
<             {
<                 isnewgene = ajTrue;
<                 seqgene = ajSeqgeneNew();
<             }
<             else
<             {
<                 while(ajStrGetLen(token))
---
>                 if(!ajStrGetLen(seqToken))
10591,10592c11973,11981
<                     isgenetoken = ajTrue;
<                     ajStrTrimWhite(&token);
---
>                     if(ajStrGetCharLast(xref->Id) == '.')
>                         ajStrCutEnd(&xref->Id, 1);
>                 }
>                 else
>                 {
>                     if(ajStrGetCharLast(seqToken) == '.')
>                         ajStrCutEnd(&seqToken, 1);
>                     ajStrTrimWhite(&seqToken);
>                     ajStrAssignS(&xref->Secid, seqToken);
10594,10609c11983,11985
<                     if(ajStrMatchC(token, "Name"))
<                     {
<                         ajStrTokenNextParseC(&handle, ";\n\r", &tmpstr);
<                         ajSeqgeneSetName(seqgene, tmpstr);
<                     }
<                     else if (ajStrMatchC(token, "Synonyms"))
<                     {
<                         ajStrTokenNextParseC(&handle, ";\n\r", &tmpstr);
<                         ajSeqgeneSetSynonyms(seqgene, tmpstr);
<                     }
<                     else if (ajStrMatchC(token, "OrderedLocusNames"))
<                     {
<                         ajStrTokenNextParseC(&handle, ";\n\r", &tmpstr);
<                         ajSeqgeneSetOln(seqgene, tmpstr);
<                     }
<                     else if (ajStrMatchC(token, "ORFNames"))
---
>                     ajStrTokenNextParse(seqHandle, &seqToken); /* secondary*/
> 
>                     if(!ajStrGetLen(seqToken))
10611,10612c11987,11988
<                         ajStrTokenNextParseC(&handle, ";\n\r", &tmpstr);
<                         ajSeqgeneSetOrf(seqgene, tmpstr);
---
>                         if(ajStrGetCharLast(xref->Secid) == '.')
>                             ajStrCutEnd(&xref->Secid, 1);
10616,10629c11992,11995
<                         isgenetoken = ajFalse;
<                         ajDebug("Swissnew GN line unexpected '%S' (%S)",
<                                token, genetoken);
< 
<                         if(ajStrMatchC(genetoken, "Name"))
<                             ajSeqgeneAppendName(seqgene, token);
<                         else if (ajStrMatchC(genetoken, "Synonyms"))
<                             ajSeqgeneAppendSynonyms(seqgene, token);
<                         else if (ajStrMatchC(genetoken,
<                                              "OrderedLocusNames"))
<                             ajSeqgeneAppendOln(seqgene, token);
<                         else if (ajStrMatchC(genetoken, "ORFNames"))
<                             ajSeqgeneAppendOrf(seqgene, token);
<                     }
---
>                         if(ajStrGetCharLast(seqToken) == '.')
>                             ajStrCutEnd(&seqToken, 1);
>                         ajStrTrimWhite(&seqToken);
>                         ajStrAssignS(&xref->Terid, seqToken);
10631c11997
<                     ajStrTokenNextParseC(&handle, "=;\n\r", &token);
---
>                         ajStrTokenNextParse(seqHandle, &seqToken);/* secondary*/
10633,10634c11999,12011
<                     if(isgenetoken)
<                         ajStrAssignS(&genetoken, token);
---
>                         if(!ajStrGetLen(seqToken))
>                         {
>                             if(ajStrGetCharLast(xref->Terid) == '.')
>                                 ajStrCutEnd(&xref->Terid, 1);
>                         }
>                         else
>                         {
>                             if(ajStrGetCharLast(seqToken) == '.')
>                                 ajStrCutEnd(&seqToken, 1);
>                             ajStrTrimWhite(&seqToken);
>                             ajStrAssignS(&xref->Quatid, seqToken);
>                         }
>                     }
10635a12013,12016
>                 xref->Type = XREF_DR;
>                 ajSeqAddXref(thys, xref);
>                 xref = NULL;
>                 break;
10637c12018,12019
<                 if(isnewgene)
---
>             case SWISS_RN:
>                 if(seqref)
10639,10640c12021,12023
<                     isnewgene = ajFalse;
<                     ajSeqAddGene(thys, seqgene);
---
>                     ajSeqrefStandard(seqref);
>                     ajSeqAddRef(thys, seqref);
>                     seqref = NULL;
10642,10644d12024
<                 /* keep seqgene so we can add to it if the line wraps */
<             }
< 	}
10646,10650c12026,12033
< 	else if(ajStrPrefixC(seqReadLine, "PE   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* PE */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token);
---
>                 seqref = ajSeqrefNew();
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RN' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* [num] */
>                 ajStrAssignSubS(&seqToken2, seqToken, 1, -2);
>                 ajStrToUint(seqToken2, &refnum);
>                 ajSeqrefSetnumNumber(seqref, refnum);
>                 break;
10652,10655c12035,12043
<             if(ajStrGetLen(token))
<                 ajStrAssignS(&thys->Evidence, token);
<         }
<     
---
>             case SWISS_RG:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RG' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* groupname */
>                 ajSeqrefAppendGroupname(seqref, seqToken);
>                 break;
10657,10703c12045,12053
< 	else if(ajStrPrefixC(seqReadLine, "KW   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KW' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OS   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OS' */
< 
< 	    while(ajStrTokenNextParseC(&handle, "\n\r", &token))
< 	    {
<                 if(ajStrGetLen(taxstr))
<                     ajStrAppendK(&taxstr, ' ');
< 
< 		ajStrAppendS(&taxstr, token);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OC' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 		ajStrDel(&tmpstr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OG   "))
< 	{
<             ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OG' */
< 	    ajStrTokenNextParse(&handle, &token);
<             ajStrAssignS(&tmpstr, token);
---
>             case SWISS_RX:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RX' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* xref */
>                 ajSeqrefAppendXref(seqref, seqToken);
>                 break;
10705,10712c12055,12063
<             while(ajStrTokenNextParse(&handle, &token))
<             {
<                 ajStrAppendK(&tmpstr, ' ');
<                 ajStrAppendS(&tmpstr, token);
<             }
<             
<             if(ajStrGetCharLast(tmpstr) == '.')
<                 ajStrCutEnd(&tmpstr, 1);
---
>             case SWISS_RP:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RP' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* position */
>                 ajSeqrefAppendPosition(seqref, seqToken);
>                 break;
10714,10715c12065,12073
<             seqTaxSave(thys, tmpstr, 2);
< 	}
---
>             case SWISS_RA:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RA' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r;", &seqToken); /* authors */
>                 ajSeqrefAppendAuthors(seqref, seqToken);
>                 break;
10717,10732c12075,12081
< 	else if(ajStrPrefixC(seqReadLine, "OX   "))
< 	{
<             ajStrTokenAssignC(&handle, seqReadLine, " =;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OX' */
< 	    ajStrTokenNextParse(&handle, &token);
<             ajStrAssignS(&tmpstr, token);
< 
<             if(ajStrMatchC(token, "NCBI_TaxID"))
<             {
<                 ajStrTokenNextParse(&handle, &token);
< 		seqTaxidSaveS(thys, token);
<                 xref = ajSeqxrefNewDbC(token, "taxon", XREF_TAX);
<                 ajSeqAddXref(thys, xref);
<                 xref = NULL;
< 	    }
< 	}
---
>             case SWISS_RT:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RT' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* title */
10734,10736c12083,12085
< 	else if(ajStrPrefixC(seqReadLine, "CC   "))
< 	{
< 	    ajStrAssignSubS(&token, seqReadLine, 5, -1);
---
>                 if(!ajStrMatchC(seqToken, ";"))
>                     ajSeqrefAppendTitle(seqref, seqToken);
>                 break;
10738,10740c12087,12095
< 	    if(ajStrGetLen(cmtstr))
<             {
< 		ajStrAppendC(&cmtstr, "\n");
---
>             case SWISS_RL:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RL' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* location */
>                 ajSeqrefAppendLocation(seqref, seqToken);
>                 break;
10742,10749c12097,12105
<                 if(ajStrPrefixC(token, "-!- ") ||
<                    (ajStrPrefixC(token, "--------") &&
<                     ajStrPrefixC(cmtstr, "-!- ")))
<                 {
<                     ajSeqAddCmt(thys, cmtstr);
<                     cmtstr = NULL;
<                 }
<             }
---
>             case SWISS_RC:
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'RC' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
>                 ajSeqrefAppendComment(seqref, seqToken);
>                 break;
10751,10752c12107,12109
< 	    ajStrAppendS(&cmtstr, token);
<         }
---
>             case SWISS_DT:
>                 if(!thys->Date)
>                     thys->Date = ajSeqdateNew();
10754,10765c12111,12112
< 	else if(ajStrPrefixC(seqReadLine, "DR   "))
< 	{
<             AJNEW0(xref);
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DR' */
< 	    ajStrTokenNextParseC(&handle, ";\n\r", &token); /* dbname */
< 	    ajStrAssignS(&xref->Db, token);
<             ajStrTrimWhite(&token);
< 	    ajStrTokenNextParse(&handle, &token); /* primary */
<             ajStrTrimWhite(&token);
< 	    ajStrAssignS(&xref->Id, token);
< 	    ajStrTokenNextParse(&handle, &token); /* secondary*/
---
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " (),.\n\r");
>                 icount = 0;
10767,10777c12114,12116
<             if(!ajStrGetLen(token))
<             {
<                 if(ajStrGetCharLast(xref->Id) == '.')
<                     ajStrCutEnd(&xref->Id, 1);
<             }
<             else
<             {
<                 if(ajStrGetCharLast(token) == '.')
<                     ajStrCutEnd(&token, 1);
<                 ajStrTrimWhite(&token);
<                 ajStrAssignS(&xref->Secid, token);
---
>                 while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 {
>                     icount++;
10779c12118,12124
<                 ajStrTokenNextParse(&handle, &token); /* secondary*/
---
>                     if(icount==2)
>                         ajStrAssignS(&datestr, seqToken);
>                     else if(icount == 3)
>                         ajStrAssignS(&datetype, seqToken);
>                     else if(icount == 5)
>                         ajStrAssignS(&relstr, seqToken);
>                 }
10781c12126
<                 if(!ajStrGetLen(token))
---
>                 if(ajStrMatchC(datetype, "integrated"))
10783,10784c12128,12139
<                     if(ajStrGetCharLast(xref->Secid) == '.')
<                         ajStrCutEnd(&xref->Secid, 1);
---
>                     ajSeqdateSetCreateS(thys->Date, datestr);
>                     ajStrAssignS(&thys->Date->CreVer, relstr);
>                 }
>                 else if (ajStrMatchC(datetype, "sequence"))
>                 {
>                     ajSeqdateSetModseqS(thys->Date, datestr);
>                     ajStrAssignS(&thys->Date->SeqVer, relstr);
>                 }
>                 else if (ajStrMatchC(datetype, "entry"))
>                 {
>                     ajSeqdateSetModifyS(thys->Date, datestr);
>                     ajStrAssignS(&thys->Date->ModVer, relstr);
10788,10806c12143,12144
<                     if(ajStrGetCharLast(token) == '.')
<                         ajStrCutEnd(&token, 1);
<                     ajStrTrimWhite(&token);
<                     ajStrAssignS(&xref->Terid, token);
< 
<                     ajStrTokenNextParse(&handle, &token); /* secondary*/
< 
<                     if(!ajStrGetLen(token))
<                     {
<                         if(ajStrGetCharLast(xref->Terid) == '.')
<                             ajStrCutEnd(&xref->Terid, 1);
<                     }
<                     else
<                     {
<                         if(ajStrGetCharLast(token) == '.')
<                             ajStrCutEnd(&token, 1);
<                         ajStrTrimWhite(&token);
<                         ajStrAssignS(&xref->Quatid, token);
<                     }
---
>                     ajDebug("unknown datetype '%S' '%S'",
>                             datetype, seqReadLine);
10808,10819c12146
<             }
<             xref->Type = XREF_DR;
< 	    ajSeqAddXref(thys, xref);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RN   "))
< 	{
<             if(seqref)
<             {
<                 ajSeqrefStandard(seqref);
<                 ajSeqAddRef(thys, seqref);
<             }
---
>                 break;
10821,10968c12148,12155
< 	    seqref = ajSeqrefNew();
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RN' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* [num] */
< 	    ajStrAssignSubS(&tmpstr, token, 1, -2);
< 	    ajStrToUint(tmpstr, &refnum);
< 	    ajSeqrefSetnumNumber(seqref, refnum);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RG   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RG' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* groupname */
< 	    ajSeqrefAppendGroupname(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RX   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RX' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* xref */
< 	    ajSeqrefAppendXref(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RP   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RP' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* position */
< 	    ajSeqrefAppendPosition(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RA   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RA' */
< 	    ajStrTokenNextParseC(&handle, "\n\r;", &token); /* authors */
< 	    ajSeqrefAppendAuthors(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RT   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RT' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* title */
< 
< 	    if(!ajStrMatchC(token, ";"))
< 		ajSeqrefAppendTitle(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RL   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RL' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* authors */
< 	    ajSeqrefAppendLocation(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RC   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RC' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* comment */
< 	    ajSeqrefAppendComment(seqref, token);
< 	}
< 
<         else if(ajStrPrefixC(seqReadLine, "FT   "))
<         {
< 	    if(seqinUfoLocal(seqin))
< 	    {
< 		if(!dofeat)
< 		{
< 		    dofeat = ajTrue;
< 		    ajFeattabinDel(&seqin->Ftquery);
< 		    seqin->Ftquery = ajFeattabinNewSS(seqFtFmtSwiss,
< 						      thys->Name, "N");
< 		    ajDebug("seqin->Ftquery ftfile %x\n",
< 			    seqin->Ftquery->Input->Filebuff);
< 		}
< 
< 		ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
< 		/* ajDebug("SWISS FEAT saved line:\n%S", seqReadLine); */
< 	    }
<         }
< 
< 	else if(ajStrPrefixC(seqReadLine, "DT   "))
< 	{
< 	    if(!thys->Date)
< 		thys->Date = ajSeqdateNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " (),.\n\r");
< 	    icount = 0;
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 	    {
< 		icount++;
< 
< 		if(icount==2)
< 		    ajStrAssignS(&datestr, token);
< 		else if(icount == 3)
< 		    ajStrAssignS(&datetype, token);
< 		else if(icount == 5)
< 		    ajStrAssignS(&relstr, token);
<             }
< 
<             if(ajStrMatchC(datetype, "integrated"))
<             {
<                 ajSeqdateSetCreateS(thys->Date, datestr);
<                 ajStrAssignS(&thys->Date->CreVer, relstr);
<             }
<             else if (ajStrMatchC(datetype, "sequence"))
<             {
<                 ajSeqdateSetModseqS(thys->Date, datestr);
<                 ajStrAssignS(&thys->Date->SeqVer, relstr);
<             }
<             else if (ajStrMatchC(datetype, "entry"))
<             {
<                 ajSeqdateSetModifyS(thys->Date, datestr);
<                 ajStrAssignS(&thys->Date->ModVer, relstr);
< 	    }
<             else 
<             {
<                 ajDebug("unknown datetype '%S' '%S'",
<                        datetype, seqReadLine);
<             }
< 	}
---
>             case SWISS_UNK:
>             case SWISS_END:
>             case SWISS_MORE:
>             case SWISS_XX:
>             case SWISS_SV:
>             case SWISS_MAX:
>                 ajWarn("Unknown swissprot line type '%2.2S'", seqReadLine);
>                 break;
10970,10971c12157,12162
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>             default:
>                 break;
>         }
>         
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
10974c12165
<     if(ajStrGetLen(taxstr)) 
---
>     if(MAJSTRGETLEN(taxstr))
10978c12169
<         if(ajStrGetCharLast(taxstr) == '.')
---
>         if(MAJSTRGETCHARLAST(taxstr) == '.')
10980c12171,12180
<         seqTaxSave(thys, taxstr, 1);
---
> 
>         ajStrTokenAssignC(&seqHandle, taxstr, "()");
>         itaxtype=1;
> 
>         while(ajStrTokenNextParse(seqHandle, &seqToken))
>         {
>             ajStrTrimWhite(&seqToken);
>             seqTaxSave(thys, seqToken, itaxtype);
>             itaxtype = 3;
>         }
10990c12190
<     if(ajStrGetLen(cmtstr))
---
>     if(MAJSTRGETLEN(cmtstr))
10998,11002c12198,12202
<  	ajDebug("EMBL FEAT TabIn %x\n", seqin->Ftquery);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>         ajDebug("EMBL FEAT TabIn %x\n", seqin->Ftquery);
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         /* ajFeattableTrace(thys->Fttable); */
>         ajFeattabinClear(seqin->Ftquery);
11005c12205
<     if(ajStrGetLen(seqin->Inseq))
---
>     if(MAJSTRGETLEN(seqin->Inseq))
11007,11008c12207,12208
< 	/* we have a sequence to use */
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
---
>         /* we have a sequence to use */
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
11010,11014c12210,12214
< 	if(seqin->Input->Text)
< 	{
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
< 	    ajFmtPrintAppS(&thys->TextPtr, "//\n");
< 	}
---
>         if(seqin->Input->Text)
>         {
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
>             ajFmtPrintAppS(&thys->TextPtr, "//\n");
>         }
11018,11028c12218,12227
< 	/* read the sequence and terminator */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    seqAppend(&thys->Seq, seqReadLine);
< 	    seqin->Input->Records++;
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	}
---
>         /* read the sequence and terminator */
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
> 
>         while(ok && lineprefix != SWISS_END)
>         {
>             seqAppend(&thys->Seq, seqReadLine);
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixSwiss(seqReadLine);
>         }
11030d12228
<     ajStrDel(&tmpstr);    
11035c12233
<     if(!ajStrGetLen(thys->Desc))
---
>     if(!MAJSTRGETLEN(thys->Desc) && thys->Fulldesc)
11041c12239
<         while((tmpstr = (AjPStr) ajListIterGet(iter)))
---
>         while((tmpstr = (const AjPStr) ajListIterGet(iter)))
11043c12241
<             if(ajStrGetLen(tmpstr))
---
>             if(MAJSTRGETLEN(tmpstr))
11046c12244
<         
---
> 
11051c12249
<         while((tmpstr = (AjPStr) ajListIterGet(iter)))
---
>         while((tmpstr = (const AjPStr) ajListIterGet(iter)))
11053c12251
<             if(ajStrGetLen(tmpstr))
---
>             if(MAJSTRGETLEN(tmpstr))
11056c12254
<         
---
> 
11063c12261
<             if(ajStrGetLen(subdesc->Name))
---
>             if(MAJSTRGETLEN(subdesc->Name))
11073c12271
<             
---
> 
11108c12306
<         
---
> 
11204c12402
<         
---
> 
11305c12503
<         
---
> 
11329c12527
<                 }
---
>             }
11347c12545
<         if(ajStrGetCharFirst(thys->Desc) == ' ')
---
>         if(MAJSTRGETCHARFIRST(thys->Desc) == ' ')
11355c12553,12554
<     ajSeqreflistGetXrefs(thys->Reflist, &thys->Xreflist);
---
>     if(thys->Reflist)
>         ajSeqreflistGetXrefs(thys->Reflist, &thys->Xreflist);
11358c12557
<     ajStrDel(&token);
---
> 
11363d12561
<     ajStrDel(&tmpstr);
11365c12563,12566
<     ajStrTokenDel(&handle);
---
> 
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
>     ajStrTokenReset(seqHandle);
11380a12582,12583
> **
> ** @release 1.0.0
11386,11388d12588
< 
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
11392,11394c12592,12594
<     AjPStr tmpstr = NULL;
<     AjBool dofeat        = ajFalse;
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
>     AjPStr liststr;                     /* for lists, do not delete */
11397c12597
<     AjPStr cmtstr = NULL;		/* stored in AjPSeq - do not delete */
---
>     AjPStr cmtstr = NULL;               /* stored in AjPSeq - do not delete */
11406a12607,12624
>     ajuint itaxtype = 0;
>     SeqEPrefixSwiss lineprefix = SWISS_UNK;
>     AjPStrTok handle = NULL;
>     AjPSeqin conseqin = NULL;
>     AjPSeq conseq = NULL;
>     AjPStr conqry = NULL;
>     AjPStr condb = NULL;
>     AjPStr confield = NULL;
>     AjPStr constr = NULL;
>     AjPStr numstr = NULL;
>     AjPStr token     = NULL;
>     ajuint gaplen = 0;
>     ajuint start = 0;
>     ajuint end = 0;
>     ajint dotpos;
>     ajint colonpos;
>     ajint istat = 0;
>     AjBool conrev = ajFalse;
11411c12629
< 	ajStrAssignC(&seqFtFmtEmbl, "embl");
---
>         ajStrAssignC(&seqFtFmtEmbl, "embl");
11413,11415c12631,12633
<     if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			   seqin->Input->Text, &thys->TextPtr))
< 	return ajFalse;
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         return ajFalse;
>     lineprefix = seqPrefixSwiss(seqReadLine);
11419c12637
<     while(ajStrPrefixC(seqReadLine, "WP "))
---
>     while(lineprefix == SWISS_WP)
11421,11424c12639,12642
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
<         seqin->Input->Records++;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
> 
>         lineprefix = seqPrefixSwiss(seqReadLine);
11431,11433c12649,12652
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
> 
>         lineprefix = seqPrefixSwiss(seqReadLine);
11438c12657
<     if(!ajStrPrefixC(seqReadLine, "ID   "))
---
>     if(lineprefix != SWISS_ID)
11440c12659
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
11442c12661
< 	return ajFalse;
---
>         return ajFalse;
11444d12662
<     seqin->Input->Records++;
11447c12665
< 	ajStrAssignC(&thys->TextPtr,ajStrGetPtr(seqReadLine));
---
>         ajStrAssignS(&thys->TextPtr, seqReadLine);
11450,11452c12668,12670
<     ajStrTokenAssignC(&handle, seqReadLine, " ;\t\n\r");
<     ajStrTokenNextParse(&handle, &token);	/* 'ID' */
<     ajStrTokenNextParse(&handle, &token);	/* entry name */
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\t\n\r");
>     ajStrTokenStep(seqHandle);       /* 'ID' */
>     ajStrTokenNextParse(seqHandle, &seqToken);       /* entry name */
11454c12672,12698
<     seqSetName(thys, token);
---
>     seqSetName(thys, seqToken);
> 
>     ajStrTokenNextParse(seqHandle, &seqToken);       /* SV for new syntax */
> 
>     if(ajStrMatchC(seqToken, "SV"))        /* new post-2006 EMBL line */
>     {
>         ajStrTokenNextParse(seqHandle, &seqToken);   /* SV */
>         ajStrInsertK(&seqToken, 0, '.');
>         ajStrInsertS(&seqToken, 0, thys->Name);
>         seqSvSave(thys, seqToken);
> 
>         ajStrTokenNextParse(seqHandle, &seqToken); /* linear or circular */
> 
>         if(ajStrMatchC(seqToken, "circular"))
>             thys->Circular = ajTrue;
> 
>         ajStrTokenNextParseC(seqHandle, ";\t\n\r", &seqToken);
>         ajStrTrimWhite(&seqToken);
>         ajSeqmolSetEmbl(&thys->Molecule, seqToken);
> 
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         ajStrTrimWhite(&seqToken);
>         ajStrAssignS(&thys->Class, seqToken);
> 
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         ajStrTrimWhite(&seqToken);
>         ajStrAssignS(&thys->Division, seqToken);
11456c12700,12722
<     ajStrTokenNextParse(&handle, &token);	/* SV for new syntax */
---
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         ajStrTrimEndC(&seqToken, "BP.");
>         ajStrTrimWhite(&seqToken);
>         ajStrToUint(seqToken, &seqlen);
>     }
>     else                     /* test for a SwissProt/SpTrEMBL entry */
>     {
>         if(ajStrFindC(seqReadLine, " PRT; ")>= 0  ||
>            ajStrFindC(seqReadLine, " Unreviewed; ") >= 0 ||
>            ajStrFindC(seqReadLine, " Reviewed; ") >= 0 ||
>            ajStrFindC(seqReadLine, " Preliminary; ") >= 0
>            )
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrTokenReset(seqHandle);
>             ajStrDelStatic(&seqToken);
> 
>             return ajFalse;
>         }
>     }
> 
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixSwiss(seqReadLine);
11458c12724,12729
<     if(ajStrMatchC(token, "SV"))	/* new post-2006 EMBL line */
---
>     dofeat = ajFalse;
>     tryfeat = seqinUfoLocal(seqin);
> 
>     while(ok &&
>           lineprefix != SWISS_SQ &&
>           lineprefix != SWISS_END)
11460,11625c12731,12844
< 	ajStrTokenNextParse(&handle, &token);	/* SV */
< 	ajStrInsertK(&token, 0, '.');
< 	ajStrInsertS(&token, 0, thys->Name);
< 	seqSvSave(thys, token);
< 
< 	ajStrTokenNextParse(&handle, &token); /* linear or circular */
< 
< 	if(ajStrMatchC(token, "circular"))
< 	    thys->Circular = ajTrue;
< 
< 	ajStrTokenNextParseC(&handle, ";\t\n\r", &token);
< 	ajStrTrimWhite(&token);
< 	ajSeqmolSetEmbl(&thys->Molecule, token);
< 
< 	ajStrTokenNextParse(&handle, &token);
< 	ajStrTrimWhite(&token);
< 	ajStrAssignS(&thys->Class, token);
< 
< 	ajStrTokenNextParse(&handle, &token);
< 	ajStrTrimWhite(&token);
< 	ajStrAssignS(&thys->Division, token);
< 
< 	ajStrTokenNextParse(&handle, &token);
< 	ajStrTrimEndC(&token, "BP.");
< 	ajStrTrimWhite(&token);
< 	ajStrToUint(token, &seqlen);
<     }
<     else		     /* test for a SwissProt/SpTrEMBL entry */
<     {
< 	if(ajStrFindC(seqReadLine, " PRT; ")>= 0  ||
< 	   ajStrFindC(seqReadLine, " Unreviewed; ") >= 0 ||
< 	   ajStrFindC(seqReadLine, " Reviewed; ") >= 0 ||
< 	   ajStrFindC(seqReadLine, " Preliminary; ") >= 0 
< 	   )
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    ajStrTokenDel(&handle);
< 	    ajStrDel(&token);
< 
< 	    return ajFalse;
< 	}
<     }
< 
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
< 
<     while(ok && !ajStrPrefixC(seqReadLine, "SQ"))
<     {
< 	seqin->Input->Records++;
< 
< 	/* check for Staden Experiment format instead */
< 	if(ajStrPrefixC(seqReadLine, "EN   ") ||
< 	   ajStrPrefixC(seqReadLine, "TN   ") ||
< 	   ajStrPrefixC(seqReadLine, "EX   ") )
< 	{
< 	    ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	    ajStrDel(&token);
< 
< 	    return ajFalse;;
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "FH   ") ||
< 		ajStrPrefixC(seqReadLine, "AH   "))
< 	    ok = ajTrue;		/* ignore these lines */
< 
< 	else if(ajStrPrefixC(seqReadLine, "AC   ") ||
< 	   ajStrPrefixC(seqReadLine, "PA   ") ) /* emblcds database format */
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'AC' */
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "SV   ") ||
< 	   ajStrPrefixC(seqReadLine, "IV   ") ) /* emblcds database format */
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'SV' */
< 	    ajStrTokenNextParse(&handle, &token); /* version */
< 	    seqSvSave(thys, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "DE   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 
< 	    if(ajStrGetLen(thys->Desc))
< 	    {
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 	    }
< 	    else
< 		ajStrAssignS(&thys->Desc, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "KW   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KW' */
< 
<             while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OS   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OS' */
< 
< 	    /* maybe better remove . from this, and trim from end */
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 1);
< 		ajStrDel(&tmpstr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OC' */
< 
< 	    /* maybe better remove . from this, and trim from end */
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 		ajStrDel(&tmpstr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "OG   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OG' */
< 
< 	    /* maybe better remove . from this, and trim from end */
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 2);
< 		ajStrDel(&tmpstr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "CC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'CC' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* comment */
< 
< 	    if(ajStrGetLen(cmtstr))
< 		ajStrAppendC(&cmtstr, "\n");
< 	    ajStrAppendS(&cmtstr, token);
---
>         /* check for Staden Experiment format instead */
>         if(lineprefix == SWISS_EX)
>         {
>             ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>             ajStrDelStatic(&seqToken);
> 
>             return ajFalse;;
>         }
> 
>         else if(lineprefix == SWISS_FH)
>             ok = ajTrue;                /* ignore these lines */
> 
>         else if(lineprefix == SWISS_AC) /* emblcds database format */
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'AC' */
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
> 
>         else if(lineprefix==SWISS_SV)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'SV' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* version */
>             seqSvSave(thys, seqToken);
>         }
> 
>         else if(lineprefix == SWISS_DE)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'DE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* desc */
> 
>             if(ajStrGetLen(thys->Desc))
>             {
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>             }
>             else
>                 ajStrAssignS(&thys->Desc, seqToken);
>         }
> 
>         else if(lineprefix == SWISS_KW)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'KW' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 liststr = ajStrNewS(seqToken);
>                 ajStrTrimWhite(&liststr);
>                 ajSeqAddKey(thys, liststr);
>                 liststr = NULL;
>             }
>         }
> 
>         else if(lineprefix == SWISS_OS)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'OS' */
> 
>             /* maybe better remove . from this, and trim from end */
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 ajStrTokenAssignC(&seqHandle2, seqToken, "()");
>                 itaxtype=1;
> 
>                 while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>                 {
>                     ajStrTrimWhite(&seqToken2);
>                     seqTaxSave(thys, seqToken2, itaxtype);
>                     itaxtype = 3;
>                 }
>             }
>         }
> 
>         else if(lineprefix == SWISS_OC)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'OC' */
> 
>             /* maybe better remove . from this, and trim from end */
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 seqTaxSave(thys, seqToken, 0);
>             }
>         }
> 
>         else if(lineprefix == SWISS_OG)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'OG' */
> 
>             /* maybe better remove . from this, and trim from end */
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 seqTaxSave(thys, seqToken, 2);
>             }
>         }
> 
>         else if(lineprefix == SWISS_CC)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'CC' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
> 
>             if(ajStrGetLen(cmtstr))
>                 ajStrAppendC(&cmtstr, "\n");
>             ajStrAppendS(&cmtstr, seqToken);
11633,11651c12852,12870
< 	    if(ajStrGetLen(cmtstr))
< 	    {
< 		if(ajStrGetLen(token))
< 		{
< 		    if(ajStrGetCharLast(cmtstr) != '\n')
< 			ajStrAppendK(&cmtstr, ' ');
< 		    ajStrAppendS(&cmtstr, token);
< 		}
< 		else
< 		{
< 		    if(ajStrGetCharLast(cmtstr) != '\n')
< 			ajStrAppendK(&cmtstr, '\n');
< 		    ajStrAppendC(&cmtstr, " \n");
< 		}
< 	    }
< 	    else
< 		ajStrAssignS(&cmtstr, token);
< 	    if(ajStrGetCharLast(token) == '.')
< 		ajStrAppendK(&cmtstr, '\n');
---
>   if(ajStrGetLen(cmtstr))
>   {
>   if(ajStrGetLen(seqToken))
>   {
>   if(ajStrGetCharLast(cmtstr) != '\n')
>   ajStrAppendK(&cmtstr, ' ');
>   ajStrAppendS(&cmtstr, seqToken);
>   }
>   else
>   {
>   if(ajStrGetCharLast(cmtstr) != '\n')
>   ajStrAppendK(&cmtstr, '\n');
>   ajStrAppendC(&cmtstr, " \n");
>   }
>   }
>   else
>   ajStrAssignS(&cmtstr, seqToken);
>   if(ajStrGetCharLast(seqToken) == '.')
>   ajStrAppendK(&cmtstr, '\n');
11653c12872
< 	}
---
>         }
11655,11656c12874,12875
< 	else if(ajStrPrefixC(seqReadLine, "DR   "))
< 	{
---
>         else if(lineprefix == SWISS_DR)
>         {
11658,11666c12877,12886
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DR' */
< 	    ajStrTokenNextParseC(&handle, ";\n\r", &token); /* dbname */
< 	    ajStrAssignS(&xref->Db, token);
<             ajStrTrimWhite(&token);
< 	    ajStrTokenNextParse(&handle, &token); /* primary */
<             ajStrTrimWhite(&token);
< 	    ajStrAssignS(&xref->Id, token);
< 	    ajStrTokenNextParse(&handle, &token); /* secondary*/
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'DR' */
> 
>             ajStrTokenNextParseC(seqHandle, ";\n\r", &seqToken); /* dbname */
>             ajStrTrimWhite(&seqToken);
>             ajStrAssignS(&xref->Db, seqToken);
> 
>             ajStrTokenNextParse(seqHandle, &seqToken); /* primary */
>             ajStrTrimWhite(&seqToken);
>             ajStrAssignS(&xref->Id, seqToken);
11668c12888,12890
<             if(!ajStrGetLen(token))
---
>             ajStrTokenNextParse(seqHandle, &seqToken); /* secondary*/
> 
>             if(!ajStrGetLen(seqToken))
11675,11678c12897,12900
<                 if(ajStrGetCharLast(token) == '.')
<                     ajStrCutEnd(&token, 1);
<                 ajStrTrimWhite(&token);
<                 ajStrAssignS(&xref->Secid, token);
---
>                 if(ajStrGetCharLast(seqToken) == '.')
>                     ajStrCutEnd(&seqToken, 1);
>                 ajStrTrimWhite(&seqToken);
>                 ajStrAssignS(&xref->Secid, seqToken);
11680c12902
<                 ajStrTokenNextParse(&handle, &token); /* secondary*/
---
>                 ajStrTokenNextParse(seqHandle, &seqToken); /* secondary*/
11682c12904
<                 if(!ajStrGetLen(token))
---
>                 if(!ajStrGetLen(seqToken))
11689,11692c12911,12914
<                     if(ajStrGetCharLast(token) == '.')
<                         ajStrCutEnd(&token, 1);
<                     ajStrTrimWhite(&token);
<                     ajStrAssignS(&xref->Terid, token);
---
>                     if(ajStrGetCharLast(seqToken) == '.')
>                         ajStrCutEnd(&seqToken, 1);
>                     ajStrTrimWhite(&seqToken);
>                     ajStrAssignS(&xref->Terid, seqToken);
11694c12916
<                     ajStrTokenNextParse(&handle, &token); /* secondary*/
---
>                     ajStrTokenNextParse(seqHandle, &seqToken); /* secondary*/
11696c12918
<                     if(!ajStrGetLen(token))
---
>                     if(!ajStrGetLen(seqToken))
11703,11706c12925,12928
<                         if(ajStrGetCharLast(token) == '.')
<                             ajStrCutEnd(&token, 1);
<                         ajStrTrimWhite(&token);
<                         ajStrAssignS(&xref->Quatid, token);
---
>                         if(ajStrGetCharLast(seqToken) == '.')
>                             ajStrCutEnd(&seqToken, 1);
>                         ajStrTrimWhite(&seqToken);
>                         ajStrAssignS(&xref->Quatid, seqToken);
11711,11712c12933,12935
< 	    ajSeqAddXref(thys, xref);
< 	}
---
>             ajSeqAddXref(thys, xref);
>             xref = NULL;
>         }
11714,11860c12937,12940
< 	else if(ajStrPrefixC(seqReadLine, "RN   "))
< 	{
< 	    seqref = ajSeqrefNew();
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RN' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* [num] */
< 	    ajStrAssignSubS(&tmpstr, token, 1, -2);
< 	    ajStrToUint(tmpstr, &refnum);
< 	    ajSeqrefSetnumNumber(seqref, refnum);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RG   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RG' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* groupname */
< 	    ajSeqrefAppendGroupname(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RX   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RX' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* xref */
< 	    ajSeqrefAppendXref(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RP   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RP' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* position */
< 	    ajSeqrefAppendPosition(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RA   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RA' */
< 	    ajStrTokenNextParseC(&handle, "\n\r;", &token); /* authors */
< 	    ajSeqrefAppendAuthors(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RT   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RT' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* title */
< 
< 	    if(!ajStrMatchC(token, ";"))
< 		ajSeqrefAppendTitle(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RL   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RL' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* authors */
< 	    ajSeqrefAppendLocation(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "RC   "))
< 	{
< 	    if(!seqref)
< 		seqref = ajSeqrefNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'RC' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* comment */
< 	    ajSeqrefAppendComment(seqref, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "FT   "))
< 	{
< 	    if(seqinUfoLocal(seqin))
< 	    {
< 		if(!dofeat)
< 		{
< 		    dofeat = ajTrue;
< 		    ajFeattabinDel(&seqin->Ftquery);
< 		    seqin->Ftquery = ajFeattabinNewSS(seqFtFmtEmbl,
< 						      thys->Name, "N");
< 		    /* ajDebug("seqin->Ftquery Filebuff %x\n",
< 		       seqin->Ftquery->Input->Filebuff); */
< 		}
< 
< 		ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
< 		/* ajDebug("EMBL FEAT saved line:\n%S", seqReadLine); */
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "DT   "))
< 	{
< 	    if(!thys->Date)
< 		thys->Date = ajSeqdateNew();
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " (),");
< 	    icount = 0;
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 	    {
< 		icount++;
< 
< 		if(icount==2)
< 		    ajStrAssignS(&datestr, token);
< 		else if(icount==4)
< 		    ajStrAssignS(&relstr, token);
< 		else if(icount==5)
< 		{
< 		    if(ajStrMatchC(token, "Created"))
< 		    {
< 			ajSeqdateSetCreateS(thys->Date, datestr);
< 			ajStrAssignS(&thys->Date->CreRel, relstr);
< 		    }
< 		}
< 		else if(icount==8)
< 		{
< 			ajSeqdateSetModifyS(thys->Date, datestr);
< 			ajStrAssignS(&thys->Date->ModRel, relstr);
< 			ajStrAssignS(&thys->Date->ModVer, token);
< 		}
< 	    }
< 	}
< 
< 
< 	else if(ajStrPrefixC(seqReadLine, "XX"))
< 	{
< 	    if(seqref)
< 	    {
---
>         else if(lineprefix == SWISS_RN)
>         {
>             if(seqref)
>             {
11862,11869c12942,12944
< 		ajSeqAddRef(thys, seqref);
< 		seqref = NULL;
< 	    }
< 	    if(ajStrGetLen(cmtstr))
< 	    {
<                 ajSeqAddCmt(thys, cmtstr);
< 		cmtstr = NULL;
< 	    }
---
>                 ajSeqAddRef(thys, seqref);
>                 seqref = NULL;
>             }
11871c12946,12953
< 	}
---
>             seqref = ajSeqrefNew();
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RN' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* [num] */
>             ajStrAssignSubS(&seqToken2, seqToken, 1, -2);
>             ajStrToUint(seqToken2, &refnum);
>             ajSeqrefSetnumNumber(seqref, refnum);
>         }
11873c12955,12958
< /* ignored line types */
---
>         else if(lineprefix == SWISS_RG)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
11875,11888c12960,12964
< /* other line types */
< /*
< 	if(ajStrPrefixC(seqReadLine, "RN   "))
< 	if(ajStrPrefixC(seqReadLine, "RC   "))
< 	if(ajStrPrefixC(seqReadLine, "RP   "))
< 	if(ajStrPrefixC(seqReadLine, "RX   "))
< 	if(ajStrPrefixC(seqReadLine, "RG   "))
< 	if(ajStrPrefixC(seqReadLine, "RA   "))
< 	if(ajStrPrefixC(seqReadLine, "RT   "))
< 	if(ajStrPrefixC(seqReadLine, "RL   "))
< 	if(ajStrPrefixC(seqReadLine, "AS   "))
< 	if(ajStrPrefixC(seqReadLine, "CO   "))
< 	if(ajStrPrefixC(seqReadLine, "CC   "))
< */
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RG' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* groupname */
>             ajSeqrefAppendGroupname(seqref, seqToken);
>         }
11890,11892c12966,12969
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
<     }
---
>         else if(lineprefix == SWISS_RX)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
11894c12971,12975
<     /* now we are on the SQ line - or there was nothing */
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RX' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* xref */
>             ajSeqrefAppendXref(seqref, seqToken);
>         }
11896,11900c12977,12980
<     ajStrTokenAssignC(&handle, seqReadLine, " ");
<     ajStrTokenNextParse(&handle, &token); /* 'SQ' */
<     ajStrTokenNextParse(&handle, &token); /* 'Sequence' */
<     ajStrTokenNextParse(&handle, &token); /* len */
<     ajStrToUint(token, &tmplen);
---
>         else if(lineprefix == SWISS_RP)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
11902,11903c12982,12986
<     if(tmplen > seqlen)
< 	seqlen = tmplen;
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RP' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* position */
>             ajSeqrefAppendPosition(seqref, seqToken);
>         }
11905,11906c12988,12991
<     ajStrTokenNextParse(&handle, &token); /* BP; */
<     tmplen = 0;
---
>         else if(lineprefix == SWISS_RA)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
11908,11914c12993,12997
<     for(i=0;i<4;i++)
<     {
< 	ajStrTokenNextParse(&handle, &token); /* count */
< 	ajStrToUint(token, &itmp);
< 	ajStrTokenNextParse(&handle, &token); /* 'A' 'C' 'G' 'T' 'other' */
< 	tmplen += itmp;
<     }
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RA' */
>             ajStrTokenNextParseC(seqHandle, "\n\r;", &seqToken); /* authors */
>             ajSeqrefAppendAuthors(seqref, seqToken);
>         }
11916,11917c12999,13002
<     if(tmplen > seqlen)
< 	seqlen = tmplen;
---
>         else if(lineprefix == SWISS_RT)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
11919,11925c13004,13112
<     if(dofeat)
<     {
< 	/* ajDebug("EMBL FEAT TabIn %x\n", seqin->Ftquery); */
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RT' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* title */
> 
>             if(!ajStrMatchC(seqToken, ";"))
>                 ajSeqrefAppendTitle(seqref, seqToken);
>         }
> 
>         else if(lineprefix == SWISS_RL)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RL' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* authors */
>             ajSeqrefAppendLocation(seqref, seqToken);
>         }
> 
>         else if(lineprefix == SWISS_RC)
>         {
>             if(!seqref)
>                 seqref = ajSeqrefNew();
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'RC' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
>             ajSeqrefAppendComment(seqref, seqToken);
>         }
> 
>         else if(tryfeat && lineprefix == SWISS_FT)
>         {
>             if(!dofeat)
>             {
>                 dofeat = ajTrue;
>                 ajFeattabinDel(&seqin->Ftquery);
>                 seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtEmbl,
>                                                        thys->Name, "N");
>                 ajDebug("seqReadEmbl: seqin->Ftquery Filebuff %x\n",
>                         seqin->Ftquery->Input->Filebuff);
>             }
> 
>             ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
>             /* ajDebug("EMBL FEAT saved line:\n%S", seqReadLine); */
>         }
> 
>         else if(lineprefix == SWISS_DT)
>         {
>             if(!thys->Date)
>                 thys->Date = ajSeqdateNew();
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " (),");
>             icount = 0;
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>             {
>                 icount++;
> 
>                 if(icount==2)
>                     ajStrAssignS(&datestr, seqToken);
>                 else if(icount==4)
>                     ajStrAssignS(&relstr, seqToken);
>                 else if(icount==5)
>                 {
>                     if(ajStrMatchC(
>                            seqToken, "Created"))
>                     {
>                         ajSeqdateSetCreateS(thys->Date, datestr);
>                         ajStrAssignS(&thys->Date->CreRel, relstr);
>                     }
>                 }
>                 else if(icount==8)
>                 {
>                     ajSeqdateSetModifyS(thys->Date, datestr);
>                     ajStrAssignS(&thys->Date->ModRel, relstr);
>                     ajStrAssignS(&thys->Date->ModVer, seqToken);
>                 }
>             }
>         }
> 
> 
>         else if(lineprefix == SWISS_XX)
>         {
>             if(seqref)
>             {
>                 ajSeqrefStandard(seqref);
>                 ajSeqAddRef(thys, seqref);
>                 seqref = NULL;
>             }
> 
>             if(ajStrGetLen(cmtstr))
>             {
>                 ajSeqAddCmt(thys, cmtstr);
>                 cmtstr = NULL;
>             }
> 
>         }
> 
>         else if(lineprefix == SWISS_CO)
>         {
>             if(!constr)
>                 constr = ajStrNewRes(4096);
> 
>             ajStrTrimWhiteEnd(&seqReadLine);
>             ajStrAppendSubS(&constr, seqReadLine, 5, -1);
>         }
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
11928c13115
<     if(ajStrGetLen(seqin->Inseq))
---
>     if(lineprefix == SWISS_END && ajStrGetLen(constr))
11930,11931c13117,13224
< 	/* we have a sequence to use */
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
---
>         conseq = ajSeqNew();
> 
>         if(ajStrPrefixC(constr, "join(") && ajStrSuffixC(constr, ")"))
>         {
>             ajStrCutEnd(&constr, 1);
>             ajStrCutStart(&constr, 5);
>         }
> 
>         ajStrTokenAssignC(&handle, constr, ",");
> 
>         while(ajStrTokenNextParse(handle, &token))
>         {
>             ajDebug("CO parsing token '%S'\n", token);
> 
>             if(ajStrPrefixC(token, "gap("))
>             {
>                 ajDebug("CO gap: '%S'\n", token);
>                 ajStrCutEnd(&token, 1);
>                 ajStrCutStart(&token, 4);
>                 if(ajStrToUint(token, &gaplen))
>                 {
>                     ajDebug("gap %u bases total %u\n",
>                            gaplen, ajSeqGetLen(thys));
>                 }
>                 else
>                     ajWarn("Unknown gap length in '%S'", constr);
> 
>                 ajStrAppendCountK(&thys->Seq, 'N', gaplen);
>             }
>             else
>             {
>                 if(ajStrPrefixC(token, "complement("))
>                 {
>                     ajStrCutEnd(&token, 1);
>                     ajStrCutStart(&token, 11);
>                     conrev = ajTrue;
>                 }
> 
>                 if(!condb)
>                 {
>                     if(!ajNamDbGetAttrSpecialC(seqin->Input->Db, "ConDatabase",
>                                                &condb))
>                         ajStrAssignS(&condb, seqin->Input->Db);
>                     if(!ajNamDbGetAttrSpecialC(seqin->Input->Db, "ConField",
>                                                &confield))
>                         ajStrAssignC(&confield, "acc");
>                 }
> 
>                 dotpos   = (ajint) ajStrFindAnyK(token, '.');
>                 colonpos = (ajint) ajStrFindAnyK(token, ':');
>                 ajStrAssignSubS(&numstr, token, colonpos+1, -1);
>                 istat = ajFmtScanS(numstr, "%u..%u", &start, &end);
>                 if(istat != 2)
>                 {
>                     ajWarn("EMBLCON badly formed fragment '%S'", token);
>                     start = 1;
>                     end = 0;
>                 }
> 
>                 if(ajStrMatchC(confield, "sv"))
>                 {
>                     ajFmtPrintS(&conqry, "%S-sv:%S", seqin->Input->Db, token);
>                     if(conrev)
>                         ajStrAppendC(&conqry, ":r");
>                 }
>                 else
>                 {
>                     if((dotpos > 0) && (dotpos < colonpos))
>                     {
>                         ajStrCutRange(&token, dotpos, colonpos-1);
>                         ajFmtPrintS(&conqry, "%S-%S:%S",
>                                     condb, confield, token);
>                         if(conrev)
>                             ajStrAppendC(&conqry, ":r");
>                     }
>                 }
>                 ajDebug("CO done: '%S' '%S' rev:%B\n",
>                         token, conqry, conrev);
> 
>                 ajSeqinUsa(&conseqin, conqry);
> 
>                 if(!ajSeqRead(conseq, conseqin))
>                     ajErr("EMBLCON entry '%S' failed to read '%S'",
>                           thys->Name, conqry);
>                 else
>                 {
>                     ajSeqTrim(conseq);
>                     if(conrev)
>                         ajSeqReverseDo(conseq);
>                     seqAppend(&thys->Seq, ajSeqGetSeqS(conseq));
>                     ajDebug("Read %u bases total %u\n",
>                             ajSeqGetLen(conseq), ajSeqGetLen(thys));
>                 }
>             }
>         }
> 
>         ajDebug("CO processed seqlen: %u\n", ajSeqGetLen(thys));
> 
>         ajStrTokenDel(&handle);
> 
>         while(ok && lineprefix != SWISS_END)
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixSwiss(seqReadLine);
>         }
> 
>         ajSeqinDel(&conseqin);
>         ajSeqDel(&conseq);
11933,11937d13225
< 	if(seqin->Input->Text)
< 	{
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
< 	    ajFmtPrintAppS(&thys->TextPtr, "//\n");
< 	}
11939c13227,13228
<     else
---
> 
>     if(ok && lineprefix == SWISS_SQ)
11941,11952c13230,13298
< 	/* read the sequence and terminator */
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	ajStrSetRes(&thys->Seq, seqlen+1);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    seqAppend(&thys->Seq, seqReadLine);
< 	    seqin->Input->Records++;
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	}
---
>         /* now we are on the SQ line - or there was nothing */
> 
>         ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>         ajStrTokenStep(seqHandle); /* 'SQ' */
>         ajStrTokenStep(seqHandle); /* 'Sequence' */
>         ajStrTokenNextParse(seqHandle, &seqToken); /* len */
>         ajStrToUint(seqToken, &tmplen);
> 
>         if(tmplen > seqlen)
>             seqlen = tmplen;
> 
>         ajStrTokenStep(seqHandle); /* BP; */
>         tmplen = 0;
> 
>         for(i=0;i<4;i++)
>         {
>             ajStrTokenNextParse(seqHandle, &seqToken); /* count */
>             ajStrToUint(seqToken, &itmp);
>             ajStrTokenNextParse(seqHandle,
>                                 &seqToken); /* 'A' 'C' 'G' 'T' 'other' */
>             tmplen += itmp;
>         }
> 
>         if(tmplen > seqlen)
>             seqlen = tmplen;
> 
>         if(dofeat)
>         {
>             ajFeattableDel(&thys->Fttable);
>             thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>             /* ajFeattableTrace(thys->Fttable); */
>             ajDebug("EMBL FEAT SQ TabIn filebuff: %x features: %u\n",
>                     seqin->Ftquery->Input->Filebuff,
>                     ajFeattableGetSize(thys->Fttable));
>             ajFeattabinClear(seqin->Ftquery);
>         }
>         else if(tryfeat) /* but no features in entry */
>         {
>             ajDebug("EMBL FEAT SQ empty filebuff: %x\n",
>                     seqin->Ftquery->Input->Filebuff);
>             thys->Fttable = ajFeattableNewSeq(thys);
>         }
> 
>         if(ajStrGetLen(seqin->Inseq))
>         {
>             /* we have a sequence to use ...perhaps from GCG/NBRF format */
>             ajStrAssignS(&thys->Seq, seqin->Inseq);
> 
>             if(seqin->Input->Text)
>             {
>                 seqTextSeq(&thys->TextPtr, seqin->Inseq);
>                 ajFmtPrintAppS(&thys->TextPtr, "//\n");
>             }
>         }
>         else
>         {
>             /* read the sequence and terminator */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixSwiss(seqReadLine);
>             ajStrSetRes(&thys->Seq, seqlen+1);
> 
>             while(ok && lineprefix != SWISS_END)
>             {
>                 seqAppend(&thys->Seq, seqReadLine);
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixSwiss(seqReadLine);
>             }
> 
>         }
11957,11959c13303
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
<         ajStrDel(&tmpstr);
<         ajStrDel(&token);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
11962c13306,13307
<         ajStrTokenDel(&handle);
---
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
11966c13311
<     
---
> 
11978c13323
<     
---
> 
11986,11987d13330
<     ajStrDel(&tmpstr);
<     ajStrDel(&token);
11989a13333,13341
>     ajStrDel(&condb);
>     ajStrDel(&confield);
>     ajStrDel(&constr);
>     ajStrDel(&numstr);
>     ajStrDel(&conqry);
>     ajStrDel(&token);
> 
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
11991c13343,13344
<     ajStrTokenDel(&handle);
---
>     ajStrTokenReset(seqHandle);
>     ajStrTokenReset(seqHandle2);
12008a13362,13363
> **
> ** @release 3.0.0
12015,12018d13369
<     AjPStrTok handle  = NULL;
<     AjPStrTok handle2 = NULL;
<     AjPStr token      = NULL;
<     AjPStr token2     = NULL;
12021,12023c13372,13374
<     AjPStr tmpstr = NULL;
<     AjBool dofeat        = ajFalse;
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
>     AjPStr liststr;                     /* for lists, do not delete */
12027a13379,13380
>     ajuint itaxtype;
>     SeqEPrefixSwiss lineprefix = SWISS_UNK;
12032c13385
< 	ajStrAssignC(&seqFtFmtEmbl, "embl");
---
>         ajStrAssignC(&seqFtFmtEmbl, "embl");
12034,12036c13387,13388
<     if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			   seqin->Input->Text, &thys->TextPtr))
< 	return ajFalse;
---
>     if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>         return ajFalse;
12038c13390
<     seqin->Input->Records++;
---
>     lineprefix = seqPrefixSwiss(seqReadLine);
12042c13394
<     if(!ajStrPrefixC(seqReadLine, "ID   "))
---
>     if(lineprefix != SWISS_ID)
12044c13396
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12046c13398
< 	return ajFalse;
---
>         return ajFalse;
12050c13402
< 	ajStrAssignC(&thys->TextPtr,ajStrGetPtr(seqReadLine));
---
>         ajStrAssignS(&thys->TextPtr, seqReadLine);
12053,12055c13405,13407
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r\t");
<     ajStrTokenNextParse(&handle, &token);	/* 'ID' */
<     ajStrTokenNextParse(&handle, &token);	/* entry name */
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r\t");
>     ajStrTokenStep(seqHandle);       /* 'ID' */
>     ajStrTokenNextParse(seqHandle, &seqToken);       /* entry name */
12057c13409
<     seqSetName(thys, token);
---
>     seqSetName(thys, seqToken);
12059,12060c13411,13412
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixSwiss(seqReadLine);
12062c13414
<     while(ok && !ajStrPrefixC(seqReadLine, "SQ"))
---
>     while(ok && lineprefix != SWISS_SQ)
12064c13416,13498
< 	seqin->Input->Records++;
---
>         if(lineprefix == SWISS_EX)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'EX'*/
>             ajStrTokenNextParseC(seqHandle, "\n\r",
>                                  &seqToken); /*  expt. desc. */
> 
>             if(ajStrGetLen(thys->Desc))
>             {
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>             }
>             else
>                 ajStrAssignS(&thys->Desc, seqToken);
>         }
> 
>         if(lineprefix == SWISS_AV)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'AV' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* desc */
> 
>             if(ajStrGetLen(accvalstr))
>             {
>                 ajStrAppendC(&accvalstr, " ");
>                 ajStrAppendS(&accvalstr, seqToken);
>             }
>             else
>                 ajStrAssignS(&accvalstr, seqToken);
>         }
> 
>         /* standard EMBL records are allowed */
> 
>         if(lineprefix == SWISS_AC)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'AC' */
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
> 
>         if(lineprefix == SWISS_SV)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'SV' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* version */
>             seqSvSave(thys, seqToken);
>         }
> 
>         if(lineprefix == SWISS_DE)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'DE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* desc */
> 
>             if(ajStrGetLen(thys->Desc))
>             {
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>             }
>             else
>                 ajStrAssignS(&thys->Desc, seqToken);
>         }
> 
>         if(lineprefix == SWISS_KW)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'KW' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 liststr = ajStrNewS(seqToken);
>                 ajStrTrimWhite(&liststr);
>                 ajSeqAddKey(thys, liststr);
>                 liststr = NULL;
>             }
>         }
> 
>         if(lineprefix == SWISS_OS)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'OS' */
12066,12185c13500,13505
< 	if(ajStrPrefixC(seqReadLine, "EX   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'EX'*/
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /*  expt. desc. */
< 
< 	    if(ajStrGetLen(thys->Desc))
< 	    {
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 	    }
< 	    else
< 		ajStrAssignS(&thys->Desc, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "AV   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'AV' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 
< 	    if(ajStrGetLen(accvalstr))
< 	    {
< 		ajStrAppendC(&accvalstr, " ");
< 		ajStrAppendS(&accvalstr, token);
< 	    }
< 	    else
< 		ajStrAssignS(&accvalstr, token);
< 	}
< 
< 	/* standard EMBL records are allowed */
< 
< 	if(ajStrPrefixC(seqReadLine, "AC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'AC' */
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "SV   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'SV' */
< 	    ajStrTokenNextParse(&handle, &token); /* version */
< 	    seqSvSave(thys, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "DE   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 
< 	    if(ajStrGetLen(thys->Desc))
< 	    {
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 	    }
< 	    else
< 		ajStrAssignS(&thys->Desc, token);
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "KW   "))
< 	{
<             ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KW' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "OS   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OS' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 1);
< 	    }
< 	}
< 
< 	if(ajStrPrefixC(seqReadLine, "OC   "))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'OC' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 	    }
< 	}
< 
< 	ajStrDel(&tmpstr);
< 
< 	if(ajStrPrefixC(seqReadLine, "FT   "))
< 	    if(seqinUfoLocal(seqin))
< 	    {
< 		if(!dofeat)
< 		{
< 		    dofeat = ajTrue;
< 		    ajFeattabinDel(&seqin->Ftquery);
< 		    seqin->Ftquery = ajFeattabinNewSS(seqFtFmtEmbl,
< 						      thys->Name, "N");
< 		    /* ajDebug("seqin->Ftquery Filebuff %x\n",
< 		       seqin->Ftquery->Input->Filebuff); */
< 		}
< 		ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
< 		/* ajDebug("EMBL FEAT saved line:\n%S", seqReadLine); */
< 	    }
---
>             /* maybe better remove . from this, and trim from end */
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 ajStrTokenAssignC(&seqHandle2, seqToken, "()");
>                 itaxtype=1;
12187,12188c13507,13548
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>                 while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>                 {
>                     ajStrTrimWhite(&seqToken2);
>                     seqTaxSave(thys, seqToken2, itaxtype);
>                     itaxtype = 3;
>                 }
> 
>                 ajStrTokenReset(seqHandle2);
>             }
>         }
> 
>         if(lineprefix == SWISS_OC)
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'OC' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 seqTaxSave(thys, seqToken, 0);
>             }
>         }
> 
>         if(tryfeat && lineprefix == SWISS_FT)
>         {
>             if(!dofeat)
>             {
>                 dofeat = ajTrue;
>                 ajFeattabinDel(&seqin->Ftquery);
>                 seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtEmbl,
>                                                        thys->Name, "N");
>                 /* ajDebug("seqin->Ftquery Filebuff %x\n",
>                    seqin->Ftquery->Input->Filebuff); */
> 
>             }
> 
>             ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
>             /* ajDebug("EMBL FEAT saved line:\n%S", seqReadLine); */
>         }
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
12191,12192c13551,13552
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixSwiss(seqReadLine);
12194c13554
<     while(ok && !ajStrPrefixC(seqReadLine, "//"))
---
>     while(ok && lineprefix != SWISS_END)
12196,12199c13556,13558
< 	seqAppend(&thys->Seq, seqReadLine);
< 	seqin->Input->Records++;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                  seqin->Input->Text, &thys->TextPtr);
---
>         seqAppend(&thys->Seq, seqReadLine);
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
12206c13565
<     while(ok && !ajStrPrefixC(seqReadLine, "ID   "))
---
>     while(ok && lineprefix != SWISS_ID)
12208,12210c13567,13568
< 	seqin->Input->Records++;
< 	ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				&thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         lineprefix = seqPrefixSwiss(seqReadLine);
12214,12215c13572
< 	ajFilebuffClearStore(buff, 1,
< 			     seqReadLine, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreClear(seqin->Input, 1, seqReadLine, &thys->TextPtr);
12217c13574
< 	ajFilebuffClear(buff, 0);
---
>         ajFilebuffClear(buff, 0);
12221,12225c13578,13582
< 	/* ajDebug("EMBL FEAT TabIn %x\n", seqin->Ftquery); */
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>         /* ajDebug("EMBL FEAT TabIn %x\n", seqin->Ftquery); */
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         /* ajFeattableTrace(thys->Fttable); */
>         ajFeattabinClear(seqin->Ftquery);
12230c13587
< 	ilen = ajStrGetLen(thys->Seq);
---
>         ilen = ajStrGetLen(thys->Seq);
12237c13594
< 	ajStrTokenAssignC(&handle, accvalstr, " ");
---
>         ajStrTokenAssignC(&seqHandle, accvalstr, " ");
12239,12240c13596,13597
< 	for(i=0;i<ilen;i++)
< 	{
---
>         for(i=0;i<ilen;i++)
>         {
12242,12267c13599,13624
< 	    if(!ajStrTokenNextParse(&handle, &token))
< 	    {
< 		ajWarn("Missing accuracy for base %d in experiment format\n",
< 		       i+1);
< 		break;
< 	    }
< 
< 	    ajStrTokenAssignC(&handle2, token, ",");
< 
< 	    while(ajStrTokenNextParse(&handle2, &token2))
< 	    {
< 		if(ajStrToInt(token2, &ja))
< 		{
< 		    if(ja > thys->Accuracy[i])
< 			thys->Accuracy[i] = (float) ja;
< 		}
< 		else
< 		{
< 		    ajWarn("Bad accuracy '%S' for base %d "
< 			   "in experiment format\n",
< 			   token, i+1);
< 		    break;
< 		}
< 	    }
< 	    ajDebug("Accval[%d] %3d '%S'\n", i+1, thys->Accuracy[i], token);
< 	}
---
>             if(!ajStrTokenNextParse(seqHandle, &seqToken))
>             {
>                 ajWarn("Missing accuracy for base %d in experiment format\n",
>                        i+1);
>                 break;
>             }
> 
>             ajStrTokenAssignC(&seqHandle2, seqToken, ",");
> 
>             while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>             {
>                 if(ajStrToInt(seqToken2, &ja))
>                 {
>                     if(ja > thys->Accuracy[i])
>                         thys->Accuracy[i] = (float) ja;
>                 }
>                 else
>                 {
>                     ajWarn("Bad accuracy '%S' for base %d "
>                            "in experiment format\n",
>                            seqToken, i+1);
>                     break;
>                 }
>             }
>             ajDebug("Accval[%u] %3f '%S'\n", i+1, thys->Accuracy[i], seqToken);
>         }
12270,12271c13627,13628
<     ajStrDel(&token);
<     ajStrDel(&token2);
---
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
12274,12275c13631,13632
<     ajStrTokenDel(&handle);
<     ajStrTokenDel(&handle2);
---
>     ajStrTokenReset(seqHandle);
>     ajStrTokenReset(seqHandle2);
12293a13651,13652
> **
> ** @release 1.0.0
12299,12300d13657
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
12304,12306c13661,13663
<     AjPStr tmpstr = NULL;
<     AjPStr tmpstr2 = NULL;
<     AjBool dofeat        = ajFalse;
---
>     AjPStr cmtstr = NULL;
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
12308c13665
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjPStr liststr;                     /* for lists, do not delete */
12314a13672,13674
>     ajuint itaxtype = 0;
>     SeqEPrefixGenbank lineprefix = GB_UNK;
>     SeqEPrefixGenbankMore moreprefix = GB_MORE_UNK;
12322c13682
< 	ajStrAssignC(&seqFtFmtGenbank, "genbank");
---
>         ajStrAssignC(&seqFtFmtGenbank, "genbank");
12325c13685,13687
< 	return ajFalse;
---
>         return ajFalse;
> 
>     lineprefix = seqPrefixGenbank(seqReadLine);
12335,12337c13697,13699
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
>         lineprefix = seqPrefixGenbank(seqReadLine);
12342c13704
<     if(ajStrPrefixC(seqReadLine, "WPCOMMENT"))
---
>     if(lineprefix == GB_WP)
12344,12345c13706,13707
< 	ok = ajBuffreadLine(buff, &seqReadLine);
< 	seqin->Input->Records++;
---
>         ok = ajBuffreadLine(buff, &seqReadLine);
>         lineprefix = seqPrefixGenbank(seqReadLine);
12347,12351c13709,13713
< 	while(ok && ajStrPrefixC(seqReadLine, " "))
< 	{
< 	    ok = ajBuffreadLine(buff, &seqReadLine);
< 	    seqin->Input->Records++;
< 	}
---
>         while(ok && lineprefix == GB_MORE)
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12356,12360c13718,13722
< 	while(ok && !ajStrPrefixC(seqReadLine, "LOCUS"))
< 	{
< 	    ok = ajBuffreadLine(buff, &seqReadLine);
< 	    seqin->Input->Records++;
< 	}
---
>         while(ok && lineprefix != GB_ID) /* LOCUS */
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12364c13726
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12366c13728
< 	return ajFalse;
---
>         return ajFalse;
12369c13731
<     if(!ajStrPrefixC(seqReadLine, "LOCUS"))
---
>     if(lineprefix != GB_ID)     /* LOCUS */
12371,12373c13733,13735
< 	ajDebug("failed - LOCUS not found - first line was\n%S\n",
< 		seqReadLine);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("failed - LOCUS not found - first line was\n%S\n",
>                 seqReadLine);
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12375c13737
< 	return ajFalse;
---
>         return ajFalse;
12377d13738
<     seqin->Input->Records++;
12381c13742
<     if(nfields == 9) 
---
>     if(nfields == 9)
12384c13745
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12388,12389c13749,13750
<     
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
---
> 
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
12392c13753
<     while(ajStrTokenNextParse(&handle, &token))
---
>     while(ajStrTokenNextParse(seqHandle, &seqToken))
12394,12437c13755,13798
< 	switch(++i)
< 	{
< 	case 1:
< 	    break;
< 	case 2:
< 	    seqSetName(thys, token);
< 	    break;
< 	case 3:
< 	    ajStrToUint(token, &seqlen);
< 	    break;
< 	case 4:
< 	    if(ajStrMatchC(token, "aa"))
<             {
<                 ajFilebuffSetBuffered(buff);
<                 ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
<                 ajStrDel(&token);
<                 ajStrTokenDel(&handle);
< 
<                 ajDebug("first line %d aa pass to refseqp '%S'\n",
<                         buff->Pos, seqReadLine);
<                 return seqReadRefseqp(thys,seqin);
<             }
< 	    if(!ajStrMatchC(token, "bp"))
< 		ajWarn("bad Genbank LOCUS line '%S'", seqReadLine);
< 	    break;
< 	case 5:
< 	    ajSeqmolSetGb(&thys->Molecule, token);
< 	    break;
< 	case 6:
< 	    if(ajStrMatchC(token, "circular"))
< 		thys->Circular = ajTrue;
< 	    break;
< 	case 7:
< 	    ajSeqdivSetGb(&thys->Division, token);
< 	    ajSeqclsSetGb(&thys->Class, token);
< 	    break;
< 	case 8:
< 	    if(!thys->Date)
< 		thys->Date = ajSeqdateNew();
< 	    ajSeqdateSetModifyS(thys->Date, token);
< 	    break;
< 	default:
< 	    break;
< 	}
---
>         switch(++i)
>         {
>             case 1:
>                 break;
>             case 2:
>                 seqSetName(thys, seqToken);
>                 break;
>             case 3:
>                 ajStrToUint(seqToken, &seqlen);
>                 break;
>             case 4:
>                 if(ajStrMatchC(seqToken, "aa"))
>                 {
>                     ajFilebuffSetBuffered(buff);
>                     ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>                     ajStrDelStatic(&seqToken);
>                     ajStrTokenReset(seqHandle);
> 
>                     ajDebug("first line %d aa pass to refseqp '%S'\n",
>                             buff->Pos, seqReadLine);
>                     return seqReadRefseqp(thys,seqin);
>                 }
>                 if(!ajStrMatchC(seqToken, "bp"))
>                     ajWarn("bad Genbank LOCUS line '%S'", seqReadLine);
>                 break;
>             case 5:
>                 ajSeqmolSetGb(&thys->Molecule, seqToken);
>                 break;
>             case 6:
>                 if(ajStrMatchC(seqToken, "circular"))
>                     thys->Circular = ajTrue;
>                 break;
>             case 7:
>                 ajSeqdivSetGb(&thys->Division, seqToken);
>                 ajSeqclsSetGb(&thys->Class, seqToken);
>                 break;
>             case 8:
>                 if(!thys->Date)
>                     thys->Date = ajSeqdateNew();
>                 ajSeqdateSetModifyS(thys->Date, seqToken);
>                 break;
>             default:
>                 break;
>         }
12441c13802,13805
< 	ajStrAssignC(&thys->TextPtr,ajStrGetPtr(seqReadLine));
---
>         ajStrAssignS(&thys->TextPtr, seqReadLine);
> 
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixGenbank(seqReadLine);
12443,12444c13807,13808
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     dofeat = ajFalse;
>     tryfeat = seqinUfoLocal(seqin);
12447,12517c13811,13886
< 	  !ajStrPrefixC(seqReadLine, "//") &&
< 	  !ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	  !ajStrPrefixC(seqReadLine, "BASE COUNT"))
<     {
< 	done = ajFalse;
< 	seqin->Input->Records++;
< 
< 	if(ajStrPrefixC(seqReadLine, "DEFINITION"))
< 	{
< 	    ajDebug("definition found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DEFINITION' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 	    ajStrAssignS(&thys->Desc, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 		ajStrTokenNextParseC(&handle, "\n\r", &token);
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text, &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "ACCESSION"))
< 	{
< 	    ajDebug("accession found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ACCESSION' */
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "VERSION"))
< 	{
< 	    ajDebug("seqversion found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'VERSION' */
< 	    ajStrTokenNextParse(&handle, &token);
< 	    seqSvSave(thys, token);
< 
< 	    if(ajStrTokenNextParseC(&handle, ": \n\r", &token)) /* GI: */
< 	    {
< 		ajStrTokenNextParse(&handle, &token);
< 		ajStrAssignS(&thys->Gi, token);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "SOURCE"))
< 	{
< 	    ajDebug("source found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'SOURCE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* source */
< 	    ajStrAssignS(&thys->Tax, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
---
>           lineprefix != GB_END &&
>           lineprefix != GB_ORI &&
>           lineprefix != GB_BASE)
>     {
>         done = ajFalse;
> 
>         if(lineprefix == GB_DEF)
>         {
>             ajDebug("definition found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'DEFINITION' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc); /* desc */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && lineprefix == GB_MORE)
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken);
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         else if(lineprefix == GB_AC)
>         {
>             ajDebug("accession found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'ACCESSION' */
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
> 
>         else if(lineprefix == GB_VER)
>         {
>             ajDebug("seqversion found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'VERSION' */
>             ajStrTokenNextParse(seqHandle, &seqToken);
>             seqSvSave(thys, seqToken);
> 
>             if(ajStrTokenStepC(seqHandle, ": \n\r")) /* GI: */
>             {
>                 ajStrTokenNextParse(seqHandle, &thys->Gi);
>             }
>         }
> 
>         else if(lineprefix == GB_SRC)
>         {
>             ajDebug("source found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'SOURCE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* source */
>             ajStrTokenAssignC(&seqHandle2, seqToken, "()");
>             itaxtype=1;
> 
>             while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>             {
>                 ajStrTrimWhite(&seqToken2);
>                 seqTaxSave(thys, seqToken2, itaxtype);
>                 itaxtype = 3;
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && lineprefix == GB_MORE)
>             {
>                 done = ajFalse;
12519,12557d13887
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					 seqin->Input->Text, &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "FEATURES"))
< 	{
< 	    if(seqinUfoLocal(seqin))
< 	    {
< 		ajDebug("features found\n");
< 
< 		if(!dofeat)
< 		{
< 		    dofeat = ajTrue;
< 		    ajFeattabinDel(&seqin->Ftquery);
< 		    seqin->Ftquery = ajFeattabinNewSS(seqFtFmtGenbank,
< 						      thys->Name, "N");
< 		    ajDebug("seqin->Ftquery Filebuff %x\n",
< 			    seqin->Ftquery->Input->Filebuff);
< 		    /* ajDebug("GENBANK FEAT first line:\n%S", seqReadLine); */
< 		}
< 
< 		ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		done = ajTrue;
< 
< 		while(ok && ajStrPrefixC(seqReadLine, " "))
< 		{
< 		    seqin->Input->Records++;
< 		    ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
<                                     seqReadLine);
< 		    /* ajDebug("GENBANK FEAT saved line:\n%S", seqReadLine); */
< 		    ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                              seqin->Input->Text,
<                                              &thys->TextPtr);
< 		}
< 	    }
< 	}
12559,12560c13889,13963
< 	else if(ajStrPrefixC(seqReadLine, "REFERENCE"))
< 	{
---
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
> 
>                 if(moreprefix == GB_MORE_ORG)
>                 {
>                     ajDebug("organism found\n");
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenNextParse(seqHandle, &seqToken); /* 'ORGANISM' */
> 
>                     while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                     {
>                         ajStrTrimWhite(&seqToken);
>                         seqTaxSave(thys, seqToken, 1);
>                     }
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>                     moreprefix = seqPrefixGenbankMore(seqReadLine);
>                     done = ajTrue;
> 
>                     while(ok && moreprefix == GB_MORE_MORE)
>                     {
>                         ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                         while(ajStrTokenNextParseC(seqHandle, ".;\n\r",
>                                                    &seqToken))
>                         {
>                             ajStrTrimWhite(&seqToken);
>                             seqTaxSave(thys, seqToken, 0);
>                         }
> 
>                         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                         moreprefix = seqPrefixGenbankMore(seqReadLine);
>                     }
>                 }
> 
>                 if(!done)
>                 {
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 }
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         else if(tryfeat && lineprefix == GB_FEAT)
>         {
>             ajDebug("features found\n");
> 
>             if(!dofeat)
>             {
>                 dofeat = ajTrue;
>                 ajFeattabinDel(&seqin->Ftquery);
>                 seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtGenbank,
>                                                        thys->Name, "N");
>                 ajDebug("seqin->Ftquery Filebuff %x\n",
>                         seqin->Ftquery->Input->Filebuff);
>                 /* ajDebug("GENBANK FEAT first line:\n%S", seqReadLine); */
>             }
> 
>             ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && lineprefix == GB_MORE)
>             {
>                 ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
>                                 seqReadLine);
>                 /* ajDebug("GENBANK FEAT saved line:\n%S", seqReadLine); */
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         else if(lineprefix == GB_REF)
>         {
12562,12572c13965,13975
< 	    seqref = ajSeqrefNew();
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'REFERENCE' */
< 	    ajStrTokenNextParse(&handle, &token); /* number */
< 	    ajStrToUint(token, &refnum);
< 	    ajSeqrefSetnumNumber(seqref, refnum);
< 	    ajStrAssignClear(&tmpstr2);
< 
< 	    while (ajStrTokenNextParse(&handle, &token))
< 	    {
< 		if(ajStrMatchC(token, "(bases"))
---
>             seqref = ajSeqrefNew();
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'REFERENCE' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* number */
>             ajStrToUint(seqToken, &refnum);
>             ajSeqrefSetnumNumber(seqref, refnum);
>             ajStrAssignClear(&seqToken2);
> 
>             while (ajStrTokenNextParse(seqHandle, &seqToken))
>             {
>                 if(ajStrMatchC(seqToken, "(bases"))
12575c13978
< 		if(ajStrMatchC(token, "to"))
---
>                 if(ajStrMatchC(seqToken, "(residues"))
12578,12579c13981,14074
< 		if(!ajStrGetLen(tmpstr2))
< 		    ajStrAssignS(&tmpstr2, token);
---
>                 if(ajStrMatchC(seqToken, "to"))
>                     continue;
> 
>                 if(!ajStrGetLen(seqToken2))
>                     ajStrAssignS(&seqToken2, seqToken);
> 
>                 if(ajStrSuffixC(seqToken, ")"))
>                 {
>                     ajStrTrimEndC(&seqToken, ")");
>                     ajStrAppendK(&seqToken2, '-');
>                     ajStrAppendS(&seqToken2, seqToken);
>                 }
>             }
> 
>             ajSeqrefSetPosition(seqref, seqToken2);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             moreprefix = seqPrefixGenbankMore(seqReadLine);
>             done = ajTrue;
> 
>             ajSeqrefStandard(seqref);
>             ajSeqAddRef(thys, seqref);
> 
>             if(ok && moreprefix == GB_MORE_AUT)
>             {
>                 ajDebug("authors found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'AUTHORS' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken2); /* authors */
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
> 
>                 while(ok && moreprefix == GB_MORE_MORE)
>                 {
>                     ajStrAssignS(&seqToken, seqReadLine);
>                     ajStrTrimWhite(&seqToken);
>                     if(ajStrSuffixC(seqToken2, ".,") ||
>                        ajStrPrefixC(seqToken, "and "))
>                         ajStrAppendC(&seqToken2, " ");
>                     ajStrAppendS(&seqToken2, seqToken);
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     moreprefix = seqPrefixGenbankMore(seqReadLine);
>                 }
> 
>                 /* append here - genbank splits author names across lines */
>                 ajSeqrefAppendAuthors(seqref, seqToken2);
>             }
> 
>             if(ok && moreprefix == GB_MORE_TIT)
>             {
>                 ajDebug("title found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'TITLE' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* title */
> 
>                 ajSeqrefAppendTitle(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
> 
>                 while(ok && moreprefix == GB_MORE_MORE)
>                 {
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenStepC(seqHandle, "\n\r"); /* title */
>                     ajSeqrefAppendTitle(seqref, seqToken);
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     moreprefix = seqPrefixGenbankMore(seqReadLine);
>                 }
>             }
> 
>             if(ok && moreprefix == GB_MORE_JNL)
>             {
>                 ajDebug("journal location found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'JOURNAL' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* location */
> 
>                 ajSeqrefAppendLocation(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
>             }
12581,12606c14076,14129
< 		if(ajStrSuffixC(token, ")"))
< 		{
< 		    ajStrTrimEndC(&token, ")");
< 		    ajStrAppendK(&tmpstr2, '-');
< 		    ajStrAppendS(&tmpstr2, token);
< 		}
< 	    }
< 
< 	    ajSeqrefSetPosition(seqref, tmpstr2);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 		seqin->Input->Records++;
< 	    }
< 
< 	    ajSeqrefStandard(seqref);
< 	    ajSeqAddRef(thys, seqref);
< 	    seqref = NULL;
< 	}
---
>             while(ok && moreprefix == GB_MORE_MORE)
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
>             }
> 
>             seqref = NULL;
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
> 
>         else if(ok && lineprefix == GB_CC)
>         {
>             ajDebug("comment found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'COMMENT' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
> 
>             if(ajStrGetLen(cmtstr))
>                 ajStrAppendC(&cmtstr, "\n");
>             ajStrAppendS(&cmtstr, seqToken);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             moreprefix = seqPrefixGenbankMore(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && moreprefix == GB_MORE_MORE)
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* comment */
> 
>                 if(ajStrGetLen(seqToken))
>                 {
>                     if(ajStrGetLen(cmtstr))
>                         ajStrAppendC(&cmtstr, "\n");
>                     ajStrAppendS(&cmtstr, seqToken);
>                 }
>                 else
>                 {
>                     ajSeqAddCmt(thys, cmtstr);
>                     cmtstr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 moreprefix = seqPrefixGenbankMore(seqReadLine);
>             }
> 
>             if(ajStrGetLen(cmtstr))
>                 ajSeqAddCmt(thys, cmtstr);
> 
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             cmtstr = NULL;
>         }
12608,12609c14131,14132
< 	else if(ajStrPrefixC(seqReadLine, "KEYWORDS"))
< 	{
---
>         else if(lineprefix == GB_KEY)
>         {
12611,12612c14134,14143
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KEYWORDS' */
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'KEYWORDS' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 liststr = ajStrNewS(seqToken);
>                 ajStrTrimWhite(&liststr);
>                 ajSeqAddKey(thys, liststr);
>                 liststr = NULL;
>             }
12614,12680c14145,14170
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    liststr = ajStrNewS(token);
< 		    ajStrTrimWhite(&liststr);
< 		    ajSeqAddKey(thys, liststr);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
< 	{
< 	    ajDebug("organism found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ORGANISM' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, "    "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    ajStrAssignS(&tmpstr, token);
< 		    ajStrTrimWhite(&tmpstr);
< 		    seqTaxSave(thys, tmpstr, 0);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	if(!done)
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && lineprefix == GB_MORE)
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                 {
>                     liststr = ajStrNewS(seqToken);
>                     ajStrTrimWhite(&liststr);
>                     ajSeqAddKey(thys, liststr);
>                     liststr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         if(!done)
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12685,12689c14175,14179
< 	ajDebug("GENBANK FEAT TabIn %x\n", seqin->Ftquery);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>         ajDebug("GENBANK FEAT TabIn %x\n", seqin->Ftquery);
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         /* ajFeattableTrace(thys->Fttable); */
>         ajFeattabinClear(seqin->Ftquery);
12694,12695c14184,14185
< 	/* we have a sequence to use */
< 	ajDebug("Got an Inseq sequence\n");
---
>         /* we have a sequence to use */
>         ajDebug("Got an Inseq sequence\n");
12697,12708c14187,14202
< 	if(ajStrMatchC(qry->Method,"gcg"))
< 	    while(ok && !ajStrPrefixC(seqReadLine,"ORIGIN"))
< 		ok = ajBuffreadLineStore(buff,&seqReadLine, seqin->Input->Text,
< 					&thys->TextPtr);
< 
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
< 
< 	if(seqin->Input->Text)
< 	{
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
< 	    ajFmtPrintAppS(&thys->TextPtr, "//\n");
< 	}
---
>         if(ajStrMatchC(qry->Method,"gcg"))
>         {
>             while(ok && lineprefix != GB_ORI)
>             {
>                 ok = ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
> 
>         if(seqin->Input->Text)
>         {
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
>             ajFmtPrintAppS(&thys->TextPtr, "//\n");
>         }
12712,12713c14206,14207
< 	/* read the sequence and terminator */
< 	ajDebug("sequence start at '%S'\n", seqReadLine);
---
>         /* read the sequence and terminator */
>         ajDebug("sequence start at '%S'\n", seqReadLine);
12715,12718c14209,14212
< 	while(ok &&
<               !ajStrPrefixC(seqReadLine,"//") &&
< 	      !ajStrPrefixC(seqReadLine,"ORIGIN") &&
<               !ajStrPrefixC(seqReadLine,"BASE COUNT"))
---
>         while(ok &&
>               lineprefix != GB_END &&
>               lineprefix != GB_ORI &&
>               lineprefix != GB_BASE)
12720,12721c14214,14216
<             ok = ajBuffreadLineStore(buff,&seqReadLine,
<                                      seqin->Input->Text, &thys->TextPtr);
---
>             ok = ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
> 
12726,12741c14221,14237
<         if(ok && !ajStrPrefixC(seqReadLine,"//"))
<             ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                      seqin->Input->Text, &thys->TextPtr);
< 
< 	ajStrSetRes(&thys->Seq, seqlen+1);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    if(!ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	       !ajStrPrefixC(seqReadLine,"BASE COUNT"))
< 		seqAppend(&thys->Seq, seqReadLine);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    seqin->Input->Records++;
< 	}
---
>         if(ok && lineprefix != GB_END)
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
> 
>         ajStrSetRes(&thys->Seq, seqlen+1);
> 
>         while(ok && lineprefix != GB_END)
>         {
>             if(lineprefix != GB_ORI &&
>                lineprefix != GB_BASE)
>                 seqAppend(&thys->Seq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12745,12748c14241,14247
< 	while(ok && !ajStrPrefixC(seqReadLine,"//"))
< 	    ok = ajBuffreadLineStore(buff,&seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
< 
---
>     {
>         while(ok && lineprefix != GB_END)
>         {
>             ok = ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
>     }
12759c14258
<     
---
> 
12765,12768c14264,14267
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
<     ajStrDel(&tmpstr);
<     ajStrDel(&tmpstr2);
---
>     ajStrTokenReset(seqHandle);
>     ajStrTokenReset(seqHandle2);
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
12776c14275
< /* @funcstatic seqReadRefseq *************************************************
---
> /* @funcstatic seqReadRefseq **************************************************
12783a14283,14284
> **
> ** @release 6.1.0
12802a14304,14305
> **
> ** @release 6.1.0
12808,12809d14310
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
12813,12815c14314,14318
<     AjPStr tmpstr = NULL;
<     AjPStr tmpstr2 = NULL;
<     AjBool dofeat        = ajFalse;
---
>     AjPStr cmtstr = NULL;
> /*
> //    AjBool dofeat  = ajFalse;
> //    AjBool tryfeat = ajFalse;
> */
12817c14320
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjPStr liststr;                     /* for lists, do not delete */
12822a14326,14327
>     ajuint itaxtype = 0;
>     SeqEPrefixGenbank lineprefix = GB_UNK;
12830c14335
< 	return ajFalse;
---
>         return ajFalse;
12832c14337
<     seqin->Input->Records++;
---
>     lineprefix = seqPrefixGenbank(seqReadLine);
12840,12842c14345,14346
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
12844c14348
< 	seqin->Input->Records++;
---
>         lineprefix = seqPrefixGenbank(seqReadLine);
12849c14353
<     if(ajStrPrefixC(seqReadLine, "WPCOMMENT"))
---
>     if(lineprefix == GB_WP)
12851,12852c14355,14356
< 	ok = ajBuffreadLine(buff, &seqReadLine);
< 	seqin->Input->Records++;
---
>         ok = ajBuffreadLine(buff, &seqReadLine);
>         lineprefix = seqPrefixGenbank(seqReadLine);
12854,12858c14358,14362
< 	while(ok && ajStrPrefixC(seqReadLine, " "))
< 	{
< 	    ok = ajBuffreadLine(buff, &seqReadLine);
< 	    seqin->Input->Records++;
< 	}
---
>         while(ok && lineprefix == GB_MORE)
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12864,12868c14368,14372
< 	while(ok && !ajStrPrefixC(seqReadLine, "LOCUS"))
< 	{
< 	    ok = ajBuffreadLine(buff, &seqReadLine);
< 	    seqin->Input->Records++;
< 	}
---
>         while(ok && lineprefix != GB_ID) /* LOCUS */
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
12873c14377
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12875c14379
< 	return ajFalse;
---
>         return ajFalse;
12878c14382
<     if(!ajStrPrefixC(seqReadLine, "LOCUS"))
---
>     if(lineprefix != GB_ID)     /* LOCUS */
12880,12882c14384,14386
< 	ajDebug("failed - LOCUS not found - first line was\n%S\n",
< 		seqReadLine);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("failed - LOCUS not found - first line was\n%S\n",
>                 seqReadLine);
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12884c14388
< 	return ajFalse;
---
>         return ajFalse;
12889c14393
<     if(nfields == 8) 
---
>     if(nfields == 8)
12892c14396
<         ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
12896,12897c14400,14401
<     
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
---
> 
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
12900c14404
<     while(ajStrTokenNextParse(&handle, &token))
---
>     while(ajStrTokenNextParse(seqHandle, &seqToken))
12902,12929c14406,14433
< 	switch(++i)
< 	{
< 	case 1:
< 	    break;
< 	case 2:
< 	    seqSetName(thys, token);
< 	    break;
< 	case 3:
< 	    ajStrToUint(token, &seqlen);
< 	    break;
< 	case 4:
< 	    if(!ajStrMatchC(token, "aa"))
< 		ajWarn("bad Genpept LOCUS line '%S'", seqReadLine);
< 	    break;
< 	case 5:
< 	    break;
< 	case 6:
< 	    ajSeqdivSetGb(&thys->Division, token);
< 	    ajSeqclsSetGb(&thys->Class, token);
< 	    break;
< 	case 7:
< 	    if(!thys->Date)
< 		thys->Date = ajSeqdateNew();
< 	    ajSeqdateSetModifyS(thys->Date, token);
< 	    break;
< 	default:
< 	    break;
< 	}
---
>         switch(++i)
>         {
>             case 1:
>                 break;
>             case 2:
>                 seqSetName(thys, seqToken);
>                 break;
>             case 3:
>                 ajStrToUint(seqToken, &seqlen);
>                 break;
>             case 4:
>                 if(!ajStrMatchC(seqToken, "aa"))
>                     ajWarn("bad Genpept LOCUS line '%S'", seqReadLine);
>                 break;
>             case 5:
>                 break;
>             case 6:
>                 ajSeqdivSetGb(&thys->Division, seqToken);
>                 ajSeqclsSetGb(&thys->Class, seqToken);
>                 break;
>             case 7:
>                 if(!thys->Date)
>                     thys->Date = ajSeqdateNew();
>                 ajSeqdateSetModifyS(thys->Date, seqToken);
>                 break;
>             default:
>                 break;
>         }
12933c14437
< 	ajStrAssignC(&thys->TextPtr,ajStrGetPtr(seqReadLine));
---
>         ajStrAssignS(&thys->TextPtr, seqReadLine);
12935,12936c14439,14445
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     lineprefix = seqPrefixGenbank(seqReadLine);
> 
> /*
> //    dofeat = ajFalse;
> //    tryfeat = seqinUfoLocal(seqin);
> */
12939,12940c14448,14449
< 	  !ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	  !ajStrPrefixC(seqReadLine, "BASE COUNT"))
---
>           !ajStrPrefixC(seqReadLine, "ORIGIN") &&
>           !ajStrPrefixC(seqReadLine, "BASE COUNT"))
12942,12943c14451
< 	done = ajFalse;
< 	seqin->Input->Records++;
---
>         done = ajFalse;
12945,13009c14453,14522
< 	if(ajStrPrefixC(seqReadLine, "DEFINITION"))
< 	{
< 	    ajDebug("definition found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DEFINITION' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 	    ajStrAssignS(&thys->Desc, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 		ajStrTokenNextParseC(&handle, "\n\r", &token);
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "ACCESSION"))
< 	{
< 	    ajDebug("accession found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ACCESSION' */
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "VERSION"))
< 	{
< 	    ajDebug("seqversion found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'VERSION' */
< 	    ajStrTokenNextParse(&handle, &token);
< 	    seqSvSave(thys, token);
< 
< 	    if(ajStrTokenNextParseC(&handle, ": \n\r", &token)) /* GI: */
< 	    {
< 		ajStrTokenNextParse(&handle, &token);
< 		ajStrAssignS(&thys->Gi, token);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "SOURCE"))
< 	{
< 	    ajDebug("source found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'SOURCE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* source */
< 	    ajStrAssignS(&thys->Tax, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
---
>         if(ajStrPrefixC(seqReadLine, "DEFINITION"))
>         {
>             ajDebug("definition found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'DEFINITION' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc); /* desc */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken);
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "ACCESSION"))
>         {
>             ajDebug("accession found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'ACCESSION' */
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "VERSION"))
>         {
>             ajDebug("seqversion found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'VERSION' */
>             ajStrTokenNextParse(seqHandle, &seqToken);
>             seqSvSave(thys, seqToken);
> 
>             if(ajStrTokenStepC(seqHandle, ": \n\r")) /* GI: */
>             {
>                 ajStrTokenNextParse(seqHandle, &thys->Gi);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "SOURCE"))
>         {
>             ajDebug("source found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'SOURCE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* source */
>             ajStrTokenAssignC(&seqHandle2, seqToken, "()");
>             itaxtype=1;
> 
>             while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>             {
>                 ajStrTrimWhite(&seqToken2);
>                 seqTaxSave(thys, seqToken2, itaxtype);
>                 itaxtype = 3;
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 done = ajFalse;
13011,13015d14523
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
13017,13018c14525,14567
< 	else if(ajStrPrefixC(seqReadLine, "REFERENCE"))
< 	{
---
>                 if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
>                 {
>                     ajDebug("organism found\n");
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenStep(seqHandle); /* 'ORGANISM' */
> 
>                     while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                     {
>                         ajStrTrimWhite(&seqToken);
>                         seqTaxSave(thys, seqToken, 1);
>                     }
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     lineprefix = seqPrefixGenbank(seqReadLine);
>                     done = ajTrue;
> 
>                     while(ok && ajStrPrefixC(seqReadLine, "    "))
>                     {
>                         ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                         while(ajStrTokenNextParseC(seqHandle, ".;\n\r",
>                                                    &seqToken))
>                         {
>                             ajStrAssignS(&seqToken2, seqToken);
>                             ajStrTrimWhite(&seqToken2);
>                             seqTaxSave(thys, seqToken2, 0);
>                         }
> 
>                         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                         lineprefix = seqPrefixGenbank(seqReadLine);
>                     }
>                 }
> 
>                 if(!done)
>                 {
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     lineprefix = seqPrefixGenbank(seqReadLine);
>                 }
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "REFERENCE"))
>         {
13020,13030c14569,14579
< 	    seqref = ajSeqrefNew();
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'REFERENCE' */
< 	    ajStrTokenNextParse(&handle, &token); /* number */
< 	    ajStrToUint(token, &refnum);
< 	    ajSeqrefSetnumNumber(seqref, refnum);
< 	    ajStrAssignClear(&tmpstr2);
< 
< 	    while (ajStrTokenNextParse(&handle, &token))
< 	    {
< 		if(ajStrMatchC(token, "(residues"))
---
>             seqref = ajSeqrefNew();
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'REFERENCE' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* number */
>             ajStrToUint(seqToken, &refnum);
>             ajSeqrefSetnumNumber(seqref, refnum);
>             ajStrAssignClear(&seqToken2);
> 
>             while (ajStrTokenNextParse(seqHandle, &seqToken))
>             {
>                 if(ajStrMatchC(seqToken, "(bases"))
13033c14582
< 		if(ajStrMatchC(token, "to"))
---
>                 if(ajStrMatchC(seqToken, "(residues"))
13036,13037c14585,14586
< 		if(!ajStrGetLen(tmpstr2))
< 		    ajStrAssignS(&tmpstr2, token);
---
>                 if(ajStrMatchC(seqToken, "to"))
>                     continue;
13039,13064c14588,14640
< 		if(ajStrSuffixC(token, ")"))
< 		{
< 		    ajStrTrimEndC(&token, ")");
< 		    ajStrAppendK(&tmpstr2, '-');
< 		    ajStrAppendS(&tmpstr2, token);
< 		}
< 	    }
< 
< 	    ajSeqrefSetPosition(seqref, tmpstr2);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 		seqin->Input->Records++;
< 	    }
< 
< 	    ajSeqrefStandard(seqref);
< 	    ajSeqAddRef(thys, seqref);
< 	    seqref = NULL;
< 	}
---
>                 if(!ajStrGetLen(seqToken2))
>                     ajStrAssignS(&seqToken2, seqToken);
> 
>                 if(ajStrSuffixC(seqToken, ")"))
>                 {
>                     ajStrTrimEndC(&seqToken, ")");
>                     ajStrAppendK(&seqToken2, '-');
>                     ajStrAppendS(&seqToken2, seqToken);
>                 }
>             }
> 
>             ajSeqrefSetPosition(seqref, seqToken2);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine,&thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             ajSeqrefStandard(seqref);
>             ajSeqAddRef(thys, seqref);
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  AUTHORS"))
>             {
>                 ajDebug("authors found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'AUTHORS' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken2); /* authors */
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
> 
>                 while(ok && ajStrPrefixC(seqReadLine, "          "))
>                 {
>                     ajStrAssignS(&seqToken, seqReadLine);
>                     ajStrTrimWhite(&seqToken);
>                     if(ajStrSuffixC(seqToken2, ".,") ||
>                        ajStrPrefixC(seqToken2, "and "))
>                         ajStrAppendC(&seqToken2, " ");
>                     ajStrAppendS(&seqToken2, seqToken);
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     lineprefix = seqPrefixGenbank(seqReadLine);
>                 }
> 
>                 /* append here - genbank splits author names across lines */
>                 ajSeqrefAppendAuthors(seqref, seqToken2);
>             }
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  TITLE"))
>             {
>                 ajDebug("title found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
13066,13067c14642,14734
< 	else if(ajStrPrefixC(seqReadLine, "KEYWORDS"))
< 	{
---
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'TITLE' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* title */
> 
>                 ajSeqrefAppendTitle(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
> 
>                 while(ok && ajStrPrefixC(seqReadLine, "          "))
>                 {
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenNextParseC(seqHandle, "\n\r",
>                                          &seqToken); /* title */
>                     ajSeqrefAppendTitle(seqref, seqToken);
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     lineprefix = seqPrefixGenbank(seqReadLine);
>                 }
>             }
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  JOURNAL"))
>             {
>                 ajDebug("journal location found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'JOURNAL' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* location */
> 
>                 ajSeqrefAppendLocation(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
> 
>             while(ok && ajStrPrefixC(seqReadLine, "  "))
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
> 
>             seqref = NULL;
>         }
> 
>         else if(ok && ajStrPrefixC(seqReadLine, "COMMENT"))
>         {
>             ajDebug("comment found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'COMMENT' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
> 
>             if(ajStrGetLen(cmtstr))
>                 ajStrAppendC(&cmtstr, "\n");
>             ajStrAppendS(&cmtstr, seqToken);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, "          "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* comment */
> 
>                 if(ajStrGetLen(seqToken))
>                 {
>                     if(ajStrGetLen(cmtstr))
>                         ajStrAppendC(&cmtstr, "\n");
>                     ajStrAppendS(&cmtstr, seqToken);
>                 }
>                 else
>                 {
>                     ajSeqAddCmt(thys, cmtstr);
>                     cmtstr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
> 
>             if(ajStrGetLen(cmtstr))
>                 ajSeqAddCmt(thys, cmtstr);
> 
>             cmtstr = NULL;
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "KEYWORDS"))
>         {
13069,13070c14736,14737
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KEYWORDS' */
---
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'KEYWORDS' */
13072,13139c14739,14745
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    liststr = ajStrNewS(token);
< 		    ajStrTrimWhite(&liststr);
< 		    ajSeqAddKey(thys, liststr);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
< 	{
< 	    ajDebug("organism found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ORGANISM' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
<                                      &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, "    "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    ajStrAssignS(&tmpstr, token);
< 		    ajStrTrimWhite(&tmpstr);
< 		    seqTaxSave(thys, tmpstr, 0);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	if(!done)
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
<     }
---
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 liststr = ajStrNewS(seqToken);
>                 ajStrTrimWhite(&liststr);
>                 ajSeqAddKey(thys, liststr);
>                 liststr = NULL;
>             }
13141,13147c14747,14804
<     if(dofeat)
<     {
< 	ajDebug("GENPEPT FEAT TabIn %x\n", seqin->Ftquery);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                 {
>                     liststr = ajStrNewS(seqToken);
>                     ajStrTrimWhite(&liststr);
>                     ajSeqAddKey(thys, liststr);
>                     liststr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
>         {
>             ajDebug("organism found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'ORGANISM' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 seqTaxSave(thys, seqToken, 0);
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, "    "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                 {
>                     ajStrTrimWhite(&seqToken);
>                     seqTaxSave(thys, seqToken, 0);
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 lineprefix = seqPrefixGenbank(seqReadLine);
>             }
>         }
> 
>         if(!done)
>         {
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             lineprefix = seqPrefixGenbank(seqReadLine);
>         }
>         
13148a14806,14815
> /*
> //    if(dofeat)
> //    {
> //        ajDebug("GENPEPT FEAT TabIn %x\n", seqin->Ftquery);
> //        ajFeattableDel(&thys->Fttable);
> //        thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
> //        /# ajFeattableTrace(thys->Fttable); #/
> //        ajFeattabinClear(seqin->Ftquery);
> //    }
> */
13152,13153c14819,14824
< 	/* we have a sequence to use */
< 	ajDebug("Got an Inseq sequence\n");
---
>         /* we have a sequence to use */
>         ajDebug("Got an Inseq sequence\n");
> 
>         if(ajStrMatchC(qry->Method,"gcg"))
>             while(ok && !ajStrPrefixC(seqReadLine,"ORIGIN"))
>                 ok = ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr);
13155,13166c14826,14832
< 	if(ajStrMatchC(qry->Method,"gcg"))
< 	    while(ok && !ajStrPrefixC(seqReadLine,"ORIGIN"))
< 		ok = ajBuffreadLineStore(buff,&seqReadLine, seqin->Input->Text,
< 					&thys->TextPtr);
< 
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
< 
< 	if(seqin->Input->Text)
< 	{
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
< 	    ajFmtPrintAppS(&thys->TextPtr, "//\n");
< 	}
---
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
> 
>         if(seqin->Input->Text)
>         {
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
>             ajFmtPrintAppS(&thys->TextPtr, "//\n");
>         }
13170,13171c14836,14842
< 	/* read the sequence and terminator */
< 	ajDebug("sequence start at '%S'\n", seqReadLine);
---
>         /* read the sequence and terminator */
>         ajDebug("sequence start at '%S'\n", seqReadLine);
> 
>         while(!ajStrPrefixC(seqReadLine,"ORIGIN") &&
>               !ajStrPrefixC(seqReadLine,"BASE COUNT"))
>             if(!ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr))
>                 break;
13173,13191c14844,14853
< 	while(!ajStrPrefixC(seqReadLine,"ORIGIN") &&
< 	      !ajStrPrefixC(seqReadLine,"BASE COUNT"))
< 	    if(!ajBuffreadLineStore(buff,&seqReadLine,
< 				   seqin->Input->Text, &thys->TextPtr))
< 		break;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	ajStrSetRes(&thys->Seq, seqlen+1);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    if(!ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	       !ajStrPrefixC(seqReadLine,"BASE COUNT"))
< 		seqAppend(&thys->Seq, seqReadLine);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    seqin->Input->Records++;
< 	}
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ajStrSetRes(&thys->Seq, seqlen+1);
> 
>         while(ok && !ajStrPrefixC(seqReadLine, "//"))
>         {
>             if(!ajStrPrefixC(seqReadLine, "ORIGIN") &&
>                !ajStrPrefixC(seqReadLine,"BASE COUNT"))
>                 seqAppend(&thys->Seq, seqReadLine);
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
13195,13197c14857,14858
< 	while(ok && !ajStrPrefixC(seqReadLine,"//"))
< 	    ok = ajBuffreadLineStore(buff,&seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
---
>         while(ok && !ajStrPrefixC(seqReadLine,"//"))
>             ok = ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr);
13205,13208c14866,14869
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
<     ajStrDel(&tmpstr);
<     ajStrDel(&tmpstr2);
---
>     ajStrTokenReset(seqHandle);
>     ajStrTokenReset(seqHandle2);
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
13223a14885,14886
> **
> ** @release 6.1.0
13229,13230d14891
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
13234,13236c14895,14897
<     AjPStr tmpstr = NULL;
<     AjPStr tmpstr2 = NULL;
<     AjBool dofeat        = ajFalse;
---
>     AjPStr cmtstr = NULL;
>     AjBool dofeat  = ajFalse;
>     AjBool tryfeat = ajFalse;
13238c14899
<     AjPStr liststr;			/* for lists, do not delete */
---
>     AjPStr liststr;                     /* for lists, do not delete */
13242a14904
>     ajuint itaxtype = 0;
13250c14912
< 	ajStrAssignC(&seqFtFmtRefseqp, "refseqp");
---
>         ajStrAssignC(&seqFtFmtRefseqp, "refseqp");
13253c14915
< 	return ajFalse;
---
>         return ajFalse;
13257,13258d14918
<     seqin->Input->Records++;
< 
13265,13269c14925,14926
< 	if(!ajBuffreadLineStore(buff, &seqReadLine,
< 			       seqin->Input->Text, &thys->TextPtr))
< 	    return ajFalse;
< 
< 	seqin->Input->Records++;
---
>         if(!ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr))
>             return ajFalse;
13276,13277c14933
< 	ok = ajBuffreadLine(buff, &seqReadLine);
< 	seqin->Input->Records++;
---
>         ok = ajBuffreadLine(buff, &seqReadLine);
13279,13283c14935,14938
< 	while(ok && ajStrPrefixC(seqReadLine, " "))
< 	{
< 	    ok = ajBuffreadLine(buff, &seqReadLine);
< 	    seqin->Input->Records++;
< 	}
---
>         while(ok && ajStrPrefixC(seqReadLine, " "))
>         {
>             ok = ajBuffreadLine(buff, &seqReadLine);
>         }
13288c14943
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
13290c14945
< 	return ajFalse;
---
>         return ajFalse;
13295,13298c14950,14953
< 	ajDebug("failed - LOCUS not found - first line was\n%S\n",
< 		seqReadLine);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajDebug("failed - LOCUS not found - first line was\n%S\n",
>                 seqReadLine);
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
13302c14957
< 	ajStrAssignC(&thys->TextPtr,ajStrGetPtr(seqReadLine));
---
>         ajStrAssignS(&thys->TextPtr,seqReadLine);
13304c14959
<     ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
---
>     ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
13307c14962
<     while(ajStrTokenNextParse(&handle, &token))
---
>     while(ajStrTokenNextParse(seqHandle, &seqToken))
13309,13310c14964,14965
< 	switch(++i)
< 	{
---
>         switch(++i)
>         {
13314c14969
<                 seqSetName(thys, token);
---
>                 seqSetName(thys, seqToken);
13317c14972
<                 ajStrToUint(token, &seqlen);
---
>                 ajStrToUint(seqToken, &seqlen);
13320c14975
<                 if(!ajStrMatchC(token, "aa"))
---
>                 if(!ajStrMatchC(seqToken, "aa"))
13323,13325c14978
<             case 5:
<                 ajSeqdivSetGb(&thys->Division, token);
<                 ajSeqclsSetGb(&thys->Class, token);
---
>             case 5:             /* linear etc. */
13327a14981,14984
>                 ajSeqdivSetGb(&thys->Division, seqToken);
>                 ajSeqclsSetGb(&thys->Class, seqToken);
>                 break;
>             case 7:
13330c14987
<                 ajSeqdateSetModifyS(thys->Date, token);
---
>                 ajSeqdateSetModifyS(thys->Date, seqToken);
13334c14991
< 	}
---
>         }
13337,13338c14994,14997
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>     dofeat = ajFalse;
>     tryfeat = seqinUfoLocal(seqin);
13341,13342c15000,15001
< 	  !ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	  !ajStrPrefixC(seqReadLine, "BASE COUNT"))
---
>           !ajStrPrefixC(seqReadLine, "ORIGIN") &&
>           !ajStrPrefixC(seqReadLine, "BASE COUNT"))
13344,13345c15003,15033
< 	done = ajFalse;
< 	seqin->Input->Records++;
---
>         done = ajFalse;
> 
>         if(ajStrPrefixC(seqReadLine, "DEFINITION"))
>         {
>             ajDebug("definition found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'DEFINITION' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &thys->Desc); /* desc */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken);
>                 ajStrAppendC(&thys->Desc, " ");
>                 ajStrAppendS(&thys->Desc, seqToken);
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "ACCESSION"))
>         {
>             ajDebug("accession found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ;\n\r");
>             ajStrTokenStep(seqHandle); /* 'ACCESSION' */
> 
>             while(ajStrTokenNextParse(seqHandle, &seqToken))
>                 seqAccSave(thys, seqToken);
>         }
13347,13411c15035,15071
< 	if(ajStrPrefixC(seqReadLine, "DEFINITION"))
< 	{
< 	    ajDebug("definition found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'DEFINITION' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* desc */
< 	    ajStrAssignS(&thys->Desc, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 		ajStrTokenNextParseC(&handle, "\n\r", &token);
< 		ajStrAppendC(&thys->Desc, " ");
< 		ajStrAppendS(&thys->Desc, token);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "ACCESSION"))
< 	{
< 	    ajDebug("accession found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ;\n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ACCESSION' */
< 
< 	    while(ajStrTokenNextParse(&handle, &token))
< 		seqAccSave(thys, token);
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "VERSION"))
< 	{
< 	    ajDebug("seqversion found\n");
< 
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'VERSION' */
< 	    ajStrTokenNextParse(&handle, &token);
< 	    seqSvSave(thys, token);
< 
< 	    if(ajStrTokenNextParseC(&handle, ": \n\r", &token)) /* GI: */
< 	    {
< 		ajStrTokenNextParse(&handle, &token);
< 		ajStrAssignS(&thys->Gi, token);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "SOURCE"))
< 	{
< 	    ajDebug("source found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'SOURCE' */
< 	    ajStrTokenNextParseC(&handle, "\n\r", &token); /* source */
< 	    ajStrAssignS(&thys->Tax, token);
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
---
>         else if(ajStrPrefixC(seqReadLine, "VERSION"))
>         {
>             ajDebug("seqversion found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'VERSION' */
>             ajStrTokenNextParse(seqHandle, &seqToken);
>             seqSvSave(thys, seqToken);
> 
>             if(ajStrTokenStepC(seqHandle, ": \n\r")) /* GI: */
>             {
>                 ajStrTokenNextParse(seqHandle, &thys->Gi);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "SOURCE"))
>         {
>             ajDebug("source found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'SOURCE' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* source */
>             ajStrTokenAssignC(&seqHandle2, seqToken, "()");
>             itaxtype=1;
> 
>             while(ajStrTokenNextParse(seqHandle2, &seqToken2))
>             {
>                 ajStrTrimWhite(&seqToken2);
>                 seqTaxSave(thys, seqToken2, itaxtype);
>                 itaxtype = 3;
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 done = ajFalse;
13413,13467c15073,15151
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "FEATURES"))
< 	{
< 	    if(seqinUfoLocal(seqin))
< 	    {
< 		ajDebug("features found\n");
< 
< 		if(!dofeat)
< 		{
< 		    dofeat = ajTrue;
< 		    ajFeattabinDel(&seqin->Ftquery);
< 		    seqin->Ftquery = ajFeattabinNewSS(seqFtFmtRefseqp,
< 						      thys->Name, "N");
< 		    ajDebug("seqin->Ftquery Filebuff %x\n",
< 			    seqin->Ftquery->Input->Filebuff);
< 		    /* ajDebug("REFSEQP FEAT first line:\n%S", seqReadLine); */
< 		}
< 
< 		ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
< 					seqin->Input->Text, &thys->TextPtr);
< 		done = ajTrue;
< 
< 		while(ok && ajStrPrefixC(seqReadLine, " "))
< 		{
< 		    seqin->Input->Records++;
< 		    ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
<                                     seqReadLine);
< 		    /* ajDebug("REFSEQP FEAT saved line:\n%S", seqReadLine); */
< 		    ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                              seqin->Input->Text,
<                                              &thys->TextPtr);
< 		}
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "REFERENCE"))
< 	{
< 	    ajDebug("reference found\n");
< 	    seqref = ajSeqrefNew();
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \n\r");
< 	    ajStrTokenNextParse(&handle, &token); /* 'REFERENCE' */
< 	    ajStrTokenNextParse(&handle, &token); /* number */
< 	    ajStrToUint(token, &refnum);
< 	    ajSeqrefSetnumNumber(seqref, refnum);
< 	    ajStrAssignClear(&tmpstr2);
< 
< 	    while (ajStrTokenNextParse(&handle, &token))
< 	    {
< 		if(ajStrMatchC(token, "(residues"))
---
> 
>                 if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
>                 {
>                     ajDebug("organism found\n");
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenStep(seqHandle); /* 'ORGANISM' */
> 
>                     while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                     {
>                         ajStrTrimWhite(&seqToken);
>                         seqTaxSave(thys, seqToken, 1);
>                     }
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>                     done = ajTrue;
> 
>                     while(ok && ajStrPrefixC(seqReadLine, "    "))
>                     {
>                         ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                         while(ajStrTokenNextParseC(seqHandle, ".;\n\r",
>                                                    &seqToken))
>                         {
>                             ajStrTrimWhite(&seqToken);
>                             seqTaxSave(thys, seqToken, 0);
>                         }
> 
>                         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                     }
>                 }
> 
>                 if(!done)
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         else if(tryfeat && ajStrPrefixC(seqReadLine, "FEATURES"))
>         {
>             ajDebug("features found\n");
> 
>             if(!dofeat)
>             {
>                 dofeat = ajTrue;
>                 ajFeattabinDel(&seqin->Ftquery);
>                 seqin->Ftquery = ajFeattabinNewSeqinSS(seqin, seqFtFmtRefseqp,
>                                                        thys->Name, "N");
>                 ajDebug("seqin->Ftquery Filebuff %x\n",
>                         seqin->Ftquery->Input->Filebuff);
>                 /* ajDebug("REFSEQP FEAT first line:\n%S", seqReadLine); */
>             }
> 
>             ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff, seqReadLine);
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajFilebuffLoadS(seqin->Ftquery->Input->Filebuff,
>                                 seqReadLine);
>                 /* ajDebug("REFSEQP FEAT saved line:\n%S", seqReadLine); */
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "REFERENCE"))
>         {
>             ajDebug("reference found\n");
>             seqref = ajSeqrefNew();
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>             ajStrTokenStep(seqHandle); /* 'REFERENCE' */
>             ajStrTokenNextParse(seqHandle, &seqToken); /* number */
>             ajStrToUint(seqToken, &refnum);
>             ajSeqrefSetnumNumber(seqref, refnum);
>             ajStrAssignClear(&seqToken2);
> 
>             while (ajStrTokenNextParse(seqHandle, &seqToken))
>             {
>                 if(ajStrMatchC(seqToken, "(bases"))
13470c15154
< 		if(ajStrMatchC(token, "to"))
---
>                 if(ajStrMatchC(seqToken, "(residues"))
13473,13474c15157,15187
< 		if(!ajStrGetLen(tmpstr2))
< 		    ajStrAssignS(&tmpstr2, token);
---
>                 if(ajStrMatchC(seqToken, "to"))
>                     continue;
> 
>                 if(!ajStrGetLen(seqToken2))
>                     ajStrAssignS(&seqToken2, seqToken);
> 
>                 if(ajStrSuffixC(seqToken, ")"))
>                 {
>                     ajStrTrimEndC(&seqToken, ")");
>                     ajStrAppendK(&seqToken2, '-');
>                     ajStrAppendS(&seqToken2, seqToken);
>                 }
>             }
> 
>             ajSeqrefSetPosition(seqref, seqToken2);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             ajSeqrefStandard(seqref);
>             ajSeqAddRef(thys, seqref);
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  AUTHORS"))
>             {
>                 ajDebug("authors found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " \n\r");
>                 ajStrTokenStep(seqHandle); /* 'AUTHORS' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken2); /* authors */
13476,13575c15189,15360
< 		if(ajStrSuffixC(token, ")"))
< 		{
< 		    ajStrTrimEndC(&token, ")");
< 		    ajStrAppendK(&tmpstr2, '-');
< 		    ajStrAppendS(&tmpstr2, token);
< 		}
< 	    }
< 
< 	    ajSeqrefSetPosition(seqref, tmpstr2);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 		seqin->Input->Records++;
< 	    }
< 
< 	    ajSeqrefStandard(seqref);
< 	    ajSeqAddRef(thys, seqref);
< 	    seqref = NULL;
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "KEYWORDS"))
< 	{
< 	    ajDebug("keywords found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'KEYWORDS' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		liststr = ajStrNewS(token);
< 		ajStrTrimWhite(&liststr);
< 		ajSeqAddKey(thys, liststr);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, " "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    liststr = ajStrNewS(token);
< 		    ajStrTrimWhite(&liststr);
< 		    ajSeqAddKey(thys, liststr);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	else if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
< 	{
< 	    ajDebug("organism found\n");
< 	    ajStrTokenAssignC(&handle, seqReadLine, " ");
< 	    ajStrTokenNextParse(&handle, &token); /* 'ORGANISM' */
< 
< 	    while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 	    {
< 		ajStrAssignS(&tmpstr, token);
< 		ajStrTrimWhite(&tmpstr);
< 		seqTaxSave(thys, tmpstr, 0);
< 	    }
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    done = ajTrue;
< 
< 	    while(ok && ajStrPrefixC(seqReadLine, "    "))
< 	    {
< 		seqin->Input->Records++;
< 		ajStrTokenAssignC(&handle, seqReadLine, " ");
< 
< 		while(ajStrTokenNextParseC(&handle, ".;\n\r", &token))
< 		{
< 		    ajStrAssignS(&tmpstr, token);
< 		    ajStrTrimWhite(&tmpstr);
< 		    seqTaxSave(thys, tmpstr, 0);
< 		}
< 
< 		ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                          seqin->Input->Text,
<                                          &thys->TextPtr);
< 	    }
< 	}
< 
< 	if(!done)
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
---
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>                 while(ok && ajStrPrefixC(seqReadLine, "          "))
>                 {
>                     ajStrAssignS(&seqToken, seqReadLine);
>                     ajStrTrimWhite(&seqToken);
>                     if(ajStrSuffixC(seqToken2, ".,") ||
>                        ajStrPrefixC(seqToken, "and "))
>                         ajStrAppendC(&seqToken2, " ");
>                     ajStrAppendS(&seqToken2, seqToken);
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 }
> 
>                 /* append here - genbank splits author names across lines */
>                 ajSeqrefAppendAuthors(seqref, seqToken2);
>             }
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  TITLE"))
>             {
>                 ajDebug("title found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'TITLE' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* title */
> 
>                 ajSeqrefAppendTitle(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>                 while(ok && ajStrPrefixC(seqReadLine, "          "))
>                 {
>                     ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                     ajStrTokenNextParseC(seqHandle, "\n\r",
>                                          &seqToken); /* title */
>                     ajSeqrefAppendTitle(seqref, seqToken);
> 
>                     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>                 }
>             }
> 
>             if(ok && ajStrPrefixC(seqReadLine, "  JOURNAL"))
>             {
>                 ajDebug("journal location found\n");
>                 if(!seqref)
>                     seqref = ajSeqrefNew();
> 
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenStep(seqHandle); /* 'JOURNAL' */
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* location */
> 
>                 ajSeqrefAppendLocation(seqref, seqToken);
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
> 
>             while(ok && ajStrPrefixC(seqReadLine, "  "))
>             {
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
> 
>             seqref = NULL;
>         }
> 
>         else if(ok && ajStrPrefixC(seqReadLine, "COMMENT"))
>         {
>             ajDebug("comment found\n");
> 
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'COMMENT' */
>             ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken); /* comment */
> 
>             if(ajStrGetLen(cmtstr))
>                 ajStrAppendC(&cmtstr, "\n");
>             ajStrAppendS(&cmtstr, seqToken);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, "          "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>                 ajStrTokenNextParseC(seqHandle, "\n\r",
>                                      &seqToken); /* comment */
> 
>                 if(ajStrGetLen(seqToken))
>                 {
>                     if(ajStrGetLen(cmtstr))
>                         ajStrAppendC(&cmtstr, "\n");
>                     ajStrAppendS(&cmtstr, seqToken);
>                 }
>                 else
>                 {
>                     ajSeqAddCmt(thys, cmtstr);
>                     cmtstr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
> 
>             if(ajStrGetLen(cmtstr))
>                  ajSeqAddCmt(thys, cmtstr);
> 
>             cmtstr = NULL;
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "KEYWORDS"))
>         {
>             ajDebug("keywords found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'KEYWORDS' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 liststr = ajStrNewS(seqToken);
>                 ajStrTrimWhite(&liststr);
>                 ajSeqAddKey(thys, liststr);
>                 liststr = NULL;
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, " "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                 {
>                     liststr = ajStrNewS(seqToken);
>                     ajStrTrimWhite(&liststr);
>                     ajSeqAddKey(thys, liststr);
>                     liststr = NULL;
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         else if(ajStrPrefixC(seqReadLine, "  ORGANISM"))
>         {
>             ajDebug("organism found\n");
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
>             ajStrTokenStep(seqHandle); /* 'ORGANISM' */
> 
>             while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>             {
>                 ajStrTrimWhite(&seqToken);
>                 seqTaxSave(thys, seqToken, 0);
>             }
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             done = ajTrue;
> 
>             while(ok && ajStrPrefixC(seqReadLine, "    "))
>             {
>                 ajStrTokenAssignC(&seqHandle, seqReadLine, " ");
> 
>                 while(ajStrTokenNextParseC(seqHandle, ".;\n\r", &seqToken))
>                 {
>                     ajStrTrimWhite(&seqToken);
>                     seqTaxSave(thys, seqToken, 0);
>                 }
> 
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>             }
>         }
> 
>         if(!done)
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13580,13584c15365,15369
< 	ajDebug("REFSEQP FEAT TabIn %x\n", seqin->Ftquery);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(thys->Fttable); */
< 	ajFeattabinClear(seqin->Ftquery);
---
>         ajDebug("REFSEQP FEAT TabIn %x\n", seqin->Ftquery);
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         /* ajFeattableTrace(thys->Fttable); */
>         ajFeattabinClear(seqin->Ftquery);
13589,13590c15374,15381
< 	/* we have a sequence to use */
< 	ajDebug("Got an Inseq sequence\n");
---
>         /* we have a sequence to use */
>         ajDebug("Got an Inseq sequence\n");
> 
>         if(ajStrMatchC(qry->Method,"gcg"))
>             while(ok && !ajStrPrefixC(seqReadLine,"ORIGIN"))
>                 ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
> 
>         ajStrAssignS(&thys->Seq, seqin->Inseq);
13592,13603c15383,15387
< 	if(ajStrMatchC(qry->Method,"gcg"))
< 	    while(ok && !ajStrPrefixC(seqReadLine,"ORIGIN"))
< 		ok = ajBuffreadLineStore(buff,&seqReadLine, seqin->Input->Text,
< 					&thys->TextPtr);
< 
< 	ajStrAssignS(&thys->Seq, seqin->Inseq);
< 
< 	if(seqin->Input->Text)
< 	{
< 	    seqTextSeq(&thys->TextPtr, seqin->Inseq);
< 	    ajFmtPrintAppS(&thys->TextPtr, "//\n");
< 	}
---
>         if(seqin->Input->Text)
>         {
>             seqTextSeq(&thys->TextPtr, seqin->Inseq);
>             ajFmtPrintAppS(&thys->TextPtr, "//\n");
>         }
13607,13608c15391,15392
< 	/* read the sequence and terminator */
< 	ajDebug("sequence start at '%S'\n", seqReadLine);
---
>         /* read the sequence and terminator */
>         ajDebug("sequence start at '%S'\n", seqReadLine);
13610,13629c15394,15409
< 	while(!ajStrPrefixC(seqReadLine,"ORIGIN") &&
< 	      !ajStrPrefixC(seqReadLine,"BASE COUNT"))
< 	    if(!ajBuffreadLineStore(buff,&seqReadLine,
< 				   seqin->Input->Text, &thys->TextPtr))
< 		break;
< 
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
< 	ajStrSetRes(&thys->Seq, seqlen+1);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "//"))
< 	{
< 	    if(!ajStrPrefixC(seqReadLine, "ORIGIN") &&
< 	       !ajStrPrefixC(seqReadLine,"BASE COUNT"))
< 		seqAppend(&thys->Seq, seqReadLine);
< 
< 	    ok = ajBuffreadLineStore(buff, &seqReadLine, seqin->Input->Text,
< 				    &thys->TextPtr);
< 	    seqin->Input->Records++;
< 	}
---
>         while(!ajStrPrefixC(seqReadLine,"ORIGIN") &&
>               !ajStrPrefixC(seqReadLine,"BASE COUNT"))
>             if(!ajTextinStoreReadline(seqin->Input,&seqReadLine, &thys->TextPtr))
>                 break;
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         ajStrSetRes(&thys->Seq, seqlen+1);
> 
>         while(ok && !ajStrPrefixC(seqReadLine, "//"))
>         {
>             if(!ajStrPrefixC(seqReadLine, "ORIGIN") &&
>                !ajStrPrefixC(seqReadLine,"BASE COUNT"))
>                 seqAppend(&thys->Seq, seqReadLine);
> 
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
13633,13635c15413,15414
< 	while(ok && !ajStrPrefixC(seqReadLine,"//"))
< 	    ok = ajBuffreadLineStore(buff,&seqReadLine,
< 				    seqin->Input->Text, &thys->TextPtr);
---
>         while(ok && !ajStrPrefixC(seqReadLine,"//"))
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13643,13646c15422,15424
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
<     ajStrDel(&tmpstr);
<     ajStrDel(&tmpstr2);
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
>     ajStrDelStatic(&seqToken2);
13669a15448,15449
> **
> ** @release 6.4.0
13681,13682c15461,15462
<     AjPStr verstr = NULL;	/* copy of version line */
<     AjPStr outstr = NULL;	/* generated Type line */
---
>     AjPStr verstr = NULL;       /* copy of version line */
>     AjPStr outstr = NULL;       /* generated Type line */
13687c15467
< 	seqRegGffTyp = ajRegCompC("^##([DR]NA|Protein) +([^ \t\r\n]+)");
---
>         seqRegGffTyp = ajRegCompC("^##([DR]NA|Protein) +([^ \t\r\n]+)");
13690c15470
< 	ajStrAssignC(&seqFtFmtGff, "gff");
---
>         ajStrAssignC(&seqFtFmtGff, "gff");
13692,13693c15472
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13695,13697c15474
< 	return ajFalse;
< 
<     seqin->Input->Records++;
---
>         return ajFalse;
13703c15480
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
13705c15482
< 	return ajFalse;
---
>         return ajFalse;
13711c15488
< 	ajStrAssignS(&thys->TextPtr,seqReadLine);
---
>         ajStrAssignS(&thys->TextPtr,seqReadLine);
13713,13714c15490
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13719,13729c15495,15505
< 	if(ajRegExec(seqRegGffTyp, seqReadLine))
< 	{
< 	    isseq = ajTrue;
< 	    ajRegSubI(seqRegGffTyp, 1, &typstr);
< 	    ajRegSubI(seqRegGffTyp, 2, &thys->Name);
< 	    ajFmtPrintS(&outstr, "##Type %S %S", typstr, thys->Name);
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##end-"))
< 	    isseq = ajFalse;
< 	else if(isseq)
< 	    seqAppend(&thys->Seq, seqReadLine);
---
>         if(ajRegExec(seqRegGffTyp, seqReadLine))
>         {
>             isseq = ajTrue;
>             ajRegSubI(seqRegGffTyp, 1, &typstr);
>             ajRegSubI(seqRegGffTyp, 2, &thys->Name);
>             ajFmtPrintS(&outstr, "##Type %S %S", typstr, thys->Name);
>         }
>         else if(ajStrPrefixC(seqReadLine, "##end-"))
>             isseq = ajFalse;
>         else if(isseq)
>             seqAppend(&thys->Seq, seqReadLine);
13731,13732c15507
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13737,13738c15512,15513
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
< 	return ajFalse;
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
>         return ajFalse;
13745,13756c15520,15530
< 	dofeat = ajTrue;
< 	ftfile = ajFilebuffNewNofile();
< 	ajFilebuffLoadS(ftfile, verstr);
< 	ajFilebuffLoadS(ftfile, outstr);
< 
< 	while(ok && !ajStrPrefixC(seqReadLine, "##"))
< 	{
< 	    ajFilebuffLoadS(ftfile, seqReadLine);
< 	    /* ajDebug("GFF FEAT saved line:\n%S", seqReadLine); */
< 	    ok = ajBuffreadLineStore(buff,&seqReadLine,seqin->Input->Text,
< 				    &thys->TextPtr);
< 	}
---
>         dofeat = ajTrue;
>         ftfile = ajFilebuffNewNofile();
>         ajFilebuffLoadS(ftfile, verstr);
>         ajFilebuffLoadS(ftfile, outstr);
> 
>         while(ok && !ajStrPrefixC(seqReadLine, "##"))
>         {
>             ajFilebuffLoadS(ftfile, seqReadLine);
>             /* ajDebug("GFF FEAT saved line:\n%S", seqReadLine); */
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
13761,13764c15535,15540
< 	ajFeattabinDel(&seqin->Ftquery);
< 	seqin->Ftquery = ajFeattabinNewSSF(seqFtFmtGff, thys->Name,
< 					   ajStrGetPtr(seqin->Type), ftfile);
< 	ajDebug("GFF FEAT TabIn %x type: '%S'\n",
---
>         ajFeattabinDel(&seqin->Ftquery);
>         seqin->Ftquery = ajFeattabinNewSeqinSSF(seqin, seqFtFmtGff,
>                                                 thys->Name,
>                                                 ajStrGetPtr(seqin->Type),
>                                                 ftfile);
>         ajDebug("GFF FEAT TabIn %x type: '%S'\n",
13766,13772c15542,15548
< 	ftfile = NULL;		  /* now copied to seqin->Feattabin */
< 	ajFeattableDel(&seqin->Fttable);
< 	seqin->Fttable = ajFeattableNewRead(seqin->Ftquery);
< 	/* ajFeattableTrace(seqin->Fttable); */
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = seqin->Fttable;
< 	seqin->Fttable = NULL;
---
>         ftfile = NULL;            /* now copied to seqin->Feattabin */
>         ajFeattableDel(&seqin->Fttable);
>         seqin->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         /* ajFeattableTrace(seqin->Fttable); */
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = seqin->Fttable;
>         seqin->Fttable = NULL;
13776c15552
<       ajSeqSetProt(thys);
---
>         ajSeqSetProt(thys);
13778c15554
<       ajSeqSetNuc(thys);
---
>         ajSeqSetNuc(thys);
13780c15556
<       ajSeqSetProt(thys);
---
>         ajSeqSetProt(thys);
13810a15587,15588
> **
> ** @release 6.0.0
13820,13821c15598,15599
<     AjPStr verstr = NULL;	/* copy of version line */
<     AjPStr outstr = NULL;	/* generated Type line */
---
>     AjPStr verstr = NULL;       /* copy of version line */
>     AjPStr outstr = NULL;       /* generated Type line */
13822a15601,15602
>     AjPStr rest = NULL;
>     AjBool wantseq = ajFalse;
13827c15607
< 	ajStrAssignC(&seqFtFmtGff, "gff3");
---
>         ajStrAssignC(&seqFtFmtGff, "gff3");
13830c15610
< 	seqRegGff3Typ = ajRegCompC("^#!(.*)");
---
>         seqRegGff3Typ = ajRegCompC("^#!Type (.*)");
13832,13833c15612
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
< 			    seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13835,13837c15614
< 	return ajFalse;
< 
<     seqin->Input->Records++;
---
>         return ajFalse;
13845,13846c15622,15623
< 	ajDebug("bad gff3 version line '%S'\n", seqReadLine);
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajDebug("bad gff3 version line '%S'\n", seqReadLine);
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
13848c15625
< 	return ajFalse;
---
>         return ajFalse;
13854c15631
< 	ajStrAssignS(&thys->TextPtr,seqReadLine);
---
>         ajStrAssignS(&thys->TextPtr,seqReadLine);
13856,13857c15633
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
---
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13861,13889c15637,15664
< 	if(ajStrPrefixC(seqReadLine, "##sequence-region"))
< 	{
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##feature-ontology"))
< 	{
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##attribute-ontology"))
< 	{
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##source-ontology"))
< 	{
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "###"))
< 	{
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##FASTA"))
< 	{
< 	    break;
< 	}
< 	else if(ajStrPrefixC(seqReadLine, "##"))
< 	{
< 	    ajDebug("GFF3: Unrecognized header directive '%S'\n",
< 		   seqReadLine);
< 	}
< 
< 	if(ajRegExec(seqRegGff3Typ, seqReadLine))
< 	{
< 	    ajFmtPrintS(&outstr, "%S\n", seqReadLine);
< 	}
---
>         if(ajStrPrefixC(seqReadLine, "##sequence-region"))
>         {
>             ajStrTokenAssignC(&seqHandle, seqReadLine, " \t");
>             ajStrTokenStep(seqHandle);
>             ajStrTokenNextParse(seqHandle, &thys->Name);
>             ajStrTokenReset(seqHandle);
>         }
>         else if(ajStrPrefixC(seqReadLine, "##feature-ontology"))
>         {
>         }
>         else if(ajStrPrefixC(seqReadLine, "##attribute-ontology"))
>         {
>         }
>         else if(ajStrPrefixC(seqReadLine, "##source-ontology"))
>         {
>         }
>         else if(ajStrPrefixC(seqReadLine, "###"))
>         {
>         }
>         else if(ajStrPrefixC(seqReadLine, "##FASTA"))
>         {
>             break;
>         }
>         else if(ajStrPrefixC(seqReadLine, "##"))
>         {
>             ajDebug("GFF3: Unrecognized header directive '%S'\n",
>                     seqReadLine);
>         }
13891,13892c15666,15672
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         if(ajRegExec(seqRegGff3Typ, seqReadLine))
>         {
>             ajRegSubI(seqRegGff3Typ, 1, &typstr);
>             ajFmtPrintS(&outstr, "#!Type %S", typstr);
>         }
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13899c15679
< 	dofeat = ajTrue;
---
>         dofeat = ajTrue;
13901,13903c15681,15683
< 	ftfile = ajFilebuffNewNofile();
< 	ajFilebuffLoadS(ftfile, verstr);
< 	ajFilebuffLoadS(ftfile, outstr);
---
>         ftfile = ajFilebuffNewNofile();
>         ajFilebuffLoadS(ftfile, verstr);
>         ajFilebuffLoadS(ftfile, outstr);
13918a15699
> 
13920c15701,15706
< 	    ajFilebuffLoadS(ftfile, seqReadLine);
---
>             ajFilebuffLoadS(ftfile, seqReadLine);
>         else if(!ajStrGetLen(thys->Name))
>         {
>             if(ajStrExtractFirst(seqReadLine, &rest, &seqToken))
>                 ajStrAssignS(&thys->Name, seqToken);
>         }
13922,13923c15708
< 	ok = ajBuffreadLineStore(buff,&seqReadLine,seqin->Input->Text,
< 				&thys->TextPtr);
---
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13928c15713
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
13931c15716
< 	return ajFalse;
---
>         return ajFalse;
13933,13943d15717
< 	
<     ok = ajBuffreadLineStore(buff, &seqReadLine,
<                              seqin->Input->Text, &thys->TextPtr);
<     if(ok)
<     {
< 	if(ajStrPrefixC(seqReadLine, ">"))
< 	{
< 	    ajStrCutStart(&seqReadLine, 1);
< 	    ajStrExtractFirst(seqReadLine, &thys->Desc, &thys->Name);
<             ajStrRemoveWhiteExcess(&thys->Desc);
< 	}
13945,13946c15719,15734
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
<                                  seqin->Input->Text, &thys->TextPtr);
---
>     if(dofeat)
>     {
>         ajFeattabinDel(&seqin->Ftquery);
>         seqin->Ftquery = ajFeattabinNewSeqinSSF(seqin, seqFtFmtGff,
>                                                 thys->Name,
>                                                 ajStrGetPtr(seqin->Type),
>                                                 ftfile);
>         ajDebug("GFF3 FEAT TabIn %x\n", seqin->Ftquery);
>         ftfile = NULL;
>         ajFeattableDel(&seqin->Fttable);
>         ajFeattableDel(&thys->Fttable);
>         thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
>         if(thys->Fttable)
>             ajFeattableSetLength(thys->Fttable, ajStrGetLen(thys->Seq));
>         if(ajFeattableIsCircular(thys->Fttable))
>             ajSeqSetCircular(thys);
13948a15737,15739
>     ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>     wantseq = ajFalse;
> 
13951,13953c15742,15781
< 	seqAppend(&thys->Seq, seqReadLine);
< 	ok = ajBuffreadLineStore(buff, &seqReadLine,
< 				seqin->Input->Text, &thys->TextPtr);
---
>         while(ok && ajStrPrefixC(seqReadLine, ">"))
>         {
>             ajStrCutStart(&seqReadLine, 1);
>             if(wantseq)
>             {
>                 wantseq = ajFalse;
>             }
>             else
>             {
>                 ajStrExtractFirst(seqReadLine, &rest, &seqToken);
> 
>                 if(dofeat)
>                 {
>                     if(ajStrMatchS(seqToken, ajFeattableGetName(thys->Fttable)))
>                     {
>                         wantseq = ajTrue;
>                         ajStrAssignS(&thys->Name, seqToken);
>                     }
>                 }
>                 else
>                 {
>                     if(ajStrMatchS(seqToken, thys->Name))
>                     {
>                         wantseq = ajTrue;
>                     }
>                 }
> 
>                 if(wantseq)
>                 {
>                     ajStrRemoveWhiteExcess(&rest);
>                     ajStrAssignS(&thys->Desc, rest);
>                 }
>             }
>             ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
>         }
> 
>         if(wantseq)
>             seqAppend(&thys->Seq, seqReadLine);
> 
>         ok = ajTextinStoreReadline(seqin->Input, &seqReadLine, &thys->TextPtr);
13958c15786
< 	ajFilebuffResetStore(buff, seqin->Input->Text, &thys->TextPtr);
---
>         ajTextinStoreReset(seqin->Input, &thys->TextPtr);
13961,13975c15789
< 	return ajFalse;
<     }
< 
<     if(dofeat)
<     {
< 	ajFeattabinDel(&seqin->Ftquery);
< 	seqin->Ftquery = ajFeattabinNewSSF(seqFtFmtGff, thys->Name,
< 					   ajStrGetPtr(seqin->Type), ftfile);
< 	ajDebug("GFF FEAT TabIn %x\n", seqin->Ftquery);
< 	ftfile = NULL;
< 	ajFeattableDel(&seqin->Fttable);
< 	ajFeattableDel(&thys->Fttable);
< 	thys->Fttable = ajFeattableNewRead(seqin->Ftquery);
<         if(thys->Fttable)
<             ajFeattableSetLength(thys->Fttable, ajStrGetLen(thys->Seq));
---
>         return ajFalse;
13978d15791
< 
13980c15793
<       ajSeqSetProt(thys);
---
>         ajSeqSetProt(thys);
13982c15795
<       ajSeqSetNuc(thys);
---
>         ajSeqSetNuc(thys);
13984c15797
<       ajSeqSetProt(thys);
---
>         ajSeqSetProt(thys);
13990a15804,15805
>     ajStrDelStatic(&seqToken);
>     ajStrDel(&rest);
14005a15821,15822
> **
> ** @release 1.8.0
14029c15846
< 	return ajFalse;
---
>         return ajFalse;
14034c15851
< 	ajFilebuffResetPos(buff);
---
>         ajFilebuffResetPos(buff);
14036c15853
< 	return ajFalse;
---
>         return ajFalse;
14040c15857
< 	ajWarn("Failed to read text from binary ABI file %F", fp);
---
>         ajWarn("Failed to read text from binary ABI file %F", fp);
14057,14058c15874,15875
< 	ajFileSeek(fp,filestat,0);
< 	ajFilebuffResetPos(buff);
---
>         ajFileSeek(fp,filestat,0);
>         ajFilebuffResetPos(buff);
14060c15877
< 	return ajFalse;
---
>         return ajFalse;
14064c15881
<     
---
> 
14079c15896
< 	seqRegAbiDots = ajRegCompC("^(.*)[.](.*)$");
---
>         seqRegAbiDots = ajRegCompC("^(.*)[.](.*)$");
14085,14090c15902,15907
< 	ajStrSetClear(&sample);
< 	ajRegSubI(seqRegAbiDots,1,&smpl);
< 	ajStrAppendC(&smpl,"_");
< 	ajStrAppendS(&sample,smpl);
< 	ajRegSubI(seqRegAbiDots,2,&smpl);
< 	ajStrAppendS(&sample,smpl);
---
>         ajStrSetClear(&sample);
>         ajRegSubI(seqRegAbiDots,1,&smpl);
>         ajStrAppendC(&smpl,"_");
>         ajStrAppendS(&sample,smpl);
>         ajRegSubI(seqRegAbiDots,2,&smpl);
>         ajStrAppendS(&sample,smpl);
14119a15937,15938
> **
> ** @release 6.3.0
14125,14126c15944,15946
<     AjPSeq seq = NULL;
<     AjPSeqAccess seqaccess = seqin->Input->Query->Access;
---
>     AjBool debug = AJFALSE;
> 
>     AjPSeqAccess seqaccess = NULL;
14128,14132c15948
<     ajDebug("seqReadEnsembl\n"
<             "  thys %p\n"
<             "  seqin %p\n",
<             thys,
<             seqin);
---
>     debug = ajDebugTest("seqReadEnsembl");
14134c15950,15955
<     /* If the AJAX Sequence Input data member is empty, try one more. */
---
>     if(debug)
>         ajDebug("seqReadEnsembl\n"
>                 "  thys %p\n"
>                 "  seqin %p\n",
>                 thys,
>                 seqin);
14136,14137c15957,15961
<     if(!seqin->SeqData && seqaccess)
<         seqaccess->Access(seqin);
---
>     /*
>     ** Use the SeqData member of the AJAX Sequence Input structure
>     ** to pass the AJAX Sequence object between the AJAX Sequence Reading
>     ** (seqReadEnsembl) and AJAX Sequence Database (seqAccessEnsembl) modules.
>     */
14139c15963,15992
<     if(seqin->SeqData)
---
>     seqin->SeqData = (void*) thys;
> 
>     seqaccess = seqin->Input->Query->Access;
> 
>     if(((*seqaccess->Access)(seqin)) == ajFalse)
>         return ajFalse;
> 
>     return ajTrue;
> }
> 
> 
> 
> 
> /* @funcstatic seqPrefixGenbank ***********************************************
> **
> ** Returns an enumerated prefix for a record in genbank format
> **
> ** @param [r] str [const AjPStr] Input record
> **
> ** @return [SeqEPrefixGenbank] Enumerated record prefix
> ** @@
> ******************************************************************************/
> 
> static SeqEPrefixGenbank seqPrefixGenbank(const AjPStr str) 
> {
>     SeqEPrefixGenbank ipref = GB_UNK;
>     const char* cp = MAJSTRGETPTR(str);
>     const char* cq = (cp+1);
> 
>     switch (*cp)
14141c15994,16037
<         seq = (AjPSeq) seqin->SeqData;
---
>         case 'A':
>             if(*cq == 'C' && !strncmp(cp, "ACCESSION",9)) ipref = GB_AC;
>             break;
>         case 'B':
>             if(*cq == 'A' && !strncmp(cp, "BASE COUNT",10)) ipref = GB_BASE;
>             break;
>         case 'C':
>             if(*cq == 'O' && !strncmp(cp, "COMMENT",7)) ipref = GB_CC;
>             break;
>         case 'D':
>             if(*cq == 'E' && !strncmp(cp, "DEFINITION",10)) ipref = GB_DEF;
>             break;
>         case 'F':
>             if(*cq == 'E' && !strncmp(cp, "FEATURES",8)) ipref = GB_FEAT;
>             break;
>         case 'K':
>             if(*cq == 'E' && !strncmp(cp, "KEYWORDS",8)) ipref = GB_KEY;
>             break;
>         case 'L':
>             if(*cq == 'O' && !strncmp(cp, "LOCUS",5)) ipref = GB_ID;
>             break;
>         case 'O':
>             if(*cq == 'R' && !strncmp(cp, "ORIGIN",6)) ipref = GB_ORI;
>             break;
>         case 'R':
>             if(*cq == 'E' && !strncmp(cp, "REFERENCE",9)) ipref = GB_REF;
>             break;
>         case 'S':
>             if(*cq == 'E' && !strncmp(cp, "SEQVERSION",10)) ipref = GB_VER;
>             if(*cq == 'O' && !strncmp(cp, "SOURCE",6)) ipref = GB_SRC;
>             break;
>         case 'W':
>             if(*cq == 'P' && !strncmp(cp, "WPCOMMENT",9)) ipref = GB_WP;
>             break;
>         case '/':
>             if(*cq == '/' && !strncmp(cp, "//",2)) ipref = GB_END;
>             break;
>         case ' ':
>             if(*cq == ' ' && !strncmp(cp, "  ",2)) ipref = GB_MORE;
>             break;
>         default:
>             ipref = GB_UNK;
>             break;
>     }
14143c16039,16040
<         ajDebug("seqReadEnsembl got sequence %p\n", seq);
---
>     return ipref;
> }
14145,14149d16041
<         /*
<         ** TODO: It would be good to have an ajSeqAssignSeq function in the
<         ** AJAX core library to assign members of a AjPSeq structure to
<         ** another one.
<         */
14151d16042
<         /* For the moment only the name and the sequence need assigning. */
14153,14154d16043
<         ajStrAssignS(&thys->Name, seq->Name);
<         ajStrAssignS(&thys->Seq, seq->Seq);
14156c16045,16053
<         seqin->Input->Records++;
---
> /* @funcstatic seqPrefixGenbankMore *******************************************
> **
> ** Returns an enumerated prefix for a subrecord in genbank format
> **
> ** @param [r] str [const AjPStr] Input record
> **
> ** @return [SeqEPrefixGenbankMore] Enumerated record prefix
> ** @@
> ******************************************************************************/
14158c16055,16060
<         ajSeqDel(&seq);
---
> static SeqEPrefixGenbankMore seqPrefixGenbankMore(const AjPStr str) 
> {
>     SeqEPrefixGenbankMore imore = GB_MORE_UNK;
>     const char* cp = MAJSTRGETPTR(str);
>     const char* cq = (cp+1);
>     const char* cr = (cp+1);
14160c16062,16063
<         seqin->SeqData = NULL;
---
>     if(*cp != ' ' || *cq != ' ')
>         return GB_MORE_STD;
14162c16065,16096
<         return ajTrue;
---
>     switch (*cr)
>     {
>         case 'A':
>             if(!strncmp(cr, "AUTHORS",7)) imore = GB_MORE_AUT;
>             break;
>         case 'B':
>             break;
>         case 'C':
>             break;
>         case 'D':
>             break;
>         case 'F':
>             break;
>         case 'J':
>             if(!strncmp(cr, "JOURNAL",7)) imore = GB_MORE_JNL;
>             break;
>         case 'O':
>             if(!strncmp(cr, "ORGANISM",8)) imore = GB_MORE_ORG;
>             break;
>         case 'T':
>             break;
>             if(!strncmp(cr, "TITLE",5)) imore = GB_MORE_TIT;
>         case 'W':
>             break;
>         case '/':
>             break;
>         case ' ':
>             if(!strncmp(cr, "        ",8)) imore = GB_MORE_MORE;
>             break;
>         default:
>             imore = GB_MORE_UNK;
>             break;
14165c16099,16416
<     return ajFalse;
---
>     return imore;
> }
> 
> 
> 
> 
> /* @funcstatic seqPrefixSwiss *************************************************
> **
> ** Returns an enumerated prefix for a record in swissprot format
> **
> ** @param [r] str [const AjPStr] Input record
> **
> ** @return [SeqEPrefixSwiss] Enumerated record prefix
> ** @@
> ******************************************************************************/
> 
> static SeqEPrefixSwiss seqPrefixSwiss(const AjPStr str) 
> {
>     SeqEPrefixSwiss ipref = SWISS_UNK;
>     const char* cp = MAJSTRGETPTR(str);
>     const char* cq = (cp+1);
> 
>     switch (*cp)
>     {
>         case 'A':
>             switch(*cq)
>             {
>                 case 'C':
>                     ipref = SWISS_AC;
>                     break;
>                 case 'H':
>                     ipref = SWISS_FH; /* Align header ignored with FH */
>                     break;
>                 case 'S':
>                     ipref = SWISS_AS;
>                     break;
>                 case 'V':
>                     ipref = SWISS_AV; /* staden experiment */
>                     break;
>             }
>             break;
>         case 'C':
>             switch(*cq)
>             {
>                 case 'C':
>                     ipref = SWISS_CC;
>                     break;
>                 case 'O':
>                     ipref = SWISS_CO;
>                     break;
>             }
>             break;
>         case 'D':
>             switch(*cq)
>             {
>                 case 'E':
>                     ipref = SWISS_DE;
>                     break;
>                 case 'R':
>                     ipref = SWISS_DR;
>                     break;
>                 case 'T':
>                     ipref = SWISS_DT;
>                     break;
>             }
>             break;
>         case 'E':
>             switch(*cq)
>             {
>                 case 'N':
>                 case 'X':
>                     ipref = SWISS_EX;
>                     break;
>             }
>             break;
>         case 'F':
>             switch(*cq)
>             {
>                 case 'H':
>                     ipref = SWISS_FH;
>                     break;
>                 case 'T':
>                     ipref = SWISS_FT;
>                     break;
>             }
>             break;
>         case 'G':
>             if(*cq == 'N') ipref = SWISS_GN;
>             break;
>         case 'I':
>             switch(*cq)
>             {
>                 case 'D':
>                     ipref = SWISS_ID;
>                     break;
>                 case 'V':
>                     ipref = SWISS_SV; /* EMBLCDS Sv equivalent */
>                     break;
>             }
>             break;
>         case 'K':
>             if(*cq == 'W') ipref = SWISS_KW;
>             break;
>         case 'O':
>             switch (*cq)
>             {
>                 case 'C':
>                     ipref = SWISS_OC;
>                     break;
>                 case 'G':
>                     ipref = SWISS_OG;
>                     break;
>                 case 'H':
>                     ipref = SWISS_OH;
>                     break;
>                 case 'S':
>                     ipref = SWISS_OS;
>                     break;
>                 case 'X':
>                     ipref = SWISS_OX;
>                     break;
>             }
>             break;
>         case 'P':
>             switch(*cq)
>             {
>                 case 'A':
>                     ipref = SWISS_AC; /* PA records in EMBLCDS */
>                     break;
>                 case 'E':
>                     ipref = SWISS_PE;
>                     break;
>             }
>             break;
>         case 'R':
>             switch(*cq)
>             {
>                 case 'A':
>                     ipref = SWISS_RA;
>                     break;
>                 case 'C':
>                     ipref = SWISS_RC;
>                     break;
>                 case 'G':
>                     ipref = SWISS_RG;
>                     break;
>                 case 'L':
>                     ipref = SWISS_RL;
>                     break;
>                 case 'N':
>                     ipref = SWISS_RN;
>                     break;
>                 case 'P':
>                     ipref = SWISS_RP;
>                     break;
>                 case 'T':
>                     ipref = SWISS_RT;
>                     break;
>                 case 'X':
>                     ipref = SWISS_RX;
>                     break;
>             }
>             break;
>         case 'S':
>             switch(*cq)
>             {
>                 case 'Q':
>                     ipref = SWISS_SQ;
>                     break;
>                 case 'V':
>                     ipref = SWISS_SV;
>                     break;
>             }
>             break;
>         case 'T':
>             if(*cq == 'N') ipref = SWISS_EX;
>             break;
>         case 'W':
>             if(*cq == 'P') ipref = SWISS_WP;
>             break;
>         case 'X':
>             if(*cq == 'X') ipref = SWISS_XX;
>             break;
>         case '/':
>             if(*cq == '/') ipref = SWISS_END;
>             break;
>         case ' ':
>             if(*cq == ' ') ipref = SWISS_MORE;
>             break;
>         default:
>             ipref = SWISS_UNK;
>             break;
>     }
> 
>     return ipref;
> }
> 
> 
> 
> 
> /* @funcstatic seqDesSwiss ****************************************************
> **
> ** Returns an enumerated code for a description record token
> **
> ** @param [r] str [const AjPStr] Input record
> **
> ** @return [SeqEDesSwiss] Enumerated record prefix
> ** @@
> ******************************************************************************/
> 
> static SeqEDesSwiss seqDesSwiss(const AjPStr str) 
> {
>     SeqEDesSwiss ides = SWISS_DES_UNK;
>     const char* cp = MAJSTRGETPTR(str);
> 
>     switch (*cp)
>     {
>         case 'A':
>             if(!strcmp(cp, "AltName:")) ides = SWISS_DES_ALT;
>             break;
>         case 'C':
>             if(!strcmp(cp, "Contains:")) ides = SWISS_DES_CONT;
>             break;
>         case 'F':
>             if(!strcmp(cp, "Flags:")) ides = SWISS_DES_FLG;
>             break;
>         case 'I':
>             if(!strcmp(cp, "Includes:")) ides = SWISS_DES_INC;
>             break;
>         case 'R':
>             if(!strcmp(cp, "RecName:")) ides = SWISS_DES_REC;
>             break;
>         case 'S':
>             if(!strcmp(cp, "SubName:")) ides = SWISS_DES_SUB;
>             break;
>         default:
>             ides = SWISS_DES_UNK;
>             break;
>     }
> 
>     return ides;
> }
> 
> 
> 
> 
> /* @funcstatic seqDessubSwiss *************************************************
> **
> ** Returns an enumerated subcode for a description record token
> **
> ** @param [u] Pstr [AjPStr*] Input record
> **
> ** @return [SeqESubSwiss] Enumerated record prefix
> ** @@
> ******************************************************************************/
> 
> static SeqESubSwiss seqDessubSwiss(AjPStr *Pstr) 
> {
>     SeqESubSwiss isub = SWISS_SUB_UNK;
>     const char* cp = MAJSTRGETPTR(*Pstr);
> 
>     switch (*cp)
>     {
>         case 'A':
>             if(!strncmp(cp, "Allergen=", 9))
>             {
>                 isub = SWISS_SUB_ALLER;
>                 ajStrCutStart(Pstr, 9);
>             }
>             break;
>         case 'B':
>             if(!strncmp(cp, "Biotech=", 8))
>             {
>                 isub = SWISS_SUB_BIOTECH;
>                 ajStrCutStart(Pstr, 8);
>             }
>             break;
>         case 'C':
>             if(!strncmp(cp, "CD_antigen=", 11))
>             {
>                 isub = SWISS_SUB_CDA;
>                 ajStrCutStart(Pstr, 11);
>             }
>             break;
>         case 'E':
>             if(!strncmp(cp, "EC=", 3))
>             {
>                 isub = SWISS_SUB_EC;
>                 ajStrCutStart(Pstr, 3);
>             }
>             break;
>         case 'F':
>             if(!strncmp(cp, "Full=", 5))
>             {
>                 isub = SWISS_SUB_FULL;
>                 ajStrCutStart(Pstr, 5);
>             }
>             break;
>         case 'I':
>             if(!strncmp(cp, "INN=", 4))
>             {
>                 isub = SWISS_SUB_INN;
>                 ajStrCutStart(Pstr, 4);
>             }
>             break;
>         case 'S':
>             if(!strncmp(cp, "Short=", 6))
>             {
>                 isub = SWISS_SUB_SHORT;
>                 ajStrCutStart(Pstr, 6);
>             }
>             break;
>         default:
>             isub = SWISS_DES_UNK;
>             break;
>     }
> 
>     return isub;
14177a16429,16430
> **
> ** @release 1.0.0
14196c16449
< 		"Description");
---
>                 "Description");
14201,14212c16454,16465
< 	if(full || !seqinFormatDef[i].Alias)
< 	    ajFmtPrintF(outf,
< 			"  %-12s %5B %3B  %3B  %3B  %3B  %3B  %3B \"%s\"\n",
< 			seqinFormatDef[i].Name,
< 			seqinFormatDef[i].Alias,
< 			seqinFormatDef[i].Try,
< 			seqinFormatDef[i].Nucleotide,
< 			seqinFormatDef[i].Protein,
< 			seqinFormatDef[i].Feature,
< 			seqinFormatDef[i].Gap,
< 			seqinFormatDef[i].Multiset,
< 			seqinFormatDef[i].Desc);
---
>         if(full || !seqinFormatDef[i].Alias)
>             ajFmtPrintF(outf,
>                         "  %-12s %5B %3B  %3B  %3B  %3B  %3B  %3B \"%s\"\n",
>                         seqinFormatDef[i].Name,
>                         seqinFormatDef[i].Alias,
>                         seqinFormatDef[i].Try,
>                         seqinFormatDef[i].Nucleotide,
>                         seqinFormatDef[i].Protein,
>                         seqinFormatDef[i].Feature,
>                         seqinFormatDef[i].Gap,
>                         seqinFormatDef[i].Multiset,
>                         seqinFormatDef[i].Desc);
14222c16475
< /* @func ajSeqPrintbookInFormat ************************************************
---
> /* @func ajSeqPrintbookInFormat ***********************************************
14227a16481,16482
> **
> ** @release 6.2.0
14291c16546
< 	if(!seqinFormatDef[i].Alias)
---
>         if(!seqinFormatDef[i].Alias)
14299c16554
<     ajListSort(fmtlist, ajStrVcmp);
---
>     ajListSort(fmtlist, &ajStrVcmp);
14329c16584
<         
---
> 
14344c16599
< /* @func ajSeqPrinthtmlInFormat ************************************************
---
> /* @func ajSeqPrinthtmlInFormat ***********************************************
14349a16605,16606
> **
> ** @release 6.2.0
14369c16626
< 	if(!seqinFormatDef[i].Alias)
---
>         if(!seqinFormatDef[i].Alias)
14376c16633
<                     if(!seqinFormatDef[j].Alias) 
---
>                     if(!seqinFormatDef[j].Alias)
14384c16641
< 	    ajFmtPrintF(outf, "<tr><td>\n%S\n</td><td>%B</td>\n",
---
>             ajFmtPrintF(outf, "<tr><td>\n%S\n</td><td>%B</td>\n",
14386c16643
< 			seqinFormatDef[i].Try);
---
>                         seqinFormatDef[i].Try);
14389,14390c16646,16647
< 			seqinFormatDef[i].Protein,
< 			seqinFormatDef[i].Feature,
---
>                         seqinFormatDef[i].Protein,
>                         seqinFormatDef[i].Feature,
14393,14394c16650,16651
< 			seqinFormatDef[i].Multiset,
< 			seqinFormatDef[i].Desc);
---
>                         seqinFormatDef[i].Multiset,
>                         seqinFormatDef[i].Desc);
14408c16665
< /* @func ajSeqPrintwikiInFormat ************************************************
---
> /* @func ajSeqPrintwikiInFormat ***********************************************
14413a16671,16672
> **
> ** @release 6.2.0
14433c16692
< 	if(!seqinFormatDef[i].Alias)
---
>         if(!seqinFormatDef[i].Alias)
14440c16699
<                     if(!seqinFormatDef[j].Alias) 
---
>                     if(!seqinFormatDef[j].Alias)
14449,14458c16708,16717
< 	    ajFmtPrintF(outf,
< 			"|%S||%B||%B||%B||%B||%B||%B||%s\n",
< 			namestr,
< 			seqinFormatDef[i].Try,
< 			seqinFormatDef[i].Nucleotide,
< 			seqinFormatDef[i].Protein,
< 			seqinFormatDef[i].Feature,
< 			seqinFormatDef[i].Gap,
< 			seqinFormatDef[i].Multiset,
< 			seqinFormatDef[i].Desc);
---
>             ajFmtPrintF(outf,
>                         "|%S||%B||%B||%B||%B||%B||%B||%s\n",
>                         namestr,
>                         seqinFormatDef[i].Try,
>                         seqinFormatDef[i].Nucleotide,
>                         seqinFormatDef[i].Protein,
>                         seqinFormatDef[i].Feature,
>                         seqinFormatDef[i].Gap,
>                         seqinFormatDef[i].Multiset,
>                         seqinFormatDef[i].Desc);
14481a16741,16742
> **
> ** @release 6.4.0
14490c16751
<     /* ajDebug("seqinFormatFind '%S'\n", format); */
---
>      ajDebug("seqinFormatFind '%S'\n", format); 
14492c16753
< 	return ajFalse;
---
>         return ajFalse;
14499,14506c16760,16771
< 	/* ajDebug("test %d '%s' \n", i, seqinFormatDef[i].Name); */
< 	if(ajStrMatchC(tmpformat, seqinFormatDef[i].Name))
< 	{
< 	    *iformat = i;
< 	    ajStrDel(&tmpformat);
< 	    /* ajDebug("found '%s' at %d\n", seqinFormatDef[i].Name, i); */
< 	    return ajTrue;
< 	}
---
>         /*ajDebug("test %d '%s' '%s' '%s' \n",
>                 i, seqinFormatDef[i].Name,
>                 seqinFormatDef[i].Obo,
>                 seqinFormatDef[i].Desc);*/
>         if(ajStrMatchC(tmpformat, seqinFormatDef[i].Name) ||
>            ajStrMatchC(format, seqinFormatDef[i].Obo))
>         {
>             *iformat = i;
>             ajStrDel(&tmpformat);
>             /*ajDebug("found '%s' at %d\n", seqinFormatDef[i].Name, i);*/
>             return ajTrue;
>         }
14522a16788,16789
> **
> ** @release 2.7.0
14531,14533c16798,16804
< 	if(ajStrMatchCaseC(format, seqinFormatDef[i].Name))
< 	    return ajTrue;
< 
---
>     {
>         if(ajStrMatchCaseC(format, seqinFormatDef[i].Name))
>             return ajTrue;
>         if(ajStrMatchC(format, seqinFormatDef[i].Obo))
>             return ajTrue;
>     }
>     
14548a16820,16821
> **
> ** @release 1.0.0
14555,14556d16827
<     AjPStr fmtstr     = NULL;
<     AjPStrTok handle  = NULL;
14561c16832
< 	seqinFormatDef[i].Try = ajFalse;
---
>         seqinFormatDef[i].Try = ajFalse;
14565c16836
<     ajStrTokenAssignC(&handle, format, " \t\n\r,;:");
---
>     ajStrTokenAssignC(&seqHandle, format, " \t\n\r,;:");
14567c16838
<     while(ajStrTokenNextParseC(&handle, " \t\n\r,;:", &fmtstr))
---
>     while(ajStrTokenNextParseC(seqHandle, " \t\n\r,;:", &seqToken))
14569c16840
< 	ifound = 0;
---
>         ifound = 0;
14571,14578c16842,16849
< 	for(i=0; seqinFormatDef[i].Name; i++)
< 	    if(ajStrMatchCaseC(fmtstr, seqinFormatDef[i].Name))
< 	    {
< 		/* ajDebug("found '%S' %d\n", fmtstr, i); */
< 		seqinFormatDef[i].Try = ajTrue;
< 		ifound = 1;
< 		break;
< 	    }
---
>         for(i=0; seqinFormatDef[i].Name; i++)
>             if(ajStrMatchCaseC(seqToken, seqinFormatDef[i].Name))
>             {
>                 /* ajDebug("found '%S' %d\n", fmtstr, i); */
>                 seqinFormatDef[i].Try = ajTrue;
>                 ifound = 1;
>                 break;
>             }
14580,14582c16851,16853
< 	if(!ifound)
< 	{
< 	    /* ajDebug("not found '%S'\n", fmtstr); */
---
>         if(!ifound)
>         {
>             /* ajDebug("not found '%S'\n", fmtstr); */
14584,14586c16855,16857
< 	    ajErr("Input format '%S' not known", fmtstr);
< 	    ret = ajFalse;
< 	}
---
>             ajErr("Input format '%S' not known", seqToken);
>             ret = ajFalse;
>         }
14589c16860
<     ajStrTokenDel(&handle);
---
>     ajStrTokenReset(seqHandle);
14604a16876,16877
> **
> ** @release 1.0.0
14610d16882
<     AjPStr tmpstr = NULL;
14613,14615c16885,16887
<     ajStrAssignS(&tmpstr, line);
<     ajStrKeepSetAlphaC(&tmpstr, "*.~?#+-");
<     ajStrAppendS(pseq, tmpstr);
---
>     ajStrAssignS(&seqAppendTmpstr, line);
>     ajStrKeepSetAlphaC(&seqAppendTmpstr, "*.~?#+-");
>     ajStrAppendS(pseq, seqAppendTmpstr);
14618c16890,16891
<     ajStrDel(&tmpstr);
---
> 
>     ajStrDelStatic(&seqAppendTmpstr);
14633a16907,16908
> **
> ** @release 6.0.0
14666a16942,16943
> **
> ** @release 3.0.0
14671c16948
< 				const AjPStr line)
---
>                                  const AjPStr line)
14684,14731c16961,17008
< 	/* if we are in a comment, look for the end of it */
< 	/* Staden comments are <comment> */
< 	/* GCG comments are <comment< or >comment> */
< 
< 	/* there should be no case of >comment< 
< 	   but in a broken file we can't tell */
< 
< 	/* so we test for both kinds of angle brackets at both ends */
< 
< 	if(*incomment)
< 	{
< 	    i = ajStrFindAnyC(tmpstr, "<>");
< 
< 	    if(i >= 0)			/* comment ends in this line */
< 	    {
< 	      ajStrCutStart(&tmpstr, (size_t) i+1);
< 		*incomment = ajFalse;
< 	    }
< 	    else
< 	    {
< 		ajStrAssignClear(&tmpstr);	/* all comment */
< 	    }
< 	}
< 	else
< 	{
< 	    i = ajStrFindAnyC(tmpstr, "<>");
< 
< 	    if(i >= 0)			/* comment starts in this line */
< 	    {
< 		if(i)
< 		    ajStrAppendSubS(pseq, tmpstr, 0, i-1);
< 
< 		ajDebug("before comment saved '%S'\n", *pseq);
< 		ajStrCutStart(&tmpstr, (size_t) (i+1));
< 		*incomment = ajTrue;
< 	    }
< 	    else
< 	    {
< 		ajStrAppendS(pseq, tmpstr);
< 		ajDebug("all saved '%S'\n", *pseq);
< 		ajStrAssignClear(&tmpstr);
< 	    }
< 	}
< 
< 	if(ajStrGetLen(tmpstr))
< 	    ajDebug("continuing %B '%S'\n", *incomment, tmpstr);
< 	else
< 	    ajDebug("done %B '%S'\n", *incomment, tmpstr);
---
>         /* if we are in a comment, look for the end of it */
>         /* Staden comments are <comment> */
>         /* GCG comments are <comment< or >comment> */
> 
>         /* there should be no case of >comment<
>            but in a broken file we can't tell */
> 
>         /* so we test for both kinds of angle brackets at both ends */
> 
>         if(*incomment)
>         {
>             i = ajStrFindAnyC(tmpstr, "<>");
> 
>             if(i >= 0)                  /* comment ends in this line */
>             {
>                 ajStrCutStart(&tmpstr, (size_t) i+1);
>                 *incomment = ajFalse;
>             }
>             else
>             {
>                 ajStrAssignClear(&tmpstr);      /* all comment */
>             }
>         }
>         else
>         {
>             i = ajStrFindAnyC(tmpstr, "<>");
> 
>             if(i >= 0)                  /* comment starts in this line */
>             {
>                 if(i)
>                     ajStrAppendSubS(pseq, tmpstr, 0, i-1);
> 
>                 ajDebug("before comment saved '%S'\n", *pseq);
>                 ajStrCutStart(&tmpstr, (size_t) (i+1));
>                 *incomment = ajTrue;
>             }
>             else
>             {
>                 ajStrAppendS(pseq, tmpstr);
>                 ajDebug("all saved '%S'\n", *pseq);
>                 ajStrAssignClear(&tmpstr);
>             }
>         }
> 
>         if(ajStrGetLen(tmpstr))
>             ajDebug("continuing %B '%S'\n", *incomment, tmpstr);
>         else
>             ajDebug("done %B '%S'\n", *incomment, tmpstr);
14743c17020
< /* @funcstatic seqAppendWarn ***************************************************
---
> /* @funcstatic seqAppendWarn **************************************************
14751a17029
> ** @param [r] informat [ajuint] Input format, zero for unknown
14752a17031,17032
> **
> ** @release 5.0.0
14756c17036,17037
< static const AjPStr seqAppendWarn(AjPStr* pseq, const AjPStr line)
---
> static const AjPStr seqAppendWarn(AjPStr* pseq, const AjPStr line,
>                                   ajuint informat)
14762,14763c17043,17044
< 	if(ajNamGetValueC("seqwarn", &tmpstr))
< 	    ajStrToBool(tmpstr, &seqDoWarnAppend);
---
>         if(ajNamGetValueC("seqwarn", &tmpstr))
>             ajStrToBool(tmpstr, &seqDoWarnAppend);
14769c17050
<     if(seqDoWarnAppend)
---
>     if(seqDoWarnAppend || informat)
14771,14772c17052,17053
< 	ajStrKeepSetAlphaRestC(&seqAppendTmpSeq, "*.~?#+-", &seqAppendRestStr);
< 	ajStrAppendS(pseq, seqAppendTmpSeq);
---
>         ajStrKeepSetAlphaRestC(&seqAppendTmpSeq, "*.~?#+-", &seqAppendRestStr);
>         ajStrAppendS(pseq, seqAppendTmpSeq);
14774c17055
< 	ajStrDelStatic(&seqAppendTmpSeq);
---
>         ajStrDelStatic(&seqAppendTmpSeq);
14776,14777c17057,17058
< 	if(!ajStrGetLen(seqAppendRestStr))
< 	    return NULL;
---
>         if(!ajStrGetLen(seqAppendRestStr))
>             return NULL;
14779c17060
< 	return seqAppendRestStr;
---
>         return seqAppendRestStr;
14782c17063,17069
<     ajStrKeepSetAlphaC(&seqAppendTmpSeq, "*.~?#+-");
---
>     if(!seqAppendFilter)
>         seqAppendFilter = ajCharGetfilter( "*.~?#+-"
>                                            "abcdefghijklmnopqrstuvwxyz"
>                                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
> 
>     ajStrKeepSetFilter(&seqAppendTmpSeq, seqAppendFilter);
>     
14793c17080
< /* @funcstatic seqqualAppendWarn ***********************************************
---
> /* @funcstatic seqqualAppendWarn **********************************************
14802a17090,17091
> **
> ** @release 6.1.0
14826a17116,17117
> **
> ** @release 4.0.0
14832c17123
< 	seqRegGcgDot = ajRegCompC("[.][.]");
---
>         seqRegGcgDot = ajRegCompC("[.][.]");
14835c17126
< 	seqRegGcgChk = ajRegCompC("[Cc][Hh][Ee][Cc][Kk]:[ \t]*([0-9]+)");
---
>         seqRegGcgChk = ajRegCompC("[Cc][Hh][Ee][Cc][Kk]:[ \t]*([0-9]+)");
14838c17129
< 	seqRegGcgLen = ajRegCompC("[Ll][Ee][Nn][Gg][Tt][Hh]:[ \t]*([0-9]+)");
---
>         seqRegGcgLen = ajRegCompC("[Ll][Ee][Nn][Gg][Tt][Hh]:[ \t]*([0-9]+)");
14841c17132
< 	seqRegGcgTyp = ajRegCompC("[Tt][Yy][Pp][Ee]:[ \t]*([NP])");
---
>         seqRegGcgTyp = ajRegCompC("[Tt][Yy][Pp][Ee]:[ \t]*([NP])");
14844c17135
< 	seqRegGcgNam = ajRegCompC("[^ \t>]+");
---
>         seqRegGcgNam = ajRegCompC("[^ \t>]+");
14847c17138
< 	seqRegGcgMsf = ajRegCompC("[Mm][Ss][Ff]:[ \t]*([0-9]+)");
---
>         seqRegGcgMsf = ajRegCompC("[Mm][Ss][Ff]:[ \t]*([0-9]+)");
14850c17141
< 	seqRegGcgMsflen = ajRegCompC("[Ll][Ee][Nn]:[ \t]*([0-9]+)");
---
>         seqRegGcgMsflen = ajRegCompC("[Ll][Ee][Nn]:[ \t]*([0-9]+)");
14853c17144
< 	seqRegGcgWgt = ajRegCompC("[Ww][Ee][Ii][Gg][Hh][Tt]:[ \t]*([0-9.]+)");
---
>         seqRegGcgWgt = ajRegCompC("[Ww][Ee][Ii][Gg][Hh][Tt]:[ \t]*([0-9.]+)");
14856c17147
< 	seqRegGcgMsfnam = ajRegCompC("[Nn][Aa][Mm][Ee]:[ \t]*([^ \t]+)");
---
>         seqRegGcgMsfnam = ajRegCompC("[Nn][Aa][Mm][Ee]:[ \t]*([^ \t]+)");
14882a17174,17175
> **
> ** @release 1.0.0
14887,14888c17180,17181
< 			 AjPStr* Pline,
< 			 ajuint maxlines, ajuint* len)
---
>                          AjPStr* Pline,
>                          ajuint maxlines, ajuint* len)
14894,14897d17186
<     AjPFilebuff buff;
< 
<     buff = seqin->Input->Filebuff;
< 
14902,14905c17191,17193
< 	if(nlines++)
< 	    if(!ajBuffreadLineStore(buff, Pline,
< 				   seqin->Input->Text, &thys->TextPtr))
< 		return ajFalse;
---
>         if(nlines++)
>             if(!ajTextinStoreReadline(seqin->Input, Pline, &thys->TextPtr))
>                 return ajFalse;
14907,14908c17195,17196
< 	if(nlines > maxlines)
< 	    return ajFalse;
---
>         if(nlines > maxlines)
>             return ajFalse;
14910,14911c17198,17199
< 	if(!ajRegExec(seqRegGcgDot, *Pline))
< 	    continue;
---
>         if(!ajRegExec(seqRegGcgDot, *Pline))
>             continue;
14913c17201
< 	ajDebug("seqGcgDots   .. found\n'%S'\n", *Pline);
---
>         ajDebug("seqGcgDots   .. found\n'%S'\n", *Pline);
14915,14916c17203,17204
< 	if(!ajRegExec(seqRegGcgChk, *Pline))	/* checksum required */
< 	    return ajFalse;
---
>         if(!ajRegExec(seqRegGcgChk, *Pline))    /* checksum required */
>             return ajFalse;
14918,14919c17206,17207
< 	if(ajRegExec(seqRegGcgMsf, *Pline))	/* oops - it's an MSF file */
< 	    return ajFalse;
---
>         if(ajRegExec(seqRegGcgMsf, *Pline))     /* oops - it's an MSF file */
>             return ajFalse;
14921,14922c17209,17210
< 	ajRegSubI(seqRegGcgChk, 1, &token);
< 	ajStrToUint(token, &check);
---
>         ajRegSubI(seqRegGcgChk, 1, &token);
>         ajStrToUint(token, &check);
14924c17212
< 	ajDebug("   checksum %d\n", check);
---
>         ajDebug("   checksum %d\n", check);
14926,14931c17214,17219
< 	if(ajRegExec(seqRegGcgLen, *Pline))
< 	{
< 	    ajRegSubI(seqRegGcgLen, 1, &token);
< 	    ajStrToUint(token, len);
< 	    ajDebug("   length %d\n", *len);
< 	}
---
>         if(ajRegExec(seqRegGcgLen, *Pline))
>         {
>             ajRegSubI(seqRegGcgLen, 1, &token);
>             ajStrToUint(token, len);
>             ajDebug("   length %d\n", *len);
>         }
14933,14937c17221,17225
< 	if(ajRegExec(seqRegGcgNam, *Pline))
< 	{
< 	    ajRegSubI(seqRegGcgNam, 0, &thys->Name);
< 	    ajDebug("   name '%S'\n", thys->Name);
< 	}
---
>         if(ajRegExec(seqRegGcgNam, *Pline))
>         {
>             ajRegSubI(seqRegGcgNam, 0, &thys->Name);
>             ajDebug("   name '%S'\n", thys->Name);
>         }
14939,14943c17227,17231
< 	if(ajRegExec(seqRegGcgTyp, *Pline))
< 	{
< 	    ajRegSubI(seqRegGcgTyp, 1, &thys->Type);
< 	    ajDebug("   type '%S'\n", thys->Type);
< 	}
---
>         if(ajRegExec(seqRegGcgTyp, *Pline))
>         {
>             ajRegSubI(seqRegGcgTyp, 1, &thys->Type);
>             ajDebug("   type '%S'\n", thys->Type);
>         }
14945c17233
< 	ajStrDel(&token);
---
>         ajStrDel(&token);
14947c17235
< 	return ajTrue;
---
>         return ajTrue;
14974a17263,17264
> **
> ** @release 1.0.0
14979c17269
< 			    ajuint maxlines, ajuint* len)
---
>                             ajuint maxlines, ajuint* len)
14985,14988d17274
<     AjPFilebuff buff;
< 
<     buff = seqin->Input->Filebuff;
< 
14995,14998c17281,17283
< 	if(nlines++)
< 	    if(!ajBuffreadLineStore(buff, Pline,
<                                     seqin->Input->Text, &thys->TextPtr))
< 		return ajFalse;
---
>         if(nlines++)
>             if(!ajTextinStoreReadline(seqin->Input, Pline, &thys->TextPtr))
>                 return ajFalse;
15000c17285
< 	ajDebug("testing line %d\n'%S'\n", nlines,*Pline);
---
>         ajDebug("testing line %d\n'%S'\n", nlines,*Pline);
15002,15003c17287,17288
< 	if(nlines > maxlines)
< 	    return ajFalse;
---
>         if(nlines > maxlines)
>             return ajFalse;
15005,15006c17290,17291
< 	if(!ajRegExec(seqRegGcgDot, *Pline))
< 	    continue;
---
>         if(!ajRegExec(seqRegGcgDot, *Pline))
>             continue;
15008c17293
< 	/* dots found. This must be the line if this is MSF format */
---
>         /* dots found. This must be the line if this is MSF format */
15010,15011c17295,17296
< 	if(!ajRegExec(seqRegGcgChk, *Pline))	/* check: is required */
< 	    return ajFalse;
---
>         if(!ajRegExec(seqRegGcgChk, *Pline))    /* check: is required */
>             return ajFalse;
15013,15014c17298,17299
< 	if(!ajRegExec(seqRegGcgMsf, *Pline)) /* MSF: len required for GCG*/
< 	    return ajFalse;
---
>         if(!ajRegExec(seqRegGcgMsf, *Pline)) /* MSF: len required for GCG*/
>             return ajFalse;
15017,15018c17302,17303
< 	ajRegSubI(seqRegGcgMsf, 1, &token);
< 	ajStrToUint(token, len);
---
>         ajRegSubI(seqRegGcgMsf, 1, &token);
>         ajStrToUint(token, len);
15020,15021c17305,17306
< 	ajRegSubI(seqRegGcgChk, 1, &token);
< 	ajStrToUint(token, &check);
---
>         ajRegSubI(seqRegGcgChk, 1, &token);
>         ajStrToUint(token, &check);
15023,15024c17308,17309
< 	if(ajRegExec(seqRegGcgNam, *Pline))
< 	    ajRegSubI(seqRegGcgNam, 0, &thys->Name);
---
>         if(ajRegExec(seqRegGcgNam, *Pline))
>             ajRegSubI(seqRegGcgNam, 0, &thys->Name);
15026,15027c17311,17312
< 	if(ajRegExec(seqRegGcgTyp, *Pline))
< 	    ajRegSubI(seqRegGcgTyp, 1, &thys->Type);
---
>         if(ajRegExec(seqRegGcgTyp, *Pline))
>             ajRegSubI(seqRegGcgTyp, 1, &thys->Type);
15029,15031c17314,17316
< 	ajStrDel(&token);
< 	ajDebug("seqGcgMsfDots '%S' '%S' len: %d check: %d\n",
< 		thys->Name, thys->Type, *len, check);
---
>         ajStrDel(&token);
>         ajDebug("seqGcgMsfDots '%S' '%S' len: %d check: %d\n",
>                 thys->Name, thys->Type, *len, check);
15033c17318
< 	return ajTrue;
---
>         return ajTrue;
15052a17338,17339
> **
> ** @release 1.0.0
15058c17345
<     AjPStr name         = NULL;	/* NOTE: not static. New each time for list */
---
>     AjPStr name         = NULL; /* NOTE: not static. New each time for list */
15065c17352
< 	return ajFalse;
---
>         return ajFalse;
15071c17358
< 	return ajFalse;
---
>         return ajFalse;
15083,15084c17370,17371
< 	ajRegSubI(seqRegGcgMsflen, 1, &token);
< 	ajStrToUint(token, &msfitem->Len);
---
>         ajRegSubI(seqRegGcgMsflen, 1, &token);
>         ajStrToUint(token, &msfitem->Len);
15087c17374
< 	msfitem->Len = 0;
---
>         msfitem->Len = 0;
15093,15094c17380,17381
< 	ajRegSubI(seqRegGcgWgt, 1, &token);
< 	ajStrToFloat(token, &msfitem->Weight);
---
>         ajRegSubI(seqRegGcgWgt, 1, &token);
>         ajStrToFloat(token, &msfitem->Weight);
15097c17384
< 	msfitem->Weight = 1.0;
---
>         msfitem->Weight = 1.0;
15100c17387
< 	    msfitem->Name, msfitem->Check, msfitem->Len, msfitem->Weight);
---
>             msfitem->Name, msfitem->Check, msfitem->Len, msfitem->Weight);
15114a17402,17403
> **
> ** @release 6.1.0
15123c17412
< 	seqRegUsaFmt = ajRegCompC("^([A-Za-z0-9-]*)::(.*)$");
---
>         seqRegUsaFmt = ajRegCompC("^([A-Za-z0-9-]*)::(.*)$");
15128,15129c17417,17418
< 	seqRegUsaDb = ajRegCompC("^([A-Za-z][A-Za-z0-9_]+)([-]([A-Za-z]+))?"
< 			   "([:{]([^}]*)}?)?$");
---
>         seqRegUsaDb = ajRegCompC("^([A-Za-z][A-Za-z0-9_]+)([-]([A-Za-z]+))?"
>                                  "([:{]([^}]*)}?)?$");
15133c17422
<     /* \3 qry->Field (id or acc etc.) */
---
>     /* \3 qry->SingleField (id or acc etc.) */
15139,15149c17428,17438
<         /* \1 is filename \5 is the qry->Field \6 is the qry->QryString */
< 	seqRegUsaId = ajRegCompC("^([^|]+[|]|[^:{%]+)"
< 			   "(([:{%])(([^:}]+):)?([^:}]*)}?)?$");
< #else
< 	/* Windows file names can start with e.g.: 'C:\' */
< 	/* But allow e.g. 'C:/...', for Staden spin */
< 
<         /* \1 is filename \6 is the qry->Field \7 is the qry->QryString */
< 	seqRegUsaId = ajRegCompC ("^(([a-zA-Z]:[\\\\/])?[^:{%]+)"
< 				  "(([:{%])(([^:}]+):)?([^:}]*)}?)?$");
< #endif
---
>         /* \1 is filename \5 is the qry->SingleField \6 is the qry->QryString */
>         seqRegUsaId = ajRegCompC("^([^|]+[|]|[^:{%]+)"
>                                  "(([:{%])(([^:}]+):)?([^:}]*)}?)?$");
> #else /* WIN32 */
>     /* Windows file names can start with e.g.: 'C:\' */
>     /* But allow e.g. 'C:/...', for Staden spin */
> 
>     /* \1 is filename \6 is the qry->SingleField \7 is the qry->QryString */
>     seqRegUsaId = ajRegCompC ("^(([a-zA-Z]:[\\\\/])?[^:{%]+)"
>                               "(([:{%])(([^:}]+):)?([^:}]*)}?)?$");
> #endif /* !WIN32 */
15152,15153c17441,17442
<     if(!seqRegUsaList)	 /* \1 is filename \3 is the qry->QryString */
< 	seqRegUsaList = ajRegCompC("^(@|[Ll][Ii][Ss][Tt]:+)(.+)$");
---
>     if(!seqRegUsaList)   /* \1 is filename \3 is the qry->QryString */
>         seqRegUsaList = ajRegCompC("^(@|[Ll][Ii][Ss][Tt]:+)(.+)$");
15155,15156c17444,17445
<     if(!seqRegUsaAsis)	 /* \1 is filename \3 is the qry->QryString */
< 	seqRegUsaAsis = ajRegCompC("^[Aa][Ss][Ii][Ss]:+(.+)$");
---
>     if(!seqRegUsaAsis)   /* \1 is filename \3 is the qry->QryString */
>         seqRegUsaAsis = ajRegCompC("^[Aa][Ss][Ii][Ss]:+(.+)$");
15159c17448
< 	seqRegUsaWild = ajRegCompC("(.*[*].*)");
---
>         seqRegUsaWild = ajRegCompC("(.*[*].*)");
15163c17452
< 	seqRegUsaRange = ajRegCompC("(.*)[[](-?[0-9]*):(-?[0-9]*)(:([Rr])?)?[]]$");
---
>         seqRegUsaRange = ajRegCompC("(.*)[[](-?[0-9]*):(-?[0-9]*)(:([Rr])?)?[]]$");
15173c17462
< /* @func ajSeqUsaGetBase *******************************************************
---
> /* @func ajSeqUsaGetBase ******************************************************
15180a17470,17471
> **
> ** @release 6.1.0
15191c17482
< #endif
---
> #endif /* __CYGWIN__ */
15194c17485
<     
---
> 
15205c17496
< 	usatmp = ajStrNew();
---
>         usatmp = ajStrNew();
15207c17498
< 		    ajStrGetPtr(seqUsaTest)+2);
---
>                     ajStrGetPtr(seqUsaTest)+2);
15211c17502
< #endif
---
> #endif /* __CYGWIN__ */
15219c17510
< 	ajRegPre(seqRegUsaRange, &tmpstr);
---
>         ajRegPre(seqRegUsaRange, &tmpstr);
15235c17526
< 	ajRegSubI(seqRegUsaFmt, 1, &tmpstr);
---
>         ajRegSubI(seqRegUsaFmt, 1, &tmpstr);
15238c17529
< 	ajRegSubI(seqRegUsaFmt, 2,&tmpstr);
---
>         ajRegSubI(seqRegUsaFmt, 2,&tmpstr);
15246,15247c17537,17538
< 	ajRegSubI(seqRegUsaDb, 1, &tmpstr);
< 	if(!ajNamDatabase(tmpstr))
---
>         ajRegSubI(seqRegUsaDb, 1, &tmpstr);
>         if(!ajNamDatabase(tmpstr))
15256c17547
< 	{
---
>         {
15258,15262c17549,17553
< 	    ajRegSubI(seqRegUsaId, 1, &tmpstr);
< #else
< 	    ajRegSubI(seqRegUsaId, 1, &tmpstr);
< #endif
< 	    ajDebug("found filename %S\n", tmpstr);
---
>             ajRegSubI(seqRegUsaId, 1, &tmpstr);
> #else /* WIN32 */
>             ajRegSubI(seqRegUsaId, 1, &tmpstr);
> #endif /* !WIN32 */
>             ajDebug("found filename %S\n", tmpstr);
15265c17556
<         
---
> 
15271c17562
<         
---
> 
15302a17594,17595
> **
> ** @release 6.4.0
15331c17624
<            seqin->Begin, seqin->End, seqin->Rev, qrystr);
---
>             seqin->Begin, seqin->End, seqin->Rev, qrystr);
15349c17642
<     
---
> 
15373c17666
<         return seqaccess->Access(seqin);
---
>         return (*seqaccess->Access)(seqin);
15390a17684,17685
> **
> ** @release 2.1.0
15401a17697
>     seqin->Input->Fpos     = node->Fpos;
15417a17714,17715
> **
> ** @release 2.1.0
15429a17728
>     node->Fpos     = seqin->Input->Fpos;
15444a17744,17745
> **
> ** @release 2.1.0
15455c17756
<     ajDebug("SeqUsaListTrace %d nodes\n", ajListGetLength(list));
---
>     ajDebug("SeqUsaListTrace %Lu nodes\n", ajListGetLength(list));
15459,15462c17760,17763
< 	node = (SeqPListUsa) ajListIterGet(iter);
< 	ajDebug("%3d: '%S' %4d..%d (%b) '%S' %d\n",
< 		++i, node->Usa, node->Begin, node->End, node->Rev,
< 		node->Formatstr, node->Format);
---
>         node = (SeqPListUsa) ajListIterGet(iter);
>         ajDebug("%3d: '%S' %4d..%d (%b) '%S' %d\n",
>                 ++i, node->Usa, node->Begin, node->End, node->Rev,
>                 node->Formatstr, node->Format);
15491a17793,17794
> **
> ** @release 6.4.0
15501c17804
<     AjPStrTok handle = NULL;
---
>     AjPStr rest  = NULL;
15504a17808
>     ajuint recnum = 0;
15510c17814
< 	    listfile, depth, seqin->Rev);
---
>             listfile, depth, seqin->Rev);
15513c17817
< 	ajFatal("USA List too deep");
---
>         ajFatal("USA List too deep");
15516c17820
< 	seqin->Usalist = ajListNew();
---
>         seqin->Usalist = ajListNew();
15524,15525c17828,17829
< 	ajErr("Failed to open list file '%S'", listfile);
< 	depth--;
---
>         ajErr("Failed to open list file '%S'", listfile);
>         depth--;
15527c17831
< 	return ret;
---
>         return ret;
15532,15552c17836,17853
< 	seqListNoComment(&seqReadLine);
< 
< 	if(ajStrGetLen(seqReadLine))
< 	{
< 	    ajStrTokenAssignC(&handle, seqReadLine, " \t\n\r");
< 	    ajStrTokenNextParse(&handle, &token);
< 	    /* ajDebug("Line  '%S'\n");*/
< 	    /* ajDebug("token '%S'\n", seqReadLine, token); */
< 
< 	    if(ajStrGetLen(token))
< 	    {
< 	        ajDebug("++Add to list: '%S'\n", token);
< 	        AJNEW0(node);
< 	        ajStrAssignS(&node->Usa, token);
< 	        seqUsaSave(node, seqin);
< 	        ajListPushAppend(list, node);
< 	    }
< 
< 	    ajStrDel(&token);
< 	    token = NULL;
< 	}
---
>         ++recnum;
>         seqListNoComment(&seqReadLine);
>         if(ajStrExtractWord(seqReadLine, &rest, &token))
>         {
>             if(ajStrGetLen(rest)) 
>             {
>                 ajErr("Bad record %u in list file '%S'\n'%S'",
>                       recnum, listfile, seqReadLine);
>             }
>             else if(ajStrGetLen(token))
>             {
>                 ajDebug("++Add to list: '%S'\n", token);
>                 AJNEW0(node);
>                 ajStrAssignS(&node->Usa, token);
>                 seqUsaSave(node, seqin);
>                 ajListPushAppend(list, node);
>             }
>         }
15556a17858
>     ajStrDel(&rest);
15568,15571c17870,17873
<      ** now try the first item on the list
<      ** this can descend recursively if it is also a list
<      ** which is why we check the depth above
<      */
---
>     ** now try the first item on the list
>     ** this can descend recursively if it is also a list
>     ** which is why we check the depth above
>     */
15576,15582c17878,17884
< 	ajSeqinUsa(&seqin, node->Usa);
< 	seqUsaRestore(seqin, node);
< 	ajStrDel(&node->Usa);
< 	ajStrDel(&node->Formatstr);
< 	AJFREE(node);
< 	ajDebug("descending with usa '%S'\n", seqin->Input->Qry);
< 	ret = seqinUsaProcess(seqin, seq);
---
>         ajSeqinUsa(&seqin, node->Usa);
>         seqUsaRestore(seqin, node);
>         ajStrDel(&node->Usa);
>         ajStrDel(&node->Formatstr);
>         AJFREE(node);
>         ajDebug("descending with usa '%S'\n", seqin->Input->Qry);
>         ret = seqinUsaProcess(seqin, seq);
15585d17886
<     ajStrTokenDel(&handle);
15597c17898
< ** Strips comments from a character string (a line from an ACD file).
---
> ** Strips comments from a character string (a line from a list file).
15601a17903,17904
> **
> ** @release 1.0.0
15612,15613c17915,17916
<     if(!i)				/* empty string */
< 	return;
---
>     if(!i)                              /* empty string */
>         return;
15616c17919
<     
---
> 
15620,15622c17923,17925
<     {					/* comment found */
< 	*cp = '\0';
< 	ajStrSetValid(text);
---
>     {                                   /* comment found */
>         *cp = '\0';
>         ajStrSetValid(text);
15638a17942,17943
> **
> ** @release 6.4.0
15648c17953
< 	ajDebug("... input format value '%S'\n", textin->Formatstr);
---
>         ajDebug("... input format value '%S'\n", textin->Formatstr);
15650,15657c17955,17962
< 	if(seqinFormatFind(textin->Formatstr, &textin->Format))
< 	{
< 	    ajStrAssignS(&thys->Formatstr, textin->Formatstr);
< 	    thys->Format = textin->Format;
< 	    ajDebug("...format OK '%S' = %d\n", textin->Formatstr,
< 		    textin->Format);
< 	}
< 	else
---
>         if(seqinFormatFind(textin->Formatstr, &textin->Format))
>         {
>             ajStrAssignS(&thys->Formatstr, textin->Formatstr);
>             thys->Format = textin->Format;
>             ajDebug("...format OK '%S' = %d\n", textin->Formatstr,
>                     textin->Format);
>         }
>         else
15659c17964
< 	    ajDebug("...format unknown '%S'\n", textin->Formatstr);
---
>             ajDebug("...format unknown '%S'\n", textin->Formatstr);
15662,15663c17967,17968
<         
< 	return ajTrue;
---
> 
>         return ajTrue;
15666c17971
< 	ajDebug("...input format not set\n");
---
>         ajDebug("...input format not set\n");
15680c17985
< ** @param [r] thys [const AjPSeqin] Sequence input object.
---
> ** @param [r] thys [const AjPSeqin] Sequen input object.
15681a17987,17988
> **
> ** @release 1.13.0
15688c17995
< 	return ajTrue;
---
>         return ajTrue;
15704a18012,18013
> **
> ** @release 1.0.0
15710,15712d18018
<     AjPStrTok split = NULL;
<     AjPStr token = NULL;
< 
15719,15720c18025,18026
< 	ajDebug("seqSetName word '%S'\n", str);
< 	split = ajStrTokenNewC(str, ":");
---
>         ajDebug("seqSetName word '%S'\n", str);
>         ajStrTokenAssignC(&seqHandleSplit, str, ":");
15722,15724c18028,18030
< 	while(ajStrTokenNextParse(&split, &token))
< 	    if(ajStrGetLen(token))
< 	       ajStrAssignS(&thys->Name, token);
---
>         while(ajStrTokenNextParse(seqHandleSplit, &seqTokenSplit))
>             if(ajStrGetLen(seqTokenSplit))
>                 ajStrAssignS(&thys->Name, seqTokenSplit);
15726c18032,18034
< 	ajStrTokenDel(&split);
---
>         ajStrExchangeSetCC(&thys->Name, ",/\\", "___");
> 
>         ajStrTokenReset(seqHandleSplit);
15730,15734c18038,18042
< 	ajDebug("seqSetName non-word '%S'\n", str);
< 	ajStrAssignS(&thys->Name, str);
< 	ajStrRemoveWhiteExcess(&thys->Name);
< 	ajStrExchangeKK(&thys->Name, ' ', '_');
< 	ajDebug("seqSetName cleaned '%S'\n", thys->Name);
---
>         ajDebug("seqSetName non-word '%S'\n", str);
>         ajStrAssignS(&thys->Name, str);
>         ajStrRemoveWhiteExcess(&thys->Name);
>         ajStrExchangeSetCC(&thys->Name, " ,;:/\\", "______");
>         ajDebug("seqSetName cleaned '%S'\n", thys->Name);
15738c18046,18047
<     ajStrDel(&token);
---
> 
>     ajStrDelStatic(&seqTokenSplit);
15746c18055
< /* @funcstatic seqitemSetName **************************************************
---
> /* @funcstatic seqitemSetName *************************************************
15754a18064,18065
> **
> ** @release 6.2.0
15760,15762d18070
<     AjPStrTok split = NULL;
<     AjPStr token = NULL;
< 
15765,15766c18073,18074
< 	ajDebug("seqitemSetName word '%S'\n", str);
< 	split = ajStrTokenNewC(str, ":");
---
>         ajDebug("seqitemSetName word '%S'\n", str);
>         ajStrTokenAssignC(&seqHandleSplit, str, ":");
15768,15770c18076,18078
< 	while(ajStrTokenNextParse(&split, &token))
< 	    if(ajStrGetLen(token))
< 	       ajStrAssignS(&thys->Name, token);
---
>         while(ajStrTokenNextParse(seqHandleSplit, &seqTokenSplit))
>             if(ajStrGetLen(seqTokenSplit))
>                 ajStrAssignS(&thys->Name, seqTokenSplit);
15772c18080
< 	ajStrTokenDel(&split);
---
>         ajStrTokenReset(seqHandleSplit);
15776,15780c18084,18088
< 	ajDebug("seqitemSetName non-word '%S'\n", str);
< 	ajStrAssignS(&thys->Name, str);
< 	ajStrRemoveWhiteExcess(&thys->Name);
< 	ajStrExchangeKK(&thys->Name, ' ', '_');
< 	ajDebug("seqitemSetName cleaned '%S'\n", thys->Name);
---
>         ajDebug("seqitemSetName non-word '%S'\n", str);
>         ajStrAssignS(&thys->Name, str);
>         ajStrRemoveWhiteExcess(&thys->Name);
>         ajStrExchangeKK(&thys->Name, ' ', '_');
>         ajDebug("seqitemSetName cleaned '%S'\n", thys->Name);
15784c18092
<     ajStrDel(&token);
---
>     ajStrDelStatic(&seqToken);
15800a18109,18110
> **
> ** @release 6.2.0
15806,15808d18115
<     AjPStrTok split = NULL;
<     AjPStr token = NULL;
< 
15811,15812c18118,18119
< 	ajDebug("seqnameSetName word '%S'\n", str);
< 	split = ajStrTokenNewC(str, ":");
---
>         ajDebug("seqnameSetName word '%S'\n", str);
>         ajStrTokenAssignC(&seqHandleSplit, str, ":");
15814,15816c18121,18123
< 	while(ajStrTokenNextParse(&split, &token))
< 	    if(ajStrGetLen(token))
< 	       ajStrAssignS(name, token);
---
>         while(ajStrTokenNextParse(seqHandleSplit, &seqTokenSplit))
>             if(ajStrGetLen(seqTokenSplit))
>                 ajStrAssignS(name, seqTokenSplit);
15818c18125
< 	ajStrTokenDel(&split);
---
>         ajStrTokenReset(seqHandleSplit);
15822,15826c18129,18133
< 	ajDebug("seqnameSetName non-word '%S'\n", str);
< 	ajStrAssignS(name, str);
< 	ajStrRemoveWhiteExcess(name);
< 	ajStrExchangeKK(name, ' ', '_');
< 	ajDebug("seqnameSetName cleaned '%S'\n", *name);
---
>         ajDebug("seqnameSetName non-word '%S'\n", str);
>         ajStrAssignS(name, str);
>         ajStrRemoveWhiteExcess(name);
>         ajStrExchangeKK(name, ' ', '_');
>         ajDebug("seqnameSetName cleaned '%S'\n", *name);
15830c18137,18138
<     ajStrDel(&token);
---
> 
>     ajStrDelStatic(&seqTokenSplit);
15846a18155,18156
> **
> ** @release 4.1.0
15856,15859c18166,18169
< 	ajDebug("seqSetNameNospace non-word '%S'\n", str);
< 	ajStrRemoveWhiteExcess(name);
< 	ajStrExchangeKK(name, ' ', '_');
< 	ajDebug("seqSetNameNospace cleaned '%S'\n", *name);
---
>         ajDebug("seqSetNameNospace non-word '%S'\n", str);
>         ajStrRemoveWhiteExcess(name);
>         ajStrExchangeKK(name, ' ', '_');
>         ajDebug("seqSetNameNospace cleaned '%S'\n", *name);
15877a18188,18189
> **
> ** @release 2.8.0
15889,15890c18201,18202
<     if(seqin->Input->Count > 1)
< 	ajFmtPrintAppS(&thys->Name, "_%3d", seqin->Input->Count);
---
>     if(ajTextinGetCount(seqin->Input) > 1)
>         ajFmtPrintAppS(&thys->Name, "_%3d", ajTextinGetCount(seqin->Input));
15908a18221,18222
> **
> ** @release 1.0.0
15920c18234
< 	ajStrAssignS(&thys->Acc, acc);
---
>         ajStrAssignS(&thys->Acc, acc);
15935c18249,18250
< ** @param [r] level [ajuint] 0: taxon level 1: species 2: organelle
---
> ** @param [r] level [ajuint] 0: taxon level 1: species
> **                           2: organelle   3: common name
15936a18252,18253
> **
> ** @release 2.4.0
15942a18260
>     AjBool done = ajFalse;
15948a18267
>             done = ajTrue;
15952a18272,18277
>             done = ajTrue;
>             break;
>         case 3:
>             if(!ajStrGetLen(thys->Taxcommon))
>                 ajStrAssignS(&thys->Taxcommon, tax);
>             done = ajTrue;
15955,15958c18280
<             if(!thys->Taxlist)
<                 thys->Taxlist = ajListstrNew();
<             newstr = ajStrNewS(tax);
<             ajListstrPushAppend(thys->Taxlist, newstr);
---
>             done = ajFalse;
15961a18284,18291
>     if(!done)
>     {
>         if(!thys->Taxlist)
>             thys->Taxlist = ajListstrNew();
>         newstr = ajStrNewS(tax);
>         ajListstrPushAppend(thys->Taxlist, newstr);
>     }
> 
15968c18298
< /* @funcstatic seqTaxidSaveI ***************************************************
---
> /* @funcstatic seqTaxidSaveI **************************************************
15974a18305,18306
> **
> ** @release 6.1.0
15989c18321
< /* @funcstatic seqTaxidSaveS ***************************************************
---
> /* @funcstatic seqTaxidSaveS **************************************************
15995a18328,18329
> **
> ** @release 6.1.0
16016a18351,18352
> **
> ** @release 2.4.0
16023c18359
< 	ajStrAssignS(&thys->Sv, sv);
---
>         ajStrAssignS(&thys->Sv, sv);
16064a18401,18402
> **
> ** @release 1.0.0
16073,16075c18411,18413
<     AjPStr accstr;			/* from list, do not delete */
<     AjPStr keystr;			/* from list, do not delete */
<     AjPStr taxstr;			/* from list, do not delete */
---
>     AjPStr accstr;                      /* from list, do not delete */
>     AjPStr keystr;                      /* from list, do not delete */
>     AjPStr taxstr;                      /* from list, do not delete */
16079,16080c18417,18418
<     ajDebug("seqQueryMatch '%S' fields: %u Case %B Done %B\n",
< 	    seq->Name, ajListGetLength(thys->QueryFields),
---
>     ajDebug("seqQueryMatch '%S' fields: %Lu Case %B Done %B\n",
>             seq->Name, ajListGetLength(thys->QueryFields),
16083,16084c18421,18422
<     if(!thys)			   /* no query to test, that's fine */
< 	return ajTrue;
---
>     if(!thys)                      /* no query to test, that's fine */
>         return ajTrue;
16086,16087c18424,18425
<     if(thys->QryDone)			/* do we need to test here? */
< 	return ajTrue;
---
>     if(thys->QryDone)                   /* do we need to test here? */
>         return ajTrue;
16118c18456
<             
---
> 
16153c18491
<             ajDebug("  acc test:%u\n",
---
>             ajDebug("  acc test:%Lu\n",
16156c18494
<             {		   /* accession number test - check the entire list */
---
>             {              /* accession number test - check the entire list */
16182c18520
<             ajDebug("  org test:%u\n",
---
>             ajDebug("  org test:%Lu\n",
16185c18523
<             {			   /* taxonomy test - check the entire list */
---
>             {                      /* taxonomy test - check the entire list */
16214c18552
<         
---
> 
16217c18555
<             ajDebug("  key test:%u\n",
---
>             ajDebug("  key test:%Lu\n",
16250c18588
<             
---
> 
16277c18615
<         else 
---
>         else
16280c18618
<                   thys->Field, thys->QryString);
---
>                   thys->SingleField, thys->QryString);
16283c18621
<         
---
> 
16285c18623
<         
---
> 
16288c18626
<     if(!tested)		    /* nothing to test, so accept it anyway */
---
>     if(!tested)             /* nothing to test, so accept it anyway */
16297c18635
< 	return ajTrue;
---
>         return ajTrue;
16299c18637
<     
---
> 
16318a18657,18658
> **
> ** @release 2.0.0
16323c18663
< 		       AjPStr* sv, AjPStr* desc)
---
>                        AjPStr* sv, AjPStr* desc)
16325,16328d18664
<     AjPStrTok handle = NULL;
<     AjPStr token     = NULL;
<     AjPStr token2    = NULL;
<     AjPStr str       = NULL;
16334,16336c18670
< 	return ajFalse;
< 
<     ajStrAssignS(&str, instr);
---
>         return ajFalse;
16338,16339c18672,18673
<     ajStrTokenAssignC(&handle, str, "> ");
<     ajStrTokenNextParseC(&handle, " \t\n\r", id);
---
>     ajStrTokenAssignC(&seqHandle, instr, "> ");
>     ajStrTokenNextParseC(seqHandle, " \t\n\r", id);
16341,16343c18675,18677
<     ok = ajStrTokenNextParse(&handle, &token);
<     ajStrAssignS(&token2, token);
<     ajStrRemoveSetC(&token2, "()");
---
>     ok = ajStrTokenNextParse(seqHandle, &seqToken);
>     ajStrAssignS(&seqToken2, seqToken);
>     ajStrRemoveSetC(&seqToken2, "()");
16345c18679
<     if(ok && ajSeqtestIsSeqversion(token2))
---
>     if(ok && ajSeqtestIsSeqversion(seqToken2))
16347,16349c18681,18683
<         ajStrAssignS(acc, ajSeqtestIsSeqversion(token2));
< 	ajStrAssignS(sv, token2);
< 	ajStrTokenNextParseC(&handle, "\n\r", desc);
---
>         ajStrAssignS(acc, ajSeqtestIsSeqversion(seqToken2));
>         ajStrAssignS(sv, seqToken2);
>         ajStrTokenNextParseC(seqHandle, "\n\r", desc);
16351c18685
<     else if(ok && ajSeqtestIsAccession(token2))
---
>     else if(ok && ajSeqtestIsAccession(seqToken2))
16353c18687
< 	ajStrAssignS(acc, token2);
---
>         ajStrAssignS(acc, seqToken2);
16355c18689
< 	ajStrTokenNextParseC(&handle, "\n\r", desc);
---
>         ajStrTokenNextParseC(seqHandle, "\n\r", desc);
16361c18695
< 	ajStrAssignS(desc, token);
---
>         ajStrAssignS(desc, seqToken);
16363,16367c18697,18701
< 	if(ajStrTokenNextParseC(&handle, "\n\r", &token))
< 	{
< 	    ajStrAppendC(desc, " ");
< 	    ajStrAppendS(desc, token);
< 	}
---
>         if(ajStrTokenNextParseC(seqHandle, "\n\r", &seqToken))
>         {
>             ajStrAppendC(desc, " ");
>             ajStrAppendS(desc, seqToken);
>         }
16370,16373c18704,18707
<     ajStrDel(&token); /* duplicate of accession or description */
<     ajStrDel(&token2);
<     ajStrTokenDel(&handle);
<     ajStrDel(&str);
---
>     ajStrDelStatic(&seqToken); /* duplicate of accession or description */
>     ajStrDelStatic(&seqToken2);
>     ajStrTokenReset(seqHandle);
> 
16399a18734,18735
> **
> ** @release 1.0.0
16404c18740
< 		      AjPStr* sv, AjPStr* gi, AjPStr* db, AjPStr* desc)
---
>                       AjPStr* sv, AjPStr* gi, AjPStr* db, AjPStr* desc)
16406,16407d18741
<     AjPStrTok idhandle = NULL;
<     AjPStrTok handle   = NULL;
16411d18744
<     AjPStr token       = NULL;
16423,16450c18756,18783
<      ** ftp://ncbi.nlm.nih.gov/blast/db/README.formatdb
<      **
<      ** Database Name                         Identifier Syntax
<      **
<      ** GenBank                               gb|accession|locus
<      ** EMBL Data Library                     emb|accession|locus
<      ** DDBJ, DNA Database of Japan           dbj|accession|locus
<      ** SWISS-PROT                            sp|accession|entry name
<      ** NCBI Reference Sequence               ref|accession|locus
<      **
<      ** General database identifier           gnl|database|identifier
<      ** BLAST formatdb                        gnl|BL_ORD_ID|number
<      **   (prefix for normal FASTA header - remove)
<      **
<      ** NBRF PIR                              pir||entry
<      ** Protein Research Foundation           prf||name
<      **   (Japanese SEQDB protein DB)
<      **
<      ** Brookhaven Protein Data Bank          pdb|entry|chain
<      **
<      ** Patents                               pat|country|number
<      **
<      ** GenInfo Backbone Id                   bbs|number
<      ** Local Sequence identifier             lcl|identifier
<      **
<      ** GenInfo identifier prefix             gi|gi_identifier
<      **   (prefix - remove)
<      */
---
>     ** ftp://ncbi.nlm.nih.gov/blast/db/README.formatdb
>     **
>     ** Database Name                         Identifier Syntax
>     **
>     ** GenBank                               gb|accession|locus
>     ** EMBL Data Library                     emb|accession|locus
>     ** DDBJ, DNA Database of Japan           dbj|accession|locus
>     ** SWISS-PROT                            sp|accession|entry name
>     ** NCBI Reference Sequence               ref|accession|locus
>     **
>     ** General database identifier           gnl|database|identifier
>     ** BLAST formatdb                        gnl|BL_ORD_ID|number
>     **   (prefix for normal FASTA header - remove)
>     **
>     ** NBRF PIR                              pir||entry
>     ** Protein Research Foundation           prf||name
>     **   (Japanese SEQDB protein DB)
>     **
>     ** Brookhaven Protein Data Bank          pdb|entry|chain
>     **
>     ** Patents                               pat|country|number
>     **
>     ** GenInfo Backbone Id                   bbs|number
>     ** Local Sequence identifier             lcl|identifier
>     **
>     ** GenInfo identifier prefix             gi|gi_identifier
>     **   (prefix - remove)
>     */
16452c18785
<     ajDebug("ajSeqParseNcbi '%S'\n", instr);
---
> /*    ajDebug("ajSeqParseNcbi '%S'\n", instr);*/
16456c18789
< 	ajDebug("ajSeqParseNcbi failed: this is PIR format\n");
---
>         ajDebug("ajSeqParseNcbi failed: this is PIR format\n");
16458c18791
< 	return ajFalse;
---
>         return ajFalse;
16471,16472c18804,18805
< 	ajDebug("ajSeqParseNcbi failed: no '>' at start\n");
< 	ajStrDel(&str);
---
>         ajDebug("ajSeqParseNcbi failed: no '>' at start\n");
>         ajStrDel(&str);
16474c18807
< 	return ajFalse;
---
>         return ajFalse;
16479,16482c18812,18815
<     ajStrTokenAssignC(&idhandle,str,"> \t\r\n");
<     ajStrTokenNextParse(&idhandle, &idstr);
<     ajStrTokenNextParseC(&idhandle, "\r\n", &reststr);
<     ajStrTokenDel(&idhandle);
---
>     ajStrTokenAssignC(&seqHandle2,str,"> \t\r\n");
>     ajStrTokenNextParse(seqHandle2, &idstr);
>     ajStrTokenNextParseC(seqHandle2, "\r\n", &reststr);
>     ajStrTokenReset(seqHandle2);
16488,16492c18821,18825
< 	ajDebug("No ID string found - but try FASTA\n");
< 	ret = ajSeqParseFasta(str, id, acc, sv, desc);
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
---
>         ajDebug("No ID string found - but try FASTA\n");
>         ret = ajSeqParseFasta(str, id, acc, sv, desc);
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
16494c18827
< 	return ret;
---
>         return ret;
16501,16505c18834,18838
< 	ajDebug("trying ajSeqParseFasta\n");
< 	ret = ajSeqParseFasta(str, id, acc, sv, desc);
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
---
>         ajDebug("trying ajSeqParseFasta\n");
>         ret = ajSeqParseFasta(str, id, acc, sv, desc);
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
16507c18840
< 	return ret;
---
>         return ret;
16511c18844
<     ajStrTokenAssignC(&handle,idstr,"|");
---
>     ajStrTokenAssignC(&seqHandle,idstr,"|");
16513c18846
<     ajStrTokenNextParse(&handle, &prefix);
---
>     ajStrTokenNextParse(seqHandle, &prefix);
16516,16517c18849,18852
<     ajDebug(" idstr: '%S'\n", idstr);
<     ajDebug("prefix: '%S'\n", prefix);
---
> /*
> //  ajDebug(" idstr: '%S'\n", idstr);
> //    ajDebug("prefix: '%S'\n", prefix);
> */
16522,16523c18857
< 	ajStrTokenNextParse(&handle, &token);
< 	ajStrAssignS(gi, token);
---
>         ajStrTokenNextParse(seqHandle, gi);
16525,16547c18859,18881
< 	if(! ajStrTokenNextParse(&handle, &prefix))
< 	{
< 	    /* we only have a gi prefix */
< 	    ajDebug("*only* gi prefix\n");
< 	    ajStrAssignS(id, token);
< 	    ajStrAssignClear(acc);
< 	    ajStrAssignS(desc, reststr);
< 	    ajDebug("found pref: '%S' id: '%S', acc: '%S' "
< 	       "desc: '%S'\n",
< 	       prefix, *id, *acc, *desc);
< 	    ajStrDel(&str);
< 	    ajStrDel(&idstr);
< 	    ajStrDel(&reststr);
< 	    ajStrDel(&prefix);
< 	    ajStrDel(&token);
< 	    ajStrTokenDel(&handle);
< 
< 	    return ajTrue;
< 	}
< 
< 	/* otherwise we continue to parse the rest */
< 	q = MAJSTRGETPTR(prefix);
< 	ajDebug("continue with '%S'\n", prefix);
---
>         if(! ajStrTokenNextParse(seqHandle, &prefix))
>         {
>             /* we only have a gi prefix */
>             ajDebug("*only* gi prefix\n");
>             ajStrAssignS(id, *gi);
>             ajStrAssignClear(acc);
>             ajStrAssignS(desc, reststr);
>             ajDebug("found pref: '%S' id: '%S', acc: '%S' "
>                     "desc: '%S'\n",
>                     prefix, *id, *acc, *desc);
>             ajStrDel(&str);
>             ajStrDel(&idstr);
>             ajStrDel(&reststr);
>             ajStrDel(&prefix);
>             ajStrDelStatic(&seqToken);
>             ajStrTokenReset(seqHandle);
> 
>             return ajTrue;
>         }
> 
>         /* otherwise we continue to parse the rest */
>         q = MAJSTRGETPTR(prefix);
>         ajDebug("continue with '%S'\n", prefix);
16559,16577c18893,18896
< 	ajStrTokenNextParse(&handle, &token); /* BL_ORD_ID */
< 	ajStrTokenNextParse(&handle, &numtoken); /* number */
< 	ajStrInsertC(&reststr, 0, ">");
< 
< 	if(ajSeqParseNcbi(reststr,id,acc,sv,gi,db,desc))
< 	{
< 	    ajStrAssignEmptyS(db, token);
< 	    /* recursive ... */
< 	    ajDebug("ajSeqParseNcbi recursive success '%S'\n", reststr);
< 	    /* ajDebug("found pref: '%S' id: '%S', acc: '%S' "
< 	       "sv: '%S' desc: '%S'\n",
< 	       prefix, *id, *acc, *sv, *desc); */
< 	    ajStrDel(&str);
< 	    ajStrDel(&idstr);
< 	    ajStrDel(&reststr);
< 	    ajStrDel(&prefix);
< 	    ajStrDel(&numtoken);
< 	    ajStrDel(&token);
< 	    ajStrTokenDel(&handle);
---
>         ajStrTokenStep(seqHandle); /* BL_ORD_ID */
>         ajStrTokenStep(seqHandle); /* number */
>         ajStrInsertC(&reststr, 0, ">");
>         ajStrTokenReset(seqHandle);
16579,16580c18898,18915
< 	    return ajTrue;
< 	}
---
>         if(ajSeqParseNcbi(reststr,id,acc,sv,gi,db,desc))
>         {
>             ajStrAssignEmptyC(db, "BL_ORD_ID");
>             /* recursive ... */
>             ajDebug("ajSeqParseNcbi recursive success '%S'\n", reststr);
>             /* ajDebug("found pref: '%S' id: '%S', acc: '%S' "
>                "sv: '%S' desc: '%S'\n",
>                prefix, *id, *acc, *sv, *desc); */
>             ajStrDel(&str);
>             ajStrDel(&idstr);
>             ajStrDel(&reststr);
>             ajStrDel(&prefix);
>             ajStrDel(&numtoken);
>             ajStrDelStatic(&seqToken);
>             ajStrTokenReset(seqHandle);
> 
>             return ajTrue;
>         }
16582,16594c18917,18929
< 		reststr);
< 	ajStrAssignS(id,numtoken);
< 	ajStrAssignClear(acc);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' "
< 	   "sv: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *sv, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>                 reststr);
>         ajStrAssignS(id,numtoken);
>         ajStrAssignClear(acc);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' "
>            "sv: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *sv, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenDel(&seqHandle);
16596c18931
< 	return ajTrue;
---
>         return ajTrue;
16600c18935
<      ** still checking for any mis-formatted databases elsewhere */
---
>     ** still checking for any mis-formatted databases elsewhere */
16604,16605c18939,18940
< 	if(!strcmp(q, "lcl"))
< 	    ajStrAssignS(db, prefix);
---
>         if(!strcmp(q, "lcl"))
>             ajStrAssignS(db, prefix);
16608,16619c18943,18954
< 	ajStrTokenNextParse(&handle, id);
< 	ajStrAssignClear(acc);
< 	ajStrAssignS(desc, reststr);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>         ajStrTokenNextParse(seqHandle, id);
>         ajStrAssignClear(acc);
>         ajStrAssignS(desc, reststr);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
16621c18956
< 	return ajTrue;
---
>         return ajTrue;
16626,16627c18961
< 	/* ajDebug("gnl or pat prefix\n"); */
< 	ajStrTokenNextParse(&handle, &token);
---
>         /* ajDebug("gnl or pat prefix\n"); */
16629,16641c18963,18965
< 	   ajStrAssignS(db, token);
< 	ajStrTokenNextParse(&handle, id);
< 	ajStrAssignClear(acc);		/* no accession number */
< 	ajStrAssignS(desc, reststr);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>             ajStrTokenNextParse(seqHandle, db);
>         else
>             ajStrTokenStep(seqHandle);
16643c18967,18980
< 	return ajTrue;
---
>         ajStrTokenNextParse(seqHandle, id);
>         ajStrAssignClear(acc);          /* no accession number */
>         ajStrAssignS(desc, reststr);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDel(&seqToken);
>         ajStrTokenReset(seqHandle);
> 
>         return ajTrue;
16649c18986
< 	ajStrAssignS(db, prefix);
---
>         ajStrAssignS(db, prefix);
16651c18988,18994
< 	ajStrTokenNextParse(&handle, id);
---
>         ajStrTokenNextParse(seqHandle, id);
> 
>         if(ajStrTokenNextParse(seqHandle, &seqToken))
>         {
>             /* chain identifier to append */
>             ajStrAppendS(id, seqToken);
>         }
16653,16669c18996,19006
< 	if(ajStrTokenNextParse(&handle, &token))
< 	{
< 	    /* chain identifier to append */
< 	    ajStrAppendS(id, token);
< 	}
< 
< 	ajStrAssignClear(acc);		/* no accession number */
< 	ajStrAssignS(desc, reststr);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>         ajStrAssignClear(acc);          /* no accession number */
>         ajStrAssignS(desc, reststr);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
16671c19008
< 	return ajTrue;
---
>         return ajTrue;
16680,16707c19017,19033
< 	ajStrAssignS(db, prefix);
< 	ajStrTokenNextParse(&handle, &token);
< 	vacc = ajSeqtestIsSeqversion(token);
< 
< 	if(vacc)
< 	{
< 	    ajStrAssignS(sv,token);
< 	    ajStrAssignS(acc,vacc);
< 	}
< 	else if(ajSeqtestIsAccession(token))
< 	    ajStrAssignS(acc,token);
< 
< 	if(!ajStrTokenNextParse(&handle, id))
< 	{
< 	    /* no ID, reuse accession token */
< 	    ajStrAssignS(id, token);
< 	}
< 
< 	ajStrAssignS(desc, reststr);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>         ajStrAssignS(db, prefix);
>         ajStrTokenNextParse(seqHandle, &seqToken);
>         vacc = ajSeqtestIsSeqversion(seqToken);
> 
>         if(vacc)
>         {
>             ajStrAssignS(sv,seqToken);
>             ajStrAssignS(acc,vacc);
>         }
>         else if(ajSeqtestIsAccession(seqToken))
>             ajStrAssignS(acc,seqToken);
> 
>         if(!ajStrTokenNextParse(seqHandle, id))
>         {
>             /* no ID, reuse accession token */
>             ajStrAssignS(id, seqToken);
>         }
16709c19035,19046
< 	return ajTrue;
---
>         ajStrAssignS(desc, reststr);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
> 
>         return ajTrue;
16715c19052
< 	ajStrAssignS(db, prefix);
---
>         ajStrAssignS(db, prefix);
16717,16728c19054,19065
< 	ajStrTokenNextParse(&handle, id);
< 	ajStrAssignS(desc, reststr);
< 	ajStrAssignClear(acc);
< 	/* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
< 	   prefix, *id, *acc, *desc); */
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>         ajStrTokenNextParse(seqHandle, id);
>         ajStrAssignS(desc, reststr);
>         ajStrAssignClear(acc);
>         /* ajDebug("found pref: '%S' id: '%S', acc: '%S' desc: '%S'\n",
>            prefix, *id, *acc, *desc); */
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
16730c19067
< 	return ajTrue;
---
>         return ajTrue;
16741c19078
<       nt++;
---
>         nt++;
16747,16753c19084,19090
< 	ajStrDel(&str);
< 	ajStrDel(&idstr);
< 	ajStrDel(&reststr);
< 	ajStrDel(&prefix);
< 	ajStrDel(&numtoken);
< 	ajStrDel(&token);
< 	ajStrTokenDel(&handle);
---
>         ajStrDel(&str);
>         ajStrDel(&idstr);
>         ajStrDel(&reststr);
>         ajStrDel(&prefix);
>         ajStrDel(&numtoken);
>         ajStrDelStatic(&seqToken);
>         ajStrTokenReset(seqHandle);
16755c19092
< 	return ajFalse;
---
>         return ajFalse;
16760c19097
<     ajStrTokenAssignC(&handle,idstr,"|");
---
>     ajStrTokenAssignC(&seqHandle,idstr,"|");
16762,16763c19099,19100
<     for(i=0;i<nt-2;++i)
<       ajStrTokenNextParse(&handle, &token);
---
>     for(i=0;i<nt-3;++i)
>         ajStrTokenStep(seqHandle);
16765,16768c19102,19107
<     ajStrAssignS(db, token);
<     ajStrTokenNextParse(&handle, &token);
<     ajDebug("token acc: '%S'\n", token);
<     vacc = ajSeqtestIsSeqversion(token);
---
>     ajStrTokenNextParse(seqHandle, &seqToken);
>         
>     ajStrAssignS(db, seqToken);
>     ajStrTokenNextParse(seqHandle, &seqToken);
>     ajDebug("token acc: '%S'\n", seqToken);
>     vacc = ajSeqtestIsSeqversion(seqToken);
16772,16774c19111,19113
< 	ajStrAssignS(sv,token);
< 	ajStrAssignS(acc,vacc);
< 	ajStrAssignS(id,vacc);
---
>         ajStrAssignS(sv,seqToken);
>         ajStrAssignS(acc,vacc);
>         ajStrAssignS(id,vacc);
16776c19115
<     else if(ajSeqtestIsAccession(token))
---
>     else if(ajSeqtestIsAccession(seqToken))
16778,16779c19117,19118
<         ajStrAssignS(acc,token);
<         ajStrAssignS(id,token);
---
>         ajStrAssignS(acc,seqToken);
>         ajStrAssignS(id,seqToken);
16783c19122
<         ajStrAssignS(id,token);
---
>         ajStrAssignS(id,seqToken);
16785d19123
<     
16787c19125,19126
<     if(ajStrTokenNextParseC(&handle, " \n\t\r", &token))
---
> 
>     if(ajStrTokenNextParseC(seqHandle, " \n\t\r", &seqToken))
16789c19128
<        ajDebug("token id: '%S'\n", token);
---
>         ajDebug("token id: '%S'\n", seqToken);
16791,16792c19130,19131
<        if(ajStrGetLen(token))
< 	 ajStrAssignS(id,token);
---
>         if(ajStrGetLen(seqToken))
>             ajStrAssignS(id,seqToken);
16795c19134
<     ajStrTokenNextParseC(&handle, "\n\r", &token);
---
>     ajStrTokenStepC(seqHandle, "\n\r");
16797,16798c19136,19137
<     ajStrTokenDel(&handle);
<     ajStrDel(&token);
---
>     ajStrTokenReset(seqHandle);
>     ajStrDelStatic(&seqToken);
16807d19145
<     ajStrDel(&token);
16822a19161,19162
> **
> ** @release 6.1.0
16833c19173
< 	return ajFalse;
---
>         return ajFalse;
16855a19196,19197
> **
> ** @release 6.4.0
16860c19202
< 			    ajint ibegin, ajint iend, AjPSeq seq)
---
>                             ajint ibegin, ajint iend, AjPSeq seq)
16870c19212
< 	ajSeqinSetRange(seqin, ibegin, iend);
---
>         ajSeqinSetRange(seqin, ibegin, iend);
16876c19218
< 	ajSeqinSetNuc(seqin);
---
>         ajSeqinSetNuc(seqin);
16878c19220
< 	ajSeqinSetProt(seqin);
---
>         ajSeqinSetProt(seqin);
16884c19226
< 	return ajFalse;
---
>         return ajFalse;
16899a19242,19243
> **
> ** @release 1.8.0
16912c19256
< /* @func ajSeqsetGetFromUsa *****************************************
---
> /* @func ajSeqsetGetFromUsa ***************************************************
16918a19263,19264
> **
> ** @release 2.7.0
16935c19281
< 	return ajFalse;
---
>         return ajFalse;
16952a19299,19300
> **
> ** @release 2.4.0
16969,16972c19317,19320
< 	istart = i;
< 	iend = AJMIN(ilen-1, istart+iwidth-1);
< 	ajStrAssignSubS(&tmpstr, seq, istart, iend);
< 	ajFmtPrintAppS(textptr, "%S\n", tmpstr);
---
>         istart = i;
>         iend = AJMIN(ilen-1, istart+iwidth-1);
>         ajStrAssignSubS(&tmpstr, seq, istart, iend);
>         ajFmtPrintAppS(textptr, "%S\n", tmpstr);
16987a19336,19337
> **
> ** @release 4.0.0
17059a19410,19422
>     AJFREE(seqAppendFilter);
> 
>     ajStrTokenDel(&seqHandle);
>     ajStrTokenDel(&seqHandle2);
>     ajStrTokenDel(&seqHandleSplit);
> 
>     ajStrDel(&seqName);
>     ajStrDel(&seqChain);
>     ajStrDel(&seqToken);
>     ajStrDel(&seqToken2);
>     ajStrDel(&seqTokenSplit);
>     ajStrDel(&seqAppendTmpstr);
> 
17088a19452,19453
> **
> ** @release 6.4.0
17100c19465
< /* @func ajSeqinTypeGetQlinks ************************************************
---
> /* @func ajSeqinTypeGetQlinks *************************************************
17104a19470,19471
> **
> ** @release 6.4.0
17121a19489,19490
> **
> ** @release 1.0.0
17134c19503
< 	ajDebug( "  Accession: '%S'\n", thys->Acc);
---
>         ajDebug( "  Accession: '%S'\n", thys->Acc);
17137c19506
< 	ajDebug( "  Inputtype: '%S'\n", thys->Inputtype);
---
>         ajDebug( "  Inputtype: '%S'\n", thys->Inputtype);
17140c19509
< 	ajDebug( "  Description: '%S'\n", thys->Desc);
---
>         ajDebug( "  Description: '%S'\n", thys->Desc);
17143c19512
< 	ajDebug( "  Inseq len: %d\n", ajStrGetLen(thys->Inseq));
---
>         ajDebug( "  Inseq len: %d\n", ajStrGetLen(thys->Inseq));
17146c19515
< 	ajDebug( "     Rev: %B\n", thys->Rev);
---
>         ajDebug( "     Rev: %B\n", thys->Rev);
17149c19518
< 	ajDebug( "   Begin: %d\n", thys->Begin);
---
>         ajDebug( "   Begin: %d\n", thys->Begin);
17152c19521
< 	ajDebug( "     End: %d\n", thys->End);
---
>         ajDebug( "     End: %d\n", thys->End);
17155c19524
< 	ajDebug( "  Full name: '%S'\n", thys->Full);
---
>         ajDebug( "  Full name: '%S'\n", thys->Full);
17158c19527
< 	ajDebug( "  Date: '%S'\n", thys->Date);
---
>         ajDebug( "  Date: '%S'\n", thys->Date);
17161c19530
< 	ajDebug( "  Ufo: '%S'\n", thys->Ufo);
---
>         ajDebug( "  Ufo: '%S'\n", thys->Ufo);
17164c19533
< 	ajDebug( "  Fttable: exists\n");
---
>         ajDebug( "  Fttable: exists\n");
17167c19536
< 	ajDebug( "  Ftquery: exists\n");
---
>         ajDebug( "  Ftquery: exists\n");
17170c19539
< 	ajDebug( "  Entryname: '%S'\n", thys->Entryname);
---
>         ajDebug( "  Entryname: '%S'\n", thys->Entryname);
17173c19542
< 	ajDebug( "  DbSequence: '%S'\n", thys->DbSequence);
---
>         ajDebug( "  DbSequence: '%S'\n", thys->DbSequence);
17176c19545
< 	ajDebug( "  Features: %B\n", thys->Features);
---
>         ajDebug( "  Features: %B\n", thys->Features);
17179c19548
< 	ajDebug( "  IsNuc: %B\n", thys->IsNuc);
---
>         ajDebug( "  IsNuc: %B\n", thys->IsNuc);
17182c19551
< 	ajDebug( "  IsProt: %B\n", thys->IsProt);
---
>         ajDebug( "  IsProt: %B\n", thys->IsProt);
17185c19554
< 	ajDebug( "  SeqData: exists\n");
---
>         ajDebug( "  SeqData: exists\n");
17188c19557
< 	ajDebug( "  Documentation:...\n%S\n", thys->Doc);
---
>         ajDebug( "  Documentation:...\n%S\n", thys->Doc);
17201a19571,19572
> **
> ** @release 4.0.0
17235,17236c19606,19607
< 	thys->name[i] = ajStrNew();
< 	thys->str[i]  = ajStrNew();
---
>         thys->name[i] = ajStrNew();
>         thys->str[i]  = ajStrNew();
17254,17255c19625,19626
< {
<     SeqPStockholmdata thys = NULL;
---
>   {
>   SeqPStockholmdata thys = NULL;
17257c19628
<     AJNEW0(thys);
---
>   AJNEW0(thys);
17259,17274c19630,19645
<     thys->id  = ajStrNew();
<     thys->ac  = ajStrNew();
<     thys->de  = ajStrNew();
<     thys->au  = ajStrNew();
<     thys->al  = ajStrNew();
<     thys->tp  = ajStrNew();
<     thys->se  = ajStrNew();
<     thys->bm  = ajStrNew();
<     thys->dc  = ajStrNew();
<     thys->dr  = ajStrNew();
<     thys->cc  = ajStrNew();
<     thys->gs  = ajStrNew();
<     thys->ref = ajStrNew();
<     thys->sacons  = ajStrNew();
<     thys->sqcons  = ajStrNew();
<     thys->sscons  = ajStrNew();
---
>   thys->id  = ajStrNew();
>   thys->ac  = ajStrNew();
>   thys->de  = ajStrNew();
>   thys->au  = ajStrNew();
>   thys->al  = ajStrNew();
>   thys->tp  = ajStrNew();
>   thys->se  = ajStrNew();
>   thys->bm  = ajStrNew();
>   thys->dc  = ajStrNew();
>   thys->dr  = ajStrNew();
>   thys->cc  = ajStrNew();
>   thys->gs  = ajStrNew();
>   thys->ref = ajStrNew();
>   thys->sacons  = ajStrNew();
>   thys->sqcons  = ajStrNew();
>   thys->sscons  = ajStrNew();
17276,17277c19647,19648
<     return thys;
< }*/
---
>   return thys;
>   }*/
17287a19659,19660
> **
> ** @release 4.0.0
17297c19670
< 	return;
---
>         return;
17302c19675
< 	return;
---
>         return;
17323,17324c19696,19697
< 	ajStrDel(&pthis->name[i]);
< 	ajStrDel(&pthis->str[i]);
---
>         ajStrDel(&pthis->name[i]);
>         ajStrDel(&pthis->str[i]);
17347,17348c19720,19721
< {
<     SeqPStockholmdata pthis = NULL;
---
>   {
>   SeqPStockholmdata pthis = NULL;
17350,17354c19723,19744
<     if(!Pseq)
< 	return;
<     pthis = *Pseq;
<     if(!pthis)
< 	return;
---
>   if(!Pseq)
>   return;
>   pthis = *Pseq;
>   if(!pthis)
>   return;
> 
>   ajStrDel(&pthis->id);
>   ajStrDel(&pthis->ac);
>   ajStrDel(&pthis->de);
>   ajStrDel(&pthis->au);
>   ajStrDel(&pthis->al);
>   ajStrDel(&pthis->tp);
>   ajStrDel(&pthis->se);
>   ajStrDel(&pthis->bm);
>   ajStrDel(&pthis->dc);
>   ajStrDel(&pthis->dr);
>   ajStrDel(&pthis->cc);
>   ajStrDel(&pthis->gs);
>   ajStrDel(&pthis->ref);
>   ajStrDel(&pthis->sacons);
>   ajStrDel(&pthis->sqcons);
>   ajStrDel(&pthis->sscons);
17356,17371c19746
<     ajStrDel(&pthis->id);
<     ajStrDel(&pthis->ac);
<     ajStrDel(&pthis->de);
<     ajStrDel(&pthis->au);
<     ajStrDel(&pthis->al);
<     ajStrDel(&pthis->tp);
<     ajStrDel(&pthis->se);
<     ajStrDel(&pthis->bm);
<     ajStrDel(&pthis->dc);
<     ajStrDel(&pthis->dr);
<     ajStrDel(&pthis->cc);
<     ajStrDel(&pthis->gs);
<     ajStrDel(&pthis->ref);
<     ajStrDel(&pthis->sacons);
<     ajStrDel(&pthis->sqcons);
<     ajStrDel(&pthis->sscons);
---
>   AJFREE(*Pseq);
17373,17376c19748,19749
<     AJFREE(*Pseq);
< 
<     return;
< }*/
---
>   return;
>   }*/
17386a19760,19761
> **
> ** @release 4.0.0
17411,17414c19786,19789
< 	thys->name[i] = ajStrNew();
< 	thys->str[i]  = ajStrNew();
< 	thys->ss[i]   = ajStrNew();
< 	thys->sq[i]   = selexseqNew();
---
>         thys->name[i] = ajStrNew();
>         thys->str[i]  = ajStrNew();
>         thys->ss[i]   = ajStrNew();
>         thys->sq[i]   = selexseqNew();
17427a19803,19804
> **
> ** @release 4.0.0
17457,17466c19834,19835
< {
<     SeqPSelexdata thys = NULL;
< 
<     AJNEW0(thys);
<     thys->id = ajStrNew();
<     thys->ac = ajStrNew();
<     thys->de = ajStrNew();
<     thys->au = ajStrNew();
<     thys->cs = ajStrNew();
<     thys->rf = ajStrNew();
---
>   {
>   SeqPSelexdata thys = NULL;
17468,17471c19837,19848
<     thys->name = ajStrNew();
<     thys->str  = ajStrNew();
<     thys->ss   = ajStrNew();
<     thys->sq   = selexseqNew();
---
>   AJNEW0(thys);
>   thys->id = ajStrNew();
>   thys->ac = ajStrNew();
>   thys->de = ajStrNew();
>   thys->au = ajStrNew();
>   thys->cs = ajStrNew();
>   thys->rf = ajStrNew();
> 
>   thys->name = ajStrNew();
>   thys->str  = ajStrNew();
>   thys->ss   = ajStrNew();
>   thys->sq   = selexseqNew();
17473,17474c19850,19851
<     return thys;
< }*/
---
>   return thys;
>   }*/
17485a19863,19864
> **
> ** @release 4.1.0
17495c19874
< 	return;
---
>         return;
17516a19896,19897
> **
> ** @release 4.1.0
17529c19910
< 	return;
---
>         return;
17535,17538c19916,19919
< 	ajStrDel(&pthis->name[i]);
< 	ajStrDel(&pthis->str[i]);
< 	ajStrDel(&pthis->ss[i]);
< 	selexseqDel(&pthis->sq[i]);
---
>         ajStrDel(&pthis->name[i]);
>         ajStrDel(&pthis->str[i]);
>         ajStrDel(&pthis->ss[i]);
>         selexseqDel(&pthis->sq[i]);
17543,17546c19924,19927
< 	AJFREE(pthis->name);
< 	AJFREE(pthis->str);
< 	AJFREE(pthis->ss);
< 	AJFREE(pthis->sq);
---
>         AJFREE(pthis->name);
>         AJFREE(pthis->str);
>         AJFREE(pthis->ss);
>         AJFREE(pthis->sq);
17575,17576c19956,19957
< {
<     SeqPSelexdata pthis;
---
>   {
>   SeqPSelexdata pthis;
17578c19959
<     pthis = *Pseq;
---
>   pthis = *Pseq;
17580,17581c19961,19962
<     if(!Pseq || !pthis)
< 	return;
---
>   if(!Pseq || !pthis)
>   return;
17584,17587c19965,19968
<     ajStrDel(&pthis->name);
<     ajStrDel(&pthis->str);
<     ajStrDel(&pthis->ss);
<     selexseqDel(&pthis->sq);
---
>   ajStrDel(&pthis->name);
>   ajStrDel(&pthis->str);
>   ajStrDel(&pthis->ss);
>   selexseqDel(&pthis->sq);
17589,17594c19970,19975
<     ajStrDel(&pthis->id);
<     ajStrDel(&pthis->ac);
<     ajStrDel(&pthis->de);
<     ajStrDel(&pthis->au);
<     ajStrDel(&pthis->cs);
<     ajStrDel(&pthis->rf);
---
>   ajStrDel(&pthis->id);
>   ajStrDel(&pthis->ac);
>   ajStrDel(&pthis->de);
>   ajStrDel(&pthis->au);
>   ajStrDel(&pthis->cs);
>   ajStrDel(&pthis->rf);
17596,17597c19977,19978
<     AJFREE(pthis);
<     *Pseq = NULL;
---
>   AJFREE(pthis);
>   *Pseq = NULL;
17599,17600c19980,19981
<     return;
< }*/
---
>   return;
>   }*/
17616,17617c19997,19998
< {
<     SeqPSelexdata pthis;
---
>   {
>   SeqPSelexdata pthis;
17619c20000
<     pthis = selexdataNew();
---
>   pthis = selexdataNew();
17621,17646c20002,20027
<     ajStrAssignS(&pthis->id, thys->id);
<     ajStrAssignS(&pthis->ac, thys->ac);
<     ajStrAssignS(&pthis->de, thys->de);
<     ajStrAssignS(&pthis->au, thys->au);
<     ajStrAssignS(&pthis->cs, thys->cs);
<     ajStrAssignS(&pthis->rf, thys->rf);
<     ajStrAssignS(&pthis->name, thys->name);
<     ajStrAssignS(&pthis->str, thys->str);
<     ajStrAssignS(&pthis->ss, thys->ss);
< 
<     pthis->ga[0] = thys->ga[0];
<     pthis->ga[1] = thys->ga[1];
<     pthis->tc[0] = thys->tc[0];
<     pthis->tc[1] = thys->tc[1];
<     pthis->nc[0] = thys->nc[0];
<     pthis->nc[1] = thys->nc[1];
< 
<     ajStrAssignS(&pthis->sq->name, thys->sq->name);
<     ajStrAssignS(&pthis->sq->source, thys->sq->source);
<     ajStrAssignS(&pthis->sq->ac, thys->sq->ac);
<     ajStrAssignS(&pthis->sq->de, thys->sq->de);
< 
<     pthis->sq->wt    = thys->sq->wt;
<     pthis->sq->start = thys->sq->start;
<     pthis->sq->stop  = thys->sq->stop;
<     pthis->sq->len   = thys->sq->len;
---
>   ajStrAssignS(&pthis->id, thys->id);
>   ajStrAssignS(&pthis->ac, thys->ac);
>   ajStrAssignS(&pthis->de, thys->de);
>   ajStrAssignS(&pthis->au, thys->au);
>   ajStrAssignS(&pthis->cs, thys->cs);
>   ajStrAssignS(&pthis->rf, thys->rf);
>   ajStrAssignS(&pthis->name, thys->name);
>   ajStrAssignS(&pthis->str, thys->str);
>   ajStrAssignS(&pthis->ss, thys->ss);
> 
>   pthis->ga[0] = thys->ga[0];
>   pthis->ga[1] = thys->ga[1];
>   pthis->tc[0] = thys->tc[0];
>   pthis->tc[1] = thys->tc[1];
>   pthis->nc[0] = thys->nc[0];
>   pthis->nc[1] = thys->nc[1];
> 
>   ajStrAssignS(&pthis->sq->name, thys->sq->name);
>   ajStrAssignS(&pthis->sq->source, thys->sq->source);
>   ajStrAssignS(&pthis->sq->ac, thys->sq->ac);
>   ajStrAssignS(&pthis->sq->de, thys->sq->de);
> 
>   pthis->sq->wt    = thys->sq->wt;
>   pthis->sq->start = thys->sq->start;
>   pthis->sq->stop  = thys->sq->stop;
>   pthis->sq->len   = thys->sq->len;
17649,17650c20030,20031
<     return pthis;
< }*/
---
>   return pthis;
>   }*/
17662a20044,20045
> **
> ** @release 4.1.0
17681c20064
<       ajStrAssignS(&thys->Db, seqin->Input->Db);
---
>         ajStrAssignS(&thys->Db, seqin->Input->Db);
17687c20070
<       ajStrAssignS(&thys->Name, thys->Entryname);
---
>         ajStrAssignS(&thys->Name, thys->Entryname);
17694c20077
<         if(thys->Format) 
---
>         if(thys->Format)
17705c20088
<     
---
> 
17707,17708c20090,20102
< 	ajSeqType(thys);
<     
---
>         ajSeqType(thys);
> 
>     if(seqin->Circular)
>         thys->Circular = ajTrue;
> 
>     if(thys->Fttable)
>     {
>         if(thys->Circular)
>             ajFeattableSetCircular(thys->Fttable);
>         else if(ajFeattableIsCircular(thys->Fttable))
>             thys->Circular = ajTrue;
>     }
> 
17719a20114,20115
> **
> ** @release 6.4.0
17740a20137,20138
> **
> ** @release 6.4.0
17746c20144
<     AjPSeqAccess methoddata; 
---
>     AjPSeqAccess methoddata;
17764a20163,20164
> **
> ** @release 6.4.0
17770c20170
<     AjPSeqAccess methoddata; 
---
>     AjPSeqAccess methoddata;
17790,17801d20189
< /* @obsolete ajSeqMethodGetScope
< ** @rename ajSeqaccessMethodGetScope
< */
< 
< __deprecated ajuint ajSeqMethodGetScope(const AjPStr method)
< {
<     return ajSeqaccessMethodGetScope(method);
< }
< 
< 
< 
< 
17807a20196,20197
> **
> ** @release 6.4.0
17814c20204
<       return ajTrue;
---
>         return ajTrue;
17822,17833d20211
< /* @obsolete ajSeqMethodTest
< ** @rename ajSeqaccessMethodTest
< */
< 
< __deprecated AjBool ajSeqMethodTest(const AjPStr method)
< {
<     return ajSeqaccessMethodTest(method);
< }
< 
< 
< 
< 
17836c20214
< ** Tests whether a data input format termis known
---
> ** Tests whether a data input format term is known
17839a20218,20219
> **
> ** @release 6.4.0
17848,17849c20228,20229
< 	if(ajStrMatchCaseC(term, seqinFormatDef[i].Obo))
< 	    return ajTrue;
---
>         if(ajStrMatchC(term, seqinFormatDef[i].Obo))
>             return ajTrue;
17862a20243,20244
> **
> ** @release 6.4.0
17871,17872c20253,20254
< 	if(ajStrMatchCaseC(format, seqinFormatDef[i].Name))
< 	    return ajTrue;
---
>         if(ajStrMatchCaseC(format, seqinFormatDef[i].Name))
>             return ajTrue;
17875a20258,20290
> 
> 
> 
> 
> #ifdef AJ_COMPILE_DEPRECATED_BOOK
> #endif /* AJ_COMPILE_DEPRECATED_BOOK */
> 
> 
> 
> 
> #ifdef AJ_COMPILE_DEPRECATED
> /* @obsolete ajSeqMethodGetScope
> ** @rename ajSeqaccessMethodGetScope
> */
> 
> __deprecated ajuint ajSeqMethodGetScope(const AjPStr method)
> {
>     return ajSeqaccessMethodGetScope(method);
> }
> 
> 
> 
> 
> /* @obsolete ajSeqMethodTest
> ** @rename ajSeqaccessMethodTest
> */
> 
> __deprecated AjBool ajSeqMethodTest(const AjPStr method)
> {
>     return ajSeqaccessMethodTest(method);
> }
> 
> #endif /* AJ_COMPILE_DEPRECATED */
