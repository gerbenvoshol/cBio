/* HMMer's foundation.
 *
 * Contents:
 *    1. Exception and fatal error handling.
 *    2. Memory allocation/deallocation conventions.
 *    3. Standard banner for Easel miniapplications.
 *    4. Improved replacements for some C library functions.
 *    5. Portable drop-in replacements for nonstandard C functions.
 *    6. Additional string functions, esl_str*()
 *    7. File path/name manipulation, including tmpfiles.
 *    8. Typed comparison functions.
 *    9. Unit tests.
 *   10. Test driver.
 *   11. Examples.
 *   12. Copyright and license.
 */

/* HMMer */

/*** Start of inlined file: cm.c ***/
#include "esl_config.h"
#include "p7_config.h"
#include "config.h"

#include "easellib.h"
#include "hmmerlib.h"
#include "infernallib.h"

#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static int
integer_textwidth(long n)
{
  int w = (n < 0)? 1 : 0;
  while (n != 0) { n /= 10; w++; }
  return w;
}

/* Function: CreateCM(); CreateCMShell(); CreateCMBody()
 * Date:     SRE, Sat Jul 29 09:02:16 2000 [St. Louis]
 *
 * Purpose:  Create a covariance model, given the number of states
 *           and nodes that should be in it.
 *
 *           Allocation is usually one step: CreateCM(N, M).
 *
 *           In cmio.c, allocation is two-step: CreateCMShell()
 *           then CreateCMBody(cm, N, M). This way we can create
 *           a model, start storing header info in it (including M
 *           and N themselves), and only after we read M and N
 *           do we allocate the bulk of the model.
 *
 * Args:     nnodes  =  number of nodes in the model
 *           nstates = number of states in the model
 *
 * Returns:  ptr to allocated cm.
 *           Caller is responsible for free'ing the cm.
 */
CM_t *
CreateCM(int nnodes, int nstates, int clen, const ESL_ALPHABET *abc)
{
  CM_t *cm;

  cm = CreateCMShell();
  if (cm != NULL) CreateCMBody(cm, nnodes, nstates, clen, abc);
  return cm;
}
CM_t *
CreateCMShell(void)
{
  int status, z;
  CM_t *cm;

  ESL_ALLOC(cm, sizeof(CM_t));
				/* general information: added later */
  cm->abc    = NULL;

  cm->name      = NULL;
  cm->acc       = NULL;
  cm->desc      = NULL;
  cm->rf        = NULL;
  cm->consensus = NULL;
  cm->map       = NULL;
  cm->checksum  = 0;
				/* null model information */
  cm->null   = NULL;

				/* structural information */
  cm->M       = 0;
  cm->clen    = 0;
  cm->W       = 0;
  cm->W_setby = CM_W_SETBY_INIT;
  cm->sttype  = NULL;
  cm->ndidx   = NULL;
  cm->stid    = NULL;
  cm->cfirst  = NULL;
  cm->cnum    = NULL;
  cm->plast   = NULL;
  cm->pnum    = NULL;
				/* node->state map information */
  cm->nodes   = 0;
  cm->nodemap = NULL;
  cm->ndtype  = NULL;
				/* parameter information */
  cm->t          = NULL;
  cm->e          = NULL;
  cm->begin      = NULL;
  cm->end        = NULL;
  cm->tsc        = NULL;
  cm->esc        = NULL;
  cm->oesc       = NULL;
  cm->beginsc    = NULL;
  cm->endsc      = NULL;
  cm->itsc       = NULL;
  cm->iesc       = NULL;
  cm->ioesc      = NULL;
  cm->ibeginsc   = NULL;
  cm->iendsc     = NULL;

  cm->lmesc   = NULL;
  cm->rmesc   = NULL;
  cm->ilmesc  = NULL;
  cm->irmesc  = NULL;

  cm->flags    = 0;
  cm->offset   = 0;

  cm->el_selfsc = sreLOG2(DEFAULT_EL_SELFPROB);

  cm->qdbinfo      = NULL;
  cm->beta_W       = DEFAULT_BETA_W;     /* will be set when beta_W is read from cmfile */
  cm->tau          = DEFAULT_TAU;        /* 1E-7 the default tau  (tail loss for HMM banding) */
  cm->maxtau       = DEFAULT_MAXTAU;     /* 0.1  the default max tau during HMM band tightening */
  cm->null2_omega  = V1P0_NULL2_OMEGA;   /* will be redefined upon reading cmfile (if CM was created by Infernal version later than 1.0.2) */
  cm->null3_omega  = V1P0_NULL3_OMEGA;   /* will be redefined upon reading cmfile (if CM was created by Infernal version later than 1.0.2) */
  cm->cp9          = NULL;
  cm->Lcp9         = NULL;
  cm->Rcp9         = NULL;
  cm->Tcp9         = NULL;
  cm->cp9b         = NULL;
  cm->cp9map       = NULL;
  cm->root_trans   = NULL;
  cm->expA         = NULL;
  cm->smx          = NULL;
  cm->trsmx        = NULL;
  cm->hb_mx        = NULL;
  cm->hb_omx       = NULL;
  cm->hb_emx       = NULL;
  cm->hb_shmx      = NULL;
  cm->trhb_mx      = NULL;
  cm->trhb_omx     = NULL;
  cm->trhb_emx     = NULL;
  cm->trhb_shmx    = NULL;
  cm->nb_mx        = NULL;
  cm->nb_omx       = NULL;
  cm->nb_emx       = NULL;
  cm->nb_shmx      = NULL;
  cm->trnb_mx      = NULL;
  cm->trnb_omx     = NULL;
  cm->trnb_emx     = NULL;
  cm->trnb_shmx    = NULL;
  cm->cp9_mx       = NULL;
  cm->cp9_bmx      = NULL;
  cm->pbegin       = DEFAULT_PBEGIN; /* summed probability of internal local begin */
  cm->pend         = DEFAULT_PEND;   /* summed probability of internal local end */
  cm->mlp7         = NULL;
  cm->fp7          = NULL;

  for (z = 0; z < CM_p7_NEVPARAM; z++) cm->fp7_evparam[z]  = CM_p7_EVPARAM_UNSET;

  cm->ga       = 0.;  /* only valid if cm->flags & CMH_GA */
  cm->tc       = 0.;  /* only valid if cm->flags & CMH_TC */
  cm->nc       = 0.;  /* only valid if cm->flags & CMH_NC */
  cm->eff_nseq = 0.;
  cm->nseq     = 0;
  cm->clen     = 0;
  cm->ctime    = NULL;
  cm->comlog   = NULL;
  cm->emap     = NULL;
  cm->cmcons   = NULL;
  cm->trp      = NULL;

  return cm;

 ERROR:
  cm_Fail("CreateCMShell() Memory allocation error.\n");
  return NULL; /* never reached */
}

void
CreateCMBody(CM_t *cm, int nnodes, int nstates, int clen, const ESL_ALPHABET *abc)
{
  int status;
  int v;
								/* alphabet, only a reference */
  cm->abc    = abc;
				/* structural information */
  cm->M      = nstates;
  cm->nodes  = nnodes;
  cm->clen   = clen;

  CMAllocNullModel(cm);

  ESL_ALLOC(cm->sttype, (nstates+1) * sizeof(char));
  ESL_ALLOC(cm->ndidx,   nstates    * sizeof(int));
  ESL_ALLOC(cm->stid,   (nstates+1) * sizeof(char));
  ESL_ALLOC(cm->cfirst,  nstates    * sizeof(int));
  ESL_ALLOC(cm->cnum,    nstates    * sizeof(int));
  ESL_ALLOC(cm->plast,   nstates    * sizeof(int));
  ESL_ALLOC(cm->pnum,    nstates    * sizeof(int));
				/* node->state map information */
  ESL_ALLOC(cm->nodemap, nnodes  * sizeof(int));
  ESL_ALLOC(cm->ndtype,  nnodes  * sizeof(char));

  if((cm->qdbinfo = CreateCMQDBInfo(nstates, clen)) == NULL) goto ERROR;

  /* parameter information */
  /* level 1 */
  ESL_ALLOC(cm->t,      (nstates) * sizeof(float *));
  ESL_ALLOC(cm->e,      (nstates) * sizeof(float *));
  ESL_ALLOC(cm->tsc,    (nstates) * sizeof(float *));
  ESL_ALLOC(cm->esc,    (nstates) * sizeof(float *));
  ESL_ALLOC(cm->lmesc,  (nstates) * sizeof(float *));
  ESL_ALLOC(cm->rmesc,  (nstates) * sizeof(float *));
  ESL_ALLOC(cm->itsc,   (nstates) * sizeof(int *));
  ESL_ALLOC(cm->iesc,   (nstates) * sizeof(int *));
  ESL_ALLOC(cm->ilmesc, (nstates) * sizeof(int *));
  ESL_ALLOC(cm->irmesc, (nstates) * sizeof(int *));
  cm->t[0]      = NULL;
  cm->e[0]      = NULL;
  cm->tsc[0]    = NULL;
  cm->esc[0]    = NULL;
  cm->lmesc[0]  = NULL;
  cm->rmesc[0]  = NULL;
  cm->itsc[0]   = NULL;
  cm->iesc[0]   = NULL;
  cm->ilmesc[0] = NULL;
  cm->irmesc[0] = NULL;
  ESL_ALLOC(cm->begin,      (nstates) * sizeof(float));
  ESL_ALLOC(cm->end,        (nstates) * sizeof(float));
  ESL_ALLOC(cm->beginsc,    (nstates) * sizeof(float));
  ESL_ALLOC(cm->endsc,      (nstates) * sizeof(float));
  ESL_ALLOC(cm->ibeginsc,   (nstates) * sizeof(int));
  ESL_ALLOC(cm->iendsc,     (nstates) * sizeof(int));
  /* don't allocate for cm->oesc and cm->ioesc yet, they're
   * alloc'ed and filled by CalcOptimizedEmitScores() called
   * in CMLogoddsify().
   */

  /* level 2 */
  ESL_ALLOC(cm->t[0],      MAXCONNECT  * nstates              * sizeof(float));
  ESL_ALLOC(cm->e[0],      cm->abc->K  * cm->abc->K * nstates * sizeof(float));
  ESL_ALLOC(cm->tsc[0],    MAXCONNECT  * nstates              * sizeof(float));
  ESL_ALLOC(cm->esc[0],    cm->abc->K  * cm->abc->K * nstates * sizeof(float));
  ESL_ALLOC(cm->lmesc[0],  cm->abc->Kp * nstates              * sizeof(float));
  ESL_ALLOC(cm->rmesc[0],  cm->abc->Kp * nstates              * sizeof(float));
  ESL_ALLOC(cm->itsc[0],   MAXCONNECT  * nstates              * sizeof(int));
  ESL_ALLOC(cm->iesc[0],   cm->abc->K  * cm->abc->K * nstates * sizeof(int));
  ESL_ALLOC(cm->ilmesc[0], cm->abc->Kp * nstates              * sizeof(int));
  ESL_ALLOC(cm->irmesc[0], cm->abc->Kp * nstates              * sizeof(int));
  for (v = 0; v < nstates; v++)
	{
	  cm->e[v]      = cm->e[0]      + v * (cm->abc->K * cm->abc->K);
	  cm->t[v]      = cm->t[0]      + v * MAXCONNECT;
	  cm->tsc[v]    = cm->tsc[0]    + v * MAXCONNECT;
	  cm->esc[v]    = cm->esc[0]    + v * (cm->abc->K * cm->abc->K);
	  cm->lmesc[v]  = cm->lmesc[0]  + v * cm->abc->Kp;
	  cm->rmesc[v]  = cm->rmesc[0]  + v * cm->abc->Kp;
	  cm->iesc[v]   = cm->iesc[0]   + v * (cm->abc->K * cm->abc->K);
	  cm->itsc[v]   = cm->itsc[0]   + v * MAXCONNECT;
	  cm->ilmesc[v] = cm->ilmesc[0] + v * cm->abc->Kp;
	  cm->irmesc[v] = cm->irmesc[0] + v * cm->abc->Kp;
	}

  /* Zero model */

  CMZero(cm);

  /* the EL state at M is special: we only need state
   * type info recorded, so functions looking at parsetrees
   * can interpret what an "M" index means.
   */
  cm->sttype[cm->M] = EL_st;
  cm->stid[cm->M]   = END_EL;

  /* don't modify cm->flags nor cm->offset, they may have been updated prior to this
   * call, i.e. when reading a CM from a file */
  cm->config_opts   = 0;
  cm->align_opts    = 0;
  cm->search_opts   = 0;
  cm->cp9           = NULL;
  cm->Lcp9          = NULL;
  cm->Rcp9          = NULL;
  cm->Tcp9          = NULL;
  cm->cp9b          = NULL;
  cm->cp9map        = NULL;

  /* we'll allocate all matrices and all cp9 related data structuers
   * inside cm_Configure(), we need some more info about the
   * CM besides M and nnodes to build those
   */

  /* Optional allocation, status flag dependent */
  if (cm->flags & CMH_RF)    ESL_ALLOC(cm->rf,          (cm->clen+2) * sizeof(char));
  if (cm->flags & CMH_CONS)  ESL_ALLOC(cm->consensus,   (cm->clen+2) * sizeof(char));
  if (cm->flags & CMH_MAP)   ESL_ALLOC(cm->map,         (cm->clen+1) * sizeof(int));

  return;

 ERROR:
  cm_Fail("CreateCMBody(), memory allocation error.");
  return; /* never reached */
}

/* Function: CMZero()
 * Date:     SRE, Mon Jul 31 19:14:31 2000 [St. Louis]
 *
 * Purpose:  Initialize the probability parameters and scores of a CM to zero.
 *
 * Returns:  (void)
 */
void
CMZero(CM_t *cm)
{
  int v;			/* counter over states                 */

  for (v = 0; v < cm->M; v++) {
	esl_vec_FSet(cm->e[v],      (cm->abc->K * cm->abc->K), 0.);
	esl_vec_FSet(cm->t[v],      MAXCONNECT,                0.);
	esl_vec_FSet(cm->tsc[v],    MAXCONNECT,                0.);
	esl_vec_FSet(cm->esc[v],    (cm->abc->K * cm->abc->K), 0.);
	esl_vec_FSet(cm->lmesc[v],  cm->abc->Kp,               0.);
	esl_vec_FSet(cm->rmesc[v],  cm->abc->Kp,               0.);
	esl_vec_ISet(cm->itsc[v],   MAXCONNECT,                0);
	esl_vec_ISet(cm->iesc[v],   (cm->abc->K * cm->abc->K), 0);
	esl_vec_ISet(cm->ilmesc[v], cm->abc->Kp,               0);
	esl_vec_ISet(cm->irmesc[v], cm->abc->Kp,               0);
  }
  esl_vec_FSet(cm->begin,      cm->M, 0.);
  esl_vec_FSet(cm->end,        cm->M, 0.);
  esl_vec_FSet(cm->beginsc,    cm->M, 0.);
  esl_vec_FSet(cm->endsc,      cm->M, 0.);
  esl_vec_ISet(cm->ibeginsc,   cm->M, 0);
  esl_vec_ISet(cm->iendsc,     cm->M, 0);
}

/* Function:  CMRenormalize()
 * Incept:    SRE, Wed Aug 14 14:16:55 2002 [St. Louis]
 *
 * Purpose:   Renormalize all the probability distributions in a CM.
 *            Used by cmio.c's flatfile parser, for example.
 *
 * Xref:      STL6 p.108
 */
void
CMRenormalize(CM_t *cm)
{
  int v;

  esl_vec_FNorm(cm->null, cm->abc->K);
  for (v = 0; v < cm->M; v++)
	{
	  if (cm->cnum[v] > 0 && cm->sttype[v] != B_st)
	esl_vec_FNorm(cm->t[v], cm->cnum[v]);

	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st || cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	esl_vec_FNorm(cm->e[v], cm->abc->K);
	  if (cm->sttype[v] == MP_st)
	esl_vec_FNorm(cm->e[v], cm->abc->K * cm->abc->K);
	}
  if (cm->flags & CMH_LOCAL_BEGIN) esl_vec_FNorm(cm->begin, cm->M);
  if (cm->flags & CMH_LOCAL_END)   cm_Fail("Renormalization of models in local end mode not supported yet");
}

/* Function: FreeCM()
 * Date:     SRE, Sat Jul 29 11:22:32 2000 [St. Louis]
 *
 * Purpose:  Free a CM data structure.
 *
 * Args:     cm - the model to free. (duh).
 *
 * Note:      Remember, leave reference pointer to abc alone.
 *            This is under the application's control not ours.
 *
 * Returns:  (void)
 */
void
FreeCM(CM_t *cm)
{
  int i;

  if (cm->smx       != NULL) cm_scan_mx_Destroy   (cm, cm->smx);   /* free this early, it needs some info from cm->stid */
  if (cm->trsmx     != NULL) cm_tr_scan_mx_Destroy(cm, cm->trsmx); /* ditto */

  if (cm->name      != NULL) free(cm->name);
  if (cm->acc       != NULL) free(cm->acc);
  if (cm->desc      != NULL) free(cm->desc);
  if (cm->rf        != NULL) free(cm->rf);
  if (cm->consensus != NULL) free(cm->consensus);
  if (cm->map       != NULL) free(cm->map);
  if (cm->null      != NULL) free(cm->null);

  free(cm->sttype);
  free(cm->ndidx);
  free(cm->stid);
  free(cm->cfirst);
  free(cm->cnum);
  free(cm->plast);
  free(cm->pnum);
  free(cm->nodemap);
  free(cm->ndtype);

  if (cm->lmesc   != NULL) { free(cm->lmesc[0]);  free(cm->lmesc); }
  if (cm->rmesc   != NULL) { free(cm->rmesc[0]);  free(cm->rmesc); }
  if (cm->ilmesc  != NULL) { free(cm->ilmesc[0]); free(cm->ilmesc); }
  if (cm->irmesc  != NULL) { free(cm->irmesc[0]); free(cm->irmesc); }

  if(cm->t != NULL) {
	if(cm->t[0] != NULL) free(cm->t[0]);
	free(cm->t);
  }
  if(cm->e != NULL) {
	if(cm->e[0] != NULL) free(cm->e[0]);
	free(cm->e);
  }
  if(cm->tsc != NULL) {
	if(cm->tsc[0] != NULL) free(cm->tsc[0]);
	free(cm->tsc);
  }
  if(cm->esc != NULL) {
	if(cm->esc[0] != NULL) free(cm->esc[0]);
	free(cm->esc);
  }
  if(cm->itsc != NULL) {
	if(cm->itsc[0] != NULL) free(cm->itsc[0]);
	free(cm->itsc);
  }
  if(cm->iesc != NULL) {
	if(cm->iesc[0] != NULL) free(cm->iesc[0]);
	free(cm->iesc);
  }
  if(cm->begin      != NULL) free(cm->begin);
  if(cm->end        != NULL) free(cm->end);
  if(cm->beginsc    != NULL) free(cm->beginsc);
  if(cm->endsc      != NULL) free(cm->endsc);
  if(cm->ibeginsc   != NULL) free(cm->ibeginsc);
  if(cm->iendsc     != NULL) free(cm->iendsc);

  if(cm->ctime      != NULL) free(cm->ctime);
  if(cm->comlog     != NULL) free(cm->comlog);
  if(cm->qdbinfo    != NULL) FreeCMQDBInfo(cm->qdbinfo);
  if(cm->cp9map     != NULL) FreeCP9Map(cm->cp9map);
  if(cm->cp9b       != NULL) FreeCP9Bands(cm->cp9b);
  if(cm->cp9        != NULL) FreeCPlan9(cm->cp9);
  if(cm->Lcp9       != NULL) FreeCPlan9(cm->Lcp9);
  if(cm->Rcp9       != NULL) FreeCPlan9(cm->Rcp9);
  if(cm->Tcp9       != NULL) FreeCPlan9(cm->Tcp9);
  if(cm->root_trans != NULL) free(cm->root_trans);
  if(cm->hb_mx      != NULL) cm_hb_mx_Destroy(cm->hb_mx);
  if(cm->hb_omx     != NULL) cm_hb_mx_Destroy(cm->hb_omx);
  if(cm->hb_emx     != NULL) cm_hb_emit_mx_Destroy(cm->hb_emx);
  if(cm->hb_shmx    != NULL) cm_hb_shadow_mx_Destroy(cm->hb_shmx);
  if(cm->trhb_mx    != NULL) cm_tr_hb_mx_Destroy(cm->trhb_mx);
  if(cm->trhb_omx   != NULL) cm_tr_hb_mx_Destroy(cm->trhb_omx);
  if(cm->trhb_emx   != NULL) cm_tr_hb_emit_mx_Destroy(cm->trhb_emx);
  if(cm->trhb_shmx  != NULL) cm_tr_hb_shadow_mx_Destroy(cm->trhb_shmx);
  if(cm->nb_mx      != NULL) cm_mx_Destroy(cm->nb_mx);
  if(cm->nb_omx     != NULL) cm_mx_Destroy(cm->nb_omx);
  if(cm->nb_emx     != NULL) cm_emit_mx_Destroy(cm->nb_emx);
  if(cm->nb_shmx    != NULL) cm_shadow_mx_Destroy(cm->nb_shmx);
  if(cm->trnb_mx    != NULL) cm_tr_mx_Destroy(cm->trnb_mx);
  if(cm->trnb_omx   != NULL) cm_tr_mx_Destroy(cm->trnb_omx);
  if(cm->trnb_emx   != NULL) cm_tr_emit_mx_Destroy(cm->trnb_emx);
  if(cm->trnb_shmx  != NULL) cm_tr_shadow_mx_Destroy(cm->trnb_shmx);
  if(cm->cp9_mx     != NULL) FreeCP9Matrix(cm->cp9_mx);
  if(cm->cp9_bmx    != NULL) FreeCP9Matrix(cm->cp9_bmx);
  if(cm->oesc != NULL || cm->ioesc != NULL) FreeOptimizedEmitScores(cm->oesc, cm->ioesc, cm->M);

  if(cm->expA != NULL) {
	for(i = 0; i < EXP_NMODES;  i++) {
	  free(cm->expA[i]);
	}
	free(cm->expA);
  }

  if(cm->mlp7 != NULL) {
	p7_hmm_Destroy(cm->mlp7);
	if(cm->fp7 == cm->mlp7) cm->fp7 = NULL;
	cm->mlp7 = NULL;
  }
  if(cm->fp7  != NULL) {
	p7_hmm_Destroy(cm->fp7);
	cm->fp7  = NULL;
  }
  if(cm->emap   != NULL) FreeEmitMap(cm->emap);
  if(cm->cmcons != NULL) FreeCMConsensus(cm->cmcons);
  if(cm->trp    != NULL) cm_tr_penalties_Destroy(cm->trp);

  free(cm);
}

/* Function: DefaultNullModel()
 * Date:     SRE, Tue Aug  1 15:31:52 2000 [St. Louis]
 *
 * Purpose:  Allocate and initialize a float vector
 *           that will be a template null model to
 *           equiprobable (e.g. 0.25)
 */
int
DefaultNullModel(const ESL_ALPHABET *abc, float **ret_null)
{
  /* Contract check */
  if(abc      == NULL) cm_Fail("ERROR in CMCreateNullModel, cm->abc is NULL.\n");

  int status;
  float *null = NULL;
  ESL_ALLOC(null, sizeof(float) * abc->K);
  int x;
  for (x = 0; x < abc->K; x++)
	null[x] = 1./(float) abc->K;
  esl_vec_FNorm(null, abc->K); /* completely unnecessary */
  *ret_null = null;
  return eslOK;

 ERROR:
  if(null != NULL) free(null);
  return status;
}

/* Function: CMAllocNullModel()
 *
 * Purpose:  Allocate the null model section of a CM
 *           and fill it with default, equiprobable
 *           null distro.
 */
int
CMAllocNullModel(CM_t *cm)
{
  int status;

  /* Contract check */
  if(cm->abc  == NULL) cm_Fail("ERROR in CMAllocNullModel, cm->abc is NULL.\n");
  if(cm->null != NULL) cm_Fail("ERROR in CMAllocNullModel, cm->null is not NULL.\n");

  status = DefaultNullModel(cm->abc, &(cm->null));
  return status;
}

/* Function: CMSetNullModel()
 *
 * Purpose:  Set the null model section of a CM.
 */
void
CMSetNullModel(CM_t *cm, float *null)
{
  /* Contract check */
  if(cm->abc  == NULL) cm_Fail("ERROR in CMCreateNullModel, cm->abc is NULL.\n");
  if(cm->null == NULL) cm_Fail("ERROR in CMSetNullModel, cm->null is NULL.\n");

  int x;
  for (x = 0; x < cm->abc->K; x++)
	cm->null[x] = null[x];
  esl_vec_FNorm(cm->null, cm->abc->K);
  return;
}

/* Function: CMReadNullModel()
 * EPN 10.19.05
 * based on SRE's HMMER's cm.c's P7ReadNullModel()
 *
 * Purpose:  Read a CM null model from a file.
 *           ret_null is filled with a newly allocated
 *           float vector that is the null model.
 *
 * Returns:  eslOK on success.
 */
int
CMReadNullModel(const ESL_ALPHABET *abc, char *nullfile, float **ret_null)
{
  /* Contract check */
  if(abc  == NULL) cm_Fail("ERROR in CMReadNullModel, abc is NULL.\n");

  int status;
  float *null = NULL;
  FILE *fp;
  char *buf = NULL;
  char *s;
  int   n;			/* length of buf */
  int   x;
  char *tok;
  float sum;

  ESL_ALLOC(null, sizeof(float) * abc->K);
  n   = 0;
  sum = 0.;
  /* Expects a file with cm->abc->K lines that don't begin with "# ".
   * The first token of each of these 4 lines is read as
   * the background probability of A, C, G, and U (in that order)
   * Then does a check to make sure the 4 read in values
   * sum to 1.0 exactly.
   */
  if ((fp = fopen(nullfile, "r")) == NULL)
	cm_Fail("Failed to open null model file %s\n", nullfile);

  /* parse the file */
  x = 0;
  while(x < abc->K) {
	if((status = esl_fgets(&buf, &n, fp)) != eslOK) goto ERROR;
	s   = buf;
	if((status = esl_strtok(&s, " \t\n", &tok)) != eslOK) goto ERROR;
	if(strcmp(tok, "#") != 0)
	  {
	null[x] = atof(tok);
	sum += null[x];
	x++;
	  }
  }
  /*fragile*/
  if(sum > 1.00001 || sum < 0.99999)
	cm_Fail("%s is not in CM null model file format.\nThere are not %d background probabilities that sum to exactly 1.0", nullfile, abc->K);
  esl_vec_FNorm(null, abc->K);

  *ret_null = null;
  if(buf  != NULL) free(buf);
  fclose(fp);
  return eslOK;

 ERROR:
  fclose(fp);
  if(buf  != NULL) free(buf);
  if(null != NULL) free(null);
  return status;
}

/* Function: CMSimpleProbify()
 * Date:     SRE, Tue Aug  1 11:07:17 2000 [St. Louis]
 *
 * Purpose:  Convert a counts-based CM to probability form, using
 *           a plus-one Laplace prior.
 */
void
CMSimpleProbify(CM_t *cm)
{
  int v,x;

  for (v = 0; v < cm->M; v++)
	{
	  /* Transitions. B, E have no transition probabilities.
	   */
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	{
	  for (x = 0; x < cm->cnum[v]; x++) cm->t[v][x] += 1.0; /* Laplace prior */
	  esl_vec_FNorm(cm->t[v], cm->cnum[v]);	                        /* normalize to a probability */
	}

	  /* Emissions.
	   */
	  if (cm->sttype[v] == MP_st)
	{
	  for (x = 0; x < cm->abc->K*cm->abc->K; x++) cm->e[v][x] += 1.0;
	  esl_vec_FNorm(cm->e[v], cm->abc->K*cm->abc->K);
	}
	  else if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st ||
	       cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	{
	  for (x = 0; x < cm->abc->K; x++) cm->e[v][x] += 1.0;
	  esl_vec_FNorm(cm->e[v], cm->abc->K);
	}
	}
}

/* Function: rsearch_CMProbifyEmissions()
 * Date:     EPN, Wed Mar 14 06:14:51 2007
 *
 * Purpose:  Convert emissions in a counts-based CM built from a single sequence,
 *           we expect 1 count in each vector to be 1.0, all others 0.0,
 *           to probability form, using a RIBOSUM matrix with background
 *           and target frequencies.
 *
 *           The code that does this in RSEARCH is buildcm.c::SingleSequenceLogoddsify(),
 *           but that's different in that it fills in log odds scores, here we
 *           fill in probabilities, derived from the RIBOSUM log odds scores.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEINVAL> if an emission vector does not have exactly 1 non-zero
 *                        count that is exactly 1.0 (or within 0.000001 of it)
 */
int
rsearch_CMProbifyEmissions(CM_t *cm, fullmat_t *fullmat)
{
  int v,x,y;
  int cur_emission;
  float thresh;
  int found_ct_flag;
  thresh = 0.000001;

  /* Check the contract. */
  if(fullmat->scores_flag) ESL_EXCEPTION(eslEINVAL, "in rsearch_CMProbifyEmissions(), matrix is in log odds mode, it should be in probs mode");
  if(!(cm->flags & CM_RSEARCHEMIT)) ESL_EXCEPTION(eslEINVAL, "in rsearch_CMProbifyEmissions(), CM_RSEARCHEMIT flag is down");

  for (v = 0; v < cm->M; v++)
	{
	  found_ct_flag = FALSE;
	  if (cm->stid[v] == MATP_MP)
	{
	  /* First, figure out which letter was in the query */

	  for (x=0; x<cm->abc->K; x++)
	    for (y=0; y<cm->abc->K; y++)
	      if (fabs(cm->e[v][x*cm->abc->K+y] - 0.) > thresh)
		{
		  if(found_ct_flag)
		    {
		      for (x=0; x<cm->abc->K; x++)
			for (y=0; y<cm->abc->K; y++)
			  printf("cm->e[v:%d][%d]: %f\n", v, (x*cm->abc->K+y), cm->e[v][(x*cm->abc->K+y)]);
		      ESL_EXCEPTION(eslEINVAL, "cm->e[v:%d] a MATP_MP has > 1 non-zero count", v);
		    }
		  cur_emission = numbered_basepair(cm->abc->sym[x], cm->abc->sym[y]);
		  found_ct_flag = TRUE;
		}
	  /* Now, set emission probs as target probs in correct cells of score matrix */
	  for (x=0; x<cm->abc->K*cm->abc->K; x++)
	    cm->e[v][x] = fullmat->paired->matrix[matrix_index(cur_emission, x)];
	  esl_vec_FNorm(cm->e[v], cm->abc->K*cm->abc->K);
	}
	  else if (cm->stid[v] == MATL_ML || cm->stid[v] == MATR_MR)
	{
	  for (x=0; x<cm->abc->K; x++)
	    if (fabs(cm->e[v][x] - 0.) > thresh)
		{
		  if(found_ct_flag) {
		    for (y=0; y<cm->abc->K; y++) printf("cm->e[v:%d][%d]: %f\n", v, x, cm->e[v][x]);
		    ESL_EXCEPTION(eslEINVAL, "cm->e[v:%d] a MAT{L,R}_M{L,R} has > 1 non-zero count", v);
		  }
		  cur_emission = numbered_nucleotide(cm->abc->sym[x]);
		  found_ct_flag = TRUE;
		}
	  /* Now, set emission probs as target probs in correct cells of score matrix */
	  for (x=0; x<cm->abc->K; x++)
	    cm->e[v][x] = fullmat->unpaired->matrix[matrix_index(cur_emission, x)];
	  esl_vec_FNorm(cm->e[v], cm->abc->K);
	}
	  else if (cm->stid[v] == MATP_ML || cm->stid[v] == MATP_MR)
	{
	  /* RSEARCH technique: determine residue emitted to left and right,
	   * use target freqs from unpaired matrix for this residue.
	   * Alternative technique: determine residue emitted to left and right,
	   * marginalize target freqs from paired matrix for this residue.
	   * RSEARCH technique currently implemented */
	  for (x=0; x<cm->abc->K; x++)
	    for (y=0; y<cm->abc->K; y++)
	      {
		if (cm->stid[v] == MATP_ML && (fabs(cm->e[(v-1)][x*cm->abc->K + y] - 0.) > thresh))
		  cur_emission = numbered_nucleotide(cm->abc->sym[x]);
		else if (cm->stid[v] == MATP_MR && (fabs(cm->e[(v-2)][x*cm->abc->K + y] - 0.) > thresh))
		  cur_emission = numbered_nucleotide(cm->abc->sym[y]);
		/* We don't have to check we have only 1 non-zero count, we've already
		 * done so when we filled e for the MATP_MP in the same node as v */
	      }
	  /* fill emission probs */
	  for (x=0; x<cm->abc->K; x++)
	    cm->e[v][x] = fullmat->unpaired->matrix[matrix_index(cur_emission, x)];
	  esl_vec_FNorm(cm->e[v], cm->abc->K);
	}
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	{
	  /* Don't give any score for emissions matching to an Insert state,
	   * but make sure we don't have any counts in any of these guys */
	  for (x = 0; x < cm->abc->K; x++)
	    if(fabs(cm->e[v][x] - 0.) > thresh) ESL_EXCEPTION(eslEINVAL, "cm->e[v:%d] an I{L,R} has > 0 non-zero count", v);
	  esl_vec_FNorm(cm->e[v], cm->abc->K); /* these will have all been zero */
	}
	}
  return eslOK;
}

/* Function: CMLogoddsify()
 * Date:     SRE, Tue Aug  1 15:18:26 2000 [St. Louis]
 *
 * Purpose:  Convert the probabilities in a CM to log-odds.
 *           Then create consensus data in cm->cmcons.
 *
 * Returns:  eslOK on success; eslFAIL if we can't create
 *           cmcons.
 */
int
CMLogoddsify(CM_t *cm)
{
  /*printf("in CMLogoddsify()\n");*/
  int v, x, y;

  /* zero lmesc, rmesc, we'll sum up probs then convert to scores */
  esl_vec_FSet(cm->lmesc[0], cm->M * cm->abc->Kp, 0.);
  esl_vec_FSet(cm->rmesc[0], cm->M * cm->abc->Kp, 0.);

  for (v = 0; v < cm->M; v++) {
	/* fill in unused marginal scores */
	cm->lmesc[v][cm->abc->K]      = cm->rmesc[v][cm->abc->K]     = IMPOSSIBLE; /* gap */
	cm->lmesc[v][cm->abc->Kp-2]   = cm->rmesc[v][cm->abc->Kp-2]  = IMPOSSIBLE; /* no-residue '*' */
	cm->lmesc[v][cm->abc->Kp-1]   = cm->rmesc[v][cm->abc->Kp-1]  = IMPOSSIBLE; /* missing data */
	cm->ilmesc[v][cm->abc->K]     = cm->irmesc[v][cm->abc->K]    = -INFTY;   ; /* gap */
	cm->ilmesc[v][cm->abc->Kp-2]  = cm->irmesc[v][cm->abc->Kp-2] = -INFTY;   ; /* no-residue '*' */
	cm->ilmesc[v][cm->abc->Kp-1]  = cm->irmesc[v][cm->abc->Kp-1] = -INFTY;   ; /* missing data */

	if (cm->sttype[v] != B_st && cm->sttype[v] != E_st) {
	  for (x = 0; x < cm->cnum[v]; x++) {
	cm->tsc[v][x]  = sreLOG2(cm->t[v][x]);
	cm->itsc[v][x] = Prob2Score(cm->t[v][x], 1.0);
	/*printf("cm->t[%4d][%2d]: %f itsc->e: %f itsc: %d\n", v, x, cm->t[v][x], Score2Prob(cm->itsc[v][x], 1.0), cm->itsc[v][x]);*/
	  }
	}
	if (cm->sttype[v] == MP_st) {
	  for (x = 0; x < cm->abc->K; x++) {
	for (y = 0; y < cm->abc->K; y++) {
	  cm->esc[v][x*cm->abc->K+y]  = sreLOG2   (cm->e[v][x*cm->abc->K+y] / (cm->null[x]*cm->null[y]));
	  cm->iesc[v][x*cm->abc->K+y] = Prob2Score(cm->e[v][x*cm->abc->K+y],  (cm->null[x]*cm->null[y]));
	  /* printf("cm->e[%4d][%2d]: %f iesc->e: %f iesc: %d\n", v, (x*cm->abc->K+y), cm->e[v][(x*cm->abc->K+y)], Score2Prob(cm->iesc[v][x*cm->abc->K+y], (cm->null[x]*cm->null[y])), cm->iesc[v][(x*cm->abc->K+y)]); */
	  cm->lmesc[v][x] += cm->e[v][x*cm->abc->K+y];
	  cm->rmesc[v][y] += cm->e[v][x*cm->abc->K+y];
	}
	  }
	  for (x = 0; x < cm->abc->K; x++) {
	cm->ilmesc[v][x] = Prob2Score(cm->lmesc[v][x],  cm->null[x]);
	cm->irmesc[v][x] = Prob2Score(cm->rmesc[v][x],  cm->null[x]);
	cm->lmesc[v][x]  = sreLOG2   (cm->lmesc[v][x] / cm->null[x]);
	cm->rmesc[v][x]  = sreLOG2   (cm->rmesc[v][x] / cm->null[x]);
	  }
	  /* handle degeneracies */
	  esl_abc_FExpectScVec(cm->abc, cm->lmesc[v],  cm->null);
	  esl_abc_FExpectScVec(cm->abc, cm->rmesc[v],  cm->null);
	  esl_abc_IExpectScVec(cm->abc, cm->ilmesc[v], cm->null);
	  esl_abc_IExpectScVec(cm->abc, cm->irmesc[v], cm->null);
	}
	else if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st || cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	  for (x = 0; x < cm->abc->K; x++) {
	cm->esc[v][x]    = sreLOG2(cm->e[v][x] / cm->null[x]);
	cm->iesc[v][x]   = Prob2Score(cm->e[v][x], cm->null[x]);
	/*printf("cm->e[%4d][%2d]: %f esc: %f null[%d]: %f\n", v, x, cm->e[v][x], cm->esc[v][x], x, cm->null[x]);*/
	/*printf("cm->e[%4d][%2d]: %f iesc->e: %f iesc: %d\n", v, x, cm->e[v][x], Score2Prob(cm->iesc[v][x], (cm->null[x])), cm->iesc[v][x]);*/
	  }
	  /* handle marginals, differently for L and R states */
	  if(cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  cm->lmesc[v][x]  = cm->esc[v][x];
	  cm->ilmesc[v][x] = cm->iesc[v][x];
	  cm->rmesc[v][x]  = 0.;
	  cm->irmesc[v][x] = 0;
	}
	esl_abc_FExpectScVec(cm->abc, cm->lmesc[v],  cm->null);
	esl_abc_IExpectScVec(cm->abc, cm->ilmesc[v], cm->null);
	esl_vec_FSet(cm->rmesc[v]  + cm->abc->K+1, ((cm->abc->Kp-3) - cm->abc->K), 0.);
	esl_vec_ISet(cm->irmesc[v] + cm->abc->K+1, ((cm->abc->Kp-3) - cm->abc->K), 0);
	  }
	  else if(cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  cm->lmesc[v][x]  = 0.;
	  cm->ilmesc[v][x] = 0;
	  cm->rmesc[v][x]  = cm->esc[v][x];
	  cm->irmesc[v][x] = cm->iesc[v][x];
	}
	esl_vec_FSet(cm->lmesc[v]  + cm->abc->K+1, ((cm->abc->Kp-3) - cm->abc->K), 0.);
	esl_vec_ISet(cm->ilmesc[v] + cm->abc->K+1, ((cm->abc->Kp-3) - cm->abc->K), 0);
	esl_abc_FExpectScVec(cm->abc, cm->rmesc[v],  cm->null);
	esl_abc_IExpectScVec(cm->abc, cm->irmesc[v], cm->null);
	  }
	}

	/* These work even if begin/end distributions are inactive 0's,
	 * sreLOG2 will set beginsc, endsc to -infinity.
	 */
	cm->beginsc[v]    = sreLOG2(cm->begin[v]);
	cm->ibeginsc[v]   = Prob2Score(cm->begin[v], 1.0);
	/*printf("cm->begin[%4d]: %f ibeginsc->e: %f ibeginsc: %d\n", v, cm->begin[v], Score2Prob(cm->ibeginsc[v], 1.0), cm->ibeginsc[v]);*/

	cm->endsc[v]    = sreLOG2(cm->end[v]);
	cm->iendsc[v]   = Prob2Score(cm->end[v], 1.0);
	/*printf("cm->end[%4d]: %f iendsc->e: %f iendsc: %d\n\n", v, cm->end[v], Score2Prob(cm->iendsc[v], 1.0), cm->iendsc[v]);*/
  }

  cm->iel_selfsc = Prob2Score(sreEXP2(cm->el_selfsc), 1.0);
  /*printf("cm->el_selfsc: %f prob: %f cm->iel_selfsc: %d prob: %f\n", cm->el_selfsc,
	(sreEXP2(cm->el_selfsc)), cm->iel_selfsc, (Score2Prob(cm->iel_selfsc, 1.0)));
	printf("-INFTY: %d prob: %f 2^: %f\n", -INFTY, (Score2Prob(-INFTY, 1.0)), sreEXP2(-INFTY));*/

  /* Allocate and fill optimized emission scores for this CM.
   * If they already exist, free them and recalculate them, slightly wasteful, oh well.
   */
  if(cm->oesc != NULL || cm->ioesc != NULL) FreeOptimizedEmitScores(cm->oesc, cm->ioesc, cm->M);
  cm->oesc = FCalcOptimizedEmitScores(cm);
  /* EPN, Wed Aug 20 15:26:01 2008
   * old, slow way:
   * cm->ioesc = ICalcOptimizedEmitScores(cm);
   */
  cm->ioesc = ICopyOptimizedEmitScoresFromFloats(cm, cm->oesc);

  /* Potentially, overwrite transitions with non-probabilistic
   * RSEARCH transitions. Currently only default transition
   * parameters are allowed, these are defined as DEFAULT_R*
   * in infernal.h */
  if(cm->flags & CM_RSEARCHTRANS)
	{
	  float           alpha =   DEFAULT_RALPHA;
	  float           beta =    DEFAULT_RBETA;
	  float           alphap =  DEFAULT_RALPHAP;
	  float           betap =   DEFAULT_RBETAP;
	  float           beginsc = DEFAULT_RBEGINSC;
	  float           endsc =   DEFAULT_RENDSC;
	  int             nd;
	  /* First do the normal transitions */
	  for (v=0; v<cm->M; v++)
	{
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	    {
	      for (x=0; x<cm->cnum[v]; x++)
		{
		  cm->tsc[v][x] = -1. * rsearch_calculate_gap_penalty
		    (cm->stid[v], cm->stid[cm->cfirst[v]+x],
		     cm->ndtype[cm->ndidx[v]], cm->ndtype[cm->ndidx[cm->cfirst[v]+x]],
		     alpha, beta, alphap, betap);
		  /* alphas and rbetas were positive -- gap score is a penalty, so
		     multiply by -1 */
		  cm->itsc[v][x] = INTSCALE * cm->tsc[v][x];
		}
	    }
	}
	  /* Overwrite local begin and end scores */
	  for (v=cm->M - 1; v>=0; v--) {
	cm->beginsc[v]   = IMPOSSIBLE;
	cm->endsc[v] = IMPOSSIBLE;
	  }

	  /* beginsc states */
	  for (nd = 2; nd < cm->nodes; nd++) {
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	    cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BIF_nd)
	  {
	    cm->beginsc[cm->nodemap[nd]]  = beginsc;
	    cm->ibeginsc[cm->nodemap[nd]] = INTSCALE * beginsc;
	  }
	  }

	  /* endsc states */
	  for (nd = 1; nd < cm->nodes; nd++) {
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	     cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	     cm->ndtype[nd] == BEGR_nd) &&
	    cm->ndtype[nd+1] != END_nd)
	  {
	  cm->endsc[cm->nodemap[nd]] = endsc;
	  cm->iendsc[cm->nodemap[nd]] = INTSCALE * endsc;
	  }
	  }

	  cm->flags |= CMH_LOCAL_BEGIN;
	  cm->flags |= CMH_LOCAL_END;
	}

  /* raise flag saying we have valid log odds scores */
  cm->flags |= CMH_BITS;

  /* create cm->cmcons, we expect this to be valid if we have valid log odds score */
  if(cm->cmcons != NULL) FreeCMConsensus(cm->cmcons);
  if((cm->cmcons = CreateCMConsensus(cm, cm->abc)) == NULL) return eslFAIL;

  return eslOK;
}

/* Function: CountStatetype(), CMSubtreeCountStatetype(), CMSegmentCountStatetype
 * Date:     SRE, Wed Aug  2 09:15:00 2000 [St. Louis]
 *
 * Purpose:  Conveniences for counting the # of occurrences
 *           of a particular state type in a CM. Useful for
 *           "how many bifurcations does this model have", etc.
 *
 *           CMSubtreeCountStatetype() only counts underneath
 *           a particular subtree rooted at state v
 *
 * Args:     cm   - the model
 *           r    - the root of the subtree to start from (inclusive)
 *           z    - end of the subtree to stop at (inclusive)
 *           type - a state type (e.g. E_st or MP_st)
 *
 * Returns:  how many states of that type are in the model
 */
int
CMSegmentCountStatetype(CM_t *cm, int r, int z, char type)
{
  int count = 0;
  int v;
  for (v = r; v <= z; v++)
	if (cm->sttype[v] == type) count++;
  return count;
}
int
CMSubtreeCountStatetype(CM_t *cm, int v, char type)
{
  int unsatisfied_starts = 1;
  int count = 0;

  while (unsatisfied_starts) {
	if (cm->sttype[v] == B_st) unsatisfied_starts++;
	if (cm->sttype[v] == E_st) unsatisfied_starts--;
	if (cm->sttype[v] == type) count++;
	v++;
  }
  return count;
}
int
CMCountStatetype(CM_t *cm, char type)
{
  return CMSubtreeCountStatetype(cm, 0, type);
}
int
CMSubtreeFindEnd(CM_t *cm, int r)
{
  int unsatisfied_starts = 1;

  while (unsatisfied_starts) {
	if (cm->sttype[r] == B_st) unsatisfied_starts++;
	if (cm->sttype[r] == E_st) unsatisfied_starts--;
	r++;
  }
  return (r-1);
}
int
CMCountNodetype(CM_t *cm, char type)
{
  int nd;
  int count = 0;
  for(nd = 0; nd < cm->nodes; nd++) {
	if(cm->ndtype[nd] == type) count++;
  }
  return count;
}
int
CMSubtreeCountNodetype(CM_t *cm, int v, char type)
{
  int unsatisfied_starts = 1;
  int count = 0;

  while (unsatisfied_starts) {
	if (cm->sttype[v] == B_st) unsatisfied_starts++;
	if (cm->sttype[v] == E_st) unsatisfied_starts--;
	if (cm->stid[v]   == type) count++;
	v++;
  }
  return count;
}

/* Function: CalculateStateIndex()
 * Date:     SRE, Mon Jul 31 15:37:55 2000 [St. Louis]
 *
 * Purpose:  Given a node index and a unique state type, use the CM's
 *           nodemap to calculate and return a state index in the CM.
 *
 *           Doesn't check that the node type matches what's implied
 *           by the utype! (e.g., if you pass utype==MATP_MP, the node
 *           had better be a MATP.)
 *
 * Args:     cm     - the covariance model
 *           node   - node index, 0..cm->nodes-1
 *           utype  - unique statetype, e.g. MATP_MP
 *
 * Returns:  a state index, 0..cm->M-1
 *
 * Used in:  cm_modelmaker.c:transmogrify()
 */
int
CalculateStateIndex(CM_t *cm, int node, char utype)
{
  int base;

  base = cm->nodemap[node];
  switch (utype) {
  case ROOT_S:  return base;
  case ROOT_IL: return base+1;
  case ROOT_IR: return base+2;
  case BEGL_S:  return base;
  case BEGR_S:  return base;
  case BEGR_IL: return base+1;
  case MATP_MP: return base;
  case MATP_ML: return base+1;
  case MATP_MR: return base+2;
  case MATP_D:  return base+3;
  case MATP_IL: return base+4;
  case MATP_IR: return base+5;
  case MATL_ML: return base;
  case MATL_D:  return base+1;
  case MATL_IL: return base+2;
  case MATR_MR: return base;
  case MATR_D:  return base+1;
  case MATR_IR: return base+2;
  case END_E:   return base;
  case BIF_B:   return base;
  default: cm_Fail("bogus utype %d in CalculateStateIndex()", utype);
  }
  return base;			/* not used */
}

/* Function:  TotalStatesInNode(), SplitStatesInNode(), InsertStatesInNode()
 * Incept:    SRE, Thu Aug  8 09:57:59 2002 [St. Louis]
 *
 * Purpose:   Returns the number of states in a node type.
 *
 * Args:      ndtype  - type of node (cm->ndtype[])
 */
int
TotalStatesInNode(int ndtype)
{
  switch (ndtype) {
  case BIF_nd:   return 1;
  case MATP_nd:  return 6;
  case MATL_nd:  return 3;
  case MATR_nd:  return 3;
  case BEGL_nd:  return 1;
  case BEGR_nd:  return 2;
  case ROOT_nd:  return 3;
  case END_nd:   return 1;
  default:       cm_Fail("Bogus node type %d", ndtype);
  }
  return 0;/*NOTREACHED*/
}
int
SplitStatesInNode(int ndtype)
{
  switch (ndtype) {
  case BIF_nd:   return 1;
  case MATP_nd:  return 4;
  case MATL_nd:  return 2;
  case MATR_nd:  return 2;
  case BEGL_nd:  return 1;
  case BEGR_nd:  return 1;
  case ROOT_nd:  return 1;
  case END_nd:   return 1;
  default:       cm_Fail("Bogus node type %d", ndtype);
  }
  return 0;/*NOTREACHED*/
}
int
InsertStatesInNode(int ndtype)
{
  switch (ndtype) {
  case BIF_nd:   return 0;
  case MATP_nd:  return 2;
  case MATL_nd:  return 1;
  case MATR_nd:  return 1;
  case BEGL_nd:  return 0;
  case BEGR_nd:  return 1;
  case ROOT_nd:  return 2;
  case END_nd:   return 0;
  default:       cm_Fail("Bogus node type %d", ndtype);
  }
  return 0;/*NOTREACHED*/
}

/* Function:  StateDelta(), StateLeftDelta(), StateRightDelta()
 * Incept:    SRE, Thu Oct  9 11:23:13 2003 [St. Louis]
 *
 * Purpose:   Convenience functions, mirroring some notation in Durbin et al.
 *            and elsewhere. \Delta notation simplifies some expositions
 *            of dynamic programming code.
 *
 *            \Delta^R_v = 1 if the state emits right; else 0
 *            \Delta^L_v = 1 if the state emits left;  else 0
 *            \Delta_v   = 2 for pairwise, 1 for singlet, 0 for mute states.
 *
 *            B_st, EL_st are special cases - Delta is returned as zero,
 *            but can't be used the same way.
 *
 * Args:      sttype   - state type code, e.g. MP_st
 *
 * Returns:   (see above)
 */
int
StateDelta(int sttype)
{
  switch (sttype) {
  case D_st:  return 0;
  case MP_st: return 2;
  case ML_st: return 1;
  case MR_st: return 1;
  case IL_st: return 1;
  case IR_st: return 1;
  case S_st:  return 0;
  case E_st:  return 0;
  case B_st:  return 0;
  case EL_st: return 0;
  default: cm_Fail("bogus state type %d\n", sttype);
  }
  /*NOTREACHED*/
  return 0;
}
int
StateLeftDelta(int sttype)
{
  switch (sttype) {
  case D_st:  return 0;
  case MP_st: return 1;
  case ML_st: return 1;
  case MR_st: return 0;
  case IL_st: return 1;
  case IR_st: return 0;
  case S_st:  return 0;
  case E_st:  return 0;
  case B_st:  return 0;
  case EL_st: return 0;
  default: cm_Fail("bogus state type %d\n", sttype);
  }
  /*NOTREACHED*/
  return 0;
}
int
StateRightDelta(int sttype)
{
  switch (sttype) {
  case D_st:  return 0;
  case MP_st: return 1;
  case ML_st: return 0;
  case MR_st: return 1;
  case IL_st: return 0;
  case IR_st: return 1;
  case S_st:  return 0;
  case E_st:  return 0;
  case B_st:  return 0;
  case EL_st: return 0;
  default: cm_Fail("bogus state type %d\n", sttype);
  }
  /*NOTREACHED*/
  return 0;
}
/* Function:  Emitmode()
 * Incept:    EPN, Fri Nov  9 09:03:10 2007
 *
 * Purpose:   Convenience function, return emitmode of a sttype
 *            EMITLEFT, EMITRIGHT, EMITNONE, or EMITPAIR
 *
 * Args:      sttype   - state type code, e.g. MP_st
 *
 * Returns:   (see above)
 */
int
Emitmode(int sttype)
{
  switch (sttype) {
  case IL_st: return EMITLEFT;
  case IR_st: return EMITRIGHT;
  case D_st:  return EMITNONE;
  case ML_st: return EMITLEFT;
  case MR_st: return EMITRIGHT;
  case MP_st: return EMITPAIR;
  case S_st:  return EMITNONE;
  case E_st:  return EMITNONE;
  case B_st:  return EMITNONE;
  case EL_st: return EMITNONE;
  default: cm_Fail("bogus state type %d\n", sttype);
  }
  /*NOTREACHED*/
  return 0;
}
/* Function:  NumReachableInserts()
 * Incept:    EPN, Mon Oct 24 22:41:00 2011
 *
 * Purpose:   Returns number of insert states reachable
 *            from the current state, depends only on
 *            stid (node type and state type).
 *
 * Args:      stid - state id code, e.g. MATP_MP
 *
 * Returns:   (see above)
 */
int
NumReachableInserts(int stid)
{
  switch (stid) {
  case MATL_ML: return 1;
  case MATL_D:  return 1;
  case MATL_IL: return 1;
  case MATP_MP: return 2;
  case MATP_ML: return 2;
  case MATP_MR: return 2;
  case MATP_D:  return 2;
  case MATP_IL: return 2;
  case MATP_IR: return 1;
  case MATR_MR: return 1;
  case MATR_D:  return 1;
  case MATR_IR: return 1;
  case BIF_B:   return 0;
  case BEGL_S:  return 0;
  case BEGR_S:  return 1;
  case BEGR_IL: return 1;
  case END_E:   return 0;
  case ROOT_S:  return 2;
  case ROOT_IL: return 2;
  case ROOT_IR: return 1;
  case END_EL:  return 0;
  default: cm_Fail("bogus state id %d\n", stid);
  }
  /*NOTREACHED*/
  return 0;
}

/* Function: PrintCM()
 * Date:     SRE, Sat Jul 29 10:55:16 2000 [St. Louis]
 *
 * Purpose:  Debugging: show a tabular representation of a CM structure.
 *
 * Args:     fp - output stream (e.g. stdout)
 *           cm - the CM to show
 *
 * Returns:  (void)
 */
void
PrintCM(FILE *fp, CM_t *cm)
{
  int x;

  fprintf(fp, "%5s %6s %5s %6s %7s %6s %5s %5s %5s\n",
	  " idx ","sttype", "ndidx", "ndtype", "  stid ", "cfirst", " cnum", "plast", " pnum");
  fprintf(fp, "%5s %6s %5s %6s %7s %5s %5s %5s %5s\n",
	  "-----", "------", "-----", "------","-------","------","-----", "-----", "-----");

  for (x = 0; x < cm->M; x++)
	{
	  fprintf(fp, "%5d %-6s %5d %6s %-7s %6d %5d %5d %5d\n",
	      x, Statetype(cm->sttype[x]), cm->ndidx[x],
	      Nodetype(cm->ndtype[cm->ndidx[x]]), UniqueStatetype(cm->stid[x]),
	      cm->cfirst[x], cm->cnum[x],
	      cm->plast[x], cm->pnum[x]);
	}
}

/* Function: SummarizeCM()
 * Date:     SRE, Sat Jul 29 12:19:31 2000 [St. Louis]
 *
 * Purpose:  Print some summary information about a new CM;
 *           called by cmbuild after each new model construction.
 *
 * Args:     fp - output stream (e.g. stdout)
 *           cm - cm to summarize
 *
 * Returns:  (void)
 */
void
SummarizeCM(FILE *fp, CM_t *cm)
{
  int x;
  int count[UNIQUESTATES];

  for (x = 0; x < UNIQUESTATES; x++) count[x] = 0;

  for (x = 0; x < cm->M; x++)
	count[(int) cm->stid[x]]++;

  fprintf(fp, "Summary report for CM structure:\n");
  fprintf(fp, "--------------------------------------\n");
  fprintf(fp, "Total states:       %4d\n", cm->M);
  fprintf(fp, "Total nodes:        %4d\n", cm->nodes);
  fprintf(fp, "Bifurcations:       %4d\n", count[BIF_B]);
  fprintf(fp, "MATP nodes:         %4d\n", count[MATP_MP]);
  fprintf(fp, "MATL nodes:         %4d\n", count[MATL_ML]);
  fprintf(fp, "MATR nodes:         %4d\n", count[MATR_MR]);
  fprintf(fp, "Consensus columns:  %4d    (2*MATP+MATL+MATR)\n",
	  count[MATP_MP]*2+count[MATL_ML]+count[MATR_MR]);
  fprintf(fp, "Base pairs:         %4d    (MATP)\n", count[MATP_MP]);
  fprintf(fp, "Single stranded:    %4d    (MATL+MATR)\n", count[MATL_ML]+count[MATR_MR]);
  /*fprintf(fp, "W: max hit size:    %d\n", cm->W);*/

}

/* Functions: Statetype(), Nodetype(), UniqueStatetype();
 *            StateCode(), NodeCode(), UniqueStateCode()
 * Date:      SRE, Sat Jul 29 11:07:47 2000 [St. Louis]
 *
 * Purpose:   Translate internal flags into human-readable strings,
 *            for clearer debugging output (*type functions);
 *            or vice versa (*Code functions)
 *
 * Args:      type - a state type, node type, or unique statetype code
 *            s    - string representing a code
 *
 * Returns:   the appropriate string; or the appropriate code.
 */
char *
Statetype(int type)
{
  switch (type) {
  case D_st:  return "D";
  case MP_st: return "MP";
  case ML_st: return "ML";
  case MR_st: return "MR";
  case IL_st: return "IL";
  case IR_st: return "IR";
  case S_st:  return "S";
  case E_st:  return "E";
  case B_st:  return "B";
  case EL_st: return "EL";
  default: cm_Fail("bogus state type %d\n", type);
  }
  return ""; /*NOTREACHED*/
}
int
StateCode(char *s)
{
  if      (strcmp(s, "D")  == 0) return D_st;
  else if (strcmp(s, "MP") == 0) return MP_st;
  else if (strcmp(s, "ML") == 0) return ML_st;
  else if (strcmp(s, "MR") == 0) return MR_st;
  else if (strcmp(s, "IL") == 0) return IL_st;
  else if (strcmp(s, "IR") == 0) return IR_st;
  else if (strcmp(s, "S")  == 0) return S_st;
  else if (strcmp(s, "E")  == 0) return E_st;
  else if (strcmp(s, "B")  == 0) return B_st;
  else if (strcmp(s, "EL") == 0) return EL_st;
  return -1;
}
char *
Nodetype(int type)
{
  switch (type) {
  case DUMMY_nd: return "-";
  case BIF_nd:   return "BIF";
  case MATP_nd:  return "MATP";
  case MATL_nd:  return "MATL";
  case MATR_nd:  return "MATR";
  case BEGL_nd:  return "BEGL";
  case BEGR_nd:  return "BEGR";
  case ROOT_nd:  return "ROOT";
  case END_nd:   return "END";
  default: cm_Fail("bogus node type %d\n", type);
  }
  return "";
}
int
NodeCode(char *s)
{
  if      (strcmp(s, "BIF")  == 0) return BIF_nd;
  else if (strcmp(s, "MATP") == 0) return MATP_nd;
  else if (strcmp(s, "MATL") == 0) return MATL_nd;
  else if (strcmp(s, "MATR") == 0) return MATR_nd;
  else if (strcmp(s, "BEGL") == 0) return BEGL_nd;
  else if (strcmp(s, "BEGR") == 0) return BEGR_nd;
  else if (strcmp(s, "ROOT") == 0) return ROOT_nd;
  else if (strcmp(s, "END")  == 0) return END_nd;
  return -1;
}
char *
UniqueStatetype(int type)
{
  switch (type) {
  case DUMMY:   return "DUMMY";
  case ROOT_S:  return "ROOT_S";
  case ROOT_IL: return "ROOT_IL";
  case ROOT_IR: return "ROOT_IR";
  case BEGL_S : return "BEGL_S";
  case BEGR_S : return "BEGR_S";
  case BEGR_IL: return "BEGR_IL";
  case MATP_MP: return "MATP_MP";
  case MATP_ML: return "MATP_ML";
  case MATP_MR: return "MATP_MR";
  case MATP_D : return "MATP_D";
  case MATP_IL: return "MATP_IL";
  case MATP_IR: return "MATP_IR";
  case MATL_ML: return "MATL_ML";
  case MATL_D : return "MATL_D";
  case MATL_IL: return "MATL_IL";
  case MATR_MR: return "MATR_MR";
  case MATR_D : return "MATR_D";
  case MATR_IR: return "MATR_IR";
  case END_E  : return "END_E";
  case BIF_B  : return "BIF_B";
  case END_EL : return "END_EL";
  default: cm_Fail("bogus unique state type %d\n", type);
  }
  return "";
}
int
UniqueStateCode(char *s)
{
  if      (strcmp(s, "ROOT_S")  == 0) return ROOT_S;
  else if (strcmp(s, "ROOT_IL") == 0) return ROOT_IL;
  else if (strcmp(s, "ROOT_IR") == 0) return ROOT_IR;
  else if (strcmp(s, "BEGL_S")  == 0) return BEGL_S;
  else if (strcmp(s, "BEGR_S")  == 0) return BEGR_S;
  else if (strcmp(s, "BEGR_IL") == 0) return BEGR_IL;
  else if (strcmp(s, "MATP_MP") == 0) return MATP_MP;
  else if (strcmp(s, "MATP_ML") == 0) return MATP_ML;
  else if (strcmp(s, "MATP_MR") == 0) return MATP_MR;
  else if (strcmp(s, "MATP_D")  == 0) return MATP_D;
  else if (strcmp(s, "MATP_IL") == 0) return MATP_IL;
  else if (strcmp(s, "MATP_IR") == 0) return MATP_IR;
  else if (strcmp(s, "MATL_ML") == 0) return MATL_ML;
  else if (strcmp(s, "MATL_D")  == 0) return MATL_D;
  else if (strcmp(s, "MATL_IL") == 0) return MATL_IL;
  else if (strcmp(s, "MATR_MR") == 0) return MATR_MR;
  else if (strcmp(s, "MATR_D")  == 0) return MATR_D;
  else if (strcmp(s, "MATR_IR") == 0) return MATR_IR;
  else if (strcmp(s, "BIF_B")   == 0) return BIF_B;
  else if (strcmp(s, "END_E")   == 0) return END_E;
  else if (strcmp(s, "END_EL")  == 0) return END_EL;
  else cm_Fail("bogus unique statetype %s\n", s);
  return 0; /*NOTREACHED*/
}
int
DeriveUniqueStateCode(int ndtype, int sttype)
{
  switch (ndtype) {
  case BIF_nd:
	switch (sttype) {
	case B_st:  return BIF_B;
	default:    return -1;
	}
  case MATP_nd:
	switch (sttype) {
	case D_st:  return MATP_D;
	case MP_st: return MATP_MP;
	case ML_st: return MATP_ML;
	case MR_st: return MATP_MR;
	case IL_st: return MATP_IL;
	case IR_st: return MATP_IR;
	default:    return -1;
	}
  case MATL_nd:
	switch (sttype) {
	case D_st:  return MATL_D;
	case ML_st: return MATL_ML;
	case IL_st: return MATL_IL;
	default:    return -1;
	}
  case MATR_nd:
	switch (sttype) {
	case D_st:  return MATR_D;
	case MR_st: return MATR_MR;
	case IR_st: return MATR_IR;
	default:    return -1;
	}
  case BEGL_nd:
	switch (sttype) {
	case S_st:  return BEGL_S;
	default:    return -1;
	}
  case BEGR_nd:
	switch (sttype) {
	case S_st:  return BEGR_S;
	case IL_st: return BEGR_IL;
	default:    return -1;
	}
  case ROOT_nd:
	switch (sttype) {
	case S_st:  return ROOT_S;
	case IL_st: return ROOT_IL;
	case IR_st: return ROOT_IR;
	default:    return -1;
	}
  case END_nd:
	switch (sttype) {
	case E_st:  return END_E;
	default:    return -1;
	}
  default:
	return -1;
  }
}

/* Function:  MarginalMode()
 * Date:      EPN, Sat Oct  8 06:52:21 2011
 *
 * Purpose:   Translate internal flags for truncation mode
 *            into human-readable strings, for clearer output.
 *
 * Args:      mode - a marginal mode
 *                   TRMODE_J, TRMODE_L, TRMODE_R, TRMODE_T or TRMODE_UNKNOWN
 *
 * Returns:   the appropriate string
 */
char *
MarginalMode(char mode)
{
  switch (mode) {
  case TRMODE_J:       return "Joint";
  case TRMODE_L:       return "Left";
  case TRMODE_R:       return "Right";
  case TRMODE_T:       return "Term";
  case TRMODE_UNKNOWN: return "Unkwn";
  default: cm_Fail("bogus marginal mode type %d\n", mode);
  }
  return "";
}

/* Function:  ModeEmitsLeft()
 * Date:      EPN, Thu Jan  5 09:31:18 2012
 *
 * Purpose:   Returns TRUE if mode emits left, i.e.
 *            mode is TRMODE_J or TRMODE_L.
 *
 */
int
ModeEmitsLeft(char mode)
{
  if(mode == TRMODE_J || mode == TRMODE_L) return TRUE;
  return FALSE;
}

/* Function:  ModeEmitsRight()
 * Date:      EPN, Thu Jan  5 09:32:31 2012
 *
 * Purpose:   Returns TRUE if mode emits right, i.e.
 *            mode is TRMODE_J or TRMODE_R.
 *
 */
int
ModeEmitsRight(char mode)
{
  if(mode == TRMODE_J || mode == TRMODE_R) return TRUE;
  return FALSE;
}

/* Function: StateMapsLeft()
 *
 * Purpose:  Returns TRUE if cm unique states type <stid> is
 *           a state type that maps emits or deletes on the left.
 */
int
StateMapsLeft(char stid)
{
  switch (stid) {
  case MATP_MP: /* match left, match right */
  case MATP_ML: /* match left, delete right */
  case MATP_MR: /* delete left, match right */
  case MATP_D:  /* delete left, delete right */
  case MATP_IL:
  case BEGR_IL:
  case MATL_ML:
  case MATL_D:
  case MATL_IL:
  case ROOT_IL:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: StateMapsRight()
 *
 * Purpose:  Returns TRUE if cm unique states type <stid> is
 *           a state type that maps emits or deletes on the right.
 */
int
StateMapsRight(char stid)
{
  switch (stid) {
  case MATP_MP: /* match left, match right */
  case MATP_ML: /* match left, delete right */
  case MATP_MR: /* delete left, match right */
  case MATP_D:  /* delete left, delete right */
  case MATP_IR:
  case MATR_MR:
  case MATR_D:
  case MATR_IR:
  case ROOT_IR:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: StateMapsMatch()
 *
 * Purpose:  Returns TRUE if cm unique states type <stid> maps
 *           to an HMM match state type.
 */
int
StateMapsMatch(char stid)
{
  switch (stid) {
  case MATP_MP:
  case MATL_ML:
  case MATR_MR:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: StateMapsInsert()
 *
 * Purpose:  Returns TRUE if cm unique states type <stid> maps
 *           to an HMM insert state type.
 */
int
StateMapsInsert(char stid)
{
  switch (stid) {
  case MATP_IL:
  case MATP_IR:
  case MATL_IL:
  case MATR_IR:
  case BEGR_IL:
  case ROOT_IL:
  case ROOT_IR:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: StateMapsDelete()
 *
 * Purpose:  Returns TRUE if cm unique states type <stid> maps
 *           to an HMM delete state type.
 */
int
StateMapsDelete(char stid)
{
  switch (stid) {
  case MATP_ML:  /* delete right */
  case MATP_MR:  /* delete left */
  case MATP_D:   /* delete pair */
  case MATL_D:
  case MATR_D:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: NodeMapsLeft()
 *
 * Purpose:  Returns TRUE if cm node type is a type with
 *           at least one left emitting (possibly insert)
 *           state within it.
 */
int
NodeMapsLeft(char ndtype)
{
  switch (ndtype) {
  case MATP_nd:
  case MATL_nd:
  case ROOT_nd:
  case BEGR_nd:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: NodeMapsRight()
 *
 * Purpose:  Returns TRUE if cm node type is a type with
 *           at least one right emitting (possibly insert)
 *           state within it.
 */
int
NodeMapsRight(char ndtype)
{
  switch (ndtype) {
  case MATP_nd:
  case MATR_nd:
  case ROOT_nd:
	return TRUE;
  default:
	return FALSE;
  }
}

/* Function: StateIsDetached()
 *
 * Purpose:  Returns TRUE if state v of cm is a detached
 *           insert. This should be true IFF type of next
 *           state is an END_E, meaning state v is an
 *           IL_st or (rarely) a MATP_IR state.
 */
int
StateIsDetached(CM_t *cm, int v)
{
  if(cm->stid[(v+1)] == END_E) {
#if eslDEBUGLEVEL >= 1
	/* check to make sure the state is actually detached */
	int y, x, x_offset;
	/* Determine if b is an IL_st, or the rare case of a MATP_IR st */
	if(cm->sttype[v] == IL_st) x_offset = 0;
	else {
	  ESL_DASSERT1((cm->stid[v] == MATP_IR)); /* if assertion fails, v is a non-IL, non-MATP_IR state, should'nt be detached */
	  x_offset = 1; /* MATP_y -> MATP_IR is second possible transition for MATP_*,
		     * unless MATP_y == MATP_IR, but we don't get there in for loop below. */
	}
	for (y = cm->pnum[v]-1; y >= 1; y--) { /* y >= 1 means we never get to v->v prob, which is irrelevant. */
	  x = cm->plast[v] - y;
	  ESL_DASSERT1((fabs(cm->t[x][x_offset] - 0.0) < eslSMALLX1));
	}
#endif
	return TRUE;
  }
  return FALSE;
}

/* Function: CMRebalance()
 * Date:     SRE, Mon Apr  8 11:40:46 2002 [St. Louis]
 *
 * Purpose:  Rebalance a CM tree to guarantee O(N^2 log N) memory in
 *           smallcyk.c's divide and conquer algorithm.
 *
 *           Input: a non-configured CM that's numbered in preorder
 *           traversal: visit root, visit left, visit right. (e.g.,
 *           left child S always visited before right child S,
 *           cfirst[w] < cnum[y], as produced by cm_modelmaker.c).
 *
 *           Output: a renumbered CM, in a modified preorder traversal:
 *           visit root, visit min weight child, visit max weight child,
 *           where weight is the # of extra CYK decks that'll need to
 *           be held in memory to calculate this subgraph.
 *
 * Args:     cm - the old CM
 *
 * Returns:  eslOK on success, ret_new_cm is valid rebalanced CM
 *           eslFAIL if source (old) CM has been configured, ret_new_cm set as NULL
 *           eslEMEM if we run out of memory
 */
int
CMRebalance(CM_t *cm, char *errbuf, CM_t **ret_new_cm)
{
  int       status;
  ESL_STACK *pda = NULL;   /* stack used for traversing old CM */
  CM_t     *new = NULL;    /* new CM we're creating */
  int      *wgt = NULL;    /* # of extra CYK decks required to calc subgraphs */
  int      *newidx = NULL; /* newidx[v] = old CM state v's new index in new CM */
  int       v, w, y,z;	   /* state indices in old CM */
  int       nv;		   /* state index in new CM */
  int       x;		   /* counter over transitions, residues, nodes */

  if((status = cm_nonconfigured_Verify(cm, errbuf)) != eslOK) goto ERROR;

  /* Create the new model. Copy information that's unchanged by
   * renumbering the CM.
   */
  new = CreateCM(cm->nodes, cm->M, cm->clen, cm->abc);
  if((status = esl_strdup(cm->name,      -1, &(new->name)))      != eslOK) goto ERROR;
  if((status = esl_strdup(cm->acc,       -1, &(new->acc)))       != eslOK) goto ERROR;
  if((status = esl_strdup(cm->desc,      -1, &(new->desc)))      != eslOK) goto ERROR;
  if((status = esl_strdup(cm->rf,        -1, &(new->rf)))        != eslOK) goto ERROR;
  if((status = esl_strdup(cm->consensus, -1, &(new->consensus))) != eslOK) goto ERROR;
  if(cm->map != NULL) {
	ESL_ALLOC(new->map, sizeof(int) * (cm->clen+1));
	esl_vec_ICopy(cm->map, cm->clen+1, new->map);
  }

  new->flags    = cm->flags;
  new->offset   = cm->offset;
  new->clen     = cm->clen;
  new->nseq     = cm->nseq;
  new->eff_nseq = cm->eff_nseq;
  if(cm->flags & CMH_GA) new->ga = cm->ga;
  if(cm->flags & CMH_TC) new->tc = cm->tc;
  if(cm->flags & CMH_NC) new->nc = cm->nc;

  for (x = 0; x < cm->abc->K; x++) new->null[x] = cm->null[x];

  /* Calculate "weights" (# of required extra decks) on every B and S state.
   * Recursive rule here is: 1 + min(wgt[left], wgt[right]).
   */
  ESL_ALLOC(wgt, sizeof(int) * cm->M);
  for (v = cm->M-1; v >= 0; v--)
	{
	  if      (cm->sttype[v] == E_st) /* initialize unbifurcated segments with 1 */
	wgt[v] = 1;
	  else if (cm->sttype[v] == B_st) /* "cfirst"=left S child. "cnum"=right S child. */
	wgt[v] = 1 + ESL_MIN(wgt[cm->cfirst[v]], wgt[cm->cnum[v]]);
	  else
	wgt[v] = wgt[v+1];            /* all other states propagate up to S */
	}

  /* Now, preorder traverse the new CM. At each bifurcation, we want
   * to visit the S with minimum weight first. v is an index on the
   * old CM, and we hop it around using this traversal order and a
   * pushdown stack. nv is an index on the new CM, which just moves
   * in preorder traversal 0..cm->M-1.
   *
   */
  v = 0;
  z = cm->M-1;
  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  ESL_ALLOC(newidx, sizeof(int) * cm->M);
  for (nv = 0; nv < cm->M; nv++)
	{
	  /* Keep a map of where the old states are going in new CM
	   * old state v becomes newidx[v] in the new model.
	   * This is guaranteed to be a one to one map.
	   */
	  newidx[v] = nv;

	  /* Copy old v to new nv.
	   * First, the easy stuff, that's unaffected by renumbering.
	   */
	  new->sttype[nv] = cm->sttype[v];
	  new->ndidx[nv]  = cm->ndidx[v];
	  new->stid[nv]   = cm->stid[v];
	  new->pnum[nv]   = cm->pnum[v];
	  for (x = 0; x < MAXCONNECT; x++) {
	new->t[nv][x]   = cm->t[v][x];
	new->tsc[nv][x] = cm->t[v][x];
	  }
	  for (x = 0; x < cm->abc->K*cm->abc->K; x++) {
	new->e[nv][x] = cm->e[v][x];
	new->esc[nv][x] = cm->esc[v][x];
	  }

	  /* Slightly harder - the plast connection for nv, to the last
	   * of 1-6 parent states. We use the newidx map to get it from plast[v].
	   */
	  if (nv != 0) new->plast[nv] = newidx[cm->plast[v]];
	  else         new->plast[nv] = -1;	/* ROOT. */

	  /* Now, figure out next v, and make cfirst, cnum connections.
	   *
	   * If we're a B, then traverse to the lighter child S state first.
	   * Remember the overload in CM struct: cfirst = idx of left child;
	   * cnum = idx of right child. So if we visit left w first, cfirst=nv+1;
	   * if we visit right y first, cnum=nv+1. Getting the second child
	   * index is a little tricky: we rely on knowing that
	   * the # of states in the first subgraph we visit is y-w,
	   * so we know the second child index is nv+y-w+1.
	   *
	   * If we're an E, pop the next v off the stack. cfirst=-1,cnum=0, because
	   * it has no children.
	   *
	   * Else, the next v is just v++. cfirst for new nv can be calculated by using the
	   * offset in the old model: e.g. nv + (cfirst[v] - v). cnum is unchanged.
	   *
	   */
	  if (cm->sttype[v] == B_st)
	{
	  w = cm->cfirst[v];	/* left child of v*/
	  y = cm->cnum[v];	/* right child of v*/

	  if (wgt[w] <= wgt[y])	/* left (w) lighter or same weight? visit w first, defer y */
	    {
	      if((status = esl_stack_IPush(pda, y)) != eslOK) goto ERROR;
	      if((status = esl_stack_IPush(pda, z)) != eslOK) goto ERROR;
	      v = w;
	      z = y-1;
	      new->cfirst[nv] = nv+1;     /* left child is nv+1 */
	      new->cnum[nv]   = nv+y-w+1;
	    }
	  else			/* right (y) lighter? visit y first, defer w */
	    {
	      if((status = esl_stack_IPush(pda, w)) != eslOK)   goto ERROR;
	      if((status = esl_stack_IPush(pda, y-1)) != eslOK) goto ERROR;
	      v = y;		/* z unchanged. */
	      new->cfirst[nv] = nv+z-y+2;
	      new->cnum[nv]   = nv+1;     /* right child is nv+1 */
	    }
	}
	  else if (cm->sttype[v] == E_st)
	{
	  new->cfirst[nv] = -1;
	  new->cnum[nv]   = 0;
	  esl_stack_IPop(pda, &z);
	  esl_stack_IPop(pda, &v);
	}
	  else
	{
	  new->cfirst[nv] = nv + (cm->cfirst[v]-v); /* use offset in old model */
	  new->cnum[nv]   = cm->cnum[v];            /* cnum unchanged. */
	  v++;
	}
	}

  /* Deal with the renumbered begin and end transition distributions,
   * using the newidx[v] map.
   */
  for (v = 0; v < cm->M; v++)
	{
	  new->begin[newidx[v]]      = cm->begin[v];
	  new->beginsc[newidx[v]]    = cm->beginsc[v];
	  new->ibeginsc[newidx[v]]   = cm->ibeginsc[v];
	  new->end[newidx[v]]        = cm->end[v];
	  new->endsc[newidx[v]]      = cm->endsc[v];
	  new->iendsc[newidx[v]]     = cm->iendsc[v];
	}
  if(cm->qdbinfo != NULL) {
	if((status = CopyCMQDBInfo(cm->qdbinfo, new->qdbinfo, errbuf)) != eslOK) goto ERROR;
	for (v = 0; v < cm->M; v++) new->qdbinfo->dmin1[newidx[v]] = cm->qdbinfo->dmin1[v];
	for (v = 0; v < cm->M; v++) new->qdbinfo->dmax1[newidx[v]] = cm->qdbinfo->dmax1[v];
	for (v = 0; v < cm->M; v++) new->qdbinfo->dmin2[newidx[v]] = cm->qdbinfo->dmin2[v];
	for (v = 0; v < cm->M; v++) new->qdbinfo->dmax2[newidx[v]] = cm->qdbinfo->dmax2[v];
  }

  /* Guide tree numbering is unchanged - still in preorder.
   * Associate nodes with new state numbering.
   */
  for (x = 0; x < new->nodes; x++)
	{
	  new->nodemap[x] = newidx[cm->nodemap[x]];
	  new->ndtype[x]  = cm->ndtype[x];
	}

  if(wgt    != NULL) free(wgt);
  if(newidx != NULL) free(newidx);
  if(pda    != NULL) esl_stack_Destroy(pda);
  *ret_new_cm = new;
  return eslOK;

 ERROR:
  if(wgt    != NULL) free(wgt);
  if(newidx != NULL) free(newidx);
  if(pda    != NULL) esl_stack_Destroy(pda);
  if(new    != NULL) FreeCM(new);
  *ret_new_cm = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "out of memory");
  else return status;  /* status is eslFAIL, errbuf was filled by cm_nonconfigured_Verify() */
  }

/*
 * EPN, Wed Mar 21 09:29:55 2007
 *
 * rsearch_calculate_gap_penalty (FROM RSEARCH::buildcm.c)
 *
 * Given the from state, the to state, and the gap parameters, returns
 * the gap penalty.
 */
float rsearch_calculate_gap_penalty (char from_state, char to_state,
				     int from_node, int to_node,
				     float input_alpha, float input_beta,
				     float input_alphap, float input_betap) {
  int from_class, to_class;
  double alpha, beta;          /* Alpha or beta values to use */

  /* There are potentially 400 different combinations of state pairs here.
	 To make it manageable, break down into the 6 classes on p. 8 of lab
	 book 7, numbered as follows
	 0    M    ROOT_S, BEGL_S, BEGR_S, MATP_MP, MATL_ML, MATR_MR, END_E, BIF_B
	 1    IL   ROOT_IL, BEGR_IL, MATP_IL, MATL_IL
	 2    DL   MATP_MR, MATL_D
	 3    IR   ROOT_IR, MATP_IR, MATR_IR
	 4    DR   MATP_ML, MATR_D
	 5    DB   MATP_D
  */
  switch (from_state) {
  case MATP_D:
	from_class = DB_cl;
	break;
  case MATP_ML:
  case MATR_D:
	from_class = DR_cl;
	break;
  case ROOT_IR:
  case MATP_IR:
  case MATR_IR:
	from_class = IR_cl;
	break;
  case MATP_MR:
  case MATL_D:
	from_class = DL_cl;
	break;
  case ROOT_IL:
  case BEGR_IL:
  case MATP_IL:
  case MATL_IL:
	from_class = IL_cl;
	break;
  default:
	from_class = M_cl;
  }

  switch (to_state) {
  case MATP_D:
	to_class = DB_cl;
	break;
  case MATP_ML:
  case MATR_D:
	to_class = DR_cl;
	break;
  case ROOT_IR:
  case MATP_IR:
  case MATR_IR:
	to_class = IR_cl;
	break;
  case MATP_MR:
  case MATL_D:
	to_class = DL_cl;
	break;
  case ROOT_IL:
  case BEGR_IL:
  case MATP_IL:
  case MATL_IL:
	to_class = IL_cl;
	break;
  default:
	to_class = M_cl;
  }

  /* Now set alpha and beta according to state classes and nodes */
  /* Alpha is alpha' for MATP->MATP, alpha otherwise */
  if (from_node == MATP_nd && to_node == MATP_nd)
	alpha = input_alphap;
  else
	alpha = input_alpha;
  /* Beta is beta' iff from_cl is DB and MATP->MATP */
  if (from_class == DB_cl && from_node == MATP_nd && to_node == MATP_nd)
	beta = input_betap;
  else
	beta = input_beta;

  /* Now that we have the proper class, return the appropriate gap penalty */
  if (from_class == M_cl) {
	if (to_class == M_cl) {
	  return (0.);
	} else if (to_class == DB_cl) {
	  return (alpha);
	} else {
	  return (0.5*alpha);
	}
  } else if (from_class == IL_cl) {
	if (to_class == M_cl) {
	  return (beta + 0.5*alpha);
	} else if (to_class == IL_cl) {
	  return (beta);
	} else if (to_class == DB_cl) {
	  return (beta+1.5*alpha);
	} else {
	  return (beta + alpha);
	}
  } else if (from_class == DL_cl) {
	if (to_class == M_cl) {
	  return (beta + 0.5*alpha);
	} else if (to_class == DL_cl) {
	  return (beta);
	} else if (to_class == DB_cl) {
	  return (beta + 0.5*alpha);
	} else {
	  return (beta + alpha);
	}
  } else if (from_class == IR_cl) {
	if (to_class == M_cl) {
	  return (beta + 0.5*alpha);
	} else if (to_class == IR_cl) {
	  return (beta);
	} else if (to_class == DB_cl) {
	  return (beta+1.5*alpha);
	} else {
	  return (beta + alpha);
	}
  } else if (from_class == DR_cl) {
	if (to_class == M_cl) {
	  return (beta + 0.5*alpha);
	} else if (to_class == DR_cl) {
	  return (beta);
	} else if (to_class == DB_cl) {
	  return (beta + 0.5*alpha);
	} else {
	  return (beta + alpha);
	}
  } else {                /* DB_cl */
	if (to_class == IL_cl || to_class == IR_cl) {
	  return (2*beta + 1.5*alpha);
	} else if (to_class == M_cl) {
	  return (2*beta + alpha);
	} else if (to_class == DB_cl) {
	  return (2*beta);
	} else {
	  return (2*beta + 0.5*alpha);
	}
  }
  return (0);
}

/* Function: cm_Exponentiate
 * Date:     EPN, Sun May 20 13:10:06 2007
 *
 * Purpose:  Exponentiate the emission and transition probabilities
 *           of a CM by z. We can only do this if a CM is in global
 *           mode. Otherwise, the cm->end probabilities would change,
 *           and we don't want that.
 *
 * Args:
 *           CM - the covariance model
 *           z  - factor to exponentiate by
 */
int
cm_Exponentiate(CM_t *cm, double z)
{
  int v;
  int x,y;

  /* If in local mode, fail */
  if(cm->flags & CMH_LOCAL_BEGIN || cm->flags & CMH_LOCAL_END) {
	cm_Fail("cm_Exponentiate() model is not in global configuration");
  }

  for(v = 0; v < cm->M; v++)
	{
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	for (x = 0; x < cm->cnum[v]; x++)
	  cm->t[v][x]  = pow(cm->t[v][x], z);
	  if (cm->sttype[v] == MP_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    for (y = 0; y < cm->abc->K; y++)
	      cm->e[v][x*cm->abc->K+y]  = pow(cm->e[v][x*cm->abc->K+y], z);
	}
	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st ||
	  cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    cm->e[v][x]  = pow(cm->e[v][x], z);
	}
	}
  CMRenormalize(cm);

  /* new probs invalidate log odds scores */
  cm->flags &= ~CMH_BITS;
  return eslOK;
}

/* Function: cm_p7_Exponentiate
 * Date:     EPN, Wed Apr 18 05:22:25 2012
 *
 * Purpose:  Exponentiate the emission and transition probabilities
 *           of a P7_HMM by z. This function complements
 *           ExponentiateCM().
 * Args:
 *           hmm - the covariance model
 *           z   - factor to exponentiate by
 */
int
cm_p7_Exponentiate(P7_HMM *hmm, double z)
{
  int k, i;

  for(k = 0; k <= hmm->M; k++) {
	for(i = 0; i < p7H_NTRANSITIONS; i++) { /* transitions out of match */
	  hmm->t[k][i] = pow(hmm->t[k][i], z);
	}
  }
  for(k = 1; k <= hmm->M; k++) {
	for(i = 0; i < hmm->abc->K; i++) { /* transitions out of match */
	  hmm->mat[k][i] = pow(hmm->mat[k][i], z);
	  hmm->ins[k][i] = pow(hmm->ins[k][i], z);
	}
  }
  p7_hmm_Renormalize(hmm);

  return eslOK;
}

/* Function:  cm_banner()
 * Synopsis:  print standard INFERNAL application output header
 *            Based on p7_banner from HMMER3 dev code.
 * Incept:    EPN, Fri May 25 15:05:42 2007
 *
 * Purpose:   Print the standard INFERNAL command line application banner
 *            to <fp>, constructing it from <progname> (the name of the
 *            program) and a short one-line description <banner>.
 *
 *            <progname> would typically be an application's
 *            <argv[0]>, rather than a fixed string. This allows the
 *            program to be renamed, or called under different names
 *            via symlinks. Any path in the <progname> is discarded;
 *            for instance, if <progname> is "/usr/local/bin/cmcalibrate",
 *            "cmcalibrate" is used as the program name.
 *
 * Note:
 *    Needs to pick up preprocessor #define's from config.h,
 *    as set by ./configure.
 *
 * Returns:   (void)
 */
void
cm_banner(FILE *fp, char *progname, char *banner)
{
  char *appname = NULL;

  if (esl_FileTail(progname, FALSE, &appname) != eslOK) appname = progname;

  fprintf(fp, "# %s :: %s\n", appname, banner);
  fprintf(fp, "# INFERNAL %s (%s)\n", INFERNAL_VERSION, INFERNAL_DATE);
  fprintf(fp, "# %s\n", INFERNAL_COPYRIGHT);
  fprintf(fp, "# %s\n", INFERNAL_LICENSE);
  fprintf(fp, "# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

  if (appname != NULL) free(appname);
  return;
}

/* Function:  cm_CalcExpSc()
 * Incept:    EPN, Wed Aug  1 16:36:52 2007
 *
 * Purpose:   Calculate the expected score for each state of a CM.
 *            For state v, this should be the average score of an
 *            emitted parse subtree rooted at v.
 *
 * Args:
 *           cm             - the covariance model
 *           ret_expsc      - expected score at each state, alloc'ed here
 *           ret_expsc_noss - expected score at each state if we ignored structure
 *                            same as ret_expsc, but marginal emission probs used
 *                            for MP states, alloc'ed here
 *
 * Returns:
 */
void
cm_CalcExpSc(CM_t *cm, float **ret_expsc, float **ret_expsc_noss)
{
  int status;
  float *expsc;
  float *expsc_noss;
  int v,x,y,yoffset;
  float *left_e,  *left_esc;
  float *right_e, *right_esc;
  int i,j;

  /* contract check */
  if(cm->flags & CMH_LOCAL_BEGIN) cm_Fail("cm_CalcExpSc() CMH_LOCAL_BEGIN flag up.\n");
  if(cm->flags & CMH_LOCAL_END)   cm_Fail("cm_CalcExpSc() CMH_LOCAL_END flag up.\n");
  if(ret_expsc == NULL)          cm_Fail("cm_CalcExpSc() ret_expsc is NULL.\n");

  ESL_ALLOC(left_e,    sizeof(float) * cm->abc->K);
  ESL_ALLOC(right_e,   sizeof(float) * cm->abc->K);
  ESL_ALLOC(left_esc,  sizeof(float) * cm->abc->K);
  ESL_ALLOC(right_esc, sizeof(float) * cm->abc->K);

  ESL_ALLOC(expsc,      sizeof(float) * cm->M);
  ESL_ALLOC(expsc_noss, sizeof(float) * cm->M);
  esl_vec_FSet(expsc,      cm->M, 0.);
  esl_vec_FSet(expsc_noss, cm->M, 0.);

  for(v = cm->M-1; v >= 0; v--)
	{
	  switch (cm->sttype[v]) {
	  case E_st:
	break;

	  case B_st:
	expsc[v]      = expsc[cm->cfirst[v]]      + expsc[cm->cnum[v]];      /* prob of this transition is 1.0 */
	expsc_noss[v] = expsc_noss[cm->cfirst[v]] + expsc_noss[cm->cnum[v]]; /* prob of this transition is 1.0 */
	break;

	  case MP_st:
	/* calculate marginals for expsc_noss calculation */
	/* left half */
	esl_vec_FSet(left_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++)
	  for(j = (i*cm->abc->K); j < ((i+1)*cm->abc->K); j++)
	    left_e[i] += cm->e[v][j];
	/* printf("sum should be 1.0: %f\n", esl_vec_FSum(left_e, cm->abc->K)); */
	esl_vec_FNorm(left_e, cm->abc->K);
	for(i = 0; i < cm->abc->K; i++) left_esc[i] = sreLOG2(left_e[i] / cm->null[i]);

	/* right half */
	esl_vec_FSet(right_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++)
	  for(j = i; j < cm->abc->K * cm->abc->K; j += cm->abc->K)
	    right_e[i] += cm->e[v][j];
	/* printf("sum should be 1.0: %f\n", esl_vec_FSum(right_e, cm->abc->K)); */
	esl_vec_FNorm(right_e, cm->abc->K);
	for(i = 0; i < cm->abc->K; i++) right_esc[i] = sreLOG2(right_e[i] / cm->null[i]);

	/* expsc uses joint emission probs */
	for(x = 0; x < cm->abc->K * cm->abc->K; x++)
	  expsc[v]      += cm->e[v][x] * cm->esc[v][x];

	/* expsc_noss uses marginalized emission probs */
	for(x = 0; x < cm->abc->K; x++)
	  expsc_noss[v] += left_e[x] * left_esc[x];
	for(x = 0; x < cm->abc->K; x++)
	  expsc_noss[v] += right_e[x] * right_esc[x];

	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  expsc[v]      += cm->t[v][yoffset] * (expsc[y]      + cm->tsc[v][yoffset]);
	  expsc_noss[v] += cm->t[v][yoffset] * (expsc_noss[y] + cm->tsc[v][yoffset]);
	}
	break;

	  case ML_st:
	  case MR_st:
	  case IL_st:
	  case IR_st:
	for(x = 0; x < cm->abc->K; x++) {
	  expsc[v]      += cm->e[v][x] * cm->esc[v][x];
	  expsc_noss[v] += cm->e[v][x] * cm->esc[v][x];
	}
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  expsc[v]      += cm->t[v][yoffset] * (expsc[y]       + cm->tsc[v][yoffset]);
	  expsc_noss[v] += cm->t[v][yoffset] * (expsc_noss[y]  + cm->tsc[v][yoffset]);
	}
	break;

	  case S_st:
	  case D_st:
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  expsc[v]      += cm->t[v][yoffset] * (expsc[y]      + cm->tsc[v][yoffset]);
	  expsc_noss[v] += cm->t[v][yoffset] * (expsc_noss[y] + cm->tsc[v][yoffset]);
	}
	break;
	  }
	}
  /* must return ret_expsc */
  *ret_expsc      = expsc;
  /* optionally return ret_expsc_noss */
  if(ret_expsc_noss != NULL) *ret_expsc_noss = expsc_noss;
  else free(expsc_noss);

  for(v = 0; v < cm->M; v++)
	printf("EXPSC[%4d]: %10.6f NOSS: %10.6f (%10.6f)\n", v, expsc[v], expsc_noss[v], (expsc[v] - expsc_noss[v]));

  return;
 ERROR:
  cm_Fail("ERROR in cm_CalcExpSc().\n");
}

/* Function:  cm_Validate()
 * Incept:    EPN, Fri Jul 27 14:59:55 2007 [Janelia]
 *
 * Purpose:   Validates some internals of the CM structure <cm>.
 *
 *            Probability vectors are validated to sum up to
 *            within a fractional tolerance <tol> of 1.0.
 *
 *            Probably only useful for debugging and development,
 *            not production code.
 *
 * Returns:   <eslOK> if <cm> internals look fine.
 *            Returns <eslFAIL> if something is wrong.
 */
int
cm_Validate(CM_t *cm, float tol, char *errbuf)
{
  int status;
  int v;
  int clen = 0;
  float pvec[MAXCONNECT+1];
  int y;

  if (cm             == NULL)       ESL_XFAIL(eslFAIL, errbuf, "CM is a null pointer");
  if (cm->M          <  1)          ESL_XFAIL(eslFAIL, errbuf, "CM has M < 1");
  if (cm->abc        == NULL)       ESL_XFAIL(eslFAIL, errbuf, "CM has no alphabet reference");
  if (cm->abc->type  == eslUNKNOWN) ESL_XFAIL(eslFAIL, errbuf, "CM's alphabet is set to unknown");
  if (cm->qdbinfo    == NULL)       ESL_XFAIL(eslFAIL, errbuf, "CM's qdbinfo is NULL");

  esl_vec_FSet(pvec, MAXCONNECT+1, 0.);
  for (v = 0; v < cm->M; v++)
	{
	  if(StateDelta(cm->sttype[v]) == 2)
	{
	  if (esl_vec_FValidate(cm->e[v], (cm->abc->K * cm->abc->K), tol, NULL) != eslOK)
	    ESL_XFAIL(eslFAIL, errbuf, "e[%d] fails pvector validation", v);
	}
	  else if(StateDelta(cm->sttype[v]) > 0)
	{
	  if (esl_vec_FValidate(cm->e[v], cm->abc->K, tol, NULL) != eslOK)
	    ESL_XFAIL(eslFAIL, errbuf, "e[%d] fails pvector validation", v);
	}
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	{
	  if ((! (cm->flags & CMH_LOCAL_BEGIN)) && (! (cm->flags & CMH_LOCAL_END)))
	    {
	      if(esl_vec_FValidate(cm->t[v], cm->cnum[v], tol, NULL) != eslOK)
		ESL_XFAIL(eslFAIL, errbuf, "t[%d] fails pvector validation", v);
	    }
	  else if (v > 0 && (cm->flags & CMH_LOCAL_END))
	    {
	      esl_vec_FSet(pvec, MAXCONNECT+1, 0.); /* not really nec */
	      for(y = 0; y < cm->cnum[v]; y++) pvec[y] = cm->t[v][y];
	      pvec[cm->cnum[v]] = cm->end[v];
	      if(esl_vec_FValidate(pvec, (cm->cnum[v]+1), tol, NULL) != eslOK)
		ESL_XFAIL(eslFAIL, errbuf, "t[%d] (with local end) fails pvector validation", v);
	    }
	}
	  if(cm->stid[v] == MATL_ML) clen++;
	  if(cm->stid[v] == MATR_MR) clen++;
	  if(cm->stid[v] == MATP_MP) clen+=2;
	}
  if(cm->flags & CMH_LOCAL_BEGIN)
	if(esl_vec_FValidate(cm->begin, cm->M, tol, NULL) != eslOK)
  if(cm->clen != clen) ESL_XFAIL(eslFAIL, errbuf, "consensus length %d not correctly stored in CM, should be %d", cm->clen, clen);

  return eslOK;

 ERROR:
  return status;
}

/* Function: CMStatetype()
 *
 * Purpose:  Returns the CM state type in text.
 * Example:  CP9Statetype(MP_st) = "MP"
 */
char *
CMStatetype(char st)
{
  switch (st) {
  case D_st:  return "D";
  case MP_st: return "MP";
  case ML_st: return "ML";
  case MR_st: return "MR";
  case IL_st: return "IL";
  case IR_st: return "IR";
  case S_st:  return "S";
  case E_st:  return "E";
  case B_st:  return "B";
  case EL_st: return "EL";
  default: return "BOGUS";
  }
}

/* Function: CMNodetype()
 *
 * Purpose:  Returns the CM state type in text.
 * Example:  CP9Statetype(MATP_nd) = "MATP"
 */
char *
CMNodetype(char nd)
{
  switch (nd) {
	/*case DUMMY_nd:  return "DUMMY";*/
  case BIF_nd:    return "BIF";
  case MATP_nd:   return "MATP";
  case MATL_nd:   return "MATL";
  case MATR_nd:   return "MATR";
  case BEGL_nd:   return "BEGL";
  case BEGR_nd:   return "BEGR";
  case ROOT_nd:   return "ROOT";
  case END_nd:    return "END";
  default: return "BOGUS";
  }
}

/* Function: CMStateid()
 *
 * Purpose:  Returns the CM state id in text.
 * Example:  CP9Statetype(MATP_MP) = "MATP_MP"
 */
char *
CMStateid(char st)
{
  switch (st) {
	/*case DUMMY:   return "DUMMY";*/
  case ROOT_S:  return "ROOT_S";
  case ROOT_IL: return "ROOT_IL";
  case ROOT_IR: return "ROOT_IR";
  case BEGL_S:  return "BEGL_S";
  case BEGR_S:  return "BEGR_S";
  case BEGR_IL: return "BEGR_IL";
  case MATP_MP: return "MATP_MP";
  case MATP_ML: return "MATP_ML";
  case MATP_MR: return "MATP_MR";
  case MATP_D:  return "MATP_D";
  case MATP_IL: return "MATP_IL";
  case MATP_IR: return "MATP_IR";
  case MATL_ML: return "MATL_ML";
  case MATL_D:  return "MATL_D";
  case MATL_IL: return "MATL_IL";
  case MATR_MR: return "MATR_MR";
  case MATR_D:  return "MATR_D";
  case MATR_IR: return "MATR_IR";
  case END_E:   return "END_E";
  case BIF_B:   return "BIF_B";
  case END_EL:  return "END_EL";
  default: return "BOGUS";
  }
}

/*****************************************************************
 * Convenience routines for setting fields in an CM. (from p7_hmm.c)
 *****************************************************************/
/* Function: cm_SetName()
 * Incept:   EPN, Fri Jul 27 16:49:49 2007 [Janelia]
 *
 * Purpose:  Set or change the name of a CM to <name>.
 *           Any trailing whitespace (including newline) is chopped off.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslEMEM> on allocation error, and original name (if any)
 *           remains.
 */
int
cm_SetName(CM_t *cm, char *name)
{
  int   status;
  void *tmp;
  int   n;

  if (name == NULL) {
	if (cm->name != NULL) free(cm->name);
	cm->name = NULL;
  } else {
	n = strlen(name);
	ESL_RALLOC(cm->name, tmp, sizeof(char)*(n+1));
	strcpy(cm->name, name);
	if ((status = esl_strchop(cm->name, n)) != eslOK) goto ERROR;
  }
  return eslOK;

 ERROR:
  return status;
}

/* Function: cm_SetAccession()
 * Incept:   SRE, Mon Jan  1 16:53:53 2007 [Casa de Gatos]
 *
 * Purpose:  Set or change the accession number of a CM to <acc>,
 *           and raise the <CMH_ACC> flag. Trailing whitespace (including newline)
 *           is chopped.
 *
 *           If <acc> is <NULL>, unset the CM's accession (if any) and drop
 *           the <CMH_ACC> flag.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslEMEM> on allocation error, and original name (if any)
 *           remains.
 */
int
cm_SetAccession(CM_t *cm, char *acc)
{
  int   status;
  void *tmp;
  int   n;

  if (acc == NULL) {
	if (cm->acc != NULL) free(cm->acc);
	cm->acc = NULL;
	cm->flags &= ~CMH_ACC;
  } else {
	n = strlen(acc);
	ESL_RALLOC(cm->acc, tmp, sizeof(char)*(n+1));
	strcpy(cm->acc, acc);
	if ((status = esl_strchop(cm->acc, n)) != eslOK) goto ERROR;
	cm->flags |= CMH_ACC;
  }
  return eslOK;

 ERROR:
  return status;
}

/* Function: cm_SetDescription()
 * Incept:   SRE, Mon Jan  1 16:59:28 2007 [Casa de Gatos]
 *
 * Purpose:  Set or change the description line of a Plan7 CM.
 *           Trailing whitespace (including newline) is chopped.
 */
int
cm_SetDescription(CM_t *cm, char *desc)
{
  int   status;
  void *tmp;
  int   n;

  if (desc == NULL)
	{
	  if (cm->desc != NULL) free(cm->desc);
	  cm->desc   = NULL;
	  cm->flags &= ~CMH_DESC;
	}
  else
	{
	  n = strlen(desc);
	  ESL_RALLOC(cm->desc, tmp, sizeof(char)*(n+1));
	  strcpy(cm->desc, desc);
	  if ((status = esl_strchop(cm->desc, n)) != eslOK) goto ERROR;
	  cm->flags |= CMH_DESC;
	}
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_SetConsensus()
 * Incept:    EPN, Wed Jun 22 06:11:35 2011
 *            (SRE p7_hmm_SetConsensus())
 *
 * Synopsis:  Set the consensus residue line of the CM.
 *
 * Purpose:   Sets the consensus annotation line of the model <cm>.
 *
 *            Based on p7_hmm_SetConsensus() which is flexible to
 *            setting the consensus as a single sequence or
 *            a consensus from a multiple sequence alignment.
 *            Here, only the latter case is handled, i.e.
 *            <sq> should always be passed as NULL. But in the
 *            future, we should relax this to allow for single
 *            sequence models.
 *
 *            The consensus sequence isn't even calculated here,
 *            it must be passed in as part of the <cons> CMConsensus_t
 *            object, which was created by CreateCMConsensus().
 *
 *            So, currently, <sq> must null and <cons> must be non-null.
 *
 * Args:      cm     - model with valid probability parameters
 *            cons   - consensus information for the CM
 *            sq     - NULL if a standard model;
 *                     or the query sequence for a single-sequence model (NOT YET IMPLEMENTED)
 *
 * Returns:   <eslOK> on success. The <CMH_CONS> flag on the <cm> is raised
 *            if it wasn't already. The <cm->consensus> line is set.
 *
 * Throws:    <eslEMEM> on allocation error. <eslEINVAL> if contract is violated.
 *            In both cases, the <CMH_CONS> is dropped, even if it was up to
 *            begin with, and the <cm->consensus> is <NULL>,
 *            even if we had one to begin with.
 *
 * Xref:      SRE:J8/26.
 */
int
cm_SetConsensus(CM_t *cm, CMConsensus_t *cons, ESL_SQ *sq)
{
  int   status;
  int   cpos;

  if(cons == NULL || sq != NULL) { status = eslEINVAL; goto ERROR; }

  /* allocation, if needed */
  if (! cm->consensus) ESL_ALLOC(cm->consensus, sizeof(char) * (cm->clen+2));

  /* copy cons->cseq, careful for off-by-one */
  cm->consensus[0] = ' ';
  for (cpos = 1; cpos <= cm->clen; cpos++) cm->consensus[cpos] = cons->cseq[cpos-1];
  cm->consensus[cm->clen+1] = '\0';
  cm->flags  |= CMH_CONS;
  return eslOK;

 ERROR:
  if (cm->consensus) free(cm->consensus);
  cm->consensus = NULL;
  cm->flags    &= (~CMH_CONS);
  return status;
}

/* Function: cm_AppendComlog()
 * Synopsis: Concatenate and append command line to the command line log.
 *
 * Purpose:  Concatenate command line options and append as a new line in the
 *           command line log. Command line log is multiline, with each line
 *           ending in newline char, except for last line.
 *
 *           Based on and nearly identical to HMMER's
 *           p7_hmm_AppendComlog().  One difference is the <add_seed>
 *           and <seed> parameters, if <use_seed> is TRUE we append
 *           "--seed <seed>" to the command line string. This is
 *           necessary to allow a user to reproduce 'cmbuild --refine
 *           --gibbs' CM files, which use a random (and not recorded)
 *           seed by default.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslEMEM> on allocation failure.
 */
int
cm_AppendComlog(CM_t *cm, int argc, char **argv, int add_seed, uint32_t seed)
{
  int       status;
  void     *tmp;
  int       n;
  int       i;
  int       seedlen;
  uint32_t  temp;
  char     *seedstr;

  /* figure out length of added command line, and (re)allocate comlog */
  n = argc-1;	/* account for 1 space per arg, except last one */
  for (i = 0; i < argc; i++) {
	n += strlen(argv[i]);
  }
  /* we may need to add '--seed <seed>' */
  if(add_seed) {
	temp = seed;
	seedlen = 1;
	while(temp > 0) { temp/=10; seedlen++; } /* determine length of stringized version of seed */
	seedlen += 8; /* strlen(' --seed ') */
	n += seedlen;
  }

  if (cm->comlog != NULL) {
	n += strlen(cm->comlog) + 1; /* +1 for the \n we're going to add to the old comlog */
	ESL_RALLOC(cm->comlog, tmp, sizeof(char)* (n+1));
	strcat(cm->comlog, "\n");
  } else {
	ESL_ALLOC(cm->comlog, sizeof(char)* (n+1));
	*(cm->comlog) = '\0'; /* need this to make strcat work */
  }

  for (i = 0; i < argc-1; i++)
	{
	  strcat(cm->comlog, argv[i]);
	  strcat(cm->comlog, " ");
	}
  strcat(cm->comlog, argv[argc-1]);

  if(add_seed) {
	ESL_ALLOC(seedstr, sizeof(char) * (seedlen+1));
	sprintf(seedstr, " --seed %" PRIu32 " ", seed);
	strcat(cm->comlog, seedstr);
	free(seedstr);
  }

  return eslOK;

 ERROR:
  return status;
}

/* Function: cm_SetCtime()
 * Synopsis: Timestamp a CM.
 *
 * Purpose:  Set the <ctime> field in a new CM to the current time.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslEMEM> on allocation failure.
 *           <eslESYS> if system calls fail to obtain (or format) the time.
 *
 * Notes:    This function is based on hmmer's p7_hmm_SetCtime(),
 *           All of the following notes are copied from there.
 *
 *           This function calls <ctime_r()>, supposedly a part of the
 *           ISO/IEC 9945-1:1996 (POSIX.1) standard, but not ANSI
 *           C99, so we have potential portability problems here.
 *
 *           A known one: <ctime_r()> is by default a three-argument
 *           call on Solaris 10 systems. Our autoconf script sets
 *           -D_POSIX_PTHREAD_SEMANTICS on Solaris systems to fix this
 *           issue, requesting Solaris to use a compliant version of
 *           ctime_r().
 *
 *           We might want to use strftime() instead; that's what
 *           POSIX 2008 recommends; but we'd still need localtime_r() or
 *           its equivalent, and that has its own portability issues.
 *
 *           Note to porters: it really doesn't matter what this
 *           timestamp is. INFERNAL doesn't look at it, it's for human
 *           notetaking. If you have to, set it to an empty string.
 *
 * TODO:     Oi. Time is complicated. Easel should give us an
 *           easy and portable call to generate time stamps like this;
 *           an esl_time module, perhaps?
 */
int
cm_SetCtime(CM_t *cm)
{
  char    *s = NULL;
  time_t   date;
  int      status;

  ESL_ALLOC(s, 32);
  if ((date = time(NULL)) == -1)               { status = eslESYS; goto ERROR; }
  if (ctime_r(&date, s) == NULL)               { status = eslESYS; goto ERROR; }
  if ((status = esl_strchop(s, -1)) != eslOK)  {                   goto ERROR; }

  if (cm->ctime != NULL) free(cm->ctime);
  cm->ctime = s;
  return eslOK;

 ERROR:
  if (s) free(s);
  return status;
}

/*---------------- end, internal-setting routines ---------------*/

/* Function: IntMaxDigits()
 * Date:     EPN, Fri Nov 30 14:51:12 2007
 *
 * Returns: The number of digits in INT_MAX.
 *          Originally written to inform how big a
 *          string must be if it wants to hold any
 *          possible positive integer.
 */
int
IntMaxDigits()
{
  int big = INT_MAX;
  return IntDigits(big);
}

/* Function: IntDigits()
 * Date:     EPN, Fri May 23 06:02:22 2008
 *
 * Returns: The number of digits in <i>.
 */
int
IntDigits(int i)
{
  int n   = 0;
  while(i > 0) { i/=10; n++; }
  return n;
}

/* Function: cm_GetAvgHitLen()
 * Synopsis: Calculate the average local and global hit length for a CM
 * Date:     EPN, Thu Jan 17 05:52:00 2008
 *
 * Returns: eslOK on success, <ret_avgL_loc> and <ret_avgL_glb> set as average local/global hit length
 *          eslEMEM if we're out of memory
 */
int
cm_GetAvgHitLen(CM_t *cm, char *errbuf, float *ret_avgL_loc, float *ret_avgL_glb)
{
  int    status;
  int    Z;
  float  avgL_loc;
  float  avgL_glb;
  double *gamma0_loc;
  double *gamma0_glb;
  int     n;

  if((status = CalculateQueryDependentBands(cm, errbuf, NULL, DEFAULT_BETA_W, NULL, &gamma0_loc, &gamma0_glb, &Z)) != eslOK) return status;
  avgL_loc = avgL_glb = 0.;
  for(n = 0; n <= Z; n++) avgL_loc += gamma0_loc[n] * (float) n;
  for(n = 0; n <= Z; n++) avgL_glb += gamma0_glb[n] * (float) n;
  free(gamma0_loc);
  free(gamma0_glb);

  if(ret_avgL_loc != NULL) *ret_avgL_loc = avgL_loc;
  if(ret_avgL_glb != NULL) *ret_avgL_glb = avgL_glb;

  return eslOK;
}

/* Function: CompareCMGuideTrees()
 * EPN, Tue Mar  6 08:32:12 2007
 *
 * Purpose:  Given two CMs, cm1 and cm2, compare them, returning TRUE
 *           iff they have the same guide tree (same node architecture).
 *
 * Args:     cm1          - covariance model number 1
 *           cm2          - covariance model number 2
 *
 * Returns:  TRUE if CMs have same guide tree, FALSE otherwise
 */
int
CompareCMGuideTrees(CM_t *cm1, CM_t *cm2)
{
  int          nd;
  if(cm1->nodes != cm2->nodes) return FALSE;
  for(nd = 0; nd < cm1->nodes; nd++) {
	if(cm1->ndtype[nd] != cm2->ndtype[nd]) return FALSE;
  }
  return TRUE;
}

/* Function: cm_nonconfigured_Verify()
 * EPN, Fri Dec  9 14:20:03 2011
 *
 * Purpose:  Verify that a cm is non-configured by checking its
 *           flags and internal variables. A design goal of Infernal
 *           is that the only way to configure a CM is with the
 *           cm_Configure() function (but that's difficult to
 *           be absolutely sure of). The motivation for this
 *           goal is so there's only 1 execution path through
 *           all the configuration functions. If there are many
 *           possible paths, dictated by combinations of options
 *           to an application for example, it's very possible that
 *           some of those paths screw something up.
 *
 * Args:     cm     - CM to check
 *           errbuf - string explaining evidence CM is configured, if it is
 *
 * Returns:  eslOK   if CM does not seem to be configured
 *           eslFAIL if the CM has been configured in some way.
 */
int
cm_nonconfigured_Verify(CM_t *cm, char *errbuf)
{
  /* Check for flags that indicate the CM has been configured in
   * any way. A CM has been configured if it has been manipulated
   * after being read from a file.
   */
  if(cm->flags & CM_IS_CONFIGURED)        ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CM_IS_CONFIGURED flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_BITS)                ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_BITS flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_LOCAL_BEGIN)         ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_LOCAL_BEGIN flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_LOCAL_END)           ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_LOCAL_END flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_CP9)                 ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_CP9 flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_CP9_TRUNC)           ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_CP9_TRUNC flag is up (should be down in a non-configured CM)");
  if(cm->flags & CM_EMIT_NO_LOCAL_BEGINS) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CM_EMIT_NO_LOCAL_BEGINS flag is up (should be down in a non-configured CM)");
  if(cm->flags & CM_EMIT_NO_LOCAL_ENDS)   ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CM_EMIT_NO_LOCAL_ENDS flag is up (should be down in a non-configured CM)");
  if(cm->flags & CMH_MLP7)                ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): CMH_MLP7 flag is up (should be down in a non-configured CM)");

  /* verify variables that should be NULL are NULL */
  /* cp9-related variables */
  if(cm->cp9        != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): cp9 is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->Lcp9       != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): Lcp9 is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->Rcp9       != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): Rcp9 is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->Tcp9       != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): Tcp9 is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->cp9map     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): cp9map is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->cp9b       != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): cp9b is non-NULL (it should be NULL in a non-configured CM)");
  /* matrices */
  if(cm->hb_mx      != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): hb_mx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->hb_omx     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): hb_omx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->hb_emx     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): hb_emx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->hb_shmx    != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): hb_shmx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trhb_mx    != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trhb_mx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trhb_omx   != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trhb_omx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trhb_emx   != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trhb_emx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trhb_shmx  != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trhb_shmx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->nb_mx      != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): nb_mx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->nb_omx     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): nb_omx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->nb_emx     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): nb_emx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->nb_shmx    != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): nb_shmx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trnb_mx    != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trnb_mx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trnb_omx   != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trnb_omx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trnb_emx   != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trnb_emx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trnb_shmx  != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trnb_shmx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->smx        != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): smx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trsmx      != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trsmx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->cp9_mx     != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): cp9_mx is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->cp9_bmx    != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): cp9_bmx is non-NULL (it should be NULL in a non-configured CM)");
  /* other variables */
  if(cm->mlp7       != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): mlp7 is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->root_trans != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): root_trans is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->trp        != NULL) ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): trp is non-NULL (it should be NULL in a non-configured CM)");
  if(cm->qdbinfo != NULL && cm->qdbinfo->setby == CM_QDBINFO_SETBY_BANDCALC) {
	ESL_FAIL(eslFAIL, errbuf, "cm_nonconfigured_Verify(): qdbinfo is not in its initial state");
  }
  return eslOK;
}

/* Function: cm_Clone()
 * Incept:   EPN, Thu Dec 15 05:43:25 2011
 *
 * Purpose:  Duplicates a CM.
 *
 *           For objects the CM refers to, new ones are created
 *           either by cloning (e.g. cm->cp9, cm->mlp7) or by
 *           creating a new one (e.g. cm->hb_mx, cm->smx).
 *
 * Args:     cm     - CM to clone
 *           ret_cm - copy of CM, allocated here, must be free'd by caller.
 *
 * Returns:  eslOK on success.
 *           eslEMEM on memory error, errbuf filled.
 *           eslEINCOMPAT on contract exception.
 *           if(! eslOK) *ret_cm set to NULL, errbuf is filled.
 */
int
cm_Clone(CM_t *cm, char *errbuf, CM_t **ret_cm)
{
  int status;
  CM_t *new = NULL;
  int i, v;

  if ((new = CreateCM(cm->nodes, cm->M, cm->clen, cm->abc)) == NULL) { status = eslEMEM; goto ERROR;}
  /* CM is zeroed within CreateCMBody() which is called by CreateCM() */

  if (esl_strdup(cm->name,      -1, &(new->name))      != eslOK) { status = eslEMEM; goto ERROR;}
  if (cm->acc       != NULL) { if (esl_strdup(cm->acc,       -1, &(new->acc))       != eslOK) { status = eslEMEM; goto ERROR;} }
  if (cm->desc      != NULL) { if (esl_strdup(cm->desc,      -1, &(new->desc))      != eslOK) { status = eslEMEM; goto ERROR;} }
  if (cm->rf        != NULL) { if (esl_strdup(cm->rf,        -1, &(new->rf))        != eslOK) { status = eslEMEM; goto ERROR;} }
  if (cm->consensus != NULL) { if (esl_strdup(cm->consensus, -1, &(new->consensus)) != eslOK) { status = eslEMEM; goto ERROR;} }
  if(cm->map != NULL) {
	ESL_ALLOC(new->map, sizeof(int) * (new->clen+1));
	esl_vec_ICopy(cm->map, (new->clen+1), new->map);
  }

  if ((cm->comlog  != NULL) && (status = esl_strdup(cm->comlog,  -1, &(new->comlog)))  != eslOK) goto ERROR;
  if ((cm->ctime   != NULL) && (status = esl_strdup(cm->ctime,   -1, &(new->ctime)))   != eslOK) goto ERROR;

  new->flags       = cm->flags;
  new->checksum    = cm->checksum;
  new->nseq        = cm->nseq;
  new->eff_nseq    = cm->eff_nseq;
  new->ga          = cm->ga;
  new->tc          = cm->tc;
  new->nc          = cm->nc;
  new->offset      = cm->offset;
  new->clen        = cm->clen;
  new->W           = cm->W;
  new->W_setby     = cm->W_setby;
  new->beta_W      = cm->beta_W;
  new->pbegin      = cm->pbegin;
  new->pend        = cm->pend;
  new->null2_omega = cm->null2_omega;
  new->null3_omega = cm->null3_omega;
  new->el_selfsc   = cm->el_selfsc;
  new->iel_selfsc  = cm->iel_selfsc;
  new->tau         = cm->tau;
  new->maxtau      = cm->maxtau;
  new->config_opts = cm->config_opts;
  new->align_opts  = cm->align_opts;
  new->search_opts = cm->search_opts;

  esl_vec_FCopy(cm->null,   cm->abc->K, new->null);
  esl_vec_ICopy(cm->ndidx,  cm->M, new->ndidx);
  esl_vec_ICopy(cm->cfirst, cm->M, new->cfirst);
  esl_vec_ICopy(cm->cnum,   cm->M, new->cnum);
  esl_vec_ICopy(cm->plast,  cm->M, new->plast);
  esl_vec_ICopy(cm->pnum,   cm->M, new->pnum);
  for(i = 0; i < cm->M+1; i++) new->sttype[i] = cm->sttype[i];
  for(i = 0; i < cm->M+1; i++) new->stid[i]   = cm->stid[i];

  esl_vec_ICopy(cm->nodemap, cm->nodes, new->nodemap);
  for(i = 0; i < cm->nodes; i++) new->ndtype[i]  = cm->ndtype[i];

  if(cm->root_trans != NULL) {
	ESL_ALLOC(new->root_trans, sizeof(float) * cm->cnum[0]);
	esl_vec_FCopy(cm->root_trans, cm->cnum[0], new->root_trans);
  }

  /* emission and transition probabilities and scores (should be consistent with CMZero()) */
  for (v = 0; v < cm->M; v++) {
	esl_vec_FCopy(cm->e[v],      (cm->abc->K * cm->abc->K), new->e[v]);
	esl_vec_FCopy(cm->t[v],      MAXCONNECT,                new->t[v]);
	esl_vec_FCopy(cm->tsc[v],    MAXCONNECT,                new->tsc[v]);
	esl_vec_FCopy(cm->esc[v],    (cm->abc->K * cm->abc->K), new->esc[v]);
	esl_vec_FCopy(cm->lmesc[v],  cm->abc->Kp,               new->lmesc[v]);
	esl_vec_FCopy(cm->rmesc[v],  cm->abc->Kp,               new->rmesc[v]);
	esl_vec_ICopy(cm->itsc[v],   MAXCONNECT,                new->itsc[v]);
	esl_vec_ICopy(cm->iesc[v],   (cm->abc->K * cm->abc->K), new->iesc[v]);
	esl_vec_ICopy(cm->ilmesc[v], cm->abc->Kp,               new->ilmesc[v]);
	esl_vec_ICopy(cm->irmesc[v], cm->abc->Kp,               new->irmesc[v]);
  }
  esl_vec_FCopy(cm->begin,      cm->M, new->begin);
  esl_vec_FCopy(cm->end,        cm->M, new->end);
  esl_vec_FCopy(cm->beginsc,    cm->M, new->beginsc);
  esl_vec_FCopy(cm->endsc,      cm->M, new->endsc);
  esl_vec_ICopy(cm->ibeginsc,   cm->M, new->ibeginsc);
  esl_vec_ICopy(cm->iendsc,     cm->M, new->iendsc);

  /* oesc and ioesc (not yet allocated for in new) */
  if(cm->oesc  != NULL && cm->ioesc == NULL) ESL_XFAIL(eslEINCOMPAT, errbuf, "cloning cm, cm->oesc != NULL and cm->ioesc == NULL");
  if(cm->oesc  == NULL && cm->ioesc != NULL) ESL_XFAIL(eslEINCOMPAT, errbuf, "cloning cm, cm->oesc == NULL and cm->ioesc != NULL");
  if(cm->oesc  != NULL && cm->ioesc != NULL) {
	if((status = CloneOptimizedEmitScores(cm, new, errbuf)) != eslOK) goto ERROR;
  }

  /* create the emit map (just as easy as copying) */
  if(cm->emap != NULL) if((new->emap = CreateEmitMap(new)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, unable to create new emit map");

  /* create the CM consensus data (just as easy as copying) */
  if(cm->cmcons != NULL && (new->flags & CMH_BITS)) if((new->cmcons = CreateCMConsensus(cm, cm->abc)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, unable to create a new CMConsensus_t");

  /* create the truncation penalties (just as easy as copying) */
  if(cm->trp != NULL)  if((new->trp  = cm_tr_penalties_Create(new, cm->trp->ignored_inserts, errbuf)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, unable to create new truncation penalties");

  /* QDBInfo */
  if(cm->qdbinfo != NULL) {
	if((status = CopyCMQDBInfo(cm->qdbinfo, new->qdbinfo, errbuf)) != eslOK) return status;
  }

  /* cp9 HMMs */
  if(cm->cp9  != NULL) { if((new->cp9  = cp9_Clone(cm->cp9))  == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, couldn't clone cp9");  }
  if(cm->Lcp9 != NULL) { if((new->Lcp9 = cp9_Clone(cm->Lcp9)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, couldn't clone Lcp9"); }
  if(cm->Rcp9 != NULL) { if((new->Rcp9 = cp9_Clone(cm->Rcp9)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, couldn't clone Rcp9"); }
  if(cm->Tcp9 != NULL) { if((new->Tcp9 = cp9_Clone(cm->Tcp9)) == NULL) ESL_XFAIL(eslFAIL, errbuf, "Cloning CM, couldn't clone Tcp9"); }
  /* cp9map, don't clone, just make a new one */
  if(cm->cp9map != NULL) {
	new->cp9map = AllocCP9Map(new);
	CP9_map_cm2hmm(new, new->cp9map, 0); /* 0 is debug_level, for debugging output */
	/* cp9 bands and cp9 matrices, don't clone, just make new ones (these grow to fit a target sequence) */
  }
  if(cm->cp9b    != NULL) new->cp9b    = AllocCP9Bands(new->M, new->cp9->M);
  if(cm->cp9_mx  != NULL) new->cp9_mx  = CreateCP9Matrix(1, new->cp9->M);
  if(cm->cp9_bmx != NULL) new->cp9_bmx = CreateCP9Matrix(1, new->cp9->M);

  /* p7 HMMs */
  if(cm->mlp7 != NULL) {
	if((new->mlp7 = p7_hmm_Clone(cm->mlp7)) == NULL) { status = eslEMEM; goto ERROR; }
  }
  if(cm->fp7  != NULL) {
	if((new->fp7  = p7_hmm_Clone(cm->fp7))  == NULL) { status = eslEMEM; goto ERROR; }
	esl_vec_FCopy(cm->fp7_evparam, CM_p7_NEVPARAM, new->fp7_evparam);
  }

  /* CM HMM banded DP matrices, don't clone these, just make new ones (these grow to fit a target sequence) */
  if(cm->hb_mx     != NULL) new->hb_mx     = cm_hb_mx_Create(new->M);
  if(cm->hb_omx    != NULL) new->hb_omx    = cm_hb_mx_Create(new->M);
  if(cm->hb_emx    != NULL) new->hb_emx    = cm_hb_emit_mx_Create(new);
  if(cm->hb_shmx   != NULL) new->hb_shmx   = cm_hb_shadow_mx_Create(new);
  if(cm->trhb_mx   != NULL) new->trhb_mx   = cm_tr_hb_mx_Create(new);
  if(cm->trhb_omx  != NULL) new->trhb_omx  = cm_tr_hb_mx_Create(new);
  if(cm->trhb_emx  != NULL) new->trhb_emx  = cm_tr_hb_emit_mx_Create(new);
  if(cm->trhb_shmx != NULL) new->trhb_shmx = cm_tr_hb_shadow_mx_Create(new);

  /* CM non-banded DP matrices, don't clone these, just make new ones (these grow to fit a target sequence) */
  if(cm->nb_mx     != NULL) new->nb_mx     = cm_mx_Create(new->M);
  if(cm->nb_omx    != NULL) new->nb_omx    = cm_mx_Create(new->M);
  if(cm->nb_emx    != NULL) new->nb_emx    = cm_emit_mx_Create(new);
  if(cm->nb_shmx   != NULL) new->nb_shmx   = cm_shadow_mx_Create(new);
  if(cm->trnb_mx   != NULL) new->trnb_mx   = cm_tr_mx_Create(new);
  if(cm->trnb_omx  != NULL) new->trnb_omx  = cm_tr_mx_Create(new);
  if(cm->trnb_emx  != NULL) new->trnb_emx  = cm_tr_emit_mx_Create(new);
  if(cm->trnb_shmx != NULL) new->trnb_shmx = cm_tr_shadow_mx_Create(new);

  /* CM scan matrices, don't clone these either, just make new ones.
   * Importantly we've already copied cm->qdbinfo into new->qdbinfo.
   */
  if(cm->smx   != NULL) { if((status = cm_scan_mx_Create   (new, errbuf, cm->smx->floats_valid,   cm->smx->ints_valid,   &(new->smx)))   != eslOK) goto ERROR; }
  if(cm->trsmx != NULL) { if((status = cm_tr_scan_mx_Create(new, errbuf, cm->trsmx->floats_valid, cm->trsmx->ints_valid, &(new->trsmx))) != eslOK) goto ERROR; }

  /* expA */
  if(cm->expA != NULL) {
	ESL_ALLOC(new->expA, sizeof(ExpInfo_t *) * EXP_NMODES);
	for(i = 0; i < EXP_NMODES; i++) {
	  new->expA[i] = CreateExpInfo();
	  CopyExpInfo(cm->expA[i], new->expA[i]);
	}
  }

  *ret_cm = new;

  return eslOK;

 ERROR:
  if(new != NULL) {
	FreeCM(new);
	*ret_cm = NULL;
  }
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "Cloning CM, out of memory");
  return status; /* reached if status != eslEMEM, errbuf was filled earlier */
}

/* Function: cm_Sizeof()
 * Incept:   EPN, Wed Jan 18 04:53:29 2012
 *
 * Purpose:  Calculate and return size of a CM_t object in Mb.
 *
 *           Size will include all objects the CM refers to,
 *           such as HMM banded matrices and scan matrices.
 *
 * Args:     cm     - CM to get size of
 *
 * Returns:  size of CM_t in Mg (megabytes)
 */
float
cm_Sizeof(CM_t *cm)
{
  float bytes = 0.;

  bytes  = sizeof(CM_t);
  /* from CreateCMBody() */
  if(cm->M > 0 && cm->abc != NULL) {
	bytes += sizeof(char) * (cm->M+1);   /* cm->sttype */
	bytes += sizeof(int)  *  cm->M;      /* cm->ndidx  */
	bytes += sizeof(char) * (cm->M+1);   /* cm->stid   */
	bytes += sizeof(int)  *  cm->M;      /* cm->cfirst */
	bytes += sizeof(int)  *  cm->M;      /* cm->cnum   */
	bytes += sizeof(int)  *  cm->M;      /* cm->plast  */
	bytes += sizeof(int)  *  cm->M;      /* cm->pnum   */
	bytes += sizeof(int)  *  cm->nodes;  /* cm->nodemap */
	bytes += sizeof(int)  *  cm->nodes;  /* cm->ndtype  */

	if(cm->comlog  != NULL) bytes += sizeof(char) * strlen(cm->comlog);
	if(cm->ctime   != NULL) bytes += sizeof(char) * strlen(cm->ctime);
	if(cm->qdbinfo != NULL) bytes += (1000000. * SizeofCMQDBInfo(cm->qdbinfo));
	if(cm->null    != NULL) bytes += sizeof(float) * (cm->abc->K);

	bytes += sizeof(float *) * cm->M;   /* cm->t level 1 ptrs */
	bytes += sizeof(float *) * cm->M;   /* cm->e level 1 ptrs */
	bytes += sizeof(float *) * cm->M;   /* cm->tsc level 1 ptrs */
	bytes += sizeof(float *) * cm->M;   /* cm->esc level 1 ptrs */
	bytes += sizeof(float *) * cm->M;   /* cm->lmesc level 1 ptrs */
	bytes += sizeof(float *) * cm->M;   /* cm->rmesc level 1 ptrs */
	bytes += sizeof(int *)   * cm->M;   /* cm->itsc level 1 ptrs */
	bytes += sizeof(int *)   * cm->M;   /* cm->iesc level 1 ptrs */
	bytes += sizeof(int *)   * cm->M;   /* cm->ilmesc level 1 ptrs */
	bytes += sizeof(int *)   * cm->M;   /* cm->irmesc level 1 ptrs */

	bytes += sizeof(float)   * cm->M;   /* cm->begin */
	bytes += sizeof(float)   * cm->M;   /* cm->end */
	bytes += sizeof(float)   * cm->M;   /* cm->beginsc */
	bytes += sizeof(float)   * cm->M;   /* cm->endsc */
	bytes += sizeof(int)     * cm->M;   /* cm->ibeginsc */
	bytes += sizeof(int)     * cm->M;   /* cm->iendsc */

	bytes += sizeof(float) * MAXCONNECT * cm->M;              /* cm->t level 2 */
	bytes += sizeof(float) * cm->abc->K * cm->abc->K * cm->M; /* cm->e level 2 */
	bytes += sizeof(float) * MAXCONNECT * cm->M;              /* cm->tsc level 2 */
	bytes += sizeof(float) * cm->abc->K * cm->abc->K * cm->M; /* cm->esc level 2 */
	bytes += sizeof(float) * cm->abc->Kp * cm->M;             /* cm->lmesc level 2 */
	bytes += sizeof(float) * cm->abc->Kp * cm->M;             /* cm->rmesc level 2 */
	bytes += sizeof(int)   * MAXCONNECT * cm->M;              /* cm->itsc level 2 */
	bytes += sizeof(int)   * cm->abc->K * cm->abc->K * cm->M; /* cm->iesc level 2 */
	bytes += sizeof(int)   * cm->abc->Kp * cm->M;             /* cm->ilmesc level 2 */
	bytes += sizeof(int)   * cm->abc->Kp * cm->M;             /* cm->irmesc level 2 */
  }

  if(cm->name       != NULL) bytes += sizeof(char)  * (strlen(cm->name) + 2);
  if(cm->acc        != NULL) bytes += sizeof(char)  * (strlen(cm->acc) + 2);
  if(cm->desc       != NULL) bytes += sizeof(char)  * (strlen(cm->desc) + 2);
  if(cm->rf         != NULL) bytes += sizeof(char)  * (strlen(cm->rf) + 2);
  if(cm->consensus  != NULL) bytes += sizeof(char)  * (strlen(cm->consensus) + 2);
  if(cm->map        != NULL) bytes += sizeof(int)   * (cm->clen+1);
  if(cm->root_trans != NULL) bytes += sizeof(float) * (cm->cnum[0]);

  if(cm->oesc != NULL || cm->ioesc != NULL) {
	int    nsinglets = 0;
	int    npairs    = 0;
	int    v;
	for(v = 0; v < cm->M; v++) {
	  if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st || cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) nsinglets++;
	  if(cm->sttype[v] == MP_st) npairs++;
	}
	if(cm->oesc != NULL) {
	  bytes += sizeof(float *) * cm->M;
	  bytes += sizeof(float)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs));
	}
	if(cm->ioesc != NULL) {
	  bytes += sizeof(int *) * cm->M;
	  bytes += sizeof(int)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs));
	}
  }

  /* cp9 HMMs */
  if(cm->cp9   != NULL) bytes += (1000000. * cp9_Sizeof(cm->cp9));
  if(cm->Lcp9  != NULL) bytes += (1000000. * cp9_Sizeof(cm->Lcp9));
  if(cm->Rcp9  != NULL) bytes += (1000000. * cp9_Sizeof(cm->Rcp9));
  if(cm->Tcp9  != NULL) bytes += (1000000. * cp9_Sizeof(cm->Tcp9));

  if(cm->cp9map  != NULL) bytes += (1000000. * SizeofCP9Map(cm->cp9map));
  if(cm->cp9b    != NULL) bytes += (1000000. * SizeofCP9Bands(cm->cp9b));
  if(cm->cp9_mx  != NULL) bytes += cm->cp9_mx->size_Mb;
  if(cm->cp9_bmx != NULL) bytes += cm->cp9_bmx->size_Mb;

  /* p7 HMMs */
  if(cm->mlp7 != NULL) bytes += (1000000. * cm_p7_hmm_Sizeof(cm->mlp7));
  if(cm->fp7  != NULL) bytes += (1000000. * cm_p7_hmm_Sizeof(cm->fp7));

  /* CM HMM banded DP matrices */
  if(cm->hb_mx     != NULL) bytes += (1000000. * cm->hb_mx->size_Mb);
  if(cm->hb_omx    != NULL) bytes += (1000000. * cm->hb_omx->size_Mb);
  if(cm->hb_emx    != NULL) bytes += (1000000. * cm->hb_emx->size_Mb);
  if(cm->hb_shmx   != NULL) bytes += (1000000. * cm->hb_shmx->size_Mb);
  if(cm->trhb_mx   != NULL) bytes += (1000000. * cm->trhb_mx->size_Mb);
  if(cm->trhb_omx  != NULL) bytes += (1000000. * cm->trhb_omx->size_Mb);
  if(cm->trhb_emx  != NULL) bytes += (1000000. * cm->trhb_emx->size_Mb);
  if(cm->trhb_shmx != NULL) bytes += (1000000. * cm->trhb_shmx->size_Mb);

  /* CM non-banded DP matrices */
  if(cm->nb_mx     != NULL) bytes += (1000000. * cm->nb_mx->size_Mb);
  if(cm->nb_omx    != NULL) bytes += (1000000. * cm->nb_omx->size_Mb);
  if(cm->nb_emx    != NULL) bytes += (1000000. * cm->nb_emx->size_Mb);
  if(cm->nb_shmx   != NULL) bytes += (1000000. * cm->nb_shmx->size_Mb);
  if(cm->trnb_mx   != NULL) bytes += (1000000. * cm->trnb_mx->size_Mb);
  if(cm->trnb_omx  != NULL) bytes += (1000000. * cm->trnb_omx->size_Mb);
  if(cm->trnb_emx  != NULL) bytes += (1000000. * cm->trnb_emx->size_Mb);
  if(cm->trnb_shmx != NULL) bytes += (1000000. * cm->trnb_shmx->size_Mb);

  /* CM scan matrices */
  if(cm->smx   != NULL) bytes += (1000000. * cm->smx->size_Mb);
  if(cm->trsmx != NULL) bytes += (1000000. * cm->trsmx->size_Mb);

  /* expA */
  if(cm->expA != NULL) {
	bytes += sizeof(ExpInfo_t *) * EXP_NMODES;
	bytes += sizeof(ExpInfo_t)   * EXP_NMODES;
  }

  /* the emit map */
  if(cm->emap != NULL) bytes += (1000000. * SizeofEmitMap(cm, cm->emap));

  /* CM_TR_PENALTIES */
  if(cm->trp != NULL) bytes += (1000000. * cm_tr_penalties_Sizeof(cm->trp));

  return (bytes / 1000000.);
}

/* Function: DumpCMFlags()
 * Date:     EPN, Wed Jun 22 19:24:54 2011
 *
 * Purpose:  Print flags that are raised in a CM.
 *
 * Returns:  void.
 */
void
DumpCMFlags(FILE *fp, CM_t *cm)
{
  fprintf(fp, "Dumping CM flags:\n");
  if(cm->flags & CMH_BITS)                 fprintf(fp, "\tCMH_BITS\n");
  if(cm->flags & CMH_ACC)                  fprintf(fp, "\tCMH_ACC\n");
  if(cm->flags & CMH_DESC)                 fprintf(fp, "\tCMH_DESC\n");
  if(cm->flags & CMH_RF)                   fprintf(fp, "\tCMH_RF\n");
  if(cm->flags & CMH_GA)                   fprintf(fp, "\tCMH_GA\n");
  if(cm->flags & CMH_TC)                   fprintf(fp, "\tCMH_TC\n");
  if(cm->flags & CMH_NC)                   fprintf(fp, "\tCMH_NC\n");
  if(cm->flags & CMH_CHKSUM)               fprintf(fp, "\tCMH_CHKSUM\n");
  if(cm->flags & CMH_MAP)                  fprintf(fp, "\tCMH_MAP\n");
  if(cm->flags & CMH_CONS)                 fprintf(fp, "\tCMH_CONS\n");
  if(cm->flags & CMH_LOCAL_BEGIN)          fprintf(fp, "\tCMH_LOCAL_BEGIN\n");
  if(cm->flags & CMH_LOCAL_END)            fprintf(fp, "\tCMH_LOCAL_END\n");
  if(cm->flags & CMH_EXPTAIL_STATS)        fprintf(fp, "\tCMH_EXPTAIL_STATS\n");
  if(cm->flags & CMH_CP9)                  fprintf(fp, "\tCMH_CP9\n");
  if(cm->flags & CMH_CP9_TRUNC)            fprintf(fp, "\tCMH_CP9_TRUNC\n");
  if(cm->flags & CMH_MLP7)                 fprintf(fp, "\tCMH_MLP7\n");
  if(cm->flags & CMH_FP7)                  fprintf(fp, "\tCMH_FP7\n");

  if(cm->flags & CM_IS_SUB)               fprintf(fp, "\tCM_IS_SUB\n");
  if(cm->flags & CM_IS_RSEARCH)           fprintf(fp, "\tCM_IS_RSEARCH\n");
  if(cm->flags & CM_RSEARCHTRANS)         fprintf(fp, "\tCM_RSEARCHTRANS\n");
  if(cm->flags & CM_RSEARCHEMIT)          fprintf(fp, "\tCM_RSEARCHEMIT\n");
  if(cm->flags & CM_EMIT_NO_LOCAL_BEGINS) fprintf(fp, "\tCM_EMIT_NO_LOCAL_BEGINS\n");
  if(cm->flags & CM_EMIT_NO_LOCAL_ENDS)   fprintf(fp, "\tCM_EMIT_NO_LOCAL_ENDS\n");

  fprintf(fp, "Finished dumping CM flags.\n");
  return;
}

/* Function:  cm_CreateDefaultApp()
 * Synopsis:  Initialize a small/simple/standard INFERNAL application
 * Incept:    EPN, Fri Jul  1 05:18:21 2011
 *            SRE, Thu Oct 28 15:03:21 2010 [Janelia] (p7_CreateDefaultApp())
 *
 * Purpose:   Identical to <esl_getopts_CreateDefaultApp()>, but
 *            specialized for INFERNAL. See documentation in
 *            <easel/esl_getopts.c>.
 *
 * Args:      options - array of <ESL_OPTIONS> structures for getopts
 *            nargs   - number of cmd line arguments expected (excl. of cmdname)
 *            argc    - <argc> from main()
 *            argv    - <argv> from main()
 *            banner  - optional one-line description of program (or NULL)
 *            usage   - optional one-line usage hint (or NULL)
 *
 * Returns:   ptr to new <ESL_GETOPTS> object.
 *
 *            On command line errors, this routine prints an error
 *            message to <stderr> then calls <exit(1)> to halt
 *            execution with abnormal (1) status.
 *
 *            If the standard <-h> option is seen, the routine prints
 *            the help page (using the data in the <options> structure),
 *            then calls <exit(0)> to exit with normal (0) status.
 *
 * Xref:      J7/3
 *
 * Note:      The only difference between this and esl_getopts_CreateDefaultApp()
 *            is to call cm_banner() instead of esl_banner(), to get INFERNAL
 *            versioning info into the header. There ought to be a better way
 *            (perhaps using PACKAGE_* define's instead of INFERNAL_* vs. EASEL_*
 *            define's in esl_banner(), thus removing the need for cm_banner).
 */
ESL_GETOPTS *
cm_CreateDefaultApp(ESL_OPTIONS *options, int nargs, int argc, char **argv, char *banner, char *usage)
{
  ESL_GETOPTS *go = NULL;

  go = esl_getopts_Create(options);
  if (esl_opt_ProcessCmdline(go, argc, argv) != eslOK ||
	  esl_opt_VerifyConfig(go)               != eslOK)
	{
	  printf("Failed to parse command line: %s\n", go->errbuf);
	  if (usage != NULL) esl_usage(stdout, argv[0], usage);
	  printf("\nTo see more help on available options, do %s -h\n\n", argv[0]);
	  exit(1);
	}
  if (esl_opt_GetBoolean(go, "-h") == TRUE)
	{
	  if (banner != NULL) cm_banner(stdout, argv[0], banner);
	  if (usage  != NULL) esl_usage (stdout, argv[0], usage);
	  puts("\nOptions:");
	  esl_opt_DisplayHelp(stdout, go, 0, 2, 80);
	  exit(0);
	}
  if (esl_opt_ArgNumber(go) != nargs)
	{
	  puts("Incorrect number of command line arguments.");
	  esl_usage(stdout, argv[0], usage);
	  printf("\nTo see more help on available options, do %s -h\n\n", argv[0]);
	  exit(1);
	}
  return go;
}

/* Function:  cm_p7_oprofile_CreateBlock()
 * Synopsis:  Create a new block of empty <CM_P7_OM_BLOCK>.
 * Incept:    EPN, Wed Jul  6 11:39:20 2011
 *
 * Purpose:   Creates a block of empty <CM_P7_OM_BLOCK> CM objects.
 *
 * Returns:   a pointer to the new <CM_P7_OM_BLOCK>. Caller frees this
 *            with <cm_p7_oprofile_DestroyBlock()>.
 *
 * Throws:    <NULL> if allocation fails.
 */
CM_P7_OM_BLOCK *
cm_p7_oprofile_CreateBlock(int count)
{
  int i = 0;

  CM_P7_OM_BLOCK *block = NULL;
  int status = eslOK;

  ESL_ALLOC(block, sizeof(*block));

  block->count = 0;
  block->idx0  = 0;
  block->listSize = 0;
  block->list         = NULL;
  block->msvdataA     = NULL;
  block->cm_offsetA   = NULL;
  block->cm_clenA     = NULL;
  block->cm_WA        = NULL;
  block->cm_nbpA      = NULL;
  block->gfmuA        = NULL;
  block->gflambdaA    = NULL;
  block->clan_idxA    = NULL;

  ESL_ALLOC(block->list,       sizeof(P7_OPROFILE *) * count);
  ESL_ALLOC(block->msvdataA,   sizeof(P7_SCOREDATA *)* count);
  ESL_ALLOC(block->cm_offsetA, sizeof(off_t)         * count);
  ESL_ALLOC(block->cm_clenA,   sizeof(int)           * count);
  ESL_ALLOC(block->cm_WA,      sizeof(int)           * count);
  ESL_ALLOC(block->cm_nbpA,    sizeof(int)           * count);
  ESL_ALLOC(block->gfmuA,      sizeof(float)         * count);
  ESL_ALLOC(block->gflambdaA,  sizeof(float)         * count);
  ESL_ALLOC(block->clan_idxA,  sizeof(int)           * count);
  block->listSize = count;

  for (i = 0; i < count; ++i)
	{
	  block->list[i]       = NULL;
	  block->msvdataA[i]   = NULL;
	  block->cm_offsetA[i] = 0;
	  block->cm_clenA[i]   = 0;
	  block->cm_WA[i]      = 0;
	  block->cm_nbpA[i]    = 0;
	  block->gfmuA[i]      = 0.;
	  block->gflambdaA[i]  = 0.;
	  block->clan_idxA[i]  = -1;
	}

  return block;

 ERROR:
  if (block != NULL)
	{
	  if (block->list       != NULL)  free(block->list);
	  if (block->msvdataA   != NULL)  free(block->msvdataA);
	  if (block->cm_offsetA != NULL)  free(block->cm_offsetA);
	  if (block->cm_clenA   != NULL)  free(block->cm_clenA);
	  if (block->cm_WA      != NULL)  free(block->cm_WA);
	  if (block->cm_nbpA    != NULL)  free(block->cm_clenA);
	  if (block->gfmuA      != NULL)  free(block->gfmuA);
	  if (block->gflambdaA  != NULL)  free(block->gflambdaA);
	  if (block->clan_idxA  != NULL)  free(block->clan_idxA);
	  free(block);
	}

  return NULL;
}

/* Function:  cm_p7_oprofile_DestroyBlock()
 * Synopsis:  Frees an <CM_P7_OPROFILE_BLOCK>.
 * Incept:
 *
 * Purpose:   Free a Create()'d block of profiles.
 */
void
cm_p7_oprofile_DestroyBlock(CM_P7_OM_BLOCK *block)
{
  int i;

  if (block == NULL) return;

  if (block->list != NULL) {
	for (i = 0; i < block->listSize; ++i) {
	  if (block->list[i] != NULL) p7_oprofile_Destroy(block->list[i]);
	}
	free(block->list);
  }
  if (block->msvdataA != NULL) {
	for (i = 0; i < block->listSize; ++i) {
	  if (block->msvdataA[i] != NULL) p7_hmm_ScoreDataDestroy(block->msvdataA[i]);
	}
	free(block->msvdataA);
  }
  if (block->cm_offsetA != NULL)  free(block->cm_offsetA);
  if (block->cm_clenA   != NULL)  free(block->cm_clenA);
  if (block->cm_WA      != NULL)  free(block->cm_WA);
  if (block->cm_nbpA    != NULL)  free(block->cm_nbpA);
  if (block->gfmuA      != NULL)  free(block->gfmuA);
  if (block->gflambdaA  != NULL)  free(block->gflambdaA);
  if (block->clan_idxA  != NULL)  free(block->clan_idxA);

  free(block);
  return;
}

/* Function: FCalcOptimizedEmitScores()
 * Date:     EPN, Tue Nov  6 17:24:45 2007
 *
 * Purpose:  Allocate, fill and return an optimized emission score vector
 *           of float scores for fast search/alignment.
 *
 * Returns:  the 2D float emission score vector on success,
 *           dies immediately on memory allocation error.
 */
float **
FCalcOptimizedEmitScores(CM_t *cm)
{
  int status;
  float **esc_vAA;
  ESL_DSQ a,b;
  int v;
  int cur_cell;
  int npairs = 0;
  int nsinglets = 0;
  float *ptr_to_start; /* points to block allocated to esc_vAA[0], nec b/c esc_vAA[0] gets set to NULL, because v == 0 is non-emitter */
  float **leftAA;
  float **rightAA;

  /* count pairs, singlets */
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  nsinglets++;
	  break;
	case MP_st:
	  npairs++;
	  break;
	}
  }

  /* set up our left and right vectors for all possible non-canonical residues,
   * these are calc'ed once and passed to FastPairScore*() functions to minimize
   * run time.
   */
  ESL_ALLOC(leftAA,  sizeof(float *) * cm->abc->Kp);
  ESL_ALLOC(rightAA, sizeof(float *) * cm->abc->Kp);
  for(a = 0; a <= cm->abc->K; a++) leftAA[a] = rightAA[a] = NULL; /* canonicals and gap, left/right unnec */
  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	ESL_ALLOC(leftAA[a],  sizeof(float) * cm->abc->K);
	ESL_ALLOC(rightAA[a], sizeof(float) * cm->abc->K);
	esl_vec_FSet(leftAA[a],  cm->abc->K, 0.);
	esl_vec_FSet(rightAA[a], cm->abc->K, 0.);
	esl_abc_FCount(cm->abc, leftAA[a],  a, 1.);
	esl_abc_FCount(cm->abc, rightAA[a], a, 1.);
  }
  leftAA[cm->abc->Kp-1] = rightAA[cm->abc->Kp-1] = NULL; /* missing data, left/right unnec */

  /* precalculate possible emission scores for each state */
  ESL_ALLOC(esc_vAA,     sizeof(float *) * (cm->M));
  ESL_ALLOC(esc_vAA[0],  sizeof(float)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs)));
  ptr_to_start = esc_vAA[0];
  cur_cell = 0;
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  esc_vAA[v] = ptr_to_start + cur_cell;
	  cur_cell += cm->abc->Kp;
	  for(a = 0; a < cm->abc->K; a++) /* all canonical residues */
	esc_vAA[v][a]  = cm->esc[v][a];
	  esc_vAA[v][cm->abc->K] = IMPOSSIBLE; /* gap symbol is impossible */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) /* all ambiguous residues */
	esc_vAA[v][a]  = esl_abc_FAvgScore(cm->abc, a, cm->esc[v]);
	  esc_vAA[v][cm->abc->Kp-1] = IMPOSSIBLE; /* missing data is IMPOSSIBLE */
	  break;
	case MP_st:
	  esc_vAA[v] = ptr_to_start + cur_cell;
	  esl_vec_FSet(esc_vAA[v], cm->abc->Kp * cm->abc->Kp, IMPOSSIBLE); /* init all cells to IMPOSSIBLE */
	  cur_cell += cm->abc->Kp * cm->abc->Kp;
	  /* a is canonical, b is canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  esc_vAA[v][(a * cm->abc->Kp) + b]  = cm->esc[v][(a * cm->abc->K) + b];
	}
	  }
	  /* a is not canonical, b is canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreLeftOnlyDegenerate(cm->abc->K, cm->esc[v], leftAA[a], b);
	}
	  }
	  /* a is canonical, b is not canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreRightOnlyDegenerate(cm->abc->K, cm->esc[v], rightAA[b], a);
	}
	  }
	  /* a is not canonical, b is not canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreBothDegenerate(cm->abc->K, cm->esc[v], leftAA[a], rightAA[b]);
	}
	  }
	  /* everything else, when either a or b is gap or missing data, stays IMPOSSIBLE */
	  break;
	default:
	  esc_vAA[v] = NULL;
	  break;
	}
  }
  for(a = 0; a < cm->abc->Kp; a++) {
	if(leftAA[a] != NULL)  free(leftAA[a]);
	if(rightAA[a] != NULL) free(rightAA[a]);
  }
  free(leftAA);
  free(rightAA);
  return esc_vAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/* Function: ICalcOptimizedEmitScores()
 * Date:     EPN, Tue Nov  6 17:27:34 2007
 *
 * Purpose:  Allocate, fill and return an optimized emission score vector
 *           of integer scores for fast search/alignment.
 *
 * Returns:  the 2D integer emission score vector on success,
 *           dies immediately on memory allocation error.
 */
int **
ICalcOptimizedEmitScores(CM_t *cm)
{
  int status;
  int **iesc_vAA;
  ESL_DSQ a,b;
  int v;
  int cur_cell;
  int npairs = 0;
  int nsinglets = 0;
  int *ptr_to_start; /* points to block allocated to iesc_vAA[0], nec b/c esc_vAA[0] gets set to NULL, because v == 0 is non-emitter */
  float **leftAA;
  float **rightAA;

  /* count pairs, singlets */
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  nsinglets++;
	  break;
	case MP_st:
	  npairs++;
	  break;
	}
  }

  /* set up our left and right vectors for all possible non-canonical residues,
   * these are calc'ed once and passed to FastPairScore*() functions to minimize
   * run time.
   */
  ESL_ALLOC(leftAA,  sizeof(float *) * cm->abc->Kp);
  ESL_ALLOC(rightAA, sizeof(float *) * cm->abc->Kp);
  for(a = 0; a <= cm->abc->K; a++) leftAA[a] = rightAA[a] = NULL; /* canonicals and gap, left/right unnec */
  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	ESL_ALLOC(leftAA[a],  sizeof(float) * cm->abc->K);
	ESL_ALLOC(rightAA[a], sizeof(float) * cm->abc->K);
	esl_vec_FSet(leftAA[a],  cm->abc->K, 0.);
	esl_vec_FSet(rightAA[a], cm->abc->K, 0.);
	esl_abc_FCount(cm->abc, leftAA[a],  a, 1.);
	esl_abc_FCount(cm->abc, rightAA[a], a, 1.);
  }
  leftAA[cm->abc->Kp-1] = rightAA[cm->abc->Kp-1] = NULL; /* missing data, left/right unnec */

  /* precalculate possible emission scores for each state */
  ESL_ALLOC(iesc_vAA,     sizeof(int *) * (cm->M));
  ESL_ALLOC(iesc_vAA[0],  sizeof(int)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs)));
  ptr_to_start = iesc_vAA[0];
  cur_cell = 0;
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  iesc_vAA[v] = ptr_to_start + cur_cell;
	  cur_cell += cm->abc->Kp;
	  for(a = 0; a < cm->abc->K; a++) /* all canonical residues */
	iesc_vAA[v][a]  = cm->iesc[v][a];
	  iesc_vAA[v][cm->abc->K] = -INFTY; /* gap symbol is impossible */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) /* all ambiguous residues */
	iesc_vAA[v][a]  = esl_abc_IAvgScore(cm->abc, a, cm->iesc[v]);
	  iesc_vAA[v][cm->abc->Kp-1] = -INFTY; /* missing data is IMPOSSIBLE */
	  break;
	case MP_st:
	  iesc_vAA[v] = ptr_to_start + cur_cell;
	  esl_vec_ISet(iesc_vAA[v], cm->abc->Kp * cm->abc->Kp, -INFTY); /* init all cells to -INFTY */
	  cur_cell += cm->abc->Kp * cm->abc->Kp;
	  /* a is canonical, b is canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = cm->iesc[v][(a * cm->abc->K) + b];
	}
	  }
	  /* a is not canonical, b is canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = iFastPairScoreLeftOnlyDegenerate(cm->abc->K, cm->iesc[v], leftAA[a], b);
	}
	  }
	  /* a is canonical, b is not canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = iFastPairScoreRightOnlyDegenerate(cm->abc->K, cm->iesc[v], rightAA[b], a);
	}
	  }
	  /* a is not canonical, b is not canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = iFastPairScoreBothDegenerate(cm->abc->K, cm->iesc[v], leftAA[a], rightAA[b]);
	}
	  }
	  /* everything else, when either a or b is gap or missing data, stays -INFTY */
	  break;
	default:
	  iesc_vAA[v] = NULL;
	  break;
	}
  }
  for(a = 0; a < cm->abc->Kp; a++) {
	if(leftAA[a] != NULL)  free(leftAA[a]);
	if(rightAA[a] != NULL) free(rightAA[a]);
  }
  free(leftAA);
  free(rightAA);
  return iesc_vAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/* Function: ICopyOptimizedEmitScoresFromFloats()
 * Date:     EPN, Wed Aug 20 14:47:13 2008
 *
 * Purpose:  Allocate and fill an optimized emission score
 *           vector of integer scores. For degenerate
 *           residues calculating the scores is somewhat
 *           compute-intensive, so don't calc them, but copy/integerize
 *           scores from the CM's pre-calculated float
 *           optimized emission score vector.
 *           This is done only because is fast.
 *
 * Returns:  the 2D integer emission score vector on success,
 *           dies immediately on memory allocation error.
 */
int **
ICopyOptimizedEmitScoresFromFloats(CM_t *cm, float **oesc)
{
  int status;
  int **iesc_vAA;
  ESL_DSQ a,b;
  int v;
  int cur_cell;
  int npairs = 0;
  int nsinglets = 0;
  int *ptr_to_start; /* points to block allocated to iesc_vAA[0], nec b/c esc_vAA[0] gets set to NULL, because v == 0 is non-emitter */

  /* count pairs, singlets */
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  nsinglets++;
	  break;
	case MP_st:
	  npairs++;
	  break;
	}
  }

  /* fill emission scores for each state */
  ESL_ALLOC(iesc_vAA,     sizeof(int *) * (cm->M));
  ESL_ALLOC(iesc_vAA[0],  sizeof(int)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs)));
  ptr_to_start = iesc_vAA[0];
  cur_cell = 0;
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  iesc_vAA[v] = ptr_to_start + cur_cell;
	  cur_cell += cm->abc->Kp;
	  for(a = 0; a < cm->abc->K; a++) /* all canonical residues */
	iesc_vAA[v][a]  = cm->iesc[v][a];
	  iesc_vAA[v][cm->abc->K] = -INFTY; /* gap symbol is impossible */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) /* all ambiguous residues */
	iesc_vAA[v][a]  = (int) floor(0.5 + INTSCALE * oesc[v][a]); /* COPY, don't calc */
	  iesc_vAA[v][cm->abc->Kp-1] = -INFTY; /* missing data is IMPOSSIBLE */
	  break;
	case MP_st:
	  iesc_vAA[v] = ptr_to_start + cur_cell;
	  esl_vec_ISet(iesc_vAA[v], cm->abc->Kp * cm->abc->Kp, -INFTY); /* init all cells to -INFTY */
	  cur_cell += cm->abc->Kp * cm->abc->Kp;
	  /* a is canonical, b is canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = cm->iesc[v][(a * cm->abc->K) + b];
	}
	  }
	  /* a is not canonical, b is canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = 0; b < cm->abc->K; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = (int) floor(0.5 + INTSCALE * oesc[v][(a * cm->abc->Kp)+b]); /* COPY, don't calc */
	}
	  }
	  /* a is canonical, b is not canonical */
	  for(a = 0; a < cm->abc->K; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = (int) floor(0.5 + INTSCALE * oesc[v][(a * cm->abc->Kp)+b]); /* COPY, don't calc */
	}
	  }
	  /* a is not canonical, b is not canonical */
	  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	  iesc_vAA[v][(a * cm->abc->Kp) + b]  = (int) floor(0.5 + INTSCALE * oesc[v][(a * cm->abc->Kp)+b]); /* COPY, don't calc */
	}
	  }
	  /* everything else, when either a or b is gap or missing data, stays -INFTY */
	  break;
	default:
	  iesc_vAA[v] = NULL;
	  break;
	}
  }
  return iesc_vAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/* Function: CloneOptimizedEmitScores()
 * Date:     EPN, Thu Dec 15 09:27:06 2011
 *
 * Purpose:  Allocate <oesc> and <ioesc> in <dest> and
 *           copy <src->oesc> and <src->ioesc> into it.
 *
 * Returns:  eslOK on success.
 *           eslEMEM if out of memory, errbuf filled.
 *           eslEINCOMPAT if <dest> is not the same size as <src>, or <dest->oesc> != NULL or <dest->ioesc>, errbuf filled
 */
int
CloneOptimizedEmitScores(const CM_t *src, CM_t *dest, char *errbuf)
{
  int    status;
  int    v;
  int    nsinglets = 0;
  int    npairs    = 0;
  float *fptr_to_start; /* points to block allocated to cm->oesc[0],  nec b/c it gets set to NULL, because v == 0 is non-emitter */
  int   *iptr_to_start; /* points to block allocated to cm->ioesc[0], nec b/c it gets set to NULL, because v == 0 is non-emitter */
  int    cur_cell;

  if(src->M         != dest->M)         ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->M != dest->M");
  if(src->nodes     != dest->nodes)     ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->nodes != dest->nodes");
  if(src->clen      != dest->clen)      ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->clen != dest->clen");
  if(src->abc->type != dest->abc->type) ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->abc->type != dest->abc->type");
  if(dest->oesc     != NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, dest->oesc != NULL");
  if(dest->ioesc    != NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, dest->ioesc != NULL");
  if(src->oesc      == NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->oesc == NULL");
  if(src->ioesc     == NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "cloning optimized emit scores, src->ioesc == NULL");

  /* count pairs, singlets */
  for(v = 0; v < src->M; v++) {
	if(src->sttype[v] == IL_st || src->sttype[v] == ML_st || src->sttype[v] == IR_st || src->sttype[v] == MR_st) nsinglets++;
	if(src->sttype[v] == MP_st) npairs++;
  }
  /* allocate and fill (should be consistent with CalcFOptimizedEmitScores()) */
  ESL_ALLOC(dest->oesc,     sizeof(float *) * (src->M));
  ESL_ALLOC(dest->oesc[0],  sizeof(float)   * ((src->abc->Kp * nsinglets) + (src->abc->Kp * src->abc->Kp * npairs)));
  ESL_ALLOC(dest->ioesc,    sizeof(int *)   * (src->M));
  ESL_ALLOC(dest->ioesc[0], sizeof(int)     * ((src->abc->Kp * nsinglets) + (src->abc->Kp * src->abc->Kp * npairs)));
  fptr_to_start = dest->oesc[0];
  iptr_to_start = dest->ioesc[0];
  cur_cell = 0;
  for(v = 0; v < src->M; v++) {
	if(src->sttype[v] == IL_st || src->sttype[v] == ML_st || src->sttype[v] == IR_st || src->sttype[v] == MR_st) {
	  dest->oesc[v]  = fptr_to_start + cur_cell;
	  dest->ioesc[v] = iptr_to_start + cur_cell;
	  esl_vec_FCopy(src->oesc[v],  src->abc->Kp, dest->oesc[v]);
	  esl_vec_ICopy(src->ioesc[v], src->abc->Kp, dest->ioesc[v]);
	  cur_cell += src->abc->Kp;
	}
	else if(src->sttype[v] == MP_st) {
	  dest->oesc[v]  = fptr_to_start + cur_cell;
	  dest->ioesc[v] = iptr_to_start + cur_cell;
	  esl_vec_FCopy(src->oesc[v],  src->abc->Kp * src->abc->Kp, dest->oesc[v]);
	  esl_vec_ICopy(src->ioesc[v], src->abc->Kp * src->abc->Kp, dest->ioesc[v]);
	  cur_cell += src->abc->Kp * src->abc->Kp;
	}
	else {
	  dest->oesc[v] = NULL;
	  dest->ioesc[v] = NULL;
	}
  }
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: DumpOptimizedEmitScores()
 */
void
DumpOptimizedEmitScores(CM_t *cm, FILE *fp)
{
  int v;

  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  if(cm->oesc  != NULL) {
	fprintf(fp, "SF v: %5d\t", v);
	esl_vec_FDump(fp, cm->oesc[v], cm->abc->Kp, NULL);
	  }
	  if(cm->ioesc != NULL) {
	fprintf(fp, "SI v: %5d\t", v);
	esl_vec_IDump(fp, cm->ioesc[v], cm->abc->Kp, NULL);
	  }
	  break;
	case MP_st:
	  if(cm->oesc  != NULL) {
	fprintf(fp, "PF v: %5d\t", v);
	esl_vec_FDump(fp, cm->oesc[v], cm->abc->Kp * cm->abc->Kp, NULL);
	  }
	  if(cm->ioesc != NULL) {
	esl_vec_IDump(fp, cm->ioesc[v], cm->abc->Kp * cm->abc->Kp, NULL);
	fprintf(fp, "PI v: %5d\t", v);
	  }
	  break;
	}
  }
}

/* Function: FreeOptimizedEmitScores()
 * Date:     EPN, Fri Nov  9 08:44:06 2007
 *
 * Purpose:  Free 2D vectors of optimized emissions scores.
 *           Either fesc_vAA or iesc_vAA (or both) must be non-NULL.
 *
 * Returns:  void
 */
void
FreeOptimizedEmitScores(float **fesc_vAA, int **iesc_vAA, int M)
{
  if(fesc_vAA == NULL && iesc_vAA == NULL) cm_Fail("FreeOptimizedEmitScores() but fesc and iesc are NULL.\n");

  if(fesc_vAA != NULL) {
	if(fesc_vAA[1] != NULL) {
	  free(fesc_vAA[1]); /* note: we free [1], but we alloc'ed to [0], why? b/c fesc_vAA[0] is set to NULL after it's
			  *       used for allocation b/c it's the ROOT_S state, a non-emitter, then fesc_vAA[1] is set
			  *       to point where it used to point (it's the ROOT_IL state, an emitter).
			  */
	}
	free(fesc_vAA);
	fesc_vAA = NULL;
  }

  if(iesc_vAA != NULL) {
	if(iesc_vAA[1] != NULL) {
	  free(iesc_vAA[1]); /* note: we free [1], but we alloc'ed to [0], why? b/c iesc_vAA[0] is set to NULL after it's
			  *       used for allocation b/c it's the ROOT_S state, a non-emitter, then iesc_vAA[1] is set
			  *       to point where it used to point (it's the ROOT_IL state, an emitter).
			  */
	}
	free(iesc_vAA);
	iesc_vAA = NULL;
  }
  return;
}

/* Function: FCalcInitDPScores()
 * Date:     EPN, Fri Nov  9 09:18:07 2007
 *
 * Purpose:  Allocate, fill and return the initial float scores
 *           for a scanning DP matrix for CM <cm> as it's
 *           currently configured. All [0..v..M-1][0..d..W]
 *           cells are allocated and filled, it's up to
 *           the DP function to ignore cells outside bands.
 *
 * Returns:  the 2D float init sc vector on success,
 *           dies immediately on memory error.
 */
float **
FCalcInitDPScores(CM_t *cm)
{
  int status;
  float *el_scA;
  float **init_scAA;
  int v, d;

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (cm->W+1));
  for(d = 0; d <= cm->W; d++) el_scA[d] = cm->el_selfsc * d;
  /* precalculate the initial score for all alpha[v][j][d] cells, it's independent of j
   * these scores ignore bands, (that is cells outside bands still have initsc's calc'ed)
   * it's up to the DP function to skip these cells. */
  ESL_ALLOC(init_scAA,    sizeof(float *) * (cm->M));
  ESL_ALLOC(init_scAA[0], sizeof(float)   * (cm->M) * (cm->W+1));
  for (v = 0; v < cm->M; v++) {
	init_scAA[v] = init_scAA[0] + (v * (cm->W+1));
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for(d = 0; d <= cm->W; d++) init_scAA[v][d] = el_scA[d] + cm->endsc[v];
	}
	else {
	  for(d = 0; d <= cm->W; d++) init_scAA[v][d] = IMPOSSIBLE;
	}
  }
  free(el_scA);
  return init_scAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/* Function: ICalcInitDPScores()
 * Date:     EPN, Fri Nov  9 09:10:33 2007
 *
 * Purpose:  Allocate, fill and return the initial int scores
 *           for a scanning DP matrix for CM <cm> as it's
 *           currently configured. All [0..v..M-1][0..d..W]
 *           cells are allocated and filled, it's up to
 *           the DP function to ignore cells outside bands.
 *
 * Returns:  the 2D integer init sc vector on success,
 *           dies immediately on memory error.
 */
int **
ICalcInitDPScores(CM_t *cm)
{
  int status;
  int *el_scA;
  int **init_scAA;
  int v, d;

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(int) * (cm->W+1));
  for(d = 0; d <= cm->W; d++) el_scA[d] = cm->iel_selfsc * d;
  /* precalculate the initial score for all ialpha[v][j][d] cells, it's independent of j
   * these scores ignore bands, (that is cells outside bands still have initsc's calc'ed)
   * it's up to the DP function to skip these cells. */
  ESL_ALLOC(init_scAA,    sizeof(int *) * (cm->M));
  ESL_ALLOC(init_scAA[0], sizeof(int)   * (cm->M) * (cm->W+1));
  for (v = 0; v < cm->M; v++) {
	init_scAA[v] = init_scAA[0] + (v * (cm->W+1));
	if(cm->iendsc[v] != -INFTY) {
	  for(d = 0; d <= cm->W; d++) init_scAA[v][d] = el_scA[d] + cm->iendsc[v];
	}
	else {
	  for(d = 0; d <= cm->W; d++) init_scAA[v][d] = -INFTY;
	}
  }

  free(el_scA);
  return init_scAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/************************************************************************
 * Functions stolen from HMMER 2.4 for use with CM plan 9 HMMs.
 * Eventually, these should go away, replaced with Easel funcs.
 * These first 3 were stolen from HMMER:mathsupport.c
 *
 * Score2Prob()
 * Prob2Score()
 * Scorify()
 *
 * NOTE: ILogSum() (and auxiliary funcs associated with it) used to be here
 * but moved to logsum.c (EPN, Sat Sep  8 15:49:47 2007)
 <*/

/* Function: Prob2Score()
 *
 * Purpose:  Convert a probability to a scaled integer log_2 odds score.
 *           Round to nearest integer (i.e. note use of +0.5 and floor())
 *           Return the score.
 */
int
Prob2Score(float p, float null)
{
  if(p == 0.0) return -INFTY;
  else         return (int) floor(0.5 + INTSCALE * sreLOG2(p/null));
}

/* Function: Score2Prob()
 *
 * Purpose:  Convert an integer log_2 odds score back to a probability;
 *           needs the null model probability, if any, to do the conversion.
 */
float
Score2Prob(int sc, float null)
{
  if (sc == -INFTY) return 0.;
  else              return (null * sreEXP2((float) sc / INTSCALE));
}

/* Function: Scorify()
 *
 * Purpose:  Convert a scaled integer log-odds score to a floating
 *           point score for output. (could be a macro but who cares.)
 */
float
Scorify(int sc)
{
  if (sc == -INFTY) return IMPOSSIBLE;
  else              return ((float) sc / INTSCALE);
}

/* Function: cm_ExpectedStateOccupancy()
 * Date:     EPN 12.02.05
 *           EPN, Fri Feb  3 09:07:43 2012 [Updated]
 *
 * Purpose:  Fill psi vector. psi[v] is the expected number of times
 *           state v is entered in a globally configured version of
 *           the CM. If the model is locally configured upon entry, we
 *           deal with that by making a copy of the transitions and
 *           redefine transitions out of state 0.
 *
 *           Note: this function was renamed and updated from
 *           'fill_psi()' between versions 1.0.2 and 1.1.
 *
 * Args:     cm - the model

 * Returns: void, dies on an error, which should never happen if the CM is normalized.
 *
 */
double *
cm_ExpectedStateOccupancy(CM_t *cm)
{
  int status;
  int v; /* first state in cm node nd */
  int y;
  int x;
  char tmap_val;
  int nd;
  double summed_psi;
  int nstates;
  int is_insert;
  int final_y;
  char  ***tmap = NULL;  /* transition map */
  float  **t_copy = NULL;  /* copy of transition probabilities */
  double *psi = NULL;

  /* make a copy of the CM transitions */
  ESL_ALLOC(t_copy,    cm->M * sizeof(float *));
  ESL_ALLOC(t_copy[0], cm->M * MAXCONNECT * sizeof(float));
  for (v = 0; v < cm->M; v++) {
	t_copy[v] = t_copy[0] + v * MAXCONNECT;
  }
  esl_vec_FCopy(cm->t[0],    cm->M * MAXCONNECT, t_copy[0]);
  /* deal with possibility that we have local begins on: redefine transitions out state 0 to cm->root_trans in this case */
  if(cm->root_trans != NULL) {
	esl_vec_FCopy(cm->root_trans, cm->cnum[0], t_copy[0]);
  }
  /* deal with possibility that we have local ends on: renormalize transitions out of each state (this will discount
   * the possibility that we transition to a local end)
   */
  if(cm->flags & CMH_LOCAL_END) {
	for (nd = 1; nd < cm->nodes; nd++) {
	  if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	   cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	   cm->ndtype[nd] == BEGR_nd) &&
	  cm->ndtype[nd+1] != END_nd)
	{
	  v = cm->nodemap[nd];
	  esl_vec_FNorm(t_copy[v], cm->cnum[v]);
	}
	}
  }

  /* allocate and initialize psi */
  ESL_ALLOC(psi, sizeof(double) * cm->M);
  esl_vec_DSet(psi, cm->M, 0.);

  /* create the transition map */
  tmap = cm_CreateTransitionMap();

  /*psi[v] is the 'expected number of times state v is entered'.*/
  for (v = 0; v <= cm->M-1; v++) {
	is_insert = (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) ? TRUE : FALSE;

	if(cm->sttype[v] == S_st) {
	  psi[v] = 1.0; /* no transitions into start states - they're necessarily visited in every parse. */
	}
	else { /* not a S_st */
	  final_y = (is_insert) ? 1 : 0; /* insert self loops are handled differently */
	  for (y = cm->pnum[v]-1; y >= final_y; y--) {
	x = cm->plast[v] - y; /* x is a parent of v, add contribution from x to v */
	tmap_val = tmap[(int) cm->stid[x]][(int) cm->ndtype[cm->ndidx[v]+is_insert]][(int) cm->stid[v]];
	psi[v] += psi[x] * t_copy[x][(int) tmap_val];
	  }
	  if(is_insert) {
	psi[v] += psi[v] * (t_copy[v][0] / (1.-t_copy[v][0])); /* the contribution of the self insertion loops */
	  }
	}
  }
  /* Sanity check. For any node the sum of psi values over
   * all split set states should be 1.0. */
  for(nd = 0; nd < cm->nodes; nd++) {
	summed_psi = 0.;
	nstates = TotalStatesInNode(cm->ndtype[nd]);
	for(v = cm->nodemap[nd]; v < cm->nodemap[nd] + nstates; v++) {
	  if(cm->sttype[v] != IL_st && cm->sttype[v] != IR_st) summed_psi += psi[v];
	}
	if((summed_psi < 0.999) || (summed_psi > 1.001)) {
	  cm_Fail("summed psi of split states in node %d not 1.0 but : %f\n", nd, summed_psi);
	}
	/* printf("split summed psi[%d]: %f\n", nd, summed_psi); */
  }
  /* Another sanity check, the only states that can have psi equal to 0
   * are detached insert states (states immediately prior to END_Es) */
  for(v = 0; v < cm->M; v++) {
	if(psi[v] == 0. && (! StateIsDetached(cm, v))) {
	  cm_Fail("psi of state v:%d is 0.0 and this state is not a detached insert! HMM banding would have failed...\n", v);
	}
  }

  cm_FreeTransitionMap(tmap);
  if(t_copy != NULL) {
	if(t_copy[0] != NULL) free(t_copy[0]);
	free(t_copy);
  }
  return psi;

 ERROR:
  cm_FreeTransitionMap(tmap);
  if(t_copy != NULL) {
	if(t_copy[0] != NULL) free(t_copy[0]);
	free(t_copy);
  }
  if(psi != NULL) free(psi);
  return NULL;
}

/* Function: cm_ExpectedPositionOccupancy()
 * Date:     EPN, Fri Feb  3 10:20:19 2012
 *
 * Purpose:  Determine the expected occupancy of each consensus
 *           position 1..clen and return it in <ret_mexpocc> and
 *           determine the expected occupancy of each insert position
 *           (after each position 1..clen) and return it in
 *           <ret_iexpocc>.  Most of the work is done by a call to
 *           cm_ExpectedStateOccupancy().
 *
 *           Caller can also pass in non-NULL values for <opt_psi>
 *           <opt_m2v_1>, <opt_m2v_2> and <opt_i2v>. <opt_psi> holds
 *           expected occupancy of each state. The other arrays hold
 *           the state index that emits at each match position
 *           <opt_m2v_1> and <opt_m2v_2> or inserts after each match
 *           position <opt_i2v>. For <opt_m2v_1> only consensus match
 *           states are used (MATP_MP, MATL_ML and MATR_MR). For
 *           <opt_m2v_2> only non-consensus match states are used:
 *           MATP_ML and MATP_MR, both m2v_1 and m2v_2 are necessary
 *           because 2 states can emit at each position modeled by a
 *           MATP.
 *
 * Args:     cm          - the model
 *           ret_mexpocc - RETURN: [0..clen] expected occupancy of match positions
 *           ret_iexpocc - RETURN: [0..clen] expected occupancy of inserts (after cpos)
 *           opt_psi     - OPTIONAL RETURN: [0..v..M-1] expected occupancy of state v
 *           opt_m2v_1   - OPTIONAL RETURN: [0..clen] consensus match state that emits at position cpos
 *                                                    (must be MATP_MP, MATL_ML or MATR_MR)
 *           opt_m2v_2   - OPTIONAL RETURN: [0..clen] non-consensus match state that emits at position cpos or -1
 *                                                    (if ! -1, must be MATP_ML, MATP_MR)
 *           opt_i2v     - OPTIONAL RETURN: [0..clen] insert state that emits after each position
 *
 * Returns: void, dies on an error, which should never happen if the CM is normalized.
 *
 */
int
cm_ExpectedPositionOccupancy(CM_t *cm, float **ret_mexpocc, float **ret_iexpocc, double **opt_psi, int **opt_m2v_1, int **opt_m2v_2, int **opt_i2v)
{
  int status;
  double *psi = NULL;
  float *mexpocc = NULL;
  float *iexpocc = NULL;
  int   *m2v_1 = NULL;
  int   *m2v_2 = NULL;
  int   *i2v   = NULL;
  int lpos, rpos;
  int v, nd;

  if((psi = cm_ExpectedStateOccupancy(cm)) == NULL) goto ERROR;

  ESL_ALLOC(mexpocc, sizeof(float) * (cm->clen+1));
  ESL_ALLOC(iexpocc, sizeof(float) * (cm->clen+1));
  ESL_ALLOC(m2v_1,   sizeof(int) * (cm->clen+1));
  ESL_ALLOC(m2v_2,   sizeof(int) * (cm->clen+1));
  ESL_ALLOC(i2v,     sizeof(int) * (cm->clen+1));
  esl_vec_FSet(mexpocc, (cm->clen+1), 0.);
  esl_vec_FSet(iexpocc, (cm->clen+1), 0.);
  esl_vec_ISet(m2v_1, (cm->clen+1), -1);
  esl_vec_ISet(m2v_2, (cm->clen+1), -1);
  esl_vec_ISet(i2v,   (cm->clen+1), -1);

  mexpocc[0] = 0.; /* no consensus position 0, this is redundant, but left here to emphasize that it will stay 0. */
  /* DumpEmitMap(stdout, cm->emap, cm); */
  for(v = 0; v < cm->M; v++) {
	if(! StateIsDetached(cm, v)) {
	  nd = cm->ndidx[v];
	  lpos = cm->emap->lpos[nd];
	  rpos = cm->emap->rpos[nd];
	  /* printf("v: %4d nd: %4d %4s %2s lpos: %4d rpos: %4d psi: %.6f\n", v, nd, Nodetype(cm->ndtype[nd]), Statetype(cm->sttype[v]), lpos, rpos, psi[v]); */
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st) mexpocc[lpos] += psi[v]; /* we do += so MATP_MP and MATP_ML both contribute */
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st) mexpocc[rpos] += psi[v]; /* we do += so MATP_MP and MATP_MR both contribute */
	  if(cm->sttype[v] == IL_st) { iexpocc[lpos]   = psi[v]; i2v[lpos] = v; }
	  if(cm->sttype[v] == IR_st) { iexpocc[rpos-1] = psi[v]; i2v[rpos-1] = v; }

	  if(cm->stid[v] == MATP_MP) { m2v_1[lpos] = v; m2v_1[rpos] = v; }
	  if(cm->stid[v] == MATL_ML) { m2v_1[lpos] = v; }
	  if(cm->stid[v] == MATR_MR) { m2v_1[rpos] = v; }
	  if(cm->stid[v] == MATP_ML) { m2v_2[lpos] = v; }
	  if(cm->stid[v] == MATP_MR) { m2v_2[rpos] = v; }
	}
  }

  /* int cpos; for(cpos = 0; cpos <= cm->clen; cpos++) printf("cpos: %3d  mexpocc: %.6f  iexpocc: %.6f m2v_1: %6d m2v_2: %6d i2v: %6d\n", cpos, mexpocc[cpos], iexpocc[cpos], m2v_1[cpos], m2v_2[cpos], i2v[cpos]); */

  *ret_mexpocc = mexpocc;
  *ret_iexpocc = iexpocc;
  if(opt_psi   != NULL) *opt_psi   = psi;    else free(psi);
  if(opt_m2v_1 != NULL) *opt_m2v_1 = m2v_1;  else free(m2v_1);
  if(opt_m2v_2 != NULL) *opt_m2v_2 = m2v_2;  else free(m2v_2);
  if(opt_i2v   != NULL) *opt_i2v = i2v;      else free(i2v);
  return eslOK;

 ERROR:
  if(psi != NULL) free(psi);
  if(mexpocc != NULL) free(mexpocc);
  if(iexpocc != NULL) free(iexpocc);
  *ret_mexpocc = NULL;
  *ret_iexpocc = NULL;
  if(opt_psi   != NULL) *opt_psi = NULL;
  if(opt_m2v_1 != NULL) *opt_m2v_1 = NULL;
  if(opt_m2v_2 != NULL) *opt_m2v_2 = NULL;
  if(opt_i2v   != NULL) *opt_i2v = NULL;
  return eslEMEM;
}

/* Function: cm_CreateTransitionMap()
 * Date:     EPN 12.02.05
 *           EPN, Fri Feb  3 09:07:43 2012 [Updated]
 *
 * Purpose:  Make the predefined transition map which tells you
 *           the index of a given transition from any of the 74
 *           transition sets.
 *
 *           Note: this function was renamed and updated from
 *           'make_tmap()' between versions 1.0.2 and 1.1.
 *
 * Args:     void
 *
 * Returns: transition map, a 3 dimensional character array:
 *          1st D: statetype of v
 *          2nd D: type of downstream node.
 *          3rd D: statetype of y, that we're transitioning to.
 *          value: the index of v->y in cm->t[v]
 *          Caller must free with cm_FreeTransitionMap().
 */
char ***
cm_CreateTransitionMap()
{
  int status;
  int i,j,k;
  char ***tmap;

  ESL_ALLOC(tmap, sizeof(char **) * UNIQUESTATES);
  for(i = 0; i < UNIQUESTATES; i++) {
	ESL_ALLOC(tmap[i], sizeof(char *) * NODETYPES);
	for(j = 0; j < NODETYPES; j++) {
	  ESL_ALLOC(tmap[i][j], sizeof(char) * UNIQUESTATES);
	  for(k = 0; k < UNIQUESTATES; k++) {
	tmap[i][j][k] = -1;
	  }
	}
  }

  /*following code block generated by:
   *perl ~nawrocki/notebook/5_1128_hmnl_ml_hmm/scripts/gen_tmap.pl
   */
  tmap[ROOT_S][BIF_nd][ROOT_IL] = 0;
  tmap[ROOT_S][BIF_nd][ROOT_IR] = 1;
  tmap[ROOT_S][BIF_nd][BIF_B] = 2;

  tmap[ROOT_S][MATP_nd][ROOT_IL] = 0;
  tmap[ROOT_S][MATP_nd][ROOT_IR] = 1;
  tmap[ROOT_S][MATP_nd][MATP_MP] = 2;
  tmap[ROOT_S][MATP_nd][MATP_ML] = 3;
  tmap[ROOT_S][MATP_nd][MATP_MR] = 4;
  tmap[ROOT_S][MATP_nd][MATP_D] = 5;

  tmap[ROOT_S][MATL_nd][ROOT_IL] = 0;
  tmap[ROOT_S][MATL_nd][ROOT_IR] = 1;
  tmap[ROOT_S][MATL_nd][MATL_ML] = 2;
  tmap[ROOT_S][MATL_nd][MATL_D] = 3;

  tmap[ROOT_S][MATR_nd][ROOT_IL] = 0;
  tmap[ROOT_S][MATR_nd][ROOT_IR] = 1;
  tmap[ROOT_S][MATR_nd][MATR_MR] = 2;
  tmap[ROOT_S][MATR_nd][MATR_D] = 3;

  tmap[ROOT_IL][BIF_nd][ROOT_IL] = 0;
  tmap[ROOT_IL][BIF_nd][ROOT_IR] = 1;
  tmap[ROOT_IL][BIF_nd][BIF_B] = 2;

  tmap[ROOT_IL][MATP_nd][ROOT_IL] = 0;
  tmap[ROOT_IL][MATP_nd][ROOT_IR] = 1;
  tmap[ROOT_IL][MATP_nd][MATP_MP] = 2;
  tmap[ROOT_IL][MATP_nd][MATP_ML] = 3;
  tmap[ROOT_IL][MATP_nd][MATP_MR] = 4;
  tmap[ROOT_IL][MATP_nd][MATP_D] = 5;

  tmap[ROOT_IL][MATL_nd][ROOT_IL] = 0;
  tmap[ROOT_IL][MATL_nd][ROOT_IR] = 1;
  tmap[ROOT_IL][MATL_nd][MATL_ML] = 2;
  tmap[ROOT_IL][MATL_nd][MATL_D] = 3;

  tmap[ROOT_IL][MATR_nd][ROOT_IL] = 0;
  tmap[ROOT_IL][MATR_nd][ROOT_IR] = 1;
  tmap[ROOT_IL][MATR_nd][MATR_MR] = 2;
  tmap[ROOT_IL][MATR_nd][MATR_D] = 3;

  tmap[ROOT_IR][BIF_nd][ROOT_IR] = 0;
  tmap[ROOT_IR][BIF_nd][BIF_B] = 1;

  tmap[ROOT_IR][MATP_nd][ROOT_IR] = 0;
  tmap[ROOT_IR][MATP_nd][MATP_MP] = 1;
  tmap[ROOT_IR][MATP_nd][MATP_ML] = 2;
  tmap[ROOT_IR][MATP_nd][MATP_MR] = 3;
  tmap[ROOT_IR][MATP_nd][MATP_D] = 4;

  tmap[ROOT_IR][MATL_nd][ROOT_IR] = 0;
  tmap[ROOT_IR][MATL_nd][MATL_ML] = 1;
  tmap[ROOT_IR][MATL_nd][MATL_D] = 2;

  tmap[ROOT_IR][MATR_nd][ROOT_IR] = 0;
  tmap[ROOT_IR][MATR_nd][MATR_MR] = 1;
  tmap[ROOT_IR][MATR_nd][MATR_D] = 2;

  tmap[BEGL_S][BIF_nd][BIF_B] = 0;

  tmap[BEGL_S][MATP_nd][MATP_MP] = 0;
  tmap[BEGL_S][MATP_nd][MATP_ML] = 1;
  tmap[BEGL_S][MATP_nd][MATP_MR] = 2;
  tmap[BEGL_S][MATP_nd][MATP_D] = 3;

  tmap[BEGR_S][BIF_nd][BEGR_IL] = 0;
  tmap[BEGR_S][BIF_nd][BIF_B] = 1;

  tmap[BEGR_S][MATP_nd][BEGR_IL] = 0;
  tmap[BEGR_S][MATP_nd][MATP_MP] = 1;
  tmap[BEGR_S][MATP_nd][MATP_ML] = 2;
  tmap[BEGR_S][MATP_nd][MATP_MR] = 3;
  tmap[BEGR_S][MATP_nd][MATP_D] = 4;

  tmap[BEGR_S][MATL_nd][BEGR_IL] = 0;
  tmap[BEGR_S][MATL_nd][MATL_ML] = 1;
  tmap[BEGR_S][MATL_nd][MATL_D] = 2;

  tmap[BEGR_IL][BIF_nd][BEGR_IL] = 0;
  tmap[BEGR_IL][BIF_nd][BIF_B] = 1;

  tmap[BEGR_IL][MATP_nd][BEGR_IL] = 0;
  tmap[BEGR_IL][MATP_nd][MATP_MP] = 1;
  tmap[BEGR_IL][MATP_nd][MATP_ML] = 2;
  tmap[BEGR_IL][MATP_nd][MATP_MR] = 3;
  tmap[BEGR_IL][MATP_nd][MATP_D] = 4;

  tmap[BEGR_IL][MATL_nd][BEGR_IL] = 0;
  tmap[BEGR_IL][MATL_nd][MATL_ML] = 1;
  tmap[BEGR_IL][MATL_nd][MATL_D] = 2;

  tmap[MATP_MP][BIF_nd][MATP_IL] = 0;
  tmap[MATP_MP][BIF_nd][MATP_IR] = 1;
  tmap[MATP_MP][BIF_nd][BIF_B] = 2;

  tmap[MATP_MP][MATP_nd][MATP_IL] = 0;
  tmap[MATP_MP][MATP_nd][MATP_IR] = 1;
  tmap[MATP_MP][MATP_nd][MATP_MP] = 2;
  tmap[MATP_MP][MATP_nd][MATP_ML] = 3;
  tmap[MATP_MP][MATP_nd][MATP_MR] = 4;
  tmap[MATP_MP][MATP_nd][MATP_D] = 5;

  tmap[MATP_MP][MATL_nd][MATP_IL] = 0;
  tmap[MATP_MP][MATL_nd][MATP_IR] = 1;
  tmap[MATP_MP][MATL_nd][MATL_ML] = 2;
  tmap[MATP_MP][MATL_nd][MATL_D] = 3;

  tmap[MATP_MP][MATR_nd][MATP_IL] = 0;
  tmap[MATP_MP][MATR_nd][MATP_IR] = 1;
  tmap[MATP_MP][MATR_nd][MATR_MR] = 2;
  tmap[MATP_MP][MATR_nd][MATR_D] = 3;

  tmap[MATP_MP][END_nd][MATP_IL] = 0;
  tmap[MATP_MP][END_nd][MATP_IR] = 1;
  tmap[MATP_MP][END_nd][END_E] = 2;

  tmap[MATP_ML][BIF_nd][MATP_IL] = 0;
  tmap[MATP_ML][BIF_nd][MATP_IR] = 1;
  tmap[MATP_ML][BIF_nd][BIF_B] = 2;

  tmap[MATP_ML][MATP_nd][MATP_IL] = 0;
  tmap[MATP_ML][MATP_nd][MATP_IR] = 1;
  tmap[MATP_ML][MATP_nd][MATP_MP] = 2;
  tmap[MATP_ML][MATP_nd][MATP_ML] = 3;
  tmap[MATP_ML][MATP_nd][MATP_MR] = 4;
  tmap[MATP_ML][MATP_nd][MATP_D] = 5;

  tmap[MATP_ML][MATL_nd][MATP_IL] = 0;
  tmap[MATP_ML][MATL_nd][MATP_IR] = 1;
  tmap[MATP_ML][MATL_nd][MATL_ML] = 2;
  tmap[MATP_ML][MATL_nd][MATL_D] = 3;

  tmap[MATP_ML][MATR_nd][MATP_IL] = 0;
  tmap[MATP_ML][MATR_nd][MATP_IR] = 1;
  tmap[MATP_ML][MATR_nd][MATR_MR] = 2;
  tmap[MATP_ML][MATR_nd][MATR_D] = 3;

  tmap[MATP_ML][END_nd][MATP_IL] = 0;
  tmap[MATP_ML][END_nd][MATP_IR] = 1;
  tmap[MATP_ML][END_nd][END_E] = 2;

  tmap[MATP_MR][BIF_nd][MATP_IL] = 0;
  tmap[MATP_MR][BIF_nd][MATP_IR] = 1;
  tmap[MATP_MR][BIF_nd][BIF_B] = 2;

  tmap[MATP_MR][MATP_nd][MATP_IL] = 0;
  tmap[MATP_MR][MATP_nd][MATP_IR] = 1;
  tmap[MATP_MR][MATP_nd][MATP_MP] = 2;
  tmap[MATP_MR][MATP_nd][MATP_ML] = 3;
  tmap[MATP_MR][MATP_nd][MATP_MR] = 4;
  tmap[MATP_MR][MATP_nd][MATP_D] = 5;

  tmap[MATP_MR][MATL_nd][MATP_IL] = 0;
  tmap[MATP_MR][MATL_nd][MATP_IR] = 1;
  tmap[MATP_MR][MATL_nd][MATL_ML] = 2;
  tmap[MATP_MR][MATL_nd][MATL_D] = 3;

  tmap[MATP_MR][MATR_nd][MATP_IL] = 0;
  tmap[MATP_MR][MATR_nd][MATP_IR] = 1;
  tmap[MATP_MR][MATR_nd][MATR_MR] = 2;
  tmap[MATP_MR][MATR_nd][MATR_D] = 3;

  tmap[MATP_MR][END_nd][MATP_IL] = 0;
  tmap[MATP_MR][END_nd][MATP_IR] = 1;
  tmap[MATP_MR][END_nd][END_E] = 2;

  tmap[MATP_D][BIF_nd][MATP_IL] = 0;
  tmap[MATP_D][BIF_nd][MATP_IR] = 1;
  tmap[MATP_D][BIF_nd][BIF_B] = 2;

  tmap[MATP_D][MATP_nd][MATP_IL] = 0;
  tmap[MATP_D][MATP_nd][MATP_IR] = 1;
  tmap[MATP_D][MATP_nd][MATP_MP] = 2;
  tmap[MATP_D][MATP_nd][MATP_ML] = 3;
  tmap[MATP_D][MATP_nd][MATP_MR] = 4;
  tmap[MATP_D][MATP_nd][MATP_D] = 5;

  tmap[MATP_D][MATL_nd][MATP_IL] = 0;
  tmap[MATP_D][MATL_nd][MATP_IR] = 1;
  tmap[MATP_D][MATL_nd][MATL_ML] = 2;
  tmap[MATP_D][MATL_nd][MATL_D] = 3;

  tmap[MATP_D][MATR_nd][MATP_IL] = 0;
  tmap[MATP_D][MATR_nd][MATP_IR] = 1;
  tmap[MATP_D][MATR_nd][MATR_MR] = 2;
  tmap[MATP_D][MATR_nd][MATR_D] = 3;

  tmap[MATP_D][END_nd][MATP_IL] = 0;
  tmap[MATP_D][END_nd][MATP_IR] = 1;
  tmap[MATP_D][END_nd][END_E] = 2;

  tmap[MATP_IL][BIF_nd][MATP_IL] = 0;
  tmap[MATP_IL][BIF_nd][MATP_IR] = 1;
  tmap[MATP_IL][BIF_nd][BIF_B] = 2;

  tmap[MATP_IL][MATP_nd][MATP_IL] = 0;
  tmap[MATP_IL][MATP_nd][MATP_IR] = 1;
  tmap[MATP_IL][MATP_nd][MATP_MP] = 2;
  tmap[MATP_IL][MATP_nd][MATP_ML] = 3;
  tmap[MATP_IL][MATP_nd][MATP_MR] = 4;
  tmap[MATP_IL][MATP_nd][MATP_D] = 5;

  tmap[MATP_IL][MATL_nd][MATP_IL] = 0;
  tmap[MATP_IL][MATL_nd][MATP_IR] = 1;
  tmap[MATP_IL][MATL_nd][MATL_ML] = 2;
  tmap[MATP_IL][MATL_nd][MATL_D] = 3;

  tmap[MATP_IL][MATR_nd][MATP_IL] = 0;
  tmap[MATP_IL][MATR_nd][MATP_IR] = 1;
  tmap[MATP_IL][MATR_nd][MATR_MR] = 2;
  tmap[MATP_IL][MATR_nd][MATR_D] = 3;

  tmap[MATP_IL][END_nd][MATP_IL] = 0;
  tmap[MATP_IL][END_nd][MATP_IR] = 1;
  tmap[MATP_IL][END_nd][END_E] = 2;

  tmap[MATP_IR][BIF_nd][MATP_IR] = 0;
  tmap[MATP_IR][BIF_nd][BIF_B] = 1;

  tmap[MATP_IR][MATP_nd][MATP_IR] = 0;
  tmap[MATP_IR][MATP_nd][MATP_MP] = 1;
  tmap[MATP_IR][MATP_nd][MATP_ML] = 2;
  tmap[MATP_IR][MATP_nd][MATP_MR] = 3;
  tmap[MATP_IR][MATP_nd][MATP_D] = 4;

  tmap[MATP_IR][MATL_nd][MATP_IR] = 0;
  tmap[MATP_IR][MATL_nd][MATL_ML] = 1;
  tmap[MATP_IR][MATL_nd][MATL_D] = 2;

  tmap[MATP_IR][MATR_nd][MATP_IR] = 0;
  tmap[MATP_IR][MATR_nd][MATR_MR] = 1;
  tmap[MATP_IR][MATR_nd][MATR_D] = 2;

  tmap[MATP_IR][END_nd][MATP_IR] = 0;
  tmap[MATP_IR][END_nd][END_E] = 1;

  tmap[MATL_ML][BIF_nd][MATL_IL] = 0;
  tmap[MATL_ML][BIF_nd][BIF_B] = 1;

  tmap[MATL_ML][MATP_nd][MATL_IL] = 0;
  tmap[MATL_ML][MATP_nd][MATP_MP] = 1;
  tmap[MATL_ML][MATP_nd][MATP_ML] = 2;
  tmap[MATL_ML][MATP_nd][MATP_MR] = 3;
  tmap[MATL_ML][MATP_nd][MATP_D] = 4;

  tmap[MATL_ML][MATL_nd][MATL_IL] = 0;
  tmap[MATL_ML][MATL_nd][MATL_ML] = 1;
  tmap[MATL_ML][MATL_nd][MATL_D] = 2;

  tmap[MATL_ML][MATR_nd][MATL_IL] = 0;
  tmap[MATL_ML][MATR_nd][MATR_MR] = 1;
  tmap[MATL_ML][MATR_nd][MATR_D] = 2;

  tmap[MATL_ML][END_nd][MATL_IL] = 0;
  tmap[MATL_ML][END_nd][END_E] = 1;

  tmap[MATL_D][BIF_nd][MATL_IL] = 0;
  tmap[MATL_D][BIF_nd][BIF_B] = 1;

  tmap[MATL_D][MATP_nd][MATL_IL] = 0;
  tmap[MATL_D][MATP_nd][MATP_MP] = 1;
  tmap[MATL_D][MATP_nd][MATP_ML] = 2;
  tmap[MATL_D][MATP_nd][MATP_MR] = 3;
  tmap[MATL_D][MATP_nd][MATP_D] = 4;

  tmap[MATL_D][MATL_nd][MATL_IL] = 0;
  tmap[MATL_D][MATL_nd][MATL_ML] = 1;
  tmap[MATL_D][MATL_nd][MATL_D] = 2;

  tmap[MATL_D][MATR_nd][MATL_IL] = 0;
  tmap[MATL_D][MATR_nd][MATR_MR] = 1;
  tmap[MATL_D][MATR_nd][MATR_D] = 2;

  tmap[MATL_D][END_nd][MATL_IL] = 0;
  tmap[MATL_D][END_nd][END_E] = 1;

  tmap[MATL_IL][BIF_nd][MATL_IL] = 0;
  tmap[MATL_IL][BIF_nd][BIF_B] = 1;

  tmap[MATL_IL][MATP_nd][MATL_IL] = 0;
  tmap[MATL_IL][MATP_nd][MATP_MP] = 1;
  tmap[MATL_IL][MATP_nd][MATP_ML] = 2;
  tmap[MATL_IL][MATP_nd][MATP_MR] = 3;
  tmap[MATL_IL][MATP_nd][MATP_D] = 4;

  tmap[MATL_IL][MATL_nd][MATL_IL] = 0;
  tmap[MATL_IL][MATL_nd][MATL_ML] = 1;
  tmap[MATL_IL][MATL_nd][MATL_D] = 2;

  tmap[MATL_IL][MATR_nd][MATL_IL] = 0;
  tmap[MATL_IL][MATR_nd][MATR_MR] = 1;
  tmap[MATL_IL][MATR_nd][MATR_D] = 2;

  tmap[MATL_IL][END_nd][MATL_IL] = 0;
  tmap[MATL_IL][END_nd][END_E] = 1;

  tmap[MATR_MR][BIF_nd][MATR_IR] = 0;
  tmap[MATR_MR][BIF_nd][BIF_B] = 1;

  tmap[MATR_MR][MATP_nd][MATR_IR] = 0;
  tmap[MATR_MR][MATP_nd][MATP_MP] = 1;
  tmap[MATR_MR][MATP_nd][MATP_ML] = 2;
  tmap[MATR_MR][MATP_nd][MATP_MR] = 3;
  tmap[MATR_MR][MATP_nd][MATP_D] = 4;

  tmap[MATR_MR][MATR_nd][MATR_IR] = 0;
  tmap[MATR_MR][MATR_nd][MATR_MR] = 1;
  tmap[MATR_MR][MATR_nd][MATR_D] = 2;

  tmap[MATR_D][BIF_nd][MATR_IR] = 0;
  tmap[MATR_D][BIF_nd][BIF_B] = 1;

  tmap[MATR_D][MATP_nd][MATR_IR] = 0;
  tmap[MATR_D][MATP_nd][MATP_MP] = 1;
  tmap[MATR_D][MATP_nd][MATP_ML] = 2;
  tmap[MATR_D][MATP_nd][MATP_MR] = 3;
  tmap[MATR_D][MATP_nd][MATP_D] = 4;

  tmap[MATR_D][MATR_nd][MATR_IR] = 0;
  tmap[MATR_D][MATR_nd][MATR_MR] = 1;
  tmap[MATR_D][MATR_nd][MATR_D] = 2;

  tmap[MATR_IR][BIF_nd][MATR_IR] = 0;
  tmap[MATR_IR][BIF_nd][BIF_B] = 1;

  tmap[MATR_IR][MATP_nd][MATR_IR] = 0;
  tmap[MATR_IR][MATP_nd][MATP_MP] = 1;
  tmap[MATR_IR][MATP_nd][MATP_ML] = 2;
  tmap[MATR_IR][MATP_nd][MATP_MR] = 3;
  tmap[MATR_IR][MATP_nd][MATP_D] = 4;

  tmap[MATR_IR][MATR_nd][MATR_IR] = 0;
  tmap[MATR_IR][MATR_nd][MATR_MR] = 1;
  tmap[MATR_IR][MATR_nd][MATR_D] = 2;

  tmap[BIF_B][BEGL_nd][BEGL_S] = 0;

  tmap[BIF_B][BEGR_nd][BEGR_S] = 0;

  return tmap;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* not reached */
}

/* Function: cm_FreeTransitionMap()
 *
 * Purpose:  Free a transition map.
 *
 * Returns: (void)
 */
void
cm_FreeTransitionMap(char ***tmap)
{
  int i, j;

  if(tmap != NULL) {
	for(i = 0; i < UNIQUESTATES; i++) {
	  for(j = 0; j < NODETYPES; j++) {
	free(tmap[i][j]);
	  }
	  free(tmap[i]);
	}
	free(tmap);
  }
  return;
}

/* Function: InsertsGivenNodeIndex()
 * Incept:   EPN, Tue Feb 28 08:50:19 2012
 *
 * Purpose:  Given a CM and a node index, return the insert state(s)
 *           in that node in <ret_i1> and <ret_i2>.  If less than 2
 *           inserts exist, <ret_i2> will be -1, if no inserts exist,
 *           <ret_i1> will also be set as -1.
 *
 * Returns:  insert state indices in <i1> and <i2>.
 */
void
InsertsGivenNodeIndex(CM_t *cm, int nd, int *ret_i1, int *ret_i2)
{
  int i1 = -1;
  int i2 = -1;
  int  v = cm->nodemap[nd];

  switch (cm->ndtype[nd]) {
  case MATP_nd:  i1 = v+4; i2 = v+5; break;
  case MATL_nd:  i1 = v+2; break;
  case MATR_nd:  i1 = v+2; break;
  case BEGR_nd:  i1 = v+1; break;
  case ROOT_nd:  i1 = v+1; i2 = v+2; break;
  }
  /* other node types don't have any inserts */

  *ret_i1 = i1;
  *ret_i2 = i2;
  return;
}

/* Function: cm_GuideTree()
 * Incept:   EPN, Thu Oct 25 06:24:06 2012
 *
 * Purpose:  Given a CM and a MSA with aligned sequences to that
 *           CM construct a 'guide tree' (a Parsetree_t object)
 *           that corresponds to the CM with MSA coordinates.
 *
 *           The MSA must have RF annotation indicating which
 *           positions are consensus (nongap) and which are
 *           inserts (gap) and which are missing (EL: ~).
 *
 *           This guidetree is useful for backconverting the
 *           aligned residues to parsetrees themselves.
 *
 *           This function is similar to HandModelmaker()
 *           in that it generates a guide tree, but is
 *           different in that we already have the CM,
 *           whereas in HandModelmaker() we do not have
 *           the CM (in fact, in HandModelMaker we use
 *           the guide tree to construct the CM -- the
 *           inverse of what we do here.)
 *
 *           Guide tree for <cm> is returned in <ret_gtr>.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if msa->rf is NULL or
 *           msa->rf nongap length != cm->clen
 */
int
cm_Guidetree(CM_t *cm, char *errbuf, ESL_MSA *msa, Parsetree_t **ret_gtr)
{
  int status;
  int  nd, apos, v, cpos;
  Parsetree_t *gtr = NULL;
  ESL_STACK   *pda;
  int         *matassign = NULL; /* 1..alen   array; 0=insert col, 1=match col */
  int         *elassign  = NULL; /* 1..alen   array; 0=match/ins col, 1=EL col */
  int         *c2a_map = NULL;  /* [1..cm->clen] map from consensus (match) positions to alignment positions */
  int i, j, k, el_i, el_j; /* position counters */

  if(msa->rf  == NULL) ESL_FAIL(eslEINVAL, errbuf, "msa->rf is NULL in cm_Guidetree()");

  /* create a map from consensus positions to alignment positions,
   * and fill in matassign and elassign, all for convenience later
   */
  ESL_ALLOC(c2a_map,   sizeof(int) * (cm->clen+1));
  ESL_ALLOC(matassign, sizeof(int) * (msa->alen+1));
  ESL_ALLOC(elassign,  sizeof(int) * (msa->alen+1));
  c2a_map[0] = 0;  /* invalid */
  cpos = 0;

  for (apos = 1; apos <= msa->alen; apos++) {
	matassign[apos] = ((esl_abc_CIsGap    (msa->abc, msa->rf[apos-1])) || /* CIsGap     returns true for '.', '_' and '-' only (they're equivalent, see create_rna() in esl_alphabet.c()) */
		       (esl_abc_CIsMissing(msa->abc, msa->rf[apos-1])))   /* CIsMissing returns true for '~' only */
	  ? FALSE : TRUE;
	elassign[apos] = (esl_abc_CIsMissing(msa->abc, msa->rf[apos-1])) ? TRUE : FALSE;
	if(! (esl_abc_CIsGap(cm->abc, msa->rf[apos-1]) || esl_abc_CIsMissing(cm->abc, msa->rf[apos-1]))) {
	  cpos++;
	  c2a_map[cpos] = apos;
	}
  }
  if(cpos != cm->clen) ESL_FAIL(eslEINVAL, errbuf, "msa->rf nongap length (%d) != clen (%d)\n", cpos, cm->clen);

  gtr = CreateParsetree(cm->nodes);	/* the guide tree we'll grow */

  /* Now create the guide tree using the same procedure used by
   * cm_modelmaker.c::HandModelmaker(), except that now it is simpler
   * because we already know the node architecture of the CM.  We push
   * and pop node index and i..j alignment coordinates rooted at the
   * node's subtree to a stack to properly deal with the branching
   * structure of the tree. It's important we use this specific
   * strategy (as opposed to the strategy used for constructing an
   * emitmap in display.c:CreateEmitMap()) because we have to deal
   * with inserts and ELs in the MSA.
   */
  if ((pda  = esl_stack_ICreate()) == NULL) goto ERROR;
  if((status = esl_stack_IPush(pda, 1))         != eslOK) goto ERROR;	/* emitl */
  if((status = esl_stack_IPush(pda, msa->alen)) != eslOK) goto ERROR;	/* emitr */
  if((status = esl_stack_IPush(pda, 0))         != eslOK) goto ERROR;	/* node index */
  while (esl_stack_IPop(pda, &nd) != eslEOD) /* pop a node to attach */
	{
	  esl_stack_IPop(pda, &j);
	  esl_stack_IPop(pda, &i); /* i..j == subseq we're responsible for */

	  /* We'll skip EL columns but need to remember what i and j would
	   * be if we didn't: <el_i> and <el_j>. Then, we can set emitr
	   * for MATL and emitl for MATR as <el_j> and <el_i> respectively.
	   */
	  el_i = i;
	  el_j = j;
	  while(i <= msa->alen && elassign[i]) i++;
	  while(j >= 1         && elassign[j]) j--;
	  if(i > (msa->alen+1)) ESL_XFAIL(eslEINVAL, errbuf, "cm_GuideTree(): problem with local ends (RF='~') during guide tree construction");
	  if(j < 0)             ESL_XFAIL(eslEINVAL, errbuf, "cm_GuideTree(): problem with local ends (RF='~') during guide tree construction");

	  /*printf("G nd: %2d (%4s) i: %2d j: %2d el_i: %2d el_j: %2d\n", nd, Nodetype(cm->ndtype[nd]), i, j, el_i, el_j);*/

	  v = cm->nodemap[nd];
	  gtr->state[nd] = cm->ndtype[nd];
	  gtr->mode[nd]  = TRMODE_J;
	  gtr->prv[nd] = (cm->ndtype[nd] == ROOT_nd) ? -1 : cm->ndidx[cm->plast[v]];
	  gtr->n++;

	  if (cm->ndtype[nd] == END_nd) {
	gtr->nxtl[nd]  = -1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;
	  }

	  else if (cm->ndtype[nd] == ROOT_nd) { /* try to push i,j; but deal with IL and IR */
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;
	for (; i <= j; i++) if (matassign[i] || elassign[i]) break;
	for (; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR;
	  }

	  else if (cm->ndtype[nd] == BEGL_nd) {    /* no inserts */
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	  }

	  else if (cm->ndtype[nd] == BEGR_nd)  { /* look for INSL */
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;
	for (; i <= j; i++) if (matassign[i] || elassign[i]) break;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	  }

	  else if (cm->ndtype[nd] == MATL_nd) {
	 	/* i unpaired. This is a MATL node; allow INSL */
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = el_j;
	for (i = i+1; i <= j; i++) if (matassign[i] || elassign[i]) break;
	if((status = esl_stack_IPush(pda, i))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, el_j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	  }

	  else if (cm->ndtype[nd] == MATR_nd) {
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = el_i;
	gtr->emitr[nd] = j;
	for (j = j-1; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, el_i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	  }

	  else if (cm->ndtype[nd] == MATP_nd) {
	gtr->nxtl[nd]  = nd+1;
	gtr->nxtr[nd]  = -1;
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;
	for (i = i+1; i <= j; i++) if (matassign[i] || elassign[i]) break;
	for (j = j-1; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	  }

	  else if (cm->ndtype[nd] == BIF_nd) {
	gtr->nxtl[nd]  = cm->ndidx[cm->cfirst[v]];
	gtr->nxtr[nd]  = cm->ndidx[cm->cnum[v]];
	gtr->emitl[nd] = i;
	gtr->emitr[nd] = j;

	k = c2a_map[cm->emap->rpos[nd+1]-1];

	/* push the right BEGIN node first */
	if((status = esl_stack_IPush(pda, k+1)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j))   != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, cm->ndidx[cm->cnum[cm->nodemap[nd]]])) != eslOK) goto ERROR;
	/* then push the left BEGIN node */
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, cm->ndidx[cm->cfirst[cm->nodemap[nd]]])) != eslOK) goto ERROR;
	  }
	}	/* while something's on the stack */
  esl_stack_Destroy(pda);

  if(c2a_map)   free(c2a_map);
  if(elassign)  free(elassign);
  if(matassign) free(matassign);
  *ret_gtr = gtr;

  return eslOK;

 ERROR:
  if(elassign)  free(elassign);
  if(matassign) free(matassign);
  if(c2a_map)   free(c2a_map);
  if(gtr)       FreeParsetree(gtr);

  return status;
}

/*** End of inlined file: cm.c ***/


/*** Start of inlined file: cm_alidisplay.c ***/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

static int   bp_is_canonical(char lseq, char rseq);
static float post_code_to_avg_pp(char postcode);

/*****************************************************************
 * 1. The CM_ALIDISPLAY object
 *****************************************************************/

/* Function:  cm_alidisplay_Create()
 * Synopsis:  Create an alignment display, from parsetree and model.
 * Incept:    EPN, Wed May 25 05:38:12 2011
 *            SRE, Thu May 23 13:46:09 2002 [St. Louis] (display.c:CreateFancyAli())
 *
 * Purpose:   Given a parsetree (and the model and sequence it corresponds
 *            to), create a pairwise alignment for display; return in a CM_ALIDISPLAY
 *            structure.
 *
 * Args:      cm           - model
 *            errbuf       - for error messages
 *            aln_data     - CM_ALNDATA, includes parsetree, score etc.
 *            sq           - the sequence, parsetree corresponds to subseq beginning at seqoffset
 *            seqoffset    - position in sq which corresponds to first position in tr
 *            tau          - tau used to calc HMM bands, -1.0 if bands not used
 *            elapsed_secs - time (seconds) required for alignment
 *            ret_ad       - RETURN: CM_ALIDISPLAY, allocated and filled here.
 *
 * Returns:   eslOK on success.
 *            eslFAIL on error, errbuf is filled.
 *
 * Xref:      STL6 p.58
 */
int
cm_alidisplay_Create(CM_t *cm, char *errbuf, CM_ALNDATA *adata, const ESL_SQ *sq, int64_t seqoffset,
		     double tau, double elapsed_secs, CM_ALIDISPLAY **ret_ad)
{
  int         status;
  CM_ALIDISPLAY *ad = NULL;      /* alidisplay structure we're building       */
  ESL_STACK    *pda = NULL;      /* pushdown automaton used to traverse trace */
  float        *act = NULL;      /* [0..cm->abc->K-1], count of residue in hit */
  int         type;		 /* type of pda move: PDA_RESIDUE, PDA_STATE  */
  int         v;		 /* state index       */
  int         nd;		 /* node index        */
  int         ti;		 /* position in trace */
  int         x;                 /* position in sequence */
  int         qinset, tinset;	 /* # consensus nt skipped by an EL, or in an EL */
  int         ninset;		 /* max # nt in an EL     */
  int         pos;		 /* position in growing ali */
  int         lc, rc;		 /* indices for left, right pos in consensus */
  int         symi, symj;
  char        mode;
  int         lrf, rrf;  /* chars in annotation line; left, right     */
  int         lstr, rstr;	 /* chars in structure line; left, right      */
  int         lcons, rcons;	 /* chars in consensus line; left, right      */
  int         lmid, rmid;	 /* chars in ali quality line; left, right    */
  int         lnnc, rnnc;	 /* chars in negative scoring noncanonical line; left right */
  int         lseq, rseq;	 /* chars in aligned target line; left, right */
  int         lpost, rpost;	 /* chars in aligned posteriors, left, right  */
  int         do_left, do_right; /* flags to generate left, right             */
  float       tmpsc;             /* a temporary score */
  float       ppavg;             /* average PP for string of contiguous EL emissions */
  int         cm_namelen, cm_acclen, cm_desclen;
  int         sq_namelen, sq_acclen, sq_desclen;
  int         len, n;
  int         len_el; /* lengths for ad->aseq_el, ad->rfline_el and ad->ppline_el vars */

  /* variables for constructing a single sequence MSA from passed-in
   * <tr> so we can copy it's aseq[0] to ad->aseq_el (we only need
   * this in case we output an alignment of all hits later with
   * cm_tophits_Alignment()).
   */
  ESL_SQ      **tmpsqA = NULL;
  Parsetree_t **tmptrA = NULL;
  char        **tmpppA = NULL;
  ESL_MSA      *tmpmsa = NULL;

  /* convenience ptrs */
  Parsetree_t *tr    = adata->tr;
  char        *ppstr = adata->ppstr;

  /* Variables for possibly dealing with truncated alignments */
  int         cfrom_span;        /* first model position spanned by any state in parsetree (regardless of truncation mode) */
  int         cto_span;          /* final model position spanned by any state in parsetree (regardless of truncation mode) */
  int         cfrom_emit;        /* first model position spanned by any state in parsetree in relevant mode
				  * (J or L for MATP&MATL, J or R for MATP&MATR) */
  int         cto_emit;          /* final model position spanned by any state in parsetree in relevant mode
				  * (J or L for MATP&MATL, J or R for MATP&MATR) */
  int         have_i0;           /* TRUE if first residue of source sequence is in the parsetree */
  int         have_j0;           /* TRUE if final residue of source sequence is in the parsetree */

  /* if alignment is in J mode (not L, R, or T) then
   * cfrom_span == cfrom_emit and cto_span == cto_emit
   */
  int         ntrunc_R = 0;      /* num positions truncated at 5' end of alignment */
  int         wtrunc_R = 0;      /* num chars for displaying 5' truncated begin */
  int         ntrunc_L = 0;      /* num positions truncated at 3' end of alignment */
  int         wtrunc_L = 0;      /* num chars for displaying 3' truncated begin */
  int         numwidth;		 /* number of chars to leave for displaying width numbers */
  int         is_left, is_right;

  /* Contract check. We allow the caller to specify the alphabet they want the
   * resulting MSA in, but it has to make sense (see next few lines). */
  if(cm->cmcons == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_alidisplay_Create(): cm->cmcons is NULL");

  /* Useful for debugging:
   * DumpEmitMap(stdout, cm->emap, cm);
   * ParsetreeDump(stdout, tr, cm, sq->dsq+seqoffset-1);
   */

  /* Calculate length of the alignment display (len):
   *                    :  J    L    R  (alignment mode)
   *   MATP node        : +2   +1   +1
   *   MATL node        : +1   +1   +0
   *   MATR node        : +1   +0   +1
   *   IL state         : +1   +1   +0
   *   IR state         : +1   +0   +1
   *   EL:              : +4+w N/A  N/A (w=width of length display : "*[nn]*")
   *   anything else    : +0   +0   +0
   *
   * And if marginal mode of alignment is:
   * L or T: + 4 + wtrunc_L where wtrunc_L is number of digits in number of 5' truncated cpos
   * R or T: + 4 + wtrunc_R where wtrunc_R is number of digits in number of 3' truncated cpos
   */
  len = 0;
  for (ti = 0; ti < tr->n; ti++) {
	v    = tr->state[ti];
	mode = tr->mode[ti];
	if (v == cm->M) {  /* special case: local exit into EL */
	  nd = cm->ndidx[tr->state[ti-1]]; /* calculate node that EL replaced */
	  qinset = cm->cmcons->rpos[nd] - cm->cmcons->lpos[nd] + 1;
	  tinset = tr->emitr[ti]  - tr->emitl[ti]  + 1;
	  ninset = ESL_MAX(qinset,tinset);
	  len += 4;
	  do { len++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	  continue;
	}
	else {
	  nd  = cm->ndidx[v];

	  if     (cm->sttype[v]  == IL_st)   { is_left = TRUE;  is_right = FALSE; }
	  else if(cm->sttype[v]  == IR_st)   { is_left = FALSE; is_right = TRUE;  }
	  else if(cm->ndtype[nd] == MATP_nd) { is_left = TRUE;  is_right = TRUE;  }
	  else if(cm->ndtype[nd] == MATL_nd) { is_left = TRUE;  is_right = FALSE; }
	  else if(cm->ndtype[nd] == MATR_nd) { is_left = FALSE; is_right = TRUE;  }
	  else                               { is_left = FALSE; is_right = FALSE; }

	  if((is_left)  && (mode == TRMODE_J || mode == TRMODE_L)) len++;
	  if((is_right) && (mode == TRMODE_J || mode == TRMODE_R)) len++;
	}
	/* ignore marginal-type local ends, (different from v1.0->v1.0.2)*/
  }
  /* One more step for calculating len, catch 5' and 3' truncations
   * and treat them similar to EL for output. First determine
   * how many positions were truncated 5' and 3'.
   *
   * Of course, we don't actually know how many positions were
   * truncated. Here we guess that it is the maximum possible given
   * the parsetree and the tr->pass_idx (pipeline pass we found the
   * hit in). Specifically in the parsetree, the relevant data is
   * the consensus positions spanned (lpos..rpos) by the internal
   * truncated entry state. The guess is made in ParsetreeToCMBounds()
   * see that function for details.
   */
  have_i0 = (seqoffset == 1) ? TRUE : FALSE;
  have_j0 = ((seqoffset + tr->emitr[0] - 1) == sq->n) ? TRUE : FALSE;
  if((status = ParsetreeToCMBounds(cm, tr, have_i0, have_j0, errbuf, &cfrom_span, &cto_span, &cfrom_emit, &cto_emit, NULL, NULL)) != eslOK) return status;

  /* now determine display length required to show truncations */
  ntrunc_R = wtrunc_R = 0;
  ntrunc_L = wtrunc_L = 0;
  if (cfrom_span != cfrom_emit) {
	/* We'll put a truncated begin at the beginning of the alignment. */
	ntrunc_R = cfrom_emit - cfrom_span;
	ninset   = ntrunc_R;
	wtrunc_R = 0; do { wtrunc_R++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	wtrunc_R += 4; /* space for '<[]*' */
	len += wtrunc_R;
  }
  if (cto_span != cto_emit) {
	/* We'll put a truncated begin at end of the alignment. */
	ntrunc_L = cto_span - cto_emit;
	ninset   = ntrunc_L;
	wtrunc_L = 0; do { wtrunc_L++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	wtrunc_L += 4; /* space for '*[]>' */
	len += wtrunc_L;
  }
#if eslDEBUGLEVEL >= 1
  printf("cfrom_span: %4d\n", cfrom_span);
  printf("cfrom_emit: %4d\n", cfrom_emit);
  printf("cto_emit:   %4d\n", cto_emit);
  printf("cto_span:   %4d\n", cto_span);
#endif

  /* Create strings of the full model and sequence used in an output
   * alignment. We use Parsetrees2Alignment() for this to get a 1 seq MSA.
   * This seems like it may be expensive, but it's trival compared to
   * time required for other steps of pipeline (i.e. CM DP functions).
   */
  ESL_ALLOC(tmpsqA, sizeof(ESL_SQ *) * 1);
  if((tmpsqA[0] = esl_sq_CreateDigitalFrom(cm->abc, "i", sq->dsq + seqoffset - 1, tr->emitr[0] - tr->emitl[0] + 1, NULL, NULL, NULL)) == NULL) {
	goto ERROR;
  }
  ESL_ALLOC(tmptrA, sizeof(Parsetree_t *) * 1);
  tmptrA[0] = tr;
  if(adata->ppstr) {
	ESL_ALLOC(tmpppA, sizeof(char *) * 1);
	tmpppA[0] = adata->ppstr;
  }
  if((status = Parsetrees2Alignment(cm, errbuf, cm->abc, tmpsqA, NULL, tmptrA, tmpppA, 1, NULL, NULL, TRUE, FALSE, &tmpmsa)) != eslOK) goto ERROR;
  esl_sq_Destroy(tmpsqA[0]);
  free(tmpsqA); tmpsqA = NULL;
  free(tmptrA); tmptrA = NULL; /* don't free tmptrA[0], it was just used as a pointer */
  if(adata->ppstr) { free(tmpppA); tmpppA = NULL; } /* don't free tmpppA[0], it was just meant as a pointer */
  len_el = tmpmsa->alen;

  /* Now we know the length of all arrays (len), determine total amount of memory required, and allocate it */
  /* Allocate the char arrays */

  n  = (len+1) * 5;    /* model, csline, mline, aseq, ncline */
  n += 2 * (len_el+1); /* aseq_el, rfline_el (includes EL emits) */
  if(adata->ppstr  != NULL) n += len+1 + len_el+1; /* ppline and ppline_el */
  if(cm->rf        != NULL) n += len+1;
  cm_namelen = strlen(cm->name);                           n += cm_namelen + 1;
  cm_acclen  = (cm->acc  != NULL ? strlen(cm->acc)  : 0);  n += cm_acclen  + 1;
  cm_desclen = (cm->desc != NULL ? strlen(cm->desc) : 0);  n += cm_desclen + 1;
  sq_namelen = strlen(sq->name);                           n += sq_namelen + 1;
  sq_acclen  = strlen(sq->acc);                            n += sq_acclen  + 1; /* sq->acc is "\0" when unset */
  sq_desclen = strlen(sq->desc);                           n += sq_desclen + 1; /* sq->desc is "\0" when unset */

  ESL_ALLOC(ad, sizeof(CM_ALIDISPLAY));
  ad->mem          = NULL;
  ad->memsize      = sizeof(char) * n;
  ad->sc           = adata->sc;
  ad->avgpp        = adata->pp;
  ad->tau          = tau;
  ad->matrix_Mb    = adata->mb_tot;
  ad->elapsed_secs = elapsed_secs;
  ad->hmmonly      = FALSE;
  ad->N            = len;
  ad->N_el         = len_el;

  /* and finally, space for the unaligned sequence (only nec b/c the
   * aseq will not include the residues from EL emissions).
   */

  pos = 0;
  ESL_ALLOC(ad->mem, ad->memsize);
  if (cm->rf != NULL) { ad->rfline = ad->mem + pos;  pos += len+1;} else { ad->rfline = NULL; }
  ad->ncline     = ad->mem + pos;  pos += len+1;
  ad->csline     = ad->mem + pos;  pos += len+1;
  ad->model      = ad->mem + pos;  pos += len+1;
  ad->mline      = ad->mem + pos;  pos += len+1;
  ad->aseq       = ad->mem + pos;  pos += len+1;
  if (adata->ppstr  != NULL) { ad->ppline    = ad->mem + pos;  pos += len+1;}    else { ad->ppline    = NULL; }
  ad->aseq_el    = ad->mem + pos;  pos += len_el+1;
  ad->rfline_el  = ad->mem + pos;  pos += len_el+1;
  if (adata->ppstr  != NULL) { ad->ppline_el = ad->mem + pos;  pos += len_el+1;} else { ad->ppline_el = NULL; }
  ad->cmname     = ad->mem + pos;  pos += cm_namelen +1;
  ad->cmacc      = ad->mem + pos;  pos += cm_acclen  +1;
  ad->cmdesc     = ad->mem + pos;  pos += cm_desclen +1;
  ad->sqname     = ad->mem + pos;  pos += sq_namelen +1;
  ad->sqacc      = ad->mem + pos;  pos += sq_acclen  +1;
  ad->sqdesc     = ad->mem + pos;  pos += sq_desclen +1;

  /* Set name, acc, desc char arrays */
  strcpy(ad->cmname, cm->name);
  if (cm->acc  != NULL) strcpy(ad->cmacc,  cm->acc);  else ad->cmacc[0]  = 0;
  if (cm->desc != NULL) strcpy(ad->cmdesc, cm->desc); else ad->cmdesc[0] = 0;
  strcpy(ad->sqname,  sq->name);
  strcpy(ad->sqacc,   sq->acc);
  strcpy(ad->sqdesc,  sq->desc);

  /* Set aseq_el and possibly ppline_el */
  strcpy(ad->aseq_el,   tmpmsa->aseq[0]);
  strcpy(ad->rfline_el, tmpmsa->rf);
  if(adata->ppstr) strcpy(ad->ppline_el, tmpmsa->pp[0]);

  /* Set clen */
  ad->clen = cm->clen;

  /* Allocate and initialize.
   * Blank the annotation lines (memset calls) - only needed
   * because of the way we deal w/ EL.
   */
  if (cm->rf != NULL) memset(ad->rfline, ' ', ad->N);
  memset(ad->ncline,  ' ', ad->N);
  memset(ad->csline,  ' ', ad->N);
  memset(ad->model,   ' ', ad->N);
  memset(ad->mline,   ' ', ad->N);
  memset(ad->aseq,    ' ', ad->N);
  if(adata->ppstr != NULL)   memset(ad->ppline, ' ', ad->N);

  /* Fill in the lines: traverse the traceback.
   */
  pos = 0;

  /* Before we start on the stack, add truncated begin info at the
   * beginning of the alignment display, if nec (if tr->mode[0] is R
   * or T).
   */
  if(ntrunc_R > 0) {
	/* wtrunc_R and ntrunc_R were calc'ed above */
	memset(ad->csline+pos,  '~', wtrunc_R);
	sprintf(ad->model+pos, "<[%*d]*", wtrunc_R-4, ntrunc_R);
	sprintf(ad->aseq+pos,  "<[%*s]*", wtrunc_R-4, "0");
	if(adata->ppstr != NULL) {
	  for(x = 0; x < wtrunc_R; x++) ad->ppline[pos+x] = '.';
	}
	pos += wtrunc_R;
  }

  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
  if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
  while (esl_stack_IPop(pda, &type) != eslEOD)
	{
	  if (type == PDA_RESIDUE) {
	if (cm->rf != NULL) {
	  esl_stack_IPop(pda, &rrf);
	  ad->rfline[pos] = rrf;
	}
	esl_stack_IPop(pda, &rnnc);	  ad->ncline[pos] = rnnc;
	esl_stack_IPop(pda, &rstr); 	  ad->csline[pos] = rstr;
	esl_stack_IPop(pda, &rcons);	  ad->model[pos]  = rcons;
	esl_stack_IPop(pda, &rmid);	  ad->mline[pos]  = rmid;
	esl_stack_IPop(pda, &rseq);       ad->aseq[pos]   = rseq;
	if(ppstr != NULL) {
	  esl_stack_IPop(pda, &rpost);    ad->ppline[pos] = rpost;
	}
	pos++;
	continue;
	  }

	  /* Else, we're PDA_STATE - e.g. dealing with a trace node.
	   */
	  esl_stack_IPop(pda, &ti);
	  v = tr->state[ti];

	  /* Deal with EL (local ends, state M) as a special case.
	   */
	  if (v == cm->M) {
	nd = 1 + cm->ndidx[tr->state[ti-1]]; /* calculate node that EL replaced */
	qinset     = cm->cmcons->rpos[nd] - cm->cmcons->lpos[nd] + 1;
	tinset     = tr->emitr[ti]  - tr->emitl[ti]  + 1;
	ninset     = ESL_MAX(qinset,tinset);
	numwidth = 0; do { numwidth++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	memset(ad->csline+pos,  '~', numwidth+4);
	sprintf(ad->model+pos, "*[%*d]*", numwidth, qinset);
	sprintf(ad->aseq+pos, "*[%*d]*", numwidth, tinset);
	if(cm->rf != NULL) memset(ad->rfline+pos,  '~', numwidth+4);
	if(adata->ppstr != NULL) {
	  /* calculate the single character PP code for the average posterior
	   * by averaging the average for the PP codes in ppstr (this gives
	   * the correct PP code (I didn't think it was guaranteed to at first
	   * but a simulation I performed couldn't produce a counterexample!
	   * xref: ~nawrockie/notebook/12_0423_inf_final_stress_tests/00LOG; May 22, 2012
	   */
	  ppavg = 0.;
	  for(x = tr->emitl[ti]; x <= tr->emitr[ti]; x++) {
	    ppavg += post_code_to_avg_pp(adata->ppstr[x-1]);
	  }
	  ppavg /= (float) (tr->emitr[ti]  - tr->emitl[ti]  + 1);
	  ad->ppline[pos]   = '.';
	  ad->ppline[pos+1] = '.';
	  for(x = 0; x < (numwidth-1); x++) ad->ppline[pos+2+x] = '.';
	  if(tr->emitl[ti] <= tr->emitr[ti]) {
	    ad->ppline[pos+numwidth+1] = (ppavg + 0.05 >= 1.0) ? '*' :  (char) ((ppavg + 0.05) * 10.0) + '0';
	  }
	  else { /* no residues emitted in EL, PP annotation is a gap ('.') */
	    ad->ppline[pos+numwidth+1] = '.';
	  }
	  ad->ppline[pos+numwidth+2] = '.';
	  ad->ppline[pos+numwidth+3] = '.';
	}
	pos += 4 + numwidth;
	continue;
	  }

	  /* Fetch some info into tmp variables, for "clarity"
	   */
	  nd   = cm->ndidx[v];	                      /* what CM node we're in */
	  lc   = cm->cmcons->lpos[nd];	              /* where CM node aligns to in consensus (left) */
	  rc   = cm->cmcons->rpos[nd];                    /* where CM node aligns to in consensus (right) */
	  symi = sq->dsq[tr->emitl[ti] + (seqoffset-1)];  /* residue indices that node is aligned to (left) */
	  symj = sq->dsq[tr->emitr[ti] + (seqoffset-1)];  /* residue indices that node is aligned to (right) */
	  if(ppstr != NULL) { /* posterior codes are indexed 0..alen-1, off-by-one w.r.t dsq */
	lpost = '.'; /* init to gap, if it corresponds to a residue, we'll reset it below */
	rpost = '.'; /* init to gap, if it corresponds to a residue, we'll reset it below */
	  }
	  mode = tr->mode[ti];

	  /* Calculate four of the six lines: rfline, csline, model, and aseq.
	   */
	  do_left = do_right = FALSE;
	  if (cm->sttype[v] == IL_st) {
	if(mode == TRMODE_J || mode == TRMODE_L) {
	  /* careful, its impt the above 2 'if's are separated, we don't want to
	   * enter the nearest 'else' below if we're an IL (specifically a MATP_IL
	   * with mode==TRMODE_R).
	   */
	  do_left = TRUE;
	  if (cm->rf != NULL) lrf = '.';
	  lstr    = '.';
	  lcons   = '.';
	  lseq = tolower((int) cm->abc->sym[symi]);
	  if(ppstr != NULL) lpost = ppstr[tr->emitl[ti]-1]; /* watch off-by-one b/t ppstr and dsq */
	}
	  }
	  else if (cm->sttype[v] == IR_st) {
	if (mode == TRMODE_J || mode == TRMODE_R) {
	  /* careful, its impt the above 2 'if's are separated, we don't want to
	   * enter the nearest 'else' below if we're an IR (specifically a MATP_IR
	   * with mode==TRMODE_L).
	   */
	  do_right = TRUE;
	  if (cm->rf != NULL) rrf = '.';
	  rstr    = '.';
	  rcons   = '.';
	  rseq = tolower((int) cm->abc->sym[symj]);
	  if(ppstr != NULL) rpost = ppstr[tr->emitr[ti]-1]; /* watch off-by-one b/t ppstr and dsq */
	}
	  }
	  else {
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) && (mode == TRMODE_J || mode == TRMODE_L)) {
	  do_left = TRUE;
	  if (cm->rf != NULL) lrf = cm->rf[lc+1];
	  lstr   = cm->cmcons->cstr[lc];
	  lcons  = (cm->flags & CMH_CONS) ? cm->consensus[(lc+1)] : cm->cmcons->cseq[lc];
	  if (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st) {
	    lseq = cm->abc->sym[symi];
	    if(ppstr != NULL) lpost = ppstr[tr->emitl[ti]-1]; /* watch off-by-one b/t ppstr and dsq */
	  }
	  else {
	    lseq   = '-';
	    if(ppstr != NULL) lpost  = '.';
	  }
	}
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) && (mode == TRMODE_J || mode == TRMODE_R)) {
	  do_right = TRUE;
	  if (cm->rf != NULL) rrf = cm->rf[rc+1];
	  rstr   = cm->cmcons->cstr[rc];
	  rcons  = (cm->flags & CMH_CONS) ? cm->consensus[(rc+1)] : cm->cmcons->cseq[rc];
	  if (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st) {
	    rseq = cm->abc->sym[symj];
	    if(ppstr != NULL) rpost = ppstr[tr->emitr[ti]-1]; /* watch off-by-one b/t ppstr and dsq */
	  }
	  else {
	    rseq = '-';
	    if(ppstr != NULL) rpost = '.';
	  }
	}
	  }

	  /* Use emission p and score to set lmid, rmid line for emitting states.
	   */
	  lmid = rmid = ' ';
	  lnnc = rnnc = ' ';
	  if (cm->sttype[v] == MP_st) {
	if (mode == TRMODE_L) {
	  if(lseq == toupper(lcons)) lmid = lseq;
	  lnnc = '?';
	}
	else if (mode == TRMODE_R) {
	  if(rseq == toupper(rcons)) rmid = rseq;
	  rnnc = '?';
	}
	else if (mode == TRMODE_J) {
	  tmpsc = DegeneratePairScore(cm->abc, cm->esc[v], symi, symj);
	  if (lseq == toupper(lcons) && rseq == toupper(rcons)) {
	    lmid = lseq;
	    rmid = rseq;
	  }
	  else if (tmpsc >= 0) {
	    lmid = rmid = ':';
	  }
	  /* determine lnnc, rnnc for optional negative scoring
	   * non-canonical annotation, they are 'v' if lseq and rseq
	   * are a negative scoring non-canonical (not a
	   * AU,UA,GC,CG,GU,UG) pair.
	   */
	  if (tmpsc < 0 && (! bp_is_canonical(lseq, rseq))) {
	    lnnc = rnnc = 'v';
	  }
	}
	  }
	  else if ((cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) &&
	       (mode == TRMODE_J || mode == TRMODE_L)) {
	if (lseq == toupper(lcons)) {
	  lmid = lseq;
	}
	else if(esl_abc_FAvgScore(cm->abc, symi, cm->esc[v]) > 0) {
	  lmid = '+';
	}
	  }
	  else if ((cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) &&
	       (mode == TRMODE_J || mode == TRMODE_R)) {
	if (rseq == toupper(rcons)) {
	  rmid = rseq;
	}
	else if(esl_abc_FAvgScore(cm->abc, symj, cm->esc[v]) > 0) {
	  rmid = '+';
	}
	  }
	  if((cm->stid[v] == MATP_ML || cm->stid[v] == MATP_MR) && mode == TRMODE_J) {
	lnnc = rnnc = 'v'; /* mark non-truncated half base-pairs (MATP_ML or MATP_MR) with 'v' */
	  }
	  if(cm->stid[v] == MATP_ML && mode == TRMODE_L) {
	lnnc = '?'; /* right half is truncated away, we're not sure if its canonical or not */
	  }
	  if(cm->stid[v] == MATP_MR && mode == TRMODE_R) {
	rnnc = '?'; /* left half is truncated away, we're not sure if its canonical or not */
	  }
	  /* If we're storing a residue leftwise - just do it.
	   * If rightwise - push it onto stack.
	   */
	  if (do_left) {
	if (cm->rf != NULL) ad->rfline[pos] = lrf;
	ad->ncline[pos]  = lnnc;
	ad->csline[pos]  = lstr;
	ad->model[pos]   = lcons;
	ad->mline[pos]   = lmid;
	ad->aseq[pos]    = lseq;
	if(ppstr != NULL)  ad->ppline[pos] = lpost;
	pos++;
	  }
	  if (do_right) {
	if(ppstr != NULL) {
	  if ((status = esl_stack_IPush(pda, (int) rpost)) != eslOK) goto ERROR;
	}
	if ((status = esl_stack_IPush(pda, (int) rseq))  != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rmid))  != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rcons)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rstr))  != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rnnc))  != eslOK) goto ERROR;
	if (cm->rf != NULL) if ((status = esl_stack_IPush(pda, (int) rrf)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_RESIDUE)) != eslOK) goto ERROR;
	  }

	  /* Push the child trace nodes onto the PDA;
	   * right first, so it pops last.
	   */
	  if (tr->nxtr[ti] != -1) {
	if ((status = esl_stack_IPush(pda, tr->nxtr[ti])) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	  }
	  if (tr->nxtl[ti] != -1) {
	if ((status = esl_stack_IPush(pda, tr->nxtl[ti])) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	  }
	  else if (cm->sttype[v] != E_st) {
	; /* marginal type local end, do nothing */
	  }
	} /* end loop over the PDA; PDA now empty */

  /* Final step, add truncated begin info at the end of the alignment
   * display, if nec (if tr->mode[0] is L or T).
   */
  if(ntrunc_L > 0) {
	/* wtrunc_L and ntrunc_L were calc'ed above */
	memset(ad->csline+pos,  '~', wtrunc_L);
	sprintf(ad->model+pos, "*[%*d]>", wtrunc_L-4, ntrunc_L);
	sprintf(ad->aseq+pos,  "*[%*s]>", wtrunc_L-4, "0");
	if(adata->ppstr != NULL) {
	  for(x = 0; x < wtrunc_L; x++) ad->ppline[pos+x] = '.';
	}
	pos += wtrunc_L;
  }

  /* Truly final step, calculate GC frequency, we could do this
   * inside the parstree traversal, but this is easier and can't
   * be much slower given that we'd need to check if we were an
   * emitter before calling, or count gaps as well.
   */
  ESL_ALLOC(act, sizeof(float) * cm->abc->K);
  esl_vec_FSet(act, cm->abc->K, 0.);
  for(x = tr->emitl[0] + seqoffset - 1; x <= tr->emitr[0] + seqoffset - 1; x++) {
	esl_abc_FCount(cm->abc, act, sq->dsq[x], 1.0);
  }

  if(cm->rf != NULL) ad->rfline[ad->N] = '\0';
  ad->ncline[ad->N] = '\0';
  ad->csline[ad->N] = '\0';
  ad->model[ad->N]  = '\0';
  ad->mline[ad->N]  = '\0';
  ad->aseq[ad->N]   = '\0';
  if(ppstr != NULL)  ad->ppline[ad->N] = '\0';
  ad->sqfrom      = tr->emitl[0] + seqoffset-1;
  ad->sqto        = tr->emitr[0] + seqoffset-1;
  ad->cfrom_emit  = cfrom_emit;
  ad->cto_emit    = cto_emit;
  ad->cfrom_span  = cfrom_span;
  ad->cto_span    = cto_span;
  ad->gc          = (act[1] + act[2]) / (float) (tr->emitr[0]- tr->emitl[0] + 1);

  esl_stack_Destroy(pda);
  if(tmpmsa != NULL)  esl_msa_Destroy(tmpmsa);
  if(act    != NULL)  free(act);
  if(ret_ad != NULL) *ret_ad = ad;
  return eslOK;

 ERROR:
  if(pda    != NULL)  esl_stack_Destroy(pda);
  if(ad     != NULL)  cm_alidisplay_Destroy(ad);
  if(act    != NULL)  free(act);
  if(ret_ad != NULL) *ret_ad = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "cm_alidisplay_Create() out of memory");
  return status; /*  errbuf filled some other way */
}

/* Function:  cm_alidisplay_CreateFromP7()
 * Synopsis:  Create a CM_ALIDISPLAY from a P7_ALIDISPLAY.
 * Incept:    EPN, Mon Apr  9 12:46:07 2012
 *            SRE, Thu May 23 13:46:09 2002 [St. Louis] (display.c:CreateFancyAli())
 *
 * Purpose:   Given a P7_ALIDISPLAY, create a CM_ALIDISPLAY from it.
 *            A copy of all relevant strings is made. This function
 *            was written for special pipeline runs which use an
 *            HMM only.
 *
 * Args:      cm           - model
 *            errbuf       - for error messages
 *            sq           - the sequence, parsetree corresponds to subseq beginning at seqoffset
 *            seqoffset    - position in sq which corresponds to first position in tr
 *            p7sc         - score of envelope p7ad was derived from
 *            p7pp         - avg pp of all aligned residues in envelope P7_ALIDISPLAY was derived from
 *            p7ad         - P7_ALIDISPLAY to convert
 *            ret_ad       - RETURN: CM_ALIDISPLAY, allocated and filled here.
 *
 * Returns:   eslOK on success.
 *            eslFAIL on error, errbuf is filled.
 *
 * Xref:      STL6 p.58
 */
int
cm_alidisplay_CreateFromP7(CM_t *cm, char *errbuf, const ESL_SQ *sq, int64_t seqoffset, float p7sc, float p7pp, P7_ALIDISPLAY *p7ad, CM_ALIDISPLAY **ret_ad)
{
  int            status;
  CM_ALIDISPLAY *ad = NULL;      /* alidisplay structure we're building       */
  int            n;
  int            cm_namelen, cm_acclen, cm_desclen;
  int            sq_namelen, sq_acclen, sq_desclen;
  int            len;
  int            len_el;
  int            pos;		  /* position in ad->mem */
  int            x; 		  /* residue position */
  float         *act = NULL;      /* [0..cm->abc->K-1], count of residue in hit */
  int            n5p_skipped = 0; /* number of 5' match positions skipped (p7ad->hmmfrom-1) */
  int            n3p_skipped = 0; /* number of 3' match positions skipped (p7ad->M - p7ad->hmmto) */

  len = p7ad->N;
  n5p_skipped = p7ad->hmmfrom -1;
  n3p_skipped = p7ad->M - p7ad->hmmto;
  len_el = len + n5p_skipped + n3p_skipped;

  /* Allocate the char arrays, we copy aseq into aseq_el, rf into
   * rfline_el and ppline into ppline_el for consistency with
   * cm_alidisplay_Create()
   */
  n  = (len+1) * 4;    /* model, csline, mline, aseq (ncline will remain NULL) */
  n += 2 * (len_el+1); /* aseq_el and rfline_el, mandatory */
  if(p7ad->ppline  != NULL) n += len+1 + len_el+1; /* ppline and ppline_el */
  if(p7ad->rfline  != NULL) n += len+1;
  cm_namelen = strlen(cm->name);                           n += cm_namelen + 1;
  cm_acclen  = (cm->acc  != NULL ? strlen(cm->acc)  : 0);  n += cm_acclen  + 1;
  cm_desclen = (cm->desc != NULL ? strlen(cm->desc) : 0);  n += cm_desclen + 1;
  sq_namelen = strlen(sq->name);                           n += sq_namelen + 1;
  sq_acclen  = strlen(sq->acc);                            n += sq_acclen  + 1; /* sq->acc is "\0" when unset */
  sq_desclen = strlen(sq->desc);                           n += sq_desclen + 1; /* sq->desc is "\0" when unset */

  ESL_ALLOC(ad, sizeof(CM_ALIDISPLAY));
  ad->mem          = NULL;
  ad->memsize      = sizeof(char) * n;
  ad->sc           = p7sc;
  ad->avgpp        = p7pp;
  ad->tau          = -1.0;
  ad->matrix_Mb    = 0.0;  /* unknown */
  ad->elapsed_secs = 0.0;  /* unknown */
  ad->hmmonly      = TRUE;
  ad->N            = len;
  ad->N_el         = len + n5p_skipped + n3p_skipped;

  ad->clen = cm->clen;

  ad->sqfrom     = p7ad->sqfrom;
  ad->sqto       = p7ad->sqto;
  ad->cfrom_emit = p7ad->hmmfrom;
  ad->cto_emit   = p7ad->hmmto;
  ad->cfrom_span = p7ad->hmmfrom;
  ad->cto_span   = p7ad->hmmto;

  /* calculate GC frequency */
  ESL_ALLOC(act, sizeof(float) * cm->abc->K);
  esl_vec_FSet(act, cm->abc->K, 0.);
  for(x = p7ad->sqfrom; x <= p7ad->sqto; x++) esl_abc_FCount(cm->abc, act, sq->dsq[x], 1.0);
  ad->gc = (act[1] + act[2]) / (float) (p7ad->sqto - p7ad->sqfrom + 1);

  pos = 0;
  ESL_ALLOC(ad->mem, ad->memsize);
  if (p7ad->rfline != NULL) { ad->rfline = ad->mem + pos;  pos += len+1;} else { ad->rfline = NULL; }
  ad->ncline     = NULL; /* not printed in HMM hits */
  ad->csline     = ad->mem + pos;  pos += len+1;
  ad->model      = ad->mem + pos;  pos += len+1;
  ad->mline      = ad->mem + pos;  pos += len+1;
  ad->aseq       = ad->mem + pos;  pos += len+1;
  if (p7ad->ppline  != NULL) { ad->ppline    = ad->mem + pos;  pos += len+1;}    else { ad->ppline    = NULL; }
  ad->aseq_el    = ad->mem + pos;  pos += len_el+1;
  ad->rfline_el  = ad->mem + pos;  pos += len_el+1;
  if (p7ad->ppline  != NULL) { ad->ppline_el = ad->mem + pos;  pos += len_el+1;} else { ad->ppline_el = NULL; }
  ad->cmname     = ad->mem + pos;  pos += cm_namelen +1;
  ad->cmacc      = ad->mem + pos;  pos += cm_acclen  +1;
  ad->cmdesc     = ad->mem + pos;  pos += cm_desclen +1;
  ad->sqname     = ad->mem + pos;  pos += sq_namelen +1;
  ad->sqacc      = ad->mem + pos;  pos += sq_acclen  +1;
  ad->sqdesc     = ad->mem + pos;  pos += sq_desclen +1;

  /* Set name, acc, desc char arrays */
  strcpy(ad->cmname, cm->name);
  if (cm->acc  != NULL) strcpy(ad->cmacc,  cm->acc);  else ad->cmacc[0]  = 0;
  if (cm->desc != NULL) strcpy(ad->cmdesc, cm->desc); else ad->cmdesc[0] = 0;
  strcpy(ad->sqname,  sq->name);
  strcpy(ad->sqacc,   sq->acc);
  strcpy(ad->sqdesc,  sq->desc);

  /* Copy strings from p7ad */
  if(p7ad->rfline) strcpy(ad->rfline,  p7ad->rfline);
  strcpy(ad->csline,  p7ad->csline);
  strcpy(ad->model,   p7ad->model);
  strcpy(ad->mline,   p7ad->mline);
  strcpy(ad->aseq,    p7ad->aseq);
  if(p7ad->ppline) strcpy(ad->ppline,  p7ad->ppline);

  /* Create aseq_el, rfline_el, and ppline_el. aseq_el and ppline_el
   * are copies of p7ad->aseq p7ad->ppline with n5p_skipped '-'
   * characters prepended and n3p_skipped '-' characters appended.
   * rfline_el is a copy of p7ad->rfline but with 'x' instead
   * '-' (to indicate the skipped positions were match positions).
   */
  for(x = 0; x < n5p_skipped; x++) ad->aseq_el[x] = '-';
  memcpy(ad->aseq_el + n5p_skipped, p7ad->aseq, ad->N);
  for(x = ad->N + n5p_skipped; x < ad->N_el; x++) ad->aseq_el[x] = '-';
  ad->aseq_el[ad->N_el] = '\0';

  for(x = 0; x < n5p_skipped; x++) ad->rfline_el[x] = 'x';
  /* copy p7ad->model NOT p7ad->rfline into p7ad->rfline_el (p7ad->rfline is not mandatory) */
  memcpy(ad->rfline_el + n5p_skipped, p7ad->model, ad->N);
  for(x = ad->N + n5p_skipped; x < ad->N_el; x++) ad->rfline_el[x] = 'x';
  ad->rfline_el[ad->N_el] = '\0';

  if(p7ad->ppline) {
	for(x = 0; x < n5p_skipped; x++) ad->ppline_el[x] = '-';
	memcpy(ad->ppline_el + n5p_skipped, p7ad->ppline, ad->N);
	for(x = ad->N + n5p_skipped; x < ad->N_el; x++) ad->ppline_el[x] = '-';
	ad->ppline_el[ad->N_el] = '\0';
  }
  else {
	ad->ppline_el[0] = '\0';
  }

  if(act    != NULL)  free(act);
  if(ret_ad != NULL) *ret_ad = ad;
  return eslOK;

 ERROR:
  if(act    != NULL)  free(act);
  if(ret_ad != NULL) *ret_ad = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "cm_alidisplay_CreateFromP7() out of memory");
  return status; /*  errbuf filled some other way */
}

/* Function:  cm_alidisplay_Clone()
 * Synopsis:  Make a duplicate of an ALIDISPLAY.
 *
 * Purpose:   Create a duplicate of alignment display <ad>.
 *            Return a pointer to the duplicate. Caller
 *            is responsible for freeing the new object.
 *
 * Returns:   pointer to new <CM_ALIDISPLAY>
 *
 * Throws:    <NULL> on allocation failure.
 */
CM_ALIDISPLAY *
cm_alidisplay_Clone(const CM_ALIDISPLAY *ad)
{
  CM_ALIDISPLAY *ad2 = NULL;
  int status;

  ESL_ALLOC(ad2, sizeof(CM_ALIDISPLAY));
  ad2->rfline  = ad2->ncline = ad2->csline  = ad2->model = ad2->mline = ad2->aseq = ad2->ppline = NULL;
  ad2->cmname  = ad2->cmacc  = ad2->cmdesc  = NULL;
  ad2->sqname  = ad2->sqacc  = ad2->sqdesc  = NULL;
  ad2->aseq_el = ad2->rfline_el = ad2->ppline_el = NULL;
  ad2->mem     = NULL;
  ad2->memsize = 0;

  if (ad->memsize) 		/* serialized */
	{
	  ESL_ALLOC(ad2->mem, sizeof(char) * ad->memsize);
	  ad2->memsize = ad->memsize;
	  memcpy(ad2->mem, ad->mem, ad->memsize);

	  ad2->rfline    = (ad->rfline ? ad2->mem + (ad->rfline - ad->mem) : NULL );
	  ad2->ncline    = (ad->ncline ? ad2->mem + (ad->ncline - ad->mem) : NULL );
	  ad2->csline    = ad2->mem + (ad->csline - ad->mem);
	  ad2->model     = ad2->mem + (ad->model  - ad->mem);
	  ad2->mline     = ad2->mem + (ad->mline  - ad->mem);
	  ad2->aseq      = ad2->mem + (ad->aseq   - ad->mem);
	  ad2->ppline    = (ad->ppline ? ad2->mem + (ad->ppline - ad->mem) : NULL );
	  ad2->aseq_el   = ad2->mem + (ad->aseq_el   - ad->mem);
	  ad2->rfline_el = ad2->mem + (ad->rfline_el - ad->mem);
	  ad2->ppline_el = (ad->ppline_el ? ad2->mem + (ad->ppline_el - ad->mem) : NULL );
	  ad2->N         = ad->N;
	  ad2->N_el      = ad->N_el;

	  ad2->cmname     = ad2->mem + (ad->cmname - ad->mem);
	  ad2->cmacc      = ad2->mem + (ad->cmacc  - ad->mem);
	  ad2->cmdesc     = ad2->mem + (ad->cmdesc - ad->mem);
	  ad2->cfrom_emit = ad->cfrom_emit;
	  ad2->cto_emit   = ad->cto_emit;
	  ad2->cfrom_span = ad->cfrom_span;
	  ad2->cto_span   = ad->cto_span;
	  ad2->clen       = ad->clen;

	  ad2->sqname  = ad2->mem + (ad->sqname - ad->mem);
	  ad2->sqacc   = ad2->mem + (ad->sqacc  - ad->mem);
	  ad2->sqdesc  = ad2->mem + (ad->sqdesc - ad->mem);
	  ad2->sqfrom  = ad->sqfrom;
	  ad2->sqto    = ad->sqto;
	}
  else				/* deserialized */
	{
	  if ( esl_strdup(ad->rfline,    -1, &(ad2->rfline))    != eslOK) goto ERROR;
	  if ( esl_strdup(ad->ncline,    -1, &(ad2->ncline))    != eslOK) goto ERROR;
	  if ( esl_strdup(ad->csline,    -1, &(ad2->csline))    != eslOK) goto ERROR;
	  if ( esl_strdup(ad->model,     -1, &(ad2->model))     != eslOK) goto ERROR;
	  if ( esl_strdup(ad->mline,     -1, &(ad2->mline))     != eslOK) goto ERROR;
	  if ( esl_strdup(ad->aseq,      -1, &(ad2->aseq))      != eslOK) goto ERROR;
	  if ( esl_strdup(ad->ppline,    -1, &(ad2->ppline))    != eslOK) goto ERROR;
	  if ( esl_strdup(ad->aseq_el,   -1, &(ad2->aseq_el))   != eslOK) goto ERROR;
	  if ( esl_strdup(ad->rfline_el, -1, &(ad2->rfline_el)) != eslOK) goto ERROR;
	  if ( esl_strdup(ad->ppline_el, -1, &(ad2->ppline_el)) != eslOK) goto ERROR;
	  ad2->N    = ad->N;
	  ad2->N_el = ad->N_el;

	  if ( esl_strdup(ad->cmname, -1, &(ad2->cmname)) != eslOK) goto ERROR;
	  if ( esl_strdup(ad->cmacc,  -1, &(ad2->cmacc))  != eslOK) goto ERROR;
	  if ( esl_strdup(ad->cmdesc, -1, &(ad2->cmdesc)) != eslOK) goto ERROR;
	  ad2->cfrom_emit = ad->cfrom_emit;
	  ad2->cto_emit   = ad->cto_emit;
	  ad2->cfrom_span = ad->cfrom_span;
	  ad2->cto_span   = ad->cto_span;
	  ad2->clen       = ad->clen;

	  if ( esl_strdup(ad->sqname,  -1, &(ad2->sqname)) != eslOK) goto ERROR;
	  if ( esl_strdup(ad->sqacc,   -1, &(ad2->sqacc))  != eslOK) goto ERROR;
	  if ( esl_strdup(ad->sqdesc,  -1, &(ad2->sqdesc)) != eslOK) goto ERROR;
	  ad2->sqfrom  = ad->sqfrom;
	  ad2->sqto    = ad->sqto;
	}

  /* other data */
  ad2->sc           = ad->sc;
  ad2->avgpp        = ad->avgpp;
  ad2->gc           = ad->gc;
  ad2->tau          = ad->tau;
  ad2->matrix_Mb    = ad->matrix_Mb;
  ad2->elapsed_secs = ad->elapsed_secs;
  ad2->hmmonly      = ad->hmmonly;

  return ad2;

 ERROR:
  if (ad2) cm_alidisplay_Destroy(ad2);
  return NULL;
}

/* Function:  cm_alidisplay_Sizeof()
 * Synopsis:  Returns the total size of a CM_ALIDISPLAY, in bytes.
 *
 * Purpose:   Return the total size of <CM_ALIDISPLAY> <ad>, in bytes.
 *
 *            Note that <ad->memsize = cm_alidisplay_Sizeof(ad) - sizeof(CM_ALIDISPLAY)>,
 *            for a serialized object, because <ad->memsize> only refers to the sum
 *            of the variable-length allocated fields.
 *
 * Args:      ad - CM_ALIDISPLAY to get the size of
 *
 * Returns:   size of <ad> in bytes
 */
size_t
cm_alidisplay_Sizeof(const CM_ALIDISPLAY *ad)
{
  size_t n = sizeof(CM_ALIDISPLAY);

  if (ad->rfline) n += ad->N+1; /* +1 for \0 */
  n += 4 * (ad->N+1);           /* csline, model, mline, aseq */
  if (ad->ppline)    n += ad->N+1;
  if (ad->ncline)    n += ad->N+1;
  n += ad->N_el+1;              /* aseq_el */
  n += ad->N_el+1;              /* rfline_el */
  if (ad->ppline_el) n += ad->N_el+1;
  n += 1 + strlen(ad->cmname);
  n += 1 + strlen(ad->cmacc);	/* optional acc, desc fields: when not present, just "" ("\0") */
  n += 1 + strlen(ad->cmdesc);
  n += 1 + strlen(ad->sqname);
  n += 1 + strlen(ad->sqacc);
  n += 1 + strlen(ad->sqdesc);

  return n;
}

/* Function:  cm_alidisplay_Destroy()
 * Synopsis:  Frees a <CM_ALIDISPLAY>
 */
void
cm_alidisplay_Destroy(CM_ALIDISPLAY *ad)
{
  if (ad == NULL) return;
  if (ad->mem)
	{	/* serialized form */
	  free(ad->mem);
	}
  else
	{	/* deserialized form */
	  if (ad->rfline)    free(ad->rfline);
	  if (ad->ncline)    free(ad->ncline);
	  if (ad->csline)    free(ad->csline);
	  if (ad->model)     free(ad->model);
	  if (ad->mline)     free(ad->mline);
	  if (ad->aseq)      free(ad->aseq);
	  if (ad->ppline)    free(ad->ppline);
	  if (ad->aseq_el)   free(ad->aseq_el);
	  if (ad->rfline_el) free(ad->rfline_el);
	  if (ad->ppline_el) free(ad->ppline_el);
	  if (ad->cmname)    free(ad->cmname);
	  if (ad->cmacc)     free(ad->cmacc);
	  if (ad->cmdesc)    free(ad->cmdesc);
	  if (ad->sqname)    free(ad->sqname);
	  if (ad->sqacc)     free(ad->sqacc);
	  if (ad->sqdesc)    free(ad->sqdesc);
	}
  free(ad);
}

/* Function: post_code_to_avg_pp()
 * Date:     EPN, Tue May 22 20:43:46 2012
 *
 * Purpose:  Return the average posterior probability
 *           for the given posterior single character
 *           code <postcode>.
 *
 *
 */
float
post_code_to_avg_pp(char postcode)
{
  switch (postcode) {
  case '*': return 0.975; break;
  case '9': return 0.9;   break;
  case '8': return 0.8;   break;
  case '7': return 0.7;   break;
  case '6': return 0.6;   break;
  case '5': return 0.5;   break;
  case '4': return 0.4;   break;
  case '3': return 0.3;   break;
  case '2': return 0.2;   break;
  case '1': return 0.1;   break;
  case '0': return 0.025; break;
  default:  return 0.0;
  }
  return 0.; /* NOT REACHED */
}

/* Function: bp_is_canonical
 * Date:     EPN, Wed Oct 14 06:17:27 2009
 *
 * Purpose:  Determine if two residues form a canonical base pair or not.
 *           Works for RNA or DNA (because for some reason cmsearch allows
 *           the user to format output as DNA (with --dna)).
 *
 * Returns:  TRUE if:
 *           lseq  rseq
 *           ----  ----
 *            A     U
 *            U     A
 *            C     G
 *            G     C
 *            G     U
 *            U     G
 *            A     T
 *            T     A
 *            G     T
 *            T     G
 *            Else, return FALSE.
 */
int
bp_is_canonical(char lseq, char rseq)
{
  switch (toupper(lseq)) {
  case 'A':
	switch (toupper(rseq)) {
	case 'U': return TRUE; break;
	case 'T': return TRUE; break;
	default: break;
	}
	break;
  case 'C':
	switch (toupper(rseq)) {
	case 'G': return TRUE; break;
	default: break;
	}
	break;
  case 'G':
	switch (toupper(rseq)) {
	case 'C': return TRUE; break;
	case 'U': return TRUE; break;
	case 'T': return TRUE; break;
	default: break;
	}
	break;
  case 'U':
	switch (toupper(rseq)) {
	case 'A': return TRUE; break;
	case 'G': return TRUE; break;
	default: break;
	}
	break;
  case 'T':
	switch (toupper(rseq)) {
	case 'A': return TRUE; break;
	case 'G': return TRUE; break;
	default: break;
	}
	break;
  default: break;
  }

  return FALSE;
}

/*---------------- end, alidisplay object -----------------------*/

/*****************************************************************
 * 2. The CM_ALIDISPLAY API
 *****************************************************************/

/* Function:  cm_alidisplay_EncodePostProb()
 * Synopsis:  Convert a posterior probability to a char code.
 *
 * Purpose:   Convert the posterior probability <p> to
 *            a character code suitable for Stockholm format
 *            <#=GC PP_cons> and <#=GR seqname PP> annotation
 *            lines. HMMER uses the same codes in alignment
 *            output.
 *
 *            Characters <0-9*> are used; $0.0 \leq p < 0.05$
 *            is coded as 0, $0.05 \leq p < 0.15$ is coded as
 *            1, ... and so on ..., $0.85 \leq p < 0.95$ is
 *            coded as 9, and $0.95 \leq p \leq 1.0$ is coded
 *            as '*'.
 *
 * Returns:   the encoded character.
 */
char
cm_alidisplay_EncodePostProb(float p)
{
  return (p + 0.05 >= 1.0) ? '*' :  (char) ((p + 0.05) * 10.0) + '0';
}

/* Function:  cm_alidisplay_DecodePostProb()
 * Synopsis:  Convert a char code post prob to an approx float.
 *
 * Purpose:   Convert posterior probability code <pc>, which
 *            is [0-9*], to an approximate floating point probability.
 *
 *            The result is crude, because <pc> has already discretized
 *            with loss of precision. We require that
 *            <cm_alidisplay_EncodePostProb(cm_alidisplay_DecodePostProb(pc)) == pc>,
 *            and that <pc=='0'> decodes to a nonzero probability just to
 *            avoid any possible absorbing-zero artifacts.
 *
 * Returns:   the decoded real-valued approximate probability.
 */
float
cm_alidisplay_DecodePostProb(char pc)
{
  if      (pc == '0') return 0.01;
  else if (pc == '*') return 1.0;
  else if (pc == '.') return 0.0;
  else                return ((float) (pc - '0') / 10.);
}

/* Function:  cm_alidisplay_Print()
 * Synopsis:  Human readable output of <CM_ALIDISPLAY>
 *
 * Purpose:   Prints alignment <ad> to stream <fp>.
 *
 *            Put at least <min_aliwidth> alignment characters per
 *            line; try to make lines no longer than <linewidth>
 *            characters, including name, coords, and spacing.  The
 *            width of lines may exceed <linewidth>, if that's what it
 *            takes to put a name, coords, and <min_aliwidth>
 *            characters of alignment on a line.
 *
 *            As a special case, if <linewidth> is negative or 0, then
 *            alignments are formatted in a single block of unlimited
 *            line length.
 *
 * Returns:   eslOK on success
 *            eslEINVAL if ad->aseq or ad->model are invalid,
 *            specifically if local end formatting is invalid.
 *            All local ends should begin with '*[' and end with
 *            ']*' with the intervening characters being 0 or
 *            more whitespace characters followed by an integer.
 */
int
cm_alidisplay_Print(FILE *fp, CM_ALIDISPLAY *ad, int min_aliwidth, int linewidth, int show_accessions)
{
  char *buf          = NULL;
  char *show_cmname  = NULL;
  char *show_seqname = NULL;
  int   namewidth, coordwidth, aliwidth, cur_aliwidth;
  int   pos;
  int   status;
  int   ni, nk;
  int   z, zp;
  long  i1,i2;
  int   k1,k2;
  int   ni_toadd, nk_toadd;
  int   trunc_at_start; /* special case, ali begins with a truncated begin */

  /* implement the --acc option for preferring accessions over names in output  */
  show_cmname  = (show_accessions && ad->cmacc[0] != '\0') ? ad->cmacc : ad->cmname;
  show_seqname = (show_accessions && ad->sqacc[0] != '\0') ? ad->sqacc : ad->sqname;

  /* dynamically size the output lines */
  namewidth  = ESL_MAX(strlen(show_cmname), strlen(show_seqname));
  coordwidth = ESL_MAX(ESL_MAX(integer_textwidth(ad->cfrom_emit),
			       integer_textwidth(ad->cto_emit)),
		       ESL_MAX(integer_textwidth(ad->sqfrom),
			       integer_textwidth(ad->sqto)));
  aliwidth   = (linewidth > 0) ? linewidth - namewidth - 2*coordwidth - 5 : ad->N;
  if (aliwidth < ad->N && aliwidth < min_aliwidth) aliwidth = min_aliwidth; /* at least, regardless of some silly linewidth setting */
  ESL_ALLOC(buf, sizeof(char) * (aliwidth+1));
  buf[aliwidth] = '\0';

  /* Break the alignment into multiple blocks of width aliwidth for printing */
  i1 = ad->sqfrom;
  k1 = ad->cfrom_emit;
  cur_aliwidth = aliwidth;

  for (pos = 0; pos < ad->N; pos += cur_aliwidth)
	{
	  if (pos > 0) fprintf(fp, "\n"); /* blank line betweeen blocks */

	  ni = nk = 0;
	  cur_aliwidth = aliwidth; /* this will change if a aliwidth-wide block will end in the middle of a local end display */

	  for (z = pos; z < pos + cur_aliwidth && z < ad->N; z++) {
	if ((ad->aseq[z]  == '*' && ad->model[z] == '*') ||
	    (ad->aseq[z]  == '<' && ad->model[z] == '<')) {
	  /* we're at the beginning of a local end or truncated begin display, process it:
	   * Examples:
	   *   "*[ 7]*" (local begin)
	   *   "<[ 7]*" (trunc begin, at aln start)  (processed differently, initial k1 will be '1', not ad->cfrom_emit)
	   *   "*[ 7]>" (trunc begin, at aln end)    (we process this just like a local begin here)
	   */
	  trunc_at_start = (ad->aseq[z]  == '<' && ad->model[z] == '<') ? TRUE : FALSE;
	  nk_toadd = ni_toadd = 0;
	  if(ad->aseq[z+1] != '[' || ad->model[z+1] != '[') { status = eslEINVAL; goto ERROR; }

	  zp = z+2;
	  while(ad->model[zp] == ' ') { zp++; } /* chew up any whitespace */
	  while(ad->model[zp] != ']') { nk_toadd *= 10; nk_toadd += ad->model[zp] - '0'; zp++; } /* determine size of local end in model */

	  zp = z+2;
	  while(ad->aseq[zp] == ' ')  { zp++; } /* chew up any whitespace */
	  while(ad->aseq[zp] != ']')  { ni_toadd *= 10; ni_toadd += ad->aseq[zp] - '0';  zp++; } /* determine size of local end in aseq */

	  if((zp+1) >= (pos + aliwidth)) { /* the local end display will not fit completely on this block, save it for next block */
	    cur_aliwidth = z - pos;
	  }
	  else {
	    nk += nk_toadd;
	    ni += ni_toadd;
	    if(trunc_at_start) k1 -= nk_toadd;
	    z = zp+1; /* position z at end of local end display (one char past the ']', on the '*'), the 'z++' at end of for loop will increase it 1 more */
	    /* printf("z: %4d  nk_toadd: %d nk: %4d\n", z, nk_toadd, nk); */
	  }
	}
	else { /* normal case, we're not at the beginning of a local end */
	  if (ad->model[z] != '.') nk++; /* k advances except on insert states */
	  if (ad->aseq[z]  != '-') ni++; /* i advances except on delete states */
	}
	  }

	  if(aliwidth != cur_aliwidth) buf[cur_aliwidth] = '\0';

	  k2 = k1+nk-1;
	  if (ad->sqfrom < ad->sqto) { i2 = i1+ni-1; }
	  else                       { i2 = i1-ni+1; }

	  if (ad->ncline != NULL) { strncpy(buf, ad->ncline+pos,  cur_aliwidth); fprintf(fp, "  %*s %s %*sNC\n", namewidth+coordwidth+1, "", buf, aliwidth-cur_aliwidth, ""); }
	  strncpy(buf, ad->csline+pos, cur_aliwidth); fprintf(fp, "  %*s %s %*sCS\n", namewidth+coordwidth+1, "", buf, aliwidth-cur_aliwidth, "");
	  strncpy(buf, ad->model+pos,  cur_aliwidth); fprintf(fp, "  %*s %*d %s %*s%-*d\n", namewidth,  show_cmname, coordwidth, k1, buf, aliwidth-cur_aliwidth, "", coordwidth, k2);
	  strncpy(buf, ad->mline+pos,  cur_aliwidth); fprintf(fp, "  %*s %s\n", namewidth+coordwidth+1, " ", buf);
	  if (ni > 0) { strncpy(buf, ad->aseq+pos, cur_aliwidth); fprintf(fp, "  %*s %*ld %s %*s%-*ld\n", namewidth, show_seqname, coordwidth, i1,  buf, aliwidth-cur_aliwidth, "", coordwidth, i2);  }
	  else        { strncpy(buf, ad->aseq+pos, cur_aliwidth); fprintf(fp, "  %*s %*s %s %*s%*s\n",    namewidth, show_seqname, coordwidth, "-", buf, aliwidth-cur_aliwidth, "", coordwidth, "-"); }
	  if (ad->ppline != NULL) { strncpy(buf, ad->ppline+pos, cur_aliwidth); fprintf(fp, "  %*s %s %*sPP\n", namewidth+coordwidth+1, "", buf, aliwidth-cur_aliwidth, ""); }
	  if (ad->rfline != NULL) { strncpy(buf, ad->rfline+pos, cur_aliwidth); fprintf(fp, "  %*s %s %*sRF\n", namewidth+coordwidth+1, "", buf, aliwidth-cur_aliwidth, ""); }

	  k1 += nk;
	  if (ad->sqfrom < ad->sqto) { i1 += ni; }
	  else                       { i1 -= ni; } /* revcomp hit for DNA */
	}
  fflush(fp);
  free(buf);
  return eslOK;

 ERROR:
  if (buf != NULL) free(buf);
  return status;
}

/* Functions: cm_alidisplay_Is5PTrunc()
 *            cm_alidisplay_Is3PTrunc()
 *            cm_alidisplay_Is5PAnd3PTrunc()
 *            cm_alidisplay_Is5PTruncOnly()
 *            cm_alidisplay_Is3PTruncOnly()
 *
 * Synopsis:  Return TRUE if an alignment is truncated in a specific way.
 *            These are convenience functions that use a simple tests
 *            of equality between ad->cfrom_span and ad->cfrom_emit and
 *            between ad->cto_span and ad->cto_emit. Those four values
 *            were calculated in ParsetreeToCMBounds() (which is called
 *            by cm_alidisplay_Create()) based on the parsetree of the
 *            hit, the pipeline pass the hit was found in and whether
 *            the parsetree contained the first and/or final residue of
 *            the source sequence of the hit. See ParsetreeToCMBounds()
 *            for details.
 *
 * Returns:   TRUE or FALSE;
 */
int
cm_alidisplay_Is5PTrunc(const CM_ALIDISPLAY *ad)
{
  return (ad->cfrom_emit != ad->cfrom_span) ? TRUE : FALSE;
}

int
cm_alidisplay_Is3PTrunc(const CM_ALIDISPLAY *ad)
{
  return (ad->cto_emit != ad->cto_span) ? TRUE : FALSE;
}

int
cm_alidisplay_Is5PAnd3PTrunc(const CM_ALIDISPLAY *ad)
{
  return (ad->cfrom_emit != ad->cfrom_span && ad->cto_emit != ad->cto_span) ? TRUE : FALSE;
}

int
cm_alidisplay_Is5PTruncOnly(const CM_ALIDISPLAY *ad)
{
  return (ad->cfrom_emit != ad->cfrom_span && ad->cto_emit == ad->cto_span) ? TRUE : FALSE;
}

int
cm_alidisplay_Is3PTruncOnly(const CM_ALIDISPLAY *ad)
{
  return (ad->cfrom_emit == ad->cfrom_span && ad->cto_emit != ad->cto_span) ? TRUE : FALSE;
}

/* Function:  cm_alidisplay_TruncString()
 * Synopsis:  Determine if an alignment is truncated 5', 3' or both
 *            and return a string summarizing the truncation: "5'&3'",
 *            "5'", "3'", or "no". As a special case, if hit was
 *            found using a HMM only pipeline pass, we return "-".
 *
 * Returns:   informative string
 */
char *
cm_alidisplay_TruncString(const CM_ALIDISPLAY *ad)
{
  if     (ad->hmmonly)                      return "-";
  else if(cm_alidisplay_Is5PAnd3PTrunc(ad)) return "5'&3'";
  else if(cm_alidisplay_Is5PTruncOnly(ad))  return "5'";
  else if(cm_alidisplay_Is3PTruncOnly(ad))  return "3'";
  else return "no";
}

/* Function:  cm_alidisplay_Backconvert()
 * Synopsis:  Convert an alidisplay to a parsetree and subsequence.
 *
 * Purpose:   Convert alignment display object <ad> to a faux subsequence
 *            and faux subsequence parsetree, returning them in <ret_sq> and
 *            <ret_tr>.
 *
 *            The subsequence <*ret_sq> is digital; ascii residues in
 *            <ad> are digitized using digital alphabet <abc>.
 *
 *            The subsequence and trace are suitable for passing as
 *            array elements to <p7_tracealign_Seqs>. This is the
 *            main purpose of backconversion. Results of a profile
 *            search are stored in a hit list as a processed
 *            <P7_ALIDISPLAY>, not as a <P7_TRACE> and <ESL_SQ>, to
 *            reduce space and to reduce communication overhead in
 *            parallelized search implementations. After reduction
 *            to a final hit list, a master may want to construct a
 *            multiple alignment of all the significant hits.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation failures. <eslECORRUPT> on unexpected internal
 *            data corruption. On any exception, <*ret_sq>, <*ret_tr> and
 *            <*ret_pp> are <NULL>.
 *
 * Xref:      SRE:J4/29.
 */
int
cm_alidisplay_Backconvert(CM_t *cm, const CM_ALIDISPLAY *ad, char *errbuf, ESL_SQ **ret_sq, Parsetree_t **ret_tr, char **ret_pp)
{
  int          status;
  ESL_SQ      *sq   = NULL;	/* RETURN: faux subsequence          */
  Parsetree_t *tr   = NULL;	/* RETURN: faux parsetree            */
  char        *pp   = NULL;	/* RETURN: post prob annotation      */
  Parsetree_t *mtr  = NULL;	/* guide tree for the CM, unfortunately we need to create this */
  ESL_MSA     *msa  = NULL;     /* we'll build an MSA from the single seq ad pertains to */
  char        *aseq = NULL;     /* an aligned string, a text sequence */
  int          apos, upos;      /* counter over aligned, unaligned positions */
  int         *a2u_map = NULL;  /* map of aligned to unaligned positions for updating tr->emitl, tr->emitr */
  int         *used_el = NULL;  /* [1..msa->alen] used_el[apos] = TRUE if apos is modeled by EL state, else FALSE */
  int          x, ulen;

  if(cm->cmcons == NULL) ESL_FAIL(eslEINVAL, errbuf, "cm_alidisplay_Backconvert(): cm->cmcons is NULL");

  msa = esl_msa_Create(1, ad->N_el);
  memcpy(msa->aseq[0], ad->aseq_el, ad->N_el);
  if((status = esl_strdup(ad->rfline_el, msa->alen, &(msa->rf))) != eslOK) ESL_XFAIL(status, errbuf, "cm_alidisplay_BackConvert() out of memory");
  /*if((status = esl_strdup(ad->aseq_el, msa->alen, &(msa->aseq[0]))) != eslOK) ESL_XFAIL(status, errbuf, "cm_alidisplay_Backconvert() out of memory");*/
  if(ad->ppline_el) {
	ESL_ALLOC(msa->pp, sizeof(char *) * 1);
	if((status = esl_strdup(ad->ppline_el, msa->alen, &(msa->pp[0]))) != eslOK) ESL_XFAIL(status, errbuf, "cm_alidisplay_Backconvert() out of memory");
  }
  ESL_ALLOC(msa->ss_cons, sizeof(char) * (msa->alen+1));

  /*cm_alidisplay_Dump(stdout, ad);*/

  upos = 0;
  for(apos = 0; apos < msa->alen; apos++) {
	msa->ss_cons[apos] = (isupper(msa->aseq[0][apos]) || msa->aseq[0][apos] == '-') ? cm->cmcons->cstr[upos++] : '.';
  }
  msa->ss_cons[msa->alen] = '\0';
  if(upos != cm->clen) ESL_XFAIL(eslERANGE, errbuf, "cm_alidisplay_Backconvert() failed to create temporary msa");

  esl_msa_FormatSeqName(msa, 0, "%s/%ld-%ld", ad->sqname, ad->sqfrom, ad->sqto);
  /*esl_msa_SetSeqName(msa, 0, ad->sqname, -1);*/
  if(ad->sqacc)  esl_msa_SetSeqAccession  (msa, 0, ad->sqacc,  -1);
  if(ad->sqdesc) esl_msa_SetSeqDescription(msa, 0, ad->sqdesc, -1);

  if((status = esl_msa_Digitize(cm->abc, msa, errbuf)) != eslOK) goto ERROR;

  /* get a guidetree for the CM */
  if((status = cm_Guidetree(cm, errbuf, msa, &mtr)) != eslOK) goto ERROR;

  ESL_ALLOC(used_el, (msa->alen+1) * sizeof(int));
  /* change any EL emissions in aseq to '~' so Transmogrify deals with them appropriately */
  used_el[0] = FALSE;
  for(apos = 0; apos < msa->alen; apos++) {
	used_el[apos+1] = (msa->rf[apos] == '~') ? TRUE : FALSE;
  }
  if((status = Transmogrify(cm, errbuf, mtr, msa->ax[0], used_el, msa->alen, &tr)) != eslOK) goto ERROR;
  /* tr is in alignment coords, convert it to unaligned coords.
   * First we construct a map of aligned to unaligned coords, then
   * we use it to convert.
   */
  ESL_ALLOC(a2u_map, sizeof(int)  * (msa->alen+1));
  a2u_map[0] = -1; /* invalid */
  upos = 1;
  for(apos = 1; apos <= msa->alen; apos++) {
	a2u_map[apos] = (esl_abc_XIsGap(msa->abc, msa->ax[0][apos])) ? -1 : upos++;
  }
  ulen = upos;
  for(x = 0; x < tr->n; x++) {
	if(tr->emitl[x] != -1) tr->emitl[x] = a2u_map[tr->emitl[x]];
	if(tr->emitr[x] != -1) tr->emitr[x] = a2u_map[tr->emitr[x]];
  }
  if((status = esl_sq_FetchFromMSA(msa, 0, &sq)) != eslOK) ESL_XFAIL(status, errbuf, "cm_alidisplay_Backconvert() unable to fetch seq from msa");
  if(msa->pp) {
	ESL_ALLOC(pp, sizeof(char) * (ulen+1));
	upos = 0;
	for(apos = 0; apos < msa->alen; apos++) {
	  if(a2u_map[apos+1] != -1) pp[upos++] = msa->pp[0][apos];
	}
	if(upos+1 != ulen) ESL_XFAIL(eslERANGE, errbuf, "cm_alidisplay_Backconvert() failed to create temporary msa");
  }

  esl_msa_Destroy(msa);
  free(used_el);
  free(a2u_map);
  FreeParsetree(mtr);
  free(aseq);

  *ret_sq = sq;
  *ret_tr = tr;
  *ret_pp = pp;
  return eslOK;

 ERROR:
  if (msa     != NULL) esl_msa_Destroy(msa);
  if (mtr     != NULL) FreeParsetree(mtr);
  if (aseq    != NULL) free(aseq);
  if (a2u_map != NULL) free(a2u_map);
  if (sq      != NULL) esl_sq_Destroy(sq);
  if (tr      != NULL) FreeParsetree(tr);
  if (pp      != NULL) free(pp);
  *ret_sq      = NULL;
  *ret_tr      = NULL;
  return status;
}

/*------------------- end, alidisplay API -----------------------*/

/*****************************************************************
 * 3. Debugging/dev code
 *****************************************************************/

/* Function:  cm_alidisplay_Dump()
 * Synopsis:  Print contents of CM_ALIDISPLAY for inspection.
 *
 * Purpose:   Print contents of the <CM_ALIDISPLAY> <ad> to
 *            stream <fp> for inspection. Includes all elements
 *            of the structure, whether the object is allocated
 *            in serialized or deserialized form, and the total
 *            size of the object in bytes.
 *
 * Returns:   <eslOK>
 */
int
cm_alidisplay_Dump(FILE *fp, const CM_ALIDISPLAY *ad)
{
  fprintf(fp, "CM_ALIDISPLAY dump\n");
  fprintf(fp, "------------------\n");

  fprintf(fp, "rfline     = %s\n", ad->rfline ? ad->rfline : "[none]");
  fprintf(fp, "ncline     = %s\n", ad->ncline ? ad->ncline : "[none]");
  fprintf(fp, "csline     = %s\n", ad->csline ? ad->csline : "[none]");
  fprintf(fp, "model      = %s\n", ad->model);
  fprintf(fp, "mline      = %s\n", ad->mline);
  fprintf(fp, "ppline     = %s\n", ad->ppline ? ad->ppline : "[none]");
  fprintf(fp, "aseq       = %s\n", ad->aseq);
  fprintf(fp, "N          = %d\n", ad->N);
  fprintf(fp, "\n");

  fprintf(fp, "aseq_el    = %s\n", ad->aseq_el);
  fprintf(fp, "ppline_el  = %s\n", ad->ppline_el ? ad->ppline_el : "[none]");
  fprintf(fp, "N_el       = %d\n", ad->N_el);
  fprintf(fp, "\n");

  fprintf(fp, "cmname     = %s\n", ad->cmname);
  fprintf(fp, "cmacc      = %s\n", ad->cmacc[0]  == '\0' ? "[none]" : ad->cmacc);
  fprintf(fp, "cmdesc     = %s\n", ad->cmdesc[0] == '\0' ? "[none]" : ad->cmdesc);
  fprintf(fp, "cfrom_span = %d\n", ad->cfrom_span);
  fprintf(fp, "cfrom_emit = %d\n", ad->cfrom_emit);
  fprintf(fp, "cto_emit   = %d\n", ad->cto_emit);
  fprintf(fp, "cto_span   = %d\n", ad->cto_span);
  fprintf(fp, "clen       = %d\n", ad->clen);
  fprintf(fp, "\n");

  fprintf(fp, "sqname     = %s\n",  ad->sqname);
  fprintf(fp, "sqacc      = %s\n",  ad->sqacc[0]  == '\0' ? "[none]" : ad->sqacc);
  fprintf(fp, "sqdesc     = %s\n",  ad->sqdesc[0] == '\0' ? "[none]" : ad->sqdesc);
  fprintf(fp, "sqfrom     = %ld\n", ad->sqfrom);
  fprintf(fp, "sqto       = %ld\n", ad->sqto);
  fprintf(fp, "\n");

  fprintf(fp, "sc         = %.2f\n",ad->sc);
  fprintf(fp, "avgpp      = %.2f\n",ad->avgpp);
  fprintf(fp, "gc         = %.2f\n",ad->gc);
  fprintf(fp, "tau        = %g\n",  ad->tau);
  fprintf(fp, "mx Mb      = %.6f\n",ad->matrix_Mb);
  fprintf(fp, "seconds    = %.6f\n",ad->elapsed_secs);
  fprintf(fp, "hmmonly    = %s\n",  ad->hmmonly ? "TRUE" : "FALSE");

  fprintf(fp, "\n");

  fprintf(fp, "size       = %d bytes\n",  (int) cm_alidisplay_Sizeof(ad));
  fprintf(fp, "%s\n", ad->mem ? "serialized" : "not serialized");
  return eslOK;
}

/* Function:  cm_alidisplay_Compare()
 * Synopsis:  Compare two <CM_ALIDISPLAY> objects for equality
 *
 * Purpose:   Compare alignment displays <ad1> and <ad2> for
 *            equality. Return <eslOK> if they have identical
 *            contents; <eslFAIL> if not.
 *
 *            Only contents matter, not serialization status;
 *            a serialized and deserialized version of the same
 *            alidisplay will compare identical.
 */
int
cm_alidisplay_Compare(const CM_ALIDISPLAY *ad1, const CM_ALIDISPLAY *ad2)
{
  if (ad1->mem && ad2->mem)	/* both objects serialized */
	{
	  if (ad1->memsize != ad2->memsize)                  return eslFAIL;
	  if (memcmp(ad1->mem, ad2->mem, ad1->memsize) != 0) return eslFAIL;
	}

  if (esl_strcmp(ad1->rfline,  ad2->rfline)  != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->csline,  ad2->csline)  != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->model,   ad2->model)   != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->mline,   ad2->mline)   != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->aseq,    ad2->aseq)    != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->ppline,  ad2->ppline)  != eslOK) return eslFAIL;
  if (ad1->N != ad2->N)                                return eslFAIL;

  if (esl_strcmp(ad1->cmname, ad2->cmname) != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->cmacc,  ad2->cmacc)  != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->cmdesc, ad2->cmdesc) != eslOK) return eslFAIL;
  if (ad1->cfrom_emit != ad2->cfrom_emit)            return eslFAIL;
  if (ad1->cto_emit   != ad2->cto_emit)              return eslFAIL;
  if (ad1->cfrom_span != ad2->cfrom_span)            return eslFAIL;
  if (ad1->cto_span   != ad2->cto_span)              return eslFAIL;

  if (esl_strcmp(ad1->sqname,  ad2->sqname)  != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->sqacc,   ad2->sqacc)   != eslOK) return eslFAIL;
  if (esl_strcmp(ad1->sqdesc,  ad2->sqdesc)  != eslOK) return eslFAIL;
  if (ad1->sqfrom != ad2->sqfrom)                      return eslFAIL;
  if (ad1->sqto   != ad2->sqto)                        return eslFAIL;
  if (ad1->clen   != ad2->clen)                        return eslFAIL;

  return eslOK;
}

/*-------------- end, debugging/dev code ------------------------*/

/*****************************************************************
 * 4. Benchmark driver.
 *****************************************************************/
/****************************************************************
 * 5. Unit tests.
 ****************************************************************/
/*****************************************************************
 * 6. Test driver.
 *****************************************************************/
/*****************************************************************
 * 7. Example.
 *****************************************************************/
/*****************************************************************
 * Infernal - inference of RNA secondary structure alignments
 * Version 1.1.2; July 2016
 * Copyright (C) 2016 Howard Hughes Medical Institute.
 * Other copyrights also apply. See the COPYRIGHT file for a full list.
 *
 * Infernal is distributed under the terms of the GNU General Public License
 * (GPLv3). See the LICENSE file for details.
 *****************************************************************/

/*** End of inlined file: cm_alidisplay.c ***/


/*** Start of inlined file: cm_alndata.c ***/

#include <stdlib.h>
#include <string.h>
#include <limits.h>

static int sub_alignment_prep(CM_t *orig_cm, char *errbuf, ESL_SQ *sq, CMSubMap_t **ret_submap, CM_t **ret_sub_cm);

/*****************************************************************
 * 1. The CM_ALNDATA object
 *****************************************************************/

/* Function:  cm_alndata_Create()
 * Synopsis:  Allocate a CM_ALNDATA object.
 * Incept:    EPN, Fri Jan  6 09:01:33 2012
 *
 * Purpose:   Allocates a new <CM_ALNDATA> and returns a pointer
 *            to it.
 *
 * Throws:    <NULL> on allocation failure.
 */
CM_ALNDATA *
cm_alndata_Create(void)
{
  int status;
  CM_ALNDATA *data = NULL;

  ESL_ALLOC(data, sizeof(CM_ALNDATA));
  data->sq         = NULL;
  data->idx        = -1;
  data->tr         = NULL;
  data->sc         = 0.;
  data->pp         = 0.;
  data->ppstr      = NULL;
  data->spos       = -1;
  data->epos       = -1;
  data->secs_bands = 0.;
  data->secs_aln   = 0.;
  data->mb_tot     = 0.;
  data->tau        = -1.;

  return data;

 ERROR:
  return NULL;
}

/* Function:  cm_alndata_Destroy()
 * Synopsis:  Free a CM_ALNDATA object.
 * Incept:    EPN, Fri Jan  6 09:10:55 2012
 *
 * Purpose:  Frees a <CM_ALNDATA> object, but only frees the
 *           ESL_SQ <sq> if <free_sq> is TRUE. Often this is
 *           only a pointer to a sequence in another data
 *           structure that will be free'd with that structure.
 *
 * Returns:  void.
 */
void
cm_alndata_Destroy(CM_ALNDATA *data, int free_sq)
{
  if(data == NULL) return;

  if(free_sq && data->sq != NULL) esl_sq_Destroy(data->sq);
  if(data->tr    != NULL)         FreeParsetree(data->tr);
  if(data->ppstr != NULL)         free(data->ppstr);
  free(data);

  return;
}

/*****************************************************************
 * 2. Alignment workunit processing functions
 *****************************************************************/

/* Function: sub_alignment_prep()
 * Date:     EPN, Mon Jan  9 05:25:26 2012
 *
 * Purpose:  Prepare for an alignment workunit in sub-mode.
 *
 * Args:     orig_cm    - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           sq         - the sequence we're creating the sub CM for
 *           ret_submap - RETURN: the sub CM to original CM map, created here
 *           ret_sub_cm - RETURN: the sub CM, created here
 *
 * Returns:  eslOK on success;
 *           eslEMEM if we run out of memory;
 *           eslEINVAL on other error, errbuf is filled;
 *           <ret_dataA> is alloc'ed and filled with sq_block->count CM_ALNDATA objects.
 */
int
sub_alignment_prep(CM_t *orig_cm, char *errbuf, ESL_SQ *sq, CMSubMap_t **ret_submap, CM_t **ret_sub_cm)
{
  int          status;            /* easel status */
  CM_t        *sub_cm  = NULL;    /* the sub CM */
  CMSubMap_t  *submap  = NULL;    /* map from mother CM to sub CM, and vice versa */
  int          spos;              /* HMM node most likely to have emitted posn 1 of target seq */
  int          spos_state;        /* HMM state type for curr spos 0=match or 1=insert */
  int          epos;              /* HMM node most likely to have emitted posn L of target seq */
  int          epos_state;        /* HMM state type for curr epos 0=match or 1=insert */

  /* step 1. predict start and end positions (HMM nodes) from posterior matrix */
  if((status = cp9_Seq2Posteriors(orig_cm, errbuf, orig_cm->cp9_mx, orig_cm->cp9_bmx, orig_cm->cp9_bmx, sq->dsq, 1, sq->L, 0)) != eslOK) return status;
  CP9NodeForPosn(orig_cm->cp9, 1, sq->L,     1, orig_cm->cp9_bmx, &spos, &spos_state, 0., TRUE,  0);
  CP9NodeForPosn(orig_cm->cp9, 1, sq->L, sq->L, orig_cm->cp9_bmx, &epos, &epos_state, 0., FALSE, 0);
  /* Deal with special cases for sub-CM alignment: If the most
   * likely state to have emitted the first or last residue is the
   * insert state in node 0, it only makes sense to start modelling
   * at consensus column 1. */
  if(spos == 0 && spos_state == 1) spos = 1;
  if(epos == 0 && epos_state == 1) epos = 1;
  /* If most-likely HMM node to emit final position comes BEFORE or
   * EQUALS the most-likely HMM node to emit first position, our HMM
   * alignment is crap, default to using the full CM. (note: If
   * EQUALS we could be right, but we can't build a CM from a single
   * consensus column (see notes in cm_modelmaker.c::cm_from_guide),
   * and I would argue we don't really care about getting single
   * residue alignments correct anyway.
   */
  if(epos <= spos) { spos = 1; epos = orig_cm->cp9->M; }

  /* step 2. build the sub_cm from the original CM. */
  if((status = build_sub_cm(orig_cm, errbuf, &sub_cm,
			    spos, epos,                /* first and last col of structure kept in the sub_cm  */
			    &submap,                   /* this maps from the sub_cm to cm and vice versa      */
			    0)) != eslOK)              /* don't print debugging info */
	return status;

  /* step 3. configure the sub_cm */
  if((status = cm_ConfigureSub(sub_cm, errbuf, -1, orig_cm, submap)) != eslOK) return status;

  *ret_sub_cm = sub_cm;
  *ret_submap = submap;

  return eslOK;
}

/* Function: DispatchSqBlockAlignment()
 * Date:     EPN, Fri Dec 30 14:59:43 2011
 *
 * Purpose:  Given a CM and a block of sequences, align the
 *           sequence(s) using the appropriate alignment function and
 *           return relevant data for eventual output in <ret_dataA>.
 *           This function simply calls DispatchSqAlignment() serially
 *           for each sequence in the block, and creates an array
 *           of the <ret_data> DispatchSqAlignment() returns.
 *
 *           Currently <mode>, <cp9b_valid> and <pass_idx> values sent
 *           to DispatchSqAlignment() are hard-coded to
 *           TRMODE_UNKNOWN, FALSE, and PLI_PASS_5P_AND_3P_FORCE (if
 *           cm->align_opts & CM_ALIGN_TRUNC) or PLI_PASS_STD_ANY (if
 *           (! cm->align_opts & CM_ALIGN_TRUNC)). This is because
 *           this function is only used by the alignment pipeline, in
 *           which these values are correct. If this changes, we may
 *           want caller to pass in an array of modes, cp9b_valids and
 *           pass_idx values, one per sq.
 *
 *           If (cm->flags & CM_ALIGN_XTAU) we'll potentially tighten
 *           HMM bands until the required DP matrices are below out
 *           limit (<mxsize>). cm->maxtau is the max allowed tau value
 *           during this iterative band tightening, and cm->xtau is
 *           the factor by which we multiply cm->tau at each iteration
 *           during band tightening.
 *
 * Args:     cm        - the covariance model
 *           errbuf    - char buffer for reporting errors
 *           sq_block  - block of sequences to align
 *           mxsize    - max size in Mb of allowable DP mx
 *           w         - stopwatch for timing individual stages
 *           w_tot     - stopwatch for timing total time per seq
 *           r         - RNG, req'd if CM_ALIGN_SAMPLE, can be NULL otherwise
 *           ret_dataA - RETURN: newly created array of CM_ALNDATA objects
 *
 * Returns:  eslOK on success;
 *           eslEINCOMPAT on contract violation, errbuf is filled;
 *           eslEMEM if we run out of memory;
 *           <ret_dataA> is alloc'ed and filled with sq_block->count CM_ALNDATA objects.
 */
int
DispatchSqBlockAlignment(CM_t *cm, char *errbuf, ESL_SQ_BLOCK *sq_block, float mxsize, ESL_STOPWATCH *w,
			 ESL_STOPWATCH *w_tot, ESL_RANDOMNESS *r, CM_ALNDATA ***ret_dataA)
{
  int           status;          /* easel status */
  int           j;               /* counter over parsetrees */
  CM_ALNDATA  **dataA = NULL;    /* CM_ALNDATA array we'll create and return */
  ESL_SQ       *sqp;             /* ptr to a ESL_SQ */
  int           pass_idx;        /* pass_idx passed to DispatchSqAlignment() */
  char          mode;            /* mode passed to DispatchSqAlignment() */
  int           cp9b_valid;      /* passed to DispatchSqAlignment() */

  ESL_ALLOC(dataA, sizeof(CM_ALNDATA *) * ESL_MAX(1, sq_block->count)); // avoid 0 malloc
  for(j = 0; j < sq_block->count; j++) dataA[j] = NULL;

  /* DispatchSqAligment() needs a mode, pipeline pass index, and
   * knowledge of whether cm->cp9b are valid for sequence to align
   * (see note in 'Purpose' above). Currently the relevant values
   * for these are as follows:
   */
  mode       = TRMODE_UNKNOWN;
  pass_idx   = (cm->align_opts & CM_ALIGN_TRUNC) ? PLI_PASS_5P_AND_3P_FORCE : PLI_PASS_STD_ANY;
  cp9b_valid = FALSE;

  /* main loop: for each sequence, call DispatchSqAlignment() to do the work */
  for(j = 0; j < sq_block->count; j++) {
	sqp = sq_block->list + j;
	if((status = DispatchSqAlignment(cm, errbuf, sqp, sq_block->first_seqidx + j, mxsize, mode, pass_idx, cp9b_valid, w, w_tot, r, &(dataA[j]))) != eslOK) goto ERROR;
  }
  *ret_dataA = dataA;

  return eslOK;

 ERROR:
  if(dataA != NULL) {
	for(j = 0; j < sq_block->count; j++) {
	  if(dataA[j] != NULL) cm_alndata_Destroy(dataA[j], FALSE);
	}
	free(dataA);
  }
  *ret_dataA = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "DispatchSqBlockAlignment(), out of memory");
  else return status; /* errbuf was filled by DispatchSqAlignment() */
}

/* Function: DispatchSqAlignment()
 * Date:     EPN, Thu Jan 12 14:47:26 2012
 *
 * Purpose:  Given a CM and a sequence, align the sequence(s) using
 *           the appropriate alignment function and return relevant
 *           data for eventual output in <ret_data>.
 *
 *           This function can be called from either an alignment
 *           pipeline (i.e. cmalign) or a search/scan pipeline
 *           (i.e. cmsearch or cmscan). <idx> is the (overloaded) flag
 *           for determining which, if -1, we're a search/scan
 *           pipeline. This is only relevant because in a search/scan
 *           pipeline we don't care about determining spos/epos so we
 *           don't call ParsetreeToCMBounds().
 *
 *           If (cm->flags & CM_ALIGN_XTAU) we'll potentially tighten
 *           HMM bands until the required DP matrices are below out
 *           limit (<mxsize>). cm->maxtau is the max allowed tau value
 *           during this iterative band tightening, and cm->xtau is
 *           the factor by which we multiply cm->tau at each iteration
 *           during band tightening.
 *
 * Args:     cm         - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           sq         - sequence to align
 *           idx        - index of sequence (may be used to reorder data later)
 *           mxsize     - max size in Mb of allowable DP mx
 *           mode       - preset mode of alignment (TRMODE_UNKNOWN if unknown)
 *           pass_idx   - pipeline pass index, determines trunc penalty
 *           cp9b_valid - TRUE if cm->cp9b are valid, don't compute HMM bands
 *           w          - stopwatch for timing individual stages, can be NULL
 *           w_tot      - stopwatch for timing total time per seq, can be NULL
 *           r          - RNG, req'd if CM_ALIGN_SAMPLE, can be NULL otherwise
 *           ret_data   - RETURN: newly created CM_ALNDATA object
 *
 * Returns:  eslOK on success;
 *           eslEINCOMPAT on contract violation, errbuf is filled;
 *           eslEMEM if we run out of memory;
 *           <ret_data> is alloc'ed and filled.
 */
int
DispatchSqAlignment(CM_t *cm, char *errbuf, ESL_SQ *sq, int64_t idx, float mxsize, char mode, int pass_idx,
		    int cp9b_valid, ESL_STOPWATCH *w, ESL_STOPWATCH *w_tot, ESL_RANDOMNESS *r, CM_ALNDATA **ret_data)
{
  int           status;            /* easel status */
  CM_ALNDATA   *data         = NULL; /* CM_ALNDATA we'll create and fill */
  float         sc           = 0.;   /* score from alignment function */
  float         pp           = 0.;   /* average PP from alignment function */
  Parsetree_t  *tr           = NULL; /* ptr to a parsetree */
  char         *ppstr        = NULL; /* ptr to a PP string */
  float         secs_bands   = 0.;   /* seconds elapsed for band calculation */
  float         secs_aln     = 0.;   /* seconds elapsed for alignment calculation */
  float         mb_tot       = 0.;   /* size of all DP matrices used for alignment */
  double        tau          = -1.;  /* tau used for calculating bands */
  float         thresh1      = -1.;  /* cp9b->thresh1 used for calculating bands */
  float         thresh2      = -1.;  /* cp9b->thresh2 used for calculating bands */
  int           spos         = -1;   /* start posn: first non-gap CM consensus position */
  int           epos         = -1;   /* end   posn: final non-gap CM consensus position */
  double        save_tau     = cm->tau; /* cm->tau upon entrance, we restore before leaving */
  float         save_thresh1 = (cm->cp9b == NULL) ? -1. : cm->cp9b->thresh1;
  float         save_thresh2 = (cm->cp9b == NULL) ? -1. : cm->cp9b->thresh2;

  /* alignment options */
  int do_nonbanded = (cm->align_opts & CM_ALIGN_NONBANDED) ? TRUE  : FALSE;
  int do_qdb       = (cm->align_opts & CM_ALIGN_QDB)       ? TRUE  : FALSE;
  int do_hbanded   = (do_nonbanded || do_qdb)              ? FALSE : TRUE;
  int do_optacc    = (cm->align_opts & CM_ALIGN_OPTACC)    ? TRUE  : FALSE;
  int do_sample    = (cm->align_opts & CM_ALIGN_SAMPLE)    ? TRUE  : FALSE;
  int do_post      = (cm->align_opts & CM_ALIGN_POST)      ? TRUE  : FALSE;
  int do_sub       = (cm->align_opts & CM_ALIGN_SUB)       ? TRUE  : FALSE;
  int do_small     = (cm->align_opts & CM_ALIGN_SMALL)     ? TRUE  : FALSE;
  int do_trunc     = (cm->align_opts & CM_ALIGN_TRUNC)     ? TRUE  : FALSE;
  int do_xtau      = (cm->align_opts & CM_ALIGN_XTAU)      ? TRUE  : FALSE;
  int doing_search = FALSE;

#if eslDEBUGLEVEL >= 1
  printf("in DispatchSqAlignment() %s\n", sq->name);
  printf("\tdo_nonbanded: %d\n", do_nonbanded);
  printf("\tdo_optacc:    %d\n", do_optacc);
  printf("\tdo_sample:    %d\n", do_sample);
  printf("\tdo_post:      %d\n", do_post);
  printf("\tdo_sub:       %d\n", do_sub);
  printf("\tdo_small:     %d\n", do_small);
  printf("\tdo_trunc:     %d\n", do_trunc);
  printf("\tdo_qdb:       %d\n", do_qdb);
  printf("\tdoing_search: %d\n", doing_search);
#endif

  /* sub-mode specific variables (wouldn't be needed if sub mode were not supported) */
  CM_t        *orig_cm = cm;      /* pointer to the original CM */
  CM_t        *sub_cm  = NULL;    /* the sub CM */
  CMSubMap_t  *submap  = NULL;    /* map from mother CM to sub CM, and vice versa */
  Parsetree_t *full_tr = NULL;    /* converted parsetree to full CM */

  /* contract check */
  if(do_small  && do_hbanded)       ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do small and HMM banded alignment");
  if(do_small  && do_optacc)        ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do small and opt acc alignment");
  if(do_post   && do_small)         ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do PP and small alignment");
  if(do_optacc && do_sample)        ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to sample and do optacc alignment");
  if(do_sub    && do_small)         ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do sub and small alignment");
  if(do_sub    && do_trunc)         ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do sub and truncated alignment");
  if(do_sample && r == NULL)        ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to sample but RNG r == NULL");
  if(do_xtau   && ! do_hbanded)     ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to multiply tau without HMM banded alignment");
  if(do_xtau   && cp9b_valid)       ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to multiply tau but HMM bands already valid");
  if(do_qdb    && do_nonbanded)     ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do qdb and nonbanded alignment");
  if(do_qdb    && do_trunc)         ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to use qdbs and truncated alignment");
  /* qdb + trunc combo disallowed only b/c no function exists for it yet */
  if(do_qdb    && (! do_small))     ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to use qdbs but not divide and conquer");
  /* qdb + small combo disallowed b/c only non-HMM banded non-small alignment functions are not set up to use QDBs */
  if(do_qdb && cm->qdbinfo == NULL) {
	ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to use qdbs but cm->qdbinfo is NULL");
  }
  if(do_qdb && (cm->qdbinfo->dmin2 == NULL || cm->qdbinfo->dmax2 == NULL)) {
	ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to use qdbs but cm->qdbinfo is NULL");
  }
  if(do_trunc && (! cm_pli_PassAllowsTruncation(pass_idx))) {
	ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() trying to do truncated alignment, but pass_idx doesn't allow truncation (PLI_PASS_STD_ANY)");
  }
  if(pass_idx == PLI_PASS_STD_ANY && (mode == TRMODE_L || mode == TRMODE_R || mode == TRMODE_T)) {
	ESL_XFAIL(eslEINCOMPAT, errbuf, "DispatchSqAlignment() mode is L, R, or T, but pass_idx is PLI_PASS_STD_ANY");
  }

  if(w_tot != NULL) esl_stopwatch_Start(w_tot);

  /* do sub-mode specific pre-alignment steps, if nec */
  if(do_sub) {
	if((status = sub_alignment_prep(cm, errbuf, sq, &submap, &sub_cm)) != eslOK) goto ERROR;
	cm = sub_cm;
  }

  if(w != NULL) esl_stopwatch_Start(w);
  /* do small D&C alignment, if nec */
  if(do_small) {
	if(do_trunc) {
	  sc = TrCYK_DnC(cm, sq->dsq, sq->L, 0, 1, sq->L, pass_idx, FALSE, &tr); /* FALSE: don't reproduce 1.0 behavior */
	  mb_tot = 4. * CYKNonQDBSmallMbNeeded(cm, sq->L); /* not sure how accurate this is */
	}
	else {
	  /* with QDB, always use dmin2/dmax2, the looser of the two sets of QDBs in cm->qdbinfo */
	  sc = CYKDivideAndConquer(cm, sq->dsq, sq->L, 0, 1, sq->L, &tr,
			       (do_qdb) ? cm->qdbinfo->dmin2 : NULL,
			       (do_qdb) ? cm->qdbinfo->dmax2 : NULL);
	  mb_tot = CYKNonQDBSmallMbNeeded(cm, sq->L);
	}
  }
  else { /* do_small is FALSE */
	if(do_nonbanded || do_qdb) { /* do not use HMM bands */
	  if(do_trunc) {
	if((status = cm_TrAlignSizeNeeded(cm, errbuf, sq->L, mxsize, do_sample, do_post,
					  NULL, NULL, NULL, &mb_tot)) != eslOK) goto ERROR;
	if((status = cm_TrAlign(cm, errbuf, sq->dsq, sq->L, mxsize, mode, pass_idx,
				do_optacc, do_sample, cm->trnb_mx, cm->trnb_shmx, cm->trnb_omx,
				cm->trnb_emx, r, do_post ? &ppstr : NULL, &tr, NULL, &pp, &sc)) != eslOK) goto ERROR;
	  }
	  else {
	if((status = cm_AlignSizeNeeded(cm, errbuf, sq->L, mxsize, do_sample, do_post,
					NULL, NULL, NULL, &mb_tot)) != eslOK) goto ERROR;
	if((status = cm_Align(cm, errbuf, sq->dsq, sq->L, mxsize, do_optacc, do_sample, cm->nb_mx, cm->nb_shmx,
			      cm->nb_omx, cm->nb_emx, r, do_post ? &ppstr : NULL, &tr, &pp, &sc)) != eslOK) goto ERROR;
	  }
	}
	else { /* use HMM bands */
	  if(! cp9b_valid) {
	if(do_xtau) { /* multiply tau (if nec) until required mx is below Mb limit (mxsize) */
	  if((status = cp9_IterateSeq2Bands(cm, errbuf, sq->dsq, 1, sq->L, pass_idx, mxsize, doing_search, do_sample, do_post,
					    cm->maxtau, NULL)) != eslOK) goto ERROR;
	}
	else {
	  if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, sq->dsq,
				     1, sq->L, cm->cp9b, doing_search, pass_idx, 0)) != eslOK) goto ERROR;
	}
	if(w != NULL) esl_stopwatch_Stop(w);
	secs_bands = (w == NULL) ? 0. : w->elapsed;
	tau     = cm->tau;
	thresh1 = cm->cp9b->thresh1;
	thresh2 = cm->cp9b->thresh2;
	/* note: we don't set these three if cp9b_valid is TRUE */
	  }

	  if(w != NULL) esl_stopwatch_Start(w);
	  if(do_trunc) {
	if((status = cm_TrAlignSizeNeededHB(cm, errbuf, sq->L, mxsize, do_sample, do_post,
					    NULL, NULL, NULL, &mb_tot)) != eslOK) goto ERROR;
	  	if((status = cm_TrAlignHB(cm, errbuf, sq->dsq, sq->L, mxsize, mode, pass_idx,
				  do_optacc, do_sample, cm->trhb_mx, cm->trhb_shmx, cm->trhb_omx,
				  cm->trhb_emx, r, do_post ? &ppstr : NULL, &tr, NULL, &pp, &sc)) != eslOK) goto ERROR;
	  }
	  else {
	if((status = cm_AlignSizeNeededHB(cm, errbuf, sq->L, mxsize, do_sample, do_post,
					  NULL, NULL, NULL, &mb_tot)) != eslOK) goto ERROR;
	if((status = cm_AlignHB(cm, errbuf, sq->dsq, sq->L, mxsize, do_optacc, do_sample, cm->hb_mx, cm->hb_shmx,
				cm->hb_omx, cm->hb_emx, r, do_post ? &ppstr : NULL, &tr, &pp, &sc)) != eslOK) goto ERROR;
	  }
	  /* add size of CP9 matrices used for calculating bands */
	  mb_tot += ((float) cm->cp9_mx->ncells_valid  * sizeof(int)) / 1000000.;
	  mb_tot += ((float) cm->cp9_bmx->ncells_valid * sizeof(int)) / 1000000.;
	  if(do_sub) { /* add size of original CM's CP9 matrices used for calculating start/end position */
	mb_tot += ((float) orig_cm->cp9_mx->ncells_valid  * sizeof(int)) / 1000000.;
	mb_tot += ((float) orig_cm->cp9_bmx->ncells_valid * sizeof(int)) / 1000000.;
	  }
	}
  }
  if(w != NULL) esl_stopwatch_Stop(w);
  secs_aln = (w == NULL) ? 0. : w->elapsed;

  if(do_sub) {
	/* convert sub cm parsetree to a full CM parsetree */
	if((status = sub_cm2cm_parsetree(orig_cm, cm, &full_tr, tr, submap, 0)) != eslOK) ESL_XFAIL(status, errbuf, "out of memory, converting sub parsetree to full parsetree");
	/* free sub data structures, we're done with them */
	FreeParsetree(tr);   tr     = full_tr;
	FreeCM(cm);          cm     = orig_cm;
	FreeSubMap(submap);  submap = NULL;
  }

  /* determine start and end points of the parsetree,
   * but only if we're not in a search/scan pipeline
   */
  if(idx != -1) { /* we're not in a search/scan pipeline */
	if((status = ParsetreeToCMBounds(cm, tr, TRUE, TRUE, errbuf, NULL, NULL, NULL, NULL, &spos, &epos)) != eslOK) goto ERROR;
  }

  /* create and fill data */
  ESL_ALLOC(data, sizeof(CM_ALNDATA));
  data->sq         = sq;
  data->idx        = idx;
  data->tr         = tr;
  data->sc         = sc;
  data->pp         = (do_post)      ? pp     : 0.;
  data->ppstr      = (do_post)      ? ppstr  : NULL;
  data->spos       = spos;
  data->epos       = epos;
  data->secs_bands = (do_nonbanded) ? 0.     : secs_bands;
  data->secs_aln   = secs_aln;
  data->mb_tot     = mb_tot;
  data->tau        = tau;
  data->thresh1    = thresh1;
  data->thresh2    = thresh2;
  if(w_tot != NULL) esl_stopwatch_Stop(w_tot);
  data->secs_tot   = (w_tot == NULL) ? 0. : w_tot->elapsed;

  *ret_data = data;

  cm->tau = save_tau;
  if(cm->cp9b != NULL) {
	cm->cp9b->thresh1 = save_thresh1;
	cm->cp9b->thresh2 = save_thresh2;
  }
  return eslOK;

 ERROR:
  cm->tau = save_tau;
  if(cm->cp9b != NULL) {
	cm->cp9b->thresh1 = save_thresh1;
	cm->cp9b->thresh2 = save_thresh2;
  }
  if(data != NULL) cm_alndata_Destroy(data, FALSE);
  *ret_data = NULL;

  if(status == eslEMEM) ESL_FAIL(status, errbuf, "DispatchSqAlignment(), out of memory");

  return status;
}

/*** End of inlined file: cm_alndata.c ***/


/*** Start of inlined file: cm_dpalign.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>


static int   cm_alignT   (CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc, CM_MX    *mx, CM_SHADOW_MX    *shmx, CM_EMIT_MX    *emit_mx, Parsetree_t **ret_tr, float *ret_sc_or_pp);
static int   cm_alignT_hb(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc, CM_HB_MX *mx, CM_HB_SHADOW_MX *shmx, CM_HB_EMIT_MX *emit_mx, Parsetree_t **ret_tr, float *ret_sc_or_pp);

/* Function: cm_alignT()
 * Date:     EPN, Sun Nov 18 19:21:30 2007
 *
 * Note:     Based on insideT() [SRE, Fri Aug 11 12:08:18 2000 [Pittsburgh]]
 *           Renamed from fast_alignT() [EPN, Wed Sep 14 06:04:39 2011].
 *
 * Purpose:  Call either cm_CYKInsideAlign() (if !<do_optacc>),
 *           or cm_OptAccAlign()  (if  <do_optacc>),
 *           get vjd shadow matrix; then trace back and
 *           append to an existing but empty parsetree tr.
 *           The full sequence 1..L will be aligned.
 *
 *           If (<do_optacc>) then emit_mx must != NULL.
 *
 *           Very similar to cm_dpsmall.c:insideT() in case of
 *           CYK alignment, but uses more efficient implementation
 *           of CYK alignment (cm_CYKInsideAlign()) as opposed to
 *           inside()).
 *
 * Args:     cm           - the model
 *           errbuf       - char buffer for reporting errors
 *           dsq          - the digitized sequence [1..L]
 *           L            - length of the dsq to align
 *           size_limit   - max size in Mb for DP matrix
 *           do_optacc    - TRUE to align with optimal accuracy, else use CYK
 *           mx           - the DP matrix to fill in
 *           shmx         - the shadow matrix to fill in
 *           emit_mx      - the pre-filled emit matrix, must be non-NULL if do_optacc
 *           ret_tr       - RETURN: the optimal parsetree
 *           ret_sc_or_pp - RETURN: optimal score (CYK if !do_optacc, else avg PP of all 1..L residues)
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>, in
 *                       this case, alignment has been aborted, ret_* variables are not valid
 *           <eslEINVAL> on traceback problem: bogus state
 */
int
cm_alignT(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc,
	  CM_MX *mx, CM_SHADOW_MX *shmx, CM_EMIT_MX *emit_mx, Parsetree_t **ret_tr, float *ret_sc_or_pp)
{
  int       status;
  Parsetree_t *tr = NULL;       /* the parsetree */
  float     sc;			/* the score of the CYK alignment */
  float     pp;			/* avg pp of all emitted residues in optacc alignment */
  ESL_STACK *pda;               /* stack that tracks bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, j, subseq len */
  int       k;			/* subseq len for bifurcs */
  int       y, yoffset;         /* child state y, it's offset */
  int       bifparent;          /* B_st parent */
  int       b;                  /* local begin state */

  if(do_optacc) { if((status = cm_OptAccAlign   (cm, errbuf, dsq, L, size_limit, mx, shmx, emit_mx, &b, &pp)) != eslOK) return status; }
  else          { if((status = cm_CYKInsideAlign(cm, errbuf, dsq, L, size_limit, mx, shmx,          &b, &sc)) != eslOK) return status; };

  /* Create and initialize the parsetree */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0); /* init: attach the root S */

  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;
  v = 0;
  i = 1;
  j = d = L;

  while (1) {
	if (cm->sttype[v] == B_st) {
	  k = shmx->kshadow[v][j][d];   /* k = len of right fragment */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  /* remember the end j */
	  if((status = esl_stack_IPush(pda, j))       != eslOK) goto ERROR;	/* remember the end j    */
	  if((status = esl_stack_IPush(pda, k))       != eslOK) goto ERROR;	/* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;	/* remember the trace index of the parent B state */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  y = cm->cfirst[v];
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	} else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	} else {
	  yoffset = shmx->yshadow[v][j][d];

	  /*printf("v : %d | r : %d | z : %d | i0 : %d | \n", v, r, z, i0);*/
	  /*printf("\tyoffset : %d\n", yoffset);*/
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    ESL_FAIL(eslEINVAL, errbuf, "bogus state type in cm_alignT()");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL)
	{	/* a local alignment end */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	  v = cm->M;		/* now we're in EL. */
	}
	  else if (yoffset == USED_LOCAL_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	  v = b;
	}
	  else
	{
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	}
  }
  esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */

  if(ret_tr       != NULL) *ret_tr = tr; else FreeParsetree(tr);
  if(ret_sc_or_pp != NULL) *ret_sc_or_pp = do_optacc ? pp : sc;
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: cm_alignT_hb()
 * Date:     EPN 03.29.06
 *
 * Note:     Based on insideT() [SRE, Fri Aug 11 12:08:18 2000 [Pittsburgh]]
 *           Renamed from fast_alignT_hb() [EPN, Wed Sep 14 06:00:51 2011].
 *
 * Purpose: Call either cm_CYKInsideAlignHB() (if !<do_optacc>), or
 *           cm_OptAccAlignHB() (if <do_optacc>), fill banded vjd
 *           shadow matrix in <shmx>; then trace back.  Append the
 *           trace to a given traceback, which already has state 0 at
 *           tr->n-1.
 *
 *           If (<do_optacc>) then emit_mx must != NULL.
 *
 * Args:     cm           - the model
 *           errbuf       - char buffer for reporting errors
 *           dsq          - the digitized sequence [1..L]
 *           L            - length of the dsq to align
 *           size_limit   - max size in Mb for DP matrix
 *           do_optacc    - TRUE to align with optimal accuracy, else use CYK
 *           mx           - the DP matrix to fill in
 *           shmx         - the shadow matrix to fill in
 *           emit_mx      - the pre-filled emit matrix, must be non-NULL if do_optacc
 *           ret_tr       - RETURN: the optimal parsetree
 *           ret_sc_or_pp - RETURN: optimal score (CYK if !do_optacc, else avg PP of all 1..L residues)
 *
 *
 * Throws:  <eslOK>     on success
 *          <eslERANGE> if required CM_HB_MX exceeds <size_limit>
 *          <eslEINVAL> on traceback problem: bogus state
 */
int
cm_alignT_hb(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc,
	     CM_HB_MX *mx, CM_HB_SHADOW_MX *shmx, CM_HB_EMIT_MX *emit_mx, Parsetree_t **ret_tr, float *ret_sc_or_pp)
{
  int       status;
  Parsetree_t *tr = NULL;       /* the parsetree */
  float     sc;			/* the score of the CYK alignment */
  float     pp;			/* avg pp of all emitted residues in optacc alignment */
  ESL_STACK *pda;               /* stack that tracks bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, j, subseq len */
  int       k;			/* subseq len for bifurcs */
  /*int       z;*/              /* state index */
  int       y, yoffset;         /* child state y, it's offset */
  int       bifparent;          /* B_st parent */
  int       b;                  /* local begin state */
  int       jp_v;               /* j-jmin[v] for current j, and current v */
  int       dp_v;               /* d-hdmin[v][jp_v] for current j, current v, current d*/
  int       allow_S_local_end;  /* set to true to allow d==0 BEGL_S and BEGR_S local ends if(do_optacc) */

  /* pointers to cp9b data for convenience */
  CP9Bands_t  *cp9b = cm->cp9b;
  int         *jmin = cp9b->jmin;
  int         *jmax = cp9b->jmax;
  int       **hdmin = cp9b->hdmin;
  int       **hdmax = cp9b->hdmax;

  if(do_optacc) { if((status = cm_OptAccAlignHB   (cm, errbuf, dsq, L, size_limit, mx, shmx, emit_mx, &b, &pp)) != eslOK) return status; }
  else          { if((status = cm_CYKInsideAlignHB(cm, errbuf, dsq, L, size_limit, mx, shmx,	      &b, &sc)) != eslOK) return status; }

  /* Create and initialize the parsetree */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0); /* init: attach the root S */

  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;
  v = 0;
  i = 1;
  j = d = L;

  while (1) {
	/* special case for HMM banded optimal accuracy, explained below, after the crazy if */
	if(do_optacc && d == 0 && (cm->stid[v] == BEGL_S || cm->stid[v] == BEGR_S) &&
	   ((j < jmin[v]             || j > jmax[v]) ||              /* j is outside v's j band */
	(d < hdmin[v][j-jmin[v]] || d > hdmax[v][j-jmin[v]]))) { /* j is within v's j band, but d is outside j's d band */
	  /* special case: doing optimal accuracy and v is a BEGL_S or
	   * BEGR_S and d is 0 and j is outside v's j band or j is within
	   * the band but d is outside j's d band.  We allow this case
	   * because although this implies a cell outside the bands, in
	   * optimal accuracy only emissions add to the score and we to
	   * initialize all cells to IMPOSSIBLE. This means when d==0, we
	   * have no way of distinguishing those cells that have been
	   * reset to IMPOSSIBLE because they correspond to a valid cell
	   * (with valid cells in the B deck, BEGL_S and BEGR_S decks) and
	   * those that do not correspond to a valid cell and were never
	   * changed since initialization (i.e. this case). So we allow it
	   * to prevent an out-of-bounds error. We have to catch it though
	   * so we don't try to determine jp_v and dp_v below. We even use
	   * USED_EL here if we're not in local mode. You could argue
	   * either way whether we should or shouldn't allow this (e.g. we
	   * already allow illegal parsetrees in optimal accuracy), but a
	   * big reason I decided to allow it is that it is difficult
	   * implement a way of disallowing it. Plus the goal of optimal
	   * accuracy is to show the alignment that has the maximum
	   * average PP on emitted residues within the bands. By allowing
	   * this, we also consider a few possible alignments that violate
	   * the bands, which I think is okay.
	   */
	  allow_S_local_end = TRUE; /* this sets yoffset to USED_LOCAL_END in the final 'else' of below code block */
	}
	else if (cm->sttype[v] != EL_st) { /* normal case, determine jp_v, dp_v, j, d offset values given bands */
	  jp_v = j - jmin[v];
	  dp_v = d - hdmin[v][jp_v];
	  allow_S_local_end = FALSE;
	  assert(j >= jmin[v]        && j <= jmax[v]);
	  assert(d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]);
	  ESL_DASSERT1((j >= jmin[v]        && j <= jmax[v]));
	  ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	}

	if (cm->sttype[v] == B_st) {
	  k = shmx->kshadow[v][jp_v][dp_v];   /* k = offset len of right fragment */
	  /*z = cm->cnum[v];*/

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(pda, j)) != eslOK)       goto ERROR;	/* remember the end j    */
	  if((status = esl_stack_IPush(pda, k)) != eslOK)       goto ERROR;	/* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR; /* remember the trace index of the parent B state */
	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  y = cm->cfirst[v];
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	}
	else {
	  /* get yoffset */
	  if (allow_S_local_end) {
	yoffset = USED_EL;
	  }
	  else {
	yoffset = shmx->yshadow[v][jp_v][dp_v];
	  }
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    ESL_FAIL(eslEINVAL, errbuf, "Bogus state type in cm_alignT_hb()");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL)
	{	/* a local alignment end */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	  v = cm->M;		/* now we're in EL. */
	}
	  else if (yoffset == USED_LOCAL_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	  v = b;
	}
	  else
	{
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	  /*ParsetreeDump(stdout, tr, cm, dsq);*/
	}
  }
  esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */

  /*ParsetreeDump(stdout, tr, cm, dsq);*/

  if(ret_tr       != NULL) *ret_tr = tr; else FreeParsetree(tr);
  if(ret_sc_or_pp != NULL) *ret_sc_or_pp = do_optacc ? pp : sc;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: cm_AlignSizeNeeded()
 * Date:     EPN, Thu Jan 12 09:51:11 2012
 *
 * Purpose:  Determine size in Mb required to successfully call
 *           cm_Align() for a given model <cm>, sequence length
 *           <L> and alignment options in <do_sample> and <do_post>.
 *
 *           Return <eslERANGE> if required size exceeds size_limit.
 *
 * Args:     cm         - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of sequence
 *           size_limit - max size in Mb for all required matrices, return eslERANGE if exceeded
 *           do_sample  - TRUE to sample a parsetree from the Inside matrix
 *           do_post    - TRUE to do posteriors
 *           ret_mxmb   - RETURN: size in Mb of required CM_MX (we'll need 2 of these if do_post)
 *           ret_emxmb  - RETURN: size in Mb of required CM_EMIT_MX   (0. if we won't need one)
 *           ret_shmxmb - RETURN: size in Mb of required CM_SHADOW_MX (0. if we won't need one)
 *           ret_totmb  - RETURN: size in Mb of all required matrices
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if total size of all matrices exceeds <size_limit>
 */
int
cm_AlignSizeNeeded(CM_t *cm, char *errbuf, int L, float size_limit, int do_sample, int do_post,
		   float *ret_mxmb, float *ret_emxmb, float *ret_shmxmb, float *ret_totmb)
{
  int          status;
  float        totmb    = 0.;  /* total Mb required for all matrices (that must be simultaneously in memory) */
  float        mxmb     = 0.;  /* Mb required for CM_MX */
  float        emxmb    = 0.;  /* Mb required for CM_EMIT_MX */
  float        shmxmb   = 0.;  /* Mb required for CM_SHADOW_MX */

  /* we pass NULL values to the *_mx_SizeNeeded() functions because we don't care about cell counts */

  /* we will always need an Inside or CYK matrix */
  if((status = cm_mx_SizeNeeded(cm, errbuf, L, NULL, &mxmb)) != eslOK) return status;
  totmb = mxmb;

  /* if calc'ing posteriors, we'll also need an Outside matrix (which
   * we'll reuse as the Posterior matrix, so only count it once) and
   * an emit matrix.
   */
  if(do_post) {
	totmb += mxmb;
	if((status = cm_emit_mx_SizeNeeded(cm, errbuf, L, NULL, NULL, &emxmb)) != eslOK) return status;
	totmb += emxmb;
  }

  /* if we're not sampling an alignment, we'll also need a shadow
   * matrix for the traceback.
   */
  if(! do_sample) { /* if do_sample, we won't need a shadow matrix */
	if((status = cm_shadow_mx_SizeNeeded(cm, errbuf, L, NULL, NULL, &shmxmb)) != eslOK) return status;
	totmb += shmxmb;
  }

  if (ret_mxmb   != NULL) *ret_mxmb    = mxmb;
  if (ret_emxmb  != NULL) *ret_emxmb   = emxmb;
  if (ret_shmxmb != NULL) *ret_shmxmb  = shmxmb;
  if (ret_totmb  != NULL) *ret_totmb   = totmb;

  if(totmb > size_limit) ESL_FAIL(eslERANGE, errbuf, "non-banded standard alignment mxes need %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", totmb, (float) size_limit);

  return eslOK;
}

/* Function: cm_AlignSizeNeededHB()
 * Date:     EPN, Thu Jan 12 10:06:20 2012
 *
 * Purpose:  Determine size in Mb required to successfully call
 *           cm_AlignHB() for a given model <cm>, sequence length
 *           <L>, HMM bands <cm->cp9b> and alignment options
 *           in <do_sample> and <do_post>.
 *
 *           Return <eslERANGE> if required size exceeds size_limit.
 *
 * Args:     cm         - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of sequence
 *           size_limit - max size in Mb for all required matrices, return eslERANGE if exceeded
 *           do_sample  - TRUE to sample a parsetree from the Inside matrix
 *           do_post    - TRUE to do posteriors
 *           ret_mxmb   - RETURN: size in Mb of required CM_HB_MX (we'll need 2 of these if do_post)
 *           ret_emxmb  - RETURN: size in Mb of required CM_HB_EMIT_MX   (0. if we won't need one)
 *           ret_shmxmb - RETURN: size in Mb of required CM_HB_SHADOW_MX (0. if we won't need one)
 *           ret_totmb  - RETURN: size in Mb of all required matrices
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if total size of all matrices exceeds <size_limit>
 */
int
cm_AlignSizeNeededHB(CM_t *cm, char *errbuf, int L, float size_limit, int do_sample, int do_post,
		     float *ret_mxmb, float *ret_emxmb, float *ret_shmxmb, float *ret_totmb)
{
  int          status;
  float        totmb    = 0.;  /* total Mb required for all matrices (that must be simultaneously in memory) */
  float        mxmb     = 0.;  /* Mb required for CM_MX */
  float        emxmb    = 0.;  /* Mb required for CM_EMIT_MX */
  float        shmxmb   = 0.;  /* Mb required for CM_SHADOW_MX */

  /* we pass NULL values to the *_mx_SizeNeeded() functions because we don't care about cell counts */

  /* we will always need an Inside or CYK matrix */
  if((status = cm_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, &mxmb)) != eslOK) return status;
  totmb = mxmb;

  /* if calc'ing posteriors, we'll also need an Outside matrix (which
   * we'll reuse as the Posterior matrix, so only count it once) and
   * an emit matrix.
   */
  if(do_post) {
	totmb += mxmb;
	if((status = cm_hb_emit_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, &emxmb)) != eslOK) return status;
	totmb += emxmb;
  }

  /* if we're not sampling an alignment, we'll also need a shadow
   * matrix for the traceback.
   */
  if(! do_sample) {
	if((status = cm_hb_shadow_mx_SizeNeeded(cm, errbuf, cm->cp9b, NULL, NULL, &shmxmb)) != eslOK) return status;
	totmb += shmxmb;
  }

  if (ret_mxmb   != NULL) *ret_mxmb    = mxmb;
  if (ret_emxmb  != NULL) *ret_emxmb   = emxmb;
  if (ret_shmxmb != NULL) *ret_shmxmb  = shmxmb;
  if (ret_totmb  != NULL) *ret_totmb   = totmb;

#if eslDEBUGLEVEL >= 1
  printf("cm_AlignSizeNeededHB()\n");
  printf("\t mxmb:  %.2f\n", mxmb);
  printf("\t emxmb: %.2f\n", emxmb);
  printf("\t shmxmb:%.2f\n", shmxmb);
  printf("\t totmb: %.2f\n", totmb);
  printf("\t limit: %.2f\n", size_limit);
#endif

  if(totmb > size_limit) ESL_FAIL(eslERANGE, errbuf, "HMM banded standard alignment mxes need %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", totmb, (float) size_limit);

  return eslOK;
}

/* Function: cm_Align()
 * Date:     EPN, Sun Nov 18 19:26:45 2007
 *
 * Note:     Very similar to cm_dpsmall.c:CYKInside() for case
 *           of CYK alignment, but uses slightly more efficient
 *           implementation (cm_CYKInsideAlign() instead of inside()).
 *           Renamed from FastAlign() [EPN, Wed Sep 14 06:12:46 2011].
 *
 * Purpose: Wrapper for the cm_alignT() routine - solve a full
 *           alignment problem either by CYK, using optimal accuracy,
 *           or sampling, and return the traceback and the score,
 *           without dividing & conquering. Optionally return a
 *           posterior code string.
 *
 *           Input arguments allow this function to be run in 6 'modes':
 *
 *           mode      returns                 arguments
 *           ----  ---------------  ----------------------------------------
 *                 tr        ppstr  do_optacc  do_sample post_mx   ret_ppstr
 *                 ---------------  ----------------------------------------
 *              1. CYK       no      FALSE      FALSE      NULL      NULL
 *              2. CYK       yes     FALSE      FALSE     !NULL     !NULL
 *              3. Opt acc   no      TRUE       FALSE     !NULL      NULL
 *              4. Opt acc   yes     TRUE       FALSE     !NULL     !NULL
 *              5. sampled   no      FALSE      TRUE       NULL      NULL
 *              6. sampled   yes     FALSE      TRUE      !NULL     !NULL
 *
 *           CYK parsetrees are most the likely parsetree, 'Opt acc'
 *           parsetrees are Holmes/Durbin optimally accurate
 *           parsetrees, the parse that maximizes the summed posterior
 *           probability of emitted residues. A sampled parsetree
 *           is a parsetree sampled from an Inside matrix based on
 *           it's probability.
 *
 * Args:     cm        - the covariance model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence, 1..L
 *           L         - length of sequence
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_optacc - TRUE: do optimal accuracy alignment, not CYK, requires post_mx != NULL
 *           do_sample - TRUE to sample a parsetree from the Inside matrix
 *           mx        - the main dp matrix, grown and filled here, must be non-NULL
 *           shmx      - the shadow matrix, grown and filled here
 *           post_mx   - dp matrix for posterior calculation, grown and filled here, can be NULL only if !do_optacc
 *           emit_mx   - emit matrix to fill
 *           r         - source of randomness, must be non-NULL only if do_sample==TRUE
 *           ret_ppstr - RETURN: posterior code 1, (pass NULL if not wanted, must be NULL if post_mx == NULL)
 *           ret_tr    - RETURN: traceback (pass NULL if trace isn't wanted)
 *           ret_avgpp - RETURN: avg PP of emitted residues in parsetree (CYK or optacc) if ret_ppstr == NULL, set as 0.
 *           ret_sc    - RETURN: score of the alignment in bits (Inside score if do_optacc)
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if required CM_MX for Inside/Outside/CYK/Posterior exceeds <size_limit>
 */
int
cm_Align(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc, int do_sample,
	 CM_MX *mx, CM_SHADOW_MX *shmx, CM_MX *post_mx, CM_EMIT_MX *emit_mx, ESL_RANDOMNESS *r,
	 char **ret_ppstr, Parsetree_t **ret_tr, float *ret_avgpp, float *ret_sc)
{
  int          status;
  Parsetree_t *tr = NULL;
  float        sc       = 0.;
  float        avgpp    = 0.;
  float        ins_sc   = 0.;
  int          do_post;
  char        *ppstr = NULL;
  int          have_ppstr;

  have_ppstr = (ret_ppstr != NULL)       ? TRUE : FALSE;
  do_post    = (do_optacc || have_ppstr) ? TRUE : FALSE;

  /* Contract check */
  if(do_optacc && do_sample)         ESL_FAIL(eslEINCOMPAT, errbuf, "cm_Align(), do_optacc and do_sample are both TRUE.");
  if(do_optacc && post_mx == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_Align(), do_optacc is TRUE, but post_mx == NULL.\n");
  if(do_sample && r       == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_Align(), do_sample but r is NULL.");

  /* if do_post:   fill Inside, Outside, Posterior matrices, in that order.
   * if do_sample: fill Inside and sample from it.
   */
  if(do_post || do_sample) {
	if((status = cm_InsideAlign (cm, errbuf, dsq, L, size_limit, mx,  &ins_sc)) != eslOK) return status;
	if(do_sample) {
	  if((status = cm_StochasticParsetree(cm, errbuf, dsq, L, mx, r, &tr, &sc)) != eslOK) return status;
	}
	if(do_post) { /* Inside was called above, now do Outside, then Posterior */
	  if((status = cm_OutsideAlign(cm, errbuf, dsq, L, size_limit, ((cm->align_opts & CM_ALIGN_CHECKINOUT) && (! (cm->flags & CMH_LOCAL_END))), post_mx, mx, NULL)) != eslOK) return status;
	  /* Note: we can only check the posteriors in cm_OutsideAlign() if local begin/ends are off */
	  if((status = cm_Posterior       (cm, errbuf, L, size_limit, mx, post_mx, post_mx)) != eslOK) return status;
	  if((status = cm_EmitterPosterior(cm, errbuf, L, size_limit, post_mx, emit_mx, (cm->align_opts & CM_ALIGN_CHECKINOUT))) != eslOK) return status;
	}
  }

  if(!do_sample) { /* if do_sample, we already have a parsetree */
	if((status = cm_alignT(cm, errbuf, dsq, L, size_limit, do_optacc, mx, shmx, emit_mx, &tr, (do_optacc) ? NULL : &sc)) != eslOK) return status;
  }

  if(have_ppstr || do_optacc) { /* call cm_PostCode to get average PP and optionally a PP string (if have_ppstr) */
	if((status = cm_PostCode(cm, errbuf, L, emit_mx, tr, (have_ppstr) ? &ppstr : NULL, &avgpp)) != eslOK) return status;
  }

  if (ret_ppstr  != NULL) *ret_ppstr  = ppstr; else free(ppstr);
  if (ret_tr     != NULL) *ret_tr     = tr;    else FreeParsetree(tr);
  if (ret_avgpp  != NULL) *ret_avgpp  = avgpp;
  if (ret_sc     != NULL) *ret_sc     = (do_optacc) ? ins_sc : sc;

  ESL_DPRINTF1(("returning from cm_Align() sc : %f\n", sc));
  return eslOK;
}

/* Function: cm_AlignHB()
 * Incept:   EPN, Fri Oct 26 09:31:43 2007
 *
 * Note:     Based on CYKInside_b_jd() [11.04.05] which was based on CYKInside_b()
 *           which was based on CYKInside() [SRE, Sun Jun  3 19:48:33 2001 [St. Louis]]
 *           Renamed from cm_AlignHB() [EPN, Wed Sep 14 06:09:51 2011].
 *
 * Purpose: Wrapper for the cm_alignT() routine - solve a full
 *           alignment problem either by CYK, using optimal accuracy,
 *           or sampling, and return the traceback and the score,
 *           without dividing & conquering. Optionally return a
 *           posterior code string.
 *
 *           Identical to cm_Align() but HMM bands are used here.
 *           See that function's 'Purpose' for more details.
 *
 * Args:     cm        - the covariance model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence, 1..L
 *           L         - length of sequence
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_optacc - TRUE: do optimal accuracy alignment, not CYK, requires post_mx != NULL
 *           do_sample - TRUE: sample a parsetree from the Inside matrix
 *           mx        - the main dp matrix, grown and filled here, must be non-NULL
 *           shmx      - the shadow matrix, grown and filled here
 *           post_mx   - dp matrix for posterior calculation, grown and filled here, can be NULL only if !do_optacc
 *           emit_mx   - emit matrix to fill
 *           r         - source of randomness, must be non-NULL only if do_sample==TRUE
 *           ret_ppstr - RETURN: posterior code 1, (pass NULL if not wanted, must be NULL if post_mx == NULL)
 *           ret_tr    - RETURN: traceback (pass NULL if trace isn't wanted)
 *           ret_avgpp - RETURN: avg PP of emitted residues in parsetree (CYK or optacc) if ret_ppstr == NULL, set as 0.
 *           ret_sc    - RETURN: score of the alignment in bits (Inside score if do_optacc)
 *
 * Returns: <eslOK> on success
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if required CM_HB_MX for Inside/Outside/CYK/Posterior exceeds <size_limit>
 */

int
cm_AlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_optacc, int do_sample,
	   CM_HB_MX *mx, CM_HB_SHADOW_MX *shmx, CM_HB_MX *post_mx, CM_HB_EMIT_MX *emit_mx, ESL_RANDOMNESS *r,
	   char **ret_ppstr, Parsetree_t **ret_tr, float *ret_avgpp, float *ret_sc)
{
  int          status;
  Parsetree_t *tr = NULL;
  float        sc     = 0.;
  float        avgpp  = 0.;
  float        ins_sc = 0.;
  int          do_post;
  char        *ppstr = NULL;
  int          have_ppstr;

  have_ppstr = (ret_ppstr != NULL)       ? TRUE : FALSE;
  do_post    = (do_optacc || have_ppstr) ? TRUE : FALSE;

  /* Contract check */
  if(do_optacc && do_sample)         ESL_FAIL(eslEINCOMPAT, errbuf, "cm_AlignHB(), do_optacc and do_sample are both TRUE.");
  if(do_optacc && post_mx == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_AlignHB(), do_optacc is TRUE, but post_mx == NULL.\n");
  if(do_sample && r       == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_AlignHB(), do_sample but r is NULL.");

  /* PrintDPCellsSaved_jd(cm, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, L); */

  /* if do_post:   fill Inside, Outside, Posterior matrices, in that order.
   * if do_sample: fill Inside and sample from it.
   */
  if(do_post || do_sample) {
	if((status = cm_InsideAlignHB (cm, errbuf, dsq, L, size_limit, mx, &ins_sc)) != eslOK) return status;
	if(do_sample) {
	  if((status = cm_StochasticParsetreeHB(cm, errbuf, dsq, L, mx, r, &tr, &sc)) != eslOK) return status;
	}
	if(do_post) { /* Inside was called above, now do Outside, then Posterior */
	  if((status = cm_OutsideAlignHB(cm, errbuf, dsq, L, size_limit, ((cm->align_opts & CM_ALIGN_CHECKINOUT) && (! (cm->flags & CMH_LOCAL_END))), post_mx, mx, NULL)) != eslOK) return status;
	  /* Note: we can only check the posteriors in cm_OutsideAlignHB() if local begin/ends are off */
	  if((status = cm_PosteriorHB       (cm, errbuf, L, size_limit, mx, post_mx, post_mx)) != eslOK) return status;
	  if((status = cm_EmitterPosteriorHB(cm, errbuf, L, size_limit, post_mx, emit_mx, (cm->align_opts & CM_ALIGN_CHECKINOUT))) != eslOK) return status;
	}
  }

  if(!do_sample) { /* if do_sample, we already have a parsetree */
	if((status = cm_alignT_hb(cm, errbuf, dsq, L, size_limit, do_optacc, mx, shmx, emit_mx, &tr, (do_optacc) ? NULL : &sc)) != eslOK) return status;
  }

  if(have_ppstr || do_optacc) {
	if((status = cm_PostCodeHB(cm, errbuf, L, emit_mx, tr, (have_ppstr) ? &ppstr : NULL, &avgpp)) != eslOK) return status;
  }

#if eslDEBUGLEVEL >= 2
	CMEmitMap_t *emap;
	emap = CreateEmitMap(cm);
	DumpEmitMap(stdout, emap, cm);
	FreeEmitMap(emap);
	ParsetreeDump(stdout, tr, cm, dsq);
#endif

  if (ret_ppstr  != NULL) *ret_ppstr  = ppstr; else free(ppstr);
  if (ret_tr     != NULL) *ret_tr     = tr;    else FreeParsetree(tr);
  if (ret_avgpp  != NULL) *ret_avgpp  = avgpp;
  if (ret_sc     != NULL) *ret_sc     = (do_optacc) ? ins_sc : sc;

  ESL_DPRINTF1(("returning from cm_AlignHB() sc : %f\n", sc));
  return eslOK;
}

/* Function: cm_CYKInsideAlign()
 * Date:     EPN, Sun Nov 18 19:37:39 2007
 *
 * Purpose:  Run the inside phase of a CYK alignment. Non-banded
 *           version. See cm_CYKInsideAlignHB() for HMM banded version.
 *
 *           This function must perform a complete alignment, aligning
 *           the full sequence 1..L to the ROOT_S state 0 of the model.
 *
 *           We deal with local begins by keeping track of the optimal
 *           state that we could enter and account for the whole target
 *           sequence: b = argmax_v  alpha_v(1,L) + log t_0(v),
 *           and bsc is the score for that.
 *
 *           If local begins are on (cm->flags & CMH_LOCAL_BEGIN), the
 *           optimal alignment must use a local begin transition,
 *           0->b, and we have to be able to trace that back. If local
 *           begins are on, we return a valid b (the optimal 0->b
 *           choice), yshad[0][L][L] will be USE_LOCAL_BEGIN, telling
 *           cm_alignT() to check b and start with a local 0->b entry
 *           transition.
 *
 *           Note on history of this function: It was previously
 *           fast_cyk_align() (up to Infernal 1.0.2), which was
 *           based on inside() from cm_dpsmall.c.
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence [1..L]
 *           L         - length of the dsq to align
 *           size_limit- max size in Mb for DP matrix
 *           mx        - the DP matrix to fill in
 *           shmx      - the shadow matrix to fill in
 *           ret_b     - RETURN: local begin state if local begins are on
 *           ret_sc    - RETURN: score of optimal, CYK parsetree
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required mx or shmx size exceeds <size_limit>
 *           In this case alignment has been aborted, <ret_*> variables are not valid
 */
int
cm_CYKInsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit,
		  CM_MX *mx, CM_SHADOW_MX *shmx, int *ret_b, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */
  float   *el_scA;      /* [0..d..W-1] probability of local end emissions of length d */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;       /* j - sdr */
  int      d_sd;        /* d - sd */
  float    tsc;         /* a transition score */

  /* the DP matrix */
  float ***alpha   = mx->dp;        /* pointer to the alpha DP matrix */
  char  ***yshadow = shmx->yshadow; /* pointer to the yshadow matrix */
  int   ***kshadow = shmx->kshadow; /* pointer to the kshadow matrix */

  /* Allocations and initializations  */
  b   = -1;
  bsc = IMPOSSIBLE;

  /* grow the matrices based on the current sequence */
  if((status = cm_mx_GrowTo       (cm,   mx, errbuf, L, size_limit)) != eslOK) return status;
  if((status = cm_shadow_mx_GrowTo(cm, shmx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE, all cells of shadow matrix to USED_EL */
  esl_vec_FSet(mx->dp_mem, mx->ncells_valid, IMPOSSIBLE);
  for(i = 0; i < shmx->y_ncells_valid; i++) shmx->yshadow_mem[i] = USED_EL;
  esl_vec_ISet(shmx->kshadow_mem, shmx->k_ncells_valid, USED_EL);

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) alpha[cm->M][j][d] = el_scA[d];
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) {
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize the J deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	for (d = sd; d <= j; d++) {
	  alpha[v][j][d] = el_scA[d-sd] + cm->endsc[v];
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = 0; j <= L; j++) {
	alpha[v][j][0] = 0.;
	/* rest of deck remains IMPOSSIBLE */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][j][d] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = sdr; j <= L; j++) {
	j_sdr = j - sdr;
	for (d = sd; d <= j; d++) {
	  d_sd = d - sd;
	  i    = j - d + 1;
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if ((sc = alpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > alpha[v][j][d]) {
	      alpha[v][j][d] = sc;
	      yshadow[v][j][d]    = yoffset;
	    }
	  }
	  alpha[v][j][d] += esc_v[dsq[i--]];
	  alpha[v][j][d]  = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][j][d] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = sdr; j <= L; j++) {
	j_sdr = j - sdr;
	for (d = sd; d <= j; d++) {
	  d_sd = d - sd;
	  i = j - d + 1;
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if ((sc = alpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > alpha[v][j][d]) {
	      alpha[v][j][d] = sc;
	      yshadow[v][j][d]    = yoffset;
	    }
	  }
	  alpha[v][j][d] += esc_v[dsq[j]];
	  alpha[v][j][d]  = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in alpha[v] are independent of each other, only depending on alpha[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) {
	    if((sc = alpha[y][j_sdr][d - sd] + tsc) > alpha[v][j][d]) {
	      alpha[v][j][d] = sc;
	      yshadow[v][j][d]    = yoffset;
	    }
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = 0; j <= L; j++) {
	  i = j - 1;
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[j-d+1]];
	}
	break;
	  case MR_st:
	for (j = 0; j <= L; j++) {
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = 0; j <= L; j++) {
	  i = j - 1;
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	}
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++)
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    if ((sc = alpha[y][j-k][d-k] + alpha[z][j][k]) > alpha[v][j][d]) {
	      alpha[v][j][d] = sc;
	      kshadow[v][j][d] = k;
	    }
	  }
	}
	  }
	}

	/* allow local begins, if nec */
	if ((cm->flags & CMH_LOCAL_BEGIN) &&
	(NOT_IMPOSSIBLE(cm->beginsc[v])) &&
	(alpha[v][L][L] + cm->beginsc[v] > bsc)) {
	  b   = v;
	  bsc = alpha[v][L][L] + cm->beginsc[v];
	}
  } /* finished calculating deck v. */

  /* Check for whether we need to store an optimal local begin score
   * as the optimal overall score, and if we need to put a flag
   * in the shadow matrix telling cm_alignT() to use the b we return.
   */
  if (bsc > alpha[0][L][L]) {
	alpha[0][L][L] = bsc;
	yshadow[0][L][L] = USED_LOCAL_BEGIN;
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_cykmx",   "w"); cm_mx_Dump(fp1, mx); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.std_cykshmx", "w"); cm_shadow_mx_Dump(fp2, cm, shmx); fclose(fp2);
#endif

  sc = alpha[0][L][L];

  free(el_scA);

  if (ret_b   != NULL) *ret_b  = b;    /* b is -1 if local begins are off */
  if (ret_sc  != NULL) *ret_sc = sc;

  ESL_DPRINTF1(("cm_CYKInsideAlign return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_CYKInsideAlignHB()
 * Date:     EPN 03.29.06 [EPN started]
 *           SRE, Mon Aug  7 13:15:37 2000 [St. Louis]
 *
 * Purpose:  Run the inside phase of a CYK alignment using bands
 *           in the j and d dimensions of the DP matrix. Bands
 *           were obtained from an HMM Forward-Backward parse
 *           of the target sequence. Uses float log odds scores.
 *           Otherwise, (meant to be) identical to cm_CYKInsideAlign()
 *           see that function for more information.
 *
 *           A CM_HB_MX DP matrix must be passed in. Only cells valid
 *           within the bands given in the CP9Bands_t <cm->cp9b> will
 *           be valid.
 *
 *           Note on history of this function: It was previously
 *           fast_cyk_align_hb() (up to Infernal 1.0.2), which was
 *           based on inside_b_me() which was based on inside().
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence [1..L]
 *           L         - length of the dsq to align
 *           size_limit- max size in Mb for DP matrix
 *           mx        - the DP matrix to fill in, only cells within bands are valid
 *           shmx      - the shadow matrix to fill in, only cells within bands are valid
 *           ret_b     - RETURN: best local begin state, or NULL if unwanted
 *           ret_sc    - RETURN: score of optimal, CYK parsetree
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *          <eslEINVAL> if the full sequence is not within the bands for state 0
 *          In either case alignment has been aborted, ret_* variables are not valid
 *
 */
int
cm_CYKInsideAlignHB(CM_t *cm, char *errbuf,  ESL_DSQ *dsq, int L, float size_limit,
		    CM_HB_MX *mx, CM_HB_SHADOW_MX *shmx, int *ret_b, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;      /* [0..d..L-1] probability of local end emissions of length d */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;              /* j - sdr */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y;         /* d index for state v/y in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  int      Lp;                 /* L index also changes depending on state */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b    = cm->cp9b;
  int        *jmin    = cp9b->jmin;
  int        *jmax    = cp9b->jmax;
  int       **hdmin   = cp9b->hdmin;
  int       **hdmax   = cp9b->hdmax;
  float    ***alpha   = mx->dp;        /* pointer to the alpha DP matrix */
  char     ***yshadow = shmx->yshadow; /* pointer to the yshadow matrix */
  int      ***kshadow = shmx->kshadow; /* pointer to the kshadow matrix */

  /* Allocations and initializations  */
  b   = -1;
  bsc = IMPOSSIBLE;
  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo       (cm,   mx, errbuf, cp9b, L, size_limit)) != eslOK) return status;
  if((status = cm_hb_shadow_mx_GrowTo(cm, shmx, errbuf, cp9b, L, size_limit)) != eslOK) return status;

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands)
   */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(alpha[0][0], mx->ncells_valid, IMPOSSIBLE);
  if(shmx->y_ncells_valid > 0) for(i = 0; i < shmx->y_ncells_valid; i++) shmx->yshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will be overwritten */
  if(shmx->k_ncells_valid > 0) esl_vec_ISet(shmx->kshadow_mem, shmx->k_ncells_valid, 0);

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores,
   * Note: we could optimize by skipping this step and using el_scA[d] to
   * initialize ELs for each state in the first step of the main recursion
   * below. We fill in the EL deck here for completeness and so that
   * a check of this alpha matrix with a CYKOutside matrix will pass.
   */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) alpha[cm->M][j][d] = el_scA[d];
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) {
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	jn   = jmin[v];
	jx   = jmax[v];

	/* re-initialize if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	if(hdmin[v][jp_v] >= sd) {
	  d    = hdmin[v][jp_v];
	  dp_v = 0;
	}
	else {
	  d    = sd;
	  dp_v = sd - hdmin[v][jp_v];
	}
	for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	  if(d >= sd) {
	    alpha[v][jp_v][dp_v] = alpha[cm->M][j][d-sd] + cm->endsc[v];
	    /* If we optimize by skipping the filling of the
	     * EL deck the above line would become:
	     * 'alpha[v][jp_v][dp_v] = el_scA[d-sd] + cm->endsc[v];'
	     */
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	alpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if ((sc = alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > alpha[v][jp_v][dp_v])
		{
		  alpha[v][jp_v][dp_v] = sc;
		  yshadow[v][jp_v][dp_v]    = yoffset;
		}
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if ((sc = alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > alpha[v][jp_v][dp_v])
		{
		  alpha[v][jp_v][dp_v] = sc;
		  yshadow[v][jp_v][dp_v]    = yoffset;
		}
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in alpha[v] are independent of each other, only depending on alpha[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);

	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;

	for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	  ESL_DASSERT1((jp_v     >= 0 && jp_v     <= (jmax[v]-jmin[v])));
	  ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	/* d must satisfy:
	 * d >= hdmin[v][jp_v]
	 * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	 * d <= hdmax[v][jp_v]
	 * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	 * this reduces to two ESL_MAX calls
	 */
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	  dpn     = dn - hdmin[v][jp_v];
	  dpx     = dx - hdmin[v][jp_v];
	  dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	    if((sc = alpha[y][jp_y_sdr][dp_y_sd] + tsc) > alpha[v][jp_v][dp_v]) {
	      alpha[v][jp_v][dp_v] = sc;
	      yshadow[v][jp_v][dp_v]    = yoffset;
	    }
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	}
	break;
	  case MR_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	}
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
		/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];

	      if ((sc = alpha[y][jp_y-k][dp_y - k] + alpha[z][jp_z][kp_z])
		  > alpha[v][jp_v][dp_v]) {
		alpha[v][jp_v][dp_v] = sc;
		kshadow[v][jp_v][dp_v] = k;
	      }
	    }
	  }
	}
	  }
	} /* finished calculating deck v. */

	/* allow local begins, if nec */
	if(cm->flags & CMH_LOCAL_BEGIN) {
	  if(L >= jmin[v] && L <= jmax[v]) {
	jp_v = L - jmin[v];
	Lp   = L - hdmin[v][jp_v];
	if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {
	/* If we get here alpha[v][jp_v][Lp] is a valid cell
	 * in the banded alpha matrix, corresponding to
	 * alpha[v][L][L] in the platonic matrix.
	 */
	/* Check for local begin getting us to the root.
	 * This is "off-shadow": if/when we trace back, we'll handle this
	 * case separately (and we'll know to do it because we'll immediately
	 * see a USED_LOCAL_BEGIN flag in the shadow matrix, telling us
	 * to jump right to state b; see below)
	 */
	  if (NOT_IMPOSSIBLE(cm->beginsc[v]) &&
	      (alpha[v][jp_v][Lp] + cm->beginsc[v] > bsc)) {
	    b   = v;
	    bsc = alpha[v][jp_v][Lp] + cm->beginsc[v];
	  }
	}
	  }
	}
  } /* end loop over all v */
  /* Check for whether we need to store an optimal local begin score
   * as the optimal overall score, and if we need to put a flag
   * in the shadow matrix telling cm_alignT() to use the b we return.
   */
  if (NOT_IMPOSSIBLE(bsc) && (bsc > alpha[0][jp_0][Lp_0])) {
	alpha[0][jp_0][Lp_0] = bsc;
	yshadow[0][jp_0][Lp_0] = USED_LOCAL_BEGIN;
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_cykhbmx", "w");   cm_hb_mx_Dump(fp1, mx); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.std_cykhbshmx", "w"); cm_hb_shadow_mx_Dump(fp2, cm, shmx); fclose(fp2);
#endif

  sc = alpha[0][jp_0][Lp_0];

  free(el_scA);
  free(yvalidA);

  if (ret_b != NULL)  *ret_b   = b;    /* b is -1 if local begins are off */
  if (ret_sc != NULL) *ret_sc = sc;

  ESL_DPRINTF1(("cm_CYKInsideAlignHB return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_InsideAlign()
 * Date:     EPN, Mon Nov 19 06:21:51 2007
 *
 * Purpose:  Run the inside algorithm on a target sequence
 *           without using bands. The full target sequence
 *           1..L is aligned (only full alignments will
 *           contribute to the Inside score).
 *
 *           Identical to cm_InsideAlignHB() but no bands
 *           are used.
 *
 *           Very similar to cm_CYKInsideAlign(), see 'Purpose'
 *           of that function for more details. Only differences with
 *           that function is:
 *           - we do Inside, not CYK
 *           - can't return a shadow matrix (we're not aligning)
 *           - doesn't return bsc, b info about local begins
 *
 *           This function complements cm_OutsideAlign().
 *
 *           Note: renamed from FastInsideAlign() [EPN, Wed Sep 14 06:13:37 2011].
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           dsq        - the digitized sequence
 *           L          - target sequence length
 *           size_limit - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           mx         - the dp matrix, grown and filled here
 *           ret_sc     - RETURN: log P(S|M)/P(S|R), as a bit score
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required CM_MX size exceeds <size_limit>
 *           In this case alignment has been aborted, ret_sc is not valid
 */
int
cm_InsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, CM_MX *mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* the final score */
  float    tsc;         /* a temporary variable holding a transition score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  float    bsc;		/* summed score for using all local begins */
  float   *el_scA;      /* [0..d..L-1] probability of local end emissions of length d */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdl;         /* StateLeftDelta(cm->sttype[v] */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;       /* j - sdr */
  int      d_sd;        /* d - sd */

  /* the DP matrix */
  float ***alpha = mx->dp;     /* pointer to the alpha DP matrix */

  /* Allocations and initializations */
  bsc = IMPOSSIBLE;

  /* grow the matrix based on the current sequence */
  if((status = cm_mx_GrowTo(cm, mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(alpha[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) alpha[cm->M][j][d] = el_scA[d];
	}
  }

  /* Main recursion  */
  for (v = cm->M-1; v >= 0; v--) {
	float const *esc_v = cm->oesc[v];
	float const *tsc_v = cm->tsc[v];
	sd   = StateDelta(cm->sttype[v]);
	sdl  = StateLeftDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize the J deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	for (d = sd; d <= j; d++) alpha[v][j][d] = el_scA[d-sd] + cm->endsc[v];
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	/* E_st: easy, no children, and d must be 0 for all valid j */
	if(cm->sttype[v] == E_st) {
	  for (j = 0; j <= L; j++) {
	alpha[v][j][0] = 0.;
	/* rest of deck remains IMPOSSIBLE */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = sdr; j <= L; j++) {
	j_sdr = j - sdr;
	for (d = sd; d <= j; d++) {
	  d_sd = d - sd;
	  i    = j - d + 1;
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], alpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	  }
	  alpha[v][j][d] += esc_v[dsq[i--]];
	  alpha[v][j][d]  = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = sdr; j <= L; j++) {
	j_sdr = j - sdr;
	for (d = sd; d <= j; d++) {
	  d_sd = d - sd;
	  i    = j - d + 1;
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], alpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	  }
	  alpha[v][j][d] += esc_v[dsq[j]];
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in alpha[v] are independent of each other, only depending on alpha[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], (alpha[y][j_sdr][d-sd] + tsc));;
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = 0; j <= L; j++) {
	  i = j - sdl;
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[j-d+1]];
	}
	break;
	  case MR_st:
	for (j = 0; j <= L; j++) {
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = 0; j <= L; j++) {
	  i = j - sdl;
	  for (d = sd; d <= j; d++)
	    alpha[v][j][d] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	}
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++)
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], alpha[y][j-k][d-k] + alpha[z][j][k]);
	  }
	}
	  }
	}

	/* allow local begins, if nec */
	if ((cm->flags & CMH_LOCAL_BEGIN) &&
	(NOT_IMPOSSIBLE(cm->beginsc[v]))) {
	  /* add in score for local begin getting us to the root. */
	  bsc = FLogsum(bsc, alpha[v][L][L] + cm->beginsc[v]);
	}
  } /* finished calculating deck v. */

  /* include the bsc as part of alpha[0][L][L] */
  alpha[0][L][L] = FLogsum(alpha[0][L][L], bsc);

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_imx", "w");   cm_mx_Dump(fp1, mx); fclose(fp1);
#endif

  sc =  alpha[0][L][L];

  free(el_scA);

  if(ret_sc != NULL) *ret_sc = sc;

  ESL_DPRINTF1(("cm_InsideAlign() return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_InsideAlignHB()
 * Date:     EPN, Thu Nov  8 18:24:41 2007
 *
 * Purpose:  Run the inside algorithm on a target sequence using bands
 *           in the j and d dimensions of the DP matrix. Bands
 *           were obtained from an HMM Forward-Backward parse
 *           of the target sequence. Uses float log odds scores.
 *           The full target sequence 1..L is aligned (only full
 *           alignments will contribute to the Inside score).
 *
 *           Very similar to cm_CYKInsideAlignHB(), see 'Purpose'
 *           of that function for more details. Only differences with
 *           that function is:
 *           - we do Inside, not CYK
 *           - can't return a shadow matrix (we're not aligning)
 *           - doesn't return bsc, b info about local begins
 *
 *           This function complements cm_OutsideAlignHB().
 *
 *           Note: renamed from FastInsideAlignHB() [EPN, Wed Sep 14 06:13:08 2011].
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           dsq        - the digitized sequence
 *           L          - target sequence length
 *           size_limit - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           mx         - the dp matrix, only cells within bands in cp9b will be valid
 *           ret_sc     - RETURN: log P(S|M)/P(S|R) (given bands), as a bit score
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:  <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *          <eslEINVAL> if the full sequence is not within the bands for state 0
 *          In either case alignment has been aborted, ret_sc is not valid
 */
int
cm_InsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, CM_HB_MX *mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* the final score */
  float    tsc;         /* a temporary variable holding a transition score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  float    bsc;		/* summed score for using all local begins */
  float   *el_scA;      /* [0..d..L-1] probability of local end emissions of length d */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;       /* j - sdr */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int     *yvalidA;            /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y;         /* d index for state v/y in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  int      Lp;                 /* L also changes depending on state */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* the DP matrix */
  float ***alpha = mx->dp;     /* pointer to the alpha DP matrix */

  /* Allocations and initializations */
  bsc = IMPOSSIBLE;
  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_InsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_InsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo(cm, mx, errbuf, cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(alpha[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands)
   */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores,
   * Note: we could optimize by skipping this step and using el_scA[d] to
   * initialize ELs for each state in the first step of the main recursion
   * below. We fill in the EL deck here for completeness and so that
   * a check of this alpha matrix with a CYKOutside matrix will pass.
   */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) alpha[cm->M][j][d] = el_scA[d];
	}
  }

  /* Main recursion  */
  for (v = cm->M-1; v >= 0; v--) {
	float const *esc_v = cm->oesc[v];
	float const *tsc_v = cm->tsc[v];
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	jn   = jmin[v];
	jx   = jmax[v];

	/* re-initialize the J deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v  = j - jmin[v];
	for (dp_v = 0, d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; dp_v++, d++)
	  alpha[v][jp_v][dp_v] = el_scA[d-sd] + cm->endsc[v];
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	/* E_st: easy, no children, and d must be 0 for all valid j */
	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	alpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	/* rest of deck remains IMPOSSIBLE */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in alpha[v] are independent of each other, only depending on alpha[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;

	for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	  ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	  ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	  dpn     = dn - hdmin[v][jp_v];
	  dpx     = dx - hdmin[v][jp_v];
	  dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	    alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], (alpha[y][jp_y_sdr][dp_y_sd] + tsc));;
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	}
	break;
	  case MR_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	  }
	  default: /* no emission */
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];

	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y-k][dp_y - k] + alpha[z][jp_z][kp_z]);
	    }
	  }
	}
	  }
	}

	/* allow local begins, if nec */
	if((cm->flags & CMH_LOCAL_BEGIN) &&
	   NOT_IMPOSSIBLE(cm->beginsc[v])) {
	  if(L >= jmin[v] && L <= jmax[v]) {
	jp_v = L - jmin[v];
	Lp   = L - hdmin[v][jp_v];
	if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {
	  /* If we get here alpha[v][jp_v][Lp] is a valid cell
	   * in the banded alpha matrix, corresponding to
	   * alpha[v][L][L] in the platonic matrix.
	   */
	  /* Check for local begin getting us to the root.
	   */
	  bsc = FLogsum(bsc, (alpha[v][jp_v][Lp] + cm->beginsc[v]));
	}
	  }
	}
  } /* end loop over all v */

  /* include the bsc as part of alpha[0][jp_0][Lp_0] */
  if (NOT_IMPOSSIBLE(bsc)) {
	alpha[0][jp_0][Lp_0] = FLogsum(alpha[0][jp_0][Lp_0], bsc);
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp; fp = fopen("tmp.std_ihbmx", "w"); cm_hb_mx_Dump(fp, mx); fclose(fp);
#endif

  sc = alpha[0][jp_0][Lp_0];

  free(el_scA);
  free(yvalidA);

  if(ret_sc != NULL) *ret_sc = sc;

  ESL_DPRINTF1(("cm_InsideAlignHB() return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_OptAccAlign()
 * Date:     EPN, Sun Nov 18 20:45:22 2007
 *           EPN, Sat Oct  1 05:57:49 2011 (updated to use emit matrices)
 *
 * Purpose:  Run the Holmes/Durbin optimal accuracy algorithm
 *           on a full target sequence 1..L, given a pre-filled
 *           posterior matrix. Uses float log odds scores.
 *           Non-banded version. See cm_OptAccAlignHB() for
 *           HMM banded version.
 *
 *           A CM_EMIT_MX matrix <emit_mx> must be passed in, filled by
 *           cm_EmitterPosterior(), with values:
 *
 *           l_pp[v][i]: log of the posterior probability that state v
 *           emitted residue i leftwise either at (if a match state)
 *           or *after* (if an insert state) the left consensus
 *           position modeled by state v's node.
 *
 *           r_pp[v][i]: log of the posterior probability that state v
 *           emitted residue i rightwise either at (if a match
 *           state) or *before* (if an insert state) the right
 *           consensus position modeled by state v's node.
 *
 *           l_pp[v] is NULL for states that do not emit leftwise
 *           r_pp[v] is NULL for states that do not emit rightwise
 *
 *           Additionally, a CM_MX DP matrix <mx> and CM_SHADOW_MX
 *           <shmx> must be passed in. <shmx> will be expanded and
 *           filled here with traceback pointers to allow the
 *           optimally accurate parsetree to be recovered in
 *           cm_alignT() and <mx> will be expanded and filled with the
 *           optimal accuracy scores, where:
 *
 *           mx->dp[v][j][d]: log of the sum of the posterior
 *           probabilities of emitting residues i..j in the subtree
 *           rooted at v.
 *
 *           The optimally accurate parsetree, i.e. the parsetree that
 *           maximizes the sum of the posterior probabilities of all
 *           1..L emitted residues, will be found.
 *
 *           Previously (infernal versions 1.0->1.0.2) this function
 *           (then named optimal_accuracy_align()) used the posterior
 *           matrix instead of the emit matrices used here, and thus
 *           did not determine (or at least was not guaranteed to
 *           determine) the optimally accurate parsetree as defined
 *           above. Instead it determined the parsetree that maximized
 *           the probability mass that passed through emitting states.
 *
 *           Local begins are handled the same as they are in
 *           cm_CYKInsideAlign(), see that function's purpose for specifics.
 *
 *           Note: Renamed from optimal_accuracy_align() [EPN, Wed Sep
 *	     14 06:16:38 2011].  Corrected to use emit matrices
 *	     instead of a posterior matrix [EPN, Sat Oct 1 06:04:34
 *	     2011].
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitaized sequence [i0..j0]
 *           L         - length of the dsq
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           mx        - the DP matrix to fill in
 *           shmx      - the shadow matrix to fill in
 *           emit_mx   - pre-filled emit matrix
 *           ret_b     - RETURN: local begin state if local begins are on
 *           ret_pp    - RETURN: average posterior probability of aligned residues
 *                       in the optimally accurate parsetree
 *
 * Returns: <eslOK>     on success.
 * Throws:  <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *          If !eslOK: alignment has been aborted, ret_* variables are not valid
 */
int
cm_OptAccAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, CM_MX *mx, CM_SHADOW_MX *shmx,
	       CM_EMIT_MX *emit_mx, int *ret_b, float *ret_pp)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  float    pp;		/* average posterior probability of all emitted residues */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;       /* j - sdr */
  int      d_sd;        /* d - sd */
  int      have_el;     /* TRUE if CM has local ends on, otherwise FALSE */

  /* the DP matrices */
  float ***alpha   = mx->dp;       /* pointer to the alpha DP matrix, we'll store optimal parse in  */
  float  **l_pp    = emit_mx->l_pp; /* pointer to the prefilled posterior values for left  emitters */
  float  **r_pp    = emit_mx->r_pp; /* pointer to the prefilled posterior values for right emitters */
  char  ***yshadow = shmx->yshadow; /* pointer to the yshadow matrix */
  int   ***kshadow = shmx->kshadow; /* pointer to the kshadow matrix */

  /* Allocations and initializations  */
  b   = -1;
  bsc = IMPOSSIBLE;

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_mx_GrowTo       (cm, mx,   errbuf, L, size_limit)) != eslOK) return status;
  if((status = cm_shadow_mx_GrowTo(cm, shmx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix */
  if(  mx->ncells_valid   > 0) esl_vec_FSet(mx->dp_mem, mx->ncells_valid, IMPOSSIBLE);
  if(shmx->y_ncells_valid > 0) for(i = 0; i < shmx->y_ncells_valid; i++) shmx->yshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will almost certainly be overwritten */
  if(shmx->k_ncells_valid > 0) esl_vec_ISet(shmx->kshadow_mem, shmx->k_ncells_valid, 0);

  /* a special optimal accuracy specific step, initialize yshadow intelligently for d == 0
   * (necessary b/c zero length parsetees have 0 emits and so always score IMPOSSIBLE)
   */
  if((status = cm_InitializeOptAccShadowDZero(cm, errbuf, yshadow, L)) != eslOK) return status;

  /* start with the EL state */
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el && l_pp[cm->M] != NULL) {
	for (j = 0; j <= L; j++) {
	  alpha[cm->M][j][0] = l_pp[cm->M][0];
	  i = j;
	  for (d = 1; d <= j; d++) {
	alpha[cm->M][j][d] = FLogsum(alpha[cm->M][j][d-1], l_pp[cm->M][i--]);
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) {
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize if we can do a local end from v */
	if(have_el && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	/* copy values from saved EL deck */
	for (d = sd; d <= j; d++) {
	  alpha[v][j][d] = alpha[cm->M][j-sdr][d-sd];
	  /* yshadow[v][j][d] remains USED_EL */
	}
	  }
	}
	/* note there's no E state update here, those cells all remain IMPOSSIBLE */

	/* we have to separate out IL_st and IR_st because IL use emit_mx->l_pp and IR use emit_mx->r_pp */
	if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][j][d] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = 1; j <= L; j++) {
	i    = j;
	d_sd = 0;
	for (d = 1; d <= j; d++, d_sd++, i--) {
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if ((sc = alpha[y][j][d_sd]) > alpha[v][j][d]) {
	      alpha[v][j][d]   = sc;
	      yshadow[v][j][d] = yoffset;
	    }
	  }
	  alpha[v][j][d] = FLogsum(alpha[v][j][d], l_pp[v][i]);
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if((! have_el) && yshadow[v][j][d] == USED_EL && d > sd) {
	    alpha[v][j][d] = IMPOSSIBLE;
	  }
	}
	  }
	}
	if(cm->sttype[v] == IR_st) {
	  /* IR: same loop nesting order as for IL for same reason, see IL comment above */
	  j_sdr = 0;
	  for (j = 1; j <= L; j++, j_sdr++) {
	d_sd  = 0;
	for (d = 1; d <= j; d++, d_sd++) {
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if ((sc = alpha[y][j_sdr][d_sd]) > alpha[v][j][d]) {
	      alpha[v][j][d]   = sc;
	      yshadow[v][j][d] = yoffset;
	    }
	  }
	  alpha[v][j][d] = FLogsum(alpha[v][j][d], r_pp[v][j]);
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if((! have_el) && yshadow[v][j][d] == USED_EL && d > sd) {
	    alpha[v][j][d] = IMPOSSIBLE;
	  }
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, so all cells
	   * in alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }.
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	j_sdr = 0;
	for (j = sdr; j <= L; j++, j_sdr++) {
	  d_sd = 0;
	  for (d = sd; d <= j; d++, d_sd++) {
	    if((sc = alpha[y][j_sdr][d_sd]) > alpha[v][j][d]) {
	      alpha[v][j][d] = sc;
	      yshadow[v][j][d] = yoffset;
	    }
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = 1; j <= L; j++) {
	  i = j;
	  for (d = sd; d <= j; d++, i--) {
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], l_pp[v][i]);
	  }
	}
	break;
	  case MR_st:
	for (j = 1; j <= L; j++) {
	  for (d = sd; d <= j; d++) {
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], r_pp[v][j]);
	  }
	}
	break;
	  case MP_st:
	for (j = 2; j <= L; j++) {
	  i = j-1;
	  for (d = sd; d <= j; d++, i--) {
	    alpha[v][j][d] = FLogsum(alpha[v][j][d], FLogsum(l_pp[v][i], r_pp[v][j]));
	  }
	}
	break;
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++)
	  alpha[v][j][d] = ESL_MAX(alpha[v][j][d], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el && sd > 0) { /* this is only necessary for emitters (MP, ML, MR in this context) */
	for (j = 0; j <= L; j++) {
	  for (d = sd+1; d <= j; d++) {
	    if(yshadow[v][j][d] == USED_EL) alpha[v][j][d] = IMPOSSIBLE;
	  }
	}
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    if ((sc = FLogsum(alpha[y][j-k][d-k], alpha[z][j][k])) > alpha[v][j][d])
	      {
		if(((d == k) || (NOT_IMPOSSIBLE(alpha[y][j-k][d-k]))) && /* left  subtree can only be IMPOSSIBLE if it has length 0 (in which case d==k, and d-k=0) */
		   ((k == 0) || (NOT_IMPOSSIBLE(alpha[z][j][k]))))       /* right subtree can only be IMPOSSIBLE if it has length 0 (in which case k==0) */
		  {
		    alpha[v][j][d]   = sc;
		    kshadow[v][j][d] = k;
		    /* Note: we take the logsum here, because we're keeping track of the
		     * log of the summed probability of emitting all residues up to this
		     * point, (from i..j) from left subtree (i=j-d+1..j-k) and from the
		     * right subtree. (j-k+1..j)
		     *
		     * EPN, Tue Nov 17 10:53:13 2009
		     * Bug fix post infernal-1.0.2 release in
		     * "if(((sc = FLogsum..."  statement above.
		     * This is i15 in BUGTRAX, fixed as of svn revision
		     * 3056 in infernal 1.0 release branch, and revision
		     * 3057 in infernal trunk.
		     * Bug description:
		     * See analogous section and comment in
		     * cm_OptAccAlignHB() above. In that
		     * function, in very rare cases (1 case in the 1.1
		     * million SSU sequences in release 10_15 of RDP),
		     * this step will add two alpha values
		     * (alpha[y][j-k][d-k] for left subtree, and
		     * alpha[z][j][k] for right subtree) where one of
		     * them is IMPOSSIBLE and the corresponding
		     * subtree length ('d-k' in left subtree, or 'k'
		     * if right subtree) is non-zero, yet their
		     * FLogsum (which equals the value of the
		     * non-IMPOSSIBLE cell) is sufficiently high to be
		     * part of the optimally accurate traceback. This
		     * will probably cause a seg fault later b/c it
		     * implies a left or right subtree that is
		     * IMPOSSIBLE. It is okay if an IMPOSSIBLE scoring
		     * subtree has length 0 b/c 0 residues will
		     * contribute nothing to the summed log
		     * probability (nothing corresponds to a score of
		     * IMPOSSIBLE). We handle this case here by
		     * explicitly checking if either left or right
		     * subtree cell is IMPOSSIBLE with non-zero length
		     * before reassigning alpha[v][j][d].  I'm not
		     * sure if this is even possible in the non-banded
		     * function (this function), but I included the
		     * analogous fix here (the NOT_IMPOSSIBLE() calls)
		     * in case it was ever possible. This will slow
		     * down the implementation, but I'd rather err on
		     * the side of caution here, since we don't care
		     * so much about speed in the non-banded function,
		     * and b/c finding this bug again if the
		     * non-banded function can have the bug would be a
		     * pain in the ass.
		     */
		  }
	      }
	  }
	}
	  }
	}
	/* allow local begins, if nec */
	if((cm->flags & CMH_LOCAL_BEGIN) && (NOT_IMPOSSIBLE(cm->beginsc[v]))) {
	  if (alpha[v][L][L] > bsc) {
	b   = v;
	bsc = alpha[v][L][L];
	  }
	}
  } /* finished calculating deck v. */

  /* If local begins are on, the only way out of ROOT_S is via a local
   * begin, so update the optimal score and put a flag in the shadow
   * matrix telling cm_alignT() to use the b we return.
   *
   * Note that because we're in OptAcc alpha[0][L][L] will already be
   * equal to bsc because transition scores (and thus impossible
   * transitions out of ROOT_S) have no effect on the score, so
   * whereas we can check to see if 'bsc > alpha[0][L][L]' at an
   * analogous point in CYK before setting the USED_LOCAL_BEGIN
   * flag, we can't here because it would be FALSE.
   */
  if(NOT_IMPOSSIBLE(bsc) && (cm->flags & CMH_LOCAL_BEGIN)) {
	alpha[0][L][L]   = bsc;
	yshadow[0][L][L] = USED_LOCAL_BEGIN;
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_oamx",   "w"); cm_mx_Dump(fp1, mx); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.std_oashmx", "w"); cm_shadow_mx_Dump(fp2, cm, shmx); fclose(fp2);
#endif

  sc = alpha[0][L][L];

  /* convert sc, a log probability, into the average posterior probability of all L aligned residues */
  pp = sreEXP2(sc) / (float) L;

  if(ret_b != NULL)  *ret_b  = b;    /* b is -1 if local ends are off */
  if(ret_pp != NULL) *ret_pp = pp;

  ESL_DPRINTF1(("cm_OptAccAlign return pp: %f\n", pp));
  return eslOK;
}

/* Function: cm_OptAccAlignHB()
 * Date:     EPN, Thu Nov 15 10:48:37 2007
 *
 * Purpose:  Same as cm_OptAccAlign() but HMM bands are used.
 *           See cm_OptAccAlign()'s Purpose for more information.
 *
 *           Note: Renamed from optimal_accuracy_align_hb() [EPN, Wed Sep 14 06:16:06 2011].
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitaized sequence [i0..j0]
 *           L         - length of the dsq
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           mx        - the DP matrix to fill in
 *           shmx      - the shadow matrix to fill in
 *           emit_mx   - pre-filled emit matrix
 *           ret_b     - RETURN: local begin state if local begins are on
 *           ret_pp    - RETURN: average posterior probability of aligned residues
 *                       in the optimally accurate parsetree
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *          If !eslOK: alignment has been aborted, ret_* variables are not valid
 */
int
cm_OptAccAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, CM_HB_MX *mx, CM_HB_SHADOW_MX *shmx,
		 CM_HB_EMIT_MX *emit_mx, int *ret_b, float *ret_pp)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  float    pp;		/* average posterior probability of all emitted residues */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  int      jp_0;        /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;        /* L offset in ROOT_S's (v==0) d band */
  int      Lp;          /* L offset in any state v's d band */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v] */
  int      have_el;     /* TRUE if CM has local ends on, otherwise FALSE */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      ip_v;               /* offset i index for state v */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y;         /* d index for state v/y in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      jp_y_minus_k;       /* jp_y - k, used in one loop, stored to avoid calc'ing twice */
  int      dp_y_minus_k;       /* dp_y - k, used in one loop, stored to avoid calc'ing twice */
  int      kn, kx;             /* current minimum/maximum k value */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b  = cm->cp9b;
  int        *imin  = cp9b->imin;
  int        *imax  = cp9b->imax;
  int        *jmin  = cp9b->jmin;
  int        *jmax  = cp9b->jmax;
  int       **hdmin = cp9b->hdmin;
  int       **hdmax = cp9b->hdmax;

  /* the DP matrices */
  float ***alpha   = mx->dp;        /* pointer to the alpha DP matrix, we'll store optimal parse in  */
  float  **l_pp    = emit_mx->l_pp; /* pointer to the prefilled posterior values for left  emitters */
  float  **r_pp    = emit_mx->r_pp; /* pointer to the prefilled posterior values for right emitters */
  char  ***yshadow = shmx->yshadow; /* pointer to the yshadow matrix */
  int   ***kshadow = shmx->kshadow; /* pointer to the kshadow matrix */

  /* Allocations and initializations  */
  b   = -1;
  bsc = IMPOSSIBLE;
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_OptAccAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_OptAccAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo       (cm, mx,   errbuf, cp9b, L, size_limit)) != eslOK) return status;
  if((status = cm_hb_shadow_mx_GrowTo(cm, shmx, errbuf, cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix */
  if(  mx->ncells_valid   > 0) esl_vec_FSet(mx->dp_mem, mx->ncells_valid, IMPOSSIBLE);
  if(shmx->y_ncells_valid > 0) for(i = 0; i < shmx->y_ncells_valid; i++) shmx->yshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will almost certainly be overwritten */
  if(shmx->k_ncells_valid > 0) esl_vec_ISet(shmx->kshadow_mem, shmx->k_ncells_valid, 0);

  /* a special optimal accuracy specific step, initialize yshadow intelligently for d == 0
   * (necessary b/c zero length parsetees have 0 emits and so always score IMPOSSIBLE)
   */
  if((status = cm_InitializeOptAccShadowDZeroHB(cm, cp9b, errbuf, yshadow, L)) != eslOK) return status;

  /* start with the EL state (remember, cm->M deck is non-banded) */
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el && l_pp[cm->M] != NULL) {
	for (j = 0; j <= L; j++) {
	  alpha[cm->M][j][0] = l_pp[cm->M][0];
	  i = j;
	  for (d = 1; d <= j; d++) {
	alpha[cm->M][j][d] = FLogsum(alpha[cm->M][j][d-1], l_pp[cm->M][i--]);
	  }
	}
  }

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) {
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize if we can do a local end from v */
	if(have_el && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	/* copy values from saved EL deck */
	for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];
	  alpha[v][jp_v][dp_v] = alpha[cm->M][j-sdr][d-sd];
	  /* yshadow[v][jp_v][dp_v] remains USED_EL */
	}
	  }
	}
	/* note there's no E state update here, those cells all remain IMPOSSIBLE */

	/* we could separate out IL_st and IR_st, but I don't it makes a significant difference in run time */
	if(cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL/IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	i = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) { /* for each valid d for v, j */
	  /*printf("v: %4d j: %4d (%4d..%4d) d: %4d (%4d..%4d) i: %4d (%4d..%4d)\n",
	    v, j, jmin[v], jmax[v], d, hdmin[v][jp_v], hdmax[v][jp_v], i, imin[v], imax[v]);*/
	  assert(i >= imin[v] && i <= imax[v]);
	  ESL_DASSERT1((i >= imin[v] && i <= imax[v]));
	  ip_v = i - imin[v];         /* i index for state v in emit_mx->l_pp */
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if ((sc = alpha[y][jp_y_sdr][dp_y_sd]) > alpha[v][jp_v][dp_v])
		{
		  alpha[v][jp_v][dp_v] = sc;
		  yshadow[v][jp_v][dp_v]    = yoffset;
		}
	    }
	  }
	  if(cm->sttype[v] == IL_st) alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], l_pp[v][ip_v]);
	  else                       alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], r_pp[v][jp_v]);
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if((! have_el) && yshadow[v][jp_v][dp_v] == USED_EL && d > sd) {
	    alpha[v][jp_v][dp_v] = IMPOSSIBLE;
	  }
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in alpha[v] are independent of each other, only depending on alpha[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];

	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;

	for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	  ESL_DASSERT1((jp_v     >= 0 && jp_v     <= (jmax[v]-jmin[v])));
	  ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	  dpn     = dn - hdmin[v][jp_v];
	  dpx     = dx - hdmin[v][jp_v];
	  dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	    if((sc = alpha[y][jp_y_sdr][dp_y_sd]) > alpha[v][jp_v][dp_v]) {
	      alpha[v][jp_v][dp_v] = sc;
	      yshadow[v][jp_v][dp_v] = yoffset;
	    }
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  i    = j - hdmin[v][jp_v] + 1;
	  ip_v = i - imin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++, ip_v--) {
	    /*printf("v: %4d j: %4d (%4d..%4d) d: %4d (%4d..%4d) i: %4d (%4d..%4d)\n",
	      v, j, jmin[v], jmax[v], d, hdmin[v][jp_v], hdmax[v][jp_v], i, imin[v], imax[v]);*/
	    assert(ip_v >= 0 && ip_v <= (imax[v] - imin[v]));
	    ESL_DASSERT1((ip_v >= 0 && ip_v <= (imax[v] - imin[v])));
	    alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], l_pp[v][ip_v]);
	  }
	}
	break;
	  case MR_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	    alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], r_pp[v][jp_v]);
	  }
	}
	break;
	  case MP_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  i    = j - hdmin[v][jp_v] + 1;
	  ip_v = i - imin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++, ip_v--) {
	    assert(ip_v >= 0 && ip_v <= (imax[v] - imin[v]));
	    ESL_DASSERT1((ip_v >= 0 && ip_v <= (imax[v] - imin[v])));
	    alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], FLogsum(l_pp[v][ip_v], r_pp[v][jp_v]));
	  }
	}
	break;
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el && sd > 0) { /* this is only necessary for emitters (MP, ML, MR in this context) */
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  d = ESL_MAX(sd+1, hdmin[v][jp_v]);
	  dp_v = d - hdmin[v][jp_v];
	  for (; d <= hdmax[v][jp_v]; d++) {
	    if(yshadow[v][jp_v][dp_v] == USED_EL) alpha[v][jp_v][dp_v] = IMPOSSIBLE;
	    dp_v++;
	  }
	}
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      jp_y_minus_k = jp_y-k;
	      dp_y_minus_k = dp_y-k;

	      if((sc = FLogsum(alpha[y][jp_y_minus_k][dp_y_minus_k], alpha[z][jp_z][kp_z])) > alpha[v][jp_v][dp_v])
		{
		  if(((d == k) || (NOT_IMPOSSIBLE(alpha[y][jp_y_minus_k][dp_y_minus_k]))) && /* left subtree can only be IMPOSSIBLE if it has length 0 (in which case d==k, and d-k=0) */
		     ((k == 0) || (NOT_IMPOSSIBLE(alpha[z][jp_z][kp_z]))))                   /* right subtree can only be IMPOSSIBLE if it has length 0 (in which case k==0) */
		    {
		      alpha[v][jp_v][dp_v] = sc;
		      kshadow[v][jp_v][dp_v] = k;
		      /* Note: we take the logsum here, because we're
		       * keeping track of the log of the summed probability
		       * of emitting all residues up to this point, (from
		       * i..j) from left subtree (i=j-d+1..j-k) and from the
		       * right subtree. (j-k+1..j).
		       *
		       * EPN, Tue Nov 17 09:57:59 2009:
		       * Bug fix post infernal-1.0.2 release.
		       * Addition of 2-line if statement beginning
		       * "if(((d == k...)"  This is i15 in BUGTRAX,
		       * fixed as of svn revision 3056 in infernal 1.0
		       * release branch, and revision 3057 in infernal
		       * trunk.
		       * Bug description: In very rare cases (1 case
		       * in the 1.1 million SSU sequences in release
		       * 10_15 of RDP), this step will add two alpha
		       * values (alpha[y][jp_y_minus_k][dp_y_minus_k]
		       * for left subtree, and alpha[z][jp_z][kp_z]
		       * for right subtree) where one of them is
		       * IMPOSSIBLE and the corresponding subtree
		       * length ('d-k' in left subtree, or 'k' if right
		       * subtree) is non-zero, yet their FLogsum
		       * (which equals the value of the non-IMPOSSIBLE
		       * cell) is sufficiently high to be part of the
		       * optimally accurate traceback. This will
		       * probably cause a seg fault later b/c it
		       * implies a left or right subtree that is
		       * IMPOSSIBLE. It is okay if an IMPOSSIBLE
		       * scoring subtree has length 0 b/c 0 residues
		       * will contribute nothing to the summed log
		       * probability (nothing corresponds to a score
		       * of IMPOSSIBLE). We handle this case here by
		       * explicitly checking if either left or right
		       * subtree cell is IMPOSSIBLE with non-zero
		       * length before reassigning
		       * alpha[v][jp_v][dp_v].
		       */
		    }
		}
	    }
	  }
	}
	  }
	}
	/* allow local begins, if nec */
	if((cm->flags & CMH_LOCAL_BEGIN) && (NOT_IMPOSSIBLE(cm->beginsc[v]))) {
	  if(L >= jmin[v] && L <= jmax[v]) {
	jp_v = L - jmin[v];
	Lp   = L - hdmin[v][jp_v];
	if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {
	/* If we get here alpha[v][jp_v][Wp] is a valid cell
	 * in the banded alpha matrix, corresponding to
	 * alpha[v][j0][W] in the platonic matrix.
	 */
	/* Check for local begin getting us to the root.
	 * This is "off-shadow": if/when we trace back, we'll handle this
	 * case separately (and we'll know to do it because we'll immediately
	 * see a USED_LOCAL_BEGIN flag in the shadow matrix, telling us
	 * to jump right to state b; see below)
	 */
	  if (alpha[v][jp_v][Lp] > bsc) {
	    b   = v;
	    bsc = alpha[v][jp_v][Lp];
	  }
	}
	  }
	}
  } /* end loop over all v */

  /* If local begins are on, the only way out of ROOT_S is via a local
   * begin, so update the optimal score and put a flag in the shadow
   * matrix telling cm_alignT() to use the b we return.
   *
   * Note that because we're in OptAcc alpha[0][L][L] will already be
   * equal to bsc because transition scores (and thus impossible
   * transitions out of ROOT_S) have no effect on the score, so
   * whereas we can check to see if 'bsc > alpha[0][L][L]' at an
   * analogous point in CYK before setting the USED_LOCAL_BEGIN
   * flag, we can't here because it would be FALSE.
   */
  if(NOT_IMPOSSIBLE(bsc) && (cm->flags & CMH_LOCAL_BEGIN)) {
	alpha[0][jp_0][Lp_0]   = bsc;
	yshadow[0][jp_0][Lp_0] = USED_LOCAL_BEGIN;
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_oahbmx",   "w"); cm_hb_mx_Dump(fp1, mx); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.std_oahbshmx", "w"); cm_hb_shadow_mx_Dump(fp2, cm, shmx); fclose(fp2);
#endif

  sc = alpha[0][jp_0][Lp_0];

  /* convert sc, a log probability, into the average posterior probability of all L aligned residues */
  pp = sreEXP2(sc) / (float) L;

  free(yvalidA);

  if (ret_b  != NULL)   *ret_b  = b;   /* b is -1 if local begins are off */
  if (ret_pp != NULL)   *ret_pp = pp;

  ESL_DPRINTF1(("cm_OptAccAlignHB return pp: %f\n", pp));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
  return status; /* never reached */
}

/* Function: cm_CYKOutsideAlign()
 * Date:     EPN, Wed Sep 14 14:01:36 2011
 *
 * Purpose:  Run the outside CYK algorithm on a target sequence.
 *           Non-banded version. See cm_CYKOutsideAlignHB() for
 *           the HMM banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_OutsideAlign() but calculates
 *           beta[v][j][d]: log probability of the most likely parse
 *           that emits 1..i-1 and j+1..L and passes through v at j,d
 *           (where i = j-d+1) instead of the log of the summed
 *           probability of all such parses. This means max operations
 *           are used instead of logsums.
 *
 *           This function complements cm_CYKInsideAlign() but is
 *           mainly useful for testing and reference. It can be used
 *           with do_check=TRUE to verify that the implementation of
 *           CYKInside and CYKOutside are consistent.  Because the
 *           structure of CYKInside and Inside, and CYKOutside and
 *           Outside are so similar and the CYK variants are easier to
 *           debug (because only the optimal parsetree is considered
 *           instead of all possible parsetrees) this function can be
 *           useful for finding bugs in Outside.  It is currently not
 *           hooked up to any of the main Infernal programs.
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence
 *           L         - length of the dsq to align
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check  - TRUE to attempt to check
 *           mx        - the dp matrix, grown and filled here
 *           inscyk_mx - the pre-filled dp matrix from the CYK Inside calculation
 *                       (performed by cm_CYKInsideAlign(), required)
 *           ret_sc    - RETURN: log P(S|M)/P(S|R), as a bit score, this is from
 *                       inscyk_mx IF local ends are on (see comments towards
 *                       end of function).
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *           <eslEMEM>   if we run out of memory
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In any of these cases, alignment has been aborted, ret_sc is not valid.
 */
int
cm_CYKOutsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_check,
		   CM_MX *mx, CM_MX *inscyk_mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float    sc;     	       /* a temporary score */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check==TRUE */
  int      fail1_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 1*/
  int      fail2_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 2*/
  int      fail3_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 3*/
  int      n;                  /* counter over nodes, used only if do_check = TRUE */
  int      num_split_states;   /* temp variable used only if do_check = TRUE */
  float    diff;               /* temp variable used only if do_check = TRUE */
  int      vmax;               /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */
  int     *optseen = NULL;     /* [1..i..W] TRUE is residue i is accounted for in optimal parse */

  /* the DP matrices */
  float ***beta  = mx->dp;        /* pointer to the Oustide DP mx */
  float ***alpha = inscyk_mx->dp; /* pointer to the CYK Inside DP mx (already calc'ed and passed in) */

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* grow the matrix based on the current sequence */
  if((status = cm_mx_GrowTo(cm, mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(beta[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* now set beta[0][L][L] to 0., all (valid) parses must end there */
  beta[0][L][L] = 0.;

  /* initialize local begin cells for emitting full seq (j==L && d == L) */
  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (v = 1; v < cm->M; v++)
	  beta[v][L][L] = cm->beginsc[v];
  }

  /* Main recursion */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	sd  = StateDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);

	if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	  y = cm->plast[v];	/* the parent bifurcation    */
	  z = cm->cnum[y];	/* the other (right) S state */
	  for(j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= (L-j); k++) {
	    beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j+k][d+k] + alpha[z][j+k][k]));
	  }
	}
	  }
	} /* end of 'if (cm->stid[v] == BEGL_S */
	else if (cm->stid[v] == BEGR_S) {
	  y = cm->plast[v];	  /* the parent bifurcation    */
	  z = cm->cfirst[y];  /* the other (left) S state  */
	  for(j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= (j-d); k++) {
 	    beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j][d+k] + alpha[z][j-d][k]));
	  }
	}
	  }
	} /* end of 'else if (cm->stid[v] == BEGR_S */
	else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	  for (j = L; j >= 0; j--) {
	i = 1;
	for (d = j; d >= 0; d--, i++) {
	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	    voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
	    sd  = StateDelta(cm->sttype[y]);
	    sdr = StateRightDelta(cm->sttype[y]);
	    switch(cm->sttype[y]) {
	      case MP_st:
		if (j == L || d == j) continue; /* boundary condition */
		escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case ML_st:
	      case IL_st:
		if (d == j) continue;	/* boundary condition (note when j=0, d=0*/
		escore = esc_vAA[y][dsq[i-1]];
		beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case MR_st:
	      case IR_st:
		if (j == L) continue;
		escore = esc_vAA[y][dsq[j+1]];
		beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		beta[v][j][d] = ESL_MAX(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset]));
		break;
	    } /* end of switch(cm->sttype[y] */
	  } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	  if (beta[v][j][d] < IMPOSSIBLE) beta[v][j][d] = IMPOSSIBLE;
	} /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	  } /* end loop over j. We know beta for this whole state */
	} /* end of 'else if cm->sttype[v] != BEGL_S, BEGR_S */
	/* we're done calculating deck v for everything but local begins */

	/* deal with local alignment end transitions v->EL (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sdr = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	  sd  = StateDelta(cm->sttype[v]);      /* note sd  is for state v */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  i = j-d+1;
	  switch (cm->sttype[v]) {
	  case MP_st:
	    if (j == L || d == j) continue; /* boundary condition */
	    escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case ML_st:
	  case IL_st:
	    if (d == j) continue;
	    escore = esc_vAA[v][dsq[i-1]];
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case MR_st:
	  case IR_st:
	    if (j == L) continue;
	    escore = esc_vAA[v][dsq[j+1]];
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case S_st:
	  case D_st:
	  case B_st:
	  case E_st:
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]));
	    break;
	  }
	}
	  }
	}
  }
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) /* careful w/ boundary here */
	beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[cm->M][j][d+1] + cm->el_selfsc));
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_ocykmx", "w");   cm_mx_Dump(fp1, mx); fclose(fp1);
#endif

  fail1_flag = FALSE;
  fail2_flag = FALSE;
  fail3_flag = FALSE;
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. We assume the Inside CYK parse score
	 * (optsc) is the optimal score, so for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 *
	 * Further, we know that each residue must be emitted by a state
	 * in the optimal parse. So as we do the above check, we determine
	 * when we're in a cell that may be involved in the optimal parse
	 * (the sum of the Inside and Outside scores are equal to the
	 * optimal parse score), if that cell corresponds to a left
	 * emitter emitting position i, we know an emitted i has been
	 * observed in an optimal parse and set optseen[i] to TRUE.
	 * Likewise, if that cell corresponds to a right emitter emitting
	 * position j, we update optseen[j] to TRUE. At the end of the
	 * check optseen[i] should be TRUE for all i in the range
	 * [1..L].
	 *
	 * Note that we don't ensure that all of our presumed optimal
	 * cells make up a valid parse, so it is possible we could pass
	 * this check even if the Inside and Outside matrices are
	 * inconsistent (i.e. there's a bug in the implementation of one
	 * and or the other) but that should be extremely unlikely.  If we
	 * do this test many times for many different models and pass, we
	 * should be confident we have consistent implementations.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 *
	 * Another test we could do but do not is to determine the CYK
	 * parse by tracing back the CYK Inside matrix, then ensure that
	 * for each cell in that parse alpha[v][j][d]+beta[v][j][d] ==
	 * optsc.
	 */
	ESL_ALLOC(optseen, sizeof(int) * (L+1));
	esl_vec_ISet(optseen, L+1, FALSE);
	vmax = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  for(j = 1; j <= L; j++) {
	for(d = 0; d <= j; d++) {
	  sc  = (alpha[v][j][d] + beta[v][j][d]) - alpha[0][L][L];
	  if(sc > tol) {
	    printf("Check 1 failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, alpha[v][j][d], beta[v][j][d], alpha[v][j][d] + beta[v][j][d], alpha[0][L][L]);
	    fail1_flag = TRUE;
	  }
	  if(fabs(sc) < tol) { /* this cell is involved in a parse with the optimal score */
	    i  = j-d+1;
	    if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st || (cm->sttype[v] == EL_st && d >0)) {
	      /* i is accounted for by a parse with an optimal score */
	      optseen[i] = TRUE;
	      /*printf("\tResidue %4d possibly accounted for by Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);*/
	    }
	    if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	      /* j is accounted for by a parse with an optimal score */
	      optseen[j] = TRUE;
	      /*printf("\tResidue %4d possibly accounted for by Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);*/
	    }
	  }
	}
	  }
	}
	for(j = 1; j <= L; j++) {
	  if(optseen[j] == FALSE) {
	printf("Check 2 failure: residue %d not emitted in the optimal parsetree\n", j);
	fail2_flag = TRUE;
	  }
	}
	free(optseen);
  }
  /* Another test that we can only do if local ends are OFF */
  if(do_check && (!(cm->flags & CMH_LOCAL_END))) {
	/* Local ends make the following test invalid because it is not true that
	 * exactly 1 state in each node's split set must be visited in each parse.
	 *
	 * Determine P(pi, S|M) / P(S|R) (probability of the sequence and most likely parse
	 * tree pi given the model)
	 * using both the Outside (beta) and Inside (alpha) matrices,
	 * and ensure they're consistent with P(pi, S|M) / P(S|R) from the Inside calculation.
	 * For all v in each split set: Max_v [ Max_j,(d<=j) ( alpha[v][j][d] * beta[v][j][d] ) ]
	 *                                                = P(pi, S|M) / P(S|R)
	 */
	for(n = 0; n < cm->nodes; n++) {
	  sc = IMPOSSIBLE;
	  num_split_states = SplitStatesInNode(cm->ndtype[n]);
	  for(v = cm->nodemap[n]; v < cm->nodemap[n] + num_split_states; v++) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    sc = ESL_MAX(sc, (alpha[v][j][d] + beta[v][j][d]));
	  }
	}
	  }
	  /*printf("checking node: %d | sc: %.6f\n", n, sc);*/
	  diff = sc - alpha[0][L][L];
	  if(diff > 0.01 || diff < -0.01) {
	fail3_flag = TRUE;
	printf("ERROR: node %d P(S|M): %.5f inconsistent with Inside P(S|M): %.5f (diff: %.5f)\n",
	       n, sc, alpha[0][L][L], diff);
	  }
	}
  }
  /* Finally, calculate the optimal score, but this only works if
   * we're not in local mode:
   *
   * If local ends are off, we know the optimal parse MUST visit each END_E state,
   * we pick final END_E state state cm->M-1 (though any END_E could be used here):
   *
   * Max_j=0 to L (alpha[M-1][j][0] * beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * Note: alpha[M-1][j][0] = 0.0 for all j
   *       because all parse subtrees rooted at an END_E must have d=0, (2^0 = 1.0)
   * therefore:
   * Max_j=0 to L (beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * *** If local ends are on, each parse MUST visit either each END_E state with d=0
   * or the EL state but d can vary, so we can't use this test (believe me I tried
   * to get a similar test working, but I'm convinced you need alpha to get P(S|M)
   * in local mode).
   */
  if(!(cm->flags & CMH_LOCAL_END)) {
	sc = IMPOSSIBLE;
	v = cm->M-1;
	for (j = 0; j <= L; j++) {
	  sc = ESL_MAX(sc, (beta[v][j][0]));
	  /*printf("\talpha[%3d][%3d][%3d]: %5.2f | beta[%3d][%3d][%3d]: %5.2f\n", (cm->M-1), (j), 0, alpha[(cm->M-1)][j][0], (cm->M-1), (j), 0, beta[(cm->M-1)][j][0]);*/
	}
  }
  else { /* return sc = P(S|M) / P(S|R) from Inside() */
	sc = alpha[0][L][L];
  }

  if(do_check) {
	if     (fail1_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside check1 FAILED.");
	else if(fail2_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside check2 FAILED.");
	else if(fail3_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside check3 FAILED.");
	ESL_DPRINTF1(("SUCCESS! CYK Inside/Outside checks PASSED.\n"));
  }

  if(!(cm->flags & CMH_LOCAL_END)) ESL_DPRINTF1(("\tcm_CYKOutsideAlign() sc : %f\n", sc));
  else                             ESL_DPRINTF1(("\tcm_CYKOutsideAlign() sc : %f (LOCAL mode; sc is from Inside)\n", sc));

  if(ret_sc != NULL) *ret_sc = sc;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_CYKOutsideAlignHB()
 * Date:     EPN, Fri Sep 30 10:12:51 2011
 *
 * Purpose:  Run the outside CYK algorithm on a target sequence.
 *           HMM banded version. See cm_CYKOutsideAlign() for
 *           the non-banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_OutsideAlignHB() but calculates
 *           beta[v][j][d]: log probability of the most likely parse
 *           that emits 1..i-1 and j+1..L and passes through v at j,d
 *           (where i = j-d+1) instead of the log of the summed
 *           probability of all such parses. This means max operations
 *           are used instead of logsums.
 *
 *           This function complements cm_CYKInsideAlignHB() but is
 *           mainly useful for testing and reference. It can be used
 *           with do_check=TRUE to verify that the implementation of
 *           CYKInsideHB and CYKOutsideHB are consistent.  Because the
 *           structure of CYKInsideHB and InsideHB, and CYKOutsideHB
 *           and OutsideHB are so similar and the CYK variants are
 *           easier to debug (because only the optimal parsetree is
 *           considered instead of all possible parsetrees) this
 *           function can be useful for finding bugs in OutsideHB.  It
 *           is currently not hooked up to any of the main Infernal
 *           programs.
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence
 *           L         - length of the dsq to align
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check  - TRUE to attempt to check
 *           mx        - the dp matrix, only cells within bands in cp9b will be valid
 *           ins_mx    - the dp matrix from the Inside run calculation (required)
 *           ret_sc    - RETURN: log P(S|M)/P(S|R), as a bit score, this is from ins_mx IF local
 *                       ends are on (see *** comment towards end of function).
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted, ret_sc is not valid.
 */
int
cm_CYKOutsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_check,
		     CM_HB_MX *mx, CM_HB_MX *ins_mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    sc;		       /* a temporary score */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      emitmode;           /* EMITLEFT, EMITRIGHT, EMITPAIR, EMITNONE, for state y */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check */
  int      fail1_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 1*/
  int      fail2_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 2*/
  int      fail3_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 3*/
  int      n;                  /* counter over nodes, used only if do_check = TRUE */
  int      num_split_states;   /* temp variable used only if do_check = TRUE */
  float    diff;               /* temp variable used only if do_check = TRUE */
  int      vmax;               /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */
  int     *optseen = NULL;     /* [1..i..W] TRUE is residue i is accounted for in optimal parse */

  /* band related variables */
  int      dp_v;               /* d index for state v in alpha w/mem eff bands */
  int      dp_y;               /* d index for state y in alpha w/mem eff bands */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      Lp;                 /* L index also changes depending on state */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      kmin, kmax;         /* temporary minimum/maximum allowed k */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* the DP matrices */
  float ***beta  = mx->dp;     /* pointer to the Oustide DP mx */
  float ***alpha = ins_mx->dp; /* pointer to the Inside DP mx (already calc'ed and passed in) */

  /* ptrs to cp9b info, for convenience */
  int     *jmin  = cm->cp9b->jmin;
  int     *jmax  = cm->cp9b->jmax;
  int    **hdmin = cm->cp9b->hdmin;
  int    **hdmax = cm->cp9b->hdmax;

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo(cm, mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(beta[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (jmin[0] > L || jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, jmin[0], jmax[0]);
  jp_0 = L - jmin[0];
  if (hdmin[0][jp_0] > L || hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, hdmin[0][jp_0], hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];
  /* set the offset banded cell corresponding to beta[0][L][L] to 0., all parses must end there */
  beta[0][jp_0][Lp_0] = 0.;

  /* If we can do a local begin into v, overwrite IMPOSSIBLE with the local begin score. */
  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (v = 1; v < cm->M; v++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[v])) {
	if((L >= jmin[v]) && (L <= jmax[v])) {
	  jp_v = L - jmin[v];
	  if((L >= hdmin[v][jp_v]) && L <= hdmax[v][jp_v]) {
	    Lp = L - hdmin[v][jp_v];
	    beta[v][jp_v][Lp] = cm->beginsc[v];
	  }
	}
	  }
	}
  }
  /* done allocation/initialization */

  /* Recursion: main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	  y = cm->plast[v];	/* the parent bifurcation    */
	  z = cm->cnum[y];	/* the other (right) S state */
	  for (j = jmax[v]; j >= jmin[v]; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	i = j-d+1;
	for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	  dp_v = d - hdmin[v][jp_v];
	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 8 inequalities (some may be redundant):
	   * NOTE: these are different from those in Inside() (for one thing, v and y
	   *       (BEGL_S and BIF_B here respectively) are switched relative to Inside.
	   *
	   * (1) k <= jmax[y] - j;
	   * (2) k >= jmin[y] - j;
	   * (3) k <= jmax[z] - j;
	   * (4) k >= jmin[z] - j;
	   *     1 and 2 guarantee (j+k) is within state y's j band
	   *     3 and 4 guarantee (j+k) is within state z's j band
	   *
	   * (5) k >= hdmin[y][j-jmin[y]+k] - d;
	   * (6) k <= hdmax[y][j-jmin[y]+k] - d;
	   *     5 and 6 guarantee k+d is within y's j=(j+k), d band
	   *
	   * (7) k >= hdmin[z][j-jmin[z]+k];
	   * (8) k <= hdmax[z][j-jmin[z]+k];
	   *     5 and 6 guarantee k is within state z's j=(j+k) d band
	   */
	  kmin = ESL_MAX(jmin[y], jmin[z]) - j;
	  kmax = ESL_MIN(jmax[y], jmax[z]) - j;
	  /* kmin and kmax satisfy inequalities (1-4) */
	  /* RHS of inequalities 5-8 are dependent on k, so we check
	   * for these within the next for loop. */
	  for(k = kmin; k <= kmax; k++) {
	    if(k < (hdmin[y][jp_y+k] - d) || k > (hdmax[y][jp_y+k] - d)) continue;
	    /* above line continues if inequality 5 or 6 is violated */
	    if(k < (hdmin[z][jp_z+k])     || k > (hdmax[z][jp_z+k]))     continue;
	    /* above line continues if inequality 7 or 8 is violated */

	    /* if we get here for current k, all 8 inequalities have been satisified
	     * so we know the cells corresponding to the platonic
	     * matrix cells alpha[v][j][d], alpha[y][j+k][d+k], and
	     * alpha[z][j+k][k] are all within the bands. These
	     * cells correspond to beta[v][jp_v][dp_v],
	     * beta[y][jp_y+k][d-hdmin[y][jp_y+k]+k],
	     * and alpha[z][jp_z][k-hdmin[z][jp_z+k]];
	     */
	    kp_z = k-hdmin[z][jp_z+k];
	    dp_y = d-hdmin[y][jp_y+k];
	    beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y+k][dp_y+k] + alpha[z][jp_z+k][kp_z]));
	  }
	}
	  }
	} /* end of 'if (cm->stid[v] == BEGL_S */
	else if (cm->stid[v] == BEGR_S) {
	  y = cm->plast[v];	  /* the parent bifurcation    */
	  z = cm->cfirst[y];  /* the other (left) S state  */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  for (j = jx; j >= jn; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	i = j-d+1;

	dn = ESL_MAX(hdmin[v][jp_v], j-jmax[z]);
	dx = ESL_MIN(hdmax[v][jp_v], jp_z);
	/* above makes sure that j,d are valid for state z: (jmin[z] + d) >= j >= (jmax[z] + d) */
	for (d = dx; d >= dn; d--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 4 inequalities (some may be redundant):
	   * NOTE: these are different from those in Inside() (for one thing, v and y
	   *       (BEGR_S and BIF_B here respectively) are switched relative to Inside.
	   *
	   * (1) k >= hdmin[y][j-jmin[y]] - d;
	   * (2) k <= hdmax[y][j-jmin[y]] - d;
	   *     1 and 2 guarantee (d+k) is within state y's j=(j) d band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]-d];
	   * (4) k <= hdmax[z][j-jmin[z]-d];
	   *     3 and 4 guarantee k is within z's j=(j-d) d band
	   *
	   */
	  kmin = ESL_MAX((hdmin[y][jp_y]-d), (hdmin[z][jp_z-d]));
	  kmax = ESL_MIN((hdmax[y][jp_y]-d), (hdmax[z][jp_z-d]));
	  /* kmin and kmax satisfy inequalities (1-4) */
	  for(k = kmin; k <= kmax; k++) {
	    /* for current k, all 4 inequalities have been satisified
	     * so we know the cells corresponding to the platonic
	     * matrix cells beta[v][j][d], beta[y][j][d+k], and
	     * alpha[z][j-d][k] are all within the bands. These
	     * cells correspond to beta[v][jp_v][dp_v],
	     * beta[y][jp_y+k][d-hdmin[y][jp_y]+k],
	     * and alpha[z][jp_z-d][k-hdmin[z][jp_z-d]];
	     */
	    kp_z = k-hdmin[z][jp_z-d];
	    dp_y = d-hdmin[y][jp_y];
	    beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y+k]
								+ alpha[z][jp_z-d][kp_z]));
	  }
	}
	  }
	} /* end of 'else if (cm->stid[v] == BEGR_S */
	else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	  /* ILs and IRs can self transit, this means that beta[v][j][d] must be fully calculated
	   * before beta[v][j][d+1] can be started to be calculated, forcing the following nesting order:
	   * for j { for d { for y { } } }
	   * for non-self-transitioners, we can do a more efficient nesting order (see below)
	   */
	  for (j = jmax[v]; j >= jmin[v]; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	  i = j-d+1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	    voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	    /* Note: this looks like it can be optimized, I tried but my 'optimization' slowed the code, so I reverted [EPN] */
	    switch(cm->sttype[y]) {
	    case MP_st:
	      if (j == L || d == j) continue; /* boundary condition */
	      if ((j+1) < jmin[y] || (j+1) > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+2) < hdmin[y][(jp_y+1)] || (d+2) > hdmax[y][(jp_y+1)]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y+1][dp_y+2] is a valid alpha cell
	       * corresponding to alpha[y][j+1][d+2] in the platonic matrix.
		   */
	      dp_y = d - hdmin[y][jp_y+1];  /* d index for state y */
	      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y+1][dp_y+2]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case ML_st:
	    case IL_st:
	      if (d == j) continue;	/* boundary condition (note when j=0, d=0)*/
	      if (j < jmin[y] || j > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+1) < hdmin[y][jp_y] || (d+1) > hdmax[y][jp_y]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y][dp_y+1] is a valid alpha cell
	       * corresponding to alpha[y][j][d+1] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
	      escore = esc_vAA[y][dsq[i-1]];
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y+1]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case MR_st:
	    case IR_st:
	      if (j == L) continue;
	      if ((j+1) < jmin[y] || (j+1) > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+1) < hdmin[y][(jp_y+1)] || (d+1) > hdmax[y][(jp_y+1)]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y+1][dp_y+1] is a valid alpha cell
	       * corresponding to alpha[y][j+1][d+1] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][(jp_y+1)];  /* d index for state y */
	      escore = esc_vAA[y][dsq[j+1]];
	      /*printf("j: %d | jmin[y]: %d | jmax[y]: %d | jp_v: %d | dp_v: %d | jp_y: %d | dp_y: %d\n", j, jmin[y], jmax[y], jp_v, dp_v, jp_y, dp_y);*/
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y+1][dp_y+1]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case S_st:
	    case E_st:
	    case D_st:
	      if (j < jmin[y] || j > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if (d < hdmin[y][jp_y] || d > hdmax[y][jp_y]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y][dp_y] is a valid alpha cell
	       * corresponding to alpha[y][j][d] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y] + cm->tsc[y][voffset]));
	      break;
	    } /* end of switch(cm->sttype[y] */
	  } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	  if (beta[v][jp_v][dp_v] < IMPOSSIBLE) beta[v][jp_v][dp_v] = IMPOSSIBLE;
	} /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	  } /* end loop over jp. We know beta for this whole state */
	} /* end of 'else if cm->sttype[v] == IL_st || cm->sttype[v] == IR_st' */
	else { /* state v is not BEGL_S, BEGL_R IL nor IR (must be ML, MP, MR, D, S, B or E) */
	  /* ML, MP, MR, D, S, B, E states cannot self transit, this means that all cells
	   * in beta[v] are independent of each other, only depending on beta[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
	sdr = StateRightDelta(cm->sttype[y]);
	sd  = StateDelta(cm->sttype[y]);
	emitmode = Emitmode(cm->sttype[y]);
	/* determine min j (jn) and max j (jx) that are valid for v and y */
	jn = ESL_MAX(jmin[v], jmin[y]-sdr);
	jx = ESL_MIN(jmax[v], jmax[y]-sdr);
	for (j = jx; j >= jn; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j+sdr >= jmin[y] && j+sdr <= jmax[y]));

	  /* determine min d (dn) and max d (dx) that are valid for v and y and j */
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y + sdr] - sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y + sdr] - sd);
	  dp_v = dx - hdmin[v][jp_v];
	  dp_y = dx - hdmin[y][jp_y + sdr];
	  i    = j-dx+1;

	  /* for each emit mode, update beta[v][jp_v][dp_v] for all valid d = dp_v */
	  switch(emitmode) {
	  case EMITPAIR:  /* MP_st */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--, i++) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITLEFT:  /* ML_st, IL_st */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--, i++) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      escore = esc_vAA[y][dsq[i-1]];
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITRIGHT:  /* MR_st, IR_st */
	    escore = esc_vAA[y][dsq[j+1]]; /* not dependent on i */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITNONE:  /* D_st, S_st, E_st*/
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      beta[v][jp_v][dp_v] = ESL_MAX(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset]));
	    }
	    break;
	  } /* end of switch(emitmode) */
	} /* end of for j = jx; j >= jn; j-- */
	  } /* end of for y = plast[v]... */
	} /* ends else entered for non-BEGL_S/BEGR_S/IL/IR states*/
	/* we're done calculating deck v for everything but local begins */

	/* deal with local alignment end transitions v->EL (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sdr      = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	  sd       = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	  emitmode = Emitmode(cm->sttype[v]);        /* note emitmode is for state v */

	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	jp_v =  j - jmin[v];
	dn   = hdmin[v][jp_v + sdr] - sd;
	dx   = hdmax[v][jp_v + sdr] - sd;
	i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	switch (emitmode) {
	case EMITPAIR:
	  for (d = dn; d <= dx; d++, dp_v++, i--) {
	    escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;
	case EMITLEFT:
	  for (d = dn; d <= dx; d++, dp_v++, i--) {
	    escore = esc_vAA[v][dsq[i-1]];
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;

	case EMITRIGHT:
	  escore = esc_vAA[v][dsq[j+1]];
	  for (d = dn; d <= dx; d++, dp_v++) {
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;

	case EMITNONE:
	  for (d = dn; d <= dx; d++, dp_v++) {
	    beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]));
	  }
	  break;
	}
	  }
	}
  } /* end loop over decks v. */

  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) /* careful w/ boundary here */
	beta[cm->M][j][d] = ESL_MAX(beta[cm->M][j][d], (beta[cm->M][j][d+1] + cm->el_selfsc));
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.stdocykhbmx", "w");   cm_hb_mx_Dump(fp1, mx); fclose(fp1);
#endif

  fail1_flag = FALSE;
  fail2_flag = FALSE;
  fail3_flag = FALSE;
  printf("DO CHECK: %d\n", do_check);
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. We assume the Inside CYK parse score
	 * (optsc) is the optimal score, so for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 *
	 * Further, we know that each residue must be emitted by a state
	 * in the optimal parse. So as we do the above check, we determine
	 * when we're in a cell that may be involved in the optimal parse
	 * (the sum of the Inside and Outside scores are equal to the
	 * optimal parse score), if that cell corresponds to a left
	 * emitter emitting position i, we know an emitted i has been
	 * observed in an optimal parse and set optseen[i] to TRUE.
	 * Likewise, if that cell corresponds to a right emitter emitting
	 * position j, we update optseen[j] to TRUE. At the end of the
	 * check optseen[i] should be TRUE for all i in the range
	 * [1..L].
	 *
	 * Note that we don't ensure that all of our presumed optimal
	 * cells make up a valid parse, so it is possible we could pass
	 * this check even if the Inside and Outside matrices are
	 * inconsistent (i.e. there's a bug in the implementation of one
	 * and or the other) but that should be extremely unlikely.  If we
	 * do this test many times for many different models and pass, we
	 * should be confident we have consistent implementations.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 *
	 * Another test we could do but do not is to determine the CYK
	 * parse by tracing back the CYK Inside matrix, then ensure that
	 * for each cell in that parse alpha[v][j][d]+beta[v][j][d] ==
	 * optsc.
	 */
	ESL_ALLOC(optseen, sizeof(int) * (L+1));
	esl_vec_ISet(optseen, L+1, FALSE);
	vmax = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  jn = (v == cm->M) ? 1 : jmin[v];
	  jx = (v == cm->M) ? L : jmax[v];
	  for(j = jn; j <= jx; j++) {
	jp_v = (v == cm->M) ? j : j - jmin[v];
	dn   = (v == cm->M) ? 0 : hdmin[v][jp_v];
	dx   = (v == cm->M) ? j : hdmax[v][jp_v];
	for(d = dn; d <= dx; d++) {
	  dp_v = (v == cm->M) ? d : d - hdmin[v][jp_v];
	  sc  = (alpha[v][jp_v][dp_v] + beta[v][jp_v][dp_v]) - alpha[0][jp_0][Lp_0];
	  if(sc > tol) {
	    printf("Check 1 failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, alpha[v][jp_v][dp_v], beta[v][jp_v][dp_v], alpha[v][jp_v][dp_v] + beta[v][jp_v][dp_v], alpha[0][jp_0][Lp_0]);
	    fail1_flag = TRUE;
	  }
	  if(fabs(sc) < tol) { /* this cell is involved in a parse with the optimal score */
	    i  = j-d+1;
	    if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st || (cm->sttype[v] == EL_st && d >0)) {
	      /* i is accounted for by a parse with an optimal score */
	      optseen[i] = TRUE;
	      /*printf("\tResidue %4d possibly accounted for by Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);*/
	    }
	    if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	      /* j is accounted for by a parse with an optimal score */
	      optseen[j] = TRUE;
	      /*printf("\tResidue %4d possibly accounted for by Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);*/
	    }
	  }
	}
	  }
	}
	for(j = 1; j <= L; j++) {
	  if(optseen[j] == FALSE) {
	printf("Check 2 failure: residue %d not emitted in the optimal parsetree\n", j);
	fail2_flag = TRUE;
	  }
	}
	free(optseen);
  }
  /* Another test that we can only do if local ends are OFF */
  if(do_check && (!(cm->flags & CMH_LOCAL_END))) {
	/* Local ends make the following test invalid because it is not true that
	 * exactly 1 state in each node's split set must be visited in each parse.
	 *
	 * Determine P(pi, S|M) / P(S|R) (probability of the sequence and most likely parse
	 * tree pi given the model)
	 * using both the Outside (beta) and Inside (alpha) matrices,
	 * and ensure they're consistent with P(pi, S|M) / P(S|R) from the Inside calculation.
	 * For all v in each split set: Max_v [ Max_j,(d<=j) ( alpha[v][j][d] * beta[v][j][d] ) ]
	 *                                                = P(pi, S|M) / P(S|R)
	 */
	for(n = 0; n < cm->nodes; n++) {
	  sc = IMPOSSIBLE;
	  num_split_states = SplitStatesInNode(cm->ndtype[n]);
	  for(v = cm->nodemap[n]; v < cm->nodemap[n] + num_split_states; v++) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	    sc = ESL_MAX(sc, (alpha[v][jp_v][dp_v] + beta[v][jp_v][dp_v]));
	  }
	}
	  }
	  /*printf("checking node: %d | sc: %.6f\n", n, sc);*/
	  diff = sc - alpha[0][jp_0][Lp_0];
	  if(diff > 0.01 || diff < -0.01) {
	fail3_flag = TRUE;
	printf("ERROR: node %d P(S|M): %.5f inconsistent with Inside P(S|M): %.5f (diff: %.5f)\n",
	       n, sc, alpha[0][jp_0][Lp_0], diff);
	  }
	}
  }

  /* Finally, calculate the optimal score, but this only works if
   * we're not in local mode:
   *
   * If local ends are off, we know the optimal parse MUST visit each END_E state,
   * we pick final END_E state state cm->M-1 (though any END_E could be used here):
   *
   * Max_j=0 to L (alpha[M-1][j][0] * beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * Note: alpha[M-1][j][0] = 0.0 for all j
   *       because all parse subtrees rooted at an END_E must have d=0, (2^0 = 1.0)
   * therefore:
   * Max_j=0 to L (beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * *** If local ends are on, each parse MUST visit either each END_E state with d=0
   * or the EL state but d can vary, so we can't use this test (believe me I tried
   * to get a similar test working, but I'm convinced you need alpha to get P(S|M)
   * in local mode).
   */
  if(!(cm->flags & CMH_LOCAL_END)) {
	sc = IMPOSSIBLE;
	v = cm->M-1;
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  assert(hdmin[v][jp_v] == 0);
	  sc = ESL_MAX(sc, (beta[v][jp_v][0]));
	  /* printf("\talpha[%3d][%3d][%3d]: %5.2f | beta[%3d][%3d][%3d]: %5.2f\n", (cm->M-1), (j), 0, alpha[(cm->M-1)][j][0], (cm->M-1), (j), 0, beta[(cm->M-1)][j][0]);*/
	}
  }
  else { /* return sc = P(S|M) / P(S|R) from Inside() */
	sc = alpha[0][jp_0][Lp_0];
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp; fp = fopen("tmp.std_ocykhbmx", "w"); cm_hb_mx_Dump(fp, mx); fclose(fp);
#endif

  if(do_check) {
	if     (fail1_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside HB check1 FAILED.");
	else if(fail2_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside HB check2 FAILED.");
	else if(fail3_flag) ESL_FAIL(eslFAIL, errbuf, "CYK Inside/Outside HB check3 FAILED.");
	ESL_DPRINTF1(("SUCCESS! CYK Inside/Outside HB checks PASSED.\n"));
  }

  if(!(cm->flags & CMH_LOCAL_END)) ESL_DPRINTF1(("\tcm_CYKOutsideAlignHB() sc : %f\n", sc));
  else                             ESL_DPRINTF1(("\tcm_CYKOutsideAlignHB() sc : %f (LOCAL mode; sc is from Inside)\n", sc));

  if(ret_sc != NULL) *ret_sc = sc;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_OutsideAlign()
 * Date:     EPN, Mon Nov 19 07:00:37 2007
 *
 * Purpose:  Run the outside algorithm on a target sequence.
 *           Non-banded version. See cm_OutsideAlignHB() for
 *           the HMM banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_CYKOutsideAlign() but calculates
 *           beta[v][j][d]: log of the summed probability of all
 *           parsetrees that emits 1..i-1 and j+1..L and pass through
 *           v at j,d (where i = j-d+1) instead of the log of the
 *           probability of the most likely (CYK) parse. This means
 *           logsum operations are used instead of max operations.
 *
 *           For debugging this function, the cm_CYKOutsideAlign() can
 *           be useful, because it has a very similar organization but
 *           is easier to debug because only the most likely parsetree
 *           is considered. cm_CYKOutsideAlign() also allows a more
 *           stringent test for the consistency of the CYKInside and
 *           CYKOutside matrices.
 *
 *           If <do_check> is TRUE (and the CM is not in local mode)
 *           we check that the outside matrix values are consistent
 *           with the inside matrix values (in ins_mx).  This check is
 *           described in comments towards the end of the function.
 *
 *           Note: renamed from FastOutsideAlign() [EPN, Wed Sep 14 06:13:53 2011].
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence
 *           L         - length of the dsq to align
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check  - TRUE to attempt to check
 *           mx        - the dp matrix, grown and filled here
 *           ins_mx    - the pre-filled dp matrix from the Inside run calculation (required)
 *           ret_sc    - RETURN: log P(S|M)/P(S|R), as a bit score, this is from ins_mx IF local
 *                       ends are on (see *** comment towards end of function).
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted, ret_sc is not valid.

 */
int
cm_OutsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_check,
		CM_MX *mx, CM_MX *ins_mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float    sc;     	       /* a temporary score */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check==TRUE */
  int      n;                  /* counter over nodes, used only if do_check = TRUE */
  int      num_split_states;   /* temp variable used only if do_check = TRUE */
  float    diff;               /* temp variable used only if do_check = TRUE */
  int      fail_flag = FALSE;  /* set to TRUE if do_check and we see a problem */

  /* the DP matrices */
  float ***beta  = mx->dp;     /* pointer to the Oustide DP mx */
  float ***alpha = ins_mx->dp; /* pointer to the Inside DP mx (already calc'ed and passed in) */

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* grow the matrix based on the current sequence */
  if((status = cm_mx_GrowTo(cm, mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(beta[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* now set beta[0][L][L] to 0., all parses must end there */
  beta[0][L][L] = 0.;

  /* initialize local begin cells for emitting full seq (j==L && d == L) */
  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (v = 1; v < cm->M; v++)
	  beta[v][L][L] = cm->beginsc[v];
  }

  /* Main recursion */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	sd  = StateDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);

	if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	  y = cm->plast[v];	/* the parent bifurcation    */
	  z = cm->cnum[y];	/* the other (right) S state */
	  for(j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= (L-j); k++) {
	    beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j+k][d+k] + alpha[z][j+k][k]));
	  }
	}
	  }
	} /* end of 'if (cm->stid[v] == BEGL_S */
	else if (cm->stid[v] == BEGR_S) {
	  y = cm->plast[v];	  /* the parent bifurcation    */
	  z = cm->cfirst[y];  /* the other (left) S state  */
	  for(j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= (j-d); k++) {
 	    beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j][d+k] + alpha[z][j-d][k]));
	  }
	}
	  }
	} /* end of 'else if (cm->stid[v] == BEGR_S */
	else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	  for (j = L; j >= 0; j--) {
	i = 1;
	for (d = j; d >= 0; d--, i++) {
	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	    voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
	    sd  = StateDelta(cm->sttype[y]);
	    sdr = StateRightDelta(cm->sttype[y]);
	    switch(cm->sttype[y]) {
	      case MP_st:
		if (j == L || d == j) continue; /* boundary condition */
		escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case ML_st:
	      case IL_st:
		if (d == j) continue;	/* boundary condition (note when j=0, d=0*/
		escore = esc_vAA[y][dsq[i-1]];
		beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case MR_st:
	      case IR_st:
		if (j == L) continue;
		escore = esc_vAA[y][dsq[j+1]];
		beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore));
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		beta[v][j][d] = FLogsum(beta[v][j][d], (beta[y][j+sdr][d+sd] + cm->tsc[y][voffset]));
		break;
	    } /* end of switch(cm->sttype[y] */
	  } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	  if (beta[v][j][d] < IMPOSSIBLE) beta[v][j][d] = IMPOSSIBLE;
	} /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	  } /* end loop over j. We know beta for this whole state */
	} /* end of 'else if cm->sttype[v] != BEGL_S, BEGR_S */
	/* we're done calculating deck v for everything but local begins */

	/* deal with local alignment end transitions v->EL (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sdr = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	  sd  = StateDelta(cm->sttype[v]);      /* note sd  is for state v */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  i = j-d+1;
	  switch (cm->sttype[v]) {
	  case MP_st:
	    if (j == L || d == j) continue; /* boundary condition */
	    escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case ML_st:
	  case IL_st:
	    if (d == j) continue;
	    escore = esc_vAA[v][dsq[i-1]];
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case MR_st:
	  case IR_st:
	    if (j == L) continue;
	    escore = esc_vAA[v][dsq[j+1]];
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]
							    + escore));
	    break;
	  case S_st:
	  case D_st:
	  case B_st:
	  case E_st:
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][j+sdr][d+sd] + cm->endsc[v]));
	    break;
	  }
	}
	  }
	}
  }
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) /* careful w/ boundary here */
	beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[cm->M][j][d+1] + cm->el_selfsc));
	}
  }

  if(do_check && (!(cm->flags & CMH_LOCAL_END))) {
	/* Local ends make the following test invalid because it is not true that
	 * exactly 1 state in each node's split set must be visited in each parse.
	 *
	 * Determine P(S|M) / P(S|R) (probability of the sequence given the model)
	 * using both the Outside (beta) and Inside (alpha) matrices,
	 * and ensure they're consistent with P(S|M) / P(S|R) from the Inside calculation.
	 * For all v in each split set: Sum_v [ Sum_j,(d<=j) ( alpha[v][j][d] * beta[v][j][d] ) ]
	 *                                                = P(S|M) / P(S|R)
	 */
	for(n = 0; n < cm->nodes; n++) {
	  sc = IMPOSSIBLE;
	  num_split_states = SplitStatesInNode(cm->ndtype[n]);
	  for(v = cm->nodemap[n]; v < cm->nodemap[n] + num_split_states; v++) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    sc = FLogsum(sc, (alpha[v][j][d] + beta[v][j][d]));
	  }
	}
	  }
	  /*printf("checking node: %d | sc: %.6f\n", n, sc);*/
	  diff = sc - alpha[0][L][L];
	  if(diff > 0.01 || diff < -0.01) {
	fail_flag = TRUE;
	printf("ERROR: node %d P(S|M): %.5f inconsistent with Inside P(S|M): %.5f (diff: %.5f)\n",
	       n, sc, alpha[0][L][L], diff);
	  }
	}
	if(! fail_flag) {
	  ESL_DPRINTF1(("SUCCESS! all nodes passed error check (cm_OutsideAlign())\n"));
	}
  }

  /* Finally, calculate the optimal score, but this only works if
   * we're not in local mode:
   *
   * IF local ends are off, we know each parse MUST visit each END_E state,
   * we pick final END_E state state cm->M-1 (though any END_E could be used here):
   *
   * Sum_j=0 to L (alpha[M-1][j][0] * beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * Note: alpha[M-1][j][0] = 0.0 for all j
   *       because all parse subtrees rooted at an END_E must have d=0, (2^0 = 1.0)
   * therefore:
   * Sum_j=0 to L (beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * *** If local ends are on, each parse MUST visit either each END_E state with d=0
   * or the EL state but d can vary, so we can't use this test (believe me I tried
   * to get a similar test working, but I'm convinced you need alpha to get P(S|M)
   * in local mode).
   */
  if(!(cm->flags & CMH_LOCAL_END)) {
	sc = IMPOSSIBLE;
	v = cm->M-1;
	for (j = 0; j <= L; j++) {
	  sc = FLogsum(sc, (beta[v][j][0]));
	  /*printf("\talpha[%3d][%3d][%3d]: %5.2f | beta[%3d][%3d][%3d]: %5.2f\n", (cm->M-1), (j), 0, alpha[(cm->M-1)][j][0], (cm->M-1), (j), 0, beta[(cm->M-1)][j][0]);*/
	}
  }
  else { /* sc = P(S|M) / P(S|R) from Inside() */
	sc = alpha[0][L][L];
  }

  if(fail_flag) ESL_FAIL(eslFAIL, errbuf, "Not all nodes passed posterior check.");

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_omx", "w");   cm_mx_Dump(fp1, mx); fclose(fp1);
#endif

  if(!(cm->flags & CMH_LOCAL_END)) ESL_DPRINTF1(("\tcm_OutsideAlign() sc : %f\n", sc));
  else                             ESL_DPRINTF1(("\tcm_OutsideAlign() sc : %f (LOCAL mode; sc is from Inside)\n", sc));

  if(ret_sc != NULL) *ret_sc = sc;

  return eslOK;
}

/* Function: cm_OutsideAlignHB()
 * Date:     EPN, Thu Nov  8 18:40:05 2007
 *
 * Purpose:  Run the outside algorithm on a target sequence.
 *           HMM banded version. See cm_OutsideAlign() for
 *           the non-banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_CYKOutsideAlignHB() but calculates
 *           beta[v][j][d]: log of the summed probability of all
 *           parsetrees that emits 1..i-1 and j+1..L and pass through
 *           v at j,d (where i = j-d+1) instead of the log of the
 *           probability of the most likely (CYK) parse. This means
 *           logsum operations are used instead of max operations.
 *
 *           For debugging this function, the cm_CYKOutsideAlign() can
 *           be useful, because it has a very similar organization but
 *           is easier to debug because only the most likely parsetree
 *           is considered. cm_CYKOutsideAlign() also allows a more
 *           stringent test for the consistency of the CYKInside and
 *           CYKOutside matrices.
  *
 *           The DP recursion has been 'optimized' for all state types
 *           except IL, IR, BEGL_S, BEGR_S. The main optimization
 *           is a change in nesting order of the for loops:
 *           optimized order:     for v { for y { for j { for d {}}}}
 *           non-optimized order: for v { for j { for d { for y {}}}}
 *
 *           ILs and IRs are not optimized because they can self
 *           transit so mx[v][j][d] must be fully calc'ed before
 *           mx[v][j][d+1] can be calced. BEGL_S and BEGR_S are not
 *           optimized b/c they require searching for optimal d and k,
 *           which complicates the enforcement of the bands and makes
 *           this optimization strategy impossible.
 *
 *           If <do_check> is TRUE (and the CM is not in local mode)
 *           we check that the outside matrix values are consistent
 *           with the inside matrix values (in ins_mx).  This check is
 *           described in comments towards the end of the function.
 *
 *           Note: renamed from FastOutsideAlignHB() [EPN, Wed Sep 14 06:13:53 2011].
 *
 * Args:     cm        - the model
 *           errbuf    - char buffer for reporting errors
 *           dsq       - the digitized sequence
 *           L         - length of the dsq to align
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check  - TRUE to attempt to check
 *           mx        - the dp matrix, only cells within bands in cp9b will be valid
 *           ins_mx    - the dp matrix from the Inside run calculation (required)
 *           ret_sc    - RETURN: log P(S|M)/P(S|R), as a bit score, this is from ins_mx IF local
 *                       ends are on (see *** comment towards end of function).
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_HB_MX size exceeds <size_limit>
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted, ret_sc is not valid.
 */
int
cm_OutsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, int do_check,
		  CM_HB_MX *mx, CM_HB_MX *ins_mx, float *ret_sc)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    sc;		       /* a temporary score */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      emitmode;           /* EMITLEFT, EMITRIGHT, EMITPAIR, EMITNONE, for state y */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check */
  int      fail_flag = FALSE;  /* set to TRUE if do_check and we see a problem */
  int      n;                  /* counter over nodes, used only if do_check = TRUE */
  int      num_split_states;   /* temp variable used only if do_check = TRUE */
  float    diff;               /* temp variable used only if do_check = TRUE */

  /* band related variables */
  int      dp_v;               /* d index for state v in alpha w/mem eff bands */
  int      dp_y;               /* d index for state y in alpha w/mem eff bands */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      Lp;                 /* L index also changes depending on state */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      kmin, kmax;         /* temporary minimum/maximum allowed k */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* the DP matrices */
  float ***beta  = mx->dp;     /* pointer to the Oustide DP mx */
  float ***alpha = ins_mx->dp; /* pointer to the Inside DP mx (already calc'ed and passed in) */

  /* ptrs to cp9b info, for convenience */
  int     *jmin  = cm->cp9b->jmin;
  int     *jmax  = cm->cp9b->jmax;
  int    **hdmin = cm->cp9b->hdmin;
  int    **hdmax = cm->cp9b->hdmax;

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo(cm, mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(beta[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (jmin[0] > L || jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, jmin[0], jmax[0]);
  jp_0 = L - jmin[0];
  if (hdmin[0][jp_0] > L || hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, hdmin[0][jp_0], hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];
  /* set the offset banded cell corresponding to beta[0][L][L] to 0., all parses must end there */
  beta[0][jp_0][Lp_0] = 0.;

  /* If we can do a local begin into v, overwrite IMPOSSIBLE with the local begin score. */
  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (v = 1; v < cm->M; v++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[v])) {
	if((L >= jmin[v]) && (L <= jmax[v])) {
	  jp_v = L - jmin[v];
	  if((L >= hdmin[v][jp_v]) && L <= hdmax[v][jp_v]) {
	    Lp = L - hdmin[v][jp_v];
	    beta[v][jp_v][Lp] = cm->beginsc[v];
	  }
	}
	  }
	}
  }
  /* done allocation/initialization */

  /* Recursion: main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	  y = cm->plast[v];	/* the parent bifurcation    */
	  z = cm->cnum[y];	/* the other (right) S state */
	  for (j = jmax[v]; j >= jmin[v]; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	i = j-d+1;
	for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	  dp_v = d - hdmin[v][jp_v];
	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 8 inequalities (some may be redundant):
	   * NOTE: these are different from those in Inside() (for one thing, v and y
	   *       (BEGL_S and BIF_B here respectively) are switched relative to Inside.
	   *
	   * (1) k <= jmax[y] - j;
	   * (2) k >= jmin[y] - j;
	   * (3) k <= jmax[z] - j;
	   * (4) k >= jmin[z] - j;
	   *     1 and 2 guarantee (j+k) is within state y's j band
	   *     3 and 4 guarantee (j+k) is within state z's j band
	   *
	   * (5) k >= hdmin[y][j-jmin[y]+k] - d;
	   * (6) k <= hdmax[y][j-jmin[y]+k] - d;
	   *     5 and 6 guarantee k+d is within y's j=(j+k), d band
	   *
	   * (7) k >= hdmin[z][j-jmin[z]+k];
	   * (8) k <= hdmax[z][j-jmin[z]+k];
	   *     5 and 6 guarantee k is within state z's j=(j+k) d band
	   */
	  kmin = ESL_MAX(jmin[y], jmin[z]) - j;
	  kmax = ESL_MIN(jmax[y], jmax[z]) - j;
	  /* kmin and kmax satisfy inequalities (1-4) */
	  /* RHS of inequalities 5-8 are dependent on k, so we check
	   * for these within the next for loop. */
	  for(k = kmin; k <= kmax; k++) {
	    if(k < (hdmin[y][jp_y+k] - d) || k > (hdmax[y][jp_y+k] - d)) continue;
	    /* above line continues if inequality 5 or 6 is violated */
	    if(k < (hdmin[z][jp_z+k])     || k > (hdmax[z][jp_z+k]))     continue;
	    /* above line continues if inequality 7 or 8 is violated */

	    /* if we get here for current k, all 8 inequalities have been satisified
	     * so we know the cells corresponding to the platonic
	     * matrix cells alpha[v][j][d], alpha[y][j+k][d+k], and
	     * alpha[z][j+k][k] are all within the bands. These
	     * cells correspond to beta[v][jp_v][dp_v],
	     * beta[y][jp_y+k][d-hdmin[y][jp_y+k]+k],
	     * and alpha[z][jp_z][k-hdmin[z][jp_z+k]];
	     */
	    kp_z = k-hdmin[z][jp_z+k];
	    dp_y = d-hdmin[y][jp_y+k];
	    beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y+k][dp_y+k] + alpha[z][jp_z+k][kp_z]));
	  }
	}
	  }
	} /* end of 'if (cm->stid[v] == BEGL_S */
	else if (cm->stid[v] == BEGR_S) {
	  y = cm->plast[v];	  /* the parent bifurcation    */
	  z = cm->cfirst[y];  /* the other (left) S state  */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  for (j = jx; j >= jn; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	i = j-d+1;

	dn = ESL_MAX(hdmin[v][jp_v], j-jmax[z]);
	dx = ESL_MIN(hdmax[v][jp_v], jp_z);
	/* above makes sure that j,d are valid for state z: (jmin[z] + d) >= j >= (jmax[z] + d) */
	for (d = dx; d >= dn; d--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 4 inequalities (some may be redundant):
	   * NOTE: these are different from those in Inside() (for one thing, v and y
	   *       (BEGR_S and BIF_B here respectively) are switched relative to Inside.
	   *
	   * (1) k >= hdmin[y][j-jmin[y]] - d;
	   * (2) k <= hdmax[y][j-jmin[y]] - d;
	   *     1 and 2 guarantee (d+k) is within state y's j=(j) d band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]-d];
	   * (4) k <= hdmax[z][j-jmin[z]-d];
	   *     3 and 4 guarantee k is within z's j=(j-d) d band
	   *
	   */
	  kmin = ESL_MAX((hdmin[y][jp_y]-d), (hdmin[z][jp_z-d]));
	  kmax = ESL_MIN((hdmax[y][jp_y]-d), (hdmax[z][jp_z-d]));
	  /* kmin and kmax satisfy inequalities (1-4) */
	  for(k = kmin; k <= kmax; k++) {
	    /* for current k, all 4 inequalities have been satisified
	     * so we know the cells corresponding to the platonic
	     * matrix cells beta[v][j][d], beta[y][j][d+k], and
	     * alpha[z][j-d][k] are all within the bands. These
	     * cells correspond to beta[v][jp_v][dp_v],
	     * beta[y][jp_y+k][d-hdmin[y][jp_y]+k],
	     * and alpha[z][jp_z-d][k-hdmin[z][jp_z-d]];
	     */
	    kp_z = k-hdmin[z][jp_z-d];
	    dp_y = d-hdmin[y][jp_y];
	    beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y+k]
								+ alpha[z][jp_z-d][kp_z]));
	  }
	}
	  }
	} /* end of 'else if (cm->stid[v] == BEGR_S */
	else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	  /* ILs and IRs can self transit, this means that beta[v][j][d] must be fully calculated
	   * before beta[v][j][d+1] can be started to be calculated, forcing the following nesting order:
	   * for j { for d { for y { } } }
	   * for non-self-transitioners, we can do a more efficient nesting order (see below)
	   */
	  for (j = jmax[v]; j >= jmin[v]; j--) {
	ESL_DASSERT1((j >= 0 && j <= L));
	jp_v = j - jmin[v];
	for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	  i = j-d+1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	    voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	    /* Note: this looks like it can be optimized, I tried but my 'optimization' slowed the code, so I reverted [EPN] */
	    switch(cm->sttype[y]) {
	    case MP_st:
	      if (j == L || d == j) continue; /* boundary condition */
	      if ((j+1) < jmin[y] || (j+1) > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+2) < hdmin[y][(jp_y+1)] || (d+2) > hdmax[y][(jp_y+1)]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y+1][dp_y+2] is a valid alpha cell
	       * corresponding to alpha[y][j+1][d+2] in the platonic matrix.
		   */
	      dp_y = d - hdmin[y][jp_y+1];  /* d index for state y */
	      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y+1][dp_y+2]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case ML_st:
	    case IL_st:
	      if (d == j) continue;	/* boundary condition (note when j=0, d=0)*/
	      if (j < jmin[y] || j > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+1) < hdmin[y][jp_y] || (d+1) > hdmax[y][jp_y]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y][dp_y+1] is a valid alpha cell
	       * corresponding to alpha[y][j][d+1] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
	      escore = esc_vAA[y][dsq[i-1]];
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y+1]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case MR_st:
	    case IR_st:
	      if (j == L) continue;
	      if ((j+1) < jmin[y] || (j+1) > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if ((d+1) < hdmin[y][(jp_y+1)] || (d+1) > hdmax[y][(jp_y+1)]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y+1][dp_y+1] is a valid alpha cell
	       * corresponding to alpha[y][j+1][d+1] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][(jp_y+1)];  /* d index for state y */
	      escore = esc_vAA[y][dsq[j+1]];
	      /*printf("j: %d | jmin[y]: %d | jmax[y]: %d | jp_v: %d | dp_v: %d | jp_y: %d | dp_y: %d\n", j, jmin[y], jmax[y], jp_v, dp_v, jp_y, dp_y);*/
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y+1][dp_y+1]
								  + cm->tsc[y][voffset] + escore));
	      break;

	    case S_st:
	    case E_st:
	    case D_st:
	      if (j < jmin[y] || j > jmax[y]) continue; /* enforces j is valid for state y */
	      jp_y = j - jmin[y];
	      if (d < hdmin[y][jp_y] || d > hdmax[y][jp_y]) continue; /* enforces d is valid for state y */
	      /* if we get here alpha[y][jp_y][dp_y] is a valid alpha cell
	       * corresponding to alpha[y][j][d] in the platonic matrix.
	       */
	      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y][dp_y] + cm->tsc[y][voffset]));
	      break;
	    } /* end of switch(cm->sttype[y] */
	  } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	  if (beta[v][jp_v][dp_v] < IMPOSSIBLE) beta[v][jp_v][dp_v] = IMPOSSIBLE;
	} /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	  } /* end loop over jp. We know beta for this whole state */
	} /* end of 'else if cm->sttype[v] == IL_st || cm->sttype[v] == IR_st' */
	else { /* state v is not BEGL_S, BEGL_R IL nor IR (must be ML, MP, MR, D, S, B or E) */
	  /* ML, MP, MR, D, S, B, E states cannot self transit, this means that all cells
	   * in beta[v] are independent of each other, only depending on beta[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
	sdr = StateRightDelta(cm->sttype[y]);
	sd  = StateDelta(cm->sttype[y]);
	emitmode = Emitmode(cm->sttype[y]);
	/* determine min j (jn) and max j (jx) that are valid for v and y */
	jn = ESL_MAX(jmin[v], jmin[y]-sdr);
	jx = ESL_MIN(jmax[v], jmax[y]-sdr);
	for (j = jx; j >= jn; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j+sdr >= jmin[y] && j+sdr <= jmax[y]));

	  /* determine min d (dn) and max d (dx) that are valid for v and y and j */
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y + sdr] - sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y + sdr] - sd);
	  dp_v = dx - hdmin[v][jp_v];
	  dp_y = dx - hdmin[y][jp_y + sdr];
	  i    = j-dx+1;

	  /* for each emit mode, update beta[v][jp_v][dp_v] for all valid d = dp_v */
	  switch(emitmode) {
	  case EMITPAIR:  /* MP_st */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--, i++) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITLEFT:  /* ML_st, IL_st */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--, i++) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      escore = esc_vAA[y][dsq[i-1]];
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITRIGHT:  /* MR_st, IR_st */
	    escore = esc_vAA[y][dsq[j+1]]; /* not dependent on i */
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset] + escore));
	    }
	    break;
	  case EMITNONE:  /* D_st, S_st, E_st*/
	    for (d = dx; d >= dn; d--, dp_v--, dp_y--) {
	      ESL_DASSERT1((  d       >= hdmin[v][jp_v]        &&   d       <= hdmax[v][jp_v]));
	      ESL_DASSERT1((((d + sd) >= hdmin[y][jp_y + sdr]) && ((d + sd) <= hdmax[y][jp_y + sdr])));
	      beta[v][jp_v][dp_v] = FLogsum(beta[v][jp_v][dp_v], (beta[y][jp_y + sdr][dp_y + sd]
								  + cm->tsc[y][voffset]));
	    }
	    break;
	  } /* end of switch(emitmode) */
	} /* end of for j = jx; j >= jn; j-- */
	  } /* end of for y = plast[v]... */
	} /* ends else entered for non-BEGL_S/BEGR_S/IL/IR states*/
	/* we're done calculating deck v for everything but local begins */

	/* deal with local alignment end transitions v->EL (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sdr      = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	  sd       = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	  emitmode = Emitmode(cm->sttype[v]);        /* note emitmode is for state v */

	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	jp_v =  j - jmin[v];
	dn   = hdmin[v][jp_v + sdr] - sd;
	dx   = hdmax[v][jp_v + sdr] - sd;
	i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	switch (emitmode) {
	case EMITPAIR:
	  for (d = dn; d <= dx; d++, dp_v++, i--) {
	    escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;
	case EMITLEFT:
	  for (d = dn; d <= dx; d++, dp_v++, i--) {
	    escore = esc_vAA[v][dsq[i-1]];
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;

	case EMITRIGHT:
	  escore = esc_vAA[v][dsq[j+1]];
	  for (d = dn; d <= dx; d++, dp_v++) {
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]
								    + escore));
	  }
	  break;

	case EMITNONE:
	  for (d = dn; d <= dx; d++, dp_v++) {
	    beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]));
	  }
	  break;
	}
	  }
	}
  } /* end loop over decks v. */

  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) /* careful w/ boundary here */
	beta[cm->M][j][d] = FLogsum(beta[cm->M][j][d], (beta[cm->M][j][d+1] + cm->el_selfsc));
	}
  }

  if(do_check && (!(cm->flags & CMH_LOCAL_END))) {
	/* Local ends make the following test invalid because it is not true that
	 * exactly 1 state in each node's split set must be visited in each parse.
	 *
	 * Determine P(S|M) / P(S|R) (probability of the sequence given the model)
	 * using both the Outside (beta) and Inside (alpha) matrices,
	 * and ensure they're consistent with P(S|M) / P(S|R) from the Inside calculation.
	 * For all v in each split set: Sum_v [ Sum_j,(d<=j) ( alpha[v][j][d] * beta[v][j][d] ) ]
	 *                                                    = P(S|M) / P(S|R)
	 */

	for(n = 0; n < cm->nodes; n++) {
	  sc = IMPOSSIBLE;
	  num_split_states = SplitStatesInNode(cm->ndtype[n]);
	  for(v = cm->nodemap[n]; v < cm->nodemap[n] + num_split_states; v++) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	    sc = FLogsum(sc, (alpha[v][jp_v][dp_v] + beta[v][jp_v][dp_v]));
	    /*printf("node %d | adding alpha beta: v: %d | jp_v: %d | dp_v: %d| j: %d | d: %d\n", n, v, jp_v, dp_v, j, d);
	      printf("\talpha: %f | beta: %f\n", alpha[v][jp_v][dp_v], beta[v][jp_v][dp_v]);*/
	  }
	}
	  }
	  /*printf("checking node: %d | sc: %.6f\n", n, sc);*/
	  diff = sc - alpha[0][jp_0][Lp_0];
	  if(diff > 0.01 || diff < -0.01) {
	fail_flag = TRUE;
	printf("ERROR: node %d P(S|M): %.5f inconsistent with Inside P(S|M): %.5f (diff: %.5f)\n",
	       n, sc, alpha[0][jp_0][Lp_0], diff);
	  }
	}
  }

  /* If not in local mode, we can calculate P(S|M) / P(S|R) given only the
   * beta matrix as follows:
   *
   * IF local ends are off, we know each parse MUST visit each END_E state,
   * we pick final END_E state state cm->M-1 (though any END_E could be used here):
   *
   * Sum_j=0 to W (alpha[M-1][j][0] * beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * Note: alpha[M-1][j][0] = 0.0 for all j
   *       because all parse subtrees rooted at an END_E must have d=0, (2^0 = 1.0)
   * therefore:
   * Sum_j=0 to W (beta[M-1][j][0]) = P(S|M) / P(S|R)
   *
   * *** If local ends are on, each parse MUST visit either each END_E state with d=0
   * or the EL state but d can vary, so we can't use this test (believe me I tried
   * to get a similar test working, but I'm convinced you need alpha to get P(S|M)
   * in local mode).
   */
  if(!(cm->flags & CMH_LOCAL_END)) {
	sc = IMPOSSIBLE;
	v = cm->M-1;
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  assert(hdmin[v][jp_v] == 0);
	  sc = FLogsum(sc, (beta[v][jp_v][0]));
	  /* printf("\talpha[%3d][%3d][%3d]: %5.2f | beta[%3d][%3d][%3d]: %5.2f\n", (cm->M-1), (j), 0, alpha[(cm->M-1)][j][0], (cm->M-1), (j), 0, beta[(cm->M-1)][j][0]);*/
	}
  }
  else { /* return_sc = P(S|M) / P(S|R) from Inside() */
	sc = alpha[0][jp_0][Lp_0];
  }

  if(fail_flag) ESL_FAIL(eslFAIL, errbuf, "Not all nodes passed posterior check.");

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_ohbmx", "w");   cm_hb_mx_Dump(fp1, mx); fclose(fp1);
#endif

  if(!(cm->flags & CMH_LOCAL_END)) ESL_DPRINTF1(("\tcm_OutsideAlignHB() sc : %f\n", sc));
  else                             ESL_DPRINTF1(("\tcm_OutsideAlignHB() sc : %f (LOCAL mode; sc is from Inside)\n", sc));

  if (ret_sc != NULL) *ret_sc = sc;
  return eslOK;
}

/* Function: cm_Posterior()
 * Date:     EPN, Mon Nov 19 09:02:12 2007
 * Note:     based on Ian Holmes' P7EmitterPosterior() from HMMER's 2.x postprob.c
 *           Renamed from CMPosterior() [EPN, Wed Sep 14 06:15:22 2011].
 *
 * Purpose: Combines non-banded Inside and Outside matrices into a
 *           posterior probability matrix. The value in post[v][j][d]
 *           is the log of the posterior probability of a parse
 *           subtree rooted at v emitting the subsequence i..j
 *           (i=j-d+1).  The caller must provide a <post> float
 *           matrix, but this matrix may be the same matrix as that
 *           provided as Outside <out_mx>, (overwriting it will not
 *           compromise the algorithm). Posteriors are calculated
 *           for the full sequence 1..L.
 *
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of the dsq to align
 *           size_limit - max number of Mb for DP matrix
 *           ins_mx     - pre-calculated Inside matrix
 *           out_mx     - pre-calculated Outside matrix
 *           post_mx    - pre-allocated matrix for Posteriors
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>, in
 *                       this case, post_mx is not filled.
 */
int
cm_Posterior(CM_t *cm, char *errbuf, int L, float size_limit, CM_MX *ins_mx, CM_MX *out_mx, CM_MX *post_mx)
{
  int   status;
  int   v, j, d; /* state, position, subseq length */
  int   vmax;    /* cm->M if local ends on, else cm->M-1 */
  float sc;      /* optimal score, from Inside matrix */

  /* the DP matrices */
  float ***alpha = ins_mx->dp; /* pointer to the alpha DP matrix */
  float ***beta  = out_mx->dp; /* pointer to the beta DP matrix */
  float ***post  = post_mx->dp; /* pointer to the post DP matrix */

  /* grow our post matrix, but only if isn't also our out_mx in which
   * case we know we're already big enought (also in that case we
   * don't want to call GrowTo b/c it can potentially free the DP
   * matrix memory and reallocate it, which would be bad b/c we
   * need the out_mx!)
   */
  if(post_mx != out_mx) {
	if((status = cm_mx_GrowTo(cm, post_mx, errbuf, L, size_limit)) != eslOK) return status;
  }

  sc = ins_mx->dp[0][L][L];

  /* If local ends are on, start with the EL state (cm->M), otherwise
   * its not a valid deck.
   */
  vmax = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
  for (v = vmax; v >= 0; v--) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	post[v][j][d] = alpha[v][j][d] + beta[v][j][d] - sc;
	  }
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_pmx", "w");   cm_mx_Dump(fp1, post_mx); fclose(fp1);
#endif

  return eslOK;
}

/* Function: cm_PosteriorHB()
 * Date:     EPN 05.27.06
 * Note:     based on Ian Holmes' P7EmitterPosterior() from HMMER's 2.x postprob.c
 *           Renamed from CMPosteriorHB() [EPN, Wed Sep 14 06:14:48 2011].
 *
 * Purpose: Combines HMM banded Inside and Outside matrices into a
 *           posterior probability matrix. Any cells outside of HMM
 *           bands do not exist in memory. The value in
 *           post[v][jp_v][dp_v] is the log of the posterior
 *           probability of a parse subtree rooted at v emitting the
 *           subsequence i..j (i=j-d+1). Where j = jp_v + jmin[v], and
 *           d = dp_v + hdmin[v][jp_v]. The caller must provide a
 *           <post> CM_HB_MX matrix, but this matrix may be the same
 *           matrix as that provided as Outside <out_mx>, (overwriting
 *           it will not compromise the algorithm). Posteriors are
 *           calculated for the full sequence 1..L.
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of the dsq to align
 *           size_limit - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           ins_mx     - pre-calculated Inside matrix
 *           out_mx     - pre-calculated Outside matrix
 *           post_mx    - pre-allocated matrix for Posteriors
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslEINVAL> if the full sequence is not within the bands for state 0
 *           In either case the post_mx is not filled
 */
int
cm_PosteriorHB(CM_t *cm, char *errbuf, int L, float size_limit, CM_HB_MX *ins_mx, CM_HB_MX *out_mx, CM_HB_MX *post_mx)
{
  int      status;
  int      v, j, d; /* state, position, position, subseq length */
  float    sc;      /* total score, the log probability of the current seq  */
  int      jp_v;    /* j index for state v in alpha/beta with HMM bands */
  int      dp_v;    /* d index for state v in alpha/beta with HMM bands */
  int      jp_0;        /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;        /* L offset in ROOT_S's (v==0) d band */

  /* the DP matrices */
  float ***alpha = ins_mx->dp; /* pointer to the alpha DP matrix */
  float ***beta  = out_mx->dp; /* pointer to the beta DP matrix */
  float ***post  = post_mx->dp; /* pointer to the post DP matrix */

  /* ptrs to cp9b info, for convenience */
  int     *jmin  = cm->cp9b->jmin;
  int     *jmax  = cm->cp9b->jmax;
  int    **hdmin = cm->cp9b->hdmin;
  int    **hdmax = cm->cp9b->hdmax;

  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (cm->cp9b->jmin[0] > L || cm->cp9b->jmax[0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cm->cp9b->jmin[0], cm->cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cm->cp9b->hdmin[0][jp_0] > L || cm->cp9b->hdmax[0][jp_0] < L)
	ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cm->cp9b->hdmin[0][jp_0], cm->cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  sc = alpha[0][jp_0][Lp_0];

  /* grow our post matrix, but only if isn't also our out_mx in which
   * case we know we're already big enought (also in that case we
   * don't want to call GrowTo b/c it can potentially free the DP
   * matrix memory and reallocate it, which would be bad b/c we
   * need the out_mx!)
   */
  if(post_mx != out_mx) {
	if((status = cm_hb_mx_GrowTo(cm, post_mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;
  }

  /* If local ends are on, start with the EL state (cm->M), otherwise
   * M deck is not valid. Note: there are no bands on the EL state
   */
  if (cm->flags & CMH_LOCAL_END) {
	for(j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	post[cm->M][j][d] = alpha[cm->M][j][d] + beta[cm->M][j][d] - sc;
	  }
	}
  }

  for (v = (cm->M-1); v >= 0; v--) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	dp_v = d - hdmin[v][jp_v];
	post[v][jp_v][dp_v] = alpha[v][jp_v][dp_v] + beta[v][jp_v][dp_v] - sc;
	/*printf("v: %3d | jp_v: %3d | dp_v: %3d | alpha: %5.2f | beta: %5.2f\n", v, jp_v, dp_v, alpha[v][jp_v][dp_v], beta[v][jp_v][dp_v]);*/
	  }
	}
  }
  return eslOK;
}

/* Function: cm_EmitterPosterior()
 * Date:     EPN, Fri Sep 30 13:53:57 2011
 *
 * Purpose: Given a posterior probability cube, where the value in
 *           post[v][j][d] is the log of the posterior probability of
 *           a parse subtree rooted at v emitting the subsequence i..j
 *           (i=j-d+1), fill a CM_EMIT_MX <emit_mx> with two 2-dimensional
 *           matrices with values:
 *
 *           emit_mx->l_pp[v][i]: log of the posterior probability that
 *           state v emitted residue i leftwise either at (if a match
 *           state) or *after* (if an insert state) the left consensus
 *           position modeled by state v's node.
 *
 *           emit_mx->r_pp[v][i]: log of the posterior probability that
 *           state v emitted residue i rightwise either at (if a match
 *           state) or *before* (if an insert state) the right
 *           consensus position modeled by state v's node.
 *
 *           l_pp[v] is NULL for states that do not emit leftwise
 *           r_pp[v] is NULL for states that do not emit rightwise
 *
 *          This is done in 3 steps:
 *          1. Fill l_pp[v][i] and r_pp[v][i] with the posterior
 *             probability that state v emitted residue i either
 *             leftwise (l_pp) or rightwise (r_pp).
 *
 *          2. Normalize l_pp and r_pp so that probability that
 *             each residue was emitted by any state is exactly
 *             1.0.
 *
 *          3. Combine l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
 *             states in the same node so they give the value defined
 *             above (i.e. l_pp[v] == l_pp[y] = the PP that either v
 *             or y emitted residue i) instead of l_pp[v] = PP that v
 *             emitted i, and l_pp[y] = PP that y emitted i.  And
 *             combine r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
 *             states in an analogous way.
 *
 *          If <do_check> we check to make sure the summed probability
 *          of any residue is > 0.98 and < 1.02 prior the step 2
 *          normalization, and throw eslFAIL if not.
 *
 *          Note: A failure of this test does not necessarily mean a
 *          bug in the code, because this check is known to fail for
 *          some cases with parsetrees that contain inserts of 100s of
 *          residues from the same IL or IR state (that utilize 100s
 *          of IL->IL or IR->IR self transitions). These cases were
 *          looked at in detail to determine if they were due to a bug
 *          in the DP code. This was logged in
 *          ~nawrockie/notebook/8_1016_inf-1rc3_bug_alignment/00LOG.
 *          The conclusion was that the failure of the posterior check
 *          is due completely to lack of precision in the float scores
 *          (not just in the logsum look-up table but also with using
 *          real log() and exp() calls). If this function returns an
 *          error, please check to see if the parsetree has a large
 *          insertion in it, if so you can expect probabilities up to
 *          1.03 due solely to this precision issue. See the notebook
 *          00LOG for more, included a check I performed to change the
 *          relevant IL->IL transition probability by very small
 *          values (~0.0001) and you can observe the posteriors change
 *          dramatically which demonstrates that precision of floats
 *          is the culprit.  (EPN, Sun Oct 26 14:54:31 2008
 *          (originally added to cm_Posterior() function 'Purpose'
 *          function which no longer exists, having been replaced by
 *          this function.)
 *
 *
 * Args:     cm         - the model
 *           errbuf     - for error messages
 *           L          - length of the sequence
 *           size_limit - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           post       - pre-filled posterior cube
 *           emit_mx     - pre-allocated emit matrix, grown and filled-in here
 *           do_check   - if TRUE, return eslEFAIL if summed prob of any residue
 *                        (before normalization) is < 0.98 or > 1.02.
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslFAIL>   if (do_check) and any residue check fails
 *           <eslEMEM>   if we run out of memory.
 *           If !eslOK the l_pp and r_pp values are invalid.
 */
int
cm_EmitterPosterior(CM_t *cm, char *errbuf, int L, float size_limit, CM_MX *post, CM_EMIT_MX *emit_mx, int do_check)
{
  int    status;
  int    v, j, d; /* state, position, subseq length */
  int    i;       /* sequence position */
  int    sd;      /* StateDelta(v) */

  /* grow the emit matrices based on the current sequence */
  if((status = cm_emit_mx_GrowTo(cm, emit_mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the emit matrices to IMPOSSIBLE */
  esl_vec_FSet(emit_mx->l_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  esl_vec_FSet(emit_mx->r_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);

  /* Step 1. Fill l_pp[v][i] and r_pp[v][i] with the posterior
   *         probability that state v emitted residue i either
   *         leftwise (l_pp) or rightwise (r_pp).
   */
  for(v = 0; v < cm->M; v++) {
	sd = StateDelta(cm->sttype[v]);
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  for(j = 1; j <= L; j++) {
	i = j-sd+1;
	for(d = sd; d <= j; d++, i--) {
	  emit_mx->l_pp[v][i] = FLogsum(emit_mx->l_pp[v][i], post->dp[v][j][d]);
	}
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  for(j = 1; j <= L; j++) {
	sd = StateDelta(cm->sttype[v]);
	for(d = sd; d <= j; d++) {
	  emit_mx->r_pp[v][j] = FLogsum(emit_mx->r_pp[v][j], post->dp[v][j][d]);
	}
	  }
	}
  }
  /* factor in contribution of local ends, the EL state may have emitted this residue. */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = 1; j <= L; j++) {
	  i = j;
	  for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	emit_mx->l_pp[cm->M][i] = FLogsum(emit_mx->l_pp[cm->M][i], post->dp[cm->M][j][d]);
	  }
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_unnorm_emitmx",  "w"); cm_emit_mx_Dump(fp1, cm, emit_mx); fclose(fp1);
#endif

  /* Step 2. Normalize l_pp and r_pp so that probability that
   *         each residue was emitted by any state is exactly
   *         1.0.
   */
  esl_vec_FSet(emit_mx->sum, (L+1), IMPOSSIBLE);
  for(v = 0; v <= cm->M; v++) {
	if(emit_mx->l_pp[v] != NULL) {
	  for(i = 1; i <= L; i++) {
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->l_pp[v][i]);
	  }
	}
	if(emit_mx->r_pp[v] != NULL) {
	  for(j = 1; j <= L; j++) {
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->r_pp[v][j]);
	  }
	}
  }
  /* perform the check, if nec */
  if(do_check) {
	for(i = 1; i <= L; i++) {
	  if((sreEXP2(emit_mx->sum[i]) < 0.98) || (sreEXP2(emit_mx->sum[i]) > 1.02)) {
	ESL_FAIL(eslFAIL, errbuf, "residue %d has summed prob of %5.4f (2^%5.4f).\nMay not be a DP coding bug, see 'Note:' on precision in cm_EmitterPosterior().\n", i, (sreEXP2(emit_mx->sum[i])), emit_mx->sum[i]);
	  }
	  printf("i: %d | total: %10.4f\n", i, (sreEXP2(emit_mx->sum[i])));
	}
	ESL_DPRINTF1(("cm_EmitterPosterior() check passed, all residues have summed probability of emission of between 0.98 and 1.02.\n"));
  }

  /* normalize, using the sum vector */
  for(v = 0; v <= cm->M; v++) {
	if(emit_mx->l_pp[v] != NULL) {
	  for(i = 1; i <= L; i++) {
	emit_mx->l_pp[v][i] -= emit_mx->sum[i];
	  }
	}
	if(emit_mx->r_pp[v] != NULL) {
	  for(j = 1; j <= L; j++) {
	emit_mx->r_pp[v][j] -= emit_mx->sum[j];
	  }
	}
  }

  /* Step 3. Combine l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
   *         states in the same node so they give the value defined
   *         above (i.e. l_pp[v] == l_pp[y] = the PP that either v or
   *         y emitted residue i) instead of l_pp[v] = PP that v
   *         emitted i, and l_pp[y] = PP that y emitted i.  And
   *         combine r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
   *         states in an analogous way.
   */
  for(v = 0; v <= cm->M; v++) {
	if(cm->sttype[v] == MP_st) {
	  for(i = 1; i <= L; i++) {
	emit_mx->l_pp[v][i]   = FLogsum(emit_mx->l_pp[v][i], emit_mx->l_pp[v+1][i]);
	emit_mx->l_pp[v+1][i] = emit_mx->l_pp[v][i];
	  }
	  for(j = 1; j <= L; j++) {
	emit_mx->r_pp[v][j]   = FLogsum(emit_mx->r_pp[v][j], emit_mx->r_pp[v+2][j]);
	emit_mx->r_pp[v+2][j] = emit_mx->r_pp[v][j];
	  }
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp2; fp2 = fopen("tmp.std_emitmx",  "w"); cm_emit_mx_Dump(fp2, cm, emit_mx); fclose(fp2);
#endif

  return eslOK;
}

/* Function: cm_EmitterPosteriorHB()
 * Date:     EPN, Thu Oct  6 06:59:53 2011
 *
 * Purpose: Same as cm_EmitterPosterior() except HMM banded matrices
 *          are used. The main difference is that we have to be careful
 *          to stay within the bands because matrix cells outside
 *          the bands do not exist (are not allocated). This requires
 *          keeping careful track of our offsets between the sequence
 *          position index and the corresponding indices in the matrix.
 *
 * Args:     cm         - the model
 *           errbuf     - for error messages
 *           L          - length of the sequence
 *           size_limit - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           post       - pre-filled posterior cube
 *           emit_mx     - pre-allocated emit matrix, grown and filled-in here
 *           do_check   - if TRUE, return eslEFAIL if summed prob of any residue
 *                        (before normalization) is < 0.98 or > 1.02.
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslFAIL>   if (do_check) and any residue check fails
 *           <eslEMEM>   if we run out of memory.
 *           If !eslOK the l_pp and r_pp values are invalid.
 */
int
cm_EmitterPosteriorHB(CM_t *cm, char *errbuf, int L, float size_limit, CM_HB_MX *post, CM_HB_EMIT_MX *emit_mx, int do_check)
{
  int    status;
  int    v, j, d; /* state, position, subseq length */
  int    i;       /* sequence position */
  int    ip_v;    /* offset i in banded matrix */
  int    ip_v2;   /* another offset i in banded matrix */
  int    jp_v;    /* offset j in banded matrix */
  int    jp_v2;   /* another offset j in banded matrix */
  int    dp_v;    /* offset d in banded matrix */
  int    in, ix;  /* temp min/max i */
  int    jn, jx;  /* temp min/max j */

  /* ptrs to band info, for convenience */
  int     *imin  = cm->cp9b->imin;
  int     *imax  = cm->cp9b->imax;
  int     *jmin  = cm->cp9b->jmin;
  int     *jmax  = cm->cp9b->jmax;
  int    **hdmin = cm->cp9b->hdmin;
  int    **hdmax = cm->cp9b->hdmax;

  /* grow the emit matrices based on the current sequence */
  if((status = cm_hb_emit_mx_GrowTo(cm, emit_mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the emit matrices to IMPOSSIBLE */
  esl_vec_FSet(emit_mx->l_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  esl_vec_FSet(emit_mx->r_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);

  /* Step 1. Fill l_pp[v][i] and r_pp[v][i] with the posterior
   *         probability that state v emitted residue i either
   *         leftwise (l_pp) or rightwise (r_pp).
   */
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  for(j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d-hdmin[v][jp_v];
	  i    = j-d+1;
	  assert(i >= imin[v] && i <= imax[v]);
	  ip_v = i - imin[v];
	  emit_mx->l_pp[v][ip_v] = FLogsum(emit_mx->l_pp[v][ip_v], post->dp[v][jp_v][dp_v]);
	}
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  for(j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d-hdmin[v][jp_v];
	  emit_mx->r_pp[v][jp_v] = FLogsum(emit_mx->r_pp[v][jp_v], post->dp[v][jp_v][dp_v]);
	}
	  }
	}
  }
  /* factor in contribution of local ends, the EL state may have emitted this residue.
   * Note, the M deck is non-banded
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = 1; j <= L; j++) {
	  i = j;
	  for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	emit_mx->l_pp[cm->M][i] = FLogsum(emit_mx->l_pp[cm->M][i], post->dp[cm->M][j][d]);
	  }
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.std_unnorm_hbemitmx",  "w"); cm_hb_emit_mx_Dump(fp1, cm, emit_mx); fclose(fp1);
#endif

  /* Step 2. Normalize l_pp and r_pp so that probability that
   *         each residue was emitted by any state is exactly
   *         1.0.
   */
  esl_vec_FSet(emit_mx->sum, (L+1), IMPOSSIBLE);
  for(v = 0; v < cm->M; v++) { /* we'll handle EL special */
	if(emit_mx->l_pp[v] != NULL) {
	  for(i = imin[v]; i <= imax[v]; i++) {
	ip_v = i - imin[v];
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->l_pp[v][ip_v]);
	  }
	}
	if(emit_mx->r_pp[v] != NULL) {
	  for(j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->r_pp[v][jp_v]);
	  }
	}
  }
  /* Handle EL deck, remember it is non-banded */
  if(emit_mx->l_pp[cm->M] != NULL) {
	for(i = 1; i <= L; i++) {
	  emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->l_pp[v][i]);
	}
  }

  /* perform the check, if nec */
  if(do_check) {
	for(i = 1; i <= L; i++) {
	  if((sreEXP2(emit_mx->sum[i]) < 0.98) || (sreEXP2(emit_mx->sum[i]) > 1.02)) {
	ESL_FAIL(eslFAIL, errbuf, "residue %d has summed prob of %5.4f (2^%5.4f).\nMay not be a DP coding bug, see 'Note:' on precision in cm_EmitterPosterior().\n", i, (sreEXP2(emit_mx->sum[i])), emit_mx->sum[i]);
	  }
	  printf("HB i: %d | total: %10.4f\n", i, (sreEXP2(emit_mx->sum[i])));
	}
	ESL_DPRINTF1(("cm_EmitterPosteriorHB() check passed, all residues have summed probability of emission of between 0.98 and 1.02.\n"));
  }

  /* normalize, using the sum vector */
  for(v = 0; v < cm->M; v++) {
	if(emit_mx->l_pp[v] != NULL) {
	  for(i = imin[v]; i <= imax[v]; i++) {
	ip_v = i - imin[v];
	emit_mx->l_pp[v][ip_v] -= emit_mx->sum[i];
	  }
	}
	if(emit_mx->r_pp[v] != NULL) {
	  for(j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	emit_mx->r_pp[v][jp_v] -= emit_mx->sum[j];
	  }
	}
  }
  /* Handle EL deck, remember it is non-banded */
  if(emit_mx->l_pp[cm->M] != NULL) {
	for(i = 1; i <= L; i++) {
	  emit_mx->l_pp[cm->M][i] -= emit_mx->sum[i];
	}
  }

  /* Step 3. Combine l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
   *         states in the same node so they give the value defined
   *         above (i.e. l_pp[v] == l_pp[y] = the PP that either v or
   *         y emitted residue i) instead of l_pp[v] = PP that v
   *         emitted i, and l_pp[y] = PP that y emitted i.  And
   *         combine r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
   *         states in an analogous way.
   */
  for(v = 0; v <= cm->M; v++) {
	if(cm->sttype[v] == MP_st) {
	  /* we only change l_pp[v][i] and l_pp[v+1][i] if i is within both
	   * state v and v+1's i band.
	   */
	  if(imax[v] >= 1 && imax[v+1] >= 1) {
	in = ESL_MAX(imin[v], imin[v+1]);
	ix = ESL_MIN(imax[v], imax[v+1]);
	for(i = in; i <= ix; i++) {
	  ip_v  = i - imin[v];
	  ip_v2 = i - imin[v+1];
	  emit_mx->l_pp[v][ip_v]    = FLogsum(emit_mx->l_pp[v][ip_v], emit_mx->l_pp[v+1][ip_v2]);
	  emit_mx->l_pp[v+1][ip_v2] = emit_mx->l_pp[v][ip_v];
	}
	  }
	  /* we only change r_pp[v][j] and r_pp[v+2][j] if j is within both
	   * state v and v+2's j band.
	   */
	  if(jmax[v] >= 1 && jmax[v+2] >= 1) {
	jn = ESL_MAX(jmin[v], jmin[v+2]);
	jx = ESL_MIN(jmax[v], jmax[v+2]);
	for(j = jn; j <= jx; j++) {
	  jp_v  = j - jmin[v];
	  jp_v2 = j - jmin[v+2];
	  emit_mx->r_pp[v][jp_v]    = FLogsum(emit_mx->r_pp[v][jp_v], emit_mx->r_pp[v+2][jp_v2]);
	  emit_mx->r_pp[v+2][jp_v2] = emit_mx->r_pp[v][jp_v];
	}
	  }
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp2; fp2 = fopen("tmp.std_hbemitmx",  "w"); cm_hb_emit_mx_Dump(fp2, cm, emit_mx); fclose(fp2);
#endif

  return eslOK;
}

/* Function: cm_PostCode()
 * Date:     EPN 05.25.06 based on SRE's Postcode()
 *           from HMMER's postprob.c
 *
 * Purpose: Given a parse tree and a filled emit matrix calculate two
 *           strings that represents the confidence values on each
 *           aligned residue in the sequence.
 *
 *           The emit_mx values are:
 *           l_pp[v][i]: log of the posterior probability that state v emitted
 *                       residue i leftwise either at (if a match state) or
 *                       *after* (if an insert state) the left consensus
 *                       position modeled by state v's node.
 *
 *           r_pp[v][i]: log of the posterior probability that state v emitted
 *                       residue i rightwise either at (if a match state) or
 *                       *before* (if an insert state) the right consensus
 *                       position modeled by state v's node.
 *
 *           l_pp[v] is NULL for states that do not emit leftwise  (B,S,D,E,IR,MR)
 *           r_pp[v] is NULL for states that do not emit rightwise (B,S,D,E,IL,ML)
 *
 *           The PP string is 0..L-1  (L = len of target seq),
 *           so its in the coordinate system of the sequence string;
 *           off by one from dsq.
 *
 *           Values are 0,1,2,3,4,5,6,7,8,9,*:
 *           '0' = [0.00-0.05)
 *           '1' = [0.05-0.15)
 *           '2' = [0.15-0.25)
 *           '3' = [0.25-0.35)
 *           '4' = [0.35-0.45)
 *           '5' = [0.45-0.55)
 *           '6' = [0.55-0.65)
 *           '7' = [0.65-0.75)
 *           '8' = [0.75-0.85)
 *           '9' = [0.85-0.95)
 *           '*' = [0.95-1.00)
 *
 *           cm_PostCodeHB() is nearly the same function with the
 *           difference that HMM bands were used for the alignment,
 *           so we have to deal with offset issues.
 *
 *           Renamed from CMPostCode() [EPN, Wed Sep 14 06:20:35 2011].
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           dsq        - the digitized sequence [1..L]
 *           L          - length of the dsq to align
 *           emit_mx    - the pre-filled emit matrix, must be non-NULL if do_optacc
 *           tr         - the parstree with the emissions we're setting PPs for
 *           ret_ppstr  - RETURN: a string of the PP code values (0..L-1)
 *           ret_avgp   - RETURN: the average PP of all aligned residues
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslEINVAL> if a posterior probability is > 1.01 or less than -0.01.
 */
char
Fscore2postcode(float sc)
{
  float p = FScore2Prob(sc, 1.);
  return (p + 0.05 >= 1.0) ? '*' :  (char) ((p + 0.05) * 10.0) + '0';
}

/* Function: FScore2Prob()
 *
 * Purpose:  Convert a float log_2 odds score back to a probability;
 *           needs the null model probability, if any, to do the conversion.
 */
float
FScore2Prob(float sc, float null)
{
  /*printf("in FScore2Prob: %10.2f sreEXP2: %10.2f\n", sc, (sreEXP2(sc)));*/
  if (!(NOT_IMPOSSIBLE(sc))) return 0.;
  else                       return (null * sreEXP2(sc));
}

int
cm_PostCode(CM_t *cm, char *errbuf, int L, CM_EMIT_MX *emit_mx, Parsetree_t *tr, char **ret_ppstr, float *ret_avgp)
{
  int   status;
  int   x, v, i, j, r; /* counters */
  char *ppstr;       /* the PP string, created here */
  float p;           /* a probability */
  float sum_logp;    /* log of summed probability of all residues emitted thus far */

  ESL_ALLOC(ppstr, (L+1) * sizeof(char));
  sum_logp = IMPOSSIBLE;

  /* go through each node of the parsetree and determine post code for emissions */
  for (x = 0; x < tr->n; x++)
	{
	  v = tr->state[x];
	  i = tr->emitl[x];
	  j = tr->emitr[x];

	  /* Only P, L, R, and EL states have emissions. */
	  if(cm->sttype[v] == EL_st) { /* EL state, we have to handle this guy special */
	for(r = i; r <= j; r++) { /* we have to annotate from residues i..j */
	  ppstr[r-1] = Fscore2postcode(emit_mx->l_pp[v][r]);
	  sum_logp   = FLogsum(sum_logp, emit_mx->l_pp[v][r]);
	  /* make sure we've got a valid probability */
	  p = FScore2Prob(emit_mx->l_pp[v][r], 1.);
	  if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for EL state v: %d residue r: %d > 1.00 (%.2f)", v, r, p);
	  if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for EL state v: %d residue r: %d < 0.00 (%.2f)", v, r, p);
	}
	  }
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	ppstr[i-1] = Fscore2postcode(emit_mx->l_pp[v][i]);
	sum_logp   = FLogsum(sum_logp, emit_mx->l_pp[v][i]);
	/* make sure we've got a valid probability */
	p = FScore2Prob(emit_mx->l_pp[v][i], 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for left state v: %d residue i: %d > 1.00 (%.2f)", v, i, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for left state v: %d residue i: %d < 0.00 (%.2f)", v, i, p);
	  }
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	ppstr[j-1] = Fscore2postcode(emit_mx->r_pp[v][j]);
	sum_logp   = FLogsum(sum_logp, emit_mx->r_pp[v][j]);
	/* make sure we've got a valid probability */
	p = FScore2Prob(emit_mx->r_pp[v][j], 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for right state v: %d residue i: %d > 1.00 (%.2f)", v, j, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for right state v: %d residue i: %d < 0.00 (%.2f)", v, j, p);
	  }
	}
  ppstr[L] = '\0';

  if(ret_ppstr != NULL) *ret_ppstr = ppstr; else free(ppstr);
  if(ret_avgp  != NULL) *ret_avgp  = sreEXP2(sum_logp) / (float) L;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_Postcode(): Memory allocation error.");
  return status; /* never reached */
}

int
cm_PostCodeHB(CM_t *cm, char *errbuf, int L, CM_HB_EMIT_MX *emit_mx, Parsetree_t *tr, char **ret_ppstr, float *ret_avgp)
{
  int   status;
  int   x, v, i, j, r; /* counters */
  char *ppstr;       /* the PP string, created here */
  float p;           /* a probability */
  float sum_logp;    /* log of summed probability of all residues emitted thus far */

  /* variables used for HMM bands */
  int ip_v, jp_v; /* i, j offset within bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *imin  = cp9b->imin;
  int     *imax  = cp9b->imax;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;

  ESL_ALLOC(ppstr, (L+1) * sizeof(char));
  sum_logp = IMPOSSIBLE;

  /* go through each node of the parsetree and determine post code for emissions */
  for (x = 0; x < tr->n; x++)
	{
	  v = tr->state[x];
	  i = tr->emitl[x];
	  j = tr->emitr[x];

	  /* Only P, L, R, and EL states have emissions. */
	  if(cm->sttype[v] == EL_st) { /* EL state, we have to handle this guy special */
	for(r = i; r <= j; r++) { /* we have to annotate from residues i..j */
	  /* remember the EL deck is non-banded */
	  ppstr[r-1] = Fscore2postcode(emit_mx->l_pp[v][r]);
	  sum_logp   = FLogsum(sum_logp, emit_mx->l_pp[v][r]);
	  /* make sure we've got a valid probability */
	  p = FScore2Prob(emit_mx->l_pp[v][r], 1.);
	  if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for EL state v: %d residue r: %d > 1.00 (%.2f)", v, r, p);
	  if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for EL state v: %d residue r: %d < 0.00 (%.2f)", v, r, p);
	}
	  }
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	ip_v = i - imin[v];
	assert(i >= imin[v] && i <= imax[v]);
	ESL_DASSERT1((i >= imin[v] && i <= imax[v]));
	ppstr[i-1] = Fscore2postcode(emit_mx->l_pp[v][ip_v]);
	sum_logp   = FLogsum(sum_logp, emit_mx->l_pp[v][ip_v]);
	/* make sure we've got a valid probability */
	p = FScore2Prob(emit_mx->l_pp[v][ip_v], 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for left state v: %d residue i: %d > 1.00 (%.2f)", v, i, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for left state v: %d residue i: %d < 0.00 (%.2f)", v, i, p);
	  }
	  if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	jp_v = j - jmin[v];
	assert(j >= jmin[v] && j <= jmax[v]);
	ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	ppstr[j-1] = Fscore2postcode(emit_mx->r_pp[v][jp_v]);
	sum_logp   = FLogsum(sum_logp, emit_mx->r_pp[v][jp_v]);
	/* make sure we've got a valid probability */
	p = FScore2Prob(emit_mx->r_pp[v][jp_v], 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for right state v: %d residue i: %d > 1.00 (%.2f)", v, j, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_PostCode(): probability for right state v: %d residue i: %d < 0.00 (%.2f)", v, j, p);
	  }
	}
  ppstr[L] = '\0';

  if(ret_ppstr != NULL) *ret_ppstr = ppstr; else free(ppstr);
  if(ret_avgp  != NULL) *ret_avgp  = sreEXP2(sum_logp) / (float) L;
  ESL_DPRINTF1(("cm_PostcodeHB(): average pp %.4f\n", sreEXP2(sum_logp) / (float) L));
  /*printf("cm_PostcodeHB(): average pp %.4f\n", sreEXP2(sum_logp) / (float) L);*/

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_PostcodeHB(): Memory allocation error.");
  return status; /* never reached */
}

/* Function: cm_InitializeOptAccShadowDZero()
 * Date:     EPN, Fri Nov 11 13:09:14 2011
 *
 * Purpose:  Initialize a optimal accuracy shadow (traceback) matrix
 *           for d == 0, based on transition scores. Optimal accuracy
 *           traceback matrices are special when d==0 because only
 *           emissions contribute to score so the value when d==0 is
 *           always IMPOSSIBLE. So d==0 cells are never modified
 *           during the OA DP recursion.
 *
 *           In this function we determine the appropriate state to
 *           traceback to for d==0 for all states v and endpoints
 *           j. If local ends are off, this is trivial; it is simply
 *           the child state y for which StateDelta(y) == 0 (there is
 *           always exactly 1 such child state for each v). If any
 *           such state is entered for d == 0 in the optimally
 *           accurate parsetree, the parse will continue along
 *           delete->delete transitions (all with d==0) until an E_st
 *           (or E_st's if we go through a B_st) is reached.
 *
 *           If local ends are on, it is more complex because we
 *           could do a local end instead of a string of deletes until
 *           an end is reached. We determine the score of the
 *           transitions from the current state v through y to the
 *           nearest E_st(s) and if it is less than the score for
 *           entering a EL state we set the shadow matrix to y, else
 *           we set it to USED_EL.
 *
 *           In some cases, we initialize to USED_EL for states v for
 *           which ELs are illegal (not a MATP_MP, MATL_ML, MATR_MR,
 *           BEGL_S or BEGR_nd). This means that the eventual optimal
 *           accuracy parsetree may contain an illegal EL, but I think
 *           this is unavoidable.
 *
 *           Upon entrance, yshadow should be initialized to USED_EL
 *           for all values.
 *
 *           Note that if we didn't call this function, the optimally
 *           accurate parsetree would not be affected, nor its score.
 *           This function is only useful because it affects the
 *           output of the parsetree's alignment by only using a zero
 *           length EL transitions only when it is less expensive than
 *           a string of deletes.
 *
 *           If called by a truncated optimal accuracy function
 *           (cm_TrOptAccAlign()), yshadow is really a <Jyshadow>
 *           matrix from a CM_TR_SHADOW_MX object. Otherwise it is a
 *           <yshadow> matrix from a CM_SHADOW_MX object.
 *
 * Args:     cm         - the model, used only for its alphabet and null model
 *           errbuf     - for reporting errors
 *           yshadow    - the shadow matrix to updated, only values for which
 *                        d==0 will be modified.
 *           L          - length of the sequence we're aligning
 *
 *
 * Returns:  eslOK on success
 *
 * Throws:   eslEMEM on memory error.
 */
int
cm_InitializeOptAccShadowDZero(CM_t *cm, char *errbuf, char ***yshadow, int L)
{
  int   status;
  float *esc;  /* [0..v..M-1] summed transition score for getting from v to nearest E_st(s)
		* through only delete states */
  float endsc; /* score for transitioning to an EL state */
  int have_el; /* are local ends on? */
  int v;       /* state counter */
  int j;       /* sequence position */
  int y, z;    /* BEGL_S and BEGR_S states */
  int sd;      /* StateDelta(v) */
  int yoffset; /* child state index */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el) {
	ESL_ALLOC(esc, sizeof(float) * cm->M);
	esl_vec_FSet(esc, cm->M, 0.);
	/* determine score for transitioning to an EL (same for all legal states) */
	v = 0; while(! NOT_IMPOSSIBLE(cm->endsc[v])) v++;
	endsc = cm->endsc[v];
	/*printf("endsc: %.4f end %.4f\n", endsc, cm->end[v]);*/
  }
  else {
	esc = NULL;
	endsc = IMPOSSIBLE;
  }

  for(v = cm->M-1; v >= 0; v--) {
	sd = StateDelta(cm->sttype[v]);
	if(cm->sttype[v] == E_st) {
	  if(esc != NULL) esc[v] = 0.;
	}
	else if(cm->sttype[v] == B_st) {
	  if(esc != NULL) {
	y = cm->cfirst[v]; /* left  subtree */
	z = cm->cnum[v];   /* right subtree */
	esc[v] = esc[y] + esc[z];
	  }
	}
	else {
	  /* determine the one and only child state y for which StateDelta(y) == 0 */
	  y = cm->cfirst[v];
	  while(StateDelta(cm->sttype[y]) != 0) y++;
	  yoffset = y-cm->cfirst[v];
	  assert(cm->ndidx[v] == (cm->ndidx[y]-1));
	  if(esc != NULL) {
	esc[v] = esc[y] + cm->tsc[v][yoffset];
	if(endsc > esc[v]) yoffset = USED_EL;
	/* else yoffset is not changed */

	/*printf("EL: %10.4f  d->d->e %10.4f  ", endsc, esc[v]);
	  if(yoffset != USED_EL) printf("  path for v: %4d %4s %2s is through deletes!\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	  else printf("\n");
	*/
	  }
	  for(j = sd; j <= L; j++) yshadow[v][j][sd] = yoffset;
	}
  }

  if(esc != NULL) free(esc);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Out of memory");
}

/* Function: cm_InitializeOptAccShadowDZeroHB()
 * Date:     EPN, Fri Nov 11 14:00:55 2011
 *
 * Purpose:  Same as cm_InitializeOptAccShadowDZero() but for HMM
 *           banded matrices, see that function for more information.
 *
 * Args:     cm         - the model, used only for its alphabet and null model
 *           cp9b       - CP9 Bands for current sequence
 *           errbuf     - for reporting errors
 *           yshadow    - the shadow matrix to updated, only values for which
 *                        d==0 will be modified.
 *           L          - length of the sequence we're aligning
 *
 *
 * Returns:  eslOK on success
 *
 * Throws:   eslEMEM on memory error.
 */
int
cm_InitializeOptAccShadowDZeroHB(CM_t *cm, CP9Bands_t *cp9b, char *errbuf, char ***yshadow, int L)
{
  int   status;
  float *esc;  /* [0..v..M-1] summed transition score for getting from v to nearest E_st(s)
		* through only delete states */
  float endsc; /* score for transitioning to an EL state */
  int have_el; /* are local ends on? */
  int v;       /* state counter */
  int j;       /* sequence position */
  int y, z;    /* BEGL_S and BEGR_S states */
  int sd;      /* StateDelta(v) */
  int yoffset; /* child state index */

  /* variables needed because we've got HMM bands */
  int sdr;     /* StateRightDelta(v) */
  int jp_v;    /* j offset for state v given HMM bands */
  int jp_y;    /* j offset for state y given HMM bands */
  int dp_v;    /* d offset for state v given HMM bands */

  /* pointers to cp9b data for convenience */
  int         *jmin = cp9b->jmin;
  int         *jmax = cp9b->jmax;
  int       **hdmin = cp9b->hdmin;
  int       **hdmax = cp9b->hdmax;

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el) {
	ESL_ALLOC(esc, sizeof(float) * cm->M);
	esl_vec_FSet(esc, cm->M, IMPOSSIBLE);
	/* determine score for transitioning to an EL (same for all legal states) */
	v = 0; while(! NOT_IMPOSSIBLE(cm->endsc[v])) v++;
	endsc = cm->endsc[v];
	/*printf("endsc: %.4f end %.4f\n", endsc, cm->end[v]);*/
  }
  else {
	esc = NULL;
	endsc = IMPOSSIBLE;
  }

  for(v = cm->M-1; v >= 0; v--) {
	if(cm->cp9b->Jvalid[v]) { /* only valid v values will have non-impossible esc[v] values */
	  sd  = StateDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);
	  if(cm->sttype[v] == E_st) {
	if(esc != NULL) esc[v] = 0.;
	  }
	  else if(cm->sttype[v] == B_st) {
	if(esc != NULL) {
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */
	  esc[v] = esc[y] + esc[z];
	}
	  }
	  else {
	/* determine the one and only child state y for which StateDelta(y) == 0 */
	y = cm->cfirst[v];
	while(StateDelta(cm->sttype[y]) != 0) y++;
	yoffset = y-cm->cfirst[v];
	assert(cm->ndidx[v] == (cm->ndidx[y]-1));
	if(esc != NULL) {
	esc[v] = esc[y] + cm->tsc[v][yoffset];
	if(endsc > esc[v]) yoffset = USED_EL;
	/* else yoffset is not changed */

#if 0
	printf("EL: %10.4f  d->d->e %10.4f  ", endsc, esc[v]);
	if(yoffset != USED_EL) printf("  path for v %4d %4s %2s is through deletes!\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	else printf("\n");
#endif

	}
	for(j = ESL_MAX(sd, jmin[v]); j <= jmax[v]; j++) {
	  jp_v = j-jmin[v];
	  if(hdmin[v][jp_v] <= hdmax[v][jp_v]) { /* at least one valid d exists for this v and j */
	    if((j-sdr) >= jmin[y] && (j-sdr) <= jmax[y]) { /* j-sdr is valid for state y */
	      jp_y = j - sdr - jmin[y];
	      if(sd >= hdmin[v][jp_v] && sd <= hdmax[v][jp_v] && /* d==sd is valid for state v and end posn j */
		 0  >= hdmin[y][jp_y] &&  0 <= hdmax[y][jp_y]) { /* d==0  is valid for state y and end posn j-sdr */
		dp_v = sd - hdmin[v][jp_v];
		yshadow[v][jp_v][dp_v] = yoffset;
	      }
	    }
	  }
	}
	  }
	}
  }

  if(esc != NULL) free(esc);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Out of memory");
}

/*****************************************************************
 * Benchmark driver
 *****************************************************************/
#ifdef IMPL_ALIGN_BENCHMARK
/* Next line is not optimized (debugging on) on MacBook Pro:
 * gcc   -o benchmark-align -std=gnu99 -g -Wall -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_ALIGN_BENCHMARK cm_dpalign.c -linfernal -lhmmer -leasel -lm
 * Next line is optimized (debugging not on) on wyvern:
 * gcc   -o benchmark-align -std=gnu99 -O3 -fomit-frame-pointer -malign-double -fstrict-aliasing -pthread -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_ALIGN_BENCHMARK cm_dpalign.c -linfernal -lhmmer -leasel -lm
 * ./benchmark-align <cmfile>
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",           0 },
  { "-l",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "configure CM/HMM for local alignment", 0 },
  { "--cykout",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "run CYKOutside, to make sure it agrees with CYK (Inside)", 0 },
  { "--sums",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "use posterior sums during HMM band calculation (widens bands)", 0 },
  { "--dlev",    eslARG_INT,    "0",   NULL, "0<=n<=3",NULL,NULL,NULL, "set verbosity of debugging print statements to <n>", 0 },
  { "--hmmcheck",eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "check that HMM posteriors are correctly calc'ed", 0 },
  { "--cmcheck", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "check that CM posteriors are correctly calc'ed", 0 },
  { "--optacc",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute optimal accuracy HMM banded alignment alg", 0 },
  { "--tau",     eslARG_REAL,   "5e-6",NULL, "0<x<1",NULL, NULL, NULL, "set tail loss prob for HMM bands to <x>", 0 },
  { "--post",   eslARG_NONE,    FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute fast float HMM banded Inside/Outside alignment algs", 0 },
  { "--mxsize",  eslARG_REAL, "256.0", NULL, "x>0.",NULL,  NULL, NULL, "set maximum allowable DP matrix size to <x> (Mb)", 0 },
  { "--nonbanded",eslARG_NONE,  FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute non-banded alignment algorithms", 0 },
  { "--tr",       eslARG_NONE,  FALSE, NULL, NULL,  NULL,  NULL, NULL, "dump parsetrees to stdout", 0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile> <seqfile>";
static char banner[] = "benchmark driver for fast HMM banded CYK alignment and scanning algorithm";

int
main(int argc, char **argv)
{
  int status;
  ESL_GETOPTS    *go      = esl_getopts_CreateDefaultApp(options, 2, argc, argv, banner, usage);
  CM_t           *cm;
  ESL_STOPWATCH  *w       = esl_stopwatch_Create();
  ESL_ALPHABET   *abc     = NULL;
  int             i;
  float           sc;
  float           pp;
  char           *cmfile  = esl_opt_GetArg(go, 1);
  char           *seqfile = esl_opt_GetArg(go, 2);
  CM_FILE        *cmfp  = NULL;  /* open input CM file stream */
  ESL_SQFILE     *sqfp  = NULL;  /* open sequence input file stream */
  ESL_SQ         *sq    = NULL;  /* a sequence */
  int             L;             /* length of sequence */
  char            errbuf[eslERRBUFSIZE];
  float           size_limit = esl_opt_GetReal(go, "--mxsize");
  int             do_check   = esl_opt_GetBoolean(go, "--cmcheck");
  float           parsetree_sc, parsetree_struct_sc;
  Parsetree_t    *tr    = NULL;

  /* open CM file */
  if ((status = cm_file_Open(cmfile, NULL, FALSE, &(cmfp), errbuf)) != eslOK) cm_Fail(errbuf);
  if ((status = cm_file_Read(cmfp, TRUE, &abc, &cm))                != eslOK) cm_Fail(cmfp->errbuf);
  cm_file_Close(cmfp);

  /* open the sequence file */
  status = esl_sqfile_OpenDigital(cm->abc, seqfile, eslSQFILE_UNKNOWN, NULL, &sqfp);
  if (status == eslENOTFOUND)    esl_fatal("File %s doesn't exist or is not readable\n", seqfile);
  else if (status == eslEFORMAT) esl_fatal("Couldn't determine format of sequence file %s\n", seqfile);
  else if (status == eslEINVAL)  esl_fatal("Can't autodetect stdin or .gz.");
  else if (status != eslOK)      esl_fatal("Sequence file open failed with error %d.\n", status);

  /* configure CM */
  cm->align_opts  |= CM_ALIGN_HBANDED;
  if(esl_opt_GetBoolean(go, "--sums")) cm->align_opts |= CM_ALIGN_SUMS;
  if(esl_opt_GetBoolean(go, "-l")) {
	cm->config_opts  |= CM_CONFIG_LOCAL;
	cm->config_opts  |= CM_CONFIG_HMMLOCAL;
	cm->config_opts  |= CM_CONFIG_HMMEL;
  }
  if(esl_opt_GetBoolean(go, "--hmmcheck")) cm->align_opts |= CM_ALIGN_CHECKFB;
  if(esl_opt_GetBoolean(go, "--cmcheck"))  cm->align_opts |= CM_ALIGN_CHECKINOUT;
  cm->tau = esl_opt_GetReal(go, "--tau");

  if((status = cm_Configure(cm, errbuf, -1)) != eslOK) cm_Fail(errbuf);

  /* setup logsum lookups (could do this only if nec based on options, but this is safer) */
  init_ilogsum();
  FLogsumInit();

  i = 0;
  sq = esl_sq_CreateDigital(cm->abc);
  while((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	i++;
	L = sq->n;

	esl_stopwatch_Start(w);
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, sq->dsq, 1, L, cm->cp9b, FALSE, PLI_PASS_STD_ANY, 0)) != eslOK) cm_Fail(errbuf);
	esl_stopwatch_Stop(w);
	printf("%4d %-30s %17s", i, "Exptl Band calc:", "");
	esl_stopwatch_Display(stdout, w, "CPU time: ");

	esl_stopwatch_Start(w);
	if((status = cm_AlignHB(cm, errbuf, sq->dsq, L, size_limit, FALSE, FALSE, cm->hb_mx, cm->hb_shmx, NULL, NULL, NULL, NULL, &tr, &pp, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", (i), "cm_AlignHB() CYK:", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");

	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, sq->dsq);
	ParsetreeScore(cm, NULL, NULL, tr, sq->dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);

	if(esl_opt_GetBoolean(go, "--cykout")) {
	  esl_stopwatch_Start(w);
	  if((status = cm_CYKOutsideAlignHB(cm, errbuf, sq->dsq, L, size_limit, TRUE, cm->hb_omx, cm->hb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i), "cm_Align() CYK:", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}

	if(esl_opt_GetBoolean(go, "--nonbanded")) {
	  esl_stopwatch_Start(w);
	  if((status = cm_Align(cm, errbuf, sq->dsq, L, size_limit, FALSE, FALSE, cm->nb_mx, cm->nb_shmx, NULL, cm->nb_emx, NULL, NULL, &tr, &pp, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i), "cm_Align() CYK:", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, sq->dsq);
	  ParsetreeScore(cm, NULL, NULL, tr, sq->dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	  FreeParsetree(tr);
	  printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);

	  if(esl_opt_GetBoolean(go, "--cykout")) {
	esl_stopwatch_Start(w);
	if((status = cm_CYKOutsideAlign(cm, errbuf, sq->dsq, L, size_limit, TRUE, cm->nb_omx, cm->nb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", (i), "cm_Align() CYK:", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	  }
	}
	printf("\n");

	if(esl_opt_GetBoolean(go, "--post")) {
	  esl_stopwatch_Start(w);
	  /* need alpha matrix from Inside to do Outside */
	  if((status = cm_InsideAlignHB(cm, errbuf, sq->dsq, L, size_limit, cm->hb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i), "cm_InsideAlignHB():", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  /* need alpha matrix from Inside to do Outside */
	  if((status = cm_OutsideAlignHB(cm, errbuf, sq->dsq, L, size_limit, do_check, cm->hb_omx, cm->hb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i), "cm_OutsideAlignHB():", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if(esl_opt_GetBoolean(go, "--nonbanded")) {
	esl_stopwatch_Start(w);
	/* need alpha matrix from Inside to do Outside */
	if((status = cm_InsideAlign(cm, errbuf, sq->dsq, L, size_limit, cm->nb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", (i), "cm_InsideAlign():", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");

	esl_stopwatch_Start(w);
	/* need alpha matrix from Inside to do Outside */
	if((status = cm_OutsideAlign(cm, errbuf, sq->dsq, L, size_limit, do_check, cm->nb_omx, cm->nb_mx, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", (i), "cm_OutsideAlign():", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	  }
	}

	if(esl_opt_GetBoolean(go, "--optacc")) {
	  esl_stopwatch_Start(w);
	  if((status = cm_AlignHB(cm, errbuf, sq->dsq, L, size_limit, TRUE, FALSE, cm->hb_mx, cm->hb_shmx, cm->hb_omx, cm->hb_emx, NULL, NULL, &tr, &pp, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f avgpp ", (i), "cm_AlignHB() OA:", pp);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, sq->dsq);
	  ParsetreeScore(cm, NULL, NULL, tr, sq->dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	  FreeParsetree(tr);
	  printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);

	  if(esl_opt_GetBoolean(go, "--nonbanded")) {
	esl_stopwatch_Start(w);
	if((status = cm_Align(cm, errbuf, sq->dsq, L, size_limit, TRUE, FALSE, cm->nb_mx, cm->nb_shmx, cm->nb_omx, cm->nb_emx, NULL, NULL, &tr, &pp, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f avgpp ", (i), "cm_Align() OA:", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");

	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, sq->dsq);
	ParsetreeScore(cm, NULL, NULL, tr, sq->dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);
	  }
	}
	printf("\n");
	esl_sq_Reuse(sq);
  }
  if(status != eslEOF) cm_Fail("ERROR reading sequence file, sequence number %d\n", i);

  FreeCM(cm);
  esl_sq_Destroy(sq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_getopts_Destroy(go);
  esl_sqfile_Close(sqfp);

  return 0;
}
#endif /*IMPL_ALIGN_BENCHMARK*/

/*** End of inlined file: cm_dpalign.c ***/


/*** Start of inlined file: cm_dpalign_trunc.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>


static int   cm_tr_alignT   (CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char optimal_mode, int pass_idx, int do_optacc, CM_TR_MX    *mx, CM_TR_SHADOW_MX    *shmx, CM_TR_EMIT_MX    *emit_mx, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc_or_pp);
static int   cm_tr_alignT_hb(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char optimal_mode, int pass_idx, int do_optacc, CM_TR_HB_MX *mx, CM_TR_HB_SHADOW_MX *shmx, CM_TR_HB_EMIT_MX *emit_mx, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc_or_pp);

/* Function: cm_tr_alignT()
 * Date:     EPN, Sat Sep 10 11:25:37 2011
 *           EPN, Sun Nov 18 19:21:30 2007 [cm_alignT()]
 *
 * Note:     based on insideT() [SRE, Fri Aug 11 12:08:18 2000 [Pittsburgh]]
 *
 * Purpose: Call either cm_TrCYKInsideAlign() (if !<do_optacc>), or
 *           cm_TrOptAccAlign() (if <do_optacc>), get vjd shadow
 *           matrix; then trace back and append to an existing but
 *           empty parsetree tr.  The full sequence 1..L will be
 *           aligned. This function is nearly identical to
 *           cm_tr_alignT_hb() with the important difference that HMM
 *           bands are not used here.
 *
 *           If <do_optacc>==TRUE then <emit_mx> must != NULL and
 *           <optimal_mode> must not be TRMODE_UNKNOWN, it will have been
 *           determined by caller from a cm_TrInsideAlign() call and
 *           passed in. If <do_optacc> is FALSE, then we're doing CYK
 *           alignment and we may or may not know the truncation mode
 *           of the alignment yet. If we know (e.g. if we're being
 *           called from a search/scan pipeline that already ran a
 *           scanning trCYK) then <optimal_mode> will be TRMODE_J,
 *           TRMODE_L, TRMODE_R or TRMODE_T, if not (e.g. if we're
 *           being called for 'cmalign') then <optimal_mode> will be
 *           TRMODE_UNKNOWN and we'll determine it via CYK.
 *
 * Args:     cm           - the model
 *           errbuf       - char buffer for reporting errors
 *           dsq          - the digitized sequence [1..L]
 *           L            - length of the dsq to align
 *           size_limit   - max size in Mb for DP matrix
 *           optimal_mode - the optimal alignment mode, TRMODE_UNKNOWN if unknown
 *           pass_idx     - pipeline pass index, indicates what truncation penalty to use
 *           do_optacc    - TRUE to align with optimal accuracy, else use CYK
 *           mx           - the DP matrix to fill in
 *           shmx         - the shadow matrix to fill in
 *           emit_mx      - the pre-filled emit matrix, must be non-NULL if do_optacc
 *           ret_tr       - RETURN: the optimal parsetree
 *           ret_mode     - RETURN: mode of optimal alignment (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc_or_pp - RETURN: optimal score (CYK if !do_optacc, else avg PP of all 1..L residues)
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>, in
 *                       this case, alignment has been aborted, ret_* variables are not valid
 *           <eslEINVAL> on invalid tro or traceback problem: bogus state
 */
int
cm_tr_alignT(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char optimal_mode, int pass_idx, int do_optacc,
			 CM_TR_MX *mx, CM_TR_SHADOW_MX *shmx, CM_TR_EMIT_MX *emit_mx, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc_or_pp)
{
  int       status;
  Parsetree_t *tr = NULL;       /* the parsetree */
  float     sc;			/* the score of the CYK alignment */
  float     pp;			/* avg pp of all emitted residues in optacc alignment */
  ESL_STACK *pda_i;             /* stack that tracks bifurc parent of a right start */
  ESL_STACK *pda_c;             /* stack that tracks mode of bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, seq positions */
  int       k;			/* right subtree len for bifurcs */
  int       y, yoffset;         /* child state y, it's offset */
  int       bifparent;          /* B_st parent */
  /* variables specific to truncated version */
  char      mode;               /* current truncation mode: TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T */
  char      prvmode, nxtmode;   /* previous, next truncation mode */
  int       b;                  /* local entry state for best overall alignment */
  int       pty_idx;            /* index for truncation penalty, determined by pass_idx */

  if(do_optacc) {
	if((status = cm_TrOptAccAlign(cm, errbuf, dsq, L,
				  size_limit,   /* max size of DP matrix */
				  optimal_mode, /* marginal mode of optimal alignment */
				  pass_idx,     /* truncation penalty index */
				  mx,	        /* the DP matrix, to expand and fill-in */
				  shmx,	        /* the shadow matrix, to expand and fill-in */
				  emit_mx,      /* pre-calc'ed emit matrix */
				  &b,           /* the entry point for optimal alignment */
				  &pp))         /* avg post prob of all emissions in optimally accurate parsetree */
	   != eslOK) return status;
	mode  = optimal_mode;
  }
  else {
	if((status = cm_TrCYKInsideAlign(cm, errbuf, dsq, L,
				     size_limit,         /* max size of DP matrix */
				     optimal_mode,       /* marginal mode of optimal alignment, TRMODE_UNKNOWN if unknown */
				     pass_idx,           /* truncation penalty index */
				     mx,                 /* the HMM banded mx */
				     shmx,	         /* the HMM banded shadow matrix */
				     &b,                 /* entry point for optimal alignment */
				     &mode, &sc))        /* mode (J,L,R or T) and score of CYK parsetree */
	   != eslOK) return status;
	optimal_mode = mode;
  }

  /* Create and initialize the parsetree */
  tr = CreateParsetree(100);
  /* set the 2 truncation-specific parsetree values:
   * is_std is always set to FALSE for truncation mode,
   * trpenalty is truncation penalty assessed in DP function, differs if we're local or global
   * and if we allowed 5' OR 3' truncations or 5' AND 3' truncations
   */
  tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
  tr->pass_idx = pass_idx;
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_alignT(), unexpected pass idx: %d", pass_idx);
  tr->trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][b] : cm->trp->g_ptyAA[pty_idx][b];
  InsertTraceNodewithMode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0, mode); /* init: attach the root S */

  pda_i = esl_stack_ICreate();
  pda_c = esl_stack_CCreate();
  if(pda_i == NULL) goto ERROR;
  if(pda_c == NULL) goto ERROR;
  v = 0;
  i = 1;
  j = d = L;

  while (1) {
#if eslDEBUGLEVEL >= 1
	if(cm->sttype[v] != EL_st) printf("v: %4d  mode: %4d  j: %4d d: %4d\n", v, mode, j, d);
	else                       printf("v: %4d  mode: %4d  j: %4d d: %4d EL\n", v, mode, j, d);
#endif

	if (cm->sttype[v] == B_st) {
	  /* get k, the len of right fragment */
	  if     (mode == TRMODE_J) k = shmx->Jkshadow[v][j][d];
	  else if(mode == TRMODE_L) k = shmx->Lkshadow[v][j][d];
	  else if(mode == TRMODE_R) k = shmx->Rkshadow[v][j][d];
	  else if(mode == TRMODE_T) k = shmx->Tkshadow[v][j][d];
	  else                      ESL_FAIL(eslEINVAL, errbuf, "bogus truncation mode for B state: %d\n", mode);
	  /* if k is 0, right fragment is of length 0 */
	  /* determine mode of right child */
	  prvmode = mode;
	  if     (mode == TRMODE_J) ; /* do nothing, in J mode, right child mode remains TRMODE_J */
	  else if(mode == TRMODE_L) mode = TRMODE_L; /* in TRMODE_L, right child is always Left marginal */
	  else if(mode == TRMODE_R) mode = shmx->Rkmode[v][j][d];
	  else if(mode == TRMODE_T) mode = TRMODE_L; /* in TRMODE_T, right child is always Left marginal */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_CPush(pda_c, mode))    != eslOK) goto ERROR;  /* remember the mode of right child */
	  if((status = esl_stack_IPush(pda_i, j))       != eslOK) goto ERROR;  /* remember the end j    */
	  if((status = esl_stack_IPush(pda_i, k))       != eslOK) goto ERROR;  /* remember the subseq length k for right child */
	  if((status = esl_stack_IPush(pda_i, tr->n-1)) != eslOK) goto ERROR;  /* remember the trace index of the parent B state */

	  /* Determine mode of left start state */
	  if     (prvmode == TRMODE_J) mode = TRMODE_J;
	  else if(prvmode == TRMODE_L) mode = shmx->Lkmode[v][j][d];
	  else if(prvmode == TRMODE_R) mode = TRMODE_R; /* for R mode, left child is always Right marginal */
	  else if(prvmode == TRMODE_T) mode = TRMODE_R; /* for T mode, left child is always Right marginal */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;

	  y = cm->cfirst[v];
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, mode);
	  v = y;

#if eslDEBUGLEVEL >= 2
	  printf("added BEGL_S, dumping parsetree (prvmode: %d mode: %d:\n", prvmode, mode);
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif
	} else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda_i, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda_i, &d);
	  esl_stack_IPop(pda_i, &j);
	  esl_stack_CPop(pda_c, &mode);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNodewithMode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y, mode);
#if eslDEBUGLEVEL >= 2
	  printf("added E or EL, dumping parsetree:\n");
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif

	  v = y;
	}
	else {
	  /* get yoffset */
	  if     (mode == TRMODE_J) yoffset = shmx->Jyshadow[v][j][d];
	  else if(mode == TRMODE_L) yoffset = shmx->Lyshadow[v][j][d];
	  else if(mode == TRMODE_R) yoffset = shmx->Ryshadow[v][j][d];
	  else if(mode == TRMODE_T) {
	/* v==0 is a special case, must be a local begin (shmx->Tyshadow[] doesn't exist) */
	if(v == 0) yoffset = USED_TRUNC_BEGIN;
	else       ESL_FAIL(eslEINVAL, errbuf, "truncation mode T for non B, not ROOT_S state");
	  }
	  else {
		ESL_FAIL(eslEINVAL, errbuf, "bogus truncation mode %d\n", mode);
	  }
#if eslDEBUGLEVEL >= 2
	  printf("v: %d std mode: %d yoffset: %d ", v, mode, yoffset);
#endif
	  /* determine nxtmode, and correct yoffset */
	  if     (yoffset == USED_TRUNC_BEGIN) { yoffset = USED_TRUNC_BEGIN; nxtmode = mode; } /* yoffset, mode don't change */
	  else if(yoffset == USED_TRUNC_END)   { yoffset = USED_TRUNC_END;   } /* nxtmode is irrelevant in this case */
	  else if(yoffset == USED_EL)          { yoffset = USED_EL;          } /* nxtmode is irrelevant in this case */
	  else if(yoffset >= TRMODE_R_OFFSET)  { nxtmode = TRMODE_R; yoffset -= TRMODE_R_OFFSET; }
	  else if(yoffset >= TRMODE_L_OFFSET)  { nxtmode = TRMODE_L; yoffset -= TRMODE_L_OFFSET; }
	  else if(yoffset >= TRMODE_J_OFFSET)  { nxtmode = TRMODE_J; yoffset -= TRMODE_J_OFFSET; }
	  else                                  ESL_FAIL(eslEINVAL, errbuf, "yoffset out of bounds: %d\n", yoffset);
#if eslDEBUGLEVEL >= 2
	  printf("new yoffset: %d nxtmode: %d\n", yoffset, nxtmode);
	  if(mode == TRMODE_J) printf("HEYA J v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
	  if(mode == TRMODE_L) printf("HEYA L v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
	  if(mode == TRMODE_R) printf("HEYA R v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
#endif
	  switch (cm->sttype[v]) {
	  case  D_st:
	break;
	  case MP_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case ML_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	break;
	  case MR_st:
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case IL_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	break;
	  case IR_st:
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case  S_st:
	break;
	  default: ESL_FAIL(eslEINVAL, errbuf, "bogus state type %d \n", cm->sttype[v]);
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL || yoffset == USED_TRUNC_END)
	{	/* a local alignment end  or a truncation end */
	  if(yoffset == USED_EL) {
	    InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M, mode);
#if eslDEBUGLEVEL >= 2
	    printf("added USED_EL or USED_TRUNC_END, dumping parsetree:\n");
	    ParsetreeDump(stdout, tr, cm, dsq);
#endif
	  }
	  v = cm->M;		/* now we're in EL (if USED_TRUNC_END, we act like we are) */
	}
	  else if (yoffset == USED_TRUNC_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b, mode);
	  v = b;
	}
	  else
	{
	  mode = nxtmode;
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, mode);
#if eslDEBUGLEVEL >= 2
	  printf("STD yoffset: %d\n", yoffset);
	  printf("added standard, dumping parsetree:\n");
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif
	  v = y;
	}
	}
  }
  esl_stack_Destroy(pda_i);  /* it should be empty; we could check; naaah. */
  esl_stack_Destroy(pda_c);  /* it should be empty; we could check; naaah. */

  if(ret_tr       != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_mode     != NULL) *ret_mode = optimal_mode;
  if(ret_sc_or_pp != NULL) *ret_sc_or_pp = do_optacc ? pp : sc;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: cm_tr_alignT_hb()
 * Date:     EPN, Thu Sep  8 07:59:10 2011
 *           EPN 03.29.06 (cm_alignT_hb())
 *
 * Purpose:  Call either cm_TrCYKInsideAlignHB() (if !<do_optacc>), or
 *           cm_TrOptAccAlignHB() (if <do_optacc>), get vjd shadow
 *           matrix; then trace back and append to an existing but
 *           empty parsetree tr.  The full sequence 1..L will be
 *           aligned. This function is nearly identical to
 *           cm_tr_alignT() with the important difference that HMM
 *           bands are used here.
 *
 *           If <do_optacc>==TRUE then <emit_mx> must != NULL and
 *           <optimal_mode> must not be TRMODE_UNKNOWN, it will have been
 *           determined by caller from a cm_TrInsideAlign() call and
 *           passed in. If <do_optacc> is FALSE, then we're doing CYK
 *           alignment and we may or may not know the truncation mode
 *           of the alignment yet. If we know (e.g. if we're being
 *           called from a search/scan pipeline that already ran a
 *           scanning trCYK) then <optimal_mode> will be TRMODE_J,
 *           TRMODE_L, TRMODE_R or TRMODE_T, if not (e.g. if we're
 *           being called for 'cmalign') then <optimal_mode> will be
 *           TRMODE_UNKNOWN and we'll determine it via CYK.
 *
 * Args:     cm           - the model
 *           errbuf       - char buffer for reporting errors
 *           dsq          - the digitized sequence [1..L]
 *           L            - length of the dsq to align
 *           size_limit   - max size in Mb for DP matrix
 *           optimal_mode - the optimal alignment mode, TRMODE_UNKNOWN if unknown
 *           pass_idx     - pipeline pass index, indicates what truncation penalty to use
 *           do_optacc    - TRUE to align with optimal accuracy, else use CYK
 *           mx           - the DP matrix to fill in
 *           shmx         - the shadow matrix to fill in
 *           emit_mx      - the pre-filled emit matrix, must be non-NULL if do_optacc
 *           ret_tr       - RETURN: the optimal parsetree
 *           ret_mode     - RETURN: mode of optimal alignment (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc_or_pp - RETURN: optimal score (CYK if !do_optacc, else avg PP of all 1..L residues)
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>, in
 *                       this case, alignment has been aborted, ret_* variables are not valid
 *           <eslEINVAL> on invalide tro or traceback problem: bogus state
 */
int
cm_tr_alignT_hb(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char optimal_mode, int pass_idx, int do_optacc,
				CM_TR_HB_MX *mx, CM_TR_HB_SHADOW_MX *shmx, CM_TR_HB_EMIT_MX *emit_mx, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc_or_pp)
{
  int       status;
  Parsetree_t *tr = NULL;       /* the parsetree */
  float     sc;			/* the score of the CYK alignment */
  float     pp;			/* avg pp of all emitted residues in optacc alignment */
  ESL_STACK *pda_i;             /* stack that tracks bifurc parent of a right start */
  ESL_STACK *pda_c;             /* stack that tracks mode of bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, seq positions */
  int       k;			/* right subtree len for bifurcs */
  int       y, yoffset;         /* child state y, it's offset */
  int       bifparent;          /* B_st parent */
  int       jp_v;               /* j-jmin[v] for current j, and current v */
  int       dp_v;               /* d-hdmin[v][jp_v] for current j, current v, current d*/
  char      mode;               /* current truncation mode: TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T */
  char      prvmode, nxtmode;   /* previous, next truncation mode */
  int       allow_S_trunc_end;  /* set to true to allow d==0 BEGL_S and BEGR_S truncated ends */
  int       allow_S_local_end;  /* set to true to allow d==0 BEGL_S and BEGR_S local ends if(do_optacc) */
  int       b;                  /* local entry state for best overall alignment */
  int       pty_idx;            /* index for truncation penalty, determined by pass_idx */

  /* pointers to cp9b data for convenience */
  CP9Bands_t  *cp9b = cm->cp9b;
  int         *jmin = cp9b->jmin;
  int         *jmax = cp9b->jmax;
  int       **hdmin = cp9b->hdmin;
  int       **hdmax = cp9b->hdmax;

  /* ensure full sequence is within bands */
  if (cp9b->jmin[0]             > L || cp9b->jmax[0]             < L) ESL_FAIL(eslEINVAL, errbuf, "cm_tr_alignT_hb(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  if (cp9b->hdmin[0][L-jmin[0]] > L || cp9b->hdmax[0][L-jmin[0]] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_tr_alignT_hb(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][L-jmin[0]], cp9b->hdmax[0][L-jmin[0]]);

  if(do_optacc) {
	if((status = cm_TrOptAccAlignHB(cm, errbuf, dsq, L,
				    size_limit,   /* max size of DP matrix */
				    optimal_mode, /* marginal mode of optimal alignment */
				    pass_idx,     /* truncation penalty index */
				    mx,	          /* the DP matrix, to expand and fill-in */
				    shmx,	  /* the shadow matrix, to expand and fill-in */
				    emit_mx,      /* pre-calc'ed emit matrix */
				    &b,           /* the entry point for optimal alignment */
				    &pp))         /* avg post prob of all emissions in optimally accurate parsetree */
	   != eslOK) return status;
	mode = optimal_mode;
  }
  else {
	if((status = cm_TrCYKInsideAlignHB(cm, errbuf, dsq, L,
				       size_limit,         /* max size of DP matrix */
				       optimal_mode,       /* marginal mode of optimal alignment, TRMODE_UNKNOWN if unknown */
				       pass_idx,           /* truncation penalty index */
				       mx,                 /* the HMM banded mx */
				       shmx,	           /* the HMM banded shadow matrix */
				       &b,                 /* entry point for optimal alignment */
				       &mode, &sc))        /* mode (J,L,R or T) and score of CYK parsetree */
	   != eslOK) return status;
	optimal_mode = mode;
  }

  /* Create and initialize the parsetree */
  tr = CreateParsetree(100);
  /* set the 2 truncation-specific parsetree values:
   * is_std is always set to FALSE for truncation mode,
   * trpenalty is truncation penalty assessed in DP function, differs if we're local or global
   * and if we allowed 5' OR 3' truncations or 5' AND 3' truncations
   */
  tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
  tr->pass_idx = pass_idx;
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_alignT_hb(), unexpected pass idx: %d", pass_idx);
  tr->trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][b] : cm->trp->g_ptyAA[pty_idx][b];
  InsertTraceNodewithMode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0, mode); /* init: attach the root S */

  pda_i = esl_stack_ICreate();
  pda_c = esl_stack_CCreate();
  if(pda_i == NULL) goto ERROR;
  if(pda_c == NULL) goto ERROR;
  v = 0;
  i = 1;
  j = d = L;

  while (1) {
#if eslDEBUGLEVEL >= 1
	if(cm->sttype[v] != EL_st) printf("v: %4d  mode: %4d  j: %4d (%4d..%4d)  d: %4d\n", v, mode, j, jmin[v], jmax[v], d);
	else                       printf("v: %4d  mode: %4d  j: %4d             d: %4d EL\n", v, mode, j, d);
#endif
	/* super special case for HMM banded truncated mode, explained below, after the crazy if */
	if((cm->stid[v] == BEGL_S || cm->stid[v] == BEGR_S) && d == 0 &&
	   ((mode == TRMODE_J && (! cp9b->Jvalid[v]))  ||            /* J mode, but J mode is disallowed for state v */
	(mode == TRMODE_L && (! cp9b->Lvalid[v]))  ||            /* L mode, but L mode is disallowed for state v */
	(mode == TRMODE_R && (! cp9b->Rvalid[v]))  ||            /* R mode, but R mode is disallowed for state v */
	(j < jmin[v]             || j > jmax[v]) ||              /* j is outside v's j band */
	(d < hdmin[v][j-jmin[v]] || d > hdmax[v][j-jmin[v]]))) { /* j is within v's j band, but d is outside j's d band */
	  /* special case: v is a BEGL_S or BEGR_S and either we're in a
	   * truncated alignment mode for v that is disallowed by the
	   * bands or j is outside v's j band or j is within the band but
	   * d is outside j's d band.  We allow this case if d == 0 b/c
	   * we're doing a truncated end out of this state immediately,
	   * i.e. we're not really using the state at all we're just using
	   * it so we can use its parent B state and its sister left or
	   * right start state. This only occurs if the parent bif state
	   * emitted the full sequence via the other child (BEGR_S or
	   * BEGL_S).
	   *
	   * This will usually occur if v is a BEGL_S and we're in R mode,
	   * or v is a BEGR_S and we're in L mode, but not always. We need
	   * to also allow a similar case that also occurs in
	   * *non-truncated* optimal accuracy alignment. See
	   * cm_dpalign.c::cm_alignT_hb() at the analogous point in that
	   * function for details.
	   */
	  ESL_DASSERT1(((cm->stid[v] == BEGL_S && mode == TRMODE_R) || (cm->stid[v] == BEGR_S && mode == TRMODE_L)));
	  if((cm->stid[v] == BEGL_S && mode == TRMODE_R) || (cm->stid[v] == BEGR_S && mode == TRMODE_L)) {
	allow_S_trunc_end = TRUE; /* this sets yoffset to USED_TRUNC_END in the final 'else' of below code block */
	allow_S_local_end = FALSE;
	  }
	  else if (do_optacc) {
	allow_S_local_end = TRUE; /* this sets yoffset to USED_EL in the final 'else' of below code block */
	allow_S_trunc_end = FALSE;
	  }
	}
	else if (cm->sttype[v] != EL_st) { /* normal case, determine jp_v, dp_v; j, d offset values given bands */
	  jp_v = j - jmin[v];
	  dp_v = d - hdmin[v][jp_v];
	  allow_S_trunc_end = FALSE;
	  allow_S_local_end = FALSE;
	  assert(j >= jmin[v]        && j <= jmax[v]);
	  assert(d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]);
	  ESL_DASSERT1((j >= jmin[v]        && j <= jmax[v]));
	  ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	}

	if (cm->sttype[v] == B_st) {
	  /* get k, the len of right fragment */
	  if     (mode == TRMODE_J) k = shmx->Jkshadow[v][jp_v][dp_v];
	  else if(mode == TRMODE_L) k = shmx->Lkshadow[v][jp_v][dp_v];
	  else if(mode == TRMODE_R) k = shmx->Rkshadow[v][jp_v][dp_v];
	  else if(mode == TRMODE_T) k = shmx->Tkshadow[v][jp_v][dp_v];
	  else                           ESL_FAIL(eslEINVAL, errbuf, "bogus truncation mode for B state: %d\n", mode);
	  /* if k is 0, right fragment is of length 0 */
	  /* determine mode of right child */
	  prvmode = mode;
	  if     (mode == TRMODE_J) ; /* do nothing, in J mode, right child mode remains TRMODE_J */
	  else if(mode == TRMODE_L) mode = TRMODE_L; /* in TRMODE_L, right child is always Left marginal */
	  else if(mode == TRMODE_R) mode = shmx->Rkmode[v][jp_v][dp_v];
	  else if(mode == TRMODE_T) mode = TRMODE_L; /* in TRMODE_T, right child is always Left marginal */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_CPush(pda_c, mode))    != eslOK) goto ERROR;  /* remember the mode of right child */
	  if((status = esl_stack_IPush(pda_i, j))       != eslOK) goto ERROR;  /* remember the end j    */
	  if((status = esl_stack_IPush(pda_i, k))       != eslOK) goto ERROR;  /* remember the subseq length k for right child */
	  if((status = esl_stack_IPush(pda_i, tr->n-1)) != eslOK) goto ERROR;  /* remember the trace index of the parent B state */

	  /* Determine mode of left start state */
	  if     (prvmode == TRMODE_J) mode = TRMODE_J;
	  else if(prvmode == TRMODE_L) mode = shmx->Lkmode[v][jp_v][dp_v];
	  else if(prvmode == TRMODE_R) mode = TRMODE_R; /* for R mode, left child is always Right marginal */
	  else if(prvmode == TRMODE_T) mode = TRMODE_R; /* for T mode, left child is always Right marginal */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;

	  y = cm->cfirst[v];
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, mode);
	  v = y;

#if eslDEBUGLEVEL >= 2
	  printf("added BEGL_S, dumping parsetree (prvmode: %d mode: %d:\n", prvmode, mode);
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda_i, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda_i, &d);
	  esl_stack_IPop(pda_i, &j);
	  esl_stack_CPop(pda_c, &mode);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNodewithMode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y, mode);
#if eslDEBUGLEVEL >= 2
	  printf("added E or EL, dumping parsetree:\n");
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif

	  v = y;
	}
	else {
	  /* get yoffset */
	  if(allow_S_trunc_end) {
	yoffset = USED_TRUNC_END; /* nxt mode is irrelevant in this case */
	  }
	  else if(allow_S_local_end) {
	yoffset = USED_EL; /* nxt mode is irrelevant in this case */
	  }
	  else {
	if     (mode == TRMODE_J) yoffset = shmx->Jyshadow[v][jp_v][dp_v];
	else if(mode == TRMODE_L) yoffset = shmx->Lyshadow[v][jp_v][dp_v];
	else if(mode == TRMODE_R) yoffset = shmx->Ryshadow[v][jp_v][dp_v];
	else if(mode == TRMODE_T) {
	  /* v==0 is a special case, must be a local begin (shmx->Tyshadow[] doesn't exist) */
	  if(v == 0) yoffset = USED_TRUNC_BEGIN;
	  else       ESL_FAIL(eslEINVAL, errbuf, "truncation mode T for non B, not ROOT_S state");
	}
	else {
	  ESL_FAIL(eslEINVAL, errbuf, "bogus truncation mode %d\n", mode);
	}
	  }
#if eslDEBUGLEVEL >= 2
	  printf("v: %d std mode: %d yoffset: %d ", v, mode, yoffset);
#endif
	  /* determine nxtmode, and correct yoffset */
	  if     (yoffset == USED_TRUNC_BEGIN) { yoffset = USED_TRUNC_BEGIN; nxtmode = mode; } /* yoffset, mode don't change */
	  else if(yoffset == USED_TRUNC_END)   { yoffset = USED_TRUNC_END; } /* nxtmode is irrelevant in this case */
	  else if(yoffset == USED_EL)          { yoffset = USED_EL;        } /* nxtmode is irrelevant in this case */
	  else if(yoffset >= TRMODE_R_OFFSET)  { nxtmode = TRMODE_R; yoffset -= TRMODE_R_OFFSET; }
	  else if(yoffset >= TRMODE_L_OFFSET)  { nxtmode = TRMODE_L; yoffset -= TRMODE_L_OFFSET; }
	  else if(yoffset >= TRMODE_J_OFFSET)  { nxtmode = TRMODE_J; yoffset -= TRMODE_J_OFFSET; }
	  else                                  ESL_FAIL(eslEINVAL, errbuf, "yoffset out of bounds: %d\n", yoffset);
#if eslDEBUGLEVEL >= 2
	  printf("new yoffset: %d nxtmode: %d\n", yoffset, nxtmode);
	  if(mode == TRMODE_J) printf("HEYA J v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
	  if(mode == TRMODE_L) printf("HEYA L v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
	  if(mode == TRMODE_R) printf("HEYA R v: %4d j: %4d d: %4d mode: %4d yoffset: %4d nxtmode: %4d\n", v, j, d, mode, yoffset, nxtmode);
#endif
	  switch (cm->sttype[v]) {
	  case  D_st:
	break;
	  case MP_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case ML_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	break;
	  case MR_st:
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case IL_st:
	if ( mode == TRMODE_J )          i++;
	if ( mode == TRMODE_L && d > 0 ) i++;
	break;
	  case IR_st:
	if ( mode == TRMODE_J )          j--;
	if ( mode == TRMODE_R && d > 0 ) j--;
	break;
	  case  S_st:
	break;
	  default: ESL_FAIL(eslEINVAL, errbuf, "bogus state type %d \n", cm->sttype[v]);
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL || yoffset == USED_TRUNC_END)
	{	/* a local alignment end  or a truncation end */
	  if(yoffset == USED_EL) {
	    InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M, mode);
#if eslDEBUGLEVEL >= 2
	    printf("added USED_EL or USED_TRUNC_END, dumping parsetree:\n");
	    ParsetreeDump(stdout, tr, cm, dsq);
#endif
	  }
	  v = cm->M; /* now we're in EL (if USED_TRUNC_END, we act like we are) */
	}
	  else if (yoffset == USED_TRUNC_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b, mode);
	  v = b;
	}
	  else
	{
	  mode = nxtmode;
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, mode);
#if eslDEBUGLEVEL >= 2
	  printf("STD yoffset: %d\n", yoffset);
	  printf("added standard, dumping parsetree:\n");
	  ParsetreeDump(stdout, tr, cm, dsq);
#endif
	  v    = y;
	}
	}
	/*ParsetreeDump(stdout, tr, cm, dsq);*/
  }
  esl_stack_Destroy(pda_i);  /* it should be empty; we could check; naaah. */
  esl_stack_Destroy(pda_c);  /* it should be empty; we could check; naaah. */

  if(ret_tr       != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_mode     != NULL) *ret_mode = optimal_mode;
  if(ret_sc_or_pp != NULL) *ret_sc_or_pp = do_optacc ? pp : sc;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: cm_TrAlignSizeNeeded()
 * Date:     EPN, Thu Jan 12 10:15:08 2012
 *
 * Purpose:  Determine size in Mb required to successfully call
 *           cm_TrAlign() for a given model <cm>, sequence length
 *           <L> and alignment options in <do_sample> and <do_post>.
 *
 *           We are ignorant of any preset marginal alignment mode,
 *           because that doesn't affect how the matrices are
 *           allocated (although it can affect which cells are filled
 *           in).
 *
 *           Return <eslERANGE> if required size exceeds size_limit.
 *
 * Args:     cm         - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of sequence
 *           size_limit - max size in Mb for all required matrices, return eslERANGE if exceeded
 *           do_sample  - TRUE to sample a parsetree from the Inside matrix
 *           do_post    - TRUE to do posteriors
 *           ret_mxmb   - RETURN: size in Mb of required CM_TR_MX (we'll need 2 of these if do_post)
 *           ret_emxmb  - RETURN: size in Mb of required CM_TR_EMIT_MX   (0. if we won't need one)
 *           ret_shmxmb - RETURN: size in Mb of required CM_TR_SHADOW_MX (0. if we won't need one)
 *           ret_totmb  - RETURN: size in Mb of all required matrices
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if total size of all matrices exceeds <size_limit>
 */
int
cm_TrAlignSizeNeeded(CM_t *cm, char *errbuf, int L, float size_limit, int do_sample, int do_post,
		     float *ret_mxmb, float *ret_emxmb, float *ret_shmxmb, float *ret_totmb)
{
  int          status;
  float        totmb    = 0.;  /* total Mb required for all matrices (that must be simultaneously in memory) */
  float        mxmb     = 0.;  /* Mb required for CM_MX */
  float        emxmb    = 0.;  /* Mb required for CM_EMIT_MX */
  float        shmxmb   = 0.;  /* Mb required for CM_SHADOW_MX */

  /* we pass NULL values to the *_mx_SizeNeeded() functions because we don't care about cell counts */

  /* we will always need an Inside or CYK matrix */
  if((status = cm_tr_mx_SizeNeeded(cm, errbuf, L, NULL, NULL, NULL, NULL, &mxmb)) != eslOK) return status;
  totmb = mxmb;

  /* if calc'ing posteriors, we'll also need an Outside matrix (which
   * we'll reuse as the Posterior matrix, so only count it once) and
   * an emit matrix.
   */
  if(do_post) {
	totmb += mxmb;
	if((status = cm_tr_emit_mx_SizeNeeded(cm, errbuf, L, NULL, NULL, &emxmb)) != eslOK) return status;
	totmb += emxmb;
  }

  /* if we're not sampling an alignment, we'll also need a shadow
   * matrix for the traceback.
   */
  if(! do_sample) {
	if((status = cm_tr_shadow_mx_SizeNeeded(cm, errbuf, L, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &shmxmb)) != eslOK) return status;
	totmb += shmxmb;
  }

  if (ret_mxmb   != NULL) *ret_mxmb    = mxmb;
  if (ret_emxmb  != NULL) *ret_emxmb   = emxmb;
  if (ret_shmxmb != NULL) *ret_shmxmb  = shmxmb;
  if (ret_totmb  != NULL) *ret_totmb   = totmb;

#if eslDEBUGLEVEL >= 1
  printf("cm_TrAlignSizeNeeded()\n");
  printf("\t mxmb:  %.2f\n", mxmb);
  printf("\t emxmb: %.2f\n", emxmb);
  printf("\t shmxmb:%.2f\n", shmxmb);
  printf("\t totmb: %.2f\n", totmb);
  printf("\t limit: %.2f\n", size_limit);
#endif

  if(totmb > size_limit) ESL_FAIL(eslERANGE, errbuf, "non-banded truncated alignment mxes need %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", totmb, (float) size_limit);

  return eslOK;
}

/* Function: cm_TrAlignSizeNeededHB()
 * Date:     EPN, Thu Jan 12 10:24:20 2012
 *
 * Purpose:  Determine size in Mb required to successfully call
 *           cm_TrAlignHB() for a given model <cm>, sequence length
 *           <L>, HMM bands <cm->cp9b> and alignment options
 *           in <do_sample> and <do_post>.
 *
 *           We are ignorant of any preset marginal alignment mode,
 *           because that doesn't affect how the matrices are
 *           allocated (although it can affect which cells are filled
 *           in).
 *
 *           Return <eslERANGE> if required size exceeds size_limit.
 *
 * Args:     cm         - the covariance model
 *           errbuf     - char buffer for reporting errors
 *           L          - length of sequence
 *           size_limit - max size in Mb for all required matrices, return eslERANGE if exceeded
 *           do_sample  - TRUE to sample a parsetree from the Inside matrix
 *           do_post    - TRUE to do posteriors
 *           ret_mxmb   - RETURN: size in Mb of required CM_TR_HB_MX (we'll need 2 of these if do_post)
 *           ret_emxmb  - RETURN: size in Mb of required CM_TR_HB_EMIT_MX   (0. if we won't need one)
 *           ret_shmxmb - RETURN: size in Mb of required CM_TR_HB_SHADOW_MX (0. if we won't need one)
 *           ret_totmb  - RETURN: size in Mb of all required matrices
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if total size of all matrices exceeds <size_limit>
 */
int
cm_TrAlignSizeNeededHB(CM_t *cm, char *errbuf, int L, float size_limit, int do_sample, int do_post,
		       float *ret_mxmb, float *ret_emxmb, float *ret_shmxmb, float *ret_totmb)
{
  int          status;
  float        totmb    = 0.;  /* total Mb required for all matrices (that must be simultaneously in memory) */
  float        mxmb     = 0.;  /* Mb required for CM_MX */
  float        emxmb    = 0.;  /* Mb required for CM_EMIT_MX */
  float        shmxmb   = 0.;  /* Mb required for CM_SHADOW_MX */

  /* we pass NULL values to the *_mx_SizeNeeded() functions because we don't care about cell counts */

  /* we will always need an Inside or CYK matrix */
  if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, NULL, NULL, &mxmb)) != eslOK) return status;
  totmb = mxmb;

  /* if calc'ing posteriors, we'll also need an Outside matrix (which
   * we'll reuse as the Posterior matrix, so only count it once) and
   * an emit matrix.
   */
  if(do_post) {
	totmb += mxmb;
	if((status = cm_tr_hb_emit_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, &emxmb)) != eslOK) return status;
	totmb += emxmb;
  }

  /* if we're not sampling an alignment, we'll also need a shadow
   * matrix for the traceback.
   */
  if(! do_sample) {
	if((status = cm_tr_hb_shadow_mx_SizeNeeded(cm, errbuf, cm->cp9b, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &shmxmb)) != eslOK) return status;
	totmb += shmxmb;
  }

  if (ret_mxmb   != NULL) *ret_mxmb    = mxmb;
  if (ret_emxmb  != NULL) *ret_emxmb   = emxmb;
  if (ret_shmxmb != NULL) *ret_shmxmb  = shmxmb;
  if (ret_totmb  != NULL) *ret_totmb   = totmb;

#if eslDEBUGLEVEL >= 1
  printf("cm_TrAlignSizeNeededHB()\n");
  printf("\t mxmb:  %.2f\n", mxmb);
  printf("\t emxmb: %.2f\n", emxmb);
  printf("\t shmxmb:%.2f\n", shmxmb);
  printf("\t totmb: %.2f\n", totmb);
  printf("\t limit: %.2f\n", size_limit);
#endif

  /*printf("cm_TrAlignSizeNeededHB() returning %.2f\n", mxmb);*/

  if(totmb > size_limit) ESL_FAIL(eslERANGE, errbuf, "HMM banded truncated alignment mxes need %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", totmb, (float) size_limit);

  return eslOK;
}

/* Function: cm_TrAlign()
 * Incept:   EPN, Sat Sep 10 12:58:09 2011
 *
 * Purpose: Wrapper for the cm_tr_alignTb() routine - solve a full
 *           alignment problem using trCYK, truncated optimal accuracy
 *           or sampling and return the traceback and the score.
 *
 *           Identical to cm_TrAlignHB() but HMM bands are not used here.
 *
 *           Input arguments allow this function to be run in 6 'modes':
 *
 *           mode      returns                 arguments
 *           ----  ----------------  ----------------------------------------
 *                 tr        ppstrs  do_optacc  do_sample post_mx   ret_ppstr
 *                 ----------------  ----------------------------------------
 *              1. CYK       no      FALSE      FALSE      NULL      NULL
 *              2. CYK       yes     FALSE      FALSE     !NULL     !NULL
 *              3. Opt acc   no      TRUE       FALSE     !NULL      NULL
 *              4. Opt acc   yes     TRUE       FALSE     !NULL     !NULL
 *              5. sampled   no      FALSE      TRUE       NULL      NULL
 *              6. sampled   yes     FALSE      TRUE      !NULL     !NULL
 *
 *           CYK parsetrees are most the likely parsetree, 'Opt acc'
 *           parsetrees are Holmes/Durbin optimally accurate
 *           parsetrees, the parse that maximizes the summed posterior
 *           probability of emitted residues. A sampled parsetree
 *           is a parsetree sampled from an Inside matrix based on
 *           its probability.
 *
 *           We can enforce that the parsetree found be in a
 *           particular marginal alignment mode via a <preset_mode>
 *           value other than TRMODE_UNKNOWN. This can be useful we're
 *           called from a search/scan pipeline and a scanning
 *           truncated DP search algorithm has already determined the
 *           optimal truncation mode for the alignment, as we'll save
 *           time by only performing the required DP calculations for
 *           that mode in the DP functions we call here. In that case,
 *           <ret_mode> will necessarily be equal to <preset_mode>.
 *           Alternatively, if <preset_mode> is TRMODE_UNKNOWN then
 *           we'll determine it here and return a known mode (TRMODE_J
 *           | TRMODE_L | TRMODE_R | TRMODE_T) in <ret_mode>.
 *
 * Args:     cm          - the covariance model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence, 1..L
 *           L           - length of sequence
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the alignment mode to enforce, if TRMODE_UNKNOWN we determine mode here
 *           pass_idx     - pipeline pass index, indicates what truncation penalty to use
 *           do_optacc   - TRUE to not do CYK alignment, determine the Holmes/Durbin optimally
 *                         accurate parsetree in ret_tr, requires post_mx != NULL
 *           do_sample   - TRUE to sample a parsetree from the Inside matrix
 *           mx          - the main dp matrix, only cells within bands in cm->cp9b will be valid.
 *           shmx        - the HMM banded shadow matrix to fill in and traceback, same cells as mx are valid.
 *           post_mx     - dp matrix for posterior calculation, can be NULL only if !do_optacc
 *           emit_mx     - emit matrix to fill
 *           r           - source of randomness, must be non-NULL only if do_sample==TRUE
 *           ret_ppstr   - RETURN: posterior code 1, (pass NULL if not wanted, must be NULL if post_mx == NULL)
 *           ret_tr      - RETURN: parsetree (either optimal or sampled, pass NULL if not wanted)
 *           ret_mode    - RETURN: mode of ret_tr, will be <preset_mode> unless that was TRMODE_UNKNOWN
 *           ret_avgpp   - RETURN: avg PP of emitted residues in parsetree (CYK or optacc) if ret_ppstr == NULL, set as 0.
 *           ret_sc      - RETURN: score of the alignment in bits (Inside score if do_optacc)
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if required CM_TR_MX for Inside/Outside/CYK/Posterior exceeds <size_limit>
 */
int
cm_TrAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
	   int do_optacc, int do_sample, CM_TR_MX *mx, CM_TR_SHADOW_MX *shmx, CM_TR_MX *post_mx,
	   CM_TR_EMIT_MX *emit_mx, ESL_RANDOMNESS *r, char **ret_ppstr, Parsetree_t **ret_tr,
	   char *ret_mode, float *ret_avgpp, float *ret_sc)
{
  int          status;
  Parsetree_t *tr = NULL;
  float        sc     = 0.;
  float        avgpp  = 0.;
  float        ins_sc = 0.;
  int          do_post;
  char        *ppstr = NULL;
  int          have_ppstr;
  char         mode = TRMODE_UNKNOWN;  /* mode of tr, <ret_mode> set as this */

  have_ppstr = (ret_ppstr != NULL)       ? TRUE : FALSE;
  do_post    = (do_optacc || have_ppstr) ? TRUE : FALSE;

  /* Contract check */
  if(do_optacc && do_sample)         ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlign(), do_optacc and do_sample are both TRUE.");
  if(do_optacc && post_mx == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlign(), do_optacc is TRUE, but post_mx == NULL.\n");
  if(do_sample && r       == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlign(), do_sample but r is NULL.");

  /* if do_post:   fill Inside, Outside, Posterior matrices, in that order.
   * if do_sample: fill Inside and sample from it.
   */
  if(do_post || do_sample) {
	if((status = cm_TrInsideAlign(cm, errbuf, dsq, L, size_limit, preset_mode, pass_idx, mx, &mode, &ins_sc)) != eslOK) return status;
	/* mode will equal preset_mode unless preset_mode is TRMODE_UNKNOWN, in which case it will be mode that gives max inside score  */
	if(do_sample) {
	  if((status = cm_TrStochasticParsetree(cm, errbuf, dsq, L, preset_mode, pass_idx, mx, r, &tr, &mode, &sc)) != eslOK) return status;
	  /* mode may be changed if preset_mode is TRMODE_UNKNOWN, else it will equal preset mode */
	}
	if(do_post) { /* Inside was called above, now do Outside, then Posterior */
	  if((status = cm_TrOutsideAlign    (cm, errbuf, dsq, L, size_limit, mode, pass_idx, (cm->align_opts & CM_ALIGN_CHECKINOUT), post_mx, mx)) != eslOK) return status;
	  if((status = cm_TrPosterior       (cm, errbuf,      L, size_limit, mode, mx, post_mx, post_mx)) != eslOK) return status;
	  if((status = cm_TrEmitterPosterior(cm, errbuf,      L, size_limit, mode, (cm->align_opts & CM_ALIGN_CHECKINOUT), post_mx, emit_mx)) != eslOK) return status;
	}
  }
  else {
	mode = preset_mode; /* this allows us to pass <mode> (not <preset_mode>) into cm_tr_alignT() below for all cases */
  }

  if(!do_sample) { /* if do_sample, we already have a parsetree */
	if((status = cm_tr_alignT(cm, errbuf, dsq, L, size_limit, mode, pass_idx, do_optacc, mx, shmx, emit_mx, &tr, &mode, (do_optacc) ? NULL : &sc)) != eslOK) return status;
  }

  if(have_ppstr || do_optacc) { /* call cm_PostCode to get average PP and optionally a PP string (if have_ppstr) */
	if((status = cm_TrPostCode(cm, errbuf, L, emit_mx, tr, (have_ppstr) ? &ppstr : NULL, &avgpp)) != eslOK) return status;
  }

  if (ret_ppstr  != NULL) *ret_ppstr  = ppstr; else if(ppstr != NULL) free(ppstr);
  if (ret_tr     != NULL) *ret_tr     = tr;    else if(tr    != NULL) FreeParsetree(tr);
  if (ret_mode   != NULL) *ret_mode   = mode;
  if (ret_avgpp  != NULL) *ret_avgpp  = avgpp;
  if (ret_sc     != NULL) *ret_sc     = (do_optacc) ? ins_sc : sc;

  ESL_DPRINTF1(("returning from cm_TrAlign() sc : %f\n", sc));
  return eslOK;
}

/* Function: cm_TrAlignHB()
 * Incept:   EPN, Thu Sep  8 08:55:26 2011
 *           EPN, Fri Oct 26 09:31:43 2007 [FastAlignHB()]
 *
 * Purpose: Wrapper for the cm_tr_alignT_hb() routine - solve a full
 *           alignment problem using trCYK, truncated optimal accuracy
 *           or sampling and return the traceback and the score,
 *           without dividing & conquering, but by using bands on the
 *           j and d dimensions of the DP matrix.  Bands derived by
 *           HMM Forward/Backward runs. Optionally return a posterior
 *           code string.
 *
 *           Identical to cm_TrAlign() but HMM bands are used here.
 *           See that function's 'Purpose' for more details.
 *
 * Args:     cm          - the covariance model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence, 1..L
 *           L           - length of sequence
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the alignment mode to enforce, if TRMODE_UNKNOWN we determine mode here
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           do_optacc   - TRUE to not do CYK alignment, determine the Holmes/Durbin optimally
 *                         accurate parsetree in ret_tr, requires post_mx != NULL
 *           do_sample   - TRUE to sample a parsetree from the Inside matrix
 *           mx          - the main dp matrix, only cells within bands in cm->cp9b will be valid.
 *           shmx        - the HMM banded shadow matrix to fill in and traceback, same cells as mx are valid.
 *           post_mx     - dp matrix for posterior calculation, can be NULL only if !do_optacc
 *           emit_mx     - emit matrix to fill
 *           r           - source of randomness, must be non-NULL only if do_sample==TRUE
 *           ret_ppstr   - RETURN: posterior code 1, (pass NULL if not wanted, must be NULL if post_mx == NULL)
 *           ret_ins_sc  - RETURN: if(do_optacc || ret_ppstr != NULL): inside score of sequence in bits
 *                                 else: should be NULL (inside will not be run)
 *           ret_tr      - RETURN: traceback (pass NULL if trace isn't wanted)
 *           ret_mode    - RETURN: mode of ret_tr, will be <preset_mode> unless that was TRMODE_UNKNOWN
 *           ret_sc      - RETURN: score of the alignment in bits (Inside score if do_optacc)
 *
 * Returns: <ret_tr>, <ret_ppstr>, <ret_sc>, see 'Args' section
 *
 * Returns: <eslOK> on success
 *
 * Throws:  <eslEINVAL> on contract violation
 *          <eslERANGE> if required CM_TR_HB_MX for Inside/Outside/CYK/Posterior exceeds <size_limit>
 */
int
cm_TrAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
	     int do_optacc, int do_sample, CM_TR_HB_MX *mx, CM_TR_HB_SHADOW_MX *shmx, CM_TR_HB_MX *post_mx,
	     CM_TR_HB_EMIT_MX *emit_mx, ESL_RANDOMNESS *r, char **ret_ppstr, Parsetree_t **ret_tr,
	     char *ret_mode, float *ret_avgpp, float *ret_sc)
{
  int          status;
  Parsetree_t *tr = NULL;
  float        sc     = 0.;
  float        avgpp  = 0.;
  float        ins_sc = 0.;
  int          do_post;
  char        *ppstr = NULL;
  int          have_ppstr;
  char         mode = TRMODE_UNKNOWN;  /* mode of tr, <ret_mode> set as this */

  have_ppstr = (ret_ppstr != NULL)       ? TRUE : FALSE;
  do_post    = (do_optacc || have_ppstr) ? TRUE : FALSE;

  /* Contract check */
  if(do_optacc && do_sample)         ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlignHB(), do_optacc and do_sample are both TRUE.");
  if(do_optacc && post_mx == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlignHB(), do_optacc is TRUE, but post_mx == NULL.\n");
  if(do_sample && r       == NULL)   ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrAlignHB(), do_sample but r is NULL.");

  /* if do_post, fill Inside, Outside, Posterior matrices, in that order */
  /* if do_sample (and !do_post) fill Inside and sample from it */
  if(do_post || do_sample) {
	if((status = cm_TrInsideAlignHB (cm, errbuf, dsq, L, size_limit, preset_mode, pass_idx, mx, &mode, &ins_sc)) != eslOK) return status;
	/* mode will equal preset_mode unless preset_mode is TRMODE_UNKNOWN, in which case it will be mode that gives max inside score  */
	if(do_sample) {
	  if((status = cm_TrStochasticParsetreeHB(cm, errbuf, dsq, L, preset_mode, pass_idx, mx, r, &tr, &mode, &sc)) != eslOK) return status;
	  /* mode may be changed if preset_mode is TRMODE_UNKNOWN, else it will equal preset mode */
	}
	if(do_post) { /* Inside was called above, now do Outside, then Posterior, then EmitterPosterior */
	  if((status = cm_TrOutsideAlignHB    (cm, errbuf, dsq, L, size_limit, mode, pass_idx, (cm->align_opts & CM_ALIGN_CHECKINOUT), post_mx, mx)) != eslOK) return status;
	  if((status = cm_TrPosteriorHB       (cm, errbuf,      L, size_limit, mode, mx, post_mx, post_mx)) != eslOK) return status;
	  if((status = cm_TrEmitterPosteriorHB(cm, errbuf,      L, size_limit, mode, (cm->align_opts & CM_ALIGN_CHECKINOUT), post_mx, emit_mx)) != eslOK) return status;
	}
  }
  else {
	mode = preset_mode; /* this allows us to pass <mode> (not <preset_mode>) into cm_tr_alignT() below for all cases */
  }

  if(!do_sample) { /* if do_sample, we already have a parsetree */
	if((status = cm_tr_alignT_hb(cm, errbuf, dsq, L, size_limit, mode, pass_idx, do_optacc, mx, shmx, emit_mx, &tr, &mode, (do_optacc) ? NULL : &sc)) != eslOK) return status;
  }

  if(have_ppstr || do_optacc) {
	if((status = cm_TrPostCodeHB(cm, errbuf, L, emit_mx, tr, (have_ppstr) ? &ppstr : NULL, &avgpp)) != eslOK) return status;
  }

#if eslDEBUGLEVEL >= 2
  CMEmitMap_t *emap;
  emap = CreateEmitMap(cm);
  DumpEmitMap(stdout, emap, cm);
  FreeEmitMap(emap);
  ParsetreeDump(stdout, tr, cm, dsq);
#endif

  if (ret_ppstr  != NULL) *ret_ppstr  = ppstr; else if(ppstr != NULL) free(ppstr);
  if (ret_tr     != NULL) *ret_tr     = tr;    else if(tr    != NULL) FreeParsetree(tr);
  if (ret_mode   != NULL) *ret_mode   = mode;
  if (ret_avgpp  != NULL) *ret_avgpp  = avgpp;
  if (ret_sc     != NULL) *ret_sc     = (do_optacc) ? ins_sc : sc;

  ESL_DPRINTF1(("returning from cm_TrAlignHB() sc : %f\n", sc));
  return eslOK;
}

/* Function: cm_TrCYKInsideAlign()
 * based on cm_CYKInsideAlign()
 *
 * Date:     EPN, Fri Sep  9 15:35:06 2011
 *
 * Note:     Very similar to inside(), but slightly more efficient.
 *           Identical to cm_TrCYKInsideAlignHB() but HMM bands are not
 *           used.
 *
 * Purpose:  Perform trCYK alignment on a full sequence 1..L
 *           rooted at state 0. Very similar to cm_CYKInsideAlign()
 *           except we're doing truncated alignment and marginal
 *           alignment modes are possible.
 *
 *           The caller may already know the mode of the optimal
 *           alignment, passed in as <preset_mode>. This will happen if
 *           we're being called from within a search pipeline, for
 *           example. If the caller does not know the optimal mode yet
 *           (e.g. if we're being called for 'cmalign'), <preset_mode>
 *           will be TRMODE_UNKNOWN. In this case, we allow all modes.
 *
 *           The mode of the optimal parsetree is returned in <ret_mode>,
 *           it has score <ret_sc>.
 *
 *           We deal with truncated begins by keeping track of the
 *           optimal state that we could enter and account for the
 *           whole target sequence in each mode: {J,L,R,T}b = argmax_v
 *           {J,L,R,T}alpha_v(1,L) + log t_0(v), and
 *           {J,L,R,T}alpha[0][L][L] is the score for that. For the
 *           mode that gives the optimal alignment, <ret_b> is that
 *           mode's b and <ret_sc> is that modes alpha[0][L][L]
 *           sc. For example if Jalpha[0][L][L] is the optimal score,
 *           a local alignment into state Jb in joint marginal mode is
 *           optimal and <ret_b> = Jb and <ret_sc> = Jbsc.
 *
 *           All alignments must use truncated begins when computing
 *           truncated alignments. The penalty for the begin is
 *           different depending on if we're in local mode or not and
 *           what the value of <pass_idx> is.
 *
 * Args:     cm          - the model    [0..M-1]
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitaized sequence [1..L]
 *           L           - length of target sequence, we align 1..L
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, or TRMODE_UNKNOWN to allow any mode
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - dp matrix
 *           shmx        - shadow matrix
 *           ret_b       - RETURN: best internal entry state for optimal mode, if local begins are on
 *           ret_mode    - RETURN: mode of optimal CYK parsetree (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc      - RETURN: score of optimal, CYK parsetree in any mode (max of mx->{J,L,R,T}alpha[0][L][L])
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required mx or shmx size exceeds <size_limit>
 *           In this case alignment has been aborted, <ret_*> variables are not valid
 */
int
cm_TrCYKInsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		    CM_TR_MX *mx, CM_TR_SHADOW_MX *shmx, int *ret_b, char *ret_mode, float *ret_sc)
{
  int      status;          /* easel status code */
  int      v,y,z;	    /* indices for states  */
  int      j,d,i,k;	    /* indices in sequence dimensions */
  float    sc;		    /* a temporary variable holding a score */
  int      yoffset;	    /* y=base+offset -- counter in child states that v can transit to */
  float   *el_scA;          /* [0..d..W-1] probability of local end emissions of length d */
  int      sd;              /* StateDelta(cm->sttype[v]) */
  int      sdl;             /* StateLeftDelta(cm->sttype[v] */
  int      sdr;             /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;           /* j - sdr */
  int      d_sd;            /* d - sd */
  int      d_sdl;           /* d - sdl */
  int      d_sdr;           /* d - sdr */
  float    tsc;             /* a transition score */

  /* other variables used in truncated version, but not standard version (not in cm_CYKInsideAlign()) */
  int   b, Jb, Lb, Rb, Tb;      /* local entry state rooting overall and {J,L,R,T} optimal parsetrees using */
  char  mode = TRMODE_UNKNOWN;  /* truncation mode for obtaining optimal score <ret_sc> */
  int   Lyoffset0;              /* first yoffset to use for updating L matrix in IR/MR states, 1 if IR, 0 if MR */
  int   Ryoffset0;              /* first yoffset to use for updating R matrix in IL/ML states, 1 if IL, 0 if ML */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  char  ***Jyshadow = shmx->Jyshadow; /* pointer to the Jyshadow matrix */
  char  ***Lyshadow = shmx->Lyshadow; /* pointer to the Lyshadow matrix */
  char  ***Ryshadow = shmx->Ryshadow; /* pointer to the Ryshadow matrix */
  int   ***Jkshadow = shmx->Jkshadow; /* pointer to the Jkshadow matrix */
  int   ***Lkshadow = shmx->Lkshadow; /* pointer to the Lkshadow matrix */
  int   ***Rkshadow = shmx->Rkshadow; /* pointer to the Rkshadow matrix */
  int   ***Tkshadow = shmx->Tkshadow; /* pointer to the Tkshadow matrix */
  char  ***Lkmode   = shmx->Lkmode;   /* pointer to the Lkmode matrix */
  char  ***Rkmode   = shmx->Rkmode;   /* pointer to the Rkmode matrix */

  /* Determine which matrices we need to fill in, based on <preset_mode>, if TRMODE_UNKNOWN, fill_L, fill_R, fill_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCYKInsideAlign(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrCYKInsideAlign(), unexpected pass idx: %d", pass_idx);

  /* Allocations and initializations  */
  Jb   = Lb   = Rb   = Tb   = b = 0; /* will be unchanged if local begins are off, *ret_b will be set as 0 */

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_mx_GrowTo       (cm, mx,   errbuf, L, size_limit)) != eslOK) return status;
  if((status = cm_tr_shadow_mx_GrowTo(cm, shmx, errbuf, L, size_limit)) != eslOK) return status;

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(  mx->Jncells_valid   > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(  mx->Lncells_valid   > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(  mx->Rncells_valid   > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(  mx->Tncells_valid   > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);
  if(shmx->Jy_ncells_valid > 0)           for(i = 0; i < shmx->Jy_ncells_valid; i++) shmx->Jyshadow_mem[i] = USED_EL;
  if(shmx->Ly_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Ly_ncells_valid; i++) shmx->Lyshadow_mem[i] = USED_EL;
  if(shmx->Ry_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Ry_ncells_valid; i++) shmx->Ryshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will almost certainly be overwritten */
  if(shmx->Jk_ncells_valid > 0)           esl_vec_ISet(shmx->Jkshadow_mem, shmx->Jk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) esl_vec_ISet(shmx->Lkshadow_mem, shmx->Lk_ncells_valid, 0);
  if(shmx->Rk_ncells_valid > 0 && fill_R) esl_vec_ISet(shmx->Rkshadow_mem, shmx->Rk_ncells_valid, 0);
  if(shmx->Tk_ncells_valid > 0 && fill_T) esl_vec_ISet(shmx->Tkshadow_mem, shmx->Tk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Lk_ncells_valid; i++) shmx->Lkmode_mem[i] = TRMODE_J;
  if(shmx->Rk_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Rk_ncells_valid; i++) shmx->Rkmode_mem[i] = TRMODE_J;

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) {
	Jalpha[cm->M][j][d] = el_scA[d];
	  }
	}
	if(fill_L) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) {
	  Lalpha[cm->M][j][d] = el_scA[d];
	}
	  }
	}
	if(fill_R) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) {
	  Ralpha[cm->M][j][d] = el_scA[d];
	}
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v]; /* marginal left  emission scores for state v */
	float const *rmesc_v = cm->rmesc[v]; /* marginal right emission scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdl  = StateLeftDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize the J, L and R deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	for (d = sd; d <= j; d++) {
	  Jalpha[v][j][d] = el_scA[d-sd] + cm->endsc[v];
	}
	  }
	  if(fill_L) {
	for (j = 0; j <= L; j++) {
	  for (d = sdl; d <= j; d++) {
	    Lalpha[v][j][d] = el_scA[d-sdl] + cm->endsc[v];
	  }
	}
	  }
	  if(fill_R) {
	for (j = 0; j <= L; j++) {
	  for (d = sdr; d <= j; d++) {
	    Ralpha[v][j][d] = el_scA[d-sdr] + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = 0; j <= L; j++) {
	Jalpha[v][j][0] = 0.;
	if(fill_L) Lalpha[v][j][0] = 0.;
	if(fill_R) Ralpha[v][j][0] = 0.;
	/* rest of deck remains IMPOSSIBLE */
	  }
	}
	else if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update alpha[v][j][d] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1]
	   * We do ML states as well as IL states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat R differently from and J and L
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Ralpha[v][j][d].
	   */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Ryoffset0 = cm->sttype[v] == IL_st ? 1 : 0; /* don't allow IL self transits in R mode */
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    d_sd = d - sd;
	    i    = j - d + 1;
	    for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	      y = cm->cfirst[v] + yoffset;
	      if ((sc = Jalpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > Jalpha[v][j][d]) {
		Jalpha[v][j][d]   = sc;
		Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if (fill_L && (sc = Lalpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	    Jalpha[v][j][d] += esc_v[dsq[i]];
	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    if(fill_L) {
	      if(d >= 2) {
		Lalpha[v][j][d] += esc_v[dsq[i]];
	      }
	      else {
		Lalpha[v][j][d]   = esc_v[dsq[i]];
		Lyshadow[v][j][d] = USED_TRUNC_END;
	      }
	      Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    }
	    i--;

	    /* handle R separately */
	    if(fill_R) {
	      /* note we use 'd', not 'd_sd' (which we used in the corresponding loop for J,L above) */
	      for (yoffset = Ryoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Ryoffset0 instead of 0 disallows IL self transits in R mode */
		y = cm->cfirst[v] + yoffset;
		if ((sc = Jalpha[y][j_sdr][d] + tsc_v[yoffset]) > Ralpha[v][j][d]) {
		  Ralpha[v][j][d] = sc;
		  Ryshadow[v][j][d]= yoffset + TRMODE_J_OFFSET;
		}
		if ((sc = Ralpha[y][j_sdr][d] + tsc_v[yoffset]) > Ralpha[v][j][d]) {
		  Ralpha[v][j][d] = sc;
		  Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
		}
	      }
	      Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm,v )) */
	}
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update alpha[v][j][d] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1].
	   * We do MR states as well as IR states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat L differently from and J and R
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Lalpha[v][j][d].
	   */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Lyoffset0 = cm->sttype[v] == IR_st ? 1 : 0; /* don't allow IR self transits in L mode */
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    d_sd = d - sd;
	    i = j - d + 1;
	    for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	      y = cm->cfirst[v] + yoffset;
	      if ((sc = Jalpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > Jalpha[v][j][d]) {
		Jalpha[v][j][d]   = sc;
		Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if (fill_R && (sc = Ralpha[y][j_sdr][d_sd] + tsc_v[yoffset]) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	      }
	    }
	    Jalpha[v][j][d] += esc_v[dsq[j]];
	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    if(fill_R) {
	      if(d >= 2) {
		Ralpha[v][j][d] += esc_v[dsq[j]];
	      }
	      else {
		Ralpha[v][j][d]   = esc_v[dsq[j]];
		Ryshadow[v][j][d] = USED_TRUNC_END;
	      }
	      Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	    }

	    /* handle L separately */
	    if(fill_L) {
	      /* note we use 'j' and 'd', not 'j_sdr' and 'd_sd' (which we used in the corresponding loop for J,R above) */
	      for (yoffset = Lyoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Lyoffset0, instead of 0 disallows IR self transits in L mode */
		y = cm->cfirst[v] + yoffset;
		if ((sc = Jalpha[y][j][d] + tsc_v[yoffset]) > Lalpha[v][j][d]) {
		  Lalpha[v][j][d] = sc;
		  Lyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
		}
		if ((sc = Lalpha[y][j][d] + tsc_v[yoffset]) > Lalpha[v][j][d]) {
		  Lalpha[v][j][d] = sc;
		  Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
		}
	      }
	      Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) { /* sd == 2 for MP state */
	    d_sd = d-sd;
	    if((sc = Jalpha[y][j_sdr][d_sd] + tsc) > Jalpha[v][j][d]) {
	      Jalpha[v][j][d]   = sc;
	      Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	    }
	  }
	  if(fill_L) {
	    /* note we use 'j' and 'd_sdl' not 'j_sdr' for 'd_sd' for L, plus minimum d is sdl (1) */
	    for (d = sdl; d <= j; d++) { /* sdl == 1 for MP state */
	      d_sdl = d-sdl;
	      if((sc = Jalpha[y][j][d_sdl] + tsc) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if((sc = Lalpha[y][j][d_sdl] + tsc) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	  }
	  if(fill_R) {
	    /* note we use 'd_sdr' not 'd_sd' for R, plus minimum d is sdr (1) */
	    for (d = sdr; d <= j; d++) { /* sdr == 1 for MP state */
	      d_sdr = d - sdr;
	      if((sc = Jalpha[y][j_sdr][d_sdr] + tsc) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if((sc = Ralpha[y][j_sdr][d_sdr] + tsc) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	      }
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = 0; j <= L; j++) {
	i = j;
	Jalpha[v][j][1] = IMPOSSIBLE;
	if(fill_L) {
	  Lalpha[v][j][1] = lmesc_v[dsq[i]];
	  Lyshadow[v][j][1] = USED_TRUNC_END;
	}
	if(fill_R) {
	  Ralpha[v][j][1] = rmesc_v[dsq[j]];
	  Ryshadow[v][j][1] = USED_TRUNC_END;
	}
	i--;
	for (d = 2; d <= j; d++) {
	  Jalpha[v][j][d] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	  if(fill_L) Lalpha[v][j][d] += lmesc_v[dsq[i]];
	  if(fill_R) Ralpha[v][j][d] += rmesc_v[dsq[j]];
	  i--;
	}
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 1; d <= j; d++) {
	  Jalpha[v][j][d] = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	  if(fill_L) Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	  if(fill_R) Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) {
	    d_sd = d-sd;
	    if((sc = Jalpha[y][j_sdr][d_sd] + tsc) > Jalpha[v][j][d]) {
	      Jalpha[v][j][d]   = sc;
	      Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	    }
	    if(fill_L && (sc = Lalpha[y][j_sdr][d_sd] + tsc) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	    }
	    if(fill_R && (sc = Ralpha[y][j_sdr][d_sd] + tsc) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	    }
	  }
	  /* an easy to overlook case: if d == 0, ensure L and R values are IMPOSSIBLE */
	  if(fill_L) Lalpha[v][j][0] = IMPOSSIBLE;
	  if(fill_R) Ralpha[v][j][0] = IMPOSSIBLE;
	  /* And another special case for BEGL_S and BEGR_S states,
	   * reset shadow matrix values for d == 0 (which were
	   * initialized to USED_EL above), even though the score of
	   * these cells is impossible we may use them as a
	   * zero-length left or right half of a BIF_B subtree during
	   * construction of the parsetree.
	   */
	  if(cm->sttype[v] == S_st) {
	    if(fill_L) Lyshadow[v][j][0] = USED_TRUNC_END;
	    if(fill_R) Ryshadow[v][j][0] = USED_TRUNC_END;
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  assert(cm->sttype[v] == B_st);
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    if((sc = Jalpha[y][j-k][d-k] + Jalpha[z][j][k]) > Jalpha[v][j][d]) {
	      Jalpha[v][j][d]   = sc;
	      Jkshadow[v][j][d] = k;
	    }
	    if(fill_L && (sc = Jalpha[y][j-k][d-k] + Lalpha[z][j][k]) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lkshadow[v][j][d] = k;
	      Lkmode[v][j][d]   = TRMODE_J;
	    }
	    if(fill_R && (sc = Ralpha[y][j-k][d-k] + Jalpha[z][j][k]) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Rkshadow[v][j][d] = k;
	      Rkmode[v][j][d]   = TRMODE_J;
	    }
	  }
	  if(fill_T) {
	    for(k = 1; k < d; k++) { /* special boundary case for T matrix */
	      if(fill_T && (sc = Ralpha[y][j-k][d-k] + Lalpha[z][j][k]) > Talpha[v][j][d]) {
		Talpha[v][j][d]   = sc;
		Tkshadow[v][j][d] = k;
	      }
	    }
	  }
	  /* two additional special cases in trCYK (these are not in standard CYK) */
	  /* special case 1: k == 0 (full sequence aligns to BEGL_S left child */
	  if(fill_L) {
	    if((sc = Jalpha[y][j][d]) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lkshadow[v][j][d] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][j][d]   = TRMODE_J;
	    }
	    if((sc = Lalpha[y][j][d]) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lkshadow[v][j][d] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][j][d]   = TRMODE_L;
	    }
	  }
	  /* special case 2: k == d (full sequence aligns to BEGR_S right child */
	  if(fill_R) {
	    if((sc = Jalpha[z][j][d]) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Rkshadow[v][j][d] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][j][d]   = TRMODE_J;
	    }
	    if((sc = Ralpha[z][j][d]) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Rkshadow[v][j][d] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][j][d]   = TRMODE_R;
	    }
	  }
	}
	  }
	} /* end of B_st recursion */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  /* check if we have a new optimally scoring Joint alignment in J matrix */
	  sc = Jalpha[v][L][L] + trpenalty;
	  if (sc > Jalpha[0][L][L]) {
	Jalpha[0][L][L] = sc;
	Jb = v;
	  }
	  /* check if we have a new optimally scoring Left alignment in L matrix */
	  if(fill_L) {
	sc = Lalpha[v][L][L] + trpenalty;
	if (sc > Lalpha[0][L][L]) {
	  Lalpha[0][L][L] = sc;
	  Lb = v;
	}
	  }
	  /* check if we have a new optimally scoring Right alignment in R matrix */
	  if(fill_R) {
	sc = Ralpha[v][L][L] + trpenalty;
	if (sc > Ralpha[0][L][L]) {
	  Ralpha[0][L][L] = sc;
	  Rb = v;
	}
	  }
	  /* check if we have a new optimally scoring Terminal alignment in T matrix */
	  if(fill_T && cm->sttype[v] == B_st) {
	sc = Talpha[v][L][L] + trpenalty;
	if (sc > Talpha[0][L][L]) {
	  Talpha[0][L][L] = sc;
	  Tb = v;
	}
	  }
	}
  } /* end loop for (v = cm->M-1; v > 0; v--) */

  /* all valid alignments must use a truncated begin */
  Jyshadow[0][L][L] = USED_TRUNC_BEGIN;
  if(fill_L) Lyshadow[0][L][L] = USED_TRUNC_BEGIN;
  if(fill_R) Ryshadow[0][L][L] = USED_TRUNC_BEGIN;
  /* Tyshadow[0] doesn't exist, caller must know how to deal */

  /* determine mode of optimal alignment, if it was preset then use that */
  if(preset_mode == TRMODE_J) {
	sc   = Jalpha[0][L][L];
	mode = TRMODE_J;
	b    = Jb;
  }
  else if(preset_mode == TRMODE_L) {
	sc   = Lalpha[0][L][L];
	mode = TRMODE_L;
	b    = Lb;
  }
  else if(preset_mode == TRMODE_R) {
	sc   = Ralpha[0][L][L];
	mode = TRMODE_R;
	b    = Rb;
  }
  else if(preset_mode == TRMODE_T) {
	sc   = Talpha[0][L][L];
	mode = TRMODE_T;
	b    = Tb;
  }
  else { /* preset_mode was unknown, max score determines mode */
	sc   = Jalpha[0][L][L];
	mode = TRMODE_J;
	b    = Jb;
	if (fill_L && Lalpha[0][L][L] > sc) {
	  sc   = Lalpha[0][L][L];
	  mode = TRMODE_L;
	  b    = Lb;
	}
	if (fill_R && Ralpha[0][L][L] > sc) {
	  sc   = Ralpha[0][L][L];
	  mode = TRMODE_R;
	  b    = Rb;
	}
	if (fill_T && Talpha[0][L][L] > sc) {
	  sc   = Talpha[0][L][L];
	  mode = TRMODE_T;
	  b    = Tb;
	}
  }

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_cykmx", "w");   cm_tr_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.tru_cykshmx", "w"); cm_tr_shadow_mx_Dump(fp2, cm, shmx, preset_mode, TRUE); fclose(fp2);
#endif

  if(ret_b    != NULL) *ret_b    = b;
  if(ret_mode != NULL) *ret_mode = mode;
  if(ret_sc   != NULL) *ret_sc   = sc;

  free(el_scA);

  ESL_DPRINTF1(("cm_TrCYKInsideAlign return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_TrCYKInsideAlignHB()
 *
 * Date:     EPN, Wed Sep  7 12:13:43 2011
 *
 * Purpose: Run the inside phase of a trCYK alignment using bands in
 *           the j and d dimensions of the DP matrix. Bands were
 *           obtained from an HMM Forward-Backward parse of the target
 *           sequence. Uses float log odds scores.
 *
 *           A CM_TR_HB_MX DP matrix must be passed in. Only cells
 *           valid within the bands given in the CP9Bands_t <cm->cp9b>
 *           will be valid.
 *
 *           Otherwise, the same as cm_TrCYKInsideAlign(), see that
 *           functions 'Purpose' for more information, including
 *           important caveats regarding handling local begins.
 *
 * Args:     cm          - the model    [0..M-1]
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitaized sequence [1..L]
 *           L           - length of target sequence, we align 1..L
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, TRMODE_UNKNOWN to allow any mode
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the dp matrix, only cells within bands in cm->cp9b will be valid.
 *           shmx        - the HMM banded shadow matrix to fill in, only cells within bands are valid
 *           ret_b       - RETURN: best internal entry state for optimal mode, if local begins are on
 *           ret_mode    - mode of optimal CYK parsetree (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc      - score of optimal, CYK parsetree in any mode (max of mx->{J,L,R,T}alpha[0][L][L])
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE>     if required mx or shmx size exceeds <size_limit>
 *           <eslEINVAL>     if the full sequence is not within the bands for state 0
 *           <eslEAMBIGUOUS> if no valid alignment is possible due to bands (score of sequence is IMPOSSIBLE)
 *           In any of these three cases, alignment has been aborted, ret variables are not valid.
 */
int
cm_TrCYKInsideAlignHB(CM_t *cm, char *errbuf,  ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		      CM_TR_HB_MX *mx, CM_TR_HB_SHADOW_MX *shmx, int *ret_b, char *ret_mode, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;          /* temporary score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;      /* [0..d..W-1] probability of local end emissions of length d */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdl;         /* StateLeftDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v]) */
  int      j_sdr;       /* j - sdr */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y, dp_z;   /* d index for state v/y/z in alpha */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dp_y_sdr;           /* dp_y - sdr */
  int      dp_y_sdl;           /* dp_y - sdl */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  int      Lp;                 /* L index also changes depending on state */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* variables related to truncated alignment (not in cm_CYKInsideAlignHB() */
  int      b, Jb, Lb, Rb, Tb;      /* local entry state rooting overall and {J,L,R,T} optimal parsetrees using */
  char     mode = TRMODE_UNKNOWN;  /* truncation mode for obtaining optimal score <ret_sc> */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z; /* must we fill J matrix deck for state v, y, z? */
  int      do_L_v, do_L_y, do_L_z; /* must we fill L matrix deck for state v, y, z? */
  int      do_R_v, do_R_y, do_R_z; /* must we fill R matrix deck for state v, y, z? */
  int      do_T_v, do_T_y, do_T_z; /* must we fill T matrix deck for state v, y, z? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  char  ***Jyshadow = shmx->Jyshadow; /* pointer to the Jyshadow matrix */
  char  ***Lyshadow = shmx->Lyshadow; /* pointer to the Lyshadow matrix */
  char  ***Ryshadow = shmx->Ryshadow; /* pointer to the Ryshadow matrix */
  int   ***Jkshadow = shmx->Jkshadow; /* pointer to the Jkshadow matrix */
  int   ***Lkshadow = shmx->Lkshadow; /* pointer to the Lkshadow matrix */
  int   ***Rkshadow = shmx->Rkshadow; /* pointer to the Rkshadow matrix */
  int   ***Tkshadow = shmx->Tkshadow; /* pointer to the Tkshadow matrix */
  char  ***Lkmode   = shmx->Lkmode;   /* pointer to the Lkmode matrix */
  char  ***Rkmode   = shmx->Rkmode;   /* pointer to the Rkmode matrix */

  /* Determine which matrices we need to fill in, based on <preset_mode>, if TRMODE_UNKNOWN, fill_L, fill_R, fill_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCYKInsideAlignHB(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrCYKInsideAlignHB(), unexpected pass idx: %d", pass_idx);

  /* Allocations and initializations  */
  Jb   = Lb   = Rb   = Tb   = b = 0; /* will be unchanged if local begins are off, *ret_b will be set as 0 */

  /* ensure a full alignment to ROOT_S (v==0) is possible, remember In CYK <preset_mode> may be known or unknown */
  if (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): preset_mode is J mode, but cp9b->Jvalid[v] is FALSE");
  if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): preset_mode is L mode, but cp9b->Lvalid[v] is FALSE");
  if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): preset_mode is R mode, but cp9b->Rvalid[v] is FALSE");
  if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): preset_mode is T mode, but cp9b->Tvalid[v] is FALSE");
  if (preset_mode == TRMODE_UNKNOWN && (! (cp9b->Jvalid[0] || cp9b->Lvalid[0] || cp9b->Rvalid[0] || cp9b->Tvalid[0]))) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): no marginal mode is allowed for state 0");
  }
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)               ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo       (cm,   mx, errbuf, cp9b, L, size_limit)) != eslOK) return status;
  if((status = cm_tr_hb_shadow_mx_GrowTo(cm, shmx, errbuf, cp9b, L, size_limit)) != eslOK) return status;

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE, all cells of shadow matrix to USED_EL or USED_TRUNC_END */
  if(  mx->Jncells_valid   > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(  mx->Lncells_valid   > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(  mx->Rncells_valid   > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(  mx->Tncells_valid   > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);
  if(shmx->Jy_ncells_valid > 0)           for(i = 0; i < shmx->Jy_ncells_valid; i++) shmx->Jyshadow_mem[i] = USED_EL;
  if(shmx->Ly_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Ly_ncells_valid; i++) shmx->Lyshadow_mem[i] = USED_EL;
  if(shmx->Ry_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Ry_ncells_valid; i++) shmx->Ryshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will be overwritten */
  if(shmx->Jk_ncells_valid > 0)           esl_vec_ISet(shmx->Jkshadow_mem, shmx->Jk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) esl_vec_ISet(shmx->Lkshadow_mem, shmx->Lk_ncells_valid, 0);
  if(shmx->Rk_ncells_valid > 0 && fill_R) esl_vec_ISet(shmx->Rkshadow_mem, shmx->Rk_ncells_valid, 0);
  if(shmx->Tk_ncells_valid > 0 && fill_T) esl_vec_ISet(shmx->Tkshadow_mem, shmx->Tk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Lk_ncells_valid; i++) shmx->Lkmode_mem[i] = TRMODE_J;
  if(shmx->Rk_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Rk_ncells_valid; i++) shmx->Rkmode_mem[i] = TRMODE_J;

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores,
   * Note: we could optimize by skipping this step and using el_scA[d] to
   * initialize ELs for each state in the first step of the main recursion
   * below. We fill in the EL deck here for completeness and so that
   * a check of this alpha matrix with a CYKOutside matrix will pass.
   */
  if(cm->flags & CMH_LOCAL_END) {
	if(cp9b->Jvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Jalpha[cm->M][j][d] = el_scA[d];
	  }
	}
	if(fill_L && cp9b->Lvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Lalpha[cm->M][j][d] = el_scA[d];
	  }
	}
	if(fill_R && cp9b->Rvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Ralpha[cm->M][j][d] = el_scA[d];
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	float const *esc_v   = cm->oesc[v];  /* emission scores for state v */
	float const *tsc_v   = cm->tsc[v];   /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v]; /* marginal left  emission scores for state v */
	float const *rmesc_v = cm->rmesc[v]; /* marginal right emission scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdl  = StateLeftDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	jn   = jmin[v];
	jx   = jmax[v];
	do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;
	/* re-initialize the J, L and R decks if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  if(do_J_v && cp9b->Jvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  if(hdmin[v][jp_v] >= sd) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sd;
	    dp_v = sd - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Jalpha[v][jp_v][dp_v] = Jalpha[cm->M][j][d-sd] + cm->endsc[v];
	    /* If we optimize by skipping the filling of the
	     * EL deck the above line would become:
	     * 'Jalpha[v][jp_v][dp_v] = el_scA[d-sd] + cm->endsc[v];'
	     */
	  }
	}
	  }
	  if(do_L_v && cp9b->Lvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  if(hdmin[v][jp_v] >= sdl) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdl;
	    dp_v = sdl - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Lalpha[v][jp_v][dp_v] = Lalpha[cm->M][j][d-sdl] + cm->endsc[v];
	  }
	}
	  }
	  if(do_R_v && cp9b->Rvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  if(hdmin[v][jp_v] >= sdr) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdr;
	    dp_v = sdr - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Ralpha[v][jp_v][dp_v] = Ralpha[cm->M][j][d-sdr] + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	if(do_J_v) Jalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_L_v) Lalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_R_v) Ralpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IL states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1]
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */
	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;
	  j_sdr = j - sdr;

	  /* determine which children y we can legally transit to for v, j */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    i    = j - d + 1;
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    /* We need to treat R differently from and J and L here, by
	     * doing separate 'for (yoffset...' loops for J and R
	     * because we have to fully calculate Jalpha[v][jp_v][dp_v])
	     * before we can start to calculate Ralpha[v][jp_v][dp_v].
	     */
	    /* Handle J and L first */
	    if(do_J_v || do_L_v) {
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		if(do_J_y || do_L_y) {
		  jp_y_sdr = j - jmin[y] - sdr;

		  if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		    if((do_J_v && do_J_y) &&
		       ((sc = Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > Jalpha[v][jp_v][dp_v])) {
		      Jalpha[v][jp_v][dp_v]   = sc;
		      Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		    }
		    if((do_L_v && do_L_y) &&
		       ((sc = Lalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > Lalpha[v][jp_v][dp_v])) {
		      Lalpha[v][jp_v][dp_v]   = sc;
		      Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
		    }
		  }
		}
	      }
	      if(do_J_v) {
		Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]];
		Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      if(do_L_v) {
		if(d >= 2) {
		  Lalpha[v][jp_v][dp_v] += esc_v[dsq[i]];
		}
		else {
		  Lalpha[v][jp_v][dp_v]   = esc_v[dsq[i]];
		  Lyshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		}
		Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      i--;
	    }

	    if(do_R_v) {
	      /* Handle R separately */
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		if((do_J_y || do_R_y) && (y != v)) { /* (y != v) part is to disallow IL self transits in R mode */
		  jp_y_sdr = j - jmin[y] - sdr;

		  /* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,L above) */
		  if((d) >= hdmin[y][jp_y_sdr] && (d) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y = d - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));

		    if(do_J_y &&
		       ((sc = Jalpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]) > Ralpha[v][jp_v][dp_v])) {
		      Ralpha[v][jp_v][dp_v] = sc;
		      Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		    }
		    if(do_R_y &&
		       ((sc = Ralpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]) > Ralpha[v][jp_v][dp_v])) {
		      Ralpha[v][jp_v][dp_v] = sc;
		      Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
		    }
		  }
		}
	      } /* end of for (yvalid_idx = 0... loop */
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IR states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1].
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	/* The first MR_st/IR_st 'for (j...' loop is for J and R matrices which use the same set of j values */
	if(do_J_v || do_R_v) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];
	    yvalid_ct = 0;
	    j_sdr = j - sdr;

	    /* determine which children y we can legally transit to for v, j */
	    for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	      if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	    for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	      dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	      /* We need to treat L differently from and J and R here, by
	       * doing separate 'for (yoffset...' loops for J because we
	       * have to fully calculate Jalpha[v][jp_v][dp_v]) before we
	       * can start to calculate Lalpha[v][jp_v][dp_v].
	       */
	      /* Handle J and R first */
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		if(do_J_y || do_R_y) {
		  jp_y_sdr = j - jmin[y] - sdr;

		  if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));

		    if((do_J_v && do_J_y) &&
		       ((sc = Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > Jalpha[v][jp_v][dp_v])) {
		      Jalpha[v][jp_v][dp_v]   = sc;
		      Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		    }
		    if((do_R_v && do_R_y) &&
		       ((sc = Ralpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]) > Ralpha[v][jp_v][dp_v])) {
		      Ralpha[v][jp_v][dp_v]   = sc;
		      Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
		    }
		  }
		}
	      }
	      if(do_J_v) {
		Jalpha[v][jp_v][dp_v] += esc_v[dsq[j]];
		Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      if(do_R_v) {
		if(d >= 2) {
		  Ralpha[v][jp_v][dp_v] += esc_v[dsq[j]];
		}
		else {
		  Ralpha[v][jp_v][dp_v]   = esc_v[dsq[j]];
		  Ryshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		}
		Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	    }
	  }
	}
	/* Handle L separately */
	if(do_L_v) {
	  /* The second MR_st/IR_st 'for (j...' loop is for the L matrix which use a different set of j values */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];
	    yvalid_ct = 0;

	    /* determine which children y we can legally transit to for v, j */
	    /* we use 'j' and not 'j_sdr' here for the L matrix, differently from J and R matrices above */
	    for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	      if(j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j is valid for state y? */

	    for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	      dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		/* Note if we're an IL state, we can't self transit in R mode, this was ensured above when we set up yvalidA[] (xref:ELN3,p5)*/
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		if((do_J_y || do_L_y) && (y != v)) { /* (y != v) part is to disallow IR self transits in L mode */

		  /* we use 'jp_y=j-min[y]' here, not 'jp_y_sdr=j-jmin[y]-sdr' (which we used in the corresponding loop for J,R above) */
		  jp_y = j - jmin[y];

		  /* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,R above) */
		  if((d) >= hdmin[y][jp_y] && (d) <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		    dp_y = d - hdmin[y][jp_y];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y] - hdmin[y][jp_y])));

		    if(do_J_y &&
		       (sc = Jalpha[y][jp_y][dp_y] + tsc_v[yoffset]) > Lalpha[v][jp_v][dp_v]) {
		      Lalpha[v][jp_v][dp_v] = sc;
		      Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		    }
		    if(do_L_y &&
		       (sc = Lalpha[y][jp_y][dp_y] + tsc_v[yoffset]) > Lalpha[v][jp_v][dp_v]) {
		      Lalpha[v][jp_v][dp_v] = sc;
		      Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
		    }
		  }
		}
	      } /* end of for (yvalid_idx = 0... loop */
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v) */
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* The first MP_st 'for (jp_v...' loop is for J and R matrices which use the same set of j values */
	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;
	/* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	if((do_J_v && do_J_y) || (do_R_v && (do_J_y || do_R_y))) {
	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    if(do_J_v && do_J_y) {
	      /* J matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sd   = dn - hdmin[y][jp_y_sdr] - sd;

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
		ESL_DASSERT1((dp_v      >= 0 && dp_v       <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y_sd   >= 0 && dp_y_sd    <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));

		if((sc = Jalpha[y][jp_y_sdr][dp_y_sd] + tsc) > Jalpha[v][jp_v][dp_v]) {
		  Jalpha[v][jp_v][dp_v]   = sc;
		  Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		}
	      }
	    }

	    if(do_R_v && (do_R_y || do_J_y)) {
	      /* R matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sdr);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sdr);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sdr  = dn - hdmin[y][jp_y_sdr] - sdr;
	      /* for {L,R}alpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		/* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
		ESL_DASSERT1((dp_y_sdr  >= 0 && dp_y_sdr   <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		if(do_J_y &&
		   ((sc = Jalpha[y][jp_y_sdr][dp_y_sdr] + tsc) > Ralpha[v][jp_v][dp_v])) {
		  Ralpha[v][jp_v][dp_v]   = sc;
		  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		}
		if(do_R_y &&
		   ((sc = Ralpha[y][jp_y_sdr][dp_y_sdr] + tsc) > Ralpha[v][jp_v][dp_v])) {
		  Ralpha[v][jp_v][dp_v]   = sc;
		  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
		}
	      }
	    }
	  }
	}

	if(do_L_v && (do_L_y || do_J_y)) {
	  /* The second MP_st 'for (jp_v...' loop is for L matrix, which uses a different set of j values from J and R */
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y] (follows from (j >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y] (follows from (j <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y = jn - jmin[y];
	  /* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y]+sdl (follows from (d-sdl >= hdmin[y][jp_y]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y]+sdl (follows from (d-sdl <= hdmax[y][jp_y]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y] + sdl);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y] + sdl);
	    dpn       = dn - hdmin[v][jp_v];
	    dpx       = dx - hdmin[v][jp_v];
	    dp_y_sdl  = dn - hdmin[y][jp_y] - sdl;
	    /* for Lalpha, we use 'dp_y_sdl' instead of 'dy_y_sd' */

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdl++) {
	      /* we use 'dp_y_sdl' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
	      ESL_DASSERT1((dp_y_sdl >= 0 && dp_y_sdl <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
	      if(do_J_y &&
		 ((sc = Jalpha[y][jp_y][dp_y_sdl] + tsc) > Lalpha[v][jp_v][dp_v])) {
		Lalpha[v][jp_v][dp_v]  = sc;
		Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
	      }
	      if(do_L_y &&
		 ((sc = Lalpha[y][jp_y][dp_y_sdl] + tsc) > Lalpha[v][jp_v][dp_v])) {
		Lalpha[v][jp_v][dp_v]  = sc;
		Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	i     = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++)
	  {
	    if(d >= 2) {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	      if(do_L_v) Lalpha[v][jp_v][dp_v] += lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] += rmesc_v[dsq[j]];
	    }
	    else {
	      if(do_J_v) { Jalpha[v][jp_v][dp_v] = IMPOSSIBLE; }
	      if(do_L_v) { Lalpha[v][jp_v][dp_v] = lmesc_v[dsq[i]]; Lyshadow[v][jp_v][dp_v] = USED_TRUNC_END; }
	      if(do_R_v) { Ralpha[v][jp_v][dp_v] = rmesc_v[dsq[j]]; Ryshadow[v][jp_v][dp_v] = USED_TRUNC_END; }
	    }
	    i--;
	  }
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	  if(do_J_v) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_L_v) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_R_v) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	if((do_J_v && do_J_y) || (do_L_v && do_L_y) || (do_R_v && do_R_y)) {
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	  jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y_sdr = jn - jmin[y] - sdr;

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	    dpn     = dn - hdmin[v][jp_v];
	    dpx     = dx - hdmin[v][jp_v];
	    dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));

	      if((do_J_v && do_J_y) &&
		 ((sc = Jalpha[y][jp_y_sdr][dp_y_sd] + tsc) > Jalpha[v][jp_v][dp_v])) {
		Jalpha[v][jp_v][dp_v]  = sc;
		Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
	      }
	      if((do_L_v && do_L_y) &&
		 ((sc = Lalpha[y][jp_y_sdr][dp_y_sd] + tsc) > Lalpha[v][jp_v][dp_v])) {
		Lalpha[v][jp_v][dp_v]  = sc;
		Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
	      }
	      if((do_R_v && do_R_y) &&
		 ((sc = Ralpha[y][jp_y_sdr][dp_y_sd] + tsc) > Ralpha[v][jp_v][dp_v])) {
		Ralpha[v][jp_v][dp_v]  = sc;
		Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
	      }
	      /* an easy to overlook case: if d == 0, ensure L and R values are IMPOSSIBLE */
	      if(dp_v == dpn && dn == 0) { /* d is 0 */
		if(do_L_v) Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		if(do_R_v) Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
		/* And another special case for BEGL_S and BEGR_S states,
		 * reset shadow matrix values for d == 0 (which were
		 * initialized to USED_EL above), even though the score of
		 * these cells is impossible we may use them as a
		 * zero-length left or right half of a BIF_B subtree during
		 * construction of the parsetree.
		 */
		if(cm->sttype[v] == S_st) {
		  if(do_L_v) Lyshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		  if(do_R_v) Ryshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		}
	      }
	    }
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	  do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	  do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	  do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	  do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;
	  do_T_z = cp9b->Tvalid[z] && fill_T ? TRUE : FALSE; /* will be FALSE, z is not a B_st */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	i = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the {J,L,R} matrix y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   *
	   * To update a cell in the T matrix with a sum of an R matrix value for y
	   * and a L matrix value for z, there are 2 additional inequalities to satisfy:
	   * (7) k != 0
	   * (8) k != d
	   * We ensure 7 and 8 in the loop below.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      if((do_J_v && do_J_y && do_J_z) &&
		 ((sc = Jalpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]) > Jalpha[v][jp_v][dp_v])) {
		Jalpha[v][jp_v][dp_v]   = sc;
		Jkshadow[v][jp_v][dp_v] = k;
	      }
	      if((do_L_v && do_J_y && do_L_z) &&
		 ((sc = Jalpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]) > Lalpha[v][jp_v][dp_v])) {
		Lalpha[v][jp_v][dp_v]   = sc;
		Lkshadow[v][jp_v][dp_v] = k;
		Lkmode[v][jp_v][dp_v]   = TRMODE_J;
	      }
	      if((do_R_v && do_R_y && do_J_z) &&
		 ((sc = Ralpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]) > Ralpha[v][jp_v][dp_v])) {
		Ralpha[v][jp_v][dp_v]   = sc;
		Rkshadow[v][jp_v][dp_v] = k;
		Rkmode[v][jp_v][dp_v]   = TRMODE_J;
	      }
	      if(k != 0 && k != d) {
		if((do_T_v && do_R_y && do_L_z) &&
		   ((sc = Ralpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]) > Talpha[v][jp_v][dp_v])) {
		  Talpha[v][jp_v][dp_v]   = sc;
		  Tkshadow[v][jp_v][dp_v] = k;
		}
	      }
	    }
	  }
	}
	  }

	  /* two additional special cases in trCYK (these are not in standard CYK).
	   * we do these in their own for(j.. { for(d.. { } } loops b/c one
	   * is independent of z, the other of y, unlike the above loop which is dependent
	   * on both.
	   */
	  if(do_L_v && (do_J_y || do_L_y)) {
	jn = (jmin[v] > jmin[y]) ? jmin[v] : jmin[y];
	jx = (jmax[v] < jmax[y]) ? jmax[v] : jmax[y];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[y] && j <= jmax[y]));
	  dn = (hdmin[v][jp_v] > hdmin[y][jp_y]) ? hdmin[v][jp_v] : hdmin[y][jp_y];
	  dx = (hdmax[v][jp_v] < hdmax[y][jp_y]) ? hdmax[v][jp_v] : hdmax[y][jp_y];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_y = d - hdmin[y][jp_y];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]));
	    if(do_J_y &&
	       ((sc = Jalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v])) {
	      Lalpha[v][jp_v][dp_v]   = sc;
	      Lkshadow[v][jp_v][dp_v] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][jp_v][dp_v]   = TRMODE_J;
	      /* consider making a different mode here, to let the traceback know that right child emits 0 residues,
	       * this should then effect the alignment display, no? it is a different case from the
	       * >0 residues from right child TRMODE_J case for Lalpha checked for in (for k) loop above.
	       */
	    }
	    if(do_L_y &&
	       ((sc = Lalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v])) {
	      Lalpha[v][jp_v][dp_v]   = sc;
	      Lkshadow[v][jp_v][dp_v] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][jp_v][dp_v]   = TRMODE_L;
	      /* consider making a different mode here, to let the traceback know that right child emits 0 residues,
	       * this should then effect the alignment display, no? it is a different case from the
	       * >0 residues from right child TRMODE_L case for Lalpha checked for in (for k) loop above.
	       */
	    }
	  }
	}
	  }
	  if(do_R_v && (do_J_z || do_R_z)) {
	jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_z = j - jmin[z];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[z] && j <= jmax[z]));
	  dn = (hdmin[v][jp_v] > hdmin[z][jp_z]) ? hdmin[v][jp_v] : hdmin[z][jp_z];
	  dx = (hdmax[v][jp_v] < hdmax[z][jp_z]) ? hdmax[v][jp_v] : hdmax[z][jp_z];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_z = d - hdmin[z][jp_z];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]));
	    if(do_J_z &&
	       ((sc = Jalpha[z][jp_z][dp_z]) > Ralpha[v][jp_v][dp_v])) {
	      Ralpha[v][jp_v][dp_v]   = sc;
	      Rkshadow[v][jp_v][dp_v] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][jp_v][dp_v]   = TRMODE_J;
	      /* consider making a different mode here, to let the traceback know that left child emits 0 residues,
	       * this should then effect the alignment display, no? it is a different case from the
	       * >0 residues from left child TRMODE_J case for Ralpha checked for in (for k) loop above.
	       */
	    }
	    if(do_R_z &&
	       ((sc = Ralpha[z][jp_z][dp_z]) > Ralpha[v][jp_v][dp_v])) {
	      Ralpha[v][jp_v][dp_v]   = sc;
	      Rkshadow[v][jp_v][dp_v] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][jp_v][dp_v]   = TRMODE_R;
	      /* consider making a different mode here, to let the traceback know that left child emits 0 residues,
	       * this should then effect the alignment display, no? it is a different case from the
	       * >0 residues from left child TRMODE_R case for Ralpha checked for in (for k) loop above.
	       */
	    }
	  }
	}
	  }
	} /* end of B_st recursion */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 */
	if(L >= jmin[v] && L <= jmax[v]) {
	  jp_v = L - jmin[v];
	  Lp   = L - hdmin[v][jp_v];
	  if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {

	/* If we get here alpha[v][jp_v][Lp] and alpha[0][jp_0][Lp_0]
	 * are valid cells in the banded alpha matrix, corresponding to
	 * alpha[v][L][L] and alpha[0][L][L] in the platonic matrix.
	 * (Le've already made sure alpha[0][jp_0][Lp_0] was valid
	 * at the beginning of the function.)
	 */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  /* check if we have a new optimally scoring Joint alignment in J matrix */
	  if(do_J_v && cp9b->Jvalid[0]) {
	    sc = Jalpha[v][jp_v][Lp] + trpenalty;
	    if (sc > Jalpha[0][jp_0][Lp_0]) {
	      Jalpha[0][jp_0][Lp_0] = sc;
	      Jb = v;
	    }
	  }
	  /* check if we have a new optimally scoring Left alignment in L matrix */
	  if(do_L_v && cp9b->Lvalid[0]) {
	    sc = Lalpha[v][jp_v][Lp] + trpenalty;
	    if (sc > Lalpha[0][jp_0][Lp_0]) {
	      Lalpha[0][jp_0][Lp_0] = sc;
	      Lb = v;
	    }
	  }
	  /* check if we have a new optimally scoring Right alignment in R matrix */
	  if(do_R_v && cp9b->Rvalid[0]) {
	    sc = Ralpha[v][jp_v][Lp] + trpenalty;
	    if (sc > Ralpha[0][jp_0][Lp_0]) {
	      Ralpha[0][jp_0][Lp_0] = sc;
	      Rb = v;
	    }
	  }
	  /* check if we have a new optimally scoring Terminal alignment in T matrix */
	  if(do_T_v && cp9b->Tvalid[0]) {
	    sc = Talpha[v][jp_v][Lp] + trpenalty;
	    if (sc > Talpha[0][jp_0][Lp_0]) {
	      Talpha[0][jp_0][Lp_0] = sc;
	      Tb = v;
	    }
	  }
	}
	  }
	}
  } /* end loop for (v = cm->M-1; v > 0; v--) */

  /* all valid alignments must use a truncated begin */
  if (          cp9b->Jvalid[0]) Jyshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  if (fill_L && cp9b->Lvalid[0]) Lyshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  if (fill_R && cp9b->Rvalid[0]) Ryshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  /* Tyshadow[0] doesn't exist, caller must know how to deal */

  /* determine mode of optimal alignment, if it was preset then use that */
  if(preset_mode == TRMODE_J) {
	sc   = Jalpha[0][jp_0][Lp_0];
	mode = TRMODE_J;
	b    = Jb;
  }
  else if(preset_mode == TRMODE_L) {
	sc   = Lalpha[0][jp_0][Lp_0];
	mode = TRMODE_L;
	b    = Lb;
  }
  else if(preset_mode == TRMODE_R) {
	sc   = Ralpha[0][jp_0][Lp_0];
	mode = TRMODE_R;
	b    = Rb;
  }
  else if(preset_mode == TRMODE_T) {
	sc   = Talpha[0][jp_0][Lp_0];
	mode = TRMODE_T;
	b    = Tb;
  }
  else { /* preset_mode was unknown, max score determines mode */
	sc   = IMPOSSIBLE;
	mode = TRMODE_UNKNOWN;
	if (cp9b->Jvalid[0] && Jalpha[0][jp_0][Lp_0] > sc) {
	  sc   = Jalpha[0][jp_0][Lp_0];
	  mode = TRMODE_J;
	  b    = Jb;
	}
	if (fill_L && cp9b->Lvalid[0] && Lalpha[0][jp_0][Lp_0] > sc) {
	  sc   = Lalpha[0][jp_0][Lp_0];
	  mode = TRMODE_L;
	  b    = Lb;
	}
	if (fill_R && cp9b->Rvalid[0] && Ralpha[0][jp_0][Lp_0] > sc) {
	  sc   = Ralpha[0][jp_0][Lp_0];
	  mode = TRMODE_R;
	  b    = Rb;
	}
	if (fill_T && cp9b->Tvalid[0] && Talpha[0][jp_0][Lp_0] > sc) {
	  sc   = Talpha[0][jp_0][Lp_0];
	  mode = TRMODE_T;
	  b    = Tb;
	}
  }

#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_cykhbmx", "w");   cm_tr_hb_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
	FILE *fp2; fp2 = fopen("tmp.tru_cykhbshmx", "w"); cm_tr_hb_shadow_mx_Dump(fp2, cm, shmx, preset_mode, TRUE); fclose(fp2);
#endif

  if(ret_b    != NULL) *ret_b    = b;
  if(ret_mode != NULL) *ret_mode = mode;
  if(ret_sc   != NULL) *ret_sc   = sc;

  free(el_scA);
  free(yvalidA);

  ESL_DPRINTF1(("cm_TrCYKInsideAlignHB return sc: %f\n", sc));

  if(*ret_mode == TRMODE_UNKNOWN) ESL_FAIL(eslEAMBIGUOUS, errbuf, "cm_TrCYKInsideAlignHB() no valid parsetree found");

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_TrInsideAlign()
 * Date:     EPN, Mon Sep 12 04:31:43 2011
 *
 * Purpose: Run the truncated inside algorithm on a target sequence
 *          without using bands. The full target sequence 1..L is
 *          aligned (only full alignments will contribute to the
 *          Inside score).
 *
 *          Identical to cm_InsideAlign() but no bands are used.
 *
 *          Very similar to cm_TrCYKInsideAlign(), see 'Purpose'
 *          of that function for more details. Only differences with
 *          that function is:
 *           - we do TrInside, not TrCYK
 *           - can't return a shadow matrix (we're not aligning)
 *           - doesn't return bsc, b info about truncated begins
 *
 *          The caller may already know the mode of the alignment,
 *          passed in as <preset_mode>. This will happen if we're
 *          being called from within a search pipeline, for
 *          example. If the caller does not know the optimal mode yet
 *          (e.g. if we're being called for 'cmalign'), <preset_mode>
 *          will be TRMODE_UNKNOWN.
 *
 *          This function complements cm_TrOutsideAlign().
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - target sequence length
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, TRMODE_UNKNOWN to allow any mode
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the dp matrix, grown and filled here
 *           ret_mode    - RETURN: mode of optimal truncation mode, TRMODE_{J,L,R,T} if {J,L,R,T}alpha[0][L][L] is max scoring.
 *           ret_sc      - RETURN: log P(S|M)/P(S|R), as a bit score
 *                         NOTE: we don't sum over different marginal modes, we pick the highest scoring
 *                         one (J,L,R or T) and return {J,L,R,T}alpha[0][L][L] the sum of all complete
 *                         J,L,R, or T alignments.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required CM_TR_MX size exceeds <size_limit>
 *           In this case alignment has been aborted, ret_sc is not valid
 */
int
cm_TrInsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		 CM_TR_MX *mx, char *ret_mode, float *ret_sc)
{
  int      status;          /* easel status code */
  int      v,y,z;	    /* indices for states  */
  int      j,d,i,k;	    /* indices in sequence dimensions */
  float    sc;		    /* a temporary variable holding a score */
  int      yoffset;	    /* y=base+offset -- counter in child states that v can transit to */
  float   *el_scA;          /* [0..d..W-1] probability of local end emissions of length d */
  int      sd;              /* StateDelta(cm->sttype[v]) */
  int      sdl;             /* StateLeftDelta(cm->sttype[v] */
  int      sdr;             /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;           /* j - sdr */
  int      d_sd;            /* d - sd */
  int      d_sdl;           /* d - sdl */
  int      d_sdr;           /* d - sdr */
  float    tsc;             /* a transition score */

  /* other variables used in truncated version, but not standard version (not in cm_CYKInsideAlign()) */
  char     mode = TRMODE_UNKNOWN;  /* truncation mode for obtaining optimal score <ret_sc> */
  int      Lyoffset0;              /* first yoffset to use for updating L matrix in IR/MR states, 1 if IR, 0 if MR */
  int      Ryoffset0;              /* first yoffset to use for updating R matrix in IL/ML states, 1 if IL, 0 if ML */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* Determine which matrices we need to fill in, based on <preset_mode>, if TRMODE_UNKNOWN, fill_L, fill_R, fill_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrInsideAlign(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrInsideAlign(), unexpected pass idx: %d", pass_idx);

  /* Allocations and initializations  */

  /* grow the matrices for current sequence */
  if((status = cm_tr_mx_GrowTo(cm, mx,   errbuf, L, size_limit)) != eslOK) return status;

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0;  d <= j; d++) {
	Jalpha[cm->M][j][d] = el_scA[d];
	  }
	}
	if(fill_L) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) {
	  Lalpha[cm->M][j][d] = el_scA[d];
	}
	  }
	}
	if(fill_R) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) {
	  Ralpha[cm->M][j][d] = el_scA[d];
	}
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v]; /* marginal left  emission scores for state v */
	float const *rmesc_v = cm->rmesc[v]; /* marginal right emission scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdl  = StateLeftDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);

	/* re-initialize the J, L and R decks if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	for (d = sd; d <= j; d++) {
	  Jalpha[v][j][d] = Jalpha[cm->M][j][d-sd] + cm->endsc[v];
	}
	  }
	  if(fill_L) {
	for (j = 0; j <= L; j++) {
	  for (d = sdl; d <= j; d++) {
	    Lalpha[v][j][d] = Lalpha[cm->M][j][d-sdl] + cm->endsc[v];
	  }
	}
	  }
	  if(fill_R) {
	for (j = 0; j <= L; j++) {
	  for (d = sdr; d <= j; d++) {
	    Ralpha[v][j][d] = Ralpha[cm->M][j][d-sdr] + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = 0; j <= L; j++) {
	Jalpha[v][j][0] = 0.;
	if(fill_L) Lalpha[v][j][0] = 0.;
	if(fill_R) Ralpha[v][j][0] = 0.;
	/* rest of deck remains IMPOSSIBLE */
	  }
	}
	else if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update alpha[v][j][d] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1]
	   * We do ML states as well as IL states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat R differently from and J and L
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Ralpha[v][j][d].
	   */
	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Ryoffset0 = cm->sttype[v] == IL_st ? 1 : 0; /* don't allow IL self transits in R mode */
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    d_sd = d - sd;
	    i    = j - d + 1;
	    for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	      y = cm->cfirst[v] + yoffset;
	      Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], Jalpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	      if(fill_L) Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Lalpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	    }
	    Jalpha[v][j][d] += esc_v[dsq[i]];
	    if(fill_L) Lalpha[v][j][d]  = (d >= 2) ? Lalpha[v][j][d] + esc_v[dsq[i]] : esc_v[dsq[i]];

	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    if(fill_L) Lalpha[v][j][d]  = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    i--;

	    /* handle R separately */
	    if(fill_R) {
	      /* note we use 'd', not 'd_sd' (which we used in the corresponding loop for J,L above) */
	      for (yoffset = Ryoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Ryoffset0 instead of 0 disallows IL self transits in R mode */
		y = cm->cfirst[v] + yoffset;
		Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Jalpha[y][j_sdr][d] + tsc_v[yoffset]);
		Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[y][j_sdr][d] + tsc_v[yoffset]);
	      }
	      Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update alpha[v][j][d] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1].
	   * We do MR states as well as IR states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat L differently from and J and R
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Lalpha[v][j][d].
	   */
	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Lyoffset0 = cm->sttype[v] == IR_st ? 1 : 0; /* don't allow IR self transits in L mode */
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    d_sd = d - sd;
	    i = j - d + 1;
	    for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	      y = cm->cfirst[v] + yoffset;
	      Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], Jalpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	      if(fill_R) Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	    }

	    Jalpha[v][j][d] += esc_v[dsq[j]];
	    if(fill_R) Ralpha[v][j][d]  = (d >= 2) ? Ralpha[v][j][d] + esc_v[dsq[j]] : esc_v[dsq[j]];

	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    if(fill_R) Ralpha[v][j][d]  = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);

	    /* handle L separately */
	    if(fill_L) {
	      /* note we use 'j' and 'd', not 'j_sdr' and 'd_sd' (which we used in the corresponding loop for J,R above) */
	      for (yoffset = Lyoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Lyoffset0, instead of 0 disallows IR self transits in L mode */
		y = cm->cfirst[v] + yoffset;
		Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Jalpha[y][j][d] + tsc_v[yoffset]);
		Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Lalpha[y][j][d] + tsc_v[yoffset]);
	      }
	      Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) { /* sd == 2 for MP state */
	    d_sd = d - sd;
	    Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], Jalpha[y][j_sdr][d_sd] + tsc_v[yoffset]);
	  }
	  if(fill_L) {
	    /* note we use 'j' and 'd_sdl' not 'j_sdr' for 'd_sd' for L, plus minimum d is sdl (1) */
	    for (d = sdl; d <= j; d++) { /* sdl == 1 for MP state */
	      d_sdl = d-sdl;
	      Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Jalpha[y][j][d_sdl] + tsc_v[yoffset]);
	      Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Lalpha[y][j][d_sdl] + tsc_v[yoffset]);
	    }
	  }
	  if(fill_R) {
	    /* note we use 'd_sdr' not 'd_sd' for R, plus minimum d is sdr (1) */
	    for (d = sdr; d <= j; d++) { /* sdr == 1 for MP state */
	      d_sdr = d - sdr;
	      Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Jalpha[y][j_sdr][d_sdr] + tsc_v[yoffset]);
	      Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[y][j_sdr][d_sdr] + tsc_v[yoffset]);
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = 0; j <= L; j++) {
	i = j;
	Jalpha[v][j][1] = IMPOSSIBLE;
	if(fill_L) Lalpha[v][j][1] = lmesc_v[dsq[i]];
	if(fill_R) Ralpha[v][j][1] = rmesc_v[dsq[j]];
	i--;
	for (d = 2; d <= j; d++) {
	  Jalpha[v][j][d] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	  if(fill_L) Lalpha[v][j][d] += lmesc_v[dsq[i]];
	  if(fill_R) Ralpha[v][j][d] += rmesc_v[dsq[j]];
	  i--;
	}
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 1; d <= j; d++) {
	  Jalpha[v][j][d] = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	  if(fill_L) Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	  if(fill_R) Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) {
	    d_sd = d-sd;
	    Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], Jalpha[y][j_sdr][d_sd] + tsc);
	    if(fill_L) Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Lalpha[y][j_sdr][d_sd] + tsc);
	    if(fill_R) Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[y][j_sdr][d_sd] + tsc);
	  }
	  /* an easy to overlook case: if d == 0, ensure L and R values are IMPOSSIBLE */
	  if(fill_L) Lalpha[v][j][0] = IMPOSSIBLE;
	  if(fill_R) Ralpha[v][j][0] = IMPOSSIBLE;
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  assert(cm->sttype[v] == B_st);
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], Jalpha[y][j-k][d-k] + Jalpha[z][j][k]);
	    if(fill_L) Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Jalpha[y][j-k][d-k] + Lalpha[z][j][k]);
	    if(fill_R) Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[y][j-k][d-k] + Jalpha[z][j][k]);
	  }
	  if(fill_T) {
	    for(k = 1; k < d; k++) { /* special boundary case for T matrix */
	      Talpha[v][j][d] = FLogsum(Talpha[v][j][d], Ralpha[y][j-k][d-k] + Lalpha[z][j][k]);
	    }
	  }
	  /* two additional special cases in trCYK (these are not in standard CYK) */
	  /* special case 1: k == 0 (full sequence aligns to BEGL_S left child */
	  if(fill_L) {
	    Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Jalpha[y][j][d]);
	    Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Lalpha[y][j][d]);
	  }
	  /* special case 2: k == d (full sequence aligns to BEGR_S right child */
	  if(fill_R) {
	    Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Jalpha[z][j][d]);
	    Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Ralpha[z][j][d]);
	  }
	}
	  }
	} /* end of B_st recursion */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  /* include full length hits in J matrix */
	  Jalpha[0][L][L] = FLogsum(Jalpha[0][L][L], Jalpha[v][L][L] + trpenalty);
	  /* include full length hits in L matrix */
	  if(fill_L) {
	Lalpha[0][L][L] = FLogsum(Lalpha[0][L][L], Lalpha[v][L][L] + trpenalty);
	  }
	  /* include full length hits in R matrix */
	  if(fill_R) {
	Ralpha[0][L][L] = FLogsum(Ralpha[0][L][L], Ralpha[v][L][L] + trpenalty);
	  }
	  /* include full length hits in T matrix */
	  if(fill_T && cm->sttype[v] == B_st) {
	Talpha[0][L][L] = FLogsum(Talpha[0][L][L], Talpha[v][L][L] + trpenalty);
	  }
	}
  } /* end of for (v = cm->M-1; v > 0; v--) */

  /* determine mode of optimal alignment, if it was preset then use that */
  if(preset_mode == TRMODE_J) {
	sc   = Jalpha[0][L][L];
	mode = TRMODE_J;
  }
  else if(preset_mode == TRMODE_L) {
	sc   = Lalpha[0][L][L];
	mode = TRMODE_L;
  }
  else if(preset_mode == TRMODE_R) {
	sc   = Ralpha[0][L][L];
	mode = TRMODE_R;
  }
  else if(preset_mode == TRMODE_T) {
	sc   = Talpha[0][L][L];
	mode = TRMODE_T;
  }
  else { /* preset_mode was unknown, max score determines mode */
	sc   = Jalpha[0][L][L];
	mode = TRMODE_J;
	if (fill_L && Lalpha[0][L][L] > sc) {
	  sc   = Lalpha[0][L][L];
	  mode = TRMODE_L;
	}
	if (fill_R && Ralpha[0][L][L] > sc) {
	  sc   = Ralpha[0][L][L];
	  mode = TRMODE_R;
	}
	if (fill_T && Talpha[0][L][L] > sc) {
	  sc   = Talpha[0][L][L];
	  mode = TRMODE_T;
	}
  }

#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_imx", "w");   cm_tr_mx_Dump(fp1, mx, mode, TRUE); fclose(fp1);
#endif

  if(ret_mode != NULL) *ret_mode = mode;
  if(ret_sc   != NULL) *ret_sc   = sc;

  free(el_scA);

  ESL_DPRINTF1(("cm_TrInsideAlign() return sc: %f\n", sc));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_TrInsideAlignHB()
 * Date:     EPN, Mon Sep 12 04:32:00 2011
 *
 * Purpose: Run the truncated inside algorithm on a target sequence
 *           using bands in the j and d dimensions of the DP
 *           matrix. Bands were obtained from an HMM Forward-Backward
 *           parse of the target sequence. Uses float log odds scores.
 *           The full target sequence 1..L is aligned (only full
 *           alignments will contribute to the Inside score).
 *
 *           Very similar to cm_TrCYKInsideAlignHB(), see 'Purpose'
 *           of that function for more details. Only differences with
 *           that function is:
 *           - we do TrInside, not TrCYK
 *           - can't return a shadow matrix (we're not aligning)
 *           - doesn't return b, info about local begins
 *
 *           The caller may already know the mode of the alignment,
 *           passed in as <preset_mode>. This will happen if we're
 *           being called from within a search pipeline, for
 *           example. If the caller does not know the optimal mode yet
 *           (e.g. if we're being called for 'cmalign'), <preset_mode>
 *           will be TRMODE_UNKNOWN.
 *
 *           This function complements cm_TrOutsideAlignHB().
 *
 * Args:     cm          - the model    [0..M-1]
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - target sequence length
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, TRMODE_UNKNOWN to allow any mode
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the dp matrix, only cells within bands in cp9b will be valid
 *           ret_mode    - RETURN: mode of optimal truncation mode, TRMODE_{J,L,R,T} if {J,L,R,T}alpha[0][L][L] is max scoring.
 *           ret_sc      - RETURN: log P(S|M)/P(S|R), as a bit score
 *                         NOTE: we don't sum over different marginal modes, we pick the highest scoring
 *                         one (J,L,R or T) and return {J,L,R,T}alpha[0][L][L] the sum of all complete
 *                         J,L,R, or T alignments.
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE>     if required CM_TR_HB_MX size exceeds <size_limit>
 *           <eslEINVAL>     if the full sequence is not within the bands for state 0
 *           <eslEAMBIGUOUS> if no valid alignment is possible due to bands (score of sequence is IMPOSSIBLE)
 *           In any of these three cases, alignment has been aborted, ret variables are not valid.
 */
int
cm_TrInsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		   CM_TR_HB_MX *mx, char *ret_mode, float *ret_sc)
{
  int      status;
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;          /* temporary score */
  float    tsc;         /* a temporary variable holding a transition score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      sd;          /* StateDelta(cm->sttype[v]) */
  int      sdl;         /* StateLeftDelta(cm->sttype[v]) */
  int      sdr;         /* StateRightDelta(cm->sttype[v]) */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;      /* [0..d..W-1] probability of local end emissions of length d */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y, dp_z;   /* d index for state v/y/z in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dp_y_sdl;           /* dp_y - sdl */
  int      dp_y_sdr;           /* dp_y - sdr */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  int      Lp;                 /* L also changes depending on state */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* variables related to truncated alignment (not in cm_InsideAlignHB()) */
  char     mode = TRMODE_UNKNOWN;  /* truncation mode for obtaining optimal score <ret_sc> */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z; /* must we fill J matrix deck for state v, y, z? */
  int      do_L_v, do_L_y, do_L_z; /* must we fill L matrix deck for state v, y, z? */
  int      do_R_v, do_R_y, do_R_z; /* must we fill R matrix deck for state v, y, z? */
  int      do_T_v, do_T_y, do_T_z; /* must we fill T matrix deck for state v, y, z? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* Determine which matrices we need to fill in, based on <preset_mode>, if TRMODE_UNKNOWN, fill_L, fill_R, fill_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrInsideAlignHB(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrInsideAlignHB(), unexpected pass idx: %d", pass_idx);

  /* Allocations and initializations */

  /* ensure a full alignment to ROOT_S (v==0) is possible, remember In Inside <preset_mode> may be known or unknown */
  if (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): preset_mode is J mode, but cp9b->Jvalid[v] is FALSE");
  if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): preset_mode is L mode, but cp9b->Lvalid[v] is FALSE");
  if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): preset_mode is R mode, but cp9b->Rvalid[v] is FALSE");
  if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): preset_mode is T mode, but cp9b->Tvalid[v] is FALSE");
  if (preset_mode == TRMODE_UNKNOWN && (! (cp9b->Jvalid[0] || cp9b->Lvalid[0] || cp9b->Rvalid[0] || cp9b->Tvalid[0]))) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): no marginal mode is allowed for state 0");
  }
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)               ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo(cm, mx, errbuf, cp9b, L, size_limit)) != eslOK) return status;

  /* precalcuate all possible local end scores, for local end emits of 1..L residues */
  ESL_ALLOC(el_scA, sizeof(float) * (L+1));
  for(d = 0; d <= L; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* if local ends are on, replace the EL deck IMPOSSIBLEs with EL scores,
   * Note: we could optimize by skipping this step and using el_scA[d] to
   * initialize ELs for each state in the first step of the main recursion
   * below. We fill in the EL deck here for completeness and so that
   * a check of this alpha matrix with a Outside matrix will pass.
   */
  if(cm->flags & CMH_LOCAL_END) {
	if(cp9b->Jvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Jalpha[cm->M][j][d] = el_scA[d];
	/* remember, the EL deck is non-banded */
	  }
	}
	if(fill_L && cp9b->Lvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Lalpha[cm->M][j][d] = el_scA[d];
	  }
	}
	if(fill_R && cp9b->Rvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0;  d <= j; d++) Ralpha[cm->M][j][d] = el_scA[d];
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	float const *esc_v   = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v   = cm->tsc[v];  /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v];
	float const *rmesc_v = cm->rmesc[v];
	sd     = StateDelta(cm->sttype[v]);
	sdl    = StateLeftDelta(cm->sttype[v]);
	sdr    = StateRightDelta(cm->sttype[v]);
	jn     = jmin[v];
	jx     = jmax[v];
	do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	/* re-initialize the J, L or R decks if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	if(do_J_v && cp9b->Jvalid[cm->M]) {
	  if(hdmin[v][jp_v] >= sd) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sd;
	    dp_v = sd - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Jalpha[v][jp_v][dp_v] = el_scA[d-sd] + cm->endsc[v];
	  }
	}

	if(do_L_v && cp9b->Lvalid[cm->M]) {
	  if(hdmin[v][jp_v] >= sdl) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdl;
	    dp_v = sdl - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Lalpha[v][jp_v][dp_v] = el_scA[d-sdl] + cm->endsc[v];
	  }
	}

	if(do_R_v && cp9b->Rvalid[cm->M]) {
	  if(hdmin[v][jp_v] >= sdr) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdr;
	    dp_v = sdr - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Ralpha[v][jp_v][dp_v] = el_scA[d-sdr] + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	if(do_J_v) Jalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_L_v) Lalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_R_v) Ralpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IL states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1]
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */
	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;
	  j_sdr = j - sdr;

	  /* determine which children y we can legally transit to for v, j */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    i    = j - d + 1;
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    /* We need to treat R differently from and J and L here, by
	     * doing separate 'for (yoffset...' loops for J and R
	     * because we have to fully calculate Jalpha[v][jp_v][dp_v])
	     * before we can start to calculate Ralpha[v][jp_v][dp_v].
	     */
	    /* Handle J and L first */
	    if(do_J_v || do_L_v) {
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		if(do_J_y || do_L_y) {
		  jp_y_sdr = j - jmin[y] - sdr;

		  if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		    if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		    if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  }
		}
	      }
	      if(do_J_v) {
		Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]];
		Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      if(do_L_v) {
		Lalpha[v][jp_v][dp_v] = (d >= 2) ? Lalpha[v][jp_v][dp_v] + esc_v[dsq[i]] : esc_v[dsq[i]];
		Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      i--;
	    }

	    if(do_R_v) {
	      /* Handle R separately */
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		if((do_J_y || do_R_y) && (y != v)) { /* (y != v) part is to disallow IL self transits in R mode */
		  jp_y_sdr = j - jmin[y] - sdr;

		  /* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,L above) */
		  if((d) >= hdmin[y][jp_y_sdr] && (d) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y = d - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		    if(do_J_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		    if(do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		  }
		}
	      } /* end of for (yvalid_idx = 0... loop */
	      Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v) */
	}
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IR states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1].
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	  /* The first MR_st/IR_st 'for (j...' loop is for J and R matrices which use the same set of j values */
	if(do_J_v || do_R_v) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];
	    yvalid_ct = 0;
	    j_sdr = j - sdr;

	    /* determine which children y we can legally transit to for v, j */
	    for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	      if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	    for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	      dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	      /* We need to treat L differently from and J and R here, by
	       * doing separate 'for (yoffset...' loops for J because we
	       * have to fully calculate Jalpha[v][jp_v][dp_v]) before we
	       * can start to calculate Lalpha[v][jp_v][dp_v].
	       */
	      /* Handle J and R first */
	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		if(do_J_y || do_R_y) {
		  jp_y_sdr = j - jmin[y] - sdr;

		  if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		    dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		    if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		    if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  }
		}
	      }
	      if(do_J_v) {
		Jalpha[v][jp_v][dp_v] += esc_v[dsq[j]];
		Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	      if(do_R_v) {
		Ralpha[v][jp_v][dp_v] = (d >= 2) ? Ralpha[v][jp_v][dp_v] + esc_v[dsq[j]] : esc_v[dsq[j]];
		Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	    }
	  }
	}
	/* Handle L separately */
	if(do_L_v) {
	  /* The second MR_st/IR_st 'for (j...' loop is for the L matrix which use a different set of j values */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];
	    yvalid_ct = 0;

	    /* determine which children y we can legally transit to for v, j */
	    /* we use 'j' and not 'j_sdr' here for the L matrix, differently from J and R matrices above */
	    for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	      if(j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j is valid for state y? */

	    for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	      dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	      for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		/* Note if we're an IL state, we can't self transit in R mode, this was ensured above when we set up yvalidA[] (xref:ELN3,p5)*/
		yoffset = yvalidA[yvalid_idx];
		y = cm->cfirst[v] + yoffset;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		if((do_J_y || do_L_y) && (y != v)) { /* (y != v) part is to disallow IR self transits in L mode */
		  /* we use 'jp_y=j-min[y]' here, not 'jp_y_sdr=j-jmin[y]-sdr' (which we used in the corresponding loop for J,R above) */
		  jp_y = j - jmin[y];

		  /* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,R above) */
		  if((d) >= hdmin[y][jp_y] && (d) <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		    dp_y = d - hdmin[y][jp_y];
		    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		    ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		    if(do_J_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		    if(do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		  }
		}
	      } /* end of for (yvalid_idx = 0... loop */
	      Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* The first MP_st 'for (jp_v...' loop is for J and R matrices which use the same set of j values */
	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;
	/* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	if((do_J_v && do_J_y) || (do_R_v && (do_J_y || do_R_y))) {
	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    if(do_J_v && do_J_y) {
	      /* J matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sd   = dn - hdmin[y][jp_y_sdr] - sd;

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
		ESL_DASSERT1((dp_v      >= 0 && dp_v       <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y_sd   >= 0 && dp_y_sd    <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      }
	    }

	    if(do_R_v && (do_R_y || do_J_y)) {
	      /* R matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sdr);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sdr);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sdr  = dn - hdmin[y][jp_y_sdr] - sdr;
	      /* for {L,R}alpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		/* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
		ESL_DASSERT1((dp_y_sdr  >= 0 && dp_y_sdr   <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		if(do_J_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sdr] + tsc);
		if(do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sdr] + tsc);
	      }
	    }
	  }
	}

	if(do_L_v && (do_L_y || do_J_y)) {
	  /* The second MP_st 'for (jp_v...' loop is for L matrix, which uses a different set of j values from J and R */
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y] (follows from (j >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y] (follows from (j <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y = jn - jmin[y];
	  /* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y] + sdr);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y] + sdr);
	    dpn       = dn - hdmin[v][jp_v];
	    dpx       = dx - hdmin[v][jp_v];
	    dp_y_sdl  = dn - hdmin[y][jp_y] - sdl;
	    /* for Lalpha, we use 'dp_y_sdl' instead of 'dy_y_sd' */

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdl++) {
	      /* we use 'dp_y_sdl' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
	      ESL_DASSERT1((dp_y_sdl >= 0 && dp_y_sdl  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
	      if(do_J_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y_sdl] + tsc);
	      if(do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y_sdl] + tsc);
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	i     = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++)
	  {
	    if(d >= 2) {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	      if(do_L_v) Lalpha[v][jp_v][dp_v] += lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] += rmesc_v[dsq[j]];
	    }
	    else {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      if(do_L_v) Lalpha[v][jp_v][dp_v] = lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] = rmesc_v[dsq[j]];
	    }
	    i--;
	  }
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	  if(do_J_v) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_L_v) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_R_v) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S (! E && ! B && ! ML && ! IL && ! MR && ! IR) */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	if((do_J_v && do_J_y) || (do_L_v && do_L_y) || (do_R_v && do_R_y)) {
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	  jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y_sdr = jn - jmin[y] - sdr;

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	    dpn     = dn - hdmin[v][jp_v];
	    dpx     = dx - hdmin[v][jp_v];
	    dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc);

	      /* an easy to overlook case: if d == 0, set L and R values to IMPOSSIBLE */
	      if(dp_v == dpn && dn == 0) { /* d is 0 */
		if(do_L_v) Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		if(do_R_v) Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      }
	    }
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	  do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	  do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	  do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	  do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;
	  do_T_z = cp9b->Tvalid[z] && fill_T ? TRUE : FALSE; /* will be FALSE, z is not a B_st */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	i = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the {J,L,R} matrix y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   *
	   * To update a cell in the T matrix with a sum of an R matrix value for y
	   * and a L matrix value for z, there are 2 additional inequalities to satisfy:
	   * (7) k != 0
	   * (8) k != d
	   * We ensure 7 and 8 in the loop below.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      if(do_J_v && do_J_y && do_J_z) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if(do_L_v && do_J_y && do_L_z) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      if(do_R_v && do_R_y && do_J_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if((k != 0) && (k != d)) {
		if(do_T_v && do_R_y && do_L_z) Talpha[v][jp_v][dp_v] = FLogsum(Talpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      }
	    }
	  }
	}
	  }

	  /* two additional special cases in trCYK (these are not in standard CYK).
	   * we do these in their own for(j.. { for(d.. { } } loops b/c one
	   * is independent of z, the other of y, unlike the above loop which is dependent
	   * on both.
	   */
	  if(do_L_v && (do_J_y || do_L_y)) {
	jn = (jmin[v] > jmin[y]) ? jmin[v] : jmin[y];
	jx = (jmax[v] < jmax[y]) ? jmax[v] : jmax[y];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[y] && j <= jmax[y]));
	  dn = (hdmin[v][jp_v] > hdmin[y][jp_y]) ? hdmin[v][jp_v] : hdmin[y][jp_y];
	  dx = (hdmax[v][jp_v] < hdmax[y][jp_y]) ? hdmax[v][jp_v] : hdmax[y][jp_y];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_y = d - hdmin[y][jp_y];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]));
	    if(do_J_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y]);
	    if(do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y]);
	  }
	}
	  }
	  if(do_R_v && (do_J_z || do_R_z)) {
	jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_z = j - jmin[z];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[z] && j <= jmax[z]));
	  dn = (hdmin[v][jp_v] > hdmin[z][jp_z]) ? hdmin[v][jp_v] : hdmin[z][jp_z];
	  dx = (hdmax[v][jp_v] < hdmax[z][jp_z]) ? hdmax[v][jp_v] : hdmax[z][jp_z];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_z = d - hdmin[z][jp_z];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]));
	    if(do_J_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Jalpha[z][jp_z][dp_z]);
	    if(do_R_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[z][jp_z][dp_z]);
	  }
	}
	  }
	} /* end of B_st recursion */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 */
	if(L >= jmin[v] && L <= jmax[v]) {
	  jp_v = L - jmin[v];
	  Lp   = L - hdmin[v][jp_v];
	  if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {
	/* If we get here alpha[v][jp_v][Lp] and alpha[0][jp_0][Lp0]
	 * are valid cells in the banded alpha matrix, corresponding to
	 * alpha[v][L][L] and alpha[0][L][L] in the platonic matrix.
	 * (We've already made sure alpha[0][jp_0][Lp_0] was valid
	 * at the beginning of the function.)
	 */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  /* include full length hits in J matrix */
	  if(do_J_v && cp9b->Jvalid[0]) {
	    Jalpha[0][jp_0][Lp_0] = FLogsum(Jalpha[0][jp_0][Lp_0], Jalpha[v][jp_v][Lp] + trpenalty);
	  }
	  /* include full length hits in L matrix */
	  if(do_L_v && cp9b->Lvalid[0]) {
	    Lalpha[0][jp_0][Lp_0] = FLogsum(Lalpha[0][jp_0][Lp_0], Lalpha[v][jp_v][Lp] + trpenalty);
	  }
	  /* include full length hits in R matrix */
	  if(do_R_v && cp9b->Rvalid[0]) {
	    Ralpha[0][jp_0][Lp_0] = FLogsum(Ralpha[0][jp_0][Lp_0], Ralpha[v][jp_v][Lp] + trpenalty);
	  }
	  /* include full length hits in T matrix */
	  if(do_T_v && cp9b->Tvalid[0]) {
	    Talpha[0][jp_0][Lp_0] = FLogsum(Talpha[0][jp_0][Lp_0], Talpha[v][jp_v][Lp] + trpenalty);
	  }
	}
	  }
	}
  } /* end of for (v = cm->M-1; v > 0; v--) */

  /* determine mode of optimal alignment, if it was preset then use that */
  if(preset_mode == TRMODE_J) {
	sc   = Jalpha[0][jp_0][Lp_0];
	mode = TRMODE_J;
  }
  else if(preset_mode == TRMODE_L) {
	sc   = Lalpha[0][jp_0][Lp_0];
	mode = TRMODE_L;
  }
  else if(preset_mode == TRMODE_R) {
	sc   = Ralpha[0][jp_0][Lp_0];
	mode = TRMODE_R;
  }
  else if(preset_mode == TRMODE_T) {
	sc   = Talpha[0][jp_0][Lp_0];
	mode = TRMODE_T;
  }
  else { /* preset_mode was unknown, max score determines mode */
	sc = IMPOSSIBLE;
	mode = TRMODE_UNKNOWN;

	if (cp9b->Jvalid[0] && Jalpha[0][jp_0][Lp_0] > sc) {
	  sc   = Jalpha[0][jp_0][Lp_0];
	  mode = TRMODE_J;
	}
	if (fill_L && cp9b->Lvalid[0] && Lalpha[0][jp_0][Lp_0] > sc) {
	  sc   = Lalpha[0][jp_0][Lp_0];
	  mode = TRMODE_L;
	}
	if (fill_R && cp9b->Rvalid[0] && Ralpha[0][jp_0][Lp_0] > sc) {
	  sc   = Ralpha[0][jp_0][Lp_0];
	  mode = TRMODE_R;
	}
	if (fill_T && cp9b->Tvalid[0] && Talpha[0][jp_0][Lp_0] > sc) {
	  sc   = Talpha[0][jp_0][Lp_0];
	  mode = TRMODE_T;
	}
  }

#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_ihbmx", "w");   cm_tr_hb_mx_Dump(fp1, mx, mode, TRUE); fclose(fp1);
#endif

  if(ret_mode != NULL) *ret_mode = mode;
  if(ret_sc   != NULL) *ret_sc   = sc;

  free(el_scA);
  free(yvalidA);

  if(ret_sc != NULL) *ret_sc = sc;

  ESL_DPRINTF1(("cm_TrInsideAlignHB() return sc: %f\n", sc));

  if(*ret_mode == TRMODE_UNKNOWN) ESL_FAIL(eslEAMBIGUOUS, errbuf, "cm_TrInsideAlignHB() no valid parsetree found");

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cm_TrOptAccAlign()
 * based on cm_OptAccAlign()
 *
 * Date:     EPN, Wed Sep 28 13:16:12 2011
 *
 * Purpose: Run the truncated version of the Holmes/Durbin optimal
 *           accuracy algorithm on a full target sequence 1..L, given
 *           a pre-filled posterior matrix. Uses float log odds
 *           scores.  Non-banded version. See cm_OptAccAlignHB() for
 *           HMM banded version.
 *
 *           A CM_TR_EMIT_MX matrix <emit_mx> must be passed in,
 *           filled by cm_TrEmitterPosterior(), with values:
 *
 *           {J,L}l_pp[v][i]: log of the posterior probability that
 *           state v emitted residue i leftwise either at (if a match
 *           state) or *after* (if an insert state) the left consensus
 *           position modeled by state v's node, either in Joint
 *           marginal or Left marginal mode {J or L}.
 *
 *           {J,R}r_pp[v][i]: log of the posterior probability that
 *           state v emitted residue i rightwise either at (if a match
 *           state) or *before* (if an insert state) the right
 *           consensus position modeled by state v's node, either in
 *           Joint marginal or Right marginal mode {J or R}.
 *
 *           {J,L}l_pp[v] is NULL for states that do not emit leftwise
 *           {J,r}r_pp[v] is NULL for states that do not emit rightwise
 *
 *           Additionally, a CM_TR_MX DP matrix <mx> and
 *           CM_TR_SHADOW_MX <shmx> must be passed in. <shmx> will be
 *           expanded and filled here with traceback pointers to allow
 *           the optimally accurate parsetree to be recovered in
 *           cm_alignT() and <mx> will be expanded and filled with the
 *           optimal accuracy scores, where:
 *
 *           mx->{J,L,R,T}dp[v][j][d]: log of the sum of the posterior
 *           probabilities of emitting residues i..j in the subtree
 *           rooted at v given that v is in marginal mode J,L,R, or T.
 *
 *           The optimally accurate parsetree in marginal mode
 *           <preset_mode>, i.e. the parsetree that maximizes the sum
 *           of the posterior probabilities of all 1..L emitted
 *           residues, will be found. Its score is returned in
 *           <ret_sc>. The optimal truncated entry state is returned in
 *           <ret_b>, regardless of if we're in global or local mode
 *           because all truncated alignments must use a truncated
 *           begin.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitaized sequence [1..L]
 *           L           - length of the dsq
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, must not be TRMODE_UNKNOWN
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the DP matrix to fill in
 *           shmx        - the shadow matrix to fill in
 *           emit_mx     - pre-filled emit matrix
 *           ret_b       - optimal entry point (state) for the alignment
 *           ret_pp      - RETURN: average posterior probability of aligned residues
 *                         in the optimally accurate parsetree
 *
 * Returns: <eslOK>     on success.
 * Throws:  <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *          If !eslOK: alignment has been aborted, ret_* variables are not valid
 */
int
cm_TrOptAccAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		 CM_TR_MX *mx, CM_TR_SHADOW_MX *shmx, CM_TR_EMIT_MX *emit_mx, int *ret_b, float *ret_pp)
{
  int      status;          /* easel status code */
  int      v,y,z;	    /* indices for states  */
  int      j,d,i,k;	    /* indices in sequence dimensions */
  float    sc;		    /* temporary log odds score */
  float    pp;		    /* average posterior probability of all emitted residues */
  int      yoffset;	    /* y=base+offset -- counter in child states that v can transit to */
  int      sd;              /* StateDelta(cm->sttype[v]) */
  int      sdl;             /* StateLeftDelta(cm->sttype[v] */
  int      sdr;             /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;           /* j - sdr */
  int      d_sd;            /* d - sd */
  int      d_sdl;           /* d - sdl */
  int      d_sdr;           /* d - sdr */
  int      have_el;         /* TRUE if local ends are on in the CM, otherwise FALSE */

  /* other variables used in truncated version, but not standard version (not in cm_OptAccAlign()) */
  int   b = 0;		    /* best truncated entry state */
  int   Lyoffset0;          /* first yoffset to use for updating L matrix in IR/MR states, 1 if IR, 0 if MR */
  int   Ryoffset0;          /* first yoffset to use for updating R matrix in IL/ML states, 1 if IL, 0 if ML */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;            /* index for truncation penalty, determined by pass_idx */
  float trpenalty;          /* truncation penalty, differs based on pty_idx and if we're local or global */
  int   nins_v;             /* number of insert states reachable from current state */
  int   yctr;               /* used for special for(y) loops in TrOptAcc (see code) */

  /* the DP matrices */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  char  ***Jyshadow = shmx->Jyshadow; /* pointer to the Jyshadow matrix */
  char  ***Lyshadow = shmx->Lyshadow; /* pointer to the Lyshadow matrix */
  char  ***Ryshadow = shmx->Ryshadow; /* pointer to the Ryshadow matrix */
  int   ***Jkshadow = shmx->Jkshadow; /* pointer to the Jkshadow matrix */
  int   ***Lkshadow = shmx->Lkshadow; /* pointer to the Lkshadow matrix */
  int   ***Rkshadow = shmx->Rkshadow; /* pointer to the Rkshadow matrix */
  int   ***Tkshadow = shmx->Tkshadow; /* pointer to the Tkshadow matrix */
  char  ***Lkmode   = shmx->Lkmode;   /* pointer to the Lkmode matrix */
  char  ***Rkmode   = shmx->Rkmode;   /* pointer to the Rkmode matrix */

  float  **Jl_pp    = emit_mx->Jl_pp; /* pointer to the prefilled posterior values for left  emitters in Joint mode */
  float  **Ll_pp    = emit_mx->Ll_pp; /* pointer to the prefilled posterior values for left  emitters in Left  mode */
  float  **Jr_pp    = emit_mx->Jr_pp; /* pointer to the prefilled posterior values for right emitters in Joint mode */
  float  **Rr_pp    = emit_mx->Rr_pp; /* pointer to the prefilled posterior values for right emitters in Right mode */

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlign(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrOptAccAlign(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrOptAccAlign(), unexpected pass idx: %d", pass_idx);

  /* we need an emitmap in this function */
  if(cm->emap == NULL) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlign(), emit map is NULL");

  /* Allocations and initializations  */
  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_mx_GrowTo       (cm, mx,   errbuf, L, size_limit)) != eslOK) return status;
  if((status = cm_tr_shadow_mx_GrowTo(cm, shmx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(  mx->Jncells_valid   > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(  mx->Lncells_valid   > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(  mx->Rncells_valid   > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(  mx->Tncells_valid   > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);
  if(shmx->Jy_ncells_valid > 0)           for(i = 0; i < shmx->Jy_ncells_valid; i++) shmx->Jyshadow_mem[i] = USED_EL;
  if(shmx->Ly_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Ly_ncells_valid; i++) shmx->Lyshadow_mem[i] = USED_EL;
  if(shmx->Ry_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Ry_ncells_valid; i++) shmx->Ryshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will almost certainly be overwritten */
  if(shmx->Jk_ncells_valid > 0)           esl_vec_ISet(shmx->Jkshadow_mem, shmx->Jk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) esl_vec_ISet(shmx->Lkshadow_mem, shmx->Lk_ncells_valid, 0);
  if(shmx->Rk_ncells_valid > 0 && fill_R) esl_vec_ISet(shmx->Rkshadow_mem, shmx->Rk_ncells_valid, 0);
  if(shmx->Tk_ncells_valid > 0 && fill_T) esl_vec_ISet(shmx->Tkshadow_mem, shmx->Tk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Lk_ncells_valid; i++) shmx->Lkmode_mem[i] = TRMODE_J;
  if(shmx->Rk_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Rk_ncells_valid; i++) shmx->Rkmode_mem[i] = TRMODE_J;

  /* a special optimal accuracy specific step, initialize Jyshadow intelligently for d == 0
   * (necessary b/c zero length parsetees have 0 emits and so always score IMPOSSIBLE)
   */
  if((status = cm_InitializeOptAccShadowDZero(cm, errbuf, Jyshadow, L)) != eslOK) return status;

  /* start with the EL state */
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el) {
	for (j = 0; j <= L; j++) {
	  if(Jl_pp[cm->M] != NULL)           Jalpha[cm->M][j][0] = Jl_pp[cm->M][0];
	  if(Ll_pp[cm->M] != NULL && fill_L) Lalpha[cm->M][j][0] = Ll_pp[cm->M][0];
	  if(Rr_pp[cm->M] != NULL && fill_R) Ralpha[cm->M][j][0] = Rr_pp[cm->M][0];
	  if(Jl_pp[cm->M] != NULL) {
	i = j;
	for (d = 1; d <= j; d++) Jalpha[cm->M][j][d] = FLogsum(Jalpha[cm->M][j][d-1], Jl_pp[cm->M][i--]);
	  }
	  if(Ll_pp[cm->M] != NULL && fill_L) {
	i = j;
	for (d = 1; d <= j; d++) Lalpha[cm->M][j][d] = FLogsum(Lalpha[cm->M][j][d-1], Ll_pp[cm->M][i--]);
	  }
	  if(Rr_pp[cm->M] != NULL && fill_R) {
	i = j;
	for (d = 1; d <= j; d++) Ralpha[cm->M][j][d] = FLogsum(Ralpha[cm->M][j][d-1], Rr_pp[cm->M][i--]);
	  }
	}
  }

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost done to ROOT_S, we handle that differently */
	sd     = StateDelta(cm->sttype[v]);
	sdl    = StateLeftDelta(cm->sttype[v]);
	sdr    = StateRightDelta(cm->sttype[v]);
	nins_v = NumReachableInserts(cm->stid[v]);

	/* re-initialize if we can do a local end from v */
	if(have_el && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = 0; j <= L; j++) {
	/* copy values from saved EL deck */
	for (d = sd;  d <= j; d++) Jalpha[v][j][d] = Jalpha[cm->M][j-sdr][d-sd];
	for (d = sdl; d <= j; d++) Lalpha[v][j][d] = Lalpha[cm->M][j][d-sdl];
	for (d = sdr; d <= j; d++) Ralpha[v][j][d] = Ralpha[cm->M][j-sdr][d-sdr];
	  }
	}
	/* note there's no E state update here, those cells all remain IMPOSSIBLE */

	if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update alpha[v][j][d] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1]
	   * We do ML states as well as IL states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat R differently from and J and L
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Ralpha[v][j][d].
	   */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Ryoffset0 = cm->sttype[v] == IL_st ? 1 : 0; /* don't allow IL self transits in R mode */
	for (j = sdr; j <= L; j++) {
	  i = j-sd+1;
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++, i--) {
	    d_sd = d - sd;
	    for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	      yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	      y = cm->cfirst[v] + yoffset;
	      if ((sc = Jalpha[y][j_sdr][d_sd]) > Jalpha[v][j][d]) {
		Jalpha[v][j][d]   = sc;
		Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if (fill_L && ((sc = Lalpha[y][j_sdr][d_sd]) > Lalpha[v][j][d])) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	    Jalpha[v][j][d]  = FLogsum(Jalpha[v][j][d], Jl_pp[v][i]);
	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	     * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	     */
	    if((! have_el) && Jyshadow[v][j][d] == USED_EL && d > sd) {
	      Jalpha[v][j][d] = IMPOSSIBLE;
	    }

	    if(fill_L) {
	      if(d >= 2) {
		Lalpha[v][j][d]  = FLogsum(Lalpha[v][j][d], Ll_pp[v][i]);
		/* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions *
		 * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		 */
		if((! have_el) && Lyshadow[v][j][d] == USED_EL) {
		  Lalpha[v][j][d] = IMPOSSIBLE;
		}
	      }
	      else {
		Lalpha[v][j][d]   = Ll_pp[v][i]; /* actually I think this will give the same value as d >= 2 case above */
		Lyshadow[v][j][d] = USED_TRUNC_END;
	      }
	      Lalpha[v][j][d]  = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    }

	    /* handle R separately */
	    if(fill_R) {
	      /* note we use 'd', not 'd_sd' (which we used in the corresponding loop for J,L above) */
	      for (yctr = Ryoffset0; yctr < cm->cnum[v]; yctr++) { /* using Ryoffset0 instead of 0 disallows IL self transits in R mode */
		yoffset = (yctr + nins_v - Ryoffset0) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
		y = cm->cfirst[v] + yoffset;
		if ((sc = Jalpha[y][j_sdr][d]) > Ralpha[v][j][d]) {
		  Ralpha[v][j][d] = sc;
		  Ryshadow[v][j][d]= yoffset + TRMODE_J_OFFSET;
		}
		if ((sc = Ralpha[y][j_sdr][d]) > Ralpha[v][j][d]) {
		  Ralpha[v][j][d] = sc;
		  Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
		}
	      }
	      /* no residue was emitted if we're in R mode */
	      Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm,v )) */
	}
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update alpha[v][j][d] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1].
	   * We do MR states as well as IR states b/c they follow the same rules,
	   * and we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat L differently from and J and R
	   * here, by doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Lalpha[v][j][d].
	   */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	Lyoffset0 = cm->sttype[v] == IR_st ? 1 : 0; /* don't allow IR self transits in L mode */
	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) {
	    d_sd = d - sd;
	    for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	      yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	      y = cm->cfirst[v] + yoffset;
	      if ((sc = Jalpha[y][j_sdr][d_sd]) > Jalpha[v][j][d]) {
		Jalpha[v][j][d]   = sc;
		Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if (fill_R && ((sc = Ralpha[y][j_sdr][d_sd]) > Ralpha[v][j][d])) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	      }
	    }
	    Jalpha[v][j][d]  = FLogsum(Jalpha[v][j][d], Jr_pp[v][j]);
	    Jalpha[v][j][d]  = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	    /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	     * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	     */
	    if((! have_el) && Jyshadow[v][j][d] == USED_EL && d > sd) {
	      Jalpha[v][j][d] = IMPOSSIBLE;
	    }

	    if(fill_R) {
	      if(d >= 2) {
		Ralpha[v][j][d]  = FLogsum(Ralpha[v][j][d], Rr_pp[v][j]);
		/* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
		* (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		*/
		if((! have_el) && Ryshadow[v][j][d] == USED_EL) {
		  Ralpha[v][j][d] = IMPOSSIBLE;
		}
	      }
	      else {
		Ralpha[v][j][d]   = Rr_pp[v][j]; /* actually I think this will give the same value as d >= 2 case above */
		Ryshadow[v][j][d] = USED_TRUNC_END;
	      }
	      Ralpha[v][j][d]  = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	    }

	    /* handle L separately */
	    if(fill_L) {
	      /* note we use 'j' and 'd', not 'j_sdr' and 'd_sd' (which we used in the corresponding loop for J,R above) */
	      for (yctr = Lyoffset0; yctr < cm->cnum[v]; yctr++) { /* using Lyoffset0, instead of 0 disallows IR self transits in L mode */
		yoffset = (yctr + nins_v - Lyoffset0) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
		y = cm->cfirst[v] + yoffset;
		if ((sc = Jalpha[y][j][d]) > Lalpha[v][j][d]) {
		  Lalpha[v][j][d] = sc;
		  Lyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
		}
		if ((sc = Lalpha[y][j][d]) > Lalpha[v][j][d]) {
		  Lalpha[v][j][d] = sc;
		  Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
		}
	      }
	      /* no residue was emitted if we're in R mode */
	      Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	y = cm->cfirst[v] + yoffset;

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;
	  for (d = sd; d <= j; d++) { /* sd == 2 for MP state */
	    d_sd = d-sd;
	    if((sc = Jalpha[y][j_sdr][d_sd]) > Jalpha[v][j][d]) {
	      Jalpha[v][j][d]   = sc;
	      Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	    }
	  }
	  if(fill_L) {
	    /* note we use 'j' and 'd_sdl' not 'j_sdr' for 'd_sd' for L, plus minimum d is sdl (1) */
	    for (d = sdl; d <= j; d++) { /* sdl == 1 for MP state */
	      d_sdl = d-sdl;
	      if((sc = Jalpha[y][j][d_sdl]) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if((sc = Lalpha[y][j][d_sdl]) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	  }
	  if(fill_R) {
	    /* note we use 'd_sdr' not 'd_sd' for R, plus minimum d is sdr (1) */
	    for (d = sdr; d <= j; d++) { /* sdr == 1 for MP state */
	      d_sdr = d - sdr;
	      if((sc = Jalpha[y][j_sdr][d_sdr]) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	      }
	      if((sc = Ralpha[y][j_sdr][d_sdr]) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	      }
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = 0; j <= L; j++) {
	Jalpha[v][j][1] = IMPOSSIBLE;
	if(fill_L) {
	  i = j-1+1;
	  Lalpha[v][j][1]   = Ll_pp[v][i];
	  Lyshadow[v][j][1] = USED_TRUNC_END;
	}
	if(fill_R) {
	  Ralpha[v][j][1]   = Rr_pp[v][j];
	  Ryshadow[v][j][1] = USED_TRUNC_END;
	}
	i = j-2+1;
	for (d = 2; d <= j; d++, i--) {
	  Jalpha[v][j][d] = FLogsum(Jalpha[v][j][d], FLogsum(Jl_pp[v][i], Jr_pp[v][j]));
	}
	if(fill_L) {
	  i = j-2+1;
	  for (d = 2; d <= j; d++, i--) {
	    Lalpha[v][j][d] = FLogsum(Lalpha[v][j][d], Ll_pp[v][i]);
	  }
	}
	if(fill_R) {
	  for (d = 2; d <= j; d++) {
	    Ralpha[v][j][d] = FLogsum(Ralpha[v][j][d], Rr_pp[v][j]);
	  }
	}
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = 0; j <= L; j++) {
	for (d = 1; d <= j; d++) Jalpha[v][j][d] = ESL_MAX(Jalpha[v][j][d], IMPOSSIBLE);
	if(fill_L) for (d = 1; d <= j; d++) Lalpha[v][j][d] = ESL_MAX(Lalpha[v][j][d], IMPOSSIBLE);
	if(fill_R) for (d = 1; d <= j; d++) Ralpha[v][j][d] = ESL_MAX(Ralpha[v][j][d], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el) {
	for (j = 0; j <= L; j++) {
	  for (d = sd+1; d <= j; d++) {
	    if(Jyshadow[v][j][d] == USED_EL) Jalpha[v][j][d] = IMPOSSIBLE;
	  }
	  if(fill_L) {
	    for (d = sdl+1; d <= j; d++) {
	      if(Lyshadow[v][j][d] == USED_EL) Lalpha[v][j][d] = IMPOSSIBLE;
	    }
	  }
	  if(fill_R) {
	    for (d = sdr+1; d <= j; d++) {
	      if(Ryshadow[v][j][d] == USED_EL) Ralpha[v][j][d] = IMPOSSIBLE;
	    }
	  }
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	y = cm->cfirst[v] + yoffset;

	for (j = sdr; j <= L; j++) {
	  j_sdr = j - sdr;

	  for (d = sd; d <= j; d++) {
	    d_sd = d-sd;
	    if((sc = Jalpha[y][j_sdr][d_sd]) > Jalpha[v][j][d]) {
	      Jalpha[v][j][d]   = sc;
	      Jyshadow[v][j][d] = yoffset + TRMODE_J_OFFSET;
	    }
	  }
	  if(fill_L) {
	    for (d = sd; d <= j; d++) {
	      d_sd = d-sd;
	      if((sc = Lalpha[y][j_sdr][d_sd]) > Lalpha[v][j][d]) {
		Lalpha[v][j][d]   = sc;
		Lyshadow[v][j][d] = yoffset + TRMODE_L_OFFSET;
	      }
	    }
	  }
	  if(fill_R) {
	    for (d = sd; d <= j; d++) {
	      d_sd = d-sd;
	      if((sc = Ralpha[y][j_sdr][d_sd]) > Ralpha[v][j][d]) {
		Ralpha[v][j][d]   = sc;
		Ryshadow[v][j][d] = yoffset + TRMODE_R_OFFSET;
	      }
	    }
	  }
	  /* an easy to overlook case: if d == 0, ensure L and R values are IMPOSSIBLE */
	  if(fill_L) Lalpha[v][j][0] = IMPOSSIBLE;
	  if(fill_R) Ralpha[v][j][0] = IMPOSSIBLE;
	  /* And another special case for BEGL_S and BEGR_S states,
	   * reset shadow matrix values for d == 0 (which were
	   * initialized to USED_EL above), even though the score of
	   * these cells is impossible we may use them as a
	   * zero-length left or right half of a BIF_B subtree during
	   * construction of the parsetree.
	   */
	  if(cm->sttype[v] == S_st) {
	    if(fill_L) Lyshadow[v][j][0] = USED_TRUNC_END;
	    if(fill_R) Ryshadow[v][j][0] = USED_TRUNC_END;
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  assert(cm->sttype[v] == B_st);
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  for (k = 0; k <= d; k++) {
	    if((NOT_IMPOSSIBLE(Jalpha[y][j-k][d-k]) || d == k) && /* left  subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
	       (NOT_IMPOSSIBLE(Jalpha[z][j][k])     || k == 0) && /* right subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
	       ((sc = FLogsum(Jalpha[y][j-k][d-k], Jalpha[z][j][k])) > Jalpha[v][j][d])) {
	      Jalpha[v][j][d]   = sc;
	      Jkshadow[v][j][d] = k;
	    }
	  }
	  if(fill_L) {
	    for (k = 0; k <= d; k++) {
	      if((NOT_IMPOSSIBLE(Jalpha[y][j-k][d-k]) || d == k) && /* left  subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		 (NOT_IMPOSSIBLE(Lalpha[z][j][k])     || k == 0) && /* right subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		 ((sc = FLogsum(Jalpha[y][j-k][d-k], Jalpha[z][j][k])) > Jalpha[v][j][d])) {
		Lalpha[v][j][d]   = sc;
		Lkshadow[v][j][d] = k;
		Lkmode[v][j][d]   = TRMODE_J;
	      }
	    }
	  }
	  if(fill_R) {
	    for (k = 0; k <= d; k++) {
	      if((NOT_IMPOSSIBLE(Ralpha[y][j-k][d-k]) || d == k) && /* left  subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		 (NOT_IMPOSSIBLE(Jalpha[z][j][k])     || k == 0) && /* right subtree is not IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		 ((sc = FLogsum(Ralpha[y][j-k][d-k], Jalpha[z][j][k])) > Ralpha[v][j][d])) {
		Ralpha[v][j][d]   = sc;
		Rkshadow[v][j][d] = k;
		Rkmode[v][j][d]   = TRMODE_J;
	      }
	    }
	  }
	  if(fill_T) {
	    for (k = 1; k < d; k++) { /* special boundary case for T matrix */
	      if((NOT_IMPOSSIBLE(Ralpha[y][j-k][d-k])) && /* left  subtree is not IMPOSSIBLE (no check for 'd==k' b/c of special T mx boundary case (see for loop above)) */
		 (NOT_IMPOSSIBLE(Lalpha[z][j][k]))     && /* right subtree is not IMPOSSIBLE (no check for 'k==0' b/c of special T mx boundary case (see for loop above)) */
		 ((sc = FLogsum(Ralpha[y][j-k][d-k], Lalpha[z][j][k])) > Talpha[v][j][d])) {
		Talpha[v][j][d]   = sc;
		Tkshadow[v][j][d] = k;
	      }
	    }
	  }
	  /* two additional special cases in trCYK (these are not in standard CYK) */
	  /* special case 1: k == 0 (full sequence aligns to BEGL_S left child */
	  if(fill_L) {
	    if((sc = Jalpha[y][j][d]) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lkshadow[v][j][d] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][j][d]   = TRMODE_J;
	    }
	    if((sc = Lalpha[y][j][d]) > Lalpha[v][j][d]) {
	      Lalpha[v][j][d]   = sc;
	      Lkshadow[v][j][d] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][j][d]   = TRMODE_L;
	    }
	  }
	  /* special case 2: k == d (full sequence aligns to BEGR_S right child */
	  if(fill_R) {
	    if((sc = Jalpha[z][j][d]) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Rkshadow[v][j][d] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][j][d]   = TRMODE_J;
	    }
	    if((sc = Ralpha[z][j][d]) > Ralpha[v][j][d]) {
	      Ralpha[v][j][d]   = sc;
	      Rkshadow[v][j][d] = d; /* k == d in this case, full sequence is on right */
	      Rkmode[v][j][d]   = TRMODE_R;
	    }
	  }
	}
	  }
	}/* end of B_st recursion */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 *
	 * Since we're in OptAcc alignment we don't assess the
	 * penalty but we still need to know if it's non-IMPOSSIBLE,
	 * to know which states we're allowed to do a truncated
	 * begin into.
	 */
	trpenalty = (have_el) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  if(preset_mode == TRMODE_J) {
	if(Jalpha[v][L][L] > Jalpha[0][L][L]) {
	  Jalpha[0][L][L] = Jalpha[v][L][L];
	  b = v;
	}
	  }
	  else if(preset_mode == TRMODE_L) {
	if(Lalpha[v][L][L] > Lalpha[0][L][L]) {
	  Lalpha[0][L][L] = Lalpha[v][L][L];
	  b = v;
	}
	  }
	  else if(preset_mode == TRMODE_R) {
	if(Ralpha[v][L][L] > Ralpha[0][L][L]) {
	  Ralpha[0][L][L] = Ralpha[v][L][L];
	  b = v;
	}
	  }
	  else if(preset_mode == TRMODE_T) {
	if(cm->sttype[v] == B_st) {
	  if(Talpha[v][L][L] > Talpha[0][L][L]) {
	    Talpha[0][L][L] = Talpha[v][L][L];
	    b = v;
	  }
	}
	  }
	}
  } /* end loop for (v = cm->M-1; v > 0; v--) */

  /* all valid alignments must use a truncated begin */
  Jyshadow[0][L][L] = USED_TRUNC_BEGIN;
  if(fill_L) Lyshadow[0][L][L] = USED_TRUNC_BEGIN;
  if(fill_R) Ryshadow[0][L][L] = USED_TRUNC_BEGIN;
  /* Tyshadow[0] doesn't exist, caller must know how to deal */

  if (preset_mode == TRMODE_J) sc = Jalpha[0][L][L];
  if (preset_mode == TRMODE_L) sc = Lalpha[0][L][L];
  if (preset_mode == TRMODE_R) sc = Ralpha[0][L][L];
  if (preset_mode == TRMODE_T) sc = Talpha[0][L][L];

  /* convert pp, a log probability, into the average posterior probability of all L aligned residues */
  pp = sreEXP2(sc) / (float) L;

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_oamx", "w");   cm_tr_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.tru_oashmx", "w"); cm_tr_shadow_mx_Dump(fp2, cm, shmx, preset_mode, TRUE); fclose(fp2);
#endif

  if(ret_b  != NULL) *ret_b  = b;
  if(ret_pp != NULL) *ret_pp = pp;

  ESL_DPRINTF1(("cm_TrOptAccAlign() return pp: %f\n", pp));
  return eslOK;
}

/* Function: cm_TrOptAccAlignHB()
 * Date:     EPN, Tue Oct 11 10:05:24 2011
 *
 * Purpose: Run the truncated version of the Holmes/Durbin optimal
 *           accuracy algorithm on a full target sequence 1..L, given
 *           a pre-filled posterior matrix. Uses float log odds
 *           scores. HMM banded version. cm_OptAccAlign() is the
 *           non-banded version. See that function's 'Purpose' for
 *           more information. The only difference is that we use
 *           HMM bands from cm->cp9b here. All cells outside the
 *           bands don't exist in memory, so we have to be careful
 *           with offset issues.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitaized sequence [1..L]
 *           L           - length of the dsq
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - the pre-determined alignment mode, can't be TRMODE_UNKNOWN
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the DP matrix to fill in
 *           shmx        - the shadow matrix to fill in
 *           emit_mx     - pre-filled emit matrix
 *           ret_b       - optimal entry point (state) for the alignment
 *           ret_pp      - RETURN: average posterior probability of aligned residues
 *                         in the optimally accurate parsetree
 *
 * Returns: <eslOK>     on success.
 * Throws:  <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *          If !eslOK: alignment has been aborted, ret_* variables are not valid
 */
int
cm_TrOptAccAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		   CM_TR_HB_MX *mx, CM_TR_HB_SHADOW_MX *shmx, CM_TR_HB_EMIT_MX *emit_mx, int *ret_b, float *ret_pp)
{
  int      status;          /* easel status code */
  int      v,y,z;	    /* indices for states  */
  int      j,d,i,k;	    /* indices in sequence dimensions */
  float    sc;		    /* temporary log odds score */
  float    pp;		    /* average posterior probability of all emitted residues */
  int      yoffset;	    /* y=base+offset -- counter in child states that v can transit to */
  int      sd;              /* StateDelta(cm->sttype[v]) */
  int      sdl;             /* StateLeftDelta(cm->sttype[v] */
  int      sdr;             /* StateRightDelta(cm->sttype[v] */
  int      j_sdr;           /* j - sdr */
  int      have_el;         /* TRUE if local ends are on in the CM, otherwise FALSE */

  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      ip_v;               /* offset i index for state v */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_y_sd;            /* dp_y - sd */
  int      dp_y_sdl;           /* dp_y - sdl */
  int      dp_y_sdr;           /* dp_y - sdr */
  int      dp_v, dp_y, dp_z;   /* d index for state v,y,z in HMM banded matrix */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  int     *yvalidA = NULL;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  int      Lp;                 /* L index also changes depending on state */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* other variables used in truncated version, but not standard version (not in cm_OptAccAlign()) */
  int   b = 0;		    /* best truncated entry state */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;            /* index for truncation penalty, determined by pass_idx */
  float trpenalty;          /* truncation penalty, differs based on pty_idx and if we're local or global */
  int   nins_v;             /* number of insert states reachable from current state */
  int   yctr;               /* used for special for(y) loops in TrOptAcc (see code) */

  /* variables related to truncated alignment (not in cm_OptAccAlignHB() */
  int      do_J_v, do_J_y, do_J_z; /* must we fill J matrix deck for state v, y, z? */
  int      do_L_v, do_L_y, do_L_z; /* must we fill L matrix deck for state v, y, z? */
  int      do_R_v, do_R_y, do_R_z; /* must we fill R matrix deck for state v, y, z? */
  int      do_T_v, do_T_y, do_T_z; /* must we fill T matrix deck for state v, y, z? */

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b  = cm->cp9b;
  int        *imin  = cp9b->imin;
  int        *imax  = cp9b->imax;
  int        *jmin  = cp9b->jmin;
  int        *jmax  = cp9b->jmax;
  int       **hdmin = cp9b->hdmin;
  int       **hdmax = cp9b->hdmax;

  /* the DP matrices */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  char  ***Jyshadow = shmx->Jyshadow; /* pointer to the Jyshadow matrix */
  char  ***Lyshadow = shmx->Lyshadow; /* pointer to the Lyshadow matrix */
  char  ***Ryshadow = shmx->Ryshadow; /* pointer to the Ryshadow matrix */
  int   ***Jkshadow = shmx->Jkshadow; /* pointer to the Jkshadow matrix */
  int   ***Lkshadow = shmx->Lkshadow; /* pointer to the Lkshadow matrix */
  int   ***Rkshadow = shmx->Rkshadow; /* pointer to the Rkshadow matrix */
  int   ***Tkshadow = shmx->Tkshadow; /* pointer to the Tkshadow matrix */
  char  ***Lkmode   = shmx->Lkmode;   /* pointer to the Lkmode matrix */
  char  ***Rkmode   = shmx->Rkmode;   /* pointer to the Rkmode matrix */

  float  **Jl_pp    = emit_mx->Jl_pp; /* pointer to the prefilled posterior values for left  emitters in Joint mode */
  float  **Ll_pp    = emit_mx->Ll_pp; /* pointer to the prefilled posterior values for left  emitters in Left  mode */
  float  **Jr_pp    = emit_mx->Jr_pp; /* pointer to the prefilled posterior values for right emitters in Joint mode */
  float  **Rr_pp    = emit_mx->Rr_pp; /* pointer to the prefilled posterior values for right emitters in Right mode */

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrOptAccAlignHB(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrOptAccAlignHB(), unexpected pass idx: %d", pass_idx);

  /* Allocations and initializations  */
  /* In OptAcc <preset_mode> must be known, ensure a full alignment to ROOT_S (v==0) in the optimal mode is allowed by the bands */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): preset_mode is not J, L, R, or T");
  if (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): preset_mode is J mode, but cp9b->Jvalid[v] is FALSE");
  if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): preset_mode is L mode, but cp9b->Lvalid[v] is FALSE");
  if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): preset_mode is R mode, but cp9b->Rvalid[v] is FALSE");
  if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): preset_mode is T mode, but cp9b->Tvalid[v] is FALSE");
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)             ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOptAccAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo       (cm, mx,   errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;
  if((status = cm_tr_hb_shadow_mx_GrowTo(cm, shmx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE, all cells of shadow matrix to USED_EL or USED_TRUNC_END */
  if(  mx->Jncells_valid   > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(  mx->Lncells_valid   > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(  mx->Rncells_valid   > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(  mx->Tncells_valid   > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);
  if(shmx->Jy_ncells_valid > 0)           for(i = 0; i < shmx->Jy_ncells_valid; i++) shmx->Jyshadow_mem[i] = USED_EL;
  if(shmx->Ly_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Ly_ncells_valid; i++) shmx->Lyshadow_mem[i] = USED_EL;
  if(shmx->Ry_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Ry_ncells_valid; i++) shmx->Ryshadow_mem[i] = USED_EL;
  /* for B states, shadow matrix holds k, length of right fragment, this will be overwritten */
  if(shmx->Jk_ncells_valid > 0)           esl_vec_ISet(shmx->Jkshadow_mem, shmx->Jk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) esl_vec_ISet(shmx->Lkshadow_mem, shmx->Lk_ncells_valid, 0);
  if(shmx->Rk_ncells_valid > 0 && fill_R) esl_vec_ISet(shmx->Rkshadow_mem, shmx->Rk_ncells_valid, 0);
  if(shmx->Tk_ncells_valid > 0 && fill_T) esl_vec_ISet(shmx->Tkshadow_mem, shmx->Tk_ncells_valid, 0);
  if(shmx->Lk_ncells_valid > 0 && fill_L) for(i = 0; i < shmx->Lk_ncells_valid; i++) shmx->Lkmode_mem[i] = TRMODE_J;
  if(shmx->Rk_ncells_valid > 0 && fill_R) for(i = 0; i < shmx->Rk_ncells_valid; i++) shmx->Rkmode_mem[i] = TRMODE_J;

  /* a special optimal accuracy specific step, initialize Jyshadow intelligently for d == 0
   * (necessary b/c zero length parsetees have 0 emits and so always score IMPOSSIBLE)
   */
  if((status = cm_InitializeOptAccShadowDZeroHB(cm, cp9b, errbuf, Jyshadow, L)) != eslOK) return status;

  /* start with the EL state (remember the EL deck is non-banded) */
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;
  if(have_el) {
	do_J_v = (cp9b->Jvalid[cm->M] && Jl_pp[cm->M] != NULL)           ? TRUE : FALSE;
	do_L_v = (cp9b->Lvalid[cm->M] && Ll_pp[cm->M] != NULL && fill_L) ? TRUE : FALSE;
	do_R_v = (cp9b->Rvalid[cm->M] && Rr_pp[cm->M] != NULL && fill_R) ? TRUE : FALSE;
	for (j = 0; j <= L; j++) {
	  if(do_J_v) Jalpha[cm->M][j][0] = Jl_pp[cm->M][0];
	  if(do_L_v) Lalpha[cm->M][j][0] = Ll_pp[cm->M][0];
	  if(do_R_v) Ralpha[cm->M][j][0] = Rr_pp[cm->M][0];
	  if(do_J_v) {
	i = j;
	for (d = 1; d <= j; d++) Jalpha[cm->M][j][d] = FLogsum(Jalpha[cm->M][j][d-1], Jl_pp[cm->M][i--]);
	  }
	  if(do_L_v) {
	i = j;
	for (d = 1; d <= j; d++) Lalpha[cm->M][j][d] = FLogsum(Lalpha[cm->M][j][d-1], Ll_pp[cm->M][i--]);
	  }
	  if(do_R_v) {
	i = j;
	for (d = 1; d <= j; d++) Ralpha[cm->M][j][d] = FLogsum(Ralpha[cm->M][j][d-1], Rr_pp[cm->M][i--]);
	  }
	}
  }

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands)
   */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	sd     = StateDelta(cm->sttype[v]);
	sdl    = StateLeftDelta(cm->sttype[v]);
	sdr    = StateRightDelta(cm->sttype[v]);
	nins_v = NumReachableInserts(cm->stid[v]);
	do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	/* re-initialize if we can do a local end from v,
	 * copy values from saved EL deck.
	 * shadow values remain as initialized: USED_EL
	 */
	if(have_el && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  if(do_J_v && cp9b->Jvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    Jalpha[v][jp_v][dp_v] = Jalpha[cm->M][j-sdr][d-sd];
	  }
	}
	  }
	  if(do_L_v && cp9b->Lvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    Lalpha[v][jp_v][dp_v] = Lalpha[cm->M][j][d-sdl];
	  }
	}
	  }
	  if(do_R_v && cp9b->Rvalid[cm->M]) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    Ralpha[v][jp_v][dp_v] = Ralpha[cm->M][j-sdr][d-sdr];
	  }
	}
	  }
	}
	/* note there's no E state update here, those cells all remain IMPOSSIBLE */

	if(cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) {
	  /* update alpha[v][j][d] cells, for IL and ML states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a alpha[v][j][d] cell must be complete
	   * (that is we must have looked at all children y) before can
	   * start calc'ing for alpha[v][j][d+1] We do ML states as well
	   * as IL states b/c they follow the same rules. We could possibly
	   * separate them out and get a small speedup, but I don't think
	   * it's worth further complicating the code.
	   */

	  /* In TrCYK: we need to treat R differently from and J and L
	   * here, by doing separate 'for (d...' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Ralpha[v][j][d].
	   */
	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	if(do_J_v || do_L_v || do_R_v) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];

	    /* determine which children y we can legally transit to for v, j in J and L mode */
	    yvalid_ct = 0;
	    for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	      yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	      y = cm->cfirst[v] + yoffset;
	      if(j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j valid for state y? */
	    }

	    if(do_J_v || do_L_v) {
	      i = j - hdmin[v][jp_v] + 1;
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) { /* for each valid d for v, j */
		assert(i >= imin[v] && i <= imax[v]);
		ESL_DASSERT1((i >= imin[v] && i <= imax[v]));
		ip_v = i - imin[v];         /* i index for state v in emit_mx->{J,L}l_pp */
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

		for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		  yoffset = yvalidA[yvalid_idx];
		  y = cm->cfirst[v] + yoffset;
		  jp_y = j - jmin[y];
		  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;

		  if(do_J_y || do_L_y) {
		    if((d-sd) >= hdmin[y][jp_y] && (d-sd) <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		      dp_y_sd = d - hdmin[y][jp_y] - sd;
		      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		      if(do_J_v && do_J_y) {
			if ((sc = Jalpha[y][jp_y][dp_y_sd]) > Jalpha[v][jp_v][dp_v]) {
			  Jalpha[v][jp_v][dp_v]   = sc;
			  Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
			}
		      }
		      if(do_L_v && do_L_y) {
			if ((sc = Lalpha[y][jp_y][dp_y_sd]) > Lalpha[v][jp_v][dp_v]) {
			  Lalpha[v][jp_v][dp_v]   = sc;
			  Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
			}
		      }
		    }
		  }
		} /* end of 'for (yvalid_idx = 0'... */
		/* add emission PP */
		if(do_J_v) {
		  Jalpha[v][jp_v][dp_v]  = FLogsum(Jalpha[v][jp_v][dp_v], Jl_pp[v][ip_v]);
		  Jalpha[v][jp_v][dp_v]  = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
		  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
		   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		   */
		  if((! have_el) && Jyshadow[v][jp_v][dp_v] == USED_EL && d > sd) {
		    Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		  }
		}
		if(do_L_v) {
		  if(d >= 2) {
		    Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Ll_pp[v][ip_v]);
		    /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions *
		     * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		     */
		    if((! have_el) && Lyshadow[v][jp_v][dp_v] == USED_EL) {
		      Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		    }
		  }
		  else {
		    Lalpha[v][jp_v][dp_v]   = Ll_pp[v][ip_v]; /* actually I think this will give the same value as d >= 2 case above */
		    Lyshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		  }
		  Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
		}
	      }
	    }
	    /* handle R separately */
	    if(do_R_v) {
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

		for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		  yoffset = yvalidA[yvalid_idx];
		  y = cm->cfirst[v] + yoffset;
		  jp_y = j - jmin[y];
		  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;

		  if((do_J_y || do_R_y) && (y != v)) { /* (y != v) part is to disallow IL self transits in R mode */
		    /* note we use 'd', not 'd_sd' (which we used in the corresponding loop for J,L above) */
		    if(d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		      dp_y = d - hdmin[y][jp_y];
		      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		      if(do_J_y) {
			if ((sc = Jalpha[y][jp_y][dp_y]) > Ralpha[v][jp_v][dp_v]) {
			  Ralpha[v][jp_v][dp_v]   = sc;
			  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
			}
		      }
		      if(do_R_y) {
			if ((sc = Ralpha[y][jp_y][dp_y]) > Ralpha[v][jp_v][dp_v]) {
			  Ralpha[v][jp_v][dp_v]   = sc;
			  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
			}
		      }
		    }
		  }
		}
		/* no residue was emitted if we're in R mode */
		Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	    }
	  } /* end of for j loop */
	}
	  } /* end of if(! StateIsDetached(cm,v )) */
	} /* end of if IL/ML state */
	else if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	  /* update alpha[v][j][d] cells, for IR and MR states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a alpha[v][j][d] cell must be complete
	   * (that is we must have looked at all children y) before can
	   * start calc'ing for alpha[v][j][d+1].  We do MR states as well
	   * as IR states here b/c they follow the same rules. We could
	   * possibly separate them out and get a small speedup, but I
	   * don't think it's worth further complicating the code.  and
	   * we're not worried about efficiency here.
	   */

	  /* In TrCYK: we need to treat L differently from and J and R
	   * here, by doing separate 'for (d..' loops for J and R
	   * because we have to fully calculate Jalpha[v][j][d]) before we
	   * can start to calculate Lalpha[v][j][d].
	   */

	  if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	if(do_J_v || do_L_v || do_R_v) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	    jp_v = j - jmin[v];
	    j_sdr = j - sdr;

	    /* determine which children y we can legally transit to for v, j in J and R mode */
	    yvalid_ct = 0;
	    for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	      yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	      y = cm->cfirst[v] + yoffset;
	      if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */
	    }

	    if(do_J_v || do_R_v) {
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
		for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		  yoffset = yvalidA[yvalid_idx];
		  y = cm->cfirst[v] + yoffset;
		  jp_y_sdr = j - jmin[y] - sdr;
		  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;

		  if(do_J_y || do_R_y) {
		    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		      dp_y_sd = d - hdmin[y][jp_y_sdr] - sd;
		      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		      if(do_J_v && do_J_y) {
			if ((sc = Jalpha[y][jp_y_sdr][dp_y_sd]) > Jalpha[v][jp_v][dp_v]) {
			  Jalpha[v][jp_v][dp_v]   = sc;
			  Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
			}
		      }
		      if(do_R_v && do_R_y) {
			if ((sc = Ralpha[y][jp_y_sdr][dp_y_sd]) > Ralpha[v][jp_v][dp_v]) {
			  Ralpha[v][jp_v][dp_v]   = sc;
			  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
			}
		      }
		    }
		  }
		} /* end of 'for (yvalid_idx = 0'... */
		/* add emission PP */
		if(do_J_v) {
		  Jalpha[v][jp_v][dp_v]  = FLogsum(Jalpha[v][jp_v][dp_v], Jr_pp[v][jp_v]);
		  Jalpha[v][jp_v][dp_v]  = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
		  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
		   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		   */
		  if((! have_el) && Jyshadow[v][jp_v][dp_v] == USED_EL && d > sd) {
		    Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		  }
		}
		if(do_R_v) {
		  if(d >= 2) {
		    Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Rr_pp[v][jp_v]);
		    /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
		     * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
		     */
		    if((! have_el) && Ryshadow[v][jp_v][dp_v] == USED_EL) {
		      Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
		    }
		  }
		  else {
		    Ralpha[v][jp_v][dp_v]   = Rr_pp[v][jp_v]; /* actually I think this will give the same value as d >= 2 case above */
		    Ryshadow[v][jp_v][dp_v] = USED_TRUNC_END;
		  }
		  Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
		}
	      } /* end of for(d... */
	    } /* end of if(do_J_v || do_R_v) */
	    /* handle L separately */
	    if(do_L_v) {
	      /* determine which children y we can legally transit to for v, j, this is different for L, b/c j is different,
	       * note we use 'j' and not 'j_sdr' because IR and MR are silent in L marginal mode
	       */
	      yvalid_ct = 0;
	      for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
		yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
		y = cm->cfirst[v] + yoffset;
		if(j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j valid for state y? */
	      }

	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
		for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
		  yoffset = yvalidA[yvalid_idx];
		  y = cm->cfirst[v] + yoffset;
		  jp_y   = j - jmin[y];
		  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;

		  /* note we use 'd' and not 'd-sd' below because IR/MR are silent in L marginal mode */
		  if((do_J_y || do_L_y) && (y != v)) { /* (y != v) part is to disallow IR self transits in L mode */
		    if(d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		      dp_y = d - hdmin[y][jp_y] ;
		      ESL_DASSERT1((dp_v >= 0 && dp_v  <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		      ESL_DASSERT1((dp_y >= 0 && dp_y  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		      if(do_J_y) {
			if ((sc = Jalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v]) {
			  Lalpha[v][jp_v][dp_v]   = sc;
			  Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
			}
		      }
		      if(do_L_y) {
			if ((sc = Lalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v]) {
			  Lalpha[v][jp_v][dp_v]   = sc;
			  Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
			}
		      }
		    }
		  }
		} /* end of 'for (yvalid_idx = 0'... */
		/* no residue was emitted if we're in L mode */
		Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	      }
	    }
	  }
	}
	  } /* end of if(! StateIsDetached(cm, v)) */
	} /* end of if IR/MR state */
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  if(do_J_v || do_L_v || do_R_v) {
	for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	  yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	  y = cm->cfirst[v] + yoffset;
	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;

	  if(do_J_v && do_J_y) {
	    jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	    jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y_sdr = jn - jmin[y] - sdr;
	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	      ESL_DASSERT1((jp_v >= 0     && jp_v     <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	      dpn     = dn - hdmin[v][jp_v];
	      dpx     = dx - hdmin[v][jp_v];
	      dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
		ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		if((sc = Jalpha[y][jp_y_sdr][dp_y_sd]) > Jalpha[v][jp_v][dp_v]) {
		  Jalpha[v][jp_v][dp_v]   = sc;
		  Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		}
	      }
	    }
	  }
	  if(do_L_v && (do_J_y || do_L_y)) {
	    /* note we use 'j' and 'd_sdl' not 'j_sdr' for 'd_sd' for L */
	    jn = ESL_MAX(jmin[v], jmin[y]);
	    jx = ESL_MIN(jmax[v], jmax[y]);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y = jn - jmin[y];
	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	      ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y >= 0 && jp_y <= (jmax[y]-jmin[y])));

	      dn  = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y] + sdl);
	      dx  = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y] + sdl);
	      dpn = dn - hdmin[v][jp_v];
	      dpx = dx - hdmin[v][jp_v];

	      if (do_J_y) {
		dp_y_sdl = dn - hdmin[y][jp_y] - sdl;
		for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdl++) {
		  ESL_DASSERT1((dp_v     >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sdl >= 0 && dp_y_sdl <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		  if((sc = Jalpha[y][jp_y][dp_y_sdl]) > Lalpha[v][jp_v][dp_v]) {
		    Lalpha[v][jp_v][dp_v]   = sc;
		    Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		  }
		}
	      }
	      if (do_L_y) {
		dp_y_sdl = dn - hdmin[y][jp_y] - sdl;
		for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdl++) {
		  ESL_DASSERT1((dp_v     >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sdl >= 0 && dp_y_sdl <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		  if((sc = Lalpha[y][jp_y][dp_y_sdl]) > Lalpha[v][jp_v][dp_v]) {
		    Lalpha[v][jp_v][dp_v]   = sc;
		    Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
		  }
		}
	      }
	    }
	  }
	  if(do_R_v && (do_J_y || do_R_y)) {
	    /* note we use 'd_sdr' not 'd_sd' for R, plus minimum d is sdr (1) */
	    jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	    jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y_sdr = jn - jmin[y] - sdr;
	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	      ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	      dn  = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sdr);
	      dx  = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sdr);
	      dpn = dn - hdmin[v][jp_v];
	      dpx = dx - hdmin[v][jp_v];

	      if (do_J_y) {
		dp_y_sdr = dn - hdmin[y][jp_y_sdr] - sdr;
		for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if((sc = Jalpha[y][jp_y_sdr][dp_y_sdr]) > Ralpha[v][jp_v][dp_v]) {
		    Ralpha[v][jp_v][dp_v]   = sc;
		    Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		  }
		}
	      }
	      if (do_R_y) {
		dp_y_sdr = dn - hdmin[y][jp_y_sdr] - sdr;
		for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if((sc = Ralpha[y][jp_y_sdr][dp_y_sdr]) > Ralpha[v][jp_v][dp_v]) {
		    Ralpha[v][jp_v][dp_v]   = sc;
		    Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
		  }
		}
	      }
	    }
	  }
	}
	  }
	  /* add in emission score */
	  if(do_J_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  ip_v  = i - imin[v];
	  for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++, ip_v--) {
	    if(d >= 2) {
	      Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], FLogsum(Jl_pp[v][ip_v], Jr_pp[v][jp_v]));
	    }
	    else {
	      Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	    }
	  }
	}
	  }
	  if(do_L_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  ip_v  = i - imin[v];
	  for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++, ip_v--) {
	    if(d >= 2) {
	      Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Ll_pp[v][ip_v]);
	    }
	    else {
	      Lalpha[v][jp_v][dp_v]   = Ll_pp[v][ip_v];
	      Lyshadow[v][jp_v][dp_v] = USED_TRUNC_END;
	    }
	  }
	}
	  }
	  if(do_R_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++) {
	    if(d >= 2) {
	      Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Rr_pp[v][jp_v]);
	    }
	    else {
	      Ralpha[v][jp_v][dp_v]   = Rr_pp[v][jp_v];
	      Ryshadow[v][jp_v][dp_v] = USED_TRUNC_END;
	    }
	  }
	}
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  if(do_J_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++, d++) {
	    Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el) {
	    d = hdmin[v][jp_v];
	    for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	      if(Jyshadow[v][jp_v][dp_v] == USED_EL && d > sd) Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      d++;
	    }
	  }
	}
	  }
	  if(do_L_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	    Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el) {
	    d = hdmin[v][jp_v];
	    for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	      if(Lyshadow[v][jp_v][dp_v] == USED_EL && d > sdl) Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      d++;
	    }
	  }
	}
	  }
	  if(do_R_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	    Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	  /* special case if local ends are off: explicitly disallow transitions to EL that require EL emissions
	   * (we do allow an 'illegal' transition to EL in OptAcc but only if no EL emissions are req'd)
	   */
	  if(! have_el) {
	    d = hdmin[v][jp_v];
	    for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	      if(Ryshadow[v][jp_v][dp_v] == USED_EL && d > sdr) Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      d++;
	    }
	  }
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  if(do_J_v || do_L_v || do_R_v) {
	for (yctr = 0; yctr < cm->cnum[v]; yctr++) {
	  yoffset = (yctr + nins_v) % cm->cnum[v]; /* special y ordering for TrOptAcc, consider consensus state first, not inserts */
	  y = cm->cfirst[v] + yoffset;
	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;

	  /*printf("v: %4d y: %4d yoffset: %4d\n", v, y, yoffset);*/
	  if(do_J_v && do_J_y) {
	    jn = ESL_MAX(jmin[v], jmin[y]);
	    jx = ESL_MIN(jmax[v], jmax[y]);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y = jn - jmin[y];

	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	      ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y >= 0 && jp_y <= (jmax[y]-jmin[y])));
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	      dpn  = dn - hdmin[v][jp_v];
	      dpx  = dx - hdmin[v][jp_v];
	      dp_y = dn - hdmin[y][jp_y];

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y++) {
		ESL_DASSERT1((dp_v >= 0 && dp_v  <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y >= 0 && dp_y  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		if((sc = Jalpha[y][jp_y][dp_y]) > Jalpha[v][jp_v][dp_v]) {
		  Jalpha[v][jp_v][dp_v]   = sc;
		  Jyshadow[v][jp_v][dp_v] = yoffset + TRMODE_J_OFFSET;
		}
	      }
	    }
	  }
	  if(do_L_v && do_L_y) {
	    jn = ESL_MAX(jmin[v], jmin[y]);
	    jx = ESL_MIN(jmax[v], jmax[y]);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y = jn - jmin[y];

	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	      ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y >= 0 && jp_y <= (jmax[y]-jmin[y])));
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	      dpn  = dn - hdmin[v][jp_v];
	      dpx  = dx - hdmin[v][jp_v];
	      dp_y = dn - hdmin[y][jp_y];

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y++) {
		ESL_DASSERT1((dp_v >= 0 && dp_v  <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y >= 0 && dp_y  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		if((sc = Lalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v]) {
		  Lalpha[v][jp_v][dp_v]   = sc;
		  Lyshadow[v][jp_v][dp_v] = yoffset + TRMODE_L_OFFSET;
		}
	      }
	    }
	  }
	  /* a couple of special considerations for d == 0 */
	  if(do_L_v) {
	    jn = jmin[v];
	    jx = jmax[v];
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    for (jp_v = jpn; jp_v <= jpx; jp_v++) {
	      /* an easy to overlook case: if d == 0, ensure L value is IMPOSSIBLE */
	      if(hdmin[v][jp_v] == 0) {
		Lalpha[v][jp_v][0] = IMPOSSIBLE;
		/* And another special case for BEGL_S states,
		 * reset shadow matrix values for d == 0 (which were
		 * initialized to USED_EL above), even though the score of
		 * these cells is impossible we may use them as a
		 * zero-length left half of a BIF_B subtree during
		 * construction of the parsetree.
		 */
		if(cm->sttype[v] == S_st) Lyshadow[v][jp_v][0] = USED_TRUNC_END;
	      }
	    }
	  }
	  if(do_R_v && do_R_y) {
	    jn = ESL_MAX(jmin[v], jmin[y]);
	    jx = ESL_MIN(jmax[v], jmax[y]);
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    jp_y = jn - jmin[y];

	    for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	      ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	      ESL_DASSERT1((jp_y >= 0 && jp_y <= (jmax[y]-jmin[y])));
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	      dpn  = dn - hdmin[v][jp_v];
	      dpx  = dx - hdmin[v][jp_v];
	      dp_y = dn - hdmin[y][jp_y];

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y++) {
		ESL_DASSERT1((dp_v >= 0 && dp_v  <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y >= 0 && dp_y  <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		if((sc = Ralpha[y][jp_y][dp_y]) > Ralpha[v][jp_v][dp_v]) {
		  Ralpha[v][jp_v][dp_v]   = sc;
		  Ryshadow[v][jp_v][dp_v] = yoffset + TRMODE_R_OFFSET;
		}
	      }
	    }
	  }
	  /* a couple of special considerations for d == 0 */
	  if(do_R_v) {
	    jn = jmin[v];
	    jx = jmax[v];
	    jpn = jn - jmin[v];
	    jpx = jx - jmin[v];
	    for (jp_v = jpn; jp_v <= jpx; jp_v++) {
	      /* an easy to overlook case: if d == 0, ensure R value is IMPOSSIBLE */
	      if(hdmin[v][jp_v] == 0) {
		Ralpha[v][jp_v][0] = IMPOSSIBLE;
		/* And another special case for BEGL_S states,
		 * reset shadow matrix values for d == 0 (which were
		 * initialized to USED_EL above), even though the score of
		 * these cells is impossible we may use them as a
		 * zero-length left half of a BIF_B subtree during
		 * construction of the parsetree.
		 */
		if(cm->sttype[v] == S_st) Ryshadow[v][jp_v][0] = USED_TRUNC_END;
	      }
	    }
	  }
	}
	  }
	  /* no emission score to add */
	} /* end of 'else if(cm->sttype[v] != B_st)' which is entered for S and D states */
	else { /* B_st */
	  if(do_J_v || do_L_v || do_R_v || do_T_v) {
	y = cm->cfirst[v]; /* left  subtree */
	z = cm->cnum[v];   /* right subtree */

	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;
	do_T_z = cp9b->Tvalid[z] && fill_T ? TRUE : FALSE; /* will be FALSE, z is not a B_st */

	/* Any valid j must be within both state v and state z's j band
	 * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	 * constructed, but we'll check anyway.
	 */
	jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	/* the main j loop */
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];
	  kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		  kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	  /* kn satisfies inequalities (1) and (3) (listed below)*/
	  kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	  /* kn satisfies inequalities (2) and (4) (listed below)*/
	  i = j - hdmin[v][jp_v] + 1;
	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) {
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	    /* Find the first k value that implies a valid cell in the {J,L,R} matrix y and z decks.
	     * This k must satisfy the following 6 inequalities (some may be redundant):
	     * (1) k >= j-jmax[y];
	     * (2) k <= j-jmin[y];
	     *     1 and 2 guarantee (j-k) is within state y's j band
	     *
	     * (3) k >= hdmin[z][j-jmin[z]];
	     * (4) k <= hdmax[z][j-jmin[z]];
	     *     3 and 4 guarantee k is within z's j=(j), d band
	     *
	     * (5) k >= d-hdmax[y][j-jmin[y]-k];
	     * (6) k <= d-hdmin[y][j-jmin[y]-k];
	     *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	     *
	     * kn and kx were set above (outside (for (dp_v...) loop) that
	     * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	     * RHS of inequalities 5 and 6 are dependent on k, so we check
	     * for these within the next for loop.
	     *
	     * To update a cell in the T matrix with a sum of an R matrix value for y
	     * and a L matrix value for z, there are 2 additional inequalities to satisfy:
	     * (7) k != 0
	     * (8) k != d
	     * We ensure 7 and 8 in the loop below.
	     */
	    for(k = kn; k <= kx; k++) {
	      if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
		/* for current k, all 6 inequalities have been satisified
		 * so we know the cells corresponding to the platonic
		 * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
		 * alpha[z][j][k] are all within the bands. These
		 * cells correspond to alpha[v][jp_v][dp_v],
		 * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
		 * and alpha[z][jp_z][k-hdmin[jp_z]];
		 */
		kp_z = k-hdmin[z][jp_z];
		dp_y = d-hdmin[y][jp_y-k];
		if(do_J_v && do_J_y && do_J_z &&
		   (NOT_IMPOSSIBLE(Jalpha[y][jp_y-k][dp_y-k]) || d == k) && /* left  subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (NOT_IMPOSSIBLE(Jalpha[z][jp_z][kp_z])     || k == 0) && /* right subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (sc = FLogsum(Jalpha[y][jp_y-k][dp_y-k], Jalpha[z][jp_z][kp_z])) > Jalpha[v][jp_v][dp_v]) {
		  Jalpha[v][jp_v][dp_v]   = sc;
		  Jkshadow[v][jp_v][dp_v] = k;
		}
		if(do_L_v && do_J_y && do_L_z &&
		   (NOT_IMPOSSIBLE(Jalpha[y][jp_y-k][dp_y-k]) || d == k) && /* left  subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (NOT_IMPOSSIBLE(Lalpha[z][jp_z][kp_z])     || k == 0) && /* right subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (sc = FLogsum(Jalpha[y][jp_y-k][dp_y-k], Lalpha[z][jp_z][kp_z])) > Lalpha[v][jp_v][dp_v]) {
		  Lalpha[v][jp_v][dp_v]   = sc;
		  Lkshadow[v][jp_v][dp_v] = k;
		}
		if(do_R_v && do_R_y && do_J_z &&
		   (NOT_IMPOSSIBLE(Ralpha[y][jp_y-k][dp_y-k]) || d == k) && /* left  subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (NOT_IMPOSSIBLE(Jalpha[z][jp_z][kp_z])     || k == 0) && /* right subtree is not-IMPOSSIBLE or IMPOSSIBLE w/length 0 (latter is ok b/c only emits contribute to score) */
		   (sc = FLogsum(Ralpha[y][jp_y-k][dp_y-k], Jalpha[z][jp_z][kp_z])) > Ralpha[v][jp_v][dp_v]) {
		  Ralpha[v][jp_v][dp_v]   = sc;
		  Rkshadow[v][jp_v][dp_v] = k;
		}
		if((k != 0) && (k != d)) { /* special boundary case for T matrix */
		  if(do_T_v && do_R_y && do_L_z &&
		     (NOT_IMPOSSIBLE(Ralpha[y][jp_y-k][dp_y-k])) &&  /* left  subtree is not-IMPOSSIBLE (no check for 'd==k' b/c of special T mx boundary case (see 3 lines up)) */
		     (NOT_IMPOSSIBLE(Lalpha[z][jp_z][kp_z]))      && /* right subtree is not-IMPOSSIBLE (no check for 'k==0' b/c of special T mx boundary case (see 3 lines up)) */
		     (sc = FLogsum(Ralpha[y][jp_y-k][dp_y-k], Lalpha[z][jp_z][kp_z])) > Talpha[v][jp_v][dp_v]) {
		    Talpha[v][jp_v][dp_v]   = sc;
		    Tkshadow[v][jp_v][dp_v] = k;
		  }
		}
	      }
	    }
	  }
	}
	  }
	  /* two additional special cases in trCYK (these are not in standard CYK).
	   * we do these in their own for(j.. { for(d.. { } } loops b/c one
	   * is independent of z, the other of y, unlike the above loop which is dependent
	   * on both.
	   */
	  if(do_L_v && (do_J_y || do_L_y)) {
	jn = ESL_MAX(jmin[v], jmin[y]);
	jx = ESL_MIN(jmax[v], jmax[y]);
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[y] && j <= jmax[y]));
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_y = d - hdmin[y][jp_y];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]));
	    if(do_J_y && (sc = Jalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v]) {
	      Lalpha[v][jp_v][dp_v]   = sc;
	      Lkshadow[v][jp_v][dp_v] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][jp_v][dp_v]   = TRMODE_J;
	    }
	    if(do_L_y && (sc = Lalpha[y][jp_y][dp_y]) > Lalpha[v][jp_v][dp_v]) {
	      Lalpha[v][jp_v][dp_v]   = sc;
	      Lkshadow[v][jp_v][dp_v] = 0; /* k == 0 for this case, full sequence is on left */
	      Lkmode[v][jp_v][dp_v]   = TRMODE_L;
	    }
	  }
	}
	  }
	  if(do_R_v && (do_J_z || do_R_z)) {
	jn = ESL_MAX(jmin[v], jmin[z]);
	jx = ESL_MIN(jmax[v], jmax[z]);
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_z = j - jmin[z];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[z] && j <= jmax[z]));
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[z][jp_z]);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[z][jp_z]);
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_z = d - hdmin[z][jp_z];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]));
	    if(do_J_z && (sc = Jalpha[z][jp_z][dp_z]) > Ralpha[v][jp_v][dp_v]) {
	      Ralpha[v][jp_v][dp_v]   = sc;
	      Rkshadow[v][jp_v][dp_v] = d; /* k == d for this case, full sequence is on right */
	      Rkmode[v][jp_v][dp_v]   = TRMODE_J;
	    }
	    if(do_R_z && (sc = Ralpha[z][jp_z][dp_z]) > Ralpha[v][jp_v][dp_v]) {
	      Ralpha[v][jp_v][dp_v]   = sc;
	      Rkshadow[v][jp_v][dp_v] = d; /* k == d for this case, full sequence is on right */
	      Rkmode[v][jp_v][dp_v]   = TRMODE_R;
	    }
	  }
	}
	  }
	} /* end of 'else' that is entered if v is a B st */

	/* Now handle from ROOT_S, state 0. So far we haven't touched
	 * the {J,L,R,T}alpha[0] decks at all since initialization and here
	 * we'll only update at most 1 cell in each, the one pertaining
	 * to a full alignment [0][L][L].
	 *
	 * In truncated alignment the only way out of ROOT_S in local or
	 * global mode is via a 'truncated begin' with a score (penalty)
	 * from cm->trp into any emitting state. The penalty was
	 * calculated in cm_tr_penalties_Create() and differs depending on
	 * whether we are in local or global mode and the value of
	 * 'pty_idx' which was passed in.
	 *
	 * Since we're in OptAcc alignment we don't assess the
	 * penalty but we still need to know if it's non-IMPOSSIBLE,
	 * to know which states we're allowed to do a truncated
	 * begin into.
	 */
	if(L >= jmin[v] && L <= jmax[v]) {
	  jp_v = L - jmin[v];
	  Lp   = L - hdmin[v][jp_v];
	  if(L >= hdmin[v][jp_v] && L <= hdmax[v][jp_v]) {
	/* If we get here alpha[v][jp_v][Lp] and alpha[0][jp_0][Lp_0]
	 * are valid cells in the banded alpha matrix, corresponding to
	 * alpha[v][L][L] and alpha[0][L][L] in the platonic matrix.
	 * (We've already made sure alpha[0][jp_0][Lp_0] was valid
	 * at the beginning of the function.)
	 */
	trpenalty = have_el ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  if(preset_mode == TRMODE_J && do_J_v) {
	    if(Jalpha[v][jp_v][Lp] > Jalpha[0][jp_0][Lp_0]) {
	      Jalpha[0][jp_0][Lp_0] = Jalpha[v][jp_v][Lp];
	      b = v;
	    }
	  }
	  if(preset_mode == TRMODE_L && do_L_v) {
	    if(Lalpha[v][jp_v][Lp] > Lalpha[0][jp_0][Lp_0]) {
	      Lalpha[0][jp_0][Lp_0] = Lalpha[v][jp_v][Lp];
	      b = v;
	    }
	  }
	  if(preset_mode == TRMODE_R && do_R_v) {
	    if(Ralpha[v][jp_v][Lp] > Ralpha[0][jp_0][Lp_0]) {
	      Ralpha[0][jp_0][Lp_0] = Ralpha[v][jp_v][Lp];
	      b = v;
	    }
	  }
	  if(preset_mode == TRMODE_T && do_T_v && cm->sttype[v] == B_st) {
	    if(Talpha[v][jp_v][Lp] > Talpha[0][jp_0][Lp_0]) {
	      Talpha[0][jp_0][Lp_0] = Talpha[v][jp_v][Lp];
	      b = v;
	    }
	  }
	}
	  }
	}
  } /* end loop for (v = cm->M-1; v > 0; v--) */

  /* all valid alignments must use a truncated begin */
  if (          cp9b->Jvalid[0]) Jyshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  if (fill_L && cp9b->Lvalid[0]) Lyshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  if (fill_R && cp9b->Rvalid[0]) Ryshadow[0][jp_0][Lp_0] = USED_TRUNC_BEGIN;
  /* Tyshadow[0] doesn't exist, caller must know how to deal */

  if (preset_mode == TRMODE_J) sc = Jalpha[0][jp_0][Lp_0];
  if (preset_mode == TRMODE_L) sc = Lalpha[0][jp_0][Lp_0];
  if (preset_mode == TRMODE_R) sc = Ralpha[0][jp_0][Lp_0];
  if (preset_mode == TRMODE_T) sc = Talpha[0][jp_0][Lp_0];

  /* convert sc, a log probability, into the average posterior probability of all L aligned residues */
  pp = sreEXP2(sc) / (float) L;

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_oahbmx", "w");   cm_tr_hb_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
  FILE *fp2; fp2 = fopen("tmp.tru_oahbshmx", "w"); cm_tr_hb_shadow_mx_Dump(fp2, cm, shmx, preset_mode, TRUE); fclose(fp2);
#endif

  if(ret_b  != NULL) *ret_b  = b;
  if(ret_pp != NULL) *ret_pp = pp;

  free(yvalidA);

  ESL_DPRINTF1(("cm_TrOptAccAlignHB() return pp: %f\n", pp));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVERREACHED */
}

/* Function: cm_TrCYKOutsideAlign()
 * Date:     EPN, Wed Sep 14 14:20:20 2011
 *
 * Purpose:  Run the outside TrCYK algorithm on a target sequence.
 *           Non-banded version. See cm_TrCYKOutsideAlignHB() for
 *           the HMM banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_TrOutsideAlign() but calculates
 *           beta[v][j][d]: log probability of the most likely parse
 *           that emits 1..i-1 and j+1..L and passes through v at j,d
 *           (where i = j-d+1) instead of the log of the summed
 *           probability of all such parses. This means max operations
 *           are used instead of logsums.
 *
 *           Meaning of cells:
 *
 *           Jbeta[v][j][d]: log prob of the most likely parse that
 *                           emits 1..i-1 and j+1..L and passes through
 *                           v in Joint marginal mode at j,d.
 *           Lbeta[v][j][d]: log prob of the most likely parse that
 *                           emits 1..i-1 and j+1..L and passes through
 *                           v in Left marginal mode at j,d.
 *           Rbeta[v][j][d]: log prob of the most likely parse that
 *                           emits 1..i-1 and j+1..L and passes through
 *                           v in Right marginal mode at j,d.
 *
 *           This function complements cm_TrCYKInsideAlign() but is
 *           mainly useful for testing and reference. It can be used
 *           with do_check=TRUE to verify that the implementation of
 *           CYKTrInside and CYKTrOutside are consistent.  Because the
 *           structure of CYKTrInside and TrInside, and CYKTrOutside
 *           and TrOutside are so similar and the CYK variants are
 *           easier to debug (because only the optimal parsetree is
 *           considered instead of all possible parsetrees) this
 *           function can be useful for finding bugs in Outside.  It
 *           is currently not hooked up to any of the main Infernal
 *           programs.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - length of the dsq to align
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check    - TRUE to attempt to check
 *           preset_mode - TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T, the pre-determined
 *                         alignment mode, we'll only allow alignments in this mode.
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - the dp matrix, grown and filled here
 *           inscyk_mx   - the pre-filled dp matrix from the CYK Inside calculation
 *                         (performed by cm_CYKInsideAlign(), required)
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *           <eslEMEM>   if we run out of memory
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 */
int
cm_TrCYKOutsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx, int do_check, CM_TR_MX *mx, CM_TR_MX *inscyk_mx)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  float    Jsc,Lsc,Rsc,Tsc;    /* a temporary variable holding a float score */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float    optsc;              /* the optimal score from the Inside matrix */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[y] */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check */
  int      fail1_flag = FALSE; /* set to TRUE if do_check and we see a problem in check 1 */
  int      fail2_flag = FALSE; /* set to TRUE if do_check and we see a problem in check 2 */
  int      vmax;               /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */
  int     *optseen = NULL;     /* [1..i..L] TRUE is residue i is accounted for in optimal parse */

  /* other variables used in truncated version, but not standard version (not in cm_CYKOutsideAlign()) */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* DP matrix variables */
  float ***Jbeta   = mx->Jdp;     /* pointer to the outside Jbeta DP matrix */
  float ***Lbeta   = mx->Ldp;     /* pointer to the outside Lbeta DP matrix */
  float ***Rbeta   = mx->Rdp;     /* pointer to the outside Rbeta DP matrix */
  float ***Tbeta   = mx->Tdp;     /* pointer to the outside Tbeta DP matrix */

  float ***Jalpha  = inscyk_mx->Jdp; /* pointer to the precalc'ed inside Jalpha DP matrix */
  float ***Lalpha  = inscyk_mx->Ldp; /* pointer to the precalc'ed inside Lalpha DP matrix */
  float ***Ralpha  = inscyk_mx->Rdp; /* pointer to the precalc'ed inside Ralpha DP matrix */
  float ***Talpha  = inscyk_mx->Tdp; /* pointer to the precalc'ed inside Talpha DP matrix, only used to possibly get optsc */

  /* Allocations and initializations */

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlign(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCYKOutsideAlign(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrCYKOussideAlign(), unexpected pass idx: %d", pass_idx);

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_mx_GrowTo(cm, mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* initialize cells in the special ROOT_S deck corresponding to full sequence alignments to 0.0 */
  if     (preset_mode == TRMODE_J) Jbeta[0][L][L] = 0.; /* a full Joint    alignment is outside this cell */
  else if(preset_mode == TRMODE_L) Lbeta[0][L][L] = 0.; /* a full Left     alignment is outside this cell */
  else if(preset_mode == TRMODE_R) Rbeta[0][L][L] = 0.; /* a full Right    alignment is outside this cell */
  else if(preset_mode == TRMODE_T) Tbeta[0][L][L] = 0.; /* a full Terminal alignment is outside this cell */
  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlign() preset_mode %d is invalid", preset_mode);

  /* set cells corresponding to legal truncated begin entry states to
   * the appropriate penalty. In truncated alignment the only way out
   * of ROOT_S in local or global mode is via a 'truncated begin' with
   * a score (penalty) from cm->trp into any emitting state. The
   * penalty was calculated in cm_tr_penalties_Create() and differs
   * depending on whether we are in local or global mode and the value
   * of 'pty_idx' which was passed in.
   */
  for(v = 0; v < cm->M; v++) {
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  if(preset_mode == TRMODE_J) Jbeta[v][L][L] = trpenalty; /* a full Joint alignment is outside this cell */
	  if(preset_mode == TRMODE_L) Lbeta[v][L][L] = trpenalty; /* a full Left  alignment is outside this cell */
	  if(preset_mode == TRMODE_R) Rbeta[v][L][L] = trpenalty; /* a full Right alignment is outside this cell */
	  if(preset_mode == TRMODE_T && cm->sttype[v] == B_st) {
	Tbeta[v][L][L] = trpenalty; /* a full Terminal alignment is outside this cell */
	  }
	}
  }

  /* main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if(! StateIsDetached(cm, v)) {
	  sd  = StateDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);

	  if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	y = cm->plast[v];	/* the parent bifurcation    */
	z = cm->cnum[y];	/* the other (right) S state */
	for(j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    for (k = 0; k <= (L-j); k++) {
	      Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j+k][d+k] + Jalpha[z][j+k][k]); /* A */
	      if(fill_L) {
		Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Lbeta[y][j+k][d+k] + Lalpha[z][j+k][k]); /* B */
	      }
	      if(fill_R) {
		Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j+k][d+k] + Jalpha[z][j+k][k]); /* C */
		if(fill_T && fill_L && d == j && (j+k) == L) {
		  Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Tbeta[y][j+k][d+k] + Lalpha[z][j+k][k]); /* D */
		  /* Note: Tbeta[y][j+k==L][d+k==L] will be 0.0 or
		   * IMPOSSIBLE because it was initialized that
		   * way. That T cell includes the full target 1..L
		   * (any valid T alignment must because we must
		   * account for the full target) rooted at a B state,
		   * and a transition from that B state to this BEGL_S
		   * is always probability 1.0.
		   */
		}
	      }
	    } /* end of for k loop */
	    if(fill_L) {
	      Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Lbeta[y][j][d]); /* entire sequence on left, no sequence on right, k == 0 */
	      Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d]); /* entire sequence on left, no sequence on right, k == 0 */
	    }
	  }
	}
	  } /* end of 'if (cm->stid[v] == BEGL_S */
	  else if (cm->stid[v] == BEGR_S) {
	y = cm->plast[v];	  /* the parent bifurcation    */
	z = cm->cfirst[y];  /* the other (left) S state  */
	for(j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    i = j-d+1;
	    for (k = 0; k <= (j-d); k++) {
	      Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j][d+k] + Jalpha[z][j-d][k]); /* A */
	      if(fill_R) {
		Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Rbeta[y][j][d+k] + Ralpha[z][j-d][k]); /* C */
	      }
	      if(fill_L) {
		Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d+k] + Jalpha[z][j-d][k]); /* B */
		if(fill_T && fill_R && k == (i-1) && j == L) {
		  Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Tbeta[y][j][d+k] + Ralpha[z][j-d][k]); /* D */
		  /* Note: Tbeta[y][j==L][d+k==L] will be 0.0 or
		   * IMPOSSIBLE because it was initialized that
		   * way. That T cell includes the full target 1..L (any
		   * valid T alignment must because we must account for
		   * the full target) rooted at a B state, and a
		   * transition from that B state to this BEGR_S is
		   * always probability 1.0.
		   */
		}
	      }
	    }
	    if(fill_R) {
	      Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Rbeta[y][j][d]); /* entire sequence on right, no sequence on left, k == 0 */
	      Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j][d]); /* entire sequence on right, no sequence on left, k == 0 */
	    }
	  }
	}
	  } /* end of 'else if (cm->stid[v] == BEGR_S */
	  else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	for (j = L; j >= 0; j--) {
	  i = 1;
	  for (d = j; d >= 0; d--, i++) {
	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      /* mind the following sneaky if statement: in truncated
	       * aln, the only way out of state 0 is through a
	       * truncated begin, which we handled above (search for
	       * 'trpenalty'). If we're in local mode transitions out
	       * of 0 will have IMPOSSIBLE scores, but NOT if we're in
	       * glocal mode, so we need this 'if'.
	       */
	      if(y != 0) {
		voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
		sd  = StateDelta(cm->sttype[y]);
		sdl = StateLeftDelta(cm->sttype[y]);
		sdr = StateRightDelta(cm->sttype[y]);
		switch(cm->sttype[y]) {
		case MP_st:
		  if(j != L && d != j) {
		    escore = cm->oesc[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		    Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_L && j == L && d != j) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		    escore = cm->lmesc[y][dsq[i-1]];
		    Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Lbeta[y][j][d+sdl] + cm->tsc[y][voffset] + escore);
		    Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d+sdl] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_R && i == 1 && j != L) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		    escore = cm->rmesc[y][dsq[j+1]];
		    Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Rbeta[y][j+sdr][d+sdr] + cm->tsc[y][voffset] + escore);
		    Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j+sdr][d+sdr] + cm->tsc[y][voffset] + escore);
		  }
		  break;
		case ML_st:
		case IL_st:
		  if (d != j) {
		    escore = cm->oesc[y][dsq[i-1]];
		    Jbeta[v][j][d]            = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j][d+sd] + cm->tsc[y][voffset] + escore);
		    if(fill_L) Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d+sd] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_R && i == 1 && /* only allow transition from R if we're emitting first residue 1 from y  */
		     v != y) {           /* will only happen if v == IL, we don't allow silent self transitions from IL->IL */
		    Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Rbeta[y][j][d] + cm->tsc[y][voffset]);
		    Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j][d] + cm->tsc[y][voffset]);
		  }
		  break;
		case MR_st:
		case IR_st:
		  if (j != L) {
		    escore = cm->oesc[y][dsq[j+1]];
		    Jbeta[v][j][d]            = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		    if(fill_R) Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_L && j == L && /* only allow transition from L if we're emitting final residue L from y */
		     v != y) {           /* will only happen if v == IR, we don't allow silent self transitions from IR->IR */
		    Jbeta[v][j][d] = ESL_MAX(Jbeta[v][j][d], Lbeta[y][j][d] + cm->tsc[y][voffset]);
		    Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d] + cm->tsc[y][voffset]);
		  }
		  break;
		case S_st:
		case E_st:
		case D_st:
		  Jbeta[v][j][d]            = ESL_MAX(Jbeta[v][j][d], Jbeta[y][j][d] + cm->tsc[y][voffset]);
		  if(fill_L) Lbeta[v][j][d] = ESL_MAX(Lbeta[v][j][d], Lbeta[y][j][d] + cm->tsc[y][voffset]);
		  if(fill_R) Rbeta[v][j][d] = ESL_MAX(Rbeta[v][j][d], Rbeta[y][j][d] + cm->tsc[y][voffset]);
		  break;
		} /* end of switch(cm->sttype[y] */
	      } /* end of sneaky if y != 0 */
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (Jbeta[v][j][d] < IMPOSSIBLE) Jbeta[v][j][d] = IMPOSSIBLE;
	  } /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	} /* end loop over j. We know beta for this whole state */
	  } /* end of 'else' (if cm->sttype[v] != BEGL_S, BEGR_S) */
	} /* end of 'if(! StateIsDetached(cm, v))' */
	/* we're done calculating deck v for everything but local ends */

	/* deal with local alignment end transitions v->EL J matrix only (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sd  = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	  sdl = StateLeftDelta(cm->sttype[v]);  /* note sdl is for state v */
	  sdr = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  i = j-d+1;
	  switch (cm->sttype[v]) {
	  case MP_st:
	    if (j != L && d != j) {
	      escore = cm->oesc[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd] + cm->endsc[v] + escore));
	    }
	    if(fill_L && j == L && d != j) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
	      escore = cm->lmesc[v][dsq[i-1]];
	      Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][j][d+sdl] + cm->endsc[v] + escore));
	    }
	    if(fill_R && i == 1 && j != L) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
	      escore = cm->rmesc[v][dsq[j+1]];
	      Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sdr] + cm->endsc[v] + escore));
	    }
	    break;
	  case ML_st:
	  case IL_st:
	    if (d != j) {
	      escore = cm->oesc[v][dsq[i-1]];
	      Jbeta[cm->M][j][d]            = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][j][d+sd] + cm->endsc[v] + escore));
	      if(fill_L) Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][j][d+sd] + cm->endsc[v] + escore));
	    }
	    if(fill_R && i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i == 1) */
	      Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], Rbeta[v][j][d] + cm->endsc[v]);
	    }
	    break;
	  case MR_st:
	  case IR_st:
	    if(j != L) {
	      escore = cm->oesc[v][dsq[j+1]];
	      Jbeta[cm->M][j][d]            = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd] + cm->endsc[v] + escore));
	      if(fill_R) Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sd] + cm->endsc[v] + escore));
	    }
	    if(fill_L && j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j == L) */
	      Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], Lbeta[v][j][d] + cm->endsc[v]);
	    }
	    break;
	  case S_st:
	  case D_st:
	  case E_st:
	    Jbeta[cm->M][j][d]            = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    if(fill_L) Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    if(fill_R) Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    break;
	  }
	}
	  }
	}
  }
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	Jbeta[cm->M][j][d]            = ESL_MAX(Jbeta[cm->M][j][d], Jbeta[cm->M][j][d+1] + cm->el_selfsc);
	if(fill_L) Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], Lbeta[cm->M][j][d+1] + cm->el_selfsc);
	if(fill_R) Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], Rbeta[cm->M][j][d+1] + cm->el_selfsc);
	  }
	}
  }

  fail1_flag = FALSE;
  fail2_flag = FALSE;
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. we assume the Inside CYK parse score
	 * (optsc) is the optimal score, so for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 * Lalpha[v][j][d] + Lbeta[v][j][d] <= optsc
	 * Ralpha[v][j][d] + Rbeta[v][j][d] <= optsc
	 *
	 * Further, we know that each residue must be emitted by a state
	 * in the optimal parse. So as we do the above check, we determine
	 * when we're in a cell that may be involved in the optimal parse
	 * (the sum of the Inside and Outside scores are equal to the
	 * optimal parse score), if that cell corresponds to a left
	 * emitter emitting position i, we know an emitted i has been
	 * observed in an optimal parse and set optseen[i] to TRUE.
	 * Likewise, if that cell corresponds to a right emitter emitting
	 * position j, we update optseen[j] to TRUE. At the end of the
	 * check optseen[i] should be TRUE for all i in the range
	 * [1..L].
	 *
	 * Note that we don't ensure that all of our presumed optimal
	 * cells make up a valid parse, so it is possible we could pass
	 * this check even if the Inside and Outside matrices are
	 * inconsistent (i.e. there's a bug in the implementation of one
	 * and/or the other) but that should be extremely unlikely.  If we
	 * do this test many times for many different models and pass, we
	 * should be confident we have consistent implementations.
	 *
	 * Note that we don't check fill_L and fill_R variables
	 * here, although they will have dictated whether we've filled
	 * in the L and R matrices. If they're FALSE, those matrices
	 * should remain as they've been initialized as all IMPOSSIBLE
	 * values, so they won't cause us to fail our tests here.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 */
	ESL_ALLOC(optseen, sizeof(int) * (L+1));
	esl_vec_ISet(optseen, L+1, FALSE);
	vmax = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	if     (preset_mode == TRMODE_J) optsc = Jalpha[0][L][L];
	else if(preset_mode == TRMODE_L) optsc = Lalpha[0][L][L];
	else if(preset_mode == TRMODE_R) optsc = Ralpha[0][L][L];
	else if(preset_mode == TRMODE_T) optsc = Talpha[0][L][L];
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  for(j = 1; j <= L; j++) {
	for(d = 0; d <= j; d++) {
	  Jsc  = Jalpha[v][j][d] + Jbeta[v][j][d] - optsc;
	  Lsc  = (fill_L) ? Lalpha[v][j][d] + Lbeta[v][j][d] - optsc : IMPOSSIBLE;
	  Rsc  = (fill_R) ? Ralpha[v][j][d] + Rbeta[v][j][d] - optsc : IMPOSSIBLE;
	  Tsc  = (fill_T && cm->sttype[v] == B_st) ? Talpha[v][j][d] + Tbeta[v][j][d] - optsc : IMPOSSIBLE;
	  if(Jsc > tol) {
	    printf("Check 1 J failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Jalpha[v][j][d], Jbeta[v][j][d], Jalpha[v][j][d] + Jbeta[v][j][d], optsc);
	    fail1_flag = TRUE;
	  }
	  if(Lsc > tol) {
	    printf("Check 1 L failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Lalpha[v][j][d], Lbeta[v][j][d], Lalpha[v][j][d] + Lbeta[v][j][d], optsc);
	    fail1_flag = TRUE;
	  }
	  if(Rsc > tol) {
	    printf("Check 1 R failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Ralpha[v][j][d], Rbeta[v][j][d], Ralpha[v][j][d] + Rbeta[v][j][d], optsc);
	    fail1_flag = TRUE;
	  }
	  if(cm->sttype[v] == B_st && Tsc > tol) {
	    printf("Check 1 T failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Talpha[v][j][d], Tbeta[v][j][d], Talpha[v][j][d] + Tbeta[v][j][d], optsc);
	    fail1_flag = TRUE;
	  }
	  if(((fabs(Jsc) < tol || fabs(Lsc) < tol) &&
	      (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st || (cm->sttype[v] == EL_st && d >0))) ||
	     ((fabs(Rsc) < tol && cm->sttype[v] == EL_st && d >0))) {
	    i = j-d+1;
	    /* i is accounted for by a parse with an optimal score */
	    optseen[i] = TRUE;
	    /*
	      if     (fabs(Jsc) < tol) printf("\tResidue %4d possibly accounted for by J matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	      else if(fabs(Lsc) < tol) printf("\tResidue %4d possibly accounted for by L matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	      else if(fabs(Rsc) < tol) printf("\tResidue %4d possibly accounted for by R matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	    */
	  }
	  if((fabs(Jsc) < tol || fabs(Rsc) < tol) &&
	     (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)) {
	    /* j is accounted for by a parse with an optimal score */
	    optseen[j] = TRUE;
	    /*
	       if     (fabs(Jsc) < tol) printf("\tResidue %4d possibly accounted for by J matrix Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);
	       else if(fabs(Rsc) < tol) printf("\tResidue %4d possibly accounted for by R matrix Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);
	    */
	  }
	}
	  }
	}
	for(j = 1; j <= L; j++) {
	  if(optseen[j] == FALSE) {
	printf("Check 2 failure: residue %d not emitted in the optimal parsetree\n", j);
	fail2_flag = TRUE;
	  }
	}
	free(optseen);
  }
  if(fail1_flag || fail2_flag) for(j = 1; j <= L; j++) printf("dsq[%4d]: %4d\n", j, dsq[j]);

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_ocykmx", "w");   cm_tr_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
#endif

  if(do_check) {
	if     (fail1_flag) ESL_FAIL(eslFAIL, errbuf, "TrCYK Inside/Outside check1 FAILED.");
	else if(fail2_flag) ESL_FAIL(eslFAIL, errbuf, "TrCYK Inside/Outside check2 FAILED.");
	/*else                printf("SUCCESS! TrCYK Inside/Outside checks PASSED.\n");*/
  }

  if     (preset_mode == TRMODE_J) optsc = Jalpha[0][L][L];
  else if(preset_mode == TRMODE_L) optsc = Lalpha[0][L][L];
  else if(preset_mode == TRMODE_R) optsc = Ralpha[0][L][L];
  else if(preset_mode == TRMODE_T) optsc = Talpha[0][L][L];
  ESL_DPRINTF1(("\tcm_TrCYKOutsideAlign() sc : %f (sc is from Inside!)\n", optsc));

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_TrCYKOutsideAlignHB()
 * Date:     EPN, Sat Oct  8 15:42:48 2011
 *
 * Purpose:  Run the outside TrCYK algorithm on a target sequence.
 *           HMM banded version. See cm_TrCYKOutsideAlign() for
 *           the non-banded version. The full target sequence
 *           1..L is aligned.
 *
 *           Very similar to cm_TrOutsideAlignHB() but calculates
 *           beta[v][j][d]: log probability of the most likely parse
 *           that emits 1..i-1 and j+1..L and passes through v at j,d
 *           (where i = j-d+1) instead of the log of the summed
 *           probability of all such parses. This means max operations
 *           are used instead of logsums.
 *
 *           This function complements cm_TrCYKInsideAlignHB() but is
 *           mainly useful for testing and reference. It can be used
 *           with do_check=TRUE to verify that the implementation of
 *           TrCYKInsideAlignHB and TrCYKOutsideAlignHB are
 *           consistent.  Because the structure of TrCYKInsideAlignHB
 *           and TrInsideAlignHB, and TrCYKOutsideAlignHB and
 *           TrOutsideAlignHB are so similar and the TrCYK variants
 *           are easier to debug (because only the optimal parsetree
 *           is considered instead of all possible parsetrees) this
 *           function can be useful for finding bugs in
 *           TrOutsideAlignHB. It is currently not hooked up to any of
 *           the main Infernal programs.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - length of the dsq to align
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           do_check    - TRUE to attempt to check
 *           mx          - the dp matrix, only cells within bands in cp9b will be valid
 *           preset_mode - TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T, the pre-determined
 *                         alignment mode, we'll only allow alignments in this mode.
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           ins_mx      - the dp matrix from the Inside run calculation (required)
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *           <eslEMEM>   if we run out of memory
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted.
 */
int
cm_TrCYKOutsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		       int do_check, CM_TR_HB_MX *mx, CM_TR_HB_MX *inscyk_mx)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  float    Jsc,Lsc,Rsc,Tsc;    /* temporary variables holding a float score */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    optsc;              /* optimal score in <preset_mode>, from Inside */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      emitmode;           /* EMITLEFT, EMITRIGHT, EMITPAIR, EMITNONE, for state y */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[y] */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check */
  int      fail1_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 1*/
  int      fail2_flag = FALSE; /* set to TRUE if do_check and we see a problem with check 2*/
  int      vmax;               /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */
  int     *optseen = NULL;     /* [1..i..W] TRUE is residue i is accounted for in optimal parse */

  /* band related variables */
  int      dp_v;               /* d index for state v in alpha w/mem eff bands */
  int      dp_y;               /* d index for state y in alpha w/mem eff bands */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      Lp;                 /* L index also changes depending on state */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      kmin, kmax;         /* temporary minimum/maximum allowed k */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* variables related to truncated alignment (not in cm_CYKInsideAlignHB() */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z; /* must we fill J matrix deck for state v, y, z? */
  int      do_L_v, do_L_y, do_L_z; /* must we fill L matrix deck for state v, y, z? */
  int      do_R_v, do_R_y, do_R_z; /* must we fill R matrix deck for state v, y, z? */
  int      do_T_v, do_T_y;         /* is T matrix valid for state v, y?    */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* DP matrix variables */
  float ***Jbeta   = mx->Jdp;     /* pointer to the outside Jbeta DP matrix */
  float ***Lbeta   = mx->Ldp;     /* pointer to the outside Lbeta DP matrix */
  float ***Rbeta   = mx->Rdp;     /* pointer to the outside Rbeta DP matrix */
  float ***Tbeta   = mx->Tdp;     /* pointer to the outside Tbeta DP matrix */

  float ***Jalpha  = inscyk_mx->Jdp; /* pointer to the precalc'ed inside Jalpha DP matrix */
  float ***Lalpha  = inscyk_mx->Ldp; /* pointer to the precalc'ed inside Lalpha DP matrix */
  float ***Ralpha  = inscyk_mx->Rdp; /* pointer to the precalc'ed inside Ralpha DP matrix */
  float ***Talpha  = inscyk_mx->Tdp; /* pointer to the precalc'ed inside Talpha DP matrix, only used to possibly get optsc */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin    = cm->cp9b->jmin;
  int     *jmax    = cm->cp9b->jmax;
  int    **hdmin   = cm->cp9b->hdmin;
  int    **hdmax   = cm->cp9b->hdmax;

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if(preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCYKOutsideAlignHB(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrCYKOutsideAlignHB(), unexpected pass idx: %d", pass_idx);

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo(cm, mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* ensure a full alignment in <preset_mode> to ROOT_S (v==0) is allowed by the bands */
  if      (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB() preset_mode is J but cp9b->Jvalid[0] is FALSE");
  else if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB() preset_mode is L but cp9b->Lvalid[0] is FALSE");
  else if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB() preset_mode is R but cp9b->Rvalid[0] is FALSE");
  else if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB() preset_mode is T but cp9b->Tvalid[0] is FALSE");
  if (jmin[0] > L        || jmax[0] < L)        ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, jmin[0], jmax[0]);
  jp_0 = L - jmin[0];
  if (hdmin[0][jp_0] > L || hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, hdmin[0][jp_0], hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* initialize cells in the special ROOT_S deck corresponding to full sequence alignments to 0.0 */
  if     (preset_mode == TRMODE_J) Jbeta[0][jp_0][Lp_0] = 0.; /* a full Joint    alignment is outside this cell */
  else if(preset_mode == TRMODE_L) Lbeta[0][jp_0][Lp_0] = 0.; /* a full Left     alignment is outside this cell */
  else if(preset_mode == TRMODE_R) Rbeta[0][jp_0][Lp_0] = 0.; /* a full Right    alignment is outside this cell */
  else if(preset_mode == TRMODE_T) Tbeta[0][jp_0][Lp_0] = 0.; /* a full Terminal alignment is outside this cell */
  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrCYKOutsideAlignHB() preset_mode %d is invalid", preset_mode);

  /* set cells corresponding to legal truncated begin entry states to
   * the appropriate penalty. In truncated alignment the only way out
   * of ROOT_S in local or global mode is via a 'truncated begin' with
   * a score (penalty) from cm->trp into any emitting state. The
   * penalty was calculated in cm_tr_penalties_Create() and differs
   * depending on whether we are in local or global mode and the value
   * of 'pty_idx' which was passed in.
   */
  for(v = 0; v < cm->M; v++) {
	if((L >= jmin[v]) && (L <= jmax[v])) {
	  jp_v = L - jmin[v];
	  if((L >= hdmin[v][jp_v]) && L <= hdmax[v][jp_v]) {
	Lp = L - hdmin[v][jp_v];

	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;
	  if(preset_mode == TRMODE_J && do_J_v) Jbeta[v][jp_v][Lp] = trpenalty; /* a full Joint alignment is outside this cell */
	  if(preset_mode == TRMODE_L && do_L_v) Lbeta[v][jp_v][Lp] = trpenalty; /* a full Left  alignment is outside this cell */
	  if(preset_mode == TRMODE_R && do_R_v) Rbeta[v][jp_v][Lp] = trpenalty; /* a full Right alignment is outside this cell */
	  if(preset_mode == TRMODE_T && do_T_v && cm->sttype[v] == B_st) {
	    Tbeta[v][jp_v][Lp] = trpenalty; /* a full Terminal alignment is outside this cell */
	  }
	}
	  }
	}
  }
  /* done allocation/initialization */

  /* Recursion: main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if(! StateIsDetached(cm, v)) {
	  sd  = StateDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	  /* if the v deck is invalid in J, L R and T mode, all states for v will remain impossible */
	  if(! (do_J_v || do_L_v || do_R_v || do_T_v)) continue;

	  if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	y = cm->plast[v];	/* the parent bifurcation    */
	z = cm->cnum[y];	/* the other (right) S state */

	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;

	for (j = jmax[v]; j >= jmin[v]; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];
	  i = j-d+1;
	  for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	    dp_v = d - hdmin[v][jp_v];
	    /* Find the first k value that implies a valid cell in the y and z decks.
	     * This k must satisfy the following 8 inequalities (some may be redundant):
	     * NOTE: these are different from those in Inside() (for one thing, v and y
	     *       (BEGL_S and BIF_B here respectively) are switched relative to Inside.
	     *
	     * (1) k <= jmax[y] - j;
	     * (2) k >= jmin[y] - j;
	     * (3) k <= jmax[z] - j;
	     * (4) k >= jmin[z] - j;
	     *     1 and 2 guarantee (j+k) is within state y's j band
	     *     3 and 4 guarantee (j+k) is within state z's j band
	     *
	     * (5) k >= hdmin[y][j-jmin[y]+k] - d;
	     * (6) k <= hdmax[y][j-jmin[y]+k] - d;
	     *     5 and 6 guarantee k+d is within y's j=(j+k), d band
	     *
	     * (7) k >= hdmin[z][j-jmin[z]+k];
	     * (8) k <= hdmax[z][j-jmin[z]+k];
	     *     5 and 6 guarantee k is within state z's j=(j+k) d band
	     */
	    kmin = ESL_MAX(jmin[y], jmin[z]) - j;
	    kmax = ESL_MIN(jmax[y], jmax[z]) - j;
	    /* kmin and kmax satisfy inequalities (1-4) */
	    /* RHS of inequalities 5-8 are dependent on k, so we check
	     * for these within the next for loop. */
	    for(k = kmin; k <= kmax; k++) {
	      if(k < (hdmin[y][jp_y+k] - d) || k > (hdmax[y][jp_y+k] - d)) continue;
	      /* above line continues if inequality 5 or 6 is violated */
	      if(k < (hdmin[z][jp_z+k])     || k > (hdmax[z][jp_z+k]))     continue;
	      /* above line continues if inequality 7 or 8 is violated */

	      /* if we get here for current k, all 8 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j+k][d+k], and
	       * alpha[z][j+k][k] are all within the bands. These
	       * cells correspond to beta[v][jp_v][dp_v],
	       * beta[y][jp_y+k][d-hdmin[y][jp_y+k]+k],
	       * and alpha[z][jp_z][k-hdmin[z][jp_z+k]];
	       */
	      kp_z = k-hdmin[z][jp_z+k];
	      dp_y = d-hdmin[y][jp_y+k];

	      if(do_J_v && do_J_y && do_J_z) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+k][dp_y+k] + Jalpha[z][jp_z+k][kp_z]); /* A */
	      if(do_J_v && do_L_y && do_L_z) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y+k][dp_y+k] + Lalpha[z][jp_z+k][kp_z]); /* B */
	      if(do_R_v && do_R_y && do_J_z) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+k][dp_y+k] + Jalpha[z][jp_z+k][kp_z]); /* C */
	      if(d == j && (j+k) == L &&
		 do_R_v && do_T_y && do_L_z) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Tbeta[y][jp_y+k][dp_y+k] + Lalpha[z][jp_z+k][kp_z]); /* D */
	      /* Note: Tbeta[y][j+k==L][d+k==L] will be 0.0 because it
	       * was initialized that way. That T cell includes the
	       * full target 1..L (any valid T alignment must because
	       * we must account for the full target) rooted at a B
	       * state, and a transition from that B state to this
	       * BEGL_S is always probability 1.0.
	       */
	    } /* end of for k loop */
	  } /* end of for d loop */
	} /* end of for j loop */
	/* Two more special cases in truncated alignment, we have to
	 * do these within their own for j and for d loops because j
	 * and d has different restrictions than it does in the
	 * above for j and for d loops we just closed.
	 */
	if(do_L_y && (do_J_v || do_L_v)) {
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  for (j = jx; j >= jn; j--) {
	    jp_v = j - jmin[v];
	    jp_y = j - jmin[y];
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	    for (d = dx; d >= dn; d--) {
	      dp_v = d-hdmin[v][jp_v];
	      dp_y = d-hdmin[y][jp_y];
	      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y]); /* entire sequence on left, no sequence on right, k == 0 */
	      if(do_L_v) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y]); /* entire sequence on left, no sequence on right, k == 0 */
	    }
	  }
	}
	  } /* end of 'if (cm->stid[v] == BEGL_S */
	  else if (cm->stid[v] == BEGR_S) {
	y = cm->plast[v];   /* the parent bifurcation    */
	z = cm->cfirst[y];  /* the other (left) S state  */

	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE;

	do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;

	jn = ESL_MAX(jmin[v], jmin[y]);
	jx = ESL_MIN(jmax[v], jmax[y]);
	for (j = jx; j >= jn; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];

	  dn = ESL_MAX(hdmin[v][jp_v], j-jmax[z]);
	  dx = ESL_MIN(hdmax[v][jp_v], jp_z);
	  /* above makes sure that j,d are valid for state z: (jmin[z] + d) >= j >= (jmax[z] + d) */
	  i = j-dx+1;
	  for (d = dx; d >= dn; d--, i++) {
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	    /* Find the first k value that implies a valid cell in the y and z decks.
	     * This k must satisfy the following 4 inequalities (some may be redundant):
	     * NOTE: these are different from those in Inside() (for one thing, v and y
	     *       (BEGR_S and BIF_B here respectively) are switched relative to Inside.
	     *
	     * (1) k >= hdmin[y][j-jmin[y]] - d;
	     * (2) k <= hdmax[y][j-jmin[y]] - d;
	     *     1 and 2 guarantee (d+k) is within state y's j=(j) d band
	     *
	     * (3) k >= hdmin[z][j-jmin[z]-d];
	     * (4) k <= hdmax[z][j-jmin[z]-d];
	     *     3 and 4 guarantee k is within z's j=(j-d) d band
	     *
	     */
	    kmin = ESL_MAX((hdmin[y][jp_y]-d), (hdmin[z][jp_z-d]));
	    kmax = ESL_MIN((hdmax[y][jp_y]-d), (hdmax[z][jp_z-d]));
	    /* kmin and kmax satisfy inequalities (1-4) */
	    for(k = kmin; k <= kmax; k++) {
	      /* for current k, all 4 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells beta[v][j][d], beta[y][j][d+k], and
	       * alpha[z][j-d][k] are all within the bands. These
	       * cells correspond to beta[v][jp_v][dp_v],
	       * beta[y][jp_y+k][d-hdmin[y][jp_y]+k],
	       * and alpha[z][jp_z-d][k-hdmin[z][jp_z-d]];
	       */
	      kp_z = k-hdmin[z][jp_z-d];
	      dp_y = d-hdmin[y][jp_y];

	      if(do_J_v && do_J_y && do_J_z) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y+k] + Jalpha[z][jp_z-d][kp_z]); /* A */
	      if(do_J_v && do_R_y && do_R_z) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y+k] + Ralpha[z][jp_z-d][kp_z]); /* C */
	      if(do_L_v && do_L_y && do_J_z) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+k] + Jalpha[z][jp_z-d][kp_z]); /* B */
	      if(k == (i-1) && j == L &&
		 do_L_v && do_T_y && do_R_z) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Tbeta[y][jp_y][dp_y+k] + Ralpha[z][jp_z-d][kp_z]); /* D */
	      /* Note: Tbeta[y][j==L][d+k==L] will be 0.0 because it
	       * was initialized that way. That T cell includes the
	       * full target 1..L (any valid T alignment must because
	       * we must account for the full target) rooted at a B
	       * state, and a transition from that B state to this
	       * BEGR_S is always probability 1.0.
	       */
	    } /* end of for k loop */
	  } /* end of for d loop */
	  /* Two more special cases in truncated alignment, we have to
	   * do these within their own for d loop because d has
	   * different restrictions than it does in the above for d
	   * loop we just closed. j's restrictions are the same
	   * though, so we stay inside the for j loop.
	   */
	  if(do_R_y && (do_J_v || do_R_v)) {
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	    for (d = dx; d >= dn; d--) {
	      dp_v = d-hdmin[v][jp_v];
	      dp_y = d-hdmin[y][jp_y];
	      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y]); /* entire sequence on right, no sequence on left, k == 0 */
	      if(do_R_v) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y]); /* entire sequence on right, no sequence on left, k == 0 */
	    }
	  }
	} /* end of for j loop */
	  } /* end of 'else if (cm->stid[v] == BEGR_S */
	  else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	/* in cm_CYKOutsideAlignHB(), IL and IR states are separated
	 * out from the other states at this stage because only they
	 * can self-transit, making it slightly more efficient to
	 * handle non-inserts differently. In truncated mode there's
	 * more special cases so I've decided to collapse all states
	 * together here. An analogous form of the following block is
	 * used only for IL/IR states in cm_CYKOutsideAlignHB().
	 *
	 * ILs and IRs can self transit, this means that
	 * {J,L,R}beta[v][j][d] must be fully calculated before
	 * {J,L,R}beta[v][j][d+1] can be started to be calculated,
	 * forcing the following nesting order: for j { for d { for y
	 * { } } } for non-self-transitioners, we could do a more
	 * efficient nesting order (you can see it in
	 * cm_CYKOutsideAlignHB() but we don't here because truncation
	 * makes it more complex).
	 */
	for (j = jmax[v]; j >= jmin[v]; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	    i = j-d+1;
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      /* mind the following sneaky if statement: in truncated
	       * aln, the only way out of state 0 is through a
	       * truncated begin, which we handled above (search for
	       * 'trpenalty'). If we're in local mode transitions out
	       * of 0 will have IMPOSSIBLE scores, but NOT if we're in
	       * glocal mode, so we need this 'if'.
	       */
	      if(y != 0) {
		voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
		sd  = StateDelta(cm->sttype[y]);
		sdl = StateLeftDelta(cm->sttype[y]);
		sdr = StateRightDelta(cm->sttype[y]);

		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

		/* if the y deck is invalid in J, L and R mode, we don't have to update v based on transitions from y */
		if (! (do_J_y || do_L_y || do_R_y)) continue;

		/* Note: this looks like it can be optimized, I tried but my 'optimization' slowed the code, so I reverted [EPN] */
		switch(cm->sttype[y]) {
		case MP_st:
		  jp_y = j - jmin[y];
		  if(j != L && d != j &&                                           /* boundary condition */
		     do_J_v && do_J_y &&                                           /* J deck is valid for v and y */
		     (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		     (d+sd  >= hdmin[y][jp_y+sdr] && d+sd  <= hdmax[y][jp_y+sdr])) /* d+sd  is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];  /* d index for state y */
		      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		      Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(j == L && d != j &&                                           /* boundary condition, only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		     do_L_y &&                                                     /* L deck is valid for y */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&              /* j is within y's j band */
		     (d+sdl >= hdmin[y][jp_y] && d+sdl <= hdmax[y][jp_y]))         /* d+sdl is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
		      escore = cm->lmesc[y][dsq[i-1]];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sdl] + cm->tsc[y][voffset] + escore);
		      if(do_L_v) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sdl] + cm->tsc[y][voffset] + escore);
		    }
		  if(i == 1 && j != L &&                                           /* boundary condition, only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		     do_R_y &&                                                     /* R deck is valid for y */
		     (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		     (d+sdr >= hdmin[y][jp_y+sdr] && d+sdr <= hdmax[y][jp_y+sdr])) /* d+sdr is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];  /* d index for state y */
		      escore = cm->rmesc[y][dsq[j+1]];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sdr] + cm->tsc[y][voffset] + escore);
		      if(do_R_v) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sdr] + cm->tsc[y][voffset] + escore);
		    }
		  break;

		case ML_st:
		case IL_st:
		  jp_y = j - jmin[y];
		  if(d != j &&                                              /* boundary case */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&       /* j is within y's j band */
		     (d+sdl >= hdmin[y][jp_y] && d+sdl <= hdmax[y][jp_y]))  /* d+sdl is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      escore = cm->oesc[y][dsq[i-1]];
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y+sd] + cm->tsc[y][voffset] + escore);
		      if(do_L_v && do_L_y) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(i == 1 &&                                              /* boundary condition, only allow transition from R if we're emitting first residue 1 from y  */
		     v != y &&                                              /* will only happen if v == IL, we don't allow silent self transitions from IL->IL */
		     do_R_y &&                                              /* R deck is valid for y */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&       /* j is within y's j band */
		     (d     >= hdmin[y][jp_y] && d     <= hdmax[y][jp_y]))  /* d+sdr(==d) is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_R_v) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;

		case MR_st:
		case IR_st:
		  jp_y = j - jmin[y];
		  if (j != L &&                                                    /* boundary condition */
		      (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		      (d+sd  >= hdmin[y][jp_y+sdr] && d+sd  <= hdmax[y][jp_y+sdr])) /* d+sd is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];
		      escore = cm->oesc[y][dsq[j+1]];
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		      if(do_R_v && do_R_y) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(j == L &&                                                     /* boundary condition, only allow transition from L if we're emitting final residue L from y */
		     v != y &&                                                     /* will only happen if v == IR, we don't allow silent self transitions from IR->IR */
		     do_L_y &&                                                     /* L deck is valid for y */
		     (j     >= jmin[y]           && j      <= jmax[y]) &&          /* j is within y's j band */
		     (d     >= hdmin[y][jp_y]    && d      <= hdmax[y][jp_y]))     /* d+sdl(==d) is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_L_v) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;
		case S_st:
		case E_st:
		case D_st:
		  jp_y = j - jmin[y];
		  if((j >= jmin[y]        && j <= jmax[y]) &&
		     (d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]))
		    {
		      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = ESL_MAX(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_L_v && do_L_y) Lbeta[v][jp_v][dp_v] = ESL_MAX(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_R_v && do_R_y) Rbeta[v][jp_v][dp_v] = ESL_MAX(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;
		} /* end of switch(cm->sttype[y] */
	      } /* end of sneaky if y != 0 */
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (do_J_v && Jbeta[v][jp_v][dp_v] < IMPOSSIBLE) Jbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	    if (do_L_v && Lbeta[v][jp_v][dp_v] < IMPOSSIBLE) Lbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	    if (do_R_v && Rbeta[v][jp_v][dp_v] < IMPOSSIBLE) Rbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	  } /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	} /* end loop over jp. We know beta for this whole state */
	  } /* end of 'else' (entered if cm->sttype[v] != BEGL_S nor BEGR_S */
	  /* we're done calculating deck v for everything but local ends */

	  /* deal with local alignment end transitions v->EL (EL = deck at M.) */
	  if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	sd       = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	sdl      = StateLeftDelta(cm->sttype[v]);  /* note sdl is for state v */
	sdr      = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	emitmode = Emitmode(cm->sttype[v]);        /* note emitmode is for state v */

	/* we handle all three possible modes (J,L,R) differently because they have different boundary conditions */

	/* J mode */
	if(do_J_v && cp9b->Jvalid[cm->M]) {
	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v + sdr] - sd;
	    dx   = hdmax[v][jp_v + sdr] - sd;
	    i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]];
		Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITRIGHT:
	      escore = esc_vAA[v][dsq[j+1]];
	      for (d = dn; d <= dx; d++, dp_v++) {
		Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
		Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	}

	/* L mode: again, this code is inefficient, but I chose not to try to optimize lest it get more complex */
	if(do_L_v && cp9b->Lvalid[cm->M]) {
	  jn = jmin[v];
	  jx = jmax[v];
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v] - sdl;
	    dx   = hdmax[v][jp_v] - sdl;
	    i    = j-dn+1;               /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      if(j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		for (d = dn; d <= dx; d++, dp_v++, i--) {
		  escore = cm->lmesc[v][dsq[i-1]];
		  Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v+sdl] + cm->endsc[v] + escore));
		}
	      }
	      break;

	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]];
		Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v+sdl] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITRIGHT:
	      if(j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		for (d = dn; d <= dx; d++, dp_v++) {
		  Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v] + cm->endsc[v]));
		}
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
		Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	} /* end of if(do_L_v) */

	/* R mode: again, this code is inefficient, but I chose not to try to optimize lest it get more complex */
	if(do_R_v && cp9b->Rvalid[cm->M]) {
	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v + sdr] - sdr;
	    dx   = hdmax[v][jp_v + sdr] - sdr;
	    i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		if(i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		  escore = cm->rmesc[v][dsq[j+1]];
		  Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v] + escore));
		}
	      }
	      break;
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		if(i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		  Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][jp_v][dp_v] + cm->endsc[v]));
		}
	      }
	      break;

	    case EMITRIGHT:
	      escore = esc_vAA[v][dsq[j+1]];
	      for (d = dn; d <= dx; d++, dp_v++) {
		Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
	      Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	} /* end of if(do_R_v) */
	  } /* end of calculating EL scores */
	} /* end of if !StateIsDetached() */
  } /* end loop over decks v. */

  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	if(cp9b->Jvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Jbeta[cm->M][j][d] = ESL_MAX(Jbeta[cm->M][j][d], (Jbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
	if(fill_L && cp9b->Lvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Lbeta[cm->M][j][d] = ESL_MAX(Lbeta[cm->M][j][d], (Lbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
	if(fill_R && cp9b->Rvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Rbeta[cm->M][j][d] = ESL_MAX(Rbeta[cm->M][j][d], (Rbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
  }

  fail1_flag = FALSE;
  fail2_flag = FALSE;
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. we assume the Inside CYK parse score
	 * (optsc) is the optimal score, so for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 * Lalpha[v][j][d] + Lbeta[v][j][d] <= optsc
	 * Ralpha[v][j][d] + Rbeta[v][j][d] <= optsc
	 *
	 * Further, we know that each residue must be emitted by a state
	 * in the optimal parse. So as we do the above check, we determine
	 * when we're in a cell that may be involved in the optimal parse
	 * (the sum of the Inside and Outside scores are equal to the
	 * optimal parse score), if that cell corresponds to a left
	 * emitter emitting position i, we know an emitted i has been
	 * observed in an optimal parse and set optseen[i] to TRUE.
	 * Likewise, if that cell corresponds to a right emitter emitting
	 * position j, we update optseen[j] to TRUE. At the end of the
	 * check optseen[i] should be TRUE for all i in the range
	 * [1..L].
	 *
	 * Note that we don't ensure that all of our presumed optimal
	 * cells make up a valid parse, so it is possible we could pass
	 * this check even if the Inside and Outside matrices are
	 * inconsistent (i.e. there's a bug in the implementation of one
	 * and/or the other) but that should be extremely unlikely.  If we
	 * do this test many times for many different models and pass, we
	 * should be confident we have consistent implementations.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 */
	ESL_ALLOC(optseen, sizeof(int) * (L+1));
	esl_vec_ISet(optseen, L+1, FALSE);
	vmax  = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	if     (preset_mode == TRMODE_J) optsc = Jalpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_L) optsc = Lalpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_R) optsc = Ralpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_T) optsc = Talpha[0][jp_0][Lp_0];
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;
	  jn = (v == cm->M) ? 1 : jmin[v];
	  jx = (v == cm->M) ? L : jmax[v];
	  for(j = jn; j <= jx; j++) {
	jp_v = (v == cm->M) ? j : j - jmin[v];
	dn   = (v == cm->M) ? 0 : hdmin[v][jp_v];
	dx   = (v == cm->M) ? j : hdmax[v][jp_v];
	for(d = dn; d <= dx; d++) {
	  dp_v = (v == cm->M) ? d : d - hdmin[v][jp_v];
	  Jsc  = (do_J_v) ? Jalpha[v][jp_v][dp_v] + Jbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Lsc  = (do_L_v) ? Lalpha[v][jp_v][dp_v] + Lbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Rsc  = (do_R_v) ? Ralpha[v][jp_v][dp_v] + Rbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Tsc  = (do_T_v) ? Talpha[v][jp_v][dp_v] + Tbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  if(Jsc > tol) {
	    printf("v: %d j: %d d: %d\n", v, j, d);
	    printf("Check 1 J failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Jalpha[v][jp_v][dp_v], Jbeta[v][jp_v][dp_v], Jalpha[v][jp_v][dp_v] + Jbeta[v][jp_v][dp_v], optsc);
	    fail1_flag = TRUE;
	  }
	  if(Lsc > tol) {
	    printf("Check 1 L failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Lalpha[v][jp_v][dp_v], Lbeta[v][jp_v][dp_v], Lalpha[v][jp_v][dp_v] + Lbeta[v][jp_v][dp_v], optsc);
	    fail1_flag = TRUE;
	  }
	  if(Rsc > tol) {
	    printf("Check 1 R failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Ralpha[v][jp_v][dp_v], Rbeta[v][jp_v][dp_v], Ralpha[v][jp_v][dp_v] + Rbeta[v][jp_v][dp_v], optsc);
	    fail1_flag = TRUE;
	  }
	  if(Tsc > tol) {
	    printf("Check 1 T failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Talpha[v][jp_v][dp_v], Tbeta[v][jp_v][dp_v], Talpha[v][jp_v][dp_v] + Tbeta[v][jp_v][dp_v], optsc);
	    fail1_flag = TRUE;
	  }
	  if((((do_J_v && fabs(Jsc) < tol) || (do_L_v && fabs(Lsc) < tol)) &&
	      (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st || (cm->sttype[v] == EL_st && d >0))) ||
	     ((do_R_v && fabs(Rsc) < tol) && cm->sttype[v] == EL_st && d >0)) {
	    i = j-d+1;
	    /* i is accounted for by a parse with an optimal score */
	    optseen[i] = TRUE;
	    /*
	      if     (fabs(Jsc) < tol) printf("\tResidue %4d possibly accounted for by J matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	      else if(fabs(Lsc) < tol) printf("\tResidue %4d possibly accounted for by L matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	      else if(fabs(Rsc) < tol) printf("\tResidue %4d possibly accounted for by R matrix Left  emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", i, Statetype(cm->sttype[v]), v, j, d);
	    */
	  }
	  if(((do_J_v && fabs(Jsc) < tol) || (do_R_v && fabs(Rsc) < tol)) &&
	     (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)) {
	    /* j is accounted for by a parse with an optimal score */
	    optseen[j] = TRUE;
	    /*
	       if     (fabs(Jsc) < tol) printf("\tResidue %4d possibly accounted for by J matrix Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);
	       else if(fabs(Rsc) < tol) printf("\tResidue %4d possibly accounted for by R matrix Right emitter %2s cell [v:%4d][j:%4d][d:%4d]\n", j, Statetype(cm->sttype[v]), v, j, d);
	    */
	  }
	}
	  }
	}
	for(j = 1; j <= L; j++) {
	  if(optseen[j] == FALSE) {
	printf("Check 2 failure: residue %d not emitted in the optimal parsetree\n", j);
	fail2_flag = TRUE;
	  }
	}
	free(optseen);
  }
  if(fail1_flag || fail2_flag) for(j = 1; j <= L; j++) printf("dsq[%4d]: %4d\n", j, dsq[j]);

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_ocykhbmx", "w");   cm_tr_hb_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
#endif

  if(do_check) {
	if     (fail1_flag) ESL_FAIL(eslFAIL, errbuf, "TrCYKHB Inside/Outside check1 FAILED.");
	else if(fail2_flag) ESL_FAIL(eslFAIL, errbuf, "TrCYKHB Inside/Outside check2 FAILED.");
	ESL_DPRINTF1(("SUCCESS! TrCYKHB Inside/Outside checks PASSED.\n"));
  }

  if     (preset_mode == TRMODE_J) optsc = Jalpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_L) optsc = Lalpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_R) optsc = Ralpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_T) optsc = Talpha[0][jp_0][Lp_0];
  ESL_DPRINTF1(("\tcm_TrCYKOutsideAlignHB() sc : %f (sc is from Inside!)\n", optsc));

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_TrOutsideAlign()
 * Date:     EPN, Mon Sep 19 14:48:30 2011
 *
 * Purpose: Run the truncated outside algorithm. Non-banded version.
 *           A CM_TR_MX DP matrix must be passed in.  Very similar to
 *           cm_TrCYKOutsideAlign() but calculates summed log probs of
 *           all likely parses instead of the most likely parse.
 *           i.e. uses log sum operations instead of max's.  Meaning of
 *           cells:
 *
 *           Jbeta[v][j][d]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Joint marginal mode at j,d.
 *           Lbeta[v][j][d]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Left marginal mode at j,d.
 *           Rbeta[v][j][d]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Right marginal mode at j,d.
 *
 * Args:     cm          - the model    [0..M-1]
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - length of the dsq to align
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T, the pre-determined
 *                         alignment mode, we'll only allow alignments in this mode.
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           do_check    - TRUE to attempt to check matrices for correctness
 *           mx          - the dp matrix, only cells within bands in cp9b will be valid
 *           ins_mx      - the dp matrix from the CYK Inside run calculation
 *                         (performed by cm_TrCYKInsideAlign(), required)
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted.
 */
int
cm_TrOutsideAlign(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		  int do_check, CM_TR_MX *mx, CM_TR_MX *ins_mx)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float    Jsc,Lsc,Rsc,Tsc;    /* temporary variables holding a float score */
  float    optsc;              /* the Inside score */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */

  /* variables used only if do_check */
  int      fail_flag = FALSE; /* set to TRUE if do_check and we see a problem */
  int      vmax;              /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */

  /* indices used in the depths of the DP recursion */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[y] */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* other variables used in truncated version, but not standard version (not in cm_OutsideAlign()) */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* DP matrix variables */
  float ***Jbeta   = mx->Jdp;     /* pointer to the outside Jbeta DP matrix */
  float ***Lbeta   = mx->Ldp;     /* pointer to the outside Lbeta DP matrix */
  float ***Rbeta   = mx->Rdp;     /* pointer to the outside Rbeta DP matrix */
  float ***Tbeta   = mx->Tdp;     /* pointer to the outside Tbeta DP matrix */

  float ***Jalpha  = ins_mx->Jdp; /* pointer to the precalc'ed inside Jalpha DP matrix */
  float ***Lalpha  = ins_mx->Ldp; /* pointer to the precalc'ed inside Lalpha DP matrix */
  float ***Ralpha  = ins_mx->Rdp; /* pointer to the precalc'ed inside Ralpha DP matrix */
  float ***Talpha  = ins_mx->Tdp; /* pointer to the precalc'ed inside Talpha DP matrix, only used to possibly get optsc */

  /* Allocations and initializations */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlign(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrOutsideAlign(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrOutsideAlign(), unexpected pass idx: %d", pass_idx);

  /* grow the matrices based on the current sequence and bands */
  if((status = cm_tr_mx_GrowTo(cm, mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* initialize cells in the special ROOT_S deck corresponding to full sequence alignments to 0.0 */
  if     (preset_mode == TRMODE_J) Jbeta[0][L][L] = 0.; /* a full Joint    alignment is outside this cell */
  else if(preset_mode == TRMODE_L) Lbeta[0][L][L] = 0.; /* a full Left     alignment is outside this cell */
  else if(preset_mode == TRMODE_R) Rbeta[0][L][L] = 0.; /* a full Right    alignment is outside this cell */
  else if(preset_mode == TRMODE_T) Tbeta[0][L][L] = 0.; /* a full Terminal alignment is outside this cell */
  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlign() preset_mode %d is invalid", preset_mode);

  /* set cells corresponding to legal truncated begin entry states to
   * the appropriate penalty. In truncated alignment the only way out
   * of ROOT_S in local or global mode is via a 'truncated begin' with
   * a score (penalty) from cm->trp into any emitting state. The
   * penalty was calculated in cm_tr_penalties_Create() and differs
   * depending on whether we are in local or global mode and the value
   * of 'pty_idx' which was passed in.
   */
  for(v = 0; v < cm->M; v++) {
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  if(preset_mode == TRMODE_J) Jbeta[v][L][L] = trpenalty; /* a full Joint alignment is outside this cell */
	  if(preset_mode == TRMODE_L) Lbeta[v][L][L] = trpenalty; /* a full Left  alignment is outside this cell */
	  if(preset_mode == TRMODE_R) Rbeta[v][L][L] = trpenalty; /* a full Right alignment is outside this cell */
	  if(preset_mode == TRMODE_T && cm->sttype[v] == B_st) {
	Tbeta[v][L][L] = trpenalty; /* a full Terminal alignment is outside this cell */
	  }
	}
  }

  /* main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if(! StateIsDetached(cm, v)) { /* skip detached inserts, they're cells will remain IMPOSSIBLE */
	  sd  = StateDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);

	  if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	y = cm->plast[v];	/* the parent bifurcation    */
	z = cm->cnum[y];	/* the other (right) S state */
	for(j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    for (k = 0; k <= (L-j); k++) {
	      Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Jbeta[y][j+k][d+k] + Jalpha[z][j+k][k]); /* A */
	      if(fill_L) {
		Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Lbeta[y][j+k][d+k] + Lalpha[z][j+k][k]); /* B */
	      }
	      if(fill_R) {
		Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j+k][d+k] + Jalpha[z][j+k][k]); /* C */
		if(fill_T && fill_L && d == j && (j+k) == L) {
		  Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Tbeta[y][j+k][d+k] + Lalpha[z][j+k][k]); /* D */
		  /* Note: Tbeta[y][j+k==L][d+k==L] will be 0.0 or
		   * IMPOSSIBLE because it was initialized that
		   * way. That T cell includes the full target 1..L
		   * (any valid T alignment must because we must
		   * account for the full target) rooted at a B state,
		   * and a transition from that B state to this BEGL_S
		   * is always probability 1.0.
		   */
		}
	      }
	    }
	    if(fill_L) {
	      Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Lbeta[y][j][d]); /* entire sequence on left, no sequence on right, k == 0 */
	      Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d]); /* entire sequence on left, no sequence on right, k == 0 */
	    }
	  }
	}
	  } /* end of 'if (cm->stid[v] == BEGL_S */
	  else if (cm->stid[v] == BEGR_S) {
	y = cm->plast[v];   /* the parent bifurcation    */
	z = cm->cfirst[y];  /* the other (left) S state  */
	for(j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    i = j-d+1;
	    for (k = 0; k <= (j-d); k++) {
	      Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Jbeta[y][j][d+k] + Jalpha[z][j-d][k]); /* A */
	      if(fill_R) {
		Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Rbeta[y][j][d+k] + Ralpha[z][j-d][k]); /* C */
	      }
	      if(fill_L) {
		Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d+k] + Jalpha[z][j-d][k]); /* B */
		if(fill_R && fill_T && k == (i-1) && j == L) {
		  Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Tbeta[y][j][d+k] + Ralpha[z][j-d][k]); /* D */
		  /* Note: Tbeta[y][j==L][d+k==L] will be 0.0 or
		   * IMPOSSIBLE because it was initialized that
		   * way. That T cell includes the full target 1..L
		   * (any valid T alignment must because we must
		   * account for the full target) rooted at a B state,
		   * and a transition from that B state to this BEGR_S
		   * is always probability 1.0.
		   */
		}
	      }
	    }
	    if(fill_R) {
	      Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Rbeta[y][j][d]); /* entire sequence on right, no sequence on left, k == 0 */
	      Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j][d]); /* entire sequence on right, no sequence on left, k == 0 */
	    }
	  }
	}
	  } /* end of 'else if (cm->stid[v] == BEGR_S */
	  else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	for (j = L; j >= 0; j--) {
	  i = 1;
	  for (d = j; d >= 0; d--, i++) {
	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      /* mind the following sneaky if statement: in truncated
	       * aln, the only way out of state 0 is through a
	       * truncated begin, which we handled above (search for
	       * 'trpenalty'). If we're in local mode transitions out
	       * of 0 will have IMPOSSIBLE scores, but NOT if we're in
	       * glocal mode, so we need this 'if'.
	       */
	      if(y != 0) {
		voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
		sd  = StateDelta(cm->sttype[y]);
		sdl = StateLeftDelta(cm->sttype[y]);
		sdr = StateRightDelta(cm->sttype[y]);
		switch(cm->sttype[y]) {
		case MP_st:
		  if(j != L && d != j) {
		    escore = cm->oesc[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		    Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Jbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_L && j == L && d != j)  { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		    escore = cm->lmesc[y][dsq[i-1]];
		    Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Lbeta[y][j][d+sdl]     + cm->tsc[y][voffset] + escore);
		    Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d+sdl]     + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_R && i == 1 && j != L) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		    escore = cm->rmesc[y][dsq[j+1]];
		    Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Rbeta[y][j+sdr][d+sdr] + cm->tsc[y][voffset] + escore);
		    Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j+sdr][d+sdr] + cm->tsc[y][voffset] + escore);
		  }
		  break;
		case ML_st:
		case IL_st:
		  if (d != j) {
		    escore = cm->oesc[y][dsq[i-1]];
		    Jbeta[v][j][d]            = FLogsum(Jbeta[v][j][d], Jbeta[y][j][d+sd]     + cm->tsc[y][voffset] + escore);
		    if(fill_L) Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d+sd]     + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_R && i == 1 && /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		     v != y ) {          /* will only happen if v == IL, we don't allow silent self transitions from IL->IL */
		    Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Rbeta[y][j][d]        + cm->tsc[y][voffset]);
		    Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j][d]        + cm->tsc[y][voffset]);
		  }
		  break;
		case MR_st:
		case IR_st:
		  if (j != L) {
		    escore = cm->oesc[y][dsq[j+1]];
		    Jbeta[v][j][d]            = FLogsum(Jbeta[v][j][d], Jbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		    if(fill_R) Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j+sdr][d+sd] + cm->tsc[y][voffset] + escore);
		  }
		  if(fill_L && j == L && /* only allow transition from R if we haven't emitted any residues rightwise (j==L) */
		     v != y) {           /* will only happen if v == IR, we don't allow silent self transitions from IR->IR */
		    Jbeta[v][j][d] = FLogsum(Jbeta[v][j][d], Lbeta[y][j][d]        + cm->tsc[y][voffset]);
		    Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d]        + cm->tsc[y][voffset]);
		  }
		  break;
		case S_st:
		case E_st:
		case D_st:
		  Jbeta[v][j][d]            = FLogsum(Jbeta[v][j][d], Jbeta[y][j][d] + cm->tsc[y][voffset]);
		  if(fill_L) Lbeta[v][j][d] = FLogsum(Lbeta[v][j][d], Lbeta[y][j][d] + cm->tsc[y][voffset]);
		  if(fill_R) Rbeta[v][j][d] = FLogsum(Rbeta[v][j][d], Rbeta[y][j][d] + cm->tsc[y][voffset]);
		  break;
		} /* end of switch(cm->sttype[y] */
	      } /* end of sneaky if y != 0 */
	    }  /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (Jbeta[v][j][d] < IMPOSSIBLE) Jbeta[v][j][d] = IMPOSSIBLE;
	  } /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	} /* end loop over j. We know beta for this whole state */
	  } /* end of 'else' (if cm->sttype[v] != BEGL_S, BEGR_S) */
	} /* end of 'if(! StateIsDetached(cm, v))' */
	/* we're done calculating deck v for everything but local ends */

	/* deal with local end transitions v->EL J matrix only (EL = deck at M.) */
	if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  sd  = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	  sdl = StateLeftDelta(cm->sttype[v]);  /* note sdl is for state v */
	  sdr = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */

	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  i = j-d+1;
	  switch (cm->sttype[v]) {
	  case MP_st:
	    if (j != L && d != j) {
	      escore = cm->oesc[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
	      Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd] + cm->endsc[v] + escore));
	    }
	    if(fill_L && j == L && d != j) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
	      escore = cm->lmesc[v][dsq[i-1]];
	      Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][j][d+sdl] + cm->endsc[v] + escore));
	    }
	    if(fill_R && i == 1 && j != L) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
	      escore = cm->rmesc[v][dsq[j+1]];
	      Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sdr] + cm->endsc[v] + escore));
	    }
	    break;
	  case ML_st:
	  case IL_st:
	    if (d != j) {
	      escore = cm->oesc[v][dsq[i-1]];
	      Jbeta[cm->M][j][d]            = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][j][d+sd]  + cm->endsc[v] + escore));
	      if(fill_L) Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][j][d+sdl] + cm->endsc[v] + escore));
	    }
	    if(fill_R && i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i == 1) */
	      Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], Rbeta[v][j][d] + cm->endsc[v]);
	    }
	    break;
	  case MR_st:
	  case IR_st:
	    if(j != L) {
	      escore = cm->oesc[v][dsq[j+1]];
	      Jbeta[cm->M][j][d]            = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd]  + cm->endsc[v] + escore));
	      if(fill_R) Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sdr] + cm->endsc[v] + escore));
	    }
	    if(fill_L && j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j == L) */
	      Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], Lbeta[v][j][d] + cm->endsc[v]);
	    }
	    break;
	  case S_st:
	  case D_st:
	  case E_st:
	    Jbeta[cm->M][j][d]            = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    if(fill_L) Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    if(fill_R) Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][j+sdr][d+sd] + cm->endsc[v]));
	    break;
	  }
	}
	  }
	}
  }
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = L; j > 0; j--) { /* careful w/ boundary here */
	  for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	Jbeta[cm->M][j][d]            = FLogsum(Jbeta[cm->M][j][d], Jbeta[cm->M][j][d+1] + cm->el_selfsc);
	if(fill_L) Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], Lbeta[cm->M][j][d+1] + cm->el_selfsc);
	if(fill_R) Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], Rbeta[cm->M][j][d+1] + cm->el_selfsc);
	  }
	}
  }

  fail_flag = FALSE;
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. If the Inside score (optsc) really is
	 * the log sum of all possible parsetrees that emit the full
	 * target sequence 1..L, then for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 * Lalpha[v][j][d] + Lbeta[v][j][d] <= optsc
	 * Ralpha[v][j][d] + Rbeta[v][j][d] <= optsc
	 * Talpha[v][j][d] + Tbeta[v][j][d] <= optsc
	 *
	 * We do a more extensive check in cm_TrCYKOutsideAlign(), but
	 * it doesn't apply here, because we've summed all parsetrees
	 * instead of finding only the optimal one.
	 *
	 * Note that we don't check fill_L and fill_R variables
	 * here, although they will have dictated whether we've filled
	 * in the L and R matrices. If they're FALSE, those matrices
	 * should remain as they've been initialized as all IMPOSSIBLE
	 * values, so they won't cause us to fail our tests here.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 */
	vmax = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	if     (preset_mode == TRMODE_J) optsc = Jalpha[0][L][L];
	else if(preset_mode == TRMODE_L) optsc = Lalpha[0][L][L];
	else if(preset_mode == TRMODE_R) optsc = Ralpha[0][L][L];
	else if(preset_mode == TRMODE_T) optsc = Talpha[0][L][L];
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  for(j = 1; j <= L; j++) {
	for(d = 0; d <= j; d++) {
	  Jsc  = Jalpha[v][j][d] + Jbeta[v][j][d] - optsc;
	  Lsc  = (fill_L) ? Lalpha[v][j][d] + Lbeta[v][j][d] - optsc : IMPOSSIBLE;
	  Rsc  = (fill_R) ? Ralpha[v][j][d] + Rbeta[v][j][d] - optsc : IMPOSSIBLE;
	  Tsc  = (fill_T && cm->sttype[v] == B_st) ? Talpha[v][j][d] + Tbeta[v][j][d] - optsc : IMPOSSIBLE;
	  if(Jsc > tol) {
	    printf("Check J failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Jalpha[v][j][d], Jbeta[v][j][d], Jalpha[v][j][d] + Jbeta[v][j][d], optsc);
	    fail_flag = TRUE;
	  }
	  if(Lsc > tol) {
	    printf("Check L failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Lalpha[v][j][d], Lbeta[v][j][d], Lalpha[v][j][d] + Lbeta[v][j][d], optsc);
	    fail_flag = TRUE;
	  }
	  if(Rsc > tol) {
	    printf("Check R failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Ralpha[v][j][d], Rbeta[v][j][d], Ralpha[v][j][d] + Rbeta[v][j][d], optsc);
	    fail_flag = TRUE;
	  }
	  if(cm->sttype[v] == B_st && Tsc > tol) {
	    printf("Check 1 T failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, ins_mx->Tdp[v][j][d], Tbeta[v][j][d], ins_mx->Tdp[v][j][d] + Tbeta[v][j][d], optsc);
	    fail_flag = TRUE;
	  }
	}
	  }
	}
	if(fail_flag) for(j = 1; j <= L; j++) printf("dsq[%4d]: %4d\n", j, dsq[j]);
  }

#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_omx", "w");   cm_tr_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
#endif

  if(do_check) {
	if  (fail_flag) ESL_FAIL(eslFAIL, errbuf, "Tr Inside/Outside check FAILED.");
	ESL_DPRINTF1(("SUCCESS! Tr Inside/Outside check PASSED.\n"));
	/*printf("SUCCESS! Tr Inside/Outside check PASSED.\n");*/
  }

  if     (preset_mode == TRMODE_J) optsc = Jalpha[0][L][L];
  else if(preset_mode == TRMODE_L) optsc = Lalpha[0][L][L];
  else if(preset_mode == TRMODE_R) optsc = Ralpha[0][L][L];
  else if(preset_mode == TRMODE_T) optsc = Talpha[0][L][L];
  ESL_DPRINTF1(("\tcm_TrOutsideAlign() sc : %f (sc is from Inside!)\n", optsc));

  return eslOK;
}

/* Function: cm_TrOutsideAlignHB()
 * Date:     EPN, Tue Oct 11 09:13:17 2011
 *
 * Purpose: Run the truncated outside algorithm. HMM banded version.
 *           See cm_TrOutsideAlign() for the non-banded version. The
 *           full target sequence 1..L is aligned.
 *
 *           A CM_TR_HB_MX DP matrix must be passed in.  Very similar to
 *           cm_TrCYKOutsideAlignHB() but calculates summed log probs of
 *           all likely parses instead of the most likely parse.
 *           i.e. uses log sum operations instead of max's.  Meaning of
 *           cells:
 *
 *           Jbeta[v][jp_v][dp_v]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Joint marginal mode at j,d.
 *           Lbeta[v][jp_v][dp_v]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Left marginal mode at j,d.
 *           Rbeta[v][jp_v][dp_v]: summed log prob of all parsetrees that
 *                           emit 1..i-1 and j+1..L and pass through
 *                           v in Right marginal mode at j,d.
 *
 *           Where jp_v = j-jmin[v] and dp_v = d-hdmin[v][jp_v];
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - the digitized sequence
 *           L           - length of the dsq to align
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T, the pre-determined
 *                         alignment mode, we'll only allow alignments in this mode.
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           do_check    - TRUE to attempt to check
 *           mx          - the dp matrix, only cells within bands in cp9b will be valid
 *           ins_mx      - the dp matrix from the Inside run calculation (required)
 *
 * Returns:  <eslOK> on success
 *
 * Throws:   <eslERANGE> if required CM_TR_HB_MX size exceeds <size_limit>
 *           <eslFAIL>   if <do_check>==TRUE and we fail a test
 *           In either of these cases, alignment has been aborted.
 */
int
cm_TrOutsideAlignHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, float size_limit, char preset_mode, int pass_idx,
		    int do_check, CM_TR_HB_MX *mx, CM_TR_HB_MX *ins_mx)
{
  int      status;
  int      v,y,z;	       /* indices for states */
  float    Jsc,Lsc,Rsc,Tsc;    /* temporary variables holding a float score */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float  **esc_vAA;            /* ptr to cm->oesc, optimized emission scores */
  float    optsc;              /* optimal score in <preset_mode>, from Inside */
  float    escore;	       /* an emission score, tmp variable */
  int      voffset;	       /* index of v in t_v(y) transition scores */
  int      emitmode;           /* EMITLEFT, EMITRIGHT, EMITPAIR, EMITNONE, for state y */
  int      sd;                 /* StateDelta(cm->sttype[y]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[y] */
  int      sdr;                /* StateRightDelta(cm->sttype[y] */

  /* variables used only if do_check */
  int      fail_flag = FALSE; /* set to TRUE if do_check and we see a problem */
  int      vmax;              /* i, offset in the matrix */
  float    tol;                /* tolerance for differences in bit scores */

  /* band related variables */
  int      dp_v;               /* d index for state v in alpha w/mem eff bands */
  int      dp_y;               /* d index for state y in alpha w/mem eff bands */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      Lp;                 /* L index also changes depending on state */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      kmin, kmax;         /* temporary minimum/maximum allowed k */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      jp_0;               /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;               /* L offset in ROOT_S's (v==0) d band */

  /* variables related to truncated alignment (not in cm_CYKInsideAlignHB() */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z; /* must we fill J matrix deck for state v, y, z? */
  int      do_L_v, do_L_y, do_L_z; /* must we fill L matrix deck for state v, y, z? */
  int      do_R_v, do_R_y, do_R_z; /* must we fill R matrix deck for state v, y, z? */
  int      do_T_v, do_T_y;         /* is T matrix valid for state v, y?    */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* DP matrix variables */
  float ***Jbeta   = mx->Jdp;     /* pointer to the outside Jbeta DP matrix */
  float ***Lbeta   = mx->Ldp;     /* pointer to the outside Lbeta DP matrix */
  float ***Rbeta   = mx->Rdp;     /* pointer to the outside Rbeta DP matrix */
  float ***Tbeta   = mx->Tdp;     /* pointer to the outside Tbeta DP matrix */

  float ***Jalpha  = ins_mx->Jdp; /* pointer to the precalc'ed inside Jalpha DP matrix */
  float ***Lalpha  = ins_mx->Ldp; /* pointer to the precalc'ed inside Lalpha DP matrix */
  float ***Ralpha  = ins_mx->Rdp; /* pointer to the precalc'ed inside Ralpha DP matrix */
  float ***Talpha  = ins_mx->Tdp; /* pointer to the precalc'ed inside Talpha DP matrix, only used to possibly get optsc */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin    = cm->cp9b->jmin;
  int     *jmax    = cm->cp9b->jmax;
  int    **hdmin   = cm->cp9b->hdmin;
  int    **hdmax   = cm->cp9b->hdmax;

  /* Allocations and initializations */
  esc_vAA = cm->oesc;            /* a ptr to the optimized emission scores */

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrOutsideAlignHB(), bogus mode: %d", preset_mode);

  /* Determine the truncation penalty index, from the pass_idx */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrOutsideAlignHB(), unexpected pass idx: %d", pass_idx);

  /* grow the matrix based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo(cm, mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* ensure a full alignment in <preset_mode> to ROOT_S (v==0) is allowed by the bands */
  if      (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB() preset_mode is J but cp9b->Jvalid[0] is FALSE");
  else if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB() preset_mode is L but cp9b->Lvalid[0] is FALSE");
  else if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB() preset_mode is R but cp9b->Rvalid[0] is FALSE");
  else if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB() preset_mode is T but cp9b->Tvalid[0] is FALSE");

  if (jmin[0] > L        || jmax[0] < L)        ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, jmin[0], jmax[0]);
  jp_0 = L - jmin[0];
  if (hdmin[0][jp_0] > L || hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, hdmin[0][jp_0], hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* initialize cells in the special ROOT_S deck corresponding to full sequence alignments to 0.0 */
  if     (preset_mode == TRMODE_J) Jbeta[0][jp_0][Lp_0] = 0.; /* a full Joint    alignment is outside this cell */
  else if(preset_mode == TRMODE_L) Lbeta[0][jp_0][Lp_0] = 0.; /* a full Left     alignment is outside this cell */
  else if(preset_mode == TRMODE_R) Rbeta[0][jp_0][Lp_0] = 0.; /* a full Right    alignment is outside this cell */
  else if(preset_mode == TRMODE_T) Tbeta[0][jp_0][Lp_0] = 0.; /* a full Terminal alignment is outside this cell */
  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrOutsideAlignHB() preset_mode %d is invalid", preset_mode);

  /* set cells corresponding to legal truncated begin entry states to
   * the appropriate penalty. In truncated alignment the only way out
   * of ROOT_S in local or global mode is via a 'truncated begin' with
   * a score (penalty) from cm->trp into any emitting state. The
   * penalty was calculated in cm_tr_penalties_Create() and differs
   * depending on whether we are in local or global mode and the value
   * of 'pty_idx' which was passed in.
   */
  for(v = 0; v < cm->M; v++) {
	if((L >= jmin[v]) && (L <= jmax[v])) {
	  jp_v = L - jmin[v];
	  if((L >= hdmin[v][jp_v]) && L <= hdmax[v][jp_v]) {
	Lp = L - hdmin[v][jp_v];

	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][v] : cm->trp->g_ptyAA[pty_idx][v];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;
	  if(preset_mode == TRMODE_J && do_J_v) Jbeta[v][jp_v][Lp] = trpenalty; /* a full Joint alignment is outside this cell */
	  if(preset_mode == TRMODE_L && do_L_v) Lbeta[v][jp_v][Lp] = trpenalty; /* a full Left  alignment is outside this cell */
	  if(preset_mode == TRMODE_R && do_R_v) Rbeta[v][jp_v][Lp] = trpenalty; /* a full Right alignment is outside this cell */
	  if(preset_mode == TRMODE_T && do_T_v && cm->sttype[v] == B_st) {
	    Tbeta[v][jp_v][Lp] = trpenalty; /* a full Terminal alignment is outside this cell */
	  }
	}
	  }
	}
  }
  /* done allocation/initialization */

  /* Recursion: main loop down through the decks */
  for (v = 1; v < cm->M; v++) { /* start at state 1 because we set all values for ROOT_S state 0 above */
	if(! StateIsDetached(cm, v)) {
	  sd  = StateDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	  /* if the v deck is invalid in J, L R and T mode, all states for v will remain impossible */
	  if(! (do_J_v || do_L_v || do_R_v || do_T_v)) continue;

	  if (cm->stid[v] == BEGL_S) { /* BEGL_S */
	y = cm->plast[v];	/* the parent bifurcation    */
	z = cm->cnum[y];	/* the other (right) S state */

	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;

	for (j = jmax[v]; j >= jmin[v]; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];
	  i = j-d+1;
	  for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	    dp_v = d - hdmin[v][jp_v];
	    /* Find the first k value that implies a valid cell in the y and z decks.
	     * This k must satisfy the following 8 inequalities (some may be redundant):
	     * NOTE: these are different from those in Inside() (for one thing, v and y
	     *       (BEGL_S and BIF_B here respectively) are switched relative to Inside.
	     *
	     * (1) k <= jmax[y] - j;
	     * (2) k >= jmin[y] - j;
	     * (3) k <= jmax[z] - j;
	     * (4) k >= jmin[z] - j;
	     *     1 and 2 guarantee (j+k) is within state y's j band
	     *     3 and 4 guarantee (j+k) is within state z's j band
	     *
	     * (5) k >= hdmin[y][j-jmin[y]+k] - d;
	     * (6) k <= hdmax[y][j-jmin[y]+k] - d;
	     *     5 and 6 guarantee k+d is within y's j=(j+k), d band
	     *
	     * (7) k >= hdmin[z][j-jmin[z]+k];
	     * (8) k <= hdmax[z][j-jmin[z]+k];
	     *     5 and 6 guarantee k is within state z's j=(j+k) d band
	     */
	    kmin = ESL_MAX(jmin[y], jmin[z]) - j;
	    kmax = ESL_MIN(jmax[y], jmax[z]) - j;
	    /* kmin and kmax satisfy inequalities (1-4) */
	    /* RHS of inequalities 5-8 are dependent on k, so we check
	     * for these within the next for loop. */
	    for(k = kmin; k <= kmax; k++) {
	      if(k < (hdmin[y][jp_y+k] - d) || k > (hdmax[y][jp_y+k] - d)) continue;
	      /* above line continues if inequality 5 or 6 is violated */
	      if(k < (hdmin[z][jp_z+k])     || k > (hdmax[z][jp_z+k]))     continue;
	      /* above line continues if inequality 7 or 8 is violated */

	      /* if we get here for current k, all 8 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j+k][d+k], and
	       * alpha[z][j+k][k] are all within the bands. These
	       * cells correspond to beta[v][jp_v][dp_v],
	       * beta[y][jp_y+k][d-hdmin[y][jp_y+k]+k],
	       * and alpha[z][jp_z][k-hdmin[z][jp_z+k]];
	       */
	      kp_z = k-hdmin[z][jp_z+k];
	      dp_y = d-hdmin[y][jp_y+k];

	      if(do_J_v && do_J_y && do_J_z) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+k][dp_y+k] + Jalpha[z][jp_z+k][kp_z]); /* A */
	      if(do_J_v && do_L_y && do_L_z) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y+k][dp_y+k] + Lalpha[z][jp_z+k][kp_z]); /* B */
	      if(do_R_v && do_R_y && do_J_z) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+k][dp_y+k] + Jalpha[z][jp_z+k][kp_z]); /* C */
	      if(d == j && (j+k) == L &&
		 do_R_v && do_T_y && do_L_z) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Tbeta[y][jp_y+k][dp_y+k] + Lalpha[z][jp_z+k][kp_z]); /* D */
	      /* Note: Tbeta[y][j+k==L][d+k==L] will be 0.0 because it
	       * was initialized that way. That T cell includes the
	       * full target 1..L (any valid T alignment must because
	       * we must account for the full target) rooted at a B
	       * state, and a transition from that B state to this
	       * BEGL_S is always probability 1.0.
	       */
	    } /* end of for k loop */
	  } /* end of for d loop */
	} /* end of for j loop */
	/* Two more special cases in truncated alignment, we have to
	 * do these within their own for j and for d loops because j
	 * and d has different restrictions than it does in the
	 * above for j and for d loops we just closed.
	 */
	if(do_L_y && (do_J_v || do_L_v)) {
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  for (j = jx; j >= jn; j--) {
	    jp_v = j - jmin[v];
	    jp_y = j - jmin[y];
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	    for (d = dx; d >= dn; d--) {
	      dp_v = d-hdmin[v][jp_v];
	      dp_y = d-hdmin[y][jp_y];
	      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y]); /* entire sequence on left, no sequence on right, k == 0 */
	      if(do_L_v) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y]); /* entire sequence on left, no sequence on right, k == 0 */
	    }
	  }
	}
	  } /* end of 'if (cm->stid[v] == BEGL_S */
	  else if (cm->stid[v] == BEGR_S) {
	y = cm->plast[v];   /* the parent bifurcation    */
	z = cm->cfirst[y];  /* the other (left) S state  */

	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE;

	do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;

	jn = ESL_MAX(jmin[v], jmin[y]);
	jx = ESL_MIN(jmax[v], jmax[y]);
	for (j = jx; j >= jn; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];

	  dn = ESL_MAX(hdmin[v][jp_v], j-jmax[z]);
	  dx = ESL_MIN(hdmax[v][jp_v], jp_z);
	  /* above makes sure that j,d are valid for state z: (jmin[z] + d) >= j >= (jmax[z] + d) */
	  i = j-dx+1;
	  for (d = dx; d >= dn; d--, i++) {
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	    /* Find the first k value that implies a valid cell in the y and z decks.
	     * This k must satisfy the following 4 inequalities (some may be redundant):
	     * NOTE: these are different from those in Inside() (for one thing, v and y
	     *       (BEGR_S and BIF_B here respectively) are switched relative to Inside.
	     *
	     * (1) k >= hdmin[y][j-jmin[y]] - d;
	     * (2) k <= hdmax[y][j-jmin[y]] - d;
	     *     1 and 2 guarantee (d+k) is within state y's j=(j) d band
	     *
	     * (3) k >= hdmin[z][j-jmin[z]-d];
	     * (4) k <= hdmax[z][j-jmin[z]-d];
	     *     3 and 4 guarantee k is within z's j=(j-d) d band
	     *
	     */
	    kmin = ESL_MAX((hdmin[y][jp_y]-d), (hdmin[z][jp_z-d]));
	    kmax = ESL_MIN((hdmax[y][jp_y]-d), (hdmax[z][jp_z-d]));
	    /* kmin and kmax satisfy inequalities (1-4) */
	    for(k = kmin; k <= kmax; k++) {
	      /* for current k, all 4 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells beta[v][j][d], beta[y][j][d+k], and
	       * alpha[z][j-d][k] are all within the bands. These
	       * cells correspond to beta[v][jp_v][dp_v],
	       * beta[y][jp_y+k][d-hdmin[y][jp_y]+k],
	       * and alpha[z][jp_z-d][k-hdmin[z][jp_z-d]];
	       */
	      kp_z = k-hdmin[z][jp_z-d];
	      dp_y = d-hdmin[y][jp_y];

	      if(do_J_v && do_J_y && do_J_z) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y+k] + Jalpha[z][jp_z-d][kp_z]); /* A */
	      if(do_J_v && do_R_y && do_R_z) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y+k] + Ralpha[z][jp_z-d][kp_z]); /* C */
	      if(do_L_v && do_L_y && do_J_z) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+k] + Jalpha[z][jp_z-d][kp_z]); /* B */
	      if(k == (i-1) && j == L &&
		 do_L_v && do_T_y && do_R_z) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Tbeta[y][jp_y][dp_y+k] + Ralpha[z][jp_z-d][kp_z]); /* D */
	      /* Note: Tbeta[y][j==L][d+k==L] will be 0.0 because it
	       * was initialized that way. That T cell includes the
	       * full target 1..L (any valid T alignment must because
	       * we must account for the full target) rooted at a B
	       * state, and a transition from that B state to this
	       * BEGR_S is always probability 1.0.
	       */
	    } /* end of for k loop */
	  } /* end of for d loop */
	  /* Two more special cases in truncated alignment, we have to
	   * do these within their own for d loop because d has
	   * different restrictions than it does in the above for d
	   * loop we just closed. j's restrictions are the same
	   * though, so we stay inside the for j loop.
	   */
	  if(do_R_y && (do_J_v || do_R_v)) {
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	    for (d = dx; d >= dn; d--) {
	      dp_v = d-hdmin[v][jp_v];
	      dp_y = d-hdmin[y][jp_y];
	      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y]); /* entire sequence on right, no sequence on left, k == 0 */
	      if(do_R_v) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y]); /* entire sequence on right, no sequence on left, k == 0 */
	    }
	  }
	} /* end of for j loop */
	  } /* end of 'else if (cm->stid[v] == BEGR_S */
	  else { /* (cm->sttype[v] != BEGL_S && cm->sttype[v] != BEGR_S */
	/* in cm_CYKOutsideAlignHB(), IL and IR states are separated
	 * out from the other states at this stage because only they
	 * can self-transit, making it slightly more efficient to
	 * handle non-inserts differently. In truncated mode there's
	 * more special cases so I've decided to collapse all states
	 * together here. An analogous form of the following block is
	 * used only for IL/IR states in cm_CYKOutsideAlignHB().
	 *
	 * ILs and IRs can self transit, this means that
	 * {J,L,R}beta[v][j][d] must be fully calculated before
	 * {J,L,R}beta[v][j][d+1] can be started to be calculated,
	 * forcing the following nesting order: for j { for d { for y
	 * { } } } for non-self-transitioners, we could do a more
	 * efficient nesting order (you can see it in
	 * cm_CYKOutsideAlignHB() but we don't here because truncation
	 * makes it more complex.
	 */
	for (j = jmax[v]; j >= jmin[v]; j--) {
	  ESL_DASSERT1((j >= 0 && j <= L));
	  jp_v = j - jmin[v];
	  for (d = hdmax[v][jp_v]; d >= hdmin[v][jp_v]; d--) {
	    i = j-d+1;
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      /* mind the following sneaky if statement: in truncated
	       * aln, the only way out of state 0 is through a
	       * truncated begin, which we handled above (search for
	       * 'trpenalty'). If we're in local mode transitions out
	       * of 0 will have IMPOSSIBLE scores, but NOT if we're in
	       * glocal mode, so we need this 'if'.
	       */
	      if(y != 0) {
		voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */
		sd  = StateDelta(cm->sttype[y]);
		sdl = StateLeftDelta(cm->sttype[y]);
		sdr = StateRightDelta(cm->sttype[y]);

		do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
		do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
		do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
		do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

		/* if the y deck is invalid in J, L and R mode, we don't have to update v based on transitions from y */
		if (! (do_J_y || do_L_y || do_R_y)) continue;

		/* Note: this looks like it can be optimized, I tried but my 'optimization' slowed the code, so I reverted [EPN] */
		switch(cm->sttype[y]) {
		case MP_st:
		  jp_y = j - jmin[y];
		  if(j != L && d != j &&                                           /* boundary condition */
		     do_J_v && do_J_y &&                                           /* J deck is valid for v and y */
		     (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		     (d+sd  >= hdmin[y][jp_y+sdr] && d+sd  <= hdmax[y][jp_y+sdr])) /* d+sd  is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];  /* d index for state y */
		      escore = esc_vAA[y][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		      Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(j == L && d != j &&                                           /* boundary condition, only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		     do_L_y &&                                                     /* L deck is valid for y */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&              /* j is within y's j band */
		     (d+sdl >= hdmin[y][jp_y] && d+sdl <= hdmax[y][jp_y]))         /* d+sdl is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
		      escore = cm->lmesc[y][dsq[i-1]];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sdl] + cm->tsc[y][voffset] + escore);
		      if(do_L_v) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sdl] + cm->tsc[y][voffset] + escore);
		    }
		  if(i == 1 && j != L &&                                           /* boundary condition, only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		     do_R_y &&                                                     /* R deck is valid for y */
		     (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		     (d+sdr >= hdmin[y][jp_y+sdr] && d+sdr <= hdmax[y][jp_y+sdr])) /* d+sdr is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];  /* d index for state y */
		      escore = cm->rmesc[y][dsq[j+1]];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sdr] + cm->tsc[y][voffset] + escore);
		      if(do_R_v) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sdr] + cm->tsc[y][voffset] + escore);
		    }
		  break;

		case ML_st:
		case IL_st:
		  jp_y = j - jmin[y];
		  if(d != j &&                                              /* boundary case */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&       /* j is within y's j band */
		     (d+sdl >= hdmin[y][jp_y] && d+sdl <= hdmax[y][jp_y]))  /* d+sdl is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      escore = cm->oesc[y][dsq[i-1]];
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y+sd] + cm->tsc[y][voffset] + escore);
		      if(do_L_v && do_L_y) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(i == 1 &&                                              /* boundary condition, only allow transition from R if we're emitting first residue 1 from y  */
		     v != y &&                                              /* will only happen if v == IL, we don't allow silent self transitions from IL->IL */
		     do_R_y &&                                              /* R deck is valid for y */
		     (j     >= jmin[y]        && j     <= jmax[y]) &&       /* j is within y's j band */
		     (d     >= hdmin[y][jp_y] && d     <= hdmax[y][jp_y]))  /* d+sdr(==d) is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_R_v) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;

		case MR_st:
		case IR_st:
		  jp_y = j - jmin[y];
		  if (j != L &&                                                    /* boundary condition */
		      (j+sdr >= jmin[y]            && j+sdr <= jmax[y]) &&          /* j+sdr is within y's j band */
		      (d+sd  >= hdmin[y][jp_y+sdr] && d+sd  <= hdmax[y][jp_y+sdr])) /* d+sd is within y's d band for j+sdr */
		    {
		      dp_y = d - hdmin[y][jp_y+sdr];
		      escore = cm->oesc[y][dsq[j+1]];
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		      if(do_R_v && do_R_y) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y+sdr][dp_y+sd] + cm->tsc[y][voffset] + escore);
		    }
		  if(j == L &&                                                     /* boundary condition, only allow transition from L if we're emitting final residue L from y */
		     v != y &&                                                     /* will only happen if v == IR, we don't allow silent self transitions from IR->IR */
		     do_L_y &&                                                     /* L deck is valid for y */
		     (j     >= jmin[y]           && j      <= jmax[y]) &&          /* j is within y's j band */
		     (d     >= hdmin[y][jp_y]    && d      <= hdmax[y][jp_y]))     /* d+sdl(==d) is within y's d band for j */
		    {
		      dp_y = d - hdmin[y][jp_y];
		      if(do_J_v) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_L_v) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;
		case S_st:
		case E_st:
		case D_st:
		  jp_y = j - jmin[y];
		  if((j >= jmin[y]        && j <= jmax[y]) &&
		     (d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]))
		    {
		      dp_y = d - hdmin[y][jp_y];  /* d index for state y */
		      if(do_J_v && do_J_y) Jbeta[v][jp_v][dp_v] = FLogsum(Jbeta[v][jp_v][dp_v], Jbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_L_v && do_L_y) Lbeta[v][jp_v][dp_v] = FLogsum(Lbeta[v][jp_v][dp_v], Lbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		      if(do_R_v && do_R_y) Rbeta[v][jp_v][dp_v] = FLogsum(Rbeta[v][jp_v][dp_v], Rbeta[y][jp_y][dp_y] + cm->tsc[y][voffset]);
		    }
		  break;
		} /* end of switch(cm->sttype[y] */
	      } /* end of sneaky if y != 0 */
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (do_J_v && Jbeta[v][jp_v][dp_v] < IMPOSSIBLE) Jbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	    if (do_L_v && Lbeta[v][jp_v][dp_v] < IMPOSSIBLE) Lbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	    if (do_R_v && Rbeta[v][jp_v][dp_v] < IMPOSSIBLE) Rbeta[v][jp_v][dp_v] = IMPOSSIBLE;
	  } /* ends loop over d. We know all beta[v][j][d] in this row j and state v */
	} /* end loop over jp. We know beta for this whole state */
	  } /* end of 'else' (entered if cm->sttype[v] != BEGL_S nor BEGR_S */
	  /* we're done calculating deck v for everything but local ends */

	  /* deal with local alignment end transitions v->EL (EL = deck at M.) */
	  if ((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	sd       = StateDelta(cm->sttype[v]);      /* note sd  is for state v */
	sdl      = StateLeftDelta(cm->sttype[v]);  /* note sdl is for state v */
	sdr      = StateRightDelta(cm->sttype[v]); /* note sdr is for state v */
	emitmode = Emitmode(cm->sttype[v]);        /* note emitmode is for state v */

	/* we handle all three possible modes (J,L,R) differently because they have different boundary conditions */

	/* J mode */
	if(do_J_v && cp9b->Jvalid[cm->M]) {
	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v + sdr] - sd;
	    dx   = hdmax[v][jp_v + sdr] - sd;
	    i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]*cm->abc->Kp+dsq[j+1]];
		Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]];
		Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITRIGHT:
	      escore = esc_vAA[v][dsq[j+1]];
	      for (d = dn; d <= dx; d++, dp_v++) {
		Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
		Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[v][jp_v+sdr][dp_v+sd] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	}

	/* L mode: again, this code is inefficient, but I chose not to try to optimize lest it get more complex */
	if(do_L_v && cp9b->Lvalid[cm->M]) {
	  jn = jmin[v];
	  jx = jmax[v];
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v] - sdl;
	    dx   = hdmax[v][jp_v] - sdl;
	    i    = j-dn+1;               /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      if(j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		for (d = dn; d <= dx; d++, dp_v++, i--) {
		  escore = cm->lmesc[v][dsq[i-1]];
		  Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v+sdl] + cm->endsc[v] + escore));
		}
	      }
	      break;

	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		escore = esc_vAA[v][dsq[i-1]];
		Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v+sdl] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITRIGHT:
	      if(j == L) { /* only allow transition from L if we haven't emitted any residues rightwise (j==L) */
		for (d = dn; d <= dx; d++, dp_v++) {
		  Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v] + cm->endsc[v]));
		}
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
		Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[v][jp_v][dp_v] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	} /* end of if(do_L_v) */

	/* R mode: again, this code is inefficient, but I chose not to try to optimize lest it get more complex */
	if(do_R_v && cp9b->Rvalid[cm->M]) {
	  jn = jmin[v] - sdr;
	  jx = jmax[v] - sdr;
	  for (j = jn; j <= jx; j++) {
	    jp_v = j - jmin[v];
	    dn   = hdmin[v][jp_v + sdr] - sdr;
	    dx   = hdmax[v][jp_v + sdr] - sdr;
	    i    = j-dn+1;                     /* we'll decrement this in for (d... loops inside switch below */
	    dp_v = dn - hdmin[v][jp_v + sdr];  /* we'll increment this in for (d... loops inside switch below */

	    switch (emitmode) {
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		if(i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		  escore = cm->rmesc[v][dsq[j+1]];
		  Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v] + escore));
		}
	      }
	      break;
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++, dp_v++, i--) {
		if(i == 1) { /* only allow transition from R if we haven't emitted any residues leftwise (i==1) */
		  Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][jp_v][dp_v] + cm->endsc[v]));
		}
	      }
	      break;

	    case EMITRIGHT:
	      escore = esc_vAA[v][dsq[j+1]];
	      for (d = dn; d <= dx; d++, dp_v++) {
		Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v] + escore));
	      }
	      break;

	    case EMITNONE:
	      for (d = dn; d <= dx; d++, dp_v++) {
		Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[v][jp_v+sdr][dp_v+sdr] + cm->endsc[v]));
	      }
	      break;
	    }
	  }
	} /* end of if(do_R_v) */
	  } /* end of calculating EL scores */
	} /* end of if !StateIsDetached() */
  } /* end loop over decks v. */

  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, EL->EL transitions. (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	if(cp9b->Jvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Jbeta[cm->M][j][d] = FLogsum(Jbeta[cm->M][j][d], (Jbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
	if(fill_L && cp9b->Lvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Lbeta[cm->M][j][d] = FLogsum(Lbeta[cm->M][j][d], (Lbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
	if(fill_R && cp9b->Rvalid[cm->M]) {
	  for (j = L; j > 0; j--) { /* careful w/ boundary here */
	for (d = j-1; d >= 0; d--) { /* careful w/ boundary here */
	  Rbeta[cm->M][j][d] = FLogsum(Rbeta[cm->M][j][d], (Rbeta[cm->M][j][d+1] + cm->el_selfsc));
	}
	  }
	}
  }
  fail_flag = FALSE;
  if(do_check) {
	/* Check for consistency between the Inside alpha matrix and the
	 * Outside beta matrix. we assume the Inside CYK parse score
	 * (optsc) is the optimal score, so for all v,j,d:
	 *
	 * Jalpha[v][j][d] + Jbeta[v][j][d] <= optsc
	 * Lalpha[v][j][d] + Lbeta[v][j][d] <= optsc
	 * Ralpha[v][j][d] + Rbeta[v][j][d] <= optsc
	 *
	 * We do a more extensive check in cm_TrCYKOutsideAlignHB(), but
	 * it doesn't apply here, because we've summed all parsetrees
	 * instead of finding only the optimal one.
	 *
	 * This is an expensive check and should only be done while
	 * debugging.
	 */
	vmax  = (cm->flags & CMH_LOCAL_END) ? cm->M : cm->M-1;
	if     (preset_mode == TRMODE_J) optsc = Jalpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_L) optsc = Lalpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_R) optsc = Ralpha[0][jp_0][Lp_0];
	else if(preset_mode == TRMODE_T) optsc = Talpha[0][jp_0][Lp_0];
	/* define bit score difference tolerance, somewhat arbitrarily:
	 * clen <= 200: tolerance is 0.001; then a function of clen:
	 * clen == 1000 tolerance is 0.005,
	 * clen == 2000, tolerance is 0.01.
	 *
	 * I did this b/c with tests with SSU_rRNA_eukarya I noticed
	 * failures with bit score differences up to 0.004 or so.  This
	 * could mean a bug, but I couldn't get any average sized model to
	 * fail with a difference above 0.001, so I blamed it on
	 * precision. I'm not entirely convinced it isn't a bug but
	 * until I see a failure on a smaller model it seems precision
	 * is the most likely explanation, right?
	 */
	tol = ESL_MAX(1e-3, (float) cm->clen / 200000.);
	for(v = 0; v <= vmax; v++) {
	  do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	  do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	  do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	  do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;
	  jn = (v == cm->M) ? 1 : jmin[v];
	  jx = (v == cm->M) ? L : jmax[v];
	  for(j = jn; j <= jx; j++) {
	jp_v = (v == cm->M) ? j : j - jmin[v];
	dn   = (v == cm->M) ? 0 : hdmin[v][jp_v];
	dx   = (v == cm->M) ? j : hdmax[v][jp_v];
	for(d = dn; d <= dx; d++) {
	  dp_v = (v == cm->M) ? d : d - hdmin[v][jp_v];
	  Jsc  = (do_J_v) ? Jalpha[v][jp_v][dp_v] + Jbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Lsc  = (do_L_v) ? Lalpha[v][jp_v][dp_v] + Lbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Rsc  = (do_R_v) ? Ralpha[v][jp_v][dp_v] + Rbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  Tsc  = (do_T_v) ? Talpha[v][jp_v][dp_v] + Tbeta[v][jp_v][dp_v] - optsc : IMPOSSIBLE;
	  if(Jsc > tol) {
	    printf("Check 1 J failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Jalpha[v][jp_v][dp_v], Jbeta[v][jp_v][dp_v], Jalpha[v][jp_v][dp_v] + Jbeta[v][jp_v][dp_v], optsc);
	    fail_flag = TRUE;
	  }
	  if(Lsc > tol) {
	    printf("Check 1 L failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Lalpha[v][jp_v][dp_v], Lbeta[v][jp_v][dp_v], Lalpha[v][jp_v][dp_v] + Lbeta[v][jp_v][dp_v], optsc);
	    fail_flag = TRUE;
	  }
	  if(Rsc > tol) {
	    printf("Check 1 R failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Ralpha[v][jp_v][dp_v], Rbeta[v][jp_v][dp_v], Ralpha[v][jp_v][dp_v] + Rbeta[v][jp_v][dp_v], optsc);
	    fail_flag = TRUE;
	  }
	  if(Tsc > tol) {
	    printf("Check 1 T failure: v: %4d j: %4d d: %4d (%.4f + %.4f) %.4f > %.4f\n",
		   v, j, d, Talpha[v][jp_v][dp_v], Tbeta[v][jp_v][dp_v], Talpha[v][jp_v][dp_v] + Tbeta[v][jp_v][dp_v], optsc);
	    fail_flag = TRUE;
	  }
	}
	  }
	}
  }
  if(fail_flag) for(j = 1; j <= L; j++) printf("dsq[%4d]: %4d\n", j, dsq[j]);

#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_ohbmx", "w");   cm_tr_hb_mx_Dump(fp1, mx, preset_mode, TRUE); fclose(fp1);
#endif

  if(do_check) {
	if(fail_flag) ESL_FAIL(eslFAIL, errbuf, "Tr Inside/Outside HB check FAILED.");
	ESL_DPRINTF1(("SUCCESS! Tr Inside/Outside HB check PASSED.\n"));
	printf("SUCCESS! Tr Inside/Outside HB check PASSED.\n");
  }

  if     (preset_mode == TRMODE_J) optsc = Jalpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_L) optsc = Lalpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_R) optsc = Ralpha[0][jp_0][Lp_0];
  else if(preset_mode == TRMODE_T) optsc = Talpha[0][jp_0][Lp_0];
  ESL_DPRINTF1(("\tcm_TrOutsideAlignHB() sc : %f (sc is from Inside!)\n", optsc));

  return eslOK;
}

/* Function: cm_TrPosterior()
 * Date:     EPN, Tue Sep 13 16:18:25 2011
 * Note:     based on Ian Holmes' P7EmitterPosterior() from HMMER's 2.x postprob.c
 *
 * Purpose: Combines non-banded cm_TrInside and cm_TrOutside matrices
 *           into a posterior probability matrix. The value in
 *           post->{J,L,R}[v][j][d] is the log of the posterior
 *           probability of a parse subtree rooted at v emitting the
 *           subsequence i..j (i=j-d+1) and being in J, L, or R mode
 *           at at state v.  The caller must provide a <post> float
 *           matrix, but this matrix may be the same matrix as that
 *           provided as Outside <out_mx>, (overwriting it will not
 *           compromise the algorithm).
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           L           - length of the target sequence we're aligning
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - mode of alignment: TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T
 *           ins_mx      - pre-calculated Inside matrix
 *           out_mx      - pre-calculated Outside matrix
 *           post_mx     - pre-allocated matrix for Posteriors
 *
 * Return:   eslOK on success, eslEINCOMPAT on contract violation
 */
int
cm_TrPosterior(CM_t *cm, char *errbuf, int L, float size_limit, char preset_mode,
	       CM_TR_MX *ins_mx, CM_TR_MX *out_mx, CM_TR_MX *post_mx)
{
  int   status;   /* Easel status code */
  int   v;        /* state index */
  int   j;        /* position */
  int   d;        /* subsequence length */
  float sc;       /* optimal Inside score */
  int   fill_L, fill_R, fill_T; /* should we fill-in values for L, R, T? (we always fill in J) */

  /* Determine which matrices we need to fill-in, and the optimal score */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPosterior(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrPosterior, bogus preset_mode: %d", preset_mode);
  if(preset_mode == TRMODE_J) sc = ins_mx->Jdp[0][L][L];
  if(preset_mode == TRMODE_L) sc = ins_mx->Ldp[0][L][L];
  if(preset_mode == TRMODE_R) sc = ins_mx->Rdp[0][L][L];
  if(preset_mode == TRMODE_T) sc = ins_mx->Tdp[0][L][L];

  /* grow our post matrix, but only if isn't also our out_mx in which
   * case we know we're already big enought (also in that case we
   * don't want to call GrowTo b/c it can potentially free the DP
   * matrix memory and reallocate it, which would be bad b/c we
   * need the out_mx!)
   */
  if(post_mx != out_mx) {
	if((status = cm_tr_mx_GrowTo(cm, post_mx, errbuf, L, size_limit)) != eslOK) return status;
  }

  /* If local ends are on, start with the EL state (cm->M), otherwise
   * it's not a valid deck. */
  if(cm->flags & CMH_LOCAL_END) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	post_mx->Jdp[cm->M][j][d] = ins_mx->Jdp[cm->M][j][d] + out_mx->Jdp[cm->M][j][d] - sc;
	  }
	}
	if(fill_L) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Ldp[cm->M][j][d] = ins_mx->Ldp[cm->M][j][d] + out_mx->Ldp[cm->M][j][d] - sc;
	}
	  }
	}
	if(fill_R) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Rdp[cm->M][j][d] = ins_mx->Rdp[cm->M][j][d] + out_mx->Rdp[cm->M][j][d] - sc;
	}
	  }
	}
  }

  /* Fill in the rest of the matrices */
  for (v = cm->M-1; v >= 0; v--) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	post_mx->Jdp[v][j][d] = ins_mx->Jdp[v][j][d] + out_mx->Jdp[v][j][d] - sc;
	  }
	}
  }
  if (fill_L) {
	for (v = cm->M-1; v >= 0; v--) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Ldp[v][j][d] = ins_mx->Ldp[v][j][d] + out_mx->Ldp[v][j][d] - sc;
	}
	  }
	}
  }
  if (fill_R) {
	for (v = cm->M-1; v >= 0; v--) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Rdp[v][j][d] = ins_mx->Rdp[v][j][d] + out_mx->Rdp[v][j][d] - sc;
	}
	  }
	}
  }
  if (fill_T) {
	for (v = cm->M-1; v >= 0; v--) {
	  if (v == 0 || cm->sttype[v] == B_st) {
	for (j = 0; j <= L; j++) {
	  for (d = 0; d <= j; d++) {
	    post_mx->Tdp[v][j][d] = ins_mx->Tdp[v][j][d] + out_mx->Tdp[v][j][d] - sc;
	  }
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_pmx", "w");   cm_tr_mx_Dump(fp1, post_mx, preset_mode, TRUE); fclose(fp1);
#endif

  return eslOK;
}

/* Function: cm_TrPosteriorHB()
 * Date:     EPN, Tue Oct 11 09:24:07 2011
 * Note:     based on Ian Holmes' P7EmitterPosterior() from HMMER's 2.x postprob.c
 *
 * Purpose: Combines HMM banded cm_TrInside and cm_TrOutside matrices
 *           into a posterior probability matrix. Any cells outside of
 *           the HMM bands do not exist in memory. The value in
 *           post->{J,L,R}[v][jp_v][dp_v] is the log of the posterior
 *           probability of a parse subtree rooted at v emitting the
 *           subsequence i..j (i=j-d+1) and being in J, L, or R mode
 *           at at state v, with jp_v = j-jmin[v] and dp_v =
 *           d-hdmin[v][jp_v].  The caller must provide a <post> float
 *           matrix, but this matrix may be the same matrix as that
 *           provided as Outside <out_mx>, (overwriting it will not
 *           compromise the algorithm).
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           L           - length of the target sequence we're aligning
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           preset_mode - mode of alignment: TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T
 *           ins_mx      - pre-calculated Inside matrix
 *           out_mx      - pre-calculated Outside matrix
 *           post_mx     - pre-allocated matrix for Posteriors
 *
 * Return:   <eslOK> on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslEINVAL> if the full sequence is not within the bands for state 0
 *           In either case the post_mx is not filled
 */
int
cm_TrPosteriorHB(CM_t *cm, char *errbuf, int L, float size_limit, char preset_mode,
		 CM_TR_HB_MX *ins_mx, CM_TR_HB_MX *out_mx, CM_TR_HB_MX *post_mx)
{
  int   status;   /* Easel status code */
  int   v;        /* state index */
  int   j;        /* position */
  int   d;        /* subsequence length */
  int   jp_v;     /* j offset in HMM banded matrix */
  int   dp_v;     /* d offset in HMM banded matrix */
  int   jx;       /* max j */
  int   dx;       /* max d */
  int   jp_0;     /* L offset in ROOT_S's (v==0) j band */
  int   Lp_0;     /* L offset in ROOT_S's (v==0) d band */
  float sc;       /* optimal Inside score */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* Determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPosteriorHB(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrPosteriorHB(), bogus mode: %d", preset_mode);

  /* ensure a full alignment to ROOT_S (v==0) is allowed by the bands */
  if (cm->cp9b->jmin[0] > L || cm->cp9b->jmax[0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cm->cp9b->jmin[0], cm->cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cm->cp9b->hdmin[0][jp_0] > L || cm->cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_CYKInsideAlignHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cm->cp9b->hdmin[0][jp_0], cm->cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* Determine the optimal score */
  if(preset_mode == TRMODE_J) sc = ins_mx->Jdp[0][jp_0][Lp_0];
  if(preset_mode == TRMODE_L) sc = ins_mx->Ldp[0][jp_0][Lp_0];
  if(preset_mode == TRMODE_R) sc = ins_mx->Rdp[0][jp_0][Lp_0];
  if(preset_mode == TRMODE_T) sc = ins_mx->Tdp[0][jp_0][Lp_0];

  /* grow our post matrix, but only if isn't also our out_mx in which
   * case we know we're already big enought (also in that case we
   * don't want to call GrowTo b/c it can potentially free the DP
   * matrix memory and reallocate it, which would be bad b/c we
   * need the out_mx!)
   */
  if(post_mx != out_mx) {
	if((status = cm_tr_hb_mx_GrowTo(cm, post_mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;
  }

  /* If local ends are on, start with the non-banded EL state (cm->M), otherwise it's not a valid deck. */
  if(cm->flags & CMH_LOCAL_END) {
	if(cp9b->Jvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Jdp[cm->M][j][d] = ins_mx->Jdp[cm->M][j][d] + out_mx->Jdp[cm->M][j][d] - sc;
	}
	  }
	}
	if(fill_L && cp9b->Lvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Ldp[cm->M][j][d] = ins_mx->Ldp[cm->M][j][d] + out_mx->Ldp[cm->M][j][d] - sc;
	}
	  }
	}
	if(fill_R && cp9b->Rvalid[cm->M]) {
	  for (j = 0; j <= L; j++) {
	for (d = 0; d <= j; d++) {
	  post_mx->Rdp[cm->M][j][d] = ins_mx->Rdp[cm->M][j][d] + out_mx->Rdp[cm->M][j][d] - sc;
	}
	  }
	}
  }
  /* Fill in the rest of the matrices */
  for (v = cm->M-1; v >= 0; v--) {
	if(cp9b->Jvalid[v]) {
	  jx = jmax[v]-jmin[v];
	  for (jp_v = 0; jp_v <= jx; jp_v++) {
	dx = hdmax[v][jp_v]-hdmin[v][jp_v];
	for (dp_v = 0; dp_v <= dx; dp_v++) {
	  post_mx->Jdp[v][jp_v][dp_v] = ins_mx->Jdp[v][jp_v][dp_v] + out_mx->Jdp[v][jp_v][dp_v] - sc;
	}
	  }
	}
  }
  if(fill_L) {
	for (v = cm->M-1; v >= 0; v--) {
	  if(cp9b->Lvalid[v]) {
	jx = jmax[v]-jmin[v];
	for (jp_v = 0; jp_v <= jx; jp_v++) {
	  dx = hdmax[v][jp_v]-hdmin[v][jp_v];
	  for (dp_v = 0; dp_v <= dx; dp_v++) {
	    post_mx->Ldp[v][jp_v][dp_v] = ins_mx->Ldp[v][jp_v][dp_v] + out_mx->Ldp[v][jp_v][dp_v] - sc;
	  }
	}
	  }
	}
  }
  if(fill_R) {
	for (v = cm->M-1; v >= 0; v--) {
	  if(cp9b->Rvalid[v]) {
	jx = jmax[v]-jmin[v];
	for (jp_v = 0; jp_v <= jx; jp_v++) {
	  dx = hdmax[v][jp_v]-hdmin[v][jp_v];
	  for (dp_v = 0; dp_v <= dx; dp_v++) {
	    post_mx->Rdp[v][jp_v][dp_v] = ins_mx->Rdp[v][jp_v][dp_v] + out_mx->Rdp[v][jp_v][dp_v] - sc;
	  }
	}
	  }
	}
  }
  if(fill_T) {
	for (v = cm->M-1; v >= 0; v--) {
	  if(cp9b->Tvalid[v]) {
	jx = jmax[v]-jmin[v];
	for (jp_v = 0; jp_v <= jx; jp_v++) {
	  dx = hdmax[v][jp_v]-hdmin[v][jp_v];
	  for (dp_v = 0; dp_v <= dx; dp_v++) {
	    post_mx->Tdp[v][jp_v][dp_v] = ins_mx->Tdp[v][jp_v][dp_v] + out_mx->Tdp[v][jp_v][dp_v] - sc;
	  }
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
	FILE *fp1; fp1 = fopen("tmp.tru_phbmx", "w");   cm_tr_hb_mx_Dump(fp1, post_mx, preset_mode, TRUE); fclose(fp1);
#endif
  return eslOK;
}

/* Function: cm_TrEmitterPosterior()
 * Date:     EPN, Fri Oct  7 05:30:31 2011
 *
 * Purpose: Given a posterior probability cube, where the value in
 *           post[v][j][d] is the log of the posterior probability of
 *           a parse subtree rooted at v emitting the subsequence i..j
 *           (i=j-d+1), fill a CM_EMIT_MX <emit_mx> with
 *           matrices with values:
 *
 *           emit_mx->*l_pp[v][i]: log of the posterior probability
 *           that state v emitted residue i leftwise while in * (J or
 *           L, Joint of Left) marginal mode either at (if a match
 *           state) or *after* (if an insert state) the left consensus
 *           position modeled by state v's node.
 *
 *           emit_mx->*r_pp[v][i]: log of the posterior probability
 *           that state v emitted residue i rightwise while in * (J
 *           or R, Joint or Right) marginal mode either at (if a match
 *           state) or *before* (if an insert state) the right
 *           consensus position modeled by state v's node.
 *
 *           *l_pp[v] is NULL for states that do not emit leftwise
 *           *r_pp[v] is NULL for states that do not emit rightwise
 *
 *           We only need to fill a subset of the *l_pp and *r_pp
 *           matrices, depending on the <preset_mode> of the alignment
 *           which is known and passed in:
 *           <preset_mode> == TRMODE_J, fill Jl_pp, Jr_pp
 *           <preset_mode> == TRMODE_L, fill Jl_pp, Jr_pp and Ll_pp
 *           <preset_mode> == TRMODE_R, fill Jl_pp, Jr_pp and Rr_pp
 *           <preset_mode> == TRMODE_T, fill Jl_pp, Jr_pp, Ll_pp, and Rr_pp
 *
 *          This is done in 3 steps:
 *          1. Fill *l_pp[v][i] and *r_pp[v][i] with the posterior
 *             probability that state v emitted residue i either
 *             leftwise (l_pp) or rightwise (r_pp).
 *
 *          2. Normalize *l_pp and *r_pp so that probability that
 *             each residue was emitted by any state is exactly
 *             1.0.
 *
 *          3. Combine *l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
 *             states in the same node so they give the value defined
 *             above (i.e. *l_pp[v] == *l_pp[y] = the PP that either v
 *             or y emitted residue i) instead of *l_pp[v] = PP that v
 *             emitted i, and *l_pp[y] = PP that y emitted i.  And
 *             combine *r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
 *             states in an analogous way.
 *
 *          If <do_check> we check to make sure the summed probability
 *          of any residue is > 0.98 and < 1.02 prior the step 2
 *          normalization, and throw eslFAIL if not.
 *
 *          Note: A failure of this test does not necessarily mean a
 *          bug in the code, because this check is known to fail for
 *          some cases with parsetrees that contain inserts of 100s of
 *          residues from the same IL or IR state (that utilize 100s
 *          of IL->IL or IR->IR self transitions). These cases were
 *          looked at in detail to determine if they were due to a bug
 *          in the DP code. This was logged in
 *          ~nawrockie/notebook/8_1016_inf-1rc3_bug_alignment/00LOG.
 *          The conclusion was that the failure of the posterior check
 *          is due completely to lack of precision in the float scores
 *          (not just in the logsum look-up table but also with using
 *          real log() and exp() calls). If this function returns an
 *          error, please check to see if the parsetree has a large
 *          insertion in it, if so you can expect probabilities up to
 *          1.03 due solely to this precision issue. See the notebook
 *          00LOG for more, included a check I performed to change the
 *          relevant IL->IL transition probability by very small
 *          values (~0.0001) and you can observe the posteriors change
 *          dramatically which demonstrates that precision of floats
 *          is the culprit.  (EPN, Sun Oct 26 14:54:31 2008
 *          (originally added to cm_Posterior() function 'Purpose'
 *          function which no longer exists, having been replaced by
 *          this function.)
 *
 * Args:     cm          - the model
 *           errbuf      - for error messages
 *           L           - length of the sequence
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           post        - pre-filled posterior cube
 *           emit_mx     - pre-allocated emit matrix, grown and filled-in here
 *           preset_mode - known (pre-determined) mode of the alignment
 *           do_check    - if TRUE, return eslEFAIL if summed prob of any residue
 *                         (before normalization) is < 0.98 or > 1.02.
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslFAIL>   if (do_check) and any residue check fails
 *           <eslEMEM>   if we run out of memory.
 *           If !eslOK the l_pp and r_pp values are invalid.
 */
int
cm_TrEmitterPosterior(CM_t *cm, char *errbuf, int L, float size_limit, char preset_mode, int do_check, CM_TR_MX *post, CM_TR_EMIT_MX *emit_mx)
{
  int    status;
  int    v, j, d; /* state, position, subseq length */
  int    i;       /* sequence position */
  int    sd;      /* StateDelta(v) */
  int    sdl;     /* StateLeftDelta(v) */
  int    sdr;     /* StateRightDelta(v) */
  int    fill_L, fill_R; /* do we need to fill Ll_pp/Rr_pp matrices? */

  /* determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrEmitterPosterior(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, NULL)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCheckFromPosterior, bogus mode: %d", preset_mode);

  /* grow the emit matrices based on the current sequence */
  if((status = cm_tr_emit_mx_GrowTo(cm, emit_mx, errbuf, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the emit matrices to IMPOSSIBLE */
  esl_vec_FSet(emit_mx->Jl_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  if(fill_L) esl_vec_FSet(emit_mx->Ll_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  esl_vec_FSet(emit_mx->Jr_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);
  if(fill_R) esl_vec_FSet(emit_mx->Rr_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);

  /* Step 1. Fill *l_pp[v][i] and *r_pp[v][i] with the posterior
   *         probability that state v emitted residue i either
   *         leftwise (*l_pp) or rightwise (*r_pp).
   */
  for(v = 0; v < cm->M; v++) {
	sd  = StateDelta(cm->sttype[v]);
	sdl = StateLeftDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  for(j = 1; j <= L; j++) {
	i = j-sd+1;
	for(d = sd; d <= j; d++, i--) {
	  emit_mx->Jl_pp[v][i] = FLogsum(emit_mx->Jl_pp[v][i], post->Jdp[v][j][d]);
	}
	if(fill_L) {
	  i = j-sdl+1; /* careful, use sdl, not sd */
	  for(d = sdl; d <= j; d++, i--) {
	    emit_mx->Ll_pp[v][i] = FLogsum(emit_mx->Ll_pp[v][i], post->Ldp[v][j][d]);
	  }
	}
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  for(j = 1; j <= L; j++) {
	for(d = sd; d <= j; d++) {
	  emit_mx->Jr_pp[v][j] = FLogsum(emit_mx->Jr_pp[v][j], post->Jdp[v][j][d]);
	}
	if(fill_R) {
	  for(d = sdr; d <= j; d++) { /* careful, use sdr, not sd */
	    emit_mx->Rr_pp[v][j] = FLogsum(emit_mx->Rr_pp[v][j], post->Rdp[v][j][d]);
	  }
	}
	  }
	}
  }
  /* factor in contribution of local ends, the EL state may have emitted this residue. */
  if (cm->flags & CMH_LOCAL_END) {
	for (j = 1; j <= L; j++) {
	  i = j;
	  for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	emit_mx->Jl_pp[cm->M][i] = FLogsum(emit_mx->Jl_pp[cm->M][i], post->Jdp[cm->M][j][d]);
	  }
	}
	if(fill_L) {
	  for (j = 1; j <= L; j++) {
	i = j;
	for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	  emit_mx->Ll_pp[cm->M][i] = FLogsum(emit_mx->Ll_pp[cm->M][i], post->Ldp[cm->M][j][d]);
	}
	  }
	}
	if(fill_R) {
	  for (j = 1; j <= L; j++) {
	i = j;
	for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	  emit_mx->Rr_pp[cm->M][i] = FLogsum(emit_mx->Rr_pp[cm->M][i], post->Rdp[cm->M][j][d]);
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_unnorm_emitmx",  "w"); cm_tr_emit_mx_Dump(fp1, cm, emit_mx, preset_mode, TRUE); fclose(fp1);
#endif

  /* Step 2. Normalize *l_pp and *r_pp so that probability that
   *         each residue was emitted by any state is exactly
   *         1.0.
   */
  esl_vec_FSet(emit_mx->sum, (L+1), IMPOSSIBLE);
  for(v = 0; v <= cm->M; v++) {
	if(emit_mx->Jl_pp[v] != NULL) {
	  for(i = 1; i <= L; i++) {
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Jl_pp[v][i]);
	  }
	}
	if(emit_mx->Ll_pp[v] != NULL && fill_L) {
	  for(i = 1; i <= L; i++) {
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Ll_pp[v][i]);
	  }
	}
	if(emit_mx->Jr_pp[v] != NULL) {
	  for(j = 1; j <= L; j++) {
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->Jr_pp[v][j]);
	  }
	}
	if(emit_mx->Rr_pp[v] != NULL && fill_R) {
	  for(j = 1; j <= L; j++) {
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->Rr_pp[v][j]);
	  }
	}
  }
  /* perform the check, if nec */
  if(do_check) {
	for(i = 1; i <= L; i++) {
	  if((sreEXP2(emit_mx->sum[i]) < 0.98) || (sreEXP2(emit_mx->sum[i]) > 1.02)) {
	ESL_FAIL(eslFAIL, errbuf, "residue %d has summed prob of %5.4f (2^%5.4f).\nMay not be a DP coding bug, see 'Note:' on precision in cm_TrEmitterPosterior", i, (sreEXP2(emit_mx->sum[i])), emit_mx->sum[i]);
	  }
	  /*printf("i: %d | total: %10.4f\n", i, (sreEXP2(emit_mx->sum[i])));*/
	}
	ESL_DPRINTF1(("cm_TrEmitterPosterior() check passed, all residues have summed probability of emission of between 0.98 and 1.02.\n"));
  }

  /* normalize, using the sum vector */
  for(v = 0; v <= cm->M; v++) {
	if(emit_mx->Jl_pp[v] != NULL) {
	  for(i = 1; i <= L; i++) emit_mx->Jl_pp[v][i] -= emit_mx->sum[i];
	}
	if(emit_mx->Ll_pp[v] != NULL && fill_L) {
	  for(i = 1; i <= L; i++) emit_mx->Ll_pp[v][i] -= emit_mx->sum[i];
	}
	if(emit_mx->Jr_pp[v] != NULL) {
	  for(j = 1; j <= L; j++) emit_mx->Jr_pp[v][j] -= emit_mx->sum[j];
	}
	if(emit_mx->Rr_pp[v] != NULL && fill_R) {
	  for(j = 1; j <= L; j++) emit_mx->Rr_pp[v][j] -= emit_mx->sum[j];
	}
  }

  /* Step 3. Combine *l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
   *         states in the same node so they give the value defined
   *         above (i.e. *l_pp[v] == *l_pp[y] = the PP that either v or
   *         y emitted residue i) instead of *l_pp[v] = PP that v
   *         emitted i, and *l_pp[y] = PP that y emitted i.  And
   *         combine *r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
   *         states in an analogous way.
   */
  for(v = 0; v <= cm->M; v++) {
	if(cm->sttype[v] == MP_st) {
	  for(i = 1; i <= L; i++) {
	emit_mx->Jl_pp[v][i]   = FLogsum(emit_mx->Jl_pp[v][i], emit_mx->Jl_pp[v+1][i]);
	emit_mx->Jl_pp[v+1][i] = emit_mx->Jl_pp[v][i];
	  }
	  if(fill_L) {
	for(i = 1; i <= L; i++) {
	  emit_mx->Ll_pp[v][i]   = FLogsum(emit_mx->Ll_pp[v][i], emit_mx->Ll_pp[v+1][i]);
	  emit_mx->Ll_pp[v+1][i] = emit_mx->Ll_pp[v][i];
	}
	  }
	  for(j = 1; j <= L; j++) {
	emit_mx->Jr_pp[v][j]   = FLogsum(emit_mx->Jr_pp[v][j], emit_mx->Jr_pp[v+2][j]);
	emit_mx->Jr_pp[v+2][j] = emit_mx->Jr_pp[v][j];
	  }
	  if(fill_R){
	for(j = 1; j <= L; j++) {
	  emit_mx->Rr_pp[v][j]   = FLogsum(emit_mx->Rr_pp[v][j], emit_mx->Rr_pp[v+2][j]);
	  emit_mx->Rr_pp[v+2][j] = emit_mx->Rr_pp[v][j];
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
  FILE *fp2; fp2 = fopen("tmp.tru_emitmx",  "w"); cm_tr_emit_mx_Dump(fp2, cm, emit_mx, preset_mode, TRUE); fclose(fp2);
#endif

  return eslOK;
}

/* Function: cm_TrEmitterPosteriorHB()
 * Date:     EPN, Tue Oct 11 09:36:55 2011
 *
 * Purpose: Same as cm_TrEmitterPosterior() except HMM banded matrices
 *          are used. The main difference is that we have to be careful
 *          to stay within the bands because matrix cells outside
 *          the bands do not exist (are not allocated). This requires
 *          keeping careful track of our offsets between the sequence
 *          position index and the corresponding indices in the matrix.
 *
 * Args:     cm          - the model
 *           errbuf      - for error messages
 *           L           - length of the sequence
 *           size_limit  - max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           post        - pre-filled posterior cube
 *           emit_mx     - pre-allocated emit matrix, grown and filled-in here
 *           preset_mode - known optimal mode of the alignment
 *           do_check    - if TRUE, return eslEFAIL if summed prob of any residue
 *                         (before normalization) is < 0.98 or > 1.02.
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslERANGE> if required DP matrix size exceeds <size_limit>
 *           <eslFAIL>   if (do_check) and any residue check fails
 *           <eslEMEM>   if we run out of memory.
 *           If !eslOK the *l_pp and *r_pp values are invalid.
 */
int
cm_TrEmitterPosteriorHB(CM_t *cm, char *errbuf, int L, float size_limit, char preset_mode, int do_check, CM_TR_HB_MX *post, CM_TR_HB_EMIT_MX *emit_mx)
{
  int    status;
  int    v, j, d; /* state, position, subseq length */
  int    i;       /* sequence position */
  int    fill_L, fill_R; /* do we need to fill Ll_pp/Rr_pp matrices? */
  int    jp_v;    /* j-jmin[v] for current j, and current v */
  int    jp_v2;   /* another offset j in banded matrix */
  int    ip_v;    /* i-imin[v] for current i, and current v */
  int    ip_v2;   /* another offset i in banded matrix */
  int    dp_v;    /* d-hdmin[v][jp_v] for current j, current v, current d*/
  int    in, ix;  /* temp min/max i */
  int    jn, jx;  /* temp min/max j */

  /* ptrs to band info, for convenience */
  int     *imin  = cm->cp9b->imin;
  int     *imax  = cm->cp9b->imax;
  int     *jmin  = cm->cp9b->jmin;
  int     *jmax  = cm->cp9b->jmax;
  int    **hdmin = cm->cp9b->hdmin;
  int    **hdmax = cm->cp9b->hdmax;

  /* determine which matrices we need to fill in, based on <preset_mode> */
  if (preset_mode != TRMODE_J && preset_mode != TRMODE_L && preset_mode != TRMODE_R && preset_mode != TRMODE_T) ESL_FAIL(eslEINVAL, errbuf, "cm_TrEmitterPosteriorHB(): preset_mode is not J, L, R, or T");
  if((status = cm_TrFillFromMode(preset_mode, &fill_L, &fill_R, NULL)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrCheckFromPosterior, bogus mode: %d", preset_mode);

  /* grow the emit matrices based on the current sequence */
  if((status = cm_tr_hb_emit_mx_GrowTo(cm, emit_mx, errbuf, cm->cp9b, L, size_limit)) != eslOK) return status;

  /* initialize all cells of the emit matrices to IMPOSSIBLE */
  esl_vec_FSet(emit_mx->Jl_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  if(fill_L) esl_vec_FSet(emit_mx->Ll_pp_mem, emit_mx->l_ncells_valid, IMPOSSIBLE);
  esl_vec_FSet(emit_mx->Jr_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);
  if(fill_R) esl_vec_FSet(emit_mx->Rr_pp_mem, emit_mx->r_ncells_valid, IMPOSSIBLE);

  /* Step 1. Fill *l_pp[v][i] and *r_pp[v][i] with the posterior
   *         probability that state v emitted residue i either
   *         leftwise (*l_pp) or rightwise (*r_pp).
   */
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  if(cm->cp9b->Jvalid[v]) {
	for(j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d-hdmin[v][jp_v];
	    i    = j-d+1;
	    assert(i >= imin[v] && i <= imax[v]);
	    ip_v = i - imin[v];
	    emit_mx->Jl_pp[v][ip_v] = FLogsum(emit_mx->Jl_pp[v][ip_v], post->Jdp[v][jp_v][dp_v]);
	  }
	}
	  }
	  if(cm->cp9b->Lvalid[v] && fill_L) {
	for(j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d-hdmin[v][jp_v];
	    i    = j-d+1;
	    assert(i >= imin[v] && i <= imax[v]);
	    ip_v = i - imin[v];
	    emit_mx->Ll_pp[v][ip_v] = FLogsum(emit_mx->Ll_pp[v][ip_v], post->Ldp[v][jp_v][dp_v]);
	  }
	}
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  if(cm->cp9b->Jvalid[v]) {
	for(j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d-hdmin[v][jp_v];
	    emit_mx->Jr_pp[v][jp_v] = FLogsum(emit_mx->Jr_pp[v][jp_v], post->Jdp[v][jp_v][dp_v]);
	  }
	}
	  }
	  if(cm->cp9b->Rvalid[v] && fill_R) {
	for(j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  for(d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	    dp_v = d-hdmin[v][jp_v];
	    emit_mx->Rr_pp[v][jp_v] = FLogsum(emit_mx->Rr_pp[v][jp_v], post->Rdp[v][jp_v][dp_v]);
	  }
	}
	  }
	}
  }
  /* factor in contribution of local ends, the EL state may have emitted this residue. */
  /* Remember, the EL deck is non-banded */
  if (cm->flags & CMH_LOCAL_END) {
	if(cm->cp9b->Jvalid[cm->M]) {
	  for (j = 1; j <= L; j++) {
	i = j;
	for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	  emit_mx->Jl_pp[cm->M][i] = FLogsum(emit_mx->Jl_pp[cm->M][i], post->Jdp[cm->M][j][d]);
	}
	  }
	}
	if(fill_L && cm->cp9b->Lvalid[cm->M]) {
	  for (j = 1; j <= L; j++) {
	i = j;
	for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	  emit_mx->Ll_pp[cm->M][i] = FLogsum(emit_mx->Ll_pp[cm->M][i], post->Ldp[cm->M][j][d]);
	}
	  }
	}
	if(fill_R && cm->cp9b->Rvalid[cm->M]) {
	  for (j = 1; j <= L; j++) {
	i = j;
	for (d = 1; d <= j; d++, i--) { /* note: d >= 1, b/c EL emits 1 residue */
	  emit_mx->Rr_pp[cm->M][i] = FLogsum(emit_mx->Rr_pp[cm->M][i], post->Rdp[cm->M][j][d]);
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
  FILE *fp1; fp1 = fopen("tmp.tru_unnorm_hbemitmx",  "w"); cm_tr_hb_emit_mx_Dump(fp1, cm, emit_mx, preset_mode, TRUE); fclose(fp1);
#endif

  /* Step 2. Normalize *l_pp and *r_pp so that probability that
   *         each residue was emitted by any state is exactly
   *         1.0.
   */
  esl_vec_FSet(emit_mx->sum, (L+1), IMPOSSIBLE);
  for(v = 0; v < cm->M; v++) { /* we'll handle EL special */
	if(emit_mx->Jl_pp[v] != NULL && cm->cp9b->Jvalid[v]) {
	  in = ESL_MAX(imin[v], 1);
	  ix = ESL_MIN(imax[v], L);
	  for(i = in; i <= ix; i++) {
	ip_v = i - imin[v];
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Jl_pp[v][ip_v]);
	  }
	}
	if(emit_mx->Ll_pp[v] != NULL && cm->cp9b->Lvalid[v] && fill_L) {
	  in = ESL_MAX(imin[v], 1);
	  ix = ESL_MIN(imax[v], L);
	  for(i = in; i <= ix; i++) {
	ip_v = i - imin[v];
	emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Ll_pp[v][ip_v]);
	  }
	}
	if(emit_mx->Jr_pp[v] != NULL && cm->cp9b->Jvalid[v]) {
	  jn = ESL_MAX(jmin[v], 1);
	  jx = ESL_MIN(jmax[v], L);
	  for(j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->Jr_pp[v][jp_v]);
	  }
	}
	if(emit_mx->Rr_pp[v] != NULL && cm->cp9b->Rvalid[v] && fill_R) {
	  jn = ESL_MAX(jmin[v], 1);
	  jx = ESL_MIN(jmax[v], L);
	  for(j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	emit_mx->sum[j] = FLogsum(emit_mx->sum[j], emit_mx->Rr_pp[v][jp_v]);
	  }
	}
  }
  /* Handle EL deck, remember it is non-banded, and only valid for Jl_pp, Ll_pp and Rr_pp */
  if(emit_mx->Jl_pp[cm->M] != NULL && cm->cp9b->Jvalid[cm->M]) {
	for(i = 1; i <= L; i++) {
	  emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Jl_pp[cm->M][i]);
	}
  }
  if(emit_mx->Ll_pp[cm->M] != NULL && cm->cp9b->Lvalid[cm->M] && fill_L) {
	for(i = 1; i <= L; i++) {
	  emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Ll_pp[cm->M][i]);
	}
  }
  if(emit_mx->Rr_pp[cm->M] != NULL && cm->cp9b->Rvalid[cm->M] && fill_R) {
	for(i = 1; i <= L; i++) {
	  emit_mx->sum[i] = FLogsum(emit_mx->sum[i], emit_mx->Rr_pp[cm->M][i]);
	}
  }

  /* perform the check, if nec */
  if(do_check) {
	for(i = 1; i <= L; i++) {
	  if((sreEXP2(emit_mx->sum[i]) < 0.98) || (sreEXP2(emit_mx->sum[i]) > 1.02)) {
	ESL_FAIL(eslFAIL, errbuf, "residue %d has summed prob of %5.4f (2^%5.4f).\nMay not be a DP coding bug, see 'Note:' on precision in cm_TrEmitterPosterior().\n", i, (sreEXP2(emit_mx->sum[i])), emit_mx->sum[i]);
	  }
	  /*printf("i: %d | total: %10.4f\n", i, (sreEXP2(emit_mx->sum[i])));*/
	}
	ESL_DPRINTF1(("cm_TrEmitterPosteriorHB() check passed, all residues have summed probability of emission of between 0.98 and 1.02.\n"));
  }

  /* normalize, using the sum vector */
  for(v = 0; v < cm->M; v++) {
	if(emit_mx->Jl_pp[v] != NULL && cm->cp9b->Jvalid[v]) {
	  in = ESL_MAX(imin[v], 1);
	  ix = ESL_MIN(imax[v], L);
	  for(i = in; i <= ix; i++) {
	ip_v = i - imin[v];
	emit_mx->Jl_pp[v][ip_v] -= emit_mx->sum[i];
	  }
	}
	if(emit_mx->Ll_pp[v] != NULL && cm->cp9b->Lvalid[v] && fill_L) {
	  in = ESL_MAX(imin[v], 1);
	  ix = ESL_MIN(imax[v], L);
	  for(i = in; i <= ix; i++) {
	ip_v = i - imin[v];
	emit_mx->Ll_pp[v][ip_v] -= emit_mx->sum[i];
	  }
	}
	if(emit_mx->Jr_pp[v] != NULL && cm->cp9b->Jvalid[v]) {
	  jn = ESL_MAX(jmin[v], 1);
	  jx = ESL_MIN(jmax[v], L);
	  for(j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	emit_mx->Jr_pp[v][jp_v] -= emit_mx->sum[j];
	  }
	}
	if(emit_mx->Rr_pp[v] != NULL && cm->cp9b->Rvalid[v] && fill_R) {
	  jn = ESL_MAX(jmin[v], 1);
	  jx = ESL_MIN(jmax[v], L);
	  for(j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	emit_mx->Rr_pp[v][jp_v] -= emit_mx->sum[j];
	  }
	}
  }
  /* Handle EL deck, remember it is non-banded */
  if(emit_mx->Jl_pp[cm->M] != NULL && cm->cp9b->Jvalid[cm->M]) {
	for(i = 1; i <= L; i++) {
	  emit_mx->Jl_pp[cm->M][i] -= emit_mx->sum[i];
	}
  }
  if(emit_mx->Ll_pp[cm->M] != NULL && cm->cp9b->Lvalid[cm->M] && fill_L) {
	for(i = 1; i <= L; i++) {
	  emit_mx->Ll_pp[cm->M][i] -= emit_mx->sum[i];
	}
  }
  if(emit_mx->Rr_pp[cm->M] != NULL && cm->cp9b->Rvalid[cm->M] && fill_R) {
	for(i = 1; i <= L; i++) {
	  emit_mx->Rr_pp[cm->M][i] -= emit_mx->sum[i];
	}
  }
  /* Step 3. Combine *l_pp values for MATP_MP (v) and MATP_ML (y=v+1)
   *         states in the same node so they give the value defined
   *         above (i.e. *l_pp[v] == *l_pp[y] = the PP that either v or
   *         y emitted residue i) instead of *l_pp[v] = PP that v
   *         emitted i, and *l_pp[y] = PP that y emitted i.  And
   *         combine *r_pp values for MATP_MP (v) and MATP_MR (y=v+2)
   *         states in an analogous way.
   */
  for(v = 0; v <= cm->M; v++) {
	if(cm->sttype[v] == MP_st) {
	  /* we only change {J,L}l_pp[v][i] and {J,L}l_pp[v+1][i] if i is within both
	   * state v and v+1's i band.
	   */
	  if(cm->cp9b->Jvalid[v]) {
	if(imax[v] >= 1 && imax[v+1] >= 1) {
	  in = ESL_MAX(imin[v], imin[v+1]);
	  ix = ESL_MIN(imax[v], imax[v+1]);
	  for(i = in; i <= ix; i++) {
	    ip_v  = i - imin[v];
	    ip_v2 = i - imin[v+1];
	    emit_mx->Jl_pp[v][ip_v]    = FLogsum(emit_mx->Jl_pp[v][ip_v], emit_mx->Jl_pp[v+1][ip_v2]);
	    emit_mx->Jl_pp[v+1][ip_v2] = emit_mx->Jl_pp[v][ip_v];
	  }
	}
	  }
	  if(cm->cp9b->Lvalid[v] && fill_L) {
	if(imax[v] >= 1 && imax[v+1] >= 1) {
	  in = ESL_MAX(imin[v], imin[v+1]);
	  ix = ESL_MIN(imax[v], imax[v+1]);
	  for(i = in; i <= ix; i++) {
	    ip_v  = i - imin[v];
	    ip_v2 = i - imin[v+1];
	    emit_mx->Ll_pp[v][ip_v]    = FLogsum(emit_mx->Ll_pp[v][ip_v], emit_mx->Ll_pp[v+1][ip_v2]);
	    emit_mx->Ll_pp[v+1][ip_v2] = emit_mx->Ll_pp[v][ip_v];
	  }
	}
	  }
	  /* we only change {J,R}r_pp[v][j] and {J,R}r_pp[v+2][j] if j is within both
	   * state v and v+2's j band.
	   */
	  if(cm->cp9b->Jvalid[v]) {
	if(jmax[v] >= 1 && jmax[v+2] >= 1) {
	  jn = ESL_MAX(jmin[v], jmin[v+2]);
	  jx = ESL_MIN(jmax[v], jmax[v+2]);
	  for(j = jn; j <= jx; j++) {
	    jp_v  = j - jmin[v];
	    jp_v2 = j - jmin[v+2];
	    emit_mx->Jr_pp[v][jp_v]    = FLogsum(emit_mx->Jr_pp[v][jp_v], emit_mx->Jr_pp[v+2][jp_v2]);
	    emit_mx->Jr_pp[v+2][jp_v2] = emit_mx->Jr_pp[v][jp_v];
	  }
	}
	  }
	  if(cm->cp9b->Rvalid[v] && fill_R) {
	if(jmax[v] >= 1 && jmax[v+2] >= 1) {
	  jn = ESL_MAX(jmin[v], jmin[v+2]);
	  jx = ESL_MIN(jmax[v], jmax[v+2]);
	  for(j = jn; j <= jx; j++) {
	    jp_v  = j - jmin[v];
	    jp_v2 = j - jmin[v+2];
	    emit_mx->Rr_pp[v][jp_v]    = FLogsum(emit_mx->Rr_pp[v][jp_v], emit_mx->Rr_pp[v+2][jp_v2]);
	    emit_mx->Rr_pp[v+2][jp_v2] = emit_mx->Rr_pp[v][jp_v];
	  }
	}
	  }
	}
  }
#if eslDEBUGLEVEL >= 2
  FILE *fp2; fp2 = fopen("tmp.tru_hbemitmx",  "w"); cm_tr_hb_emit_mx_Dump(fp2, cm, emit_mx, preset_mode, TRUE); fclose(fp2);
#endif

  return eslOK;
}

/* Function: cm_TrPostCode()
 * Date:     EPN, Fri Oct  7 14:30:32 2011
 *
 * Purpose: Given a parse tree and a filled emit matrix calculate two
 *           strings that represents the confidence values on each
 *           aligned residue in the sequence.
 *
 *           The emit_mx values are:
 *           {J,L}l_pp[v][i]: log of the posterior probability that state v emitted
 *                            residue i leftwise either at (if a match state) or
 *                            *after* (if an insert state) the left consensus
 *                            position modeled by state v's node in Joint marginal
 *                            mode (for Jl_pp) or Left marginal mode (for Ll_pp).
 *
 *           {J,R}r_pp[v][i]: log of the posterior probability that state v emitted
 *                            residue i rightwise either at (if a match state) or
 *                            *before* (if an insert state) the right consensus
 *                            position modeled by state v's node in Joint marginal
 *                            mode (for Jr_pp) or Right marginal mode (for Rr_pp).
 *
 *           {J,L}l_pp[v] is NULL for states that do not emit leftwise  (B,S,D,E,IR,MR)
 *           {J,R}r_pp[v] is NULL for states that do not emit rightwise (B,S,D,E,IL,ML)
 *
 *           The PP string is 0..L-1  (L = len of target seq),
 *           so its in the coordinate system of the sequence string;
 *           off by one from dsq.
 *
 *           Values are 0,1,2,3,4,5,6,7,8,9,*:
 *           '0' = [0.00-0.05)
 *           '1' = [0.05-0.15)
 *           '2' = [0.15-0.25)
 *           '3' = [0.25-0.35)
 *           '4' = [0.35-0.45)
 *           '5' = [0.45-0.55)
 *           '6' = [0.55-0.65)
 *           '7' = [0.65-0.75)
 *           '8' = [0.75-0.85)
 *           '9' = [0.85-0.95)
 *           '*' = [0.95-1.00)
 *
 *           cm_TrPostCodeHB() is nearly the same function with the
 *           difference that HMM bands were used for the alignment,
 *           so we have to deal with offset issues.
 *
 *           Renamed from CMPostCode() [EPN, Wed Sep 14 06:20:35 2011].
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           dsq        - the digitized sequence [1..L]
 *           L          - length of the dsq to align
 *           emit_mx    - the pre-filled emit matrix
 *           tr         - the parstree with the emissions we're setting PPs for
 *           ret_ppstr  - RETURN: a string of the PP code values (0..L-1)
 *           ret_avgp   - RETURN: the average PP of all aligned residues
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslEINVAL> if a posterior probability is > 1.01 or less than -0.01.
 *                       or if we get a marginal mode in the parsetree that doesn't
 *                       make sense.
 */
int
cm_TrPostCode(CM_t *cm, char *errbuf, int L, CM_TR_EMIT_MX *emit_mx, Parsetree_t *tr, char **ret_ppstr, float *ret_avgp)
{
  int   status;
  int   x, v, i, j, r; /* counters */
  char *ppstr;       /* the PP string, created here */
  float p;           /* a probability */
  float sum_logp;    /* log of summed probability of all residues emitted thus far */
  float cur_log_pp;  /* current log probability of emitting a residue */
  char  mode;        /* marginal mode: TRMODE_J, TRMODE_L or TRMODE_R */
  int   have_el;     /* TRUE if CM has local ends, otherwise FALSE */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  ESL_ALLOC(ppstr, (L+1) * sizeof(char));
  sum_logp = IMPOSSIBLE;

  /* go through each node of the parsetree and determine post code for emissions */
  for (x = 0; x < tr->n; x++) {
	v    = tr->state[x];
	i    = tr->emitl[x];
	j    = tr->emitr[x];
	mode = tr->mode[x];

	/* Only P, L, R, and EL states have emissions. */
	if(cm->sttype[v] == EL_st) { /* EL state, we have to handle this guy special */
	  if(mode == TRMODE_J || mode == TRMODE_L || mode == TRMODE_R) {
	for(r = i; r <= j; r++) { /* we have to annotate from residues i..j */
	  if(! have_el) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode() using EL state to emit residue %d, but ELs are turned off!\n", r);
	  switch (mode) {
	  case TRMODE_J: cur_log_pp = emit_mx->Jl_pp[v][r]; break;
	  case TRMODE_L: cur_log_pp = emit_mx->Ll_pp[v][r]; break;
	  case TRMODE_R: cur_log_pp = emit_mx->Rr_pp[v][r]; break;
	  }
	  ppstr[r-1] = Fscore2postcode(cur_log_pp);
	  sum_logp   = FLogsum(sum_logp, cur_log_pp);
	  /* make sure we've got a valid probability */
	  p = FScore2Prob(cur_log_pp, 1.);
	  if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for EL state v: %d residue r: %d > 1.00 (%.2f)", v, r, p);
	  if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for EL state v: %d residue r: %d < 0.00 (%.2f)", v, r, p);
	}
	  }
	  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): invalid mode for EL state in the parsetree: %d\n", mode);
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  if(mode == TRMODE_J || mode == TRMODE_L) {
	cur_log_pp = (mode == TRMODE_J) ? emit_mx->Jl_pp[v][i] : emit_mx->Ll_pp[v][i];
	ppstr[i-1] = Fscore2postcode(cur_log_pp);
	sum_logp   = FLogsum(sum_logp, cur_log_pp);
	/* make sure we've got a valid probability */
	p = FScore2Prob(cur_log_pp, 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for left state v: %d residue i: %d > 1.00 (%.2f)", v, i, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for left state v: %d residue i: %d < 0.00 (%.2f)", v, i, p);
	  }
	  else if(mode != TRMODE_R) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): non-sensical mode for MP, ML, IL state: %d", mode);
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  if(mode == TRMODE_J || mode == TRMODE_R) {
	cur_log_pp = (mode == TRMODE_J) ? emit_mx->Jr_pp[v][j] : emit_mx->Rr_pp[v][j];
	ppstr[j-1] = Fscore2postcode(cur_log_pp);
	sum_logp   = FLogsum(sum_logp, cur_log_pp);
	/* make sure we've got a valid probability */
	p = FScore2Prob(cur_log_pp, 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for right state v: %d residue i: %d > 1.00 (%.2f)", v, j, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): probability for right state v: %d residue i: %d < 0.00 (%.2f)", v, j, p);
	  }
	  else if(mode != TRMODE_L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): non-sensical mode for MP, MR, IR state: %d", mode);
	}
  }
  ppstr[L] = '\0';

  if(ret_ppstr != NULL) *ret_ppstr = ppstr; else free(ppstr);
  if(ret_avgp  != NULL) *ret_avgp  = sreEXP2(sum_logp) / (float) L;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_TrPostcode(): Memory allocation error.");
  return status; /* never reached */
}

/* Function: cm_TrPostCodeHB()
 * Date:     EPN, Tue Oct 11 09:58:47 2011
 *
 * Purpose: Same as cm_TrPostCode() except HMM banded matrices are
 *          used. The main difference is that we have to be careful to
 *          stay within the bands because matrix cells outside the
 *          bands do not exist (are not allocated). This requires
 *          keeping careful track of our offsets between the sequence
 *          position index and the corresponding indices in the
 *          matrix.
 *
 * Args:     cm         - the model
 *           errbuf     - char buffer for reporting errors
 *           dsq        - the digitized sequence [1..L]
 *           L          - length of the dsq to align
 *           emit_mx    - the pre-filled emit matrix
 *           tr         - the parstree with the emissions we're setting PPs for
 *           ret_ppstr  - RETURN: a string of the PP code values (0..L-1)
 *           ret_avgp   - RETURN: the average PP of all aligned residues
 *
 * Returns:  <eslOK>     on success.
 * Throws:   <eslEINVAL> if a posterior probability is > 1.01 or less than -0.01.
 *                       or if we get a marginal mode in the parsetree that doesn't
 *                       make sense.
 */
int
cm_TrPostCodeHB(CM_t *cm, char *errbuf, int L, CM_TR_HB_EMIT_MX *emit_mx, Parsetree_t *tr, char **ret_ppstr, float *ret_avgp)
{
  int   status;
  int   x, v, i, j, r; /* counters */
  char *ppstr;       /* the PP string, created here */
  float p;           /* a probability */
  float sum_logp;    /* log of summed probability of all residues emitted thus far */
  float cur_log_pp;  /* current log probability of emitting a residue */
  char  mode;        /* marginal mode: TRMODE_J, TRMODE_L or TRMODE_R */
  int   have_el;     /* TRUE if CM has local ends, otherwise FALSE */

  /* variables used for HMM bands */
  int ip_v, jp_v; /* i, j offset within bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *imin  = cp9b->imin;
  int     *imax  = cp9b->imax;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  ESL_ALLOC(ppstr, (L+1) * sizeof(char));
  sum_logp = IMPOSSIBLE;

  /* go through each node of the parsetree and determine post code for emissions */
  for (x = 0; x < tr->n; x++) {
	v    = tr->state[x];
	i    = tr->emitl[x];
	j    = tr->emitr[x];
	mode = tr->mode[x];

	/* Only P, L, R, and EL states have emissions. */
	if(cm->sttype[v] == EL_st) { /* EL state, we have to handle this guy special */
	  /* Note it is possible to use an EL state in an HMM banded
	   * truncated optimal accuracy parsetree if d == 0 (no EL
	   * emissions) even when local ends are off! (This is also true
	   * in non-truncated HMM banded OA, see the note in
	   * cm_dpalign.c:cm_alignT_hb() regarding the special case
	   * involving allow_S_local_end'.) This means we don't fail
	   * if local ends are off and we see EL unless we see that we've
	   * emitted >= 1 residues from EL.
	   */
	  if(mode == TRMODE_J || mode == TRMODE_L || mode == TRMODE_R) {
	for(r = i; r <= j; r++) { /* we have to annotate from residues i..j */
	  if(! have_el) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB() using EL state to emit residue %d, but ELs are turned off!\n", r);
	  /* remember the EL deck is non-banded */
	  switch (mode) {
	  case TRMODE_J: cur_log_pp = emit_mx->Jl_pp[v][r]; break;
	  case TRMODE_L: cur_log_pp = emit_mx->Ll_pp[v][r]; break;
	  case TRMODE_R: cur_log_pp = emit_mx->Rr_pp[v][r]; break;
	  }
	  ppstr[r-1] = Fscore2postcode(cur_log_pp);
	  sum_logp   = FLogsum(sum_logp, cur_log_pp);
	  /* make sure we've got a valid probability */
	  p = FScore2Prob(cur_log_pp, 1.);
	  if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for EL state v: %d residue r: %d > 1.00 (%.2f)", v, r, p);
	  if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for EL state v: %d residue r: %d < 0.00 (%.2f)", v, r, p);
	}
	  }
	  else ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): invalid mode for EL state in the parsetree: %d\n", mode);
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  if(mode == TRMODE_J || mode == TRMODE_L) {
	ip_v = i - imin[v];
	assert(i >= imin[v] && i <= imax[v]);
	ESL_DASSERT1((i >= imin[v] && i <= imax[v]));
	cur_log_pp = (mode == TRMODE_J) ? emit_mx->Jl_pp[v][ip_v] : emit_mx->Ll_pp[v][ip_v];
	ppstr[i-1] = Fscore2postcode(cur_log_pp);
	sum_logp   = FLogsum(sum_logp, cur_log_pp);
	/* make sure we've got a valid probability */
	p = FScore2Prob(cur_log_pp, 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for left state v: %d residue i: %d > 1.00 (%.2f)", v, i, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for left state v: %d residue i: %d < 0.00 (%.2f)", v, i, p);
	  }
	  else if(mode != TRMODE_R) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): non-sensical mode for MP, ML, IL state: %d", mode);
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  if(mode == TRMODE_J || mode == TRMODE_R) {
	jp_v = j - jmin[v];
	assert(j >= jmin[v] && j <= jmax[v]);
	ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	cur_log_pp = (mode == TRMODE_J) ? emit_mx->Jr_pp[v][jp_v] : emit_mx->Rr_pp[v][jp_v];
	ppstr[j-1] = Fscore2postcode(cur_log_pp);
	sum_logp   = FLogsum(sum_logp, cur_log_pp);
	/* make sure we've got a valid probability */
	p = FScore2Prob(cur_log_pp, 1.);
	if(p >  1.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for right state v: %d residue i: %d > 1.00 (%.2f)", v, j, p);
	if(p < -0.01) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCodeHB(): probability for right state v: %d residue i: %d < 0.00 (%.2f)", v, j, p);
	  }
	  else if(mode != TRMODE_L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrPostCode(): non-sensical mode for MP, MR, IR state: %d", mode);
	}
  }
  ppstr[L] = '\0';

  /*printf("cm_TrPostCodeHB() return avgpp: %f\n", sreEXP2(sum_logp) / (float) L);*/
  ESL_DPRINTF1(("cm_TrPostCodeHB() return avgpp: %f\n", sreEXP2(sum_logp) / (float) L));

  if(ret_ppstr != NULL) *ret_ppstr = ppstr; else free(ppstr);
  if(ret_avgp  != NULL) *ret_avgp  = sreEXP2(sum_logp) / (float) L;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_TrPostcodeHB(): Memory allocation error.");
  return status; /* never reached */
}

/* Function: cm_TrFillFromMode()
 * Date:     EPN, Wed Sep 28 05:29:19 2011
 *
 * Purpose: Given an optimal marginal alignment mode
 *          (could be TRMODE_UNKNOWN), determine which
 *          of the marginal matrices we need to fill
 *          in to find the alignment in that mode.
 *
 *          If mode == TRMODE_J: fill J matrix only
 *          If mode == TRMODE_L: fill J and L matrices only
 *          If mode == TRMODE_R: fill J and R  matrices only
 *          If mode == TRMODE_T: fill J, L, R, and T matrices
 *          If mode == TRMODE_UNKNOWN: fill J, L, R, and T matrices
 *
 *          Return TRUE/FALSE values in <ret_fill_{L,R,T}>.
 *          Note that we always must fill in J matrices so a fill_J
 *          value is unnecessary, it's implicitly true.
 *
 * Args:     mode       - optimal mode
 *           ret_fill_L - RETURN: should we fill in L based on <ret_mode>?
 *           ret_fill_R - RETURN: should we fill in R based on <ret_mode>?
 *           ret_fill_T - RETURN: should we fill in T based on <ret_mode>?
 *
 * Throws:   eslEINVAL if mode is not TRMODE_J, TRMODE_L, TRMODE_R, TRMODE_T nor TRMODE_UNKNOWN.
 */
int
cm_TrFillFromMode(char mode, int *ret_fill_L, int *ret_fill_R, int *ret_fill_T)
{
  int fill_L, fill_R, fill_T;
  int invalid_mode = FALSE;

  fill_L = fill_R = fill_T = FALSE;
  switch(mode) {
  case TRMODE_J:
	break;
  case TRMODE_L:
	fill_L = TRUE;
	break;
  case TRMODE_R:
	fill_R = TRUE;
	break;
  case TRMODE_T:
  case TRMODE_UNKNOWN:
	fill_L = fill_R = fill_T = TRUE;
	break;
  default:
	invalid_mode = TRUE;
	break;
  }

  if(ret_fill_L != NULL) *ret_fill_L = fill_L;
  if(ret_fill_R != NULL) *ret_fill_R = fill_R;
  if(ret_fill_T != NULL) *ret_fill_T = fill_T;

  if(invalid_mode) return eslEINVAL;
  return eslOK;
}

/*****************************************************************
 * Benchmark driver
 *****************************************************************/
#ifdef IMPL_TRUNC_ALIGN_BENCHMARK
/* Next line is optimized (debugging on) on MacBook Pro:
 * gcc   -o benchmark-trunc-align -std=gnu99 -g -Wall -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_TRUNC_ALIGN_BENCHMARK cm_dpalign_trunc.c -linfernal -lhmmer -leasel -lm
 * Next line is optimized (debugging not on) on wyvern:
 * gcc   -o benchmark-trunc-align -std=gnu99 -O3 -fomit-frame-pointer -malign-double -fstrict-aliasing -pthread -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_TRUNC_ALIGN_BENCHMARK cm_dpalign_trunc.c -linfernal -lhmmer -leasel -lm
 * ./benchmark-trunc-align <cmfile>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",           0 },
  { "-l",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "configure CM/HMM for local alignment", 0 },
  { "--cykout",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL,"--optacc", "run TrCYKOutside, to make sure it agrees with TrCYKInside", 0 },
  { "--std",     eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also do standard (non-truncated) alignments",    0},
  { "--orig",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,"--search", NULL, "also do search with original trCYK",         0},
  { "--hb",      eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also do HMM banded alignments",                   0},
  { "--failok",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "allow failures of Inside vs Outside checks",      0},
  { "--search",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also run search algorithms",                   0},
  { "--noqdb",   eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "don't use QDBs", 0},
  { "--sums",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "use posterior sums during HMM band calculation (widens bands)", 0},
  { "--onlyhb",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "only run HMM banded scanning trCYK", 0},
  { "--optacc",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "run optimal accuracy alignment instead of CYK", 0},
  { "--compacc", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "run optimal accuracy and CYK and ensure OA avg pp >= CYK avg pp", 0},
  { "--tau",     eslARG_REAL,   "5e-6",NULL, "0<x<1",NULL, NULL, NULL, "set tail loss prob for HMM bands to <x>", 0},
  { "--cp9noel", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  "-l", NULL,         "turn OFF local ends in cp9 HMMs", 0},
  { "--cp9gloc", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, "--cp9noel",  "configure CP9 HMM in glocal mode", 0},
  { "--thresh1", eslARG_REAL,  "0.01", NULL, NULL,  NULL,  NULL,  NULL, "set HMM bands thresh1 to <x>", 0},
  { "--thresh2", eslARG_REAL,  "0.99", NULL, NULL,  NULL,  NULL,  NULL, "set HMM bands thresh2 to <x>", 0},
  { "--mxsize",  eslARG_REAL, "128.", NULL, "x>0", NULL,  NULL,  NULL, "set maximum allowed size of HB matrices to <x> Mb", 0},
  { "--tr",      eslARG_NONE,  FALSE,  NULL, NULL,  NULL,  NULL,  NULL, "dump parsetrees to stdout", 0},
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile> <seqfile>";
static char banner[] = "benchmark driver for truncated alignment implementations";

int
main(int argc, char **argv)
{
  int                status;
  ESL_GETOPTS       *go      = esl_getopts_CreateDefaultApp(options, 2, argc, argv, banner, usage);
  CM_t              *cm;
  ESL_STOPWATCH     *w       = esl_stopwatch_Create();
  ESL_ALPHABET      *abc     = NULL;
  ESL_DSQ           *dsq;
  int                i;
  float              sc, sc_oa, sc_cyk;
  float              pp_oa, pp_cyk;
  char              *cmfile  = esl_opt_GetArg(go, 1);
  char              *seqfile = esl_opt_GetArg(go, 2);
  CM_FILE           *cmfp;	/* open input CM file stream */
  int                L;         /* length of sequence */
  char               errbuf[eslERRBUFSIZE];
  int                pass_idx  = PLI_PASS_5P_AND_3P_ANY; /* this only affects the truncation penalty, not really impt */
  ESL_SQFILE        *sqfp      = NULL;        /* open sequence input file stream */
  ESL_SQ            *sq        = NULL;  /* a sequence */
  Parsetree_t       *tr        = NULL;
  float              size_limit = esl_opt_GetReal(go, "--mxsize");
  float              save_tau, save_cp9b_thresh1, save_cp9b_thresh2;
  float              hbmx_Mb, trhbmx_Mb;
  float              parsetree_sc, parsetree_struct_sc;
  char               mode;
  int                qdbidx;
  int                do_optacc = (   esl_opt_GetBoolean(go, "--optacc")  || esl_opt_GetBoolean(go, "--compacc")) ? TRUE : FALSE;
  int                do_cyk    = ((! esl_opt_GetBoolean(go, "--optacc")) || esl_opt_GetBoolean(go, "--compacc")) ? TRUE : FALSE;
  int                do_compacc = esl_opt_GetBoolean(go, "--compacc") ? TRUE : FALSE;
  char              *ppstr = NULL; /* just so cm_*Align*() will return avg PP for CYK */

  /* open CM file */
  if ((status = cm_file_Open(cmfile, NULL, FALSE, &(cmfp), errbuf)) != eslOK) cm_Fail(errbuf);
  if ((status = cm_file_Read(cmfp, TRUE, &abc, &cm))                != eslOK) cm_Fail(cmfp->errbuf);
  cm_file_Close(cmfp);

  /* open the sequence file */
  status = esl_sqfile_OpenDigital(cm->abc, seqfile, eslSQFILE_UNKNOWN, NULL, &sqfp);
  if (status == eslENOTFOUND)    esl_fatal("File %s doesn't exist or is not readable\n", seqfile);
  else if (status == eslEFORMAT) esl_fatal("Couldn't determine format of sequence file %s\n", seqfile);
  else if (status == eslEINVAL)  esl_fatal("Can't autodetect stdin or .gz.");
  else if (status != eslOK)      esl_fatal("Sequence file open failed with error %d.\n", status);

  cm->config_opts |= CM_CONFIG_TRUNC;
  cm->align_opts  |= CM_ALIGN_HBANDED;
  if(esl_opt_GetBoolean(go, "--sums")) cm->align_opts |= CM_ALIGN_SUMS;

  if(esl_opt_GetBoolean(go, "-l")) {
	cm->config_opts |= CM_CONFIG_LOCAL;
	if(! esl_opt_GetBoolean(go, "--cp9gloc")) {
	  cm->config_opts |= CM_CONFIG_HMMLOCAL;
	  if(! esl_opt_GetBoolean(go, "--cp9noel")) cm->config_opts |= CM_CONFIG_HMMEL;
	}
  }
  if(esl_opt_GetBoolean(go, "--search")) {
	cm->config_opts |= CM_CONFIG_SCANMX;
	cm->config_opts |= CM_CONFIG_TRSCANMX;
  }

  cm->align_opts |= CM_ALIGN_CHECKINOUT;

  if((status = cm_Configure(cm, errbuf, -1)) != eslOK) cm_Fail(errbuf);

  /* setup logsum lookups (could do this only if nec based on options, but this is safer) */
  init_ilogsum();
  FLogsumInit();

  /* create nonbanded matrices if nec */
  if(esl_opt_GetBoolean(go, "--std")) {
	cm->nb_mx   = cm_mx_Create(cm->M);
	cm->nb_omx  = cm_mx_Create(cm->M);
	cm->nb_shmx = cm_shadow_mx_Create(cm);
	cm->nb_emx  = cm_emit_mx_Create(cm);
  }

  if (esl_opt_IsUsed(go, "--thresh1")) { cm->cp9b->thresh1 = esl_opt_GetReal(go, "--thresh1"); }
  if (esl_opt_IsUsed(go, "--thresh2")) { cm->cp9b->thresh2 = esl_opt_GetReal(go, "--thresh2"); }

  if (esl_opt_GetBoolean(go, "--noqdb")) {
	cm->search_opts |= CM_SEARCH_NONBANDED; /* don't use QDB to search */
	qdbidx = SMX_NOQDB;
  }
  else {
	qdbidx = SMX_QDB1_TIGHT;
  }

  cm->tau = esl_opt_GetReal(go, "--tau");

  if(! esl_opt_GetBoolean(go, "--onlyhb")) {
	printf("%-30s", "Creating tr matrix...");
	fflush(stdout);
	esl_stopwatch_Start(w);
	cm->trnb_mx   = cm_tr_mx_Create(cm);
	cm->trnb_omx  = cm_tr_mx_Create(cm);
	cm->trnb_emx  = cm_tr_emit_mx_Create(cm);
	cm->trnb_shmx = cm_tr_shadow_mx_Create(cm);
	printf("done.  ");
	fflush(stdout);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
  }

  save_tau = cm->tau;
  save_cp9b_thresh1 = cm->cp9b->thresh1;
  save_cp9b_thresh2 = cm->cp9b->thresh2;

  i = 0;
  sq = esl_sq_CreateDigital(cm->abc);
  while((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	i++;
	L = sq->n;
	dsq = sq->dsq;
	cm->search_opts &= ~CM_SEARCH_INSIDE;

	cm->tau = save_tau;
	cm->cp9b->thresh1 = save_cp9b_thresh1;
	cm->cp9b->thresh2 = save_cp9b_thresh2;

	cm->align_opts  |= CM_ALIGN_HBANDED;

	/* 1. non-banded truncated alignment, unless --onlyhb
	 * 2. non-banded standard  alignment, if requested
	 * 3. HMM banded truncated alignment, if requested
	 * 4. HMM banded standard  alignment, if requested
	 * 5. non-banded truncated search,    if requested
	 * 6. non-banded standard  search,    if requested
	 * 7. HMM banded truncated search,    if requested
	 * 8. HMM banded standard  search,    if requested
	 */

	/* 1. non-banded truncated alignment, unless --onlyhb */
	if(! esl_opt_GetBoolean(go, "--onlyhb")) {
	  /*********************Begin cm_TrAlign****************************/
	  if(do_optacc) {
	esl_stopwatch_Start(w);
	if((status = cm_TrAlign(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, TRUE, FALSE, cm->trnb_mx, cm->trnb_shmx, cm->trnb_omx, cm->trnb_emx, NULL, &ppstr, &tr, &mode, &pp_oa, &sc_oa)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f PP (mode: %s)  (FULL LENGTH OPTACC)\n", i, "cm_TrAlign(): ", pp_oa, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	free(ppstr); ppstr = NULL;
	printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);
	  }
	  if(do_cyk) {
	esl_stopwatch_Start(w);
	if((status = cm_TrAlign(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, FALSE, FALSE, cm->trnb_mx, cm->trnb_shmx, cm->trnb_omx, cm->trnb_emx, NULL,
				(do_compacc) ? &ppstr : NULL,
				&tr, &mode, &pp_cyk, &sc_cyk)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f pp %10.4f bits (mode: %s) (FULL LENGTH CYK)\n", i, "cm_TrAlign(): ", pp_cyk, sc_cyk, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	if(ppstr != NULL) { free(ppstr); ppstr = NULL; }
	printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);
	  }
	  if(do_compacc) {
	if((pp_oa - pp_cyk) < -0.0001) cm_Fail("ERROR OA PP: %f < CYK PP: %f\n", pp_oa, pp_cyk);
	  }
	  /*********************End cm_TrAlign****************************/

	  if(esl_opt_GetBoolean(go, "--cykout")) {
	/*********************Begin cm_TrCYKOutsideAlign****************************/
	esl_stopwatch_Start(w);
	status = cm_TrCYKOutsideAlign(cm, errbuf, dsq,  L, size_limit, mode, pass_idx, TRUE, cm->trnb_omx, cm->trnb_mx);
	if     (status != eslOK && esl_opt_GetBoolean(go, "--failok")) printf("%s\nError detected, but continuing thanks to --failok\n", errbuf);
	else if(status != eslOK)                                       cm_Fail(errbuf);
	printf("%4d %-30s %10s bits ", i, "cm_TrCYKOutsideAlign() CYK:", "?");
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End cm_TrCYKOutsideAlign****************************/
	  }

	  /*********************Begin cm_TrInsideAlign()****************************/
	  if((status = cm_TrInsideAlign(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, cm->trnb_mx, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (FULL LENGTH INSIDE)", i, "cm_TrInsideAlign(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End cm_TrInsideAlign*****************************/
	}

	/* 2. non-banded standard (non-truncated) alignment, if requested */
	if(esl_opt_GetBoolean(go, "--std") && (! esl_opt_GetBoolean(go, "--onlyhb"))) {
	  /*********************Begin cm_Align()****************************/
	  if(do_optacc) {
	esl_stopwatch_Start(w);
	if((status = cm_Align  (cm, errbuf, dsq, L, size_limit, TRUE, FALSE, cm->nb_mx, cm->nb_shmx, cm->nb_omx, cm->nb_emx, NULL, &ppstr, &tr, &pp_oa, &sc_oa)) != eslOK) return status;
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	mode = ParsetreeMode(tr);
	FreeParsetree(tr);
	free(ppstr); ppstr = NULL;
	printf("%4d %-30s %10.4f pp   (FULL LENGTH OPTACC)\n", i, "cm_Align(): ", pp_oa);
	printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);
	  }
	  if(do_cyk) {
	esl_stopwatch_Start(w);
	if((status = cm_Align  (cm, errbuf, dsq, L, size_limit, FALSE, FALSE, cm->nb_mx, cm->nb_shmx, cm->nb_omx, cm->nb_emx, NULL,
				(do_compacc) ? &ppstr : NULL,
				&tr, &pp_cyk, &sc_cyk)) != eslOK) return status;
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	mode = ParsetreeMode(tr);
	FreeParsetree(tr);
	if(ppstr != NULL) { free(ppstr); ppstr = NULL; }
	printf("%4d %-30s %10.4f pp %10.4f bits  (FULL LENGTH OPTACC)\n", i, "cm_Align(): ", pp_cyk, sc_cyk);
	  	printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);
	  }
	  if(do_compacc) {
	if((pp_oa - pp_cyk) < -0.0001) cm_Fail("ERROR OA PP: %f < CYK PP: %f\n", pp_oa, pp_cyk);
	  }
	  /*********************End cm_Align*****************************/

	  if(esl_opt_GetBoolean(go, "--cykout")) {
	/*********************Begin cm_CYKOutsideAlign****************************/
	esl_stopwatch_Start(w);
	status = cm_CYKOutsideAlign(cm, errbuf, dsq, L, size_limit, TRUE, cm->nb_omx, cm->nb_mx, &sc);
	if     (status != eslOK && esl_opt_GetBoolean(go, "--failok")) printf("%s\nError detected, but continuing thanks to --failok\n", errbuf);
	else if(status != eslOK)                                       cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", i, "cm_CYKOutsideAlign() CYK:", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End cm_CYKOutsideAlign****************************/
	  }

	  /*********************Begin cm_InsideAlign()****************************/
	  esl_stopwatch_Start(w);
	  if((status = cm_InsideAlign (cm, errbuf, dsq, L, size_limit, cm->nb_mx, &sc)) != eslOK) return status;
	  printf("%4d %-30s %10.4f bits (FULL LENGTH INSIDE)", i, "cm_InsideAlign(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End cm_InsideAlign*****************************/

	  /*********************Begin cm_OutsideAlign*****************************/
	  esl_stopwatch_Start(w);
	  if((status = cm_OutsideAlign(cm, errbuf, dsq, L, size_limit, TRUE, cm->nb_omx, cm->nb_mx, &sc)) != eslOK) return status;
	  printf("%4d %-30s %10.4f bits (FULL LENGTH OUTSIDE)", i, "cm_OutsideAlign(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End cm_OutsideAlign*****************************/
	  if((status = cm_Posterior(cm, errbuf, L, size_limit, cm->nb_mx, cm->nb_omx, cm->nb_omx)) != eslOK) return status;
	}

	/* 3. HMM banded truncated alignment, if requested */
	if(esl_opt_GetBoolean(go, "--hb") || esl_opt_GetBoolean(go, "--onlyhb")) {
	  /*********************Begin cm_TrAlignHB()****************************/
	  esl_stopwatch_Start(w);
	  /* Calculate HMM bands. We'll tighten tau and recalculate bands until
	   * the resulting HMM banded matrix is under our size limit.
	   */
	  cm->tau = save_tau;
	  while(1) {
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				   FALSE, /* doing search? */
				   pass_idx, 0)) != eslOK) cm_Fail(errbuf);
	if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, NULL, NULL, &trhbmx_Mb)) != eslOK) return status;
	if(trhbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	printf("TrCYK 0 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	cm->tau *= 2.;
	cm->cp9b->thresh1 *= 2.;
	cm->cp9b->thresh2 -= (1.0-cm->cp9b->thresh2);
	cm->cp9b->thresh1 = ESL_MIN(0.25, cm->cp9b->thresh1);
	cm->cp9b->thresh2 = ESL_MAX(0.25, cm->cp9b->thresh2);
	  }
	  printf("TrCYK 1 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	  esl_stopwatch_Stop(w);
	  printf("%4d %-30s %17s", i, "HMM Band calc:", "");
	  esl_stopwatch_Display(stdout, w, "CPU time: ");

	  /*PrintDPCellsSaved_jd(cm, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, L);*/

	  if(do_optacc) {
	esl_stopwatch_Start(w);
	if((status = cm_TrAlignHB(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, TRUE, FALSE, cm->trhb_mx, cm->trhb_shmx, cm->trhb_omx, cm->trhb_emx, NULL, &ppstr, &tr, &mode, &pp_oa, &sc_oa)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f PP  (mode: %s)  (FULL LENGTH OPTACC)", i, "cm_TrAlignHB(): ", pp_oa, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	mode = ParsetreeMode(tr);
	FreeParsetree(tr);
	free(ppstr); ppstr = NULL;
	printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);
	  }
	  if(do_cyk) {
	esl_stopwatch_Start(w);
	if((status = cm_TrAlignHB(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, FALSE, FALSE, cm->trhb_mx, cm->trhb_shmx, cm->trhb_omx, cm->trhb_emx, NULL,
				  (do_compacc) ? &ppstr : NULL,
				  &tr, &mode, &pp_cyk, &sc_cyk)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f pp %10.4f bits (mode: %s)  (FULL LENGTH CYK)", i, "cm_TrAlignHB(): ", pp_cyk, sc_cyk, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	mode = ParsetreeMode(tr);
	FreeParsetree(tr);
	if(ppstr != NULL) { free(ppstr); ppstr = NULL; }
	printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);
	  }
	  if(do_compacc) {
	if((pp_oa - pp_cyk) < -0.0001) cm_Fail("ERROR OA PP: %f < CYK PP: %f\n", pp_oa, pp_cyk);
	  }
	  /*********************End cm_TrAlignHB*****************************/

	  if(esl_opt_GetBoolean(go, "--cykout")) {
	/*********************Begin cm_TrCYKOutsideAlignHB****************************/
	esl_stopwatch_Start(w);
	status = cm_TrCYKOutsideAlignHB(cm, errbuf, dsq, L, size_limit, mode, pass_idx, TRUE, cm->trhb_omx, cm->trhb_mx);
	if     (status != eslOK && esl_opt_GetBoolean(go, "--failok")) printf("%s\nError detected, but continuing thanks to --failok\n", errbuf);
	else if(status != eslOK)                                       cm_Fail(errbuf);
	printf("%4d %-30s %10s bits ", i, "cm_TrCYKOutsideAlignHB() CYK:", "?");
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End cm_TrCYKOutsideAlignHB****************************/
	  }

	  /*********************Begin cm_TrInsideAlignHB()****************************/
	  esl_stopwatch_Start(w);
	  if((status = cm_TrInsideAlignHB(cm, errbuf, dsq, L, size_limit, TRMODE_UNKNOWN, pass_idx, cm->trhb_mx, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (FULL LENGTH INSIDE)", i, "cm_TrInsideAlignHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End cm_TrInsideAlignHB*****************************/
	}

	/* 4. HMM banded standard alignment, if requested */
	if(esl_opt_GetBoolean(go, "--std") && (esl_opt_GetBoolean(go, "--hb") || esl_opt_GetBoolean(go, "--onlyhb"))) {
	  /*********************Begin cm_AlignHB()***************************/
	  esl_stopwatch_Start(w);
	  while(1) {
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				   FALSE,  /* doing search? */
				   PLI_PASS_STD_ANY,  /* we are not allowing truncated alignments */
				   0)) != eslOK) cm_Fail(errbuf);
	if((status = cm_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, &hbmx_Mb)) != eslOK) return status;
	if(hbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	printf("  CYK 0 tau: %10g  hbmx_Mb: %10.2f\n", cm->tau, hbmx_Mb);
	cm->tau *= 2.;
	  }

	  esl_stopwatch_Stop(w);
	  printf("%4d %-30s %17s", i+1, "HMM Band calc:", "");
	  esl_stopwatch_Display(stdout, w, "CPU time: ");

	  /*PrintDPCellsSaved_jd(cm, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, L);*/

	  if(do_optacc) {
	esl_stopwatch_Start(w);
	if((status = cm_AlignHB(cm, errbuf, dsq, L, size_limit, TRUE, FALSE, cm->hb_mx, cm->hb_shmx, cm->hb_omx, cm->hb_emx, NULL, &ppstr, &tr, &pp_oa, &sc_oa)) != eslOK) cm_Fail(errbuf);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	free(ppstr);
	printf("%4d %-30s %10.4f pp   (FULL LENGTH OPTACC)\n", i, "cm_AlignHB(): ", pp_oa);
	printf("Parsetree score      : %.4f           (FULL LENGTH OPTACC)\n", parsetree_sc);
	  }
	  if(do_cyk) {
	if((status = cm_AlignHB(cm, errbuf, dsq, L, size_limit, FALSE, FALSE, cm->hb_mx, cm->hb_shmx, cm->hb_omx, cm->hb_emx, NULL,
				(do_compacc) ? &ppstr : NULL, &tr, &pp_cyk, &sc_cyk)) != eslOK) cm_Fail(errbuf);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	if(esl_opt_GetBoolean(go, "--tr")) ParsetreeDump(stdout, tr, cm, dsq);
	ParsetreeScore(cm, NULL, NULL, tr, dsq, FALSE, &parsetree_sc, &parsetree_struct_sc, NULL, NULL, NULL);
	FreeParsetree(tr);
	if(ppstr != NULL) { free(ppstr); ppstr = NULL; }
	printf("%4d %-30s %10.4f pp %10.4f bits (FULL LENGTH CYK)\n", i, "cm_AlignHB(): ", pp_cyk, sc_cyk);
	printf("Parsetree score      : %.4f           (FULL LENGTH CYK)\n", parsetree_sc);
	  }
	  if(do_compacc) {
	if((pp_oa - pp_cyk) < -0.0001) cm_Fail("ERROR OA PP: %f < CYK PP: %f\n", pp_oa, pp_cyk);
	  }
	  /*********************End cm_AlignHB()***************************/
	}

	if(esl_opt_GetBoolean(go, "--search")) {
	  /* 5. non-banded truncated search, if requested */
	  /*********************Begin RefTrCYKScan****************************/
	  esl_stopwatch_Start(w);
	  if((status = RefTrCYKScan(cm, errbuf, cm->trsmx, qdbidx, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (mode: %s)", i, "RefTrCYKScan(): ", sc, MarginalMode(mode));
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End RefTrCYKScan****************************/

	  /*********************Begin RefITrInsideScan****************************/
	  cm->search_opts |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = RefITrInsideScan(cm, errbuf, cm->trsmx, qdbidx, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (mode: %s)", i, "RefITrInsideScan(): ", sc, MarginalMode(mode));
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  cm->search_opts &= ~CM_SEARCH_INSIDE;
	  /*********************End RefITrInsideScan****************************/

	  if(esl_opt_GetBoolean(go, "--orig")) {
	/*********************Begin TrCYK_Inside****************************/
	esl_stopwatch_Start(w);
	sc = TrCYK_Inside(cm, dsq, L, 0, 1, L, pass_idx, FALSE, FALSE, NULL);
	printf("%4d %-30s %10.4f bits ", i, "TrCYK_Inside():   ", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End TrCYK_Inside****************************/
	  }

	  /* 6. non-banded standard search, if requested */
	  /*********************Begin FastCYKScan****************************/
	  esl_stopwatch_Start(w);
	  if((status = FastCYKScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastCYKScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End FastCYKScan****************************/

	  /*********************Begin FastIInsideScan****************************/
	  cm->search_opts |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = FastIInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastIInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  cm->search_opts &= ~CM_SEARCH_INSIDE;
	  /*********************End RefITrInsideScan****************************/

	  /* 7. HMM banded truncated search, if requested */
	  if(esl_opt_GetBoolean(go, "--hb") || esl_opt_GetBoolean(go, "--onlyhb")) {
	/*********************Begin TrCYKScanHB****************************/
	esl_stopwatch_Start(w);
	/* Calculate HMM bands. We'll tighten tau and recalculate bands until
	 * the resulting HMM banded matrix is under our size limit.
	 */
	cm->tau = save_tau;
	while(1) {
	  if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				     TRUE,  /* doing search? */
				     pass_idx, 0)) != eslOK) cm_Fail(errbuf);
	  if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, NULL, NULL, &trhbmx_Mb)) != eslOK) return status;
	  if(trhbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	  if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	  printf("TrCYK 0 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	  cm->tau *= 2.;
	  cm->cp9b->thresh1 *= 2.;
	  cm->cp9b->thresh2 -= (1.0-cm->cp9b->thresh2);
	  cm->cp9b->thresh1 = ESL_MIN(0.25, cm->cp9b->thresh1);
	  cm->cp9b->thresh2 = ESL_MAX(0.25, cm->cp9b->thresh2);
	}
	printf("TrCYK 1 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	esl_stopwatch_Stop(w);
	printf("%4d %-30s %17s", i+1, "HMM Band calc:", "");
	esl_stopwatch_Display(stdout, w, "CPU time: ");

	/*PrintDPCellsSaved_jd(cm, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, L);*/

	esl_stopwatch_Start(w);
	if((status = TrCYKScanHB(cm, errbuf, cm->trhb_mx, size_limit, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0.,  NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits (mode: %s)", i, "TrCYKScanHB(): ", sc, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End TrCYKScanHB****************************/

	/*********************Begin FTrInsideScanHB****************************/
	esl_stopwatch_Start(w);
	if((status = FTrInsideScanHB(cm, errbuf, cm->trhb_mx, size_limit, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0.,  NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits (mode: %s)", i, "FTrInsideScanHB(): ", sc, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	/*********************End FTrInsideScanHB***********************/

	/* 8. HMM banded standard search, if requested */
	if(esl_opt_GetBoolean(go, "--std") && (esl_opt_GetBoolean(go, "--hb") || esl_opt_GetBoolean(go, "--onlyhb"))) {
	  /*********************Begin FastCYKScanHB****************************/
	  esl_stopwatch_Start(w);
	  cm->tau = save_tau;
	  while(1) {
	    if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				       TRUE,  /* doing search? */
				       PLI_PASS_STD_ANY,  /* we are not allowing truncated alignments */
				       0)) != eslOK) cm_Fail(errbuf);
	    if((status = cm_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, &hbmx_Mb)) != eslOK) return status;
	    if(hbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	    if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	    printf("  CYK 0 tau: %10g  hbmx_Mb: %10.2f\n", cm->tau, hbmx_Mb);
	    cm->tau *= 2.;
	  }

	  esl_stopwatch_Stop(w);
	  printf("%4d %-30s %17s", i+1, "HMM Band calc:", "");
	  esl_stopwatch_Display(stdout, w, "CPU time: ");

	  /*PrintDPCellsSaved_jd(cm, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, L);*/

	  esl_stopwatch_Start(w);
	  if((status = FastCYKScanHB(cm, errbuf, cm->hb_mx, size_limit, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastCYKScanHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  /*********************End FastCYKScanHB****************************/
	}
	  }
	}
	printf("\n");
	esl_sq_Reuse(sq);
  }
  if(status != eslEOF) cm_Fail("ERROR reading sequence file, sequence number %d\n", i);

  FreeCM(cm);
  esl_sq_Destroy(sq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_getopts_Destroy(go);
  esl_sqfile_Close(sqfp);

  return 0;
}
#endif /*IMPL_TRUNC_ALIGN_BENCHMARK*/

/*** End of inlined file: cm_dpalign_trunc.c ***/


/*** Start of inlined file: cm_dpsearch.c ***/


#include <stdio.h>
#include <stdlib.h>



#define AMX(j,v,d) (alphap[(j * cm->M * (W+1)) + ((v) * (W+1) + d)])

/* Function: FastCYKScan()
 * Date:     EPN, Wed Sep 12 16:55:28 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           an optimized scanning CYK scanning implementation.
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with FastFInsideScan() and FastIInsideScan(),
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FastCYKScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	    int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* score of best hit */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       dp_y;               /* offset d for state y */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int       cnum;               /* number of children for current state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  float    *sc_v;               /* [0..d..W] temporary score vec for each d for current j & v */
  float   **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* Contract check */
  if(! cm->flags & CMH_BITS)               ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                              ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, dsq is NULL\n");
  if(cm->search_opts & CM_SEARCH_INSIDE)   ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, CM_SEARCH_INSIDE flag raised");
  if(smx == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, smx == NULL\n");
  if(! smx->floats_valid)                  ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, smx->floats_valid if FALSE");
  if(cm->qdbinfo == NULL)                  ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, cm->qdbinfo == NULL\n");

  /* make pointers to the ScanMatrix/CM data for convenience */
  float ***alpha      = smx->falpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  float ***alpha_begl = smx->falpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  float **esc_vAA     = cm->oesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeFloats(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* Initialize sc_v to size of M */
  ESL_ALLOC(sc_v, (sizeof(float) * (W+1)));
  esl_vec_FSet(sc_v, (W+1), IMPOSSIBLE);

  /* precalculate the initial scores for all cells */
  init_scAA = FCalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  float const *esc_v = esc_vAA[v];
	  float const *tsc_v = cm->tsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  cnum = cm->cnum[v];
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  float esc_j = IMPOSSIBLE;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      for (k = kmin; k <= kmax; k++)
		sc = ESL_MAX(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ESL_MAX (sc, alpha[jp_y][y+yoffset][d - sd] + cm->tsc[v][yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    float const *arow0;
	    float const *arow1;
	    float const *arow2;
	    float const *arow3;
	    float const *arow4;
	    float const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ESL_MAX(arow2[dp_y] + tsc_v[2],
			     arow1[dp_y] + tsc_v[1]);
		sc = ESL_MAX(sc, init_scAA[v][dp_y]);
		sc = ESL_MAX(sc, arow0[dp_y] + tsc_v[0]);

		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ESL_MAX(arow5[dp_y] + tsc_v[5],
			      init_scAA[v][dp_y]);
		sc = ESL_MAX(sc, arow4[dp_y] + tsc_v[4]);
		sc = ESL_MAX(sc, arow3[dp_y] + tsc_v[3]);
		sc = ESL_MAX(sc, arow2[dp_y] + tsc_v[2]);
		sc = ESL_MAX(sc, arow1[dp_y] + tsc_v[1]);
		sc = ESL_MAX(sc, arow0[dp_y] + tsc_v[0]);

		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ESL_MAX(arow3[dp_y] + tsc_v[3],
			     arow2[dp_y] + tsc_v[2]);
		sc = ESL_MAX(sc, init_scAA[v][dp_y]);
		sc = ESL_MAX(sc, arow1[dp_y] + tsc_v[1]);
		sc = ESL_MAX(sc, arow0[dp_y] + tsc_v[0]);

		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ESL_MAX(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc = ESL_MAX(sc, init_scAA[v][dp_y]);
		sc = ESL_MAX(sc, arow1[dp_y] + tsc_v[1]);
		sc = ESL_MAX(sc, arow2[dp_y] + tsc_v[2]);
		sc = ESL_MAX(sc, arow0[dp_y] + tsc_v[0]);

		switch (emitmode) {
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		  /* MP states can't have 5 children */
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ESL_MAX(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc = ESL_MAX(sc, arow0[dp_y] + tsc_v[0]);
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;
	    } /* end of switch(cnum) */
	    /* for (d = dn; d <= dx; d++)
	       printf("alpha[j:%d][v:%d][d:%d]: %10.4f\n", j, v, d, alpha[jp_v][v][d]); */
	  } /* end of else if (v == IL_st || v == IR_st) */
	  else { /* this else is entered if cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st */
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    float const *arow0;
	    float const *arow1;
	    float const *arow2;
	    float const *arow3;
	    float const *arow4;
	    float const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ESL_MAX(arow2[dp_y] + tsc_v[2],
				  arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ESL_MAX(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ESL_MAX(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ESL_MAX(arow5[dp_y] + tsc_v[5],
				  init_scAA[v][dp_y]);
		sc_v[d] = ESL_MAX(sc_v[d], arow4[dp_y] + tsc_v[4]);
		sc_v[d] = ESL_MAX(sc_v[d], arow3[dp_y] + tsc_v[3]);
		sc_v[d] = ESL_MAX(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ESL_MAX(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ESL_MAX(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ESL_MAX(arow3[dp_y] + tsc_v[3],
				  arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ESL_MAX(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ESL_MAX(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ESL_MAX(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ESL_MAX(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc_v[d] = ESL_MAX(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ESL_MAX(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ESL_MAX(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ESL_MAX(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for (d = dn; d <= dx; d++, dp_y++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ESL_MAX(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc_v[d] = ESL_MAX(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      }
	      break;
	    } /* end of switch(cnum) */
	    /* add in emission score (if any), and set alpha[jp_v][v][d] cell */
	    switch (emitmode) {
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]];
	      }
	      break;
	    case EMITNONE:
	      for (d = dn; d <= dx; d++)
		alpha[jp_v][v][d] = sc_v[d];
	      break;
	    case EMITRIGHT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_j;
	      }
	      break;
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	      }
	      break;
	    } /* end of switch (emitmode) */
	  } /* end of else (cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha[jp_v][v][d]);
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha_begl[jp_v][v][d]);
	  }
	  /* if(cm->stid[v] != BEGL_S)
	     for (d = dn; d <= dx; d++) { printf("alpha[j:%4d][v:%4d][d:%4d]: %.5f\n", j, v, d, alpha[jp_v][v][d]); }*/
	} /*loop over decks v>=0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * -INFTY), which is probably a little too fragile of a method.
	   */

	  float const *tsc_v = cm->tsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	     /* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(IMPOSSIBLE, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++) {
	  alpha[jp_v][0][d] = ESL_MAX (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	}
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S)
	      {
		jp_y = j % (W+1);
		for (d = dn; d <= dx; d++) {
		  /* Is this more efficient:?
		     bestr[d]          = (alpha[jp_v][0][d] > (alpha_begl[jp_y][y][d] + cm->beginsc[y])) ? bestr[d] : y;
		     alpha[jp_v][0][d] = ESL_MAX(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->beginsc[y]); */
		  if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->beginsc[y])) {
		    alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->beginsc[y];
		    bestr[d] = y;
		  }
		}
	      }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		{
		  /* Is this more efficient:?
		     bestr[d]          = (alpha[jp_v][0][d] > (alpha[jp_y][y][d] + cm->beginsc[y])) ? bestr[d] : y;
		     alpha[jp_v][0][d] = ESL_MAX(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->beginsc[y]); */
		  if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->beginsc[y])) {
		    alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->beginsc[y];
		    bestr[d] = y;
		  }
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = alpha[jp_v][0][d];
	vsc_root  = ESL_MAX(vsc_root, alpha[jp_v][0][d]);
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }
	  /*cm_scan_mx_Dump(stdout, cm, j, i0, qdbidx, TRUE);*/
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(sc_v);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;
  ESL_DPRINTF1(("FastCYKScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: RefCYKScan()
 * Date:     EPN, Wed Sep 12 16:55:28 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           a reference scanning CYK implementation. This function
 *           is slower but easier to understand than FastCYKScan().
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with RefIInsideScan() and RefCYKScan()
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
RefCYKScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	   int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  float   **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /*printf("in RefCYKScan() local: %s\n", (cm->flags & CMH_LOCAL_BEGIN) ? "TRUE" : "FALSE");*/

  /* Contract check */
  if(! cm->flags & CMH_BITS)               ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                              ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, dsq is NULL\n");
  if(cm->search_opts & CM_SEARCH_INSIDE)   ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, CM_SEARCH_INSIDE flag raised");
  if(smx == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, smx == NULL\n");
  if(! smx->floats_valid)                  ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, smx->floats_valid if FALSE");
  if(cm->qdbinfo == NULL)                  ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, cm->qdbinfo == NULL\n");

  /* make pointers to the ScanMatrix/CM data for convenience */
  float ***alpha      = smx->falpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  float ***alpha_begl = smx->falpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  float **esc_vAA     = cm->oesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "RefCYKScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeFloats(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* precalculate the initial scores for all cells */
  init_scAA = FCalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  float const *esc_v = esc_vAA[v];
	  float const *tsc_v = cm->tsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  float esc_j = IMPOSSIBLE;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      for (k = kmin; k <= kmax; k++)
		sc = ESL_MAX(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ESL_MAX(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else { /* ! B_st, ! BEGL_S st */
	    y = cm->cfirst[v];
	    i = j - dnA[v] + 1;
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd];
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ESL_MAX(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);

	      switch (emitmode) {
	      case EMITLEFT:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]];
		break;
	      case EMITNONE:
		alpha[jp_v][v][d] = sc;
		break;
	      case EMITRIGHT:
		alpha[jp_v][v][d] = sc + esc_j;
		break;
	      case EMITPAIR:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
		break;
	      } /* end of switch emitmode */
	    } /* end of for d loop */
	  } /* end of else (which was entered if ! B_st && ! BEGL_S st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha[jp_v][v][d]);
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha_begl[jp_v][v][d]);
	  }
	} /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * -INFTY), which is probably a little too fragile of a method.
	   */

	  float const *tsc_v = cm->tsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	/* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(IMPOSSIBLE, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++)
	  alpha[jp_v][0][d] = ESL_MAX (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S)
	      {
		jp_y = j % (W+1);
		for (d = dn; d <= dx; d++) {
		  /* Is this more efficient:?
		     bestr[d]          = (alpha[jp_v][0][d] > (alpha_begl[jp_y][y][d] + cm->beginsc[y])) ? bestr[d] : y;
		     alpha[jp_v][0][d] = ESL_MAX(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->beginsc[y]); */
		  if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->beginsc[y])) {
		    alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->beginsc[y];
		    bestr[d] = y;
		  }
		}
	      }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		{
		  /* Is this more efficient:?
		     bestr[d]          = (alpha[jp_v][0][d] > (alpha[jp_y][y][d] + cm->beginsc[y])) ? bestr[d] : y;
		     alpha[jp_v][0][d] = ESL_MAX(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->beginsc[y]); */
		  if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->beginsc[y])) {
		    alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->beginsc[y];
		    bestr[d] = y;
		  }
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = alpha[jp_v][0][d];
	vsc_root  = ESL_MAX(vsc_root, alpha[jp_v][0][d]);
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }

	  /* cm_DumpScanMatrixAlpha(cm, si, j, i0, TRUE); */
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc         = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;

  ESL_DPRINTF1(("RefCYKScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: FastIInsideScan()
 * Date:     EPN, Tue Nov  6 05:42:44 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           an optimized scanning Inside implementation that uses
 *           integer scores.
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with FastCYKScan() and FastFInsideScan(),
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FastIInsideScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
		int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       dp_y;               /* offset d for state y */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int       cnum;               /* number of children for current state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  int      *sc_v;               /* [0..d..W] temporary score vec for each d for current j & v */
  int     **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /*printf("in FastIInsideScan() local: %s\n", (cm->flags & CMH_LOCAL_BEGIN) ? "TRUE" : "FALSE");*/

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, dsq is NULL\n");
  if(! (cm->search_opts & CM_SEARCH_INSIDE)) ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, CM_SEARCH_INSIDE flag not raised");
  if(smx == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, smx == NULL\n");
  if(! smx->ints_valid)                      ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, smx->ints_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  int   ***alpha      = smx->ialpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  int   ***alpha_begl = smx->ialpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  int   **esc_vAA     = cm->ioesc;          /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "FastIInsideScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeIntegers(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* Initialize sc_v to size of M */
  ESL_ALLOC(sc_v, (sizeof(float) * (W+1)));
  esl_vec_ISet(sc_v, (W+1), -INFTY);

  /* precalculate the initial scores for all cells */
  init_scAA = ICalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  int sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);
	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }
	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  int const *esc_v = esc_vAA[v];
	  int const *tsc_v = cm->itsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  cnum = cm->cnum[v];
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  int esc_j = -INFTY;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B st */
	      for (k = kmin; k <= kmax; k++)
		sc = ILogsum(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ILogsum (sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    int const *arow0;
	    int const *arow1;
	    int const *arow2;
	    int const *arow3;
	    int const *arow4;
	    int const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ILogsum(arow2[dp_y] + tsc_v[2],
			     arow1[dp_y] + tsc_v[1]);
		sc = ILogsum(sc, init_scAA[v][dp_y]);
		sc = ILogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ILogsum(arow5[dp_y] + tsc_v[5],
			     init_scAA[v][dp_y]);
		sc = ILogsum(sc, arow4[dp_y] + tsc_v[4]);
		sc = ILogsum(sc, arow3[dp_y] + tsc_v[3]);
		sc = ILogsum(sc, arow2[dp_y] + tsc_v[2]);
		sc = ILogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = ILogsum(sc, arow0[dp_y] + tsc_v[0]);
		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ILogsum(arow3[dp_y] + tsc_v[3],
			     arow2[dp_y] + tsc_v[2]);
		sc = ILogsum(sc, init_scAA[v][dp_y]);
		sc = ILogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = ILogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ILogsum(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc = ILogsum(sc, init_scAA[v][dp_y]);
		sc = ILogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = ILogsum(sc, arow2[dp_y] + tsc_v[2]);
		sc = ILogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		  /* MP states can't have 5 children */
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = ILogsum(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc = ILogsum(sc, arow0[dp_y] + tsc_v[0]);
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;
	    } /* end of switch(cnum) */
	    /* for (d = dn; d <= dx; d++)
	       printf("alpha[j:%d][v:%d][d:%d]: %10.4f\n", j, v, d, alpha[jp_v][v][d]); */
	  } /* end of else if (v == IL_st || v == IR_st) */
	  else { /* this else is entered if cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st */
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    int const *arow0;
	    int const *arow1;
	    int const *arow2;
	    int const *arow3;
	    int const *arow4;
	    int const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ILogsum(arow2[dp_y] + tsc_v[2],
			     arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ILogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ILogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ILogsum(arow5[dp_y] + tsc_v[5],
			      init_scAA[v][dp_y]);
		sc_v[d] = ILogsum(sc_v[d], arow4[dp_y] + tsc_v[4]);
		sc_v[d] = ILogsum(sc_v[d], arow3[dp_y] + tsc_v[3]);
		sc_v[d] = ILogsum(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ILogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ILogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ILogsum(arow3[dp_y] + tsc_v[3],
			     arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ILogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ILogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ILogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ILogsum(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc_v[d] = ILogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = ILogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = ILogsum(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = ILogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for (d = dn; d <= dx; d++, dp_y++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = ILogsum(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc_v[d] = ILogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      }
	      break;
	    } /* end of switch(cnum) */
	    /* add in emission score (if any), and set alpha[jp_v][v][d] cell */
	    switch (emitmode) {
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]];
	      }
	      break;
	    case EMITNONE:
	      for (d = dn; d <= dx; d++)
		alpha[jp_v][v][d] = sc_v[d];
	      break;
	    case EMITRIGHT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_j;
	      }
	      break;
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	      }
	      break;
	    } /* end of switch (emitmode) */
	  } /* end of else (cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], Scorify(alpha[jp_v][v][d]));
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], Scorify(alpha_begl[jp_v][v][d]));
	  }
	  /*if(cm->stid[v] != BEGL_S)
	    for (d = dn; d <= dx; d++) { printf("alpha[j:%4d][v:%4d][d:%4d]: %.5f\n", j, v, d, alpha[jp_v][v][d]); }*/
	} /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * -INFTY), which is probably a little too fragile of a method.
	   */

	  int const *tsc_v = cm->itsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  /* determine min/max d we're allowing for the root state and this position j */
	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	/* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(-INFTY, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++)
	  alpha[jp_v][0][d] = ILogsum (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(cm->ibeginsc[y] != -INFTY) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S) {
	      jp_y = jp_wA[0];
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = ILogsum(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->ibeginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->ibeginsc[y])) {
		  alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->ibeginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = ILogsum(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->ibeginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->ibeginsc[y])) {
		  alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->ibeginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = Scorify(alpha[jp_v][0][d]);
	vsc_root  = ESL_MAX(vsc_root, Scorify(alpha[jp_v][0][d]));
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }
	  /* cm_scan_mx_Dump(stdout, cm, j, i0, qdbidx, FALSE); */
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(sc_v);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;

  ESL_DPRINTF1(("FastIInsideScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: FastFInsideScan()
 * Date:     EPN, Wed Sep 12 16:55:28 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           an optimized scanning Inside implementation that uses
 *           float scores.
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with FastCYKScan() and FastIInsideScan(),
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FastFInsideScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
		int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       dp_y;               /* offset d for state y */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int       cnum;               /* number of children for current state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  float    *sc_v;               /* [0..d..W] temporary score vec for each d for current j & v */
  float   **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /*printf("in FastFInsideScan() local: %s\n", (cm->flags & CMH_LOCAL_BEGIN) ? "TRUE" : "FALSE");*/

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, dsq is NULL\n");
  if(! (cm->search_opts & CM_SEARCH_INSIDE)) ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, CM_SEARCH_INSIDE flag not raised");
  if(smx == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, smx == NULL\n");
  if(! smx->ints_valid)                      ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, smx->ints_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  float ***alpha      = smx->falpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  float ***alpha_begl = smx->falpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  float **esc_vAA     = cm->oesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeFloats(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* Initialize sc_v to size of M */
  ESL_ALLOC(sc_v, (sizeof(float) * (W+1)));
  esl_vec_FSet(sc_v, (W+1), IMPOSSIBLE);

  /* precalculate the initial scores for all cells */
  init_scAA = FCalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  float const *esc_v = esc_vAA[v];
	  float const *tsc_v = cm->tsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  cnum = cm->cnum[v];
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  float esc_j = IMPOSSIBLE;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      for (k = kmin; k <= kmax; k++)
		sc = FLogsum(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = FLogsum (sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    float const *arow0;
	    float const *arow1;
	    float const *arow2;
	    float const *arow3;
	    float const *arow4;
	    float const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = FLogsum(arow2[dp_y] + tsc_v[2],
			     arow1[dp_y] + tsc_v[1]);
		sc = FLogsum(sc, init_scAA[v][dp_y]);
		sc = FLogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = FLogsum(arow5[dp_y] + tsc_v[5],
			      init_scAA[v][dp_y]);
		sc = FLogsum(sc, arow4[dp_y] + tsc_v[4]);
		sc = FLogsum(sc, arow3[dp_y] + tsc_v[3]);
		sc = FLogsum(sc, arow2[dp_y] + tsc_v[2]);
		sc = FLogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = FLogsum(sc, arow0[dp_y] + tsc_v[0]);
		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = FLogsum(arow3[dp_y] + tsc_v[3],
			     arow2[dp_y] + tsc_v[2]);
		sc = FLogsum(sc, init_scAA[v][dp_y]);
		sc = FLogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = FLogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = FLogsum(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc = FLogsum(sc, init_scAA[v][dp_y]);
		sc = FLogsum(sc, arow1[dp_y] + tsc_v[1]);
		sc = FLogsum(sc, arow2[dp_y] + tsc_v[2]);
		sc = FLogsum(sc, arow0[dp_y] + tsc_v[0]);

		/* add in emission score, if any */
		switch (emitmode) {
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		  /* MP states can't have 5 children */
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc = FLogsum(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc = FLogsum(sc, arow0[dp_y] + tsc_v[0]);
		switch (emitmode) {
		case EMITLEFT:
		  sc += esc_v[dsq[i--]];
		  break;
		case EMITRIGHT:
		  sc += esc_j;
		  break;
		} /* end of switch (cm->sttype[v]) */
		alpha[jp_v][v][d] = sc;
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;
	    } /* end of switch(cnum) */
	    /* for (d = dn; d <= dx; d++)
	       printf("alpha[j:%d][v:%d][d:%d]: %10.4f\n", j, v, d, alpha[jp_v][v][d]); */
	  } /* end of else if (v == IL_st || v == IR_st) */
	  else { /* this else is entered if cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st */
	    y    = cm->cfirst[v];
	    dp_y = dn - sd; /* initial dp_y, we increment it at end of 'for(d = ...' loop */
	    i    = j-dn+1;  /* initial i,    we decrement it when we access it, inside each possible case of the switch (cnum) below */

	    float const *arow0;
	    float const *arow1;
	    float const *arow2;
	    float const *arow3;
	    float const *arow4;
	    float const *arow5;

	    /* Note: order of cnum cases in switch and cases in each
	     * nested emitmode switch is based on empirical
	     * frequency in large test set, more frequent guys come
	     * earlier, so average num calcs in each switch is
	     * minimized.
	     */

	    switch (cnum) {
	    case 3:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = FLogsum(arow2[dp_y] + tsc_v[2],
			     arow1[dp_y] + tsc_v[1]);
		sc_v[d] = FLogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = FLogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 6:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      arow5 = alpha[jp_y][y+5];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = FLogsum(arow5[dp_y] + tsc_v[5],
			      init_scAA[v][dp_y]);
		sc_v[d] = FLogsum(sc_v[d], arow4[dp_y] + tsc_v[4]);
		sc_v[d] = FLogsum(sc_v[d], arow3[dp_y] + tsc_v[3]);
		sc_v[d] = FLogsum(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = FLogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = FLogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 4:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = FLogsum(arow3[dp_y] + tsc_v[3],
			     arow2[dp_y] + tsc_v[2]);
		sc_v[d] = FLogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = FLogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = FLogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for(d = dn; d <= dx; d++) */
	      break;

	    case 5:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      arow2 = alpha[jp_y][y+2];
	      arow3 = alpha[jp_y][y+3];
	      arow4 = alpha[jp_y][y+4];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = FLogsum(arow4[dp_y] + tsc_v[4],
			     arow3[dp_y] + tsc_v[3]);
		sc_v[d] = FLogsum(sc_v[d], init_scAA[v][dp_y]);
		sc_v[d] = FLogsum(sc_v[d], arow1[dp_y] + tsc_v[1]);
		sc_v[d] = FLogsum(sc_v[d], arow2[dp_y] + tsc_v[2]);
		sc_v[d] = FLogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      } /* end of for (d = dn; d <= dx; d++, dp_y++) */
	      break;

	    case 2:
	      arow0 = alpha[jp_y][y];
	      arow1 = alpha[jp_y][y+1];
	      for (d = dn; d <= dx; d++, dp_y++) {
		sc_v[d] = FLogsum(arow1[dp_y] + tsc_v[1],
			     init_scAA[v][dp_y]);
		sc_v[d] = FLogsum(sc_v[d], arow0[dp_y] + tsc_v[0]);
	      }
	      break;
	    } /* end of switch(cnum) */
	    /* add in emission score (if any), and set alpha[jp_v][v][d] cell */
	    switch (emitmode) {
	    case EMITLEFT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]];
	      }
	      break;
	    case EMITNONE:
	      for (d = dn; d <= dx; d++)
		alpha[jp_v][v][d] = sc_v[d];
	      break;
	    case EMITRIGHT:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_j;
	      }
	      break;
	    case EMITPAIR:
	      for (d = dn; d <= dx; d++) {
		alpha[jp_v][v][d] = sc_v[d] + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	      }
	      break;
	    } /* end of switch (emitmode) */
	  } /* end of else (cm->sttype[v] != B_st && cm->stid[v] !=  BEGL_S st && cm->sttype[v] != IL_st && cm->sttype[v] != IR_st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha[jp_v][v][d]);
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha_begl[jp_v][v][d]);
	  }
	  /*if(cm->stid[v] != BEGL_S)
	     for (d = dn; d <= dx; d++) { printf("alpha[j:%4d][v:%4d][d:%4d]: %.5f\n", j, v, d, alpha[jp_v][v][d]); }*/
	} /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * -INFTY), which is probably a little too fragile of a method.
	   */

	  float const *tsc_v = cm->tsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  /* determine min/max d we're allowing for the root state and this position j */
	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	/* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(IMPOSSIBLE, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++)
	  alpha[jp_v][0][d] = FLogsum (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S) {
	      jp_y = jp_wA[0];
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = ILogsum(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->beginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->beginsc[y])) {
		  alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->beginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = FLogsum(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->beginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->beginsc[y])) {
		  alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->beginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = alpha[jp_v][0][d];
	vsc_root  = ESL_MAX(vsc_root, alpha[jp_v][0][d]);
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }
	  /*FILE *fp; fp = fopen("tmp.ffins.smx", "w"); cm_scan_mx_Dump(fp, cm, j, i0, qdbidx, TRUE); fclose(fp); */
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(sc_v);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;

  ESL_DPRINTF1(("FastFInsideScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEINCOMPAT, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: RefIInsideScan()
 * Date:     EPN, Tue Nov  6 06:13:35 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           a reference scanning Inside that uses integer scores.
 *           This function is slower but easier to understand than
 *           FastIInsideScan().
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with RefCYKScan() and RefFInsideScan(),
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
RefIInsideScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	       int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  int     **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /*printf("in RefIInsideScan() local: %s\n", (cm->flags & CMH_LOCAL_BEGIN) ? "TRUE" : "FALSE");*/

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, dsq is NULL\n");
  if(! (cm->search_opts & CM_SEARCH_INSIDE)) ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, CM_SEARCH_INSIDE flag not raised");
  if(smx == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, smx == NULL\n");
  if(! smx->ints_valid)                      ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, smx->ints_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  int   ***alpha      = smx->ialpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  int   ***alpha_begl = smx->ialpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  int   **esc_vAA     = cm->ioesc;          /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "RefIInsideScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeIntegers(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* precalculate the initial scores for all cells */
  init_scAA = ICalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  int sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  int const *esc_v = esc_vAA[v];
	  int const *tsc_v = cm->itsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  int esc_j = -INFTY;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      for (k = kmin; k <= kmax; k++)
		sc = ILogsum(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ILogsum(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else { /* ! B_st, ! BEGL_S st */
	    y = cm->cfirst[v];
	    i = j - dnA[v] + 1;
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd];
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = ILogsum(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);

	      switch (emitmode) {
	      case EMITLEFT:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]];
		break;
	      case EMITNONE:
		alpha[jp_v][v][d] = sc;
		break;
	      case EMITRIGHT:
		alpha[jp_v][v][d] = sc + esc_j;
		break;
	      case EMITPAIR:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
		break;
	      } /* end of switch emitmode */
	    } /* end of for d loop */
	  } /* end of else (which was entered if ! B_st && ! BEGL_S st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], Scorify(alpha[jp_v][v][d]));
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], Scorify(alpha_begl[jp_v][v][d]));
	  }
	} /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * -INFTY), which is probably a little too fragile of a method.
	   */

	  int const *tsc_v = cm->itsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  /* determine min/max d we're allowing for the root state and this position j */
	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	/* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(-INFTY, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++)
	  alpha[jp_v][0][d] = ILogsum (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(cm->ibeginsc[y] != -INFTY) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S) {
	      jp_y = j % (W+1);
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = ILogsum(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->ibeginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->ibeginsc[y])) {
		  alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->ibeginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = ILogsum(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->ibeginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->ibeginsc[y])) {
		  alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->ibeginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = Scorify(alpha[jp_v][0][d]);
	vsc_root  = ESL_MAX(vsc_root, Scorify(alpha[jp_v][0][d]));
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }

	  /* cm_DumpScanMatrixAlpha(cm, si, j, i0, FALSE);*/
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;

  ESL_DPRINTF1(("RefIInsideScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: RefFInsideScan()
 * Date:     EPN, Sun Nov  4 16:02:17 2007
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           a reference scanning Inside that uses integer scores.
 *           This function is slower but easier to understand than
 *           FastIInsideScan().
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <smx>.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           smx             - CM_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           hitlist         - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_sc          - RETURN: score of best overall hit (vsc[0])
 *
 * Note:     This function is heavily synchronized with RefCYKScan() and RefFInsideScan(),
 *           any change to this function should be mirrored in those functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
RefFInsideScan(CM_t *cm, char *errbuf, CM_SCAN_MX *smx, int qdbidx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	       int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, smx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn,   dx;           /* minimum/maximum valid d for current state */
  int       dn_y, dx_y;         /* minimum/maximum valid d for state y */
  int       dn_w, dx_w;         /* minimum/maximum valid d for state w */
  int      *dmin;               /* [0..v..cm->M-1] minimum d allowed for this state */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  float   **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /*printf("in RefFInsideScan() local: %s\n", (cm->flags & CMH_LOCAL_BEGIN) ? "TRUE" : "FALSE");*/

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, dsq is NULL\n");
  if(! (cm->search_opts & CM_SEARCH_INSIDE)) ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, CM_SEARCH_INSIDE flag not raised");
  if(smx == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, smx == NULL\n");
  if(! smx->floats_valid)                    ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, smx->floats_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  float ***alpha      = smx->falpha;        /* [0..j..1][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v == BEGL_S */
  float ***alpha_begl = smx->falpha_begl;   /* [0..j..W][0..v..cm->M-1][0..d..W] alpha DP matrix, NULL for v != BEGL_S */
  int   **dnAA        = smx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA        = smx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  float  *bestsc      = smx->bestsc;        /* [0..d..W] best score for this d, recalc'ed for each j endpoint  */
  int    *bestr       = smx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d, recalc'ed for each j endpoint */
  float **esc_vAA     = cm->oesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
					     * and all possible emissions a (including ambiguities) */

  /* Determine if we're doing banded/non-banded and get pointers to
   * dmin/dmax. (We only need dmin/dmax so we can compute kmin/kmax
   * for B states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmin = NULL;               dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin1; dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmin = cm->qdbinfo->dmin2; dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "RefFInsideScan, qdbidx is invalid");

  L = j0-i0+1;
  W = smx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_scan_mx_InitializeFloats(cm, smx, errbuf)) != eslOK) return status;

  /* set vsc array */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* precalculate the initial scores for all cells */
  init_scAA = FCalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float sc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  float const *esc_v = esc_vAA[v];
	  float const *tsc_v = cm->tsc[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  sd   = StateDelta(cm->sttype[v]);
	  dn   = dnA[v];
	  dx   = dxA[v];
	  /* if we emit right, precalc score of emitting res j from state v */
	  float esc_j = IMPOSSIBLE;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	    esc_j = esc_v[dsq[j]];

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dn_y = ESL_MIN(dmin[y], smx->W);
		dx_y = ESL_MIN(dmax[y], smx->W);
		dn_w = ESL_MIN(dmin[w], smx->W);
		dx_w = ESL_MIN(dmax[w], smx->W);
		kmin = ESL_MAX(0, ESL_MAX(dn_y, d-dx_w));
		kmax = ESL_MIN(dx_y, d-dn_w);
	      }
	      else { kmin = 0; kmax = d; }

	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      for (k = kmin; k <= kmax; k++)
		sc = FLogsum(sc, (alpha_begl[jp_wA[k]][w][d-k] + alpha[jp_y][y][k]));
	      alpha[jp_v][v][d] = sc;
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = FLogsum(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      alpha_begl[jp_v][v][d] = sc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else { /* ! B_st, ! BEGL_S st */
	    y = cm->cfirst[v];
	    i = j - dnA[v] + 1;
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      sc = init_scAA[v][d-sd];
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		sc = FLogsum(sc, alpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);

	      switch (emitmode) {
	      case EMITLEFT:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]];
		break;
	      case EMITNONE:
		alpha[jp_v][v][d] = sc;
		break;
	      case EMITRIGHT:
		alpha[jp_v][v][d] = sc + esc_j;
		break;
	      case EMITPAIR:
		alpha[jp_v][v][d] = sc + esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
		break;
	      } /* end of switch emitmode */
	    } /* end of for d loop */
	  } /* end of else (which was entered if ! B_st && ! BEGL_S st) */
	  if(vsc != NULL) {
	    if(cm->stid[v] != BEGL_S) for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha[jp_v][v][d]);
	    else                      for (d = dn; d <= dx; d++) vsc[v] = ESL_MAX(vsc[v], alpha_begl[jp_v][v][d]);
	  }
	} /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/ local begins.
	   *
	   * If local begins are off, the hit must be rooted at v=0.
	   * With local begins on, the hit is rooted at the second state in
	   * the traceback (e.g. after 0), the internal entry point. Divide & conquer
	   * can only handle this if it's a non-insert state; this is guaranteed
	   * by the way local alignment is parameterized (other transitions are
	   * IMPOSSIBLE), which is probably a little too fragile of a method.
	   */

	  float const *tsc_v = cm->tsc[0];
	  esl_vec_ISet(bestr,  (W+1), -1);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);

	  /* determine min/max d we're allowing for the root state and this position j */
	  jp_v = cur;
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestr[d] = 0;	/* root of the traceback = root state 0 */
	y = cm->cfirst[0];
	alpha[jp_v][0][d] = ESL_MAX(IMPOSSIBLE, alpha[cur][y][d] + tsc_v[0]);
	for (yoffset = 1; yoffset < cm->cnum[0]; yoffset++)
	  alpha[jp_v][0][d] = FLogsum (alpha[jp_v][0][d], (alpha[cur][y+yoffset][d] + tsc_v[yoffset]));
	  }

	  if (cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    dn = ESL_MAX(dnA[0], dnA[y]);
	    dx = ESL_MIN(dxA[0], dxA[y]);
	    if(cm->stid[y] == BEGL_S) {
	      jp_y = j % (W+1);
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = FLogsum(alpha[jp_v][0][d], alpha_begl[jp_y][y][d] + cm->beginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha_begl[jp_y][y][d] + cm->beginsc[y])) {
		  alpha[jp_v][0][d] = alpha_begl[jp_y][y][d] + cm->beginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	    else { /* y != BEGL_S */
	      jp_y = cur;
	      for (d = dn; d <= dx; d++) {
		/*alpha[jp_v][0][d] = FLogsum(alpha[jp_v][0][d], alpha[jp_y][y][d] + cm->beginsc[y]);*/
		if(alpha[jp_v][0][d] < (alpha[jp_y][y][d] + cm->beginsc[y])) {
		  alpha[jp_v][0][d] = alpha[jp_y][y][d] + cm->beginsc[y];
		  bestr[d] = y;
		}
	      }
	    }
	  }
	}
	  }
	  /* fill in bestsc for all valid d values, and update vsc_root (best overall score) */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	bestsc[d] = alpha[jp_v][0][d];
	vsc_root  = ESL_MAX(vsc_root, alpha[jp_v][0][d]);
	/* Note: currently we NOT do a null3 correction for vsc_root */
	  }

	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(alpha[jp_v][0][d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, dnA[0], dxA[0], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }
	  /*FILE *fp; fp = fopen("tmp.rfins.smx", "w"); cm_scan_mx_Dump(fp, cm, j, i0, qdbidx, TRUE); fclose(fp); */
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else free(vsc);
  if (ret_sc != NULL) *ret_sc = vsc_root;

  ESL_DPRINTF1(("RefFInsideScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: cm_CountSearchDPCalcs()
 * Date:     EPN, Tue Oct 30 14:48:00 2007
 *
 * Purpose:  Determine the number of millions of DP calcs needed to scan a seq of length <L>
 *           for the subtree rooted at each state, either using bands <dmin> and <dmax>,
 *           or not (if <dmin> == <dmax> == NULL).
 *           <ret_vcalcs[0]> = number of dp calcs for entire model.
 *
 * Args:     cm        - the covariance model
 *           errbuf    - char buffer for error messages
 *           L         - length of the sequence to search
 *           dmin      - minimum bound on d for state v; 0..M
 *           dmax      - maximum bound on d for state v; 0..M
 *           W         - max d: max size of a hit
 *           correct_for_first_W - TRUE: to only count search for j=W+1..L because first W residues require
 *                                       fewer DP calcs b/c d <= j for all j.
 *           ret_vcalcs- RETURN: [0..v..M-1] number of Millions of DP calcs per residue for scanning with sub-CM at v
 *           ret_calcs - RETURN: number of Millions of calcs per residue to search L residues with full model (ret_vcalcs[0]).
 *
 * Returns:  eslOK
 */
int
cm_CountSearchDPCalcs(CM_t *cm, char *errbuf, int L, int *dmin, int *dmax, int W, int correct_for_first_W, float **ret_vcalcs, float *ret_calcs)
{
  int       status;
  float    *vcalcs;             /* [0..v..cm->M-1] # of millions of calcs for subtree rooted at v */
  int       d;			/* a subsequence length, 0..W */
  int       j;                  /* seq index */
  int       v, w, y;            /* state indices */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       dn;                 /* temporary value for min d in for loops */
  int       dx;                 /* temporary value for max d in for loops */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int       jfirst;             /* first j to consider (1 unless correct_for_first_W) */
  int       Leff;               /* effective L, this is L unless correct_for_first_W  */

  if ((W > L) && (correct_for_first_W)) ESL_FAIL(eslFAIL, errbuf, "gross misuse of cm_CountSearchDPCalcs(), W: %d > L: %d and correct_for_first_W is TRUE.\n", W, L);

  if(dmin != NULL && dmax != NULL) do_banded = TRUE;
  if (W > L) W = L;

  ESL_ALLOC(vcalcs, sizeof(float) * cm->M);
  esl_vec_FSet(vcalcs, cm->M, 0.);

  /* we ignore initialization and band imposition, a little imprecise */
  /* Recursion. */
  Leff   = correct_for_first_W ? (L-W): L;
  jfirst = correct_for_first_W ? (W+1) : 1;
  for (j = jfirst; j <= L; j++) {
	for (v = cm->M-1; v > 0; v--) { /* ...almost to ROOT; we handle ROOT specially... */
	  if(do_banded) {
	dn = (cm->sttype[v] == MP_st) ? ESL_MAX(dmin[v], 2) : ESL_MAX(dmin[v], 1);
	dx = ESL_MIN(j, dmax[v]);
	dx = ESL_MIN(dx, W);
	  }
	  else {
	dn = (cm->sttype[v] == MP_st) ? 2 : 1;
	dx = ESL_MIN(j, W);
	  }
	  if(cm->sttype[v] == E_st) continue;

	  if(cm->sttype[v] == B_st) {
	w = cm->cfirst[v]; /* BEGL_S */
	y = cm->cnum[v];   /* BEGR_S */
	for (d = dn; d <= dx; d++) {
	  if(do_banded) {
	    kmin = ESL_MAX(dmin[y], (d-dmax[w]));
	    kmin = ESL_MAX(kmin, 0);
	    kmax = ESL_MIN(dmax[y], (d-dmin[w]));
	  }
	  else { kmin = 0; kmax = d; }
	  if(kmax >= kmin) vcalcs[v] += ((float) ((1+(kmax-kmin+1)))) / 1000000.; /* initial '1 +' is for initialization calc */
	} /* ! B_st */
	  }
	  else if(dx >= dn) { /* if cm->sttype[v] != B_st */
	vcalcs[v] += ((float) (1 + (cm->cnum[v]+1) * (dx-dn+1))) / 1000000.; /* 1 is for initialization calc */
	if(StateDelta(cm->sttype[v]) > 0) vcalcs[v] += ((float) (dx-dn+1)) / 1000000.;
	  } /* end of else (v != B_st) */
	} /*loop over decks v>0 */

	/* determine min/max d we're allowing for the root state and this position j */
	if(do_banded) {
	  dn = ESL_MAX(dmin[0], 1);
	  dx = ESL_MIN(j, dmax[0]);
	  dx = ESL_MIN(dx, W);
	}
	else {
	  dn = 1;
	  dx = ESL_MIN(j, W);
	}
	if(dx >= dn) vcalcs[0] += ((float) ((cm->cnum[0]+1) * (dx-dn+1))) / 1000000.;

	if (cm->flags & CMH_LOCAL_BEGIN) {
	  for (y = 1; y < cm->M; y++) {
	if(do_banded) {
	  dn = (cm->sttype[y] == MP_st) ? ESL_MAX(dmin[y], 2) : ESL_MAX(dmin[y], 1);
	  dn = ESL_MAX(dn, dmin[y]);
	  dx = ESL_MIN(j, dmax[y]);
	  dx = ESL_MIN(dx, W);
	}
	else {
	  dn = 1;
	  dx = ESL_MIN(j, W);
	}
	if((dx >= dn) && (NOT_IMPOSSIBLE(cm->beginsc[y]))) vcalcs[0] += ((float) (dx - dn + 1)) / 1000000.;
	  }
	}
  } /* end loop over end positions j */

  /* sum up the megacells for all states under each v */
  for (v = cm->M-1; v >= 0; v--) {
	if     (cm->sttype[v] == B_st) vcalcs[v] += vcalcs[cm->cnum[v]] + vcalcs[cm->cfirst[v]];
	else if(cm->sttype[v] != E_st) vcalcs[v] += vcalcs[v+1];
  }
  /* convert to per residue */
  for (v = cm->M-1; v >= 0; v--) vcalcs[v] /= Leff;

  ESL_DPRINTF1(("cm_CountSearchDPCalcs(), vcalcs[0]: %f\n", vcalcs[0]));
  /* for (v = cm->M-1; v >= 0; v--) printf("vcalcs[%4d]: %.3f\n", v, vcalcs[v]); */

  if(ret_calcs != NULL)  *ret_calcs  = vcalcs[0];
  if(ret_vcalcs != NULL) *ret_vcalcs = vcalcs;
  else free(vcalcs);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_CountSearchDPCalcs(): memory error.");
  return status; /* NEVERREACHED */
}

/* Function: FastCYKScanHB()
 * Incept:   EPN, Mon Nov 12 17:45:57 2007
 *
 * Purpose:  An HMM banded scanning CYK implementation. Takes a
 *           CM_HB_MX data structure which is indexed [v][j][d] with
 *           only cells within the bands allocated (different than
 *           other (non-HB) scanning function's convention of
 *           [j][v][d]). QDBs are not used.
 *
 * Args:     cm        - the model    [0..M-1]
 *           errbuf    - char buffer for reporting errors
 *           mx        - the HMM banded dp matrix, usually cm->hbmx.
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           dsq       - the sequence [1..L]
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           cutoff    - minimum score to report
 *           hitlist   - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3  - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff- ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi  - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj  - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_sc    - RETURN: score of best overall hit (vsc[0])
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEINCONCEIVABLE if bands allow a hit > L, errbuf filled.
 *           eslERANGE if required HMM banded matrix size exceeds <size_limit>, errbuf filled.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FastCYKScanHB(CM_t *cm, char *errbuf, CM_HB_MX *mx, float size_limit, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	      int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float *ret_sc)
{

  int      status;
  GammaHitMx_t *gamma = NULL;  /* semi-HMM for hit resoultion */
  int     *bestr;       /* best root state for d at current j */
  float   *bestsc;      /* best score for d at current j */
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;      /* [0..d..W-1] probability of local end emissions of length d */
  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      sd;                 /* StateDelta(cm->sttype[v]) */
  int      sdr;                /* StateRightDelta(cm->sttype[v] */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y;         /* d index for state v/y in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp;                 /* ESL_MAX(d-sd, 0) */
  int      dp_y_sd;            /* dp_y - sd */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  float    vsc_root = IMPOSSIBLE; /* score of best hit */
  int      W;                  /* max d over all hdmax[v][j] for all valid v, j */
  double **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int      jp;                 /* j index in act */
  int      do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t  envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* Contract check */
  if(dsq == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScanHB(), dsq is NULL.\n");
  if (mx == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScanHB(), mx is NULL.\n");
  if (cm->cp9b == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "FastCYKScanHB(), cm->cp9b is NULL.\n");

  ESL_DPRINTF1(("cm->search_opts & CM_SEARCH_HMMALNBANDS: %d\n", cm->search_opts & CM_SEARCH_HMMALNBANDS));

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;
  /* the DP matrix */
  float ***alpha = mx->dp; /* pointer to the alpha DP matrix */

  /* Allocations and initializations  */
  /* grow the matrix based on the current sequence and bands */
  if((status = cm_hb_mx_GrowTo(cm, mx, errbuf, cp9b, (j0-i0+1), size_limit)) != eslOK) return status;

  /* set W as j0-i0+1 (this may exceed max size of a hit our bands will allow,
   * but that's okay b/c W is only used for sizing of act, bestr, bestsc vectors */
  W = j0-i0+1;
  /* make sure our bands won't allow a hit bigger than W (this could be modified to only execute in debugging mode) */
  for(j = jmin[0]; j <= jmax[0]; j++) {
	if(W < (hdmax[0][(j-jmin[0])])) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "FastCYKScanHB(), band allows a hit (j:%d hdmax[0][j]:%d) greater than j0-i0+1 (%" PRId64 "d)", j, hdmax[0][(j-jmin[0])], j0-i0+1);
  }

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (W+1));
  for(d = 0; d <= W; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(alpha[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(j0-i0+1, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
	/* pre-fill act, different than non-HMM banded scanner b/c our main loop doesn't step j through residues */
	for(j = i0; j <= j0; j++) {
	  jp = j-i0+1; /* j is actual index in dsq, jp is offset j relative to start i0 (j index for act) */
	  esl_vec_DCopy(act[(jp-1)%(W+1)], cm->abc->K, act[jp%(W+1)]);
	  esl_abc_DCount(cm->abc, act[jp%(W+1)], dsq[j], 1.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) { /* all the way down to root, different from other scanners */
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	jn   = jmin[v];
	jx   = jmax[v];

	/* re-initialize the deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0, d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; dp_v++, d++) {
	  dp = ESL_MAX(d-sd, 0);
	  alpha[v][jp_v][dp_v] = el_scA[dp] + cm->endsc[v];
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	alpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in beta[v] are independent of each other, only depending on beta[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;

	for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	  ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	  ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	  /* d must satisfy:
	   * d >= hdmin[v][jp_v]
	   * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	   * d <= hdmax[v][jp_v]
	   * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	   * this reduces to two ESL_MAX calls
	   */
	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	  dpn     = dn - hdmin[v][jp_v];
	  dpx     = dx - hdmin[v][jp_v];
	  dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	    alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc);
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	}
	break;
	  case MR_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    {
	      /*if(i < i0 || j > j0) {
		printf("dsq[i:%d]: %d\n", i, dsq[i]);
		printf("dsq[j:%d]: %d\n", j, dsq[j]);
		printf("esc_v[%d]: %.5f\n", dsq[i]*cm->abc->Kp+dsq[j], esc_v[dsq[i]*cm->abc->Kp+dsq[j]]);;
		printf("i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
		}*/
	      alpha[v][jp_v][dp_v] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	    }
	}
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], alpha[y][jp_y-k][dp_y - k] + alpha[z][jp_z][kp_z]);
	    }
	  }
	}
	  }
	} /* finished calculating deck v. */
  } /* end of for (v = cm->M-1; v >= 0; v--) */

  /* Deal with local begins.
   * If local begins are off, all hits must be rooted at v=0.
   * With local begins on, the hit is rooted at the second state in
   * the traceback (e.g. after 0), the internal entry point.
   *
   * Hits rooted at 0 that not involved with local begins are
   * already calc'ed from the v loop with v == 0
   */

  /* Report all possible hits, but only after looking at local begins (if they're on) */
  v = 0;
  jpn = 0;
  jpx = jmax[v] - jmin[v];
  j   = jmin[v];

  ESL_ALLOC(bestr,  sizeof(int)   * (W+1));
  ESL_ALLOC(bestsc, sizeof(float) * (W+1));

  /* update gamma, by specifying all hits with j < jmin[0] are impossible */
  if(gamma != NULL) {
	for(j = i0; j < jmin[v]; j++) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, -1, -1,
				      NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				      bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++, j++) {
	esl_vec_ISet(bestr,  (W+1), 0); /* init bestr to 0, all hits are rooted at 0 unless we find a better local begin below */
	esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);
	if (cm->flags & CMH_LOCAL_BEGIN) {
	  for (y = 1; y < cm->M; y++) {
	if(NOT_IMPOSSIBLE(cm->beginsc[y]) && (j >= jmin[y] && j <= jmax[y])) {
	  assert(cm->sttype[v] != BEGL_S); /* local begins into BEGL_S are impossible */
	  jp_y = j - jmin[y];

	  dn   = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	  dx   = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	  dpn  = dn - hdmin[v][jp_v];
	  dpx  = dx - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  d    = dn;
	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y++, d++) {
	    sc = alpha[y][jp_y][dp_y] + cm->beginsc[y];
	    if(sc > alpha[0][jp_v][dp_v]) {
	      alpha[0][jp_v][dp_v] = sc;
	      bestsc[d] = sc;
	      bestr[d]  = y;
	    }
	  }
	}
	  } /* end of for(y = 1; y < cm->M; y++) */
	} /* end of if(cm->flags & CMH_LOCAL_BEGIN */

	/* for this j, fill in bestsc for all valid d values, update
	 * vsc_root (best overall score), and update envelope boundaries
	 * (if necessary)
	 */
	dpn = 0;
	dpx = hdmax[v][jp_v] - hdmin[v][jp_v];
	for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	  d         = dp_v + hdmin[v][jp_v];
	  bestsc[d] = alpha[0][jp_v][dp_v];
	  vsc_root  = ESL_MAX(vsc_root, alpha[0][jp_v][dp_v]);
	}
	/* update envelope boundaries, if nec */
	if(do_env_defn) {
	  j = jp_v + jmin[v];
	  for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	if(alpha[0][jp_v][dp_v] >= env_cutoff) {
	  d = dp_v + hdmin[v][jp_v];
	  i = j - d + 1;
	  envi = ESL_MIN(envi, i);
	  envj = ESL_MAX(envj, j);
	}
	  }
	}

	/* if necessary, report all hits with valid d for this j, either to gamma or tmp_hitlist */
	if(gamma != NULL) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	}
	if(tmp_hitlist != NULL) {
	  if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	}
  } /* end of 'for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++, j++) {' */

  /* update gamma, by specifying all hits with j > jmax[0] are impossible */
  if(gamma != NULL) {
	for(j = jmax[v]+1; j <= j0; j++) {
	  if((status = UpdateGammaHitMx(cm, errbuf, PLI_PASS_STD_ANY, gamma, j, -1, -1,
				    NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				    bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  free(el_scA);
  free(yvalidA);
  free(bestr);
  free(bestsc);
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  if (ret_sc != NULL) *ret_sc = vsc_root;
  ESL_DPRINTF1(("FastCYKScanHB() return sc: %f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return 0.; /* never reached */
}

/* Function: FastFInsideScanHB()
 * Incept:   EPN, Wed Nov 14 18:17:28 2007
 *
 * Purpose:  An HMM banded scanning Inside implementation that uses
 *           float scores. Takes a CM_HB_MX data structure which is
 *           indexed [v][j][d] with only cells within the bands
 *           allocated (different than other (non-HB) scanning
 *           function's convention of [j][v][d]). QDBs are not used.
 *
 * Args:     cm        - the model    [0..M-1]
 *           errbuf    - char buffer for reporting errors
 *           mx        - the HMM banded dp matrix, usually cm->hbmx.
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           dsq       - the sequence [1..L]
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           cutoff    - minimum score to report
 *           hitlist   - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3  - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff- ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi  - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj  - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_sc    - RETURN: score of best overall hit (vsc[0])
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEINCONCEIVABLE if bands allow a hit > L, errbuf filled.
 *           eslERANGE if required HMM banded matrix size exceeds <size_limit>, errbuf filled.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FastFInsideScanHB(CM_t *cm, char *errbuf, CM_HB_MX *mx, float size_limit, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
		  int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float *ret_sc)
{

  int      status;
  GammaHitMx_t *gamma = NULL;  /* semi-HMM for hit resoultion */
  int     *bestr;       /* best root state for d at current j */
  float   *bestsc;      /* best score for d at current j */
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int     *yvalidA;     /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;      /* [0..d..W-1] probability of local end emissions of length d */
  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      sd;                 /* StateDelta(cm->sttype[v]) */
  int      sdr;                /* StateRightDelta(cm->sttype[v] */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y;         /* d index for state v/y in alpha w/mem eff bands */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp;                 /* ESL_MAX(d-sd, 0) */
  int      dp_y_sd;            /* dp_y - sd */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  float    vsc_root = IMPOSSIBLE; /* score of best hit */
  int      W;                  /* max d over all hdmax[v][j] for all valid v, j */
  double **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int      jp;                 /* j index in act */
  int      do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t  envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* Contract check */
  if(dsq == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScanHB(), dsq is NULL.\n");
  if (mx == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScanHB(), mx is NULL.\n");
  if (cm->cp9b == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "FastFInsideScanHB(), mx is NULL.\n");

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;
  /* the DP matrix */
  float ***alpha = mx->dp; /* pointer to the alpha DP matrix */

  /* Allocations and initializations  */
  /* grow the matrix based on the current sequence and bands */
  if((status =  cm_hb_mx_GrowTo(cm, mx, errbuf, cp9b, (j0-i0+1), size_limit)) != eslOK) return status;

  /* set W as j0-i0+1 (this may exceed max size of a hit our bands will allow,
   * but that's okay b/c W is only used for sizing of act, bestr, bestsc vectors */
  W = j0-i0+1;
  /* make sure our bands won't allow a hit bigger than W (this could be modified to only execute in debugging mode) */
  for(j = jmin[0]; j <= jmax[0]; j++) {
	if(W < (hdmax[0][(j-jmin[0])])) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "FastCYKScanHB(), band allows a hit (j:%d hdmax[0][j]:%d) greater than j0-i0+1 (%" PRId64 ")", j, hdmax[0][(j-jmin[0])], j0-i0+1);
  }

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (W+1));
  for(d = 0; d <= W; d++) el_scA[d] = cm->el_selfsc * d;

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  esl_vec_FSet(alpha[0][0], mx->ncells_valid, IMPOSSIBLE);

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(j0-i0+1, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
	/* pre-fill act, different than non-HMM banded scanner b/c our main loop doesn't step j through residues */
	for(j = i0; j <= j0; j++) {
	  jp = j-i0+1; /* j is actual index in dsq, jp is offset j relative to start i0 (j index for act) */
	  esl_vec_DCopy(act[(jp-1)%(W+1)], cm->abc->K, act[jp%(W+1)]);
	  esl_abc_DCount(cm->abc, act[jp%(W+1)], dsq[j], 1.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* Main recursion */
  for (v = cm->M-1; v >= 0; v--) { /* all the way down to root, different from other scanners */
	float const *esc_v = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v = cm->tsc[v];  /* transition scores for state v */
	sd   = StateDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	jn   = jmin[v];
	jx   = jmax[v];

	/* re-initialize the deck if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0, d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; dp_v++, d++) {
	  dp = ESL_MAX(d-sd, 0);
	  alpha[v][jp_v][dp_v] = el_scA[dp] + cm->endsc[v];
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	alpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == IL_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IL states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	  alpha[v][jp_v][dp_v] =  ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] == IR_st) {
	  /* update alpha[v][jp_v][dp_v] cells, for IR states, loop nesting order is:
	   * for j { for d { for y { } } } because they can self transit, and a
	   * alpha[v][j][d] cell must be complete (that is we must have looked at all children y)
	   * before can start calc'ing for alpha[v][j][d+1] */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */
	  for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	    yoffset = yvalidA[yvalid_idx];
	    y = cm->cfirst[v] + yoffset;
	    jp_y_sdr = j - jmin[y] - sdr;

	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
	      dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
	    }
	  }
	  alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is (! IL && ! IR && ! B) */
	  /* ML, MP, MR, D, S, E states cannot self transit, this means that all cells
	   * in beta[v] are independent of each other, only depending on beta[y] for previously calc'ed y.
	   * We can do the for loops in any nesting order, this implementation does what I think is most efficient:
	   * for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;

	for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	  ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	  ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	  dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	  dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	  dpn     = dn - hdmin[v][jp_v];
	  dpx     = dx - hdmin[v][jp_v];
	  dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	    ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	    ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	    alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y_sdr][dp_y_sd] + tsc);
	  }
	}
	  }
	  /* add in emission score, if any */
	  switch(cm->sttype[v]) {
	  case ML_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]];
	}
	break;
	  case MR_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	}
	break;
	  case MP_st:
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v  = j - jmin[v];
	  i     = j - hdmin[v][jp_v] + 1;
	  for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	    alpha[v][jp_v][dp_v] += esc_v[dsq[i--]*cm->abc->Kp+dsq[j]];
	}
	break;
	  default:
	break;
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++)
	  alpha[v][jp_v][dp_v] = ESL_MAX(alpha[v][jp_v][dp_v], IMPOSSIBLE);
	  }
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      alpha[v][jp_v][dp_v] = FLogsum(alpha[v][jp_v][dp_v], alpha[y][jp_y-k][dp_y - k] + alpha[z][jp_z][kp_z]);
	    }
	  }
	}
	  }
	} /* finished calculating deck v. */

  } /* end of for (v = cm->M-1; v >= 0; v--) */

  /* Deal with local begins.
   * If local begins are off, all hits must be rooted at v=0.
   * With local begins on, the hit is rooted at the second state in
   * the traceback (e.g. after 0), the internal entry point.
   *
   * Hits rooted at 0 that not involved with local begins are
   * already calc'ed from the v loop with v == 0
   */

  /* Report all possible hits, but only after looking at local begins (if they're on) */
  v = 0;
  sd = sdr = 0;
  jpn = 0;
  jpx = jmax[v] - jmin[v];
  j   = jmin[v];

  ESL_ALLOC(bestr,  sizeof(int)   * (W+1));
  ESL_ALLOC(bestsc, sizeof(float) * (W+1));

  /* update gamma, by specifying all hits with j < jmin[0] are impossible */
  if(gamma != NULL) {
	for(j = i0; j < jmin[v]; j++) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, -1, -1,
				      NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				      bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++, j++) {
	esl_vec_ISet(bestr,  (W+1), 0); /* init bestr to 0, all hits are rooted at 0 unless we find a better local begin below */
	esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE); /* init bestr to 0, all hits are rooted at 0 unless we find a better local begin below */
	if (cm->flags & CMH_LOCAL_BEGIN) {
	  for (y = 1; y < cm->M; y++) {
	if(NOT_IMPOSSIBLE(cm->beginsc[y]) && (j >= jmin[y] && j <= jmax[y])) {
	  assert(cm->sttype[v] != BEGL_S); /* local begins into BEGL_S are impossible */
	  jp_y = j - jmin[y];
	  dn   = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	  dx   = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);
	  dpn  = dn - hdmin[v][jp_v];
	  dpx  = dx - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  d    = dn;
	  for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y++, d++) {
	    /*alpha[0][jp_v][dp_v] = FLogsum(alpha[0][jp_v][dp_v], alpha[y][jp_y][dp_y] + cm->beginsc[y]);*/
	    sc = alpha[y][jp_y][dp_y] + cm->beginsc[y];
	    if(sc > alpha[0][jp_v][dp_v]) {
	      alpha[0][jp_v][dp_v] = sc;
	      bestr[d] = y;
	    }
	  }
	}
	  } /* end of for(y = 1; y < cm->M; y++) */
	} /* end of if(cm->flags & CMH_LOCAL_BEGIN */

	/* for this j, fill in bestsc for all valid d values, update
	 * vsc_root (best overall score), and update envelope boundaries
	 * (if necessary)
	 */
	dpn = 0;
	dpx = hdmax[v][jp_v] - hdmin[v][jp_v];
	for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	  d         = dp_v + hdmin[v][jp_v];
	  bestsc[d] = alpha[0][jp_v][dp_v];
	  vsc_root  = ESL_MAX(vsc_root, alpha[0][jp_v][dp_v]);
	}
	/* update envelope boundaries, if nec */
	if(do_env_defn) {
	  j = jp_v + jmin[v];
	  for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	if(alpha[0][jp_v][dp_v] >= env_cutoff) {
	  d = dp_v + hdmin[v][jp_v];
	  i = j - d + 1;
	  envi = ESL_MIN(envi, i);
	  envj = ESL_MAX(envj, j);
	}
	  }
	}

	/* if necessary, report all hits with valid d for this j, either to gamma or tmp_hitlist */
	if(gamma != NULL) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, PLI_PASS_STD_ANY, gamma, j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, NULL, W, act)) != eslOK) return status;
	}
	if(tmp_hitlist != NULL) {
	  if((status = ReportHitsGreedily(cm, errbuf, PLI_PASS_STD_ANY,        j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, NULL, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	}
  } /* end of 'for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++, j++) {' */

  /* update gamma, by specifying all hits with j > jmax[0] are impossible */
  if(gamma != NULL) {
	for(j = jmax[v]+1; j <= j0; j++) {
	  if((status = UpdateGammaHitMx(cm, errbuf, PLI_PASS_STD_ANY, gamma, j, -1, -1,
				    NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				    bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  free(el_scA);
  free(yvalidA);
  free(bestr);
  free(bestsc);
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	/*cm_tophits_Dump(stdout, tmp_hitlist);*/
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  ESL_DPRINTF1(("FastFInsideScanHB() return sc: %f\n", vsc_root));
  if (ret_sc != NULL) *ret_sc = vsc_root;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return 0.; /* never reached */
}

/*****************************************************************
 * Benchmark driver
 *****************************************************************/
#ifdef IMPL_SEARCH_BENCHMARK
/* Next line is not optimized (debugging on) on MacBook Pro:
 * gcc  -o benchmark-search -std=gnu99 -g -Wall -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_SEARCH_BENCHMARK cm_dpsearch.c -linfernal -lhmmer -leasel -lm
 * ./benchmark-search <cmfile>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>



static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL,  "show brief help on version and usage",           0 },
  { "-g",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "search in glocal mode [default: local]", 0 },
  { "-w",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute reference CYK scan implementation", 0 },
  { "--noqdb",   eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute non-banded optimized CYK scan implementation", 0 },
  { "--iins",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute optimized int inside scan implementation", 0 },
  { "--riins",   eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute reference int inside scan implementation", 0 },
  { "--fins",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute optimized float inside scan implementation", 0 },
  { "--rfins",   eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute reference float inside scan implementation", 0 },
  { "--hbanded", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute HMM banded CYK scan implementation", 0 },
  { "--ihbanded",eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL,  "also execute HMM banded Inside scan implementation", 0 },
  { "--tau",     eslARG_REAL,   "1e-7",NULL, "0<x<1",NULL,"--hbanded",  NULL, "set tail loss prob for --hbanded to <x>", 0 },
  { "--scan2bands",eslARG_NONE, FALSE, NULL, NULL,  NULL,"--hbanded",   NULL, "derive HMM bands from scanning Forward/Backward", 0 },
  { "--sums",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,"--hbanded",   NULL, "use posterior sums during HMM band calculation (widens bands)", 0 },
  { "--mxsize",  eslARG_REAL, "256.0", NULL, "x>0.",NULL,  NULL, NULL, "set maximum allowable DP matrix size to <x> (Mb)", 0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile>";
static char banner[] = "benchmark driver for an optimized scanning CYK implementation";

int
main(int argc, char **argv)
{
  int             status;
  ESL_GETOPTS    *go      = esl_getopts_CreateDefaultApp(options, 2, argc, argv, banner, usage);
  CM_t           *cm;
  ESL_STOPWATCH  *w       = esl_stopwatch_Create();
  ESL_ALPHABET   *abc     = NULL;
  ESL_DSQ        *dsq;
  int             i;
  float           sc;
  char           *cmfile  = esl_opt_GetArg(go, 1);
  char           *seqfile = esl_opt_GetArg(go, 2);
  CM_FILE        *cmfp;	/* open input CM file stream */
  ESL_SQFILE     *sqfp  = NULL;  /* open sequence input file stream */
  ESL_SQ         *sq    = NULL;  /* a sequence */
  int             qdbidx;
  char            errbuf[eslERRBUFSIZE];
  int             L;    /* sequence length */
  float           size_limit = esl_opt_GetReal(go, "--mxsize");

  /* open CM file */
  if ((status = cm_file_Open(cmfile, NULL, FALSE, &cmfp, errbuf)) != eslOK)  cm_Fail("Failed to open covariance model save file\n", cmfile);
  if ((status = cm_file_Read(cmfp, TRUE, &abc, &cm))              != eslOK)  cm_Fail("Failed to read a CM from cm file\n");
  cm_file_Close(cmfp);

  /* open the sequence file */
  status = esl_sqfile_OpenDigital(cm->abc, seqfile, eslSQFILE_UNKNOWN, NULL, &sqfp);
  if (status == eslENOTFOUND)    esl_fatal("File %s doesn't exist or is not readable\n", seqfile);
  else if (status == eslEFORMAT) esl_fatal("Couldn't determine format of sequence file %s\n", seqfile);
  else if (status == eslEINVAL)  esl_fatal("Can't autodetect stdin or .gz.");
  else if (status != eslOK)      esl_fatal("Sequence file open failed with error %d.\n", status);

  /* configure cm */
  if(! esl_opt_GetBoolean(go, "-g")) cm->config_opts  |= CM_CONFIG_LOCAL;
  if(  esl_opt_GetBoolean(go, "--sums"))        cm->search_opts |= CM_SEARCH_SUMS;
  if(  esl_opt_GetBoolean(go, "--hbanded"))     cm->search_opts |= CM_SEARCH_HBANDED;
  if(  esl_opt_GetBoolean(go, "--ihbanded"))    cm->search_opts |= CM_SEARCH_HBANDED;
  if( esl_opt_GetBoolean(go, "--noqdb"))        cm->search_opts |= CM_SEARCH_NONBANDED;
  else                                          cm->search_opts |= CM_SEARCH_QDB;
  cm->config_opts |= CM_CONFIG_SCANMX;
  cm->tau    = esl_opt_GetReal(go, "--tau");  /* this will be DEFAULT_TAU unless changed at command line */
  qdbidx = esl_opt_GetBoolean(go, "--noqdb") ? SMX_NOQDB : SMX_QDB1_TIGHT;

  if((status = cm_Configure(cm, errbuf, -1)) != eslOK) cm_Fail(errbuf);

  /* setup logsum lookups (could do this only if nec based on options, but this is safer) */
  init_ilogsum();
  FLogsumInit();

  i = 0;
  sq = esl_sq_CreateDigital(cm->abc);
  while((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	i++;
	L = sq->n;
	dsq = sq->dsq;
	cm->search_opts  &= ~CM_SEARCH_INSIDE;

	esl_stopwatch_Start(w);
	if((status = FastCYKScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits ", i, "FastCYKScan(): ", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");

	if (esl_opt_GetBoolean(go, "-w")) {
	  esl_stopwatch_Start(w);
	  if((status = RefCYKScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefCYKScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	/* integer inside implementations */
	if (esl_opt_GetBoolean(go, "--iins")) {
	  cm->search_opts  |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = FastIInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastIInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}

	if (esl_opt_GetBoolean(go, "--riins")) {
	  cm->search_opts  |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = RefIInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefIInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	/* float inside implementations */
	if (esl_opt_GetBoolean(go, "--fins")) {
	  cm->search_opts  |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = FastFInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastFInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}

	if (esl_opt_GetBoolean(go, "--rfins")) {
	  cm->search_opts  |= CM_SEARCH_INSIDE;
	  esl_stopwatch_Start(w);
	  if((status = RefFInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefFInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	if (esl_opt_GetBoolean(go, "--hbanded")) {
	  esl_stopwatch_Start(w);
	  if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b, TRUE, NULL, 0)) != eslOK) cm_Fail(errbuf);
	  if((status = FastCYKScanHB(cm, errbuf, cm->hbmx, size_limit, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastCYKScanHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	if (esl_opt_GetBoolean(go, "--ihbanded")) {
	  esl_stopwatch_Start(w);
	  if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b, TRUE, NULL, 0)) != eslOK) cm_Fail(errbuf);
	  if((status = FastFInsideScanHB(cm, errbuf, cm->hbmx, size_limit, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastFInsideScanHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	printf("\n");
	esl_sq_Reuse(sq);
  }

  FreeCM(cm);
  esl_sq_Destroy(sq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_getopts_Destroy(go);
  return 0;
}
#endif /*IMPL_SEARCH_BENCHMARK*/

/*** End of inlined file: cm_dpsearch.c ***/


/*** Start of inlined file: cm_dpsearch_trunc.c ***/

#include <stdio.h>
#include <stdlib.h>


/* Function: RefTrCYKScan()
 * Date:     EPN, Tue Aug 16 04:16:03 2011
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           a reference scanning trCYK implementation.
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <trsmx>. Note that with
 *           trCYK only maximum subsequence length bands (dmax) are
 *           used. Because the target can be truncated anywhere, using
 *           minimum subsequence lengths (dmin) doesn't make sense.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           trsmx           - TrScanMatrix_t for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           pass_idx        - pipeline pass index, tells us which modes to allow and trunc penalties to use
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           th              - CM_TOPHITS to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not wanted
 *           ret_mode        - RETURN: mode of best overall hit (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc          - RETURN: score of best overall hit
 *
 * Note:     This function is heavily synchronized with RefITrInsideScan()
 *           any change to this function should be mirrored in that function..
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
RefTrCYKScan(CM_t *cm, char *errbuf, CM_TR_SCAN_MX *trsmx, int qdbidx, int pass_idx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	     int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, char *ret_mode, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float     sc;                 /* a temporary score */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  float     vmode_root;         /* alignment mode of best overall alignment (that has score = vsc_root) */
  float     bsc_full;           /* best overall score that emits full sequence i0..j0 */
  float     bmode_full;         /* alignment mode of best overall parse that emits full sequence */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jq_y;  	        /* offset j for state y plus 1 (if jp_y is prv, jq_y is cur, and vice versa) */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, trsmx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn, dx;             /* minimum/maximum valid d for current state */
  int       dx_y;               /* maximum valid d for state y */
  int       dx_w;               /* maximum valid d for state w */
  int       kn, kx;             /* minimum/maximum valid k for current d in B_st recursion */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  float   **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* variables specific to truncated search */
  int   Lyoffset0;              /* first yoffset to use for updating L matrix in IR/MR states, 1 if IR, 0 if MR */
  int   Ryoffset0;              /* first yoffset to use for updating R matrix in IL/ML states, 1 if IL, 0 if ML */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, dsq is NULL\n");
  if(cm->search_opts & CM_SEARCH_INSIDE)     ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, CM_SEARCH_INSIDE flag raised");
  if(trsmx == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, trsmx == NULL\n");
  if(! trsmx->floats_valid)                  ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, trsmx->floats_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  float ***Jalpha      = trsmx->fJalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Jalpha DP matrix, NULL for v == BEGL_S */
  float ***Jalpha_begl = trsmx->fJalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Jalpha DP matrix, NULL for v != BEGL_S */
  float ***Lalpha      = trsmx->fLalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Lalpha DP matrix, NULL for v == BEGL_S */
  float ***Lalpha_begl = trsmx->fLalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Lalpha DP matrix, NULL for v != BEGL_S */
  float ***Ralpha      = trsmx->fRalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Ralpha DP matrix, NULL for v == BEGL_S */
  float ***Ralpha_begl = trsmx->fRalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Ralpha DP matrix, NULL for v != BEGL_S */
  float ***Talpha      = trsmx->fTalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Talpha DP matrix, NULL for v != BIF_B  */
  int    **dnAA        = trsmx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int    **dxAA        = trsmx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  int     *bestr       = trsmx->bestr;         /* [0..d..W] best entry state v (0->v truncated begin) for this d (recalc'ed for each endpoint j) */
  char    *bestmode    = trsmx->bestmode;      /* [0..d..W] mode of best parsetree for this d (recalc'ed for each endpoint j) */
  float   *bestsc      = trsmx->bestsc;        /* [0..d..W] score of best parsetree for this d (recalc'ed for each endpoint j) */
  float  **esc_vAA     = cm->oesc;             /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
 					        * and all possible emissions a (including ambiguities) */
  float  **lmesc_vAA   = cm->lmesc;            /* [0..v..cm->M-1][0..a..(cm->abc->Kp-1)] left  marginal emission scores for v */
  float  **rmesc_vAA   = cm->rmesc;            /* [0..v..cm->M-1][0..a..(cm->abc->Kp-1)] right marginal emission scores for v */

  /* Determine if we're doing banded/non-banded and get a pointer to
   * dmax. (We only need dmax so we can compute kmin/kmax for B
   * states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan, qdbidx is invalid");

  /* from <pass_idx>: determine which matrices we need to fill in and
   * the appropriate truncation penalty index to use.
   */
  if((status = cm_TrFillFromPassIdx(pass_idx, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status,       errbuf, "RefTrCYKScan(), unexpected pass idx: %d", pass_idx);
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1)                        ESL_FAIL(eslEINCOMPAT, errbuf, "RefTrCYKScan(), unexpected pass idx: %d", pass_idx);

  L = j0-i0+1;
  W = trsmx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_tr_scan_mx_InitializeFloats(cm, trsmx, errbuf)) != eslOK) return status;

  /* other initializations */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }
  vsc_root   = IMPOSSIBLE;
  vmode_root = TRMODE_UNKNOWN;
  bsc_full   = IMPOSSIBLE;
  bmode_full = TRMODE_UNKNOWN;

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* precalculate the initial scores for all cells */
  init_scAA = FCalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float Jsc, Lsc, Rsc, Tsc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  float const *esc_v   = esc_vAA[v];
	  float const *tsc_v   = cm->tsc[v];
	  float const *lmesc_v = lmesc_vAA[v];
	  float const *rmesc_v = rmesc_vAA[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v  = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y  = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  jq_y = (StateRightDelta(cm->sttype[v]) > 0) ? cur : prv;
	  sd    = StateDelta(cm->sttype[v]);
	  /* if we emit right, precalc score of emitting res j from state v */
	  float   esc_j = IMPOSSIBLE;
	  float rmesc_j = IMPOSSIBLE;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	    esc_j   =   esc_v[dsq[j]];
	    rmesc_j = rmesc_v[dsq[j]];
	  }
	  if(cm->sttype[v] == MP_st) {
	    rmesc_j = rmesc_v[dsq[j]];
	  }

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dx_y = ESL_MIN(dmax[y], trsmx->W);
		dx_w = ESL_MIN(dmax[w], trsmx->W);
		kmin = ESL_MAX(0,    d-dx_w);
		kmax = ESL_MIN(dx_y, d);
	      }
	      else { kmin = 0; kmax = d; }

	      Jsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_L) Lsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_R) Rsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_T) Tsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */

	      /* Careful with Tsc, it isn't updated for k == 0 or  k == d,
	       * but Jsc, Lsc, Rsc, are all updated for k == 0 and k == d */
	      for (k = kmin; k <= kmax; k++) {
		Jsc =            ESL_MAX(Jsc, (Jalpha_begl[jp_wA[k]][w][d-k] + Jalpha[jp_y][y][k]));
		if(fill_L) Lsc = ESL_MAX(Lsc, (Jalpha_begl[jp_wA[k]][w][d-k] + Lalpha[jp_y][y][k]));
		if(fill_R) Rsc = ESL_MAX(Rsc, (Ralpha_begl[jp_wA[k]][w][d-k] + Jalpha[jp_y][y][k]));
	      }
	      if(fill_T) {
		kn = ESL_MAX(1,   kmin);
		kx = ESL_MIN(d-1, kmax);
		for (k = kn; k <= kx; k++) {
		  Tsc = ESL_MAX(Tsc, (Ralpha_begl[jp_wA[k]][w][d-k] + Lalpha[jp_y][y][k]));
		}
	      }

	      Jalpha[jp_v][v][d] = Jsc;
	      if(fill_T) Talpha[jp_v][v][d] = Tsc;
	      if(fill_L) {
		if(kmin == 0) Lalpha[jp_v][v][d] = ESL_MAX(Lsc, ESL_MAX(Jalpha_begl[jp_wA[0]][w][d], Lalpha_begl[jp_wA[0]][w][d]));
		else          Lalpha[jp_v][v][d] = Lsc;
	      }
	      if(fill_R) {
		if(kmax == d) Ralpha[jp_v][v][d] = ESL_MAX(Rsc, ESL_MAX(Jalpha[jp_y][y][d], Ralpha[jp_y][y][d]));
		else          Ralpha[jp_v][v][d] = Rsc;
	      }
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      if(fill_L) Lsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      if(fill_R) Rsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc =            ESL_MAX(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_L) Lsc = ESL_MAX(Lsc, Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_R) Rsc = ESL_MAX(Rsc, Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      }
	      Jalpha_begl[jp_v][v][d] = Jsc;
	      if(fill_L) Lalpha_begl[jp_v][v][d] = Lsc;
	      if(fill_R) Ralpha_begl[jp_v][v][d] = Rsc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else if (emitmode == EMITLEFT) {
	    if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	      y = cm->cfirst[v];
	      i = j - dnA[v] + 1;
	      assert(dnA[v] == 1);
	      Ryoffset0 = cm->sttype[v] == IL_st ? 1 : 0; /* don't allow IL self transits in R mode */
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		Jsc = init_scAA[v][d-sd];
		if(fill_L) Lsc = init_scAA[v][d-sd];
		if(fill_R) {
		  Rsc = init_scAA[v][d]; /* 'd', not 'd-sd', because we won't emit left in R mode */
		  Ralpha[jp_v][v][d] = Rsc; /* this is important b/c if we're an IL, we'll access this cell in the recursion below for Ralpha */
		}
		/* We need to do separate 'for (yoffset...' loops for J
		 * and R matrices, because jp_v == jp_y for all states
		 * here, and for IL states, v can equal y+yoffset (when
		 * yoffset==0).  This means we have to fully calculate
		 * the Jalpha[jp_v][y+yoffset][d] cell (which is
		 * Jalpha[jp_v][v][d]) before we can start to calculate
		 * Ralpha[jp_v][v][d].
		 */
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		  Jsc =            ESL_MAX(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		  if(fill_L) Lsc = ESL_MAX(Lsc, Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		}
		Jalpha[jp_v][v][d]            =            Jsc + esc_v[dsq[i]];
		if(fill_L) Lalpha[jp_v][v][d] = (d >= 2) ? Lsc + esc_v[dsq[i]] : esc_v[dsq[i]];

		if(fill_R) {
		  for (yoffset = Ryoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Ryoffset0 instead of 0 disallows IL self transits in R mode */
		    Rsc = ESL_MAX(Rsc, ESL_MAX(Jalpha[jp_y][y+yoffset][d]      + tsc_v[yoffset],
					       Ralpha[jp_y][y+yoffset][d]      + tsc_v[yoffset]));
		  }
		  Ralpha[jp_v][v][d] = Rsc;
		}
		i--;
	      }
	    } /* end of if(! StateIsDetached(cm, v) */
	  }
	  else if (emitmode == EMITRIGHT) {
	    if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	      y = cm->cfirst[v];
	      assert(dnA[v] == 1);
	      Lyoffset0 = cm->sttype[v] == IR_st ? 1 : 0; /* don't allow IR self transits in L mode */
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		           Jsc = init_scAA[v][d-sd];
		if(fill_R) Rsc = init_scAA[v][d-sd];
		if(fill_L) {
		  Lsc = init_scAA[v][d]; /* 'd', not 'd-sd', because we won't emit right in L mode */
		  Lalpha[jp_v][v][d] = Lsc; /* this is important b/c if we're an IR, we'll access this cell in the recursion below for Lalpha */
		}

		/* We need to do separate 'for (yoffset...' loops for J
		 * and L matrices, because jp_v == jq_y for all states
		 * here, and for IR states, v can equal y+yoffset (when
		 * yoffset==0).  This means we have to fully calculate
		 * the Jalpha[jq_y][y+yoffset][d] cell (which is
		 * Jalpha[jp_v][v][d]) before we can start to calculate
		 * Lalpha[jp_v][v][d].
		 */
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		  Jsc            = ESL_MAX(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		  if(fill_R) Rsc = ESL_MAX(Rsc, Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		}
		Jalpha[jp_v][v][d]            =            Jsc + esc_j;
		if(fill_R) Ralpha[jp_v][v][d] = (d >= 2) ? Rsc + esc_j : esc_j;

		if(fill_L) {
		  for (yoffset = Lyoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Lyoffset0, instead of 0 disallows IR self transits in L mode */
		    Lsc = ESL_MAX(Lsc, ESL_MAX(Jalpha[jq_y][y+yoffset][d]     + tsc_v[yoffset],
					       Lalpha[jq_y][y+yoffset][d]     + tsc_v[yoffset]));
		  }
		  Lalpha[jp_v][v][d] = Lsc;
		}
	      }
	    } /* end of if(! StateIsDetached(cm, v) */
	  }
	  else if (emitmode == EMITPAIR) {
	    y = cm->cfirst[v];
	    i = j - dnA[v] + 1;
	    assert(dnA[v] == 1);
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd];
	      if(fill_L) Lsc = init_scAA[v][d-1]; /* 'd-1', not 'd', because we'll only emit 1 residue in left  mode */
	      if(fill_R) Rsc = init_scAA[v][d-1]; /* 'd-1', not 'd', because we'll only emit 1 residue in right mode */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc = ESL_MAX(Jsc,         Jalpha[jp_y][y+yoffset][d - 2] + tsc_v[yoffset]);
		if(fill_L) {
		  Lsc = ESL_MAX(Lsc, ESL_MAX(Jalpha[jq_y][y+yoffset][d - 1] + tsc_v[yoffset],
					     Lalpha[jq_y][y+yoffset][d - 1] + tsc_v[yoffset]));
		}
		if(fill_R) {
		  Rsc = ESL_MAX(Rsc, ESL_MAX(Jalpha[jp_y][y+yoffset][d - 1] + tsc_v[yoffset],
					     Ralpha[jp_y][y+yoffset][d - 1] + tsc_v[yoffset]));
		}
	      }
	      Jalpha[jp_v][v][d]            = (d >= 2) ? Jsc + esc_v[dsq[i]*cm->abc->Kp+dsq[j]] : IMPOSSIBLE;
	      if(fill_L) Lalpha[jp_v][v][d] = (d >= 2) ? Lsc + lmesc_v[dsq[i]]                  : lmesc_v[dsq[i]];
	      if(fill_R) Ralpha[jp_v][v][d] = (d >= 2) ? Rsc + rmesc_j                          : rmesc_j;
	      i--;
	    }
	  }
	  else { /* ! B_st && ! BEGL_S st && ! L_st && ! R_st && ! P_st (emitmode == EMITNONE) */
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd]; /* sd is 0 */
	      if(fill_L) Lsc = init_scAA[v][d-sd];
	      if(fill_R) Rsc = init_scAA[v][d-sd];
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc            = ESL_MAX(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_L) Lsc = ESL_MAX(Lsc, Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_R) Rsc = ESL_MAX(Rsc, Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      }
	      Jalpha[jp_v][v][d] = Jsc;
	      if(fill_L) Lalpha[jp_v][v][d] = Lsc;
	      if(fill_R) Ralpha[jp_v][v][d] = Rsc;
	    }
	  }

	  if(vsc != NULL) {
	    if(cm->stid[v] == BEGL_S) {
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		vsc[v] = ESL_MAX(vsc[v], Jalpha_begl[jp_v][v][d]);
		if(fill_L) vsc[v] = ESL_MAX(vsc[v], Lalpha_begl[jp_v][v][d]);
		if(fill_R) vsc[v] = ESL_MAX(vsc[v], Ralpha_begl[jp_v][v][d]);
	      }
	    }
	    else {
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		vsc[v] = ESL_MAX(vsc[v], Jalpha[jp_v][v][d]);
		if(fill_L) vsc[v] = ESL_MAX(vsc[v], Lalpha[jp_v][v][d]);
		if(fill_R) vsc[v] = ESL_MAX(vsc[v], Ralpha[jp_v][v][d]);
		if(cm->stid[v] == BIF_B && fill_T) {
		  vsc[v] = ESL_MAX(vsc[v], Talpha[jp_v][v][d]);
		}
	      }
	    }
	  }
#if eslDEBUGLEVEL >= 3
	  /* print alpha matrices - caution: these will be big! */
	  if(cm->stid[v] == BIF_B) {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(Jalpha[jp_v][v][d]) ? Jalpha[jp_v][v][d] : -9999.9,
		     fill_L && NOT_IMPOSSIBLE(Lalpha[jp_v][v][d]) ? Lalpha[jp_v][v][d] : -9999.9,
		     fill_R && NOT_IMPOSSIBLE(Ralpha[jp_v][v][d]) ? Ralpha[jp_v][v][d] : -9999.9,
		     fill_T && NOT_IMPOSSIBLE(Talpha[jp_v][v][d]) ? Talpha[jp_v][v][d] : -9999.9);
	    }
	  }
	  else if(cm->stid[v] == BEGL_S) {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(Jalpha_begl[jp_v][v][d]) ? Jalpha_begl[jp_v][v][d] : -9999.9,
		     fill_L && NOT_IMPOSSIBLE(Lalpha_begl[jp_v][v][d]) ? Lalpha_begl[jp_v][v][d] : -9999.9,
		     fill_R && NOT_IMPOSSIBLE(Ralpha_begl[jp_v][v][d]) ? Ralpha_begl[jp_v][v][d] : -9999.9,
		     -9999.9);
	    }
	  }
	  else if(cm->stid[v] == BEGR_S) {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(Jalpha[jp_v][v][d]) ? Jalpha[jp_v][v][d] : -9999.9,
		     fill_L && NOT_IMPOSSIBLE(Lalpha[jp_v][v][d]) ? Lalpha[jp_v][v][d] : -9999.9,
		     fill_R && NOT_IMPOSSIBLE(Ralpha[jp_v][v][d]) ? Ralpha[jp_v][v][d] : -9999.9,
		     -9999.9);
	    }
	  }
	  else {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(Jalpha[jp_v][v][d]) ? Jalpha[jp_v][v][d] : -9999.9,
		     fill_L && NOT_IMPOSSIBLE(Lalpha[jp_v][v][d]) ? Lalpha[jp_v][v][d] : -9999.9,
		     fill_R && NOT_IMPOSSIBLE(Ralpha[jp_v][v][d]) ? Ralpha[jp_v][v][d] : -9999.9,
		     -9999.9);
	    }
	  }
	  printf("\n");
#endif
	}  /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/truncated
	   * begins.  In truncated alignment only way out of ROOT_S in
	   * local or global mode is via a 'truncated begin' with a score
	   * (penalty) from cm->trp into any emitting state. The penalty
	   * differs depending on whether we are in local or global mode
	   * and the value of 'pty_idx' which was determined from
	   * <pass_idx> (passed in). In local mode the penalty includes
	   * the standard local begin probability as part of the
	   * penalty. Penalties are calculated in
	   * cm_tr_penalties_Create().
	   */
	  /* initializations */
	  v = 0;
	  esl_vec_ISet(bestr,  (W+1), 0);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);
	  for(i = 0; i <= W; i++) bestmode[i] = TRMODE_UNKNOWN;

	  for (y = 1; y < cm->M; y++) {
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][y] : cm->trp->g_ptyAA[pty_idx][y];
	if(NOT_IMPOSSIBLE(trpenalty)) {
	  assert(cm->stid[y] != BEGL_S);
	  dn = ESL_MAX(dnA[0], dnA[y]);
	  dx = ESL_MIN(dxA[0], dxA[y]);
	  jp_y = cur;
	  /* check for new optimally scoring Joint alignments of all lengths in J matrix */
	  for (d = dn; d <= dx; d++) {
	    sc = Jalpha[jp_y][y][d] + trpenalty;
	    if (sc > Jalpha[jp_v][0][d]) {
	      Jalpha[jp_v][0][d] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_J;
		bestr[d]    = y;
	      }
	    }
	  }
	  /* check for new optimally scoring Left alignments of all lengths in L matrix */
	  if(fill_L) {
	    for (d = dn; d <= dx; d++) {
	      sc = Lalpha[jp_y][y][d] + trpenalty;
	      if (sc > Lalpha[jp_v][0][d]) {
		Lalpha[jp_v][0][d] = sc;
		if(sc > bestsc[d]) {
		  bestsc[d]   = sc;
		  bestmode[d] = TRMODE_L;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	  /* check for new optimally scoring Right alignments of all lengths in L matrix */
	  if(fill_R) {
	    for (d = dn; d <= dx; d++) {
	      sc = Ralpha[jp_y][y][d] + trpenalty;
	      if (sc > Ralpha[jp_v][0][d]) {
		Ralpha[jp_v][0][d] = sc;
		if(sc > bestsc[d]) {
		  bestsc[d]   = sc;
		  bestmode[d] = TRMODE_R;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	  /* check for new optimally scoring Terminal alignments of all lengths in T matrix */
	  if(fill_T && cm->sttype[y] == B_st) {
	    for (d = dn; d <= dx; d++) {
	      sc = Talpha[jp_y][y][d] + trpenalty;
	      if (sc > Talpha[jp_v][0][d]) {
		Talpha[jp_v][0][d] = sc;
		if(sc > bestsc[d]) {
		  bestsc[d]   = sc;
		  bestmode[d] = TRMODE_T;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	}
	  }

	  /* update the best score (in any mode) stored in vsc_root */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	if(bestsc[d] > vsc_root) {
	  vsc_root   = bestsc[d];
	  vmode_root = bestmode[d];
	}
	  }
	  /* find the best score (in any mode) that spans the full sequence */
	  if(j == j0) {
	if(bestsc[j] > bsc_full) {
	  bsc_full   = bestsc[j];
	  bmode_full = bestmode[j];
	}
	  }
	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(bestsc[d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, dnA[0], dxA[0], bestsc, bestr, bestmode, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, pass_idx,        j, dnA[0], dxA[0], bestsc, bestr, bestmode, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }
	  /* cm_DumpScanMatrixAlpha(cm, si, j, i0, TRUE); */
	} /* end loop over end positions j */
  if(vsc != NULL) vsc[0] = vsc_root;

#if eslDEBUGLEVEL >= 2
  printf("Best truncated score: %.4f (%.4f) (ANY LENGTH CYK mode: %s)\n",
	 vsc_root,
	 vsc_root + sreLOG2(2./(cm->clen * (cm->clen+1))),
	 MarginalMode(vmode_root));
  printf("Best truncated score: %.4f (%.4f) (FULL LENGTH CYK mode: %s)\n",
	 bsc_full,
	 bsc_full + sreLOG2(2./(cm->clen * (cm->clen+1))),
	 MarginalMode(bmode_full));
#endif

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	/*cm_tophits_Dump(stdout, tmp_hitlist);*/
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	/*cm_tophits_Dump(stdout, hitlist);*/
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else if(vsc != NULL) free(vsc);
  if (ret_sc   != NULL) *ret_sc   = vsc_root;
  if (ret_mode != NULL) *ret_mode = vmode_root;

  ESL_DPRINTF1(("RefTrCYKScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: RefITrInsideScan()
 * Date:     EPN, Wed Aug 24 15:23:37 2011
 *
 * Purpose:  Scan a sequence for matches to a covariance model, using
 *           a reference scanning trInside implementation.
 *
 *           The choice of using one of two sets of query-dependent
 *           bands (QDBs) or not using QDBs is controlled by
 *           <qdbidx>. The QDBs are stored in <trsmx>. Note that with
 *           trCYK only maximum subsequence length bands (dmax) are
 *           used. Because the target can be truncated anywhere, using
 *           minimum subsequence lengths (dmin) doesn't make sense.
 *
 * Args:     cm              - the covariance model
 *           errbuf          - char buffer for reporting errors
 *           trsmx           - CM_TR_SCAN_MX for this search w/this model (incl. DP matrix, qdbands etc.)
 *           qdbidx          - controls which QDBs to use: SMX_NOQDB | SMX_QDB1_TIGHT | SMX_QDB2_LOOSE
 *           pass_idx        - pipeline pass index, tells us which modes to allow and trunc penalties to use
 *           dsq             - the digitized sequence
 *           i0              - start of target subsequence (1 for full seq)
 *           j0              - end of target subsequence (L for full seq)
 *           cutoff          - minimum score to report
 *           th              - CM_TOPHITS to add to; if NULL, don't add to it
 *           do_null3        - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff      - ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi        - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj        - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_vsc         - RETURN: [0..v..M-1] best score at each state v, NULL if not-wanted
 *           ret_mode        - RETURN: mode of best overall hit (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc          - RETURN: score of best overall hit
 *
 * Note:     This function is heavily synchronized with RefTrCYKScan()
 *           any change to this function should be mirrored in that functions.
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
RefITrInsideScan(CM_t *cm, char *errbuf, CM_TR_SCAN_MX *trsmx, int qdbidx, int pass_idx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
		 int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, float **ret_vsc, char *ret_mode, float *ret_sc)
{
  int       status;
  GammaHitMx_t *gamma = NULL;   /* semi-HMM for hit resoultion */
  float     fsc;                /* a temporary score */
  int       sc, ivsc;           /* integer scores */
  float    *vsc;                /* best score for each state (float) */
  float     vsc_root = IMPOSSIBLE; /* best overall score (score at ROOT_S) */
  float     vmode_root;         /* alignment mode of best overall alignment (that has score = vsc_root) */
  float     bsc_full;           /* best overall score that emits full sequence i0..j0 */
  float     bmode_full;         /* alignment mode of best overall parse that emits full sequence */
  int       yoffset;		/* offset to a child state */
  int       i,j;		/* index of start/end positions in sequence, 0..L */
  int       d;			/* a subsequence length, 0..W */
  int       k;			/* used in bifurc calculations: length of right subseq */
  int       prv, cur;		/* previous, current j row (0 or 1) */
  int       v, w, y;            /* state indices */
  int       jp_v;  	        /* offset j for state v */
  int       jp_y;  	        /* offset j for state y */
  int       jq_y;  	        /* offset j for state y plus 1 (if jp_y is prv, jq_y is cur, and vice versa) */
  int       jp_g;               /* offset j for gamma (j-i0+1) */
  int       kmin, kmax;         /* for B_st's, min/max value consistent with bands*/
  int       L;                  /* length of the subsequence (j0-i0+1) */
  int       W;                  /* max d; max size of a hit, this is min(L, trsmx->W) */
  int       sd;                 /* StateDelta(cm->sttype[v]), # emissions from v */
  int       do_banded = FALSE;  /* TRUE: use QDBs, FALSE: don't   */
  int      *dnA, *dxA;          /* tmp ptr to 1 row of dnAA, dxAA */
  int       dn, dx;             /* minimum/maximum valid d for current state */
  int       kn, kx;             /* minimum/maximum valid k for current d in B_st recursion */
  int       dx_y;               /* maximum valid d for state y */
  int       dx_w;               /* maximum valid d for state w */
  int      *dmax;               /* [0..v..cm->M-1] maximum d allowed for this state */
  int      *jp_wA;              /* rolling pointer index for B states, gets precalc'ed */
  int     **init_scAA;          /* [0..v..cm->M-1][0..d..W] initial score for each v, d for all j */
  double  **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int       do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t   envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* variables specific to truncated search */
  int   Lyoffset0;              /* first yoffset to use for updating L matrix in IR/MR states, 1 if IR, 0 if MR */
  int   Ryoffset0;              /* first yoffset to use for updating R matrix in IL/ML states, 1 if IL, 0 if ML */
  int   fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int   pty_idx;                /* index for truncation penalty, determined by pass_idx */
  int   itrpenalty;             /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* Contract check */
  if(! cm->flags & CMH_BITS)                 ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, CMH_BITS flag is not raised.\n");
  if(j0 < i0)                                ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, i0: %" PRId64 " j0: %" PRId64 "d\n", i0, j0);
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, dsq is NULL\n");
  if(! (cm->search_opts & CM_SEARCH_INSIDE)) ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, CM_SEARCH_INSIDE flag not raised");
  if(trsmx == NULL)                          ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, trsmx == NULL\n");
  if(! trsmx->ints_valid)                    ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, trsmx->ints_valid if FALSE");

  /* make pointers to the ScanMatrix/CM data for convenience */
  int  ***Jalpha       = trsmx->iJalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Jalpha DP matrix, NULL for v == BEGL_S */
  int  ***Jalpha_begl  = trsmx->iJalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Jalpha DP matrix, NULL for v != BEGL_S */
  int  ***Lalpha       = trsmx->iLalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Lalpha DP matrix, NULL for v == BEGL_S */
  int  ***Lalpha_begl  = trsmx->iLalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Lalpha DP matrix, NULL for v != BEGL_S */
  int  ***Ralpha       = trsmx->iRalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Ralpha DP matrix, NULL for v == BEGL_S */
  int  ***Ralpha_begl  = trsmx->iRalpha_begl;  /* [0..j..W][0..v..cm->M-1][0..d..W] Ralpha DP matrix, NULL for v != BEGL_S */
  int  ***Talpha       = trsmx->iTalpha;       /* [0..j..1][0..v..cm->M-1][0..d..W] Talpha DP matrix, NULL for v != BIF_B  */
  int   **dnAA         = trsmx->dnAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] minimum d for v, j (for j > W use [W][v]) */
  int   **dxAA         = trsmx->dxAAA[qdbidx]; /* [0..j..W][0..v..cm->M-1] maximum d for v, j (for j > W use [W][v]) */
  int    *bestr        = trsmx->bestr;         /* [0..d..W] best root state (for local begins or 0) for this d */
  char   *bestmode     = trsmx->bestmode;      /* [0..d..W] mode of best parsetree for this d */
  float  *bestsc       = trsmx->bestsc;        /* [0..d..W] score of best parsetree for this d (recalc'ed for each endpoint j) */
  int   **esc_vAA      = cm->ioesc;            /* [0..v..cm->M-1][0..a..(cm->abc->Kp | cm->abc->Kp**2)] optimized emission scores for v
 					        * and all possible emissions a (including ambiguities) */
  int   **lmesc_vAA    = cm->ilmesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp-1)] left  marginal emission scores for v */
  int   **rmesc_vAA    = cm->irmesc;           /* [0..v..cm->M-1][0..a..(cm->abc->Kp-1)] right marginal emission scores for v */

  /* Determine if we're doing banded/non-banded and get a pointer to
   * dmax. (We only need dmax so we can compute kmin/kmax for B
   * states.)
   */
  if     (qdbidx == SMX_NOQDB)      { do_banded = FALSE; dmax = NULL; }
  else if(qdbidx == SMX_QDB1_TIGHT) { do_banded = TRUE;  dmax = cm->qdbinfo->dmax1; }
  else if(qdbidx == SMX_QDB2_LOOSE) { do_banded = TRUE;  dmax = cm->qdbinfo->dmax2; }
  else ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan, qdbidx is invalid");

  /* from <pass_idx>: determine which matrices we need to fill in and
   * the appropriate truncation penalty index to use.
   */
  if((status = cm_TrFillFromPassIdx(pass_idx, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status,       errbuf, "RefITrInsideScan(), unexpected pass idx: %d", pass_idx);
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1)                        ESL_FAIL(eslEINCOMPAT, errbuf, "RefITrInsideScan(), unexpected pass idx: %d", pass_idx);

  L = j0-i0+1;
  W = trsmx->W;
  if (W > L) W = L;

  /* initialize the scan matrix */
  if((status = cm_tr_scan_mx_InitializeIntegers(cm, trsmx, errbuf)) != eslOK) return status;

  /* other initializations */
  vsc = NULL;
  if(ret_vsc != NULL) {
	ESL_ALLOC(vsc, sizeof(float) * cm->M);
	esl_vec_FSet(vsc, cm->M, IMPOSSIBLE);
  }
  vsc_root   = IMPOSSIBLE;
  vmode_root = TRMODE_UNKNOWN;
  bsc_full   = IMPOSSIBLE;
  bmode_full = TRMODE_UNKNOWN;

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(L, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* allocate array for precalc'ed rolling ptrs into BEGL deck, filled inside 'for(j...' loop */
  ESL_ALLOC(jp_wA, sizeof(float) * (W+1));

  /* precalculate the initial scores for all cells */
  init_scAA = ICalcInitDPScores(cm);

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* The main loop: scan the sequence from position i0 to j0.
   */
  for (j = i0; j <= j0; j++)
	{
	  float Jsc, Lsc, Rsc, Tsc;
	  jp_g = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (index in gamma* data structures) */
	  cur  = j%2;
	  prv  = (j-1)%2;
	  if(jp_g >= W) { dnA = dnAA[W];     dxA = dxAA[W];    }
	  else          { dnA = dnAA[jp_g];  dxA = dxAA[jp_g]; }
	  /* precalcuate all possible rolling ptrs into the BEGL deck, so we don't wastefully recalc them inside inner DP loop */
	  for(d = 0; d <= W; d++) jp_wA[d] = (j-d)%(W+1);

	  /* if do_null3 (act != NULL), update act */
	  if(act != NULL) {
	esl_vec_DCopy(act[(jp_g-1)%(W+1)], cm->abc->K, act[jp_g%(W+1)]);
	esl_abc_DCount(cm->abc, act[jp_g%(W+1)], dsq[j], 1.);
	/*printf("j: %3d jp_g: %3d jp_g/W: %3d act[0]: %.3f act[1]: %.3f act[2]: %.3f act[3]: %.3f\n", j, jp_g, jp_g%(W+1), act[jp_g%(W+1)][0], act[jp_g%(W+1)][1], act[jp_g%(W+1)][2], act[jp_g%(W+1)][3]);*/
	  }

	  for (v = cm->M-1; v > 0; v--) /* ...almost to ROOT; we handle ROOT specially... */
	{
	  /* printf("dnA[v:%d]: %d\ndxA[v:%d]: %d\n", v, dnA[v], v, dxA[v]); */
	  if(cm->sttype[v] == E_st) continue;
	  int const *esc_v   = esc_vAA[v];
	  int const *tsc_v   = cm->itsc[v];
	  int const *lmesc_v = lmesc_vAA[v];
	  int const *rmesc_v = rmesc_vAA[v];
	  int emitmode = Emitmode(cm->sttype[v]);

	  /* float sc; */
	  jp_v  = (cm->stid[v] == BEGL_S) ? (j % (W+1)) : cur;
	  jp_y  = (StateRightDelta(cm->sttype[v]) > 0) ? prv : cur;
	  jq_y = (StateRightDelta(cm->sttype[v]) > 0) ? cur : prv;
	  sd    = StateDelta(cm->sttype[v]);
	  /* if we emit right, precalc score of emitting res j from state v */
	  int   esc_j = -INFTY;
	  int rmesc_j = -INFTY;
	  if(cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) {
	    esc_j   =   esc_v[dsq[j]];
	    rmesc_j = rmesc_v[dsq[j]];
	  }
	  if(cm->sttype[v] == MP_st) {
	    rmesc_j = rmesc_v[dsq[j]];
	  }

	  if(cm->sttype[v] == B_st) {
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      /* k is the length of the right fragment */
	      if(do_banded) {
		/* Careful, make sure k is consistent with bands in
		 * state w and state y, and don't forget that
		 * dmin/dmax values can exceed W. */
		dx_y = ESL_MIN(dmax[y], trsmx->W);
		dx_w = ESL_MIN(dmax[w], trsmx->W);
		kmin = ESL_MAX(0,    d-dx_w);
		kmax = ESL_MIN(dx_y, d);
	      }
	      else { kmin = 0; kmax = d; }

	      Jsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_L) Lsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_R) Rsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */
	      if(fill_T) Tsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for B_st */

	      /* Careful with Tsc, it isn't updated for k == 0 or  k == d,
	       * but Jsc, Lsc, Rsc, are all updated for k == 0 and k == d */
	      for (k = kmin; k <= kmax; k++) {
		Jsc =            ILogsum(Jsc, (Jalpha_begl[jp_wA[k]][w][d-k] + Jalpha[jp_y][y][k]));
		if(fill_L) Lsc = ILogsum(Lsc, (Jalpha_begl[jp_wA[k]][w][d-k] + Lalpha[jp_y][y][k]));
		if(fill_R) Rsc = ILogsum(Rsc, (Ralpha_begl[jp_wA[k]][w][d-k] + Jalpha[jp_y][y][k]));
	      }
	      if(fill_T) {
		kn = ESL_MAX(1,   kmin);
		kx = ESL_MIN(d-1, kmax);
		for (k = kn; k <= kx; k++) {
		  Tsc = ILogsum(Tsc, (Ralpha_begl[jp_wA[k]][w][d-k] + Lalpha[jp_y][y][k]));
		}
	      }

	      Jalpha[jp_v][v][d] = Jsc;
	      if(fill_T) Talpha[jp_v][v][d] = Tsc;
	      if(fill_L) {
		if(kmin == 0) Lalpha[jp_v][v][d] = ILogsum(Lsc, ESL_MAX(Jalpha_begl[jp_wA[0]][w][d], Lalpha_begl[jp_wA[0]][w][d]));
		else          Lalpha[jp_v][v][d] = Lsc;
	      }
	      if(fill_R) {
		if(kmax == d) Ralpha[jp_v][v][d] = ILogsum(Rsc, ESL_MAX(Jalpha[jp_y][y][d], Ralpha[jp_y][y][d]));
		else          Ralpha[jp_v][v][d] = Rsc;
	      }
	      /* careful: scores for w, the BEGL_S child of v, are in alpha_begl, not alpha */
	    }
	  }
	  else if (cm->stid[v] == BEGL_S) {
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      if(fill_L) Lsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      if(fill_R) Rsc = init_scAA[v][d-sd]; /* state delta (sd) is 0 for BEGL_S st */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc =            ILogsum(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_L) Lsc = ILogsum(Lsc, Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_R) Rsc = ILogsum(Rsc, Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      }
	      Jalpha_begl[jp_v][v][d] = Jsc;
	      if(fill_L) Lalpha_begl[jp_v][v][d] = Lsc;
	      if(fill_R) Ralpha_begl[jp_v][v][d] = Rsc;
	      /* careful: y is in alpha (all children of a BEGL_S must be non BEGL_S) */
	    }
	  }
	  else if (emitmode == EMITLEFT) {
	    if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	      y = cm->cfirst[v];
	      i = j - dnA[v] + 1;
	      assert(dnA[v] == 1);
	      Ryoffset0 = cm->sttype[v] == IL_st ? 1 : 0; /* don't allow IL self transits in R mode */
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		Jsc = init_scAA[v][d-sd];
		if(fill_L) Lsc = init_scAA[v][d-sd];
		if(fill_R) {
		  Rsc = init_scAA[v][d]; /* 'd', not 'd-sd', because we won't emit left in R mode */
		  Ralpha[jp_v][v][d] = Rsc; /* this is important b/c if we're an IL, we'll access this cell in the recursion below for Ralpha */
		}

		/* We need to do separate 'for (yoffset...' loops for J
		 * and R matrices, because jp_v == jp_y for all states
		 * here, and for IL states, v can equal y+yoffset (when
		 * yoffset==0).  This means we have to fully calculate
		 * the Jalpha[jp_v][y+yoffset][d] cell (which is
		 * Jalpha[jp_v][v][d]) before we can start to calculate
		 * Ralpha[jp_v][v][d].
		 */
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		  Jsc =            ILogsum(Jsc,         Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		  if(fill_L) Lsc = ILogsum(Lsc,         Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		}
		Jalpha[jp_v][v][d]            =            Jsc + esc_v[dsq[i]];
		if(fill_L) Lalpha[jp_v][v][d] = (d >= 2) ? Lsc + esc_v[dsq[i]] : esc_v[dsq[i]];

		if(fill_R) {
		  for (yoffset = Ryoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Ryoffset0 instead of 0 disallows IL self transits in R mode */
		    Rsc = ILogsum(Rsc, ILogsum(Jalpha[jp_y][y+yoffset][d]      + tsc_v[yoffset],
					       Ralpha[jp_y][y+yoffset][d]      + tsc_v[yoffset]));
		  }
		  Ralpha[jp_v][v][d] = Rsc;
		}
		i--;
	      }
	    } /* end of if(! StateIsDetached(cm, v) */
	  }
	  else if (emitmode == EMITRIGHT) {
	    if(! StateIsDetached(cm, v)) { /* if we're detached (unreachable), leave all {J,L,R}alpha values as they were initialized, as IMPOSSIBLE */
	      y = cm->cfirst[v];
	      assert(dnA[v] == 1);
	      Lyoffset0 = cm->sttype[v] == IR_st ? 1 : 0; /* don't allow IR self transits in L mode */
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		Jsc = init_scAA[v][d-sd];
		if(fill_R) Rsc = init_scAA[v][d-sd];
		if(fill_L) {
		  Lsc = init_scAA[v][d]; /* 'd', not 'd-sd', because we won't emit right in L mode */
		  Lalpha[jp_v][v][d] = Lsc; /* this is important b/c if we're an IR, we'll access this cell in the recursion below for Lalpha */
		}

		/* We need to do separate 'for (yoffset...' loops for J
		 * and L matrices, because jp_v == jq_y for all states
		 * here, and for IR states, v can equal y+yoffset (when
		 * yoffset==0).  This means we have to fully calculate
		 * the Jalpha[jq_y][y+yoffset][d] cell (which is
		 * Jalpha[jp_v][v][d]) before we can start to calculate
		 * Lalpha[jp_v][v][d].
		 */
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		  Jsc            = ILogsum(Jsc,         Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		  if(fill_R) Rsc = ILogsum(Rsc,         Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		}
		Jalpha[jp_v][v][d]            =            Jsc + esc_j;
		if(fill_R) Ralpha[jp_v][v][d] = (d >= 2) ? Rsc + esc_j : esc_j;

		if(fill_L) {
		  for (yoffset = Lyoffset0; yoffset < cm->cnum[v]; yoffset++) { /* using Lyoffset0, instead of 0 disallows IR self transits in L mode */
		    Lsc = ILogsum(Lsc, ILogsum(Jalpha[jq_y][y+yoffset][d]     + tsc_v[yoffset],
					       Lalpha[jq_y][y+yoffset][d]     + tsc_v[yoffset]));
		  }
		  Lalpha[jp_v][v][d] = Lsc;
		}
	      }
	    } /* end of if(! StateIsDetached(cm, v) */
	  }
	  else if (emitmode == EMITPAIR) {
	    y = cm->cfirst[v];
	    i = j - dnA[v] + 1;
	    assert(dnA[v] == 1);
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd];
	      if(fill_L) Lsc = init_scAA[v][d-1]; /* 'd-1', not 'd', because we'll only emit 1 residue in left  mode */
	      if(fill_R) Rsc = init_scAA[v][d-1]; /* 'd-1', not 'd', because we'll only emit 1 residue in right mode */
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc = ILogsum(Jsc,         Jalpha[jp_y][y+yoffset][d - 2] + tsc_v[yoffset]);
		if(fill_L) {
		  Lsc = ILogsum(Lsc, ESL_MAX(Jalpha[jq_y][y+yoffset][d - 1] + tsc_v[yoffset],
					     Lalpha[jq_y][y+yoffset][d - 1] + tsc_v[yoffset]));
		}
		if(fill_R) {
		  Rsc = ILogsum(Rsc, ESL_MAX(Jalpha[jp_y][y+yoffset][d - 1] + tsc_v[yoffset],
					     Ralpha[jp_y][y+yoffset][d - 1] + tsc_v[yoffset]));
		}
	      }
	      Jalpha[jp_v][v][d]            = (d >= 2) ? Jsc + esc_v[dsq[i]*cm->abc->Kp+dsq[j]] : -INFTY;
	      if(fill_L) Lalpha[jp_v][v][d] = (d >= 2) ? Lsc + lmesc_v[dsq[i]]                  : lmesc_v[dsq[i]];
	      if(fill_R) Ralpha[jp_v][v][d] = (d >= 2) ? Rsc + rmesc_j                          : rmesc_j;
	      i--;
	    }
	  }
	  else { /* ! B_st && ! BEGL_S st && ! L_st && ! R_st && ! P_st (emitmode == EMITNONE) */
	    y = cm->cfirst[v];
	    for (d = dnA[v]; d <= dxA[v]; d++) {
	      Jsc = init_scAA[v][d-sd];
	      if(fill_L) Lsc = init_scAA[v][d-sd];
	      if(fill_R) Rsc = init_scAA[v][d-sd];
	      for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
		Jsc            = ILogsum(Jsc, Jalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_L) Lsc = ILogsum(Lsc, Lalpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
		if(fill_R) Rsc = ILogsum(Rsc, Ralpha[jp_y][y+yoffset][d - sd] + tsc_v[yoffset]);
	      }
	      Jalpha[jp_v][v][d] = Jsc;
	      if(fill_L) Lalpha[jp_v][v][d] = Lsc;
	      if(fill_R) Ralpha[jp_v][v][d] = Rsc;
	    }
	  }

	  if(vsc != NULL) {
	    ivsc = -INFTY;
	    if(cm->stid[v] == BEGL_S) {
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		ivsc = ESL_MAX(ivsc, Jalpha_begl[jp_v][v][d]);
		if(fill_L) ivsc = ESL_MAX(ivsc, Lalpha_begl[jp_v][v][d]);
		if(fill_R) ivsc = ESL_MAX(ivsc, Ralpha_begl[jp_v][v][d]);
	      }
	    }
	    else {
	      for (d = dnA[v]; d <= dxA[v]; d++) {
		ivsc = ESL_MAX(ivsc, Jalpha[jp_v][v][d]);
		if(fill_L) ivsc = ESL_MAX(ivsc, Lalpha[jp_v][v][d]);
		if(fill_R) ivsc = ESL_MAX(ivsc, Ralpha[jp_v][v][d]);
		if(cm->stid[v] == BIF_B && fill_T) {
		  ivsc = ESL_MAX(ivsc, Talpha[jp_v][v][d]);
		}
	      }
	    }
	    vsc[v] = Scorify(ivsc);
	  }
#if eslDEBUGLEVEL >= 3
	  /* print alpha matrices - caution: these will be big! */
	  if(cm->stid[v] == BIF_B) {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10d  L: %10d  R: %10d  T: %10d\n",
		     j, v, d,
		     Jalpha[jp_v][v][d],
		     fill_L ? Lalpha[jp_v][v][d] : -INFTY,
		     fill_R ? Ralpha[jp_v][v][d] : -INFTY,
		     fill_T ? Talpha[jp_v][v][d] : -INFTY);
	    }
	  }
	  else if(cm->stid[v] == BEGL_S) {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10d  L: %10d  R: %10d  T: %10d\n",
		     j, v, d,
		     Jalpha_begl[jp_v][v][d],
		     fill_L ? Lalpha_begl[jp_v][v][d] : -INFTY,
		     fill_R ? Ralpha_begl[jp_v][v][d] : -INFTY,
		     -INFTY);
	    }
	  }
	  else {
	    for(d = dnA[v]; d <= dxA[v]; d++) {
	      printf("R j: %3d  v: %3d  d: %3d   J: %10d  L: %10d  R: %10d  T: %10d\n",
		     j, v, d,
		     Jalpha[jp_v][v][d],
		     fill_L ? Lalpha[jp_v][v][d] : -INFTY,
		     fill_R ? Ralpha[jp_v][v][d] : -INFTY,
		     -INFTY);
	    }
	  }
	  printf("\n");
	  #endif
	}  /*loop over decks v>0 */

	  /* Finish up with the ROOT_S, state v=0; and deal w/truncated
	   * begins.  In truncated alignment only way out of ROOT_S in
	   * local or global mode is via a 'truncated begin' with a score
	   * (penalty) from cm->trp into any emitting state. The penalty
	   * differs depending on whether we are in local or global mode
	   * and the value of 'pty_idx' which was determined from
	   * <pass_idx> (passed in). In local mode the penalty includes
	   * the standard local begin probability as part of the
	   * penalty. Penalties are calculated in
	   * cm_tr_penalties_Create().
	   */
	  /* initializations */
	  v = 0;
	  esl_vec_ISet(bestr,  (W+1), 0);
	  esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);
	  for(i = 0; i <= W; i++) bestmode[i] = TRMODE_UNKNOWN;

	  for (y = 1; y < cm->M; y++) {
	itrpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->il_ptyAA[pty_idx][y] : cm->trp->ig_ptyAA[pty_idx][y];
	if(itrpenalty != -INFTY) {
	  assert(cm->stid[y] != BEGL_S);
	  dn = ESL_MAX(dnA[0], dnA[y]);
	  dx = ESL_MIN(dxA[0], dxA[y]);
	  jp_y = cur;
	  /* check for new optimally scoring Joint alignments of all lengths in J matrix */
	  for (d = dn; d <= dx; d++) {
	    sc = Jalpha[jp_y][y][d] + itrpenalty;
	    if (sc > Jalpha[jp_v][0][d]) {
	      Jalpha[jp_v][0][d] = sc;
	      fsc = Scorify(sc);
	      if(fsc > bestsc[d]) {
		bestsc[d]   = fsc;
		bestmode[d] = TRMODE_J;
		bestr[d]    = y;
	      }
	    }
	  }
	  /* check for new optimally scoring Left alignments of all lengths in L matrix */
	  if(fill_L) {
	    for (d = dn; d <= dx; d++) {
	      sc = Lalpha[jp_y][y][d] + itrpenalty;
	      if (sc > Lalpha[jp_v][0][d]) {
		Lalpha[jp_v][0][d] = sc;
		fsc = Scorify(sc);
		if(fsc > bestsc[d]) {
		  bestsc[d]   = fsc;
		  bestmode[d] = TRMODE_L;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	  /* check for new optimally scoring Right alignments of all lengths in L matrix */
	  if(fill_R) {
	    for (d = dn; d <= dx; d++) {
	      sc = Ralpha[jp_y][y][d] + itrpenalty;
	      if (sc > Ralpha[jp_v][0][d]) {
		Ralpha[jp_v][0][d] = sc;
		fsc = Scorify(sc);
		if(fsc > bestsc[d]) {
		  bestsc[d]   = fsc;
		  bestmode[d] = TRMODE_R;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	  /* check for new optimally scoring Terminal alignments of all lengths in T matrix */
	  if(fill_T && cm->sttype[y] == B_st) {
	    for (d = dn; d <= dx; d++) {
	      sc = Talpha[jp_y][y][d] + itrpenalty;
	      if (sc > Talpha[jp_v][0][d]) {
		Talpha[jp_v][0][d] = sc;
		fsc = Scorify(sc);
		if(fsc > bestsc[d]) {
		  bestsc[d]   = fsc;
		  bestmode[d] = TRMODE_T;
		  bestr[d]    = y;
		}
	      }
	    }
	  }
	}
	  }

	  /* update the best score (in any mode) stored in vsc_root */
	  for (d = dnA[0]; d <= dxA[0]; d++) {
	if(bestsc[d] > vsc_root) {
	  vsc_root   = bestsc[d];
	  vmode_root = bestmode[d];
	}
	  }
	  /* find the best score (in any mode) that spans the full sequence */
	  if(j == j0) {
	if(bestsc[j] > bsc_full) {
	  bsc_full   = bestsc[j];
	  bmode_full = bestmode[j];
	}
	  }
	  /* update envi, envj, if nec */
	  if(do_env_defn) {
	for (d = dnA[0]; d <= dxA[0]; d++) {
	  if(bestsc[d] >= env_cutoff) {
	    envi = ESL_MIN(envi, j-d+1);
	    envj = ESL_MAX(envj, j);
	  }
	}
	  }

	  /* done with this endpoint j, if necessary, update gamma or tmp_hitlist */
	  if(gamma != NULL) {
	if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, dnA[0], dxA[0], bestsc, bestr, bestmode, W, act)) != eslOK) return status;
	  }
	  if(tmp_hitlist != NULL) {
	if((status = ReportHitsGreedily(cm, errbuf, pass_idx,        j, dnA[0], dxA[0], bestsc, bestr, bestmode, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	  }

	  /* cm_DumpScanMatrixAlpha(cm, si, j, i0, TRUE); */
	} /* end loop over end positions j */

  if(vsc != NULL) vsc[0] = vsc_root;

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  /* clean up and return */
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }
  free(jp_wA);
  free(init_scAA[0]);
  free(init_scAA);
  if (ret_vsc != NULL) *ret_vsc = vsc;
  else if(vsc != NULL) free(vsc);
  if (ret_sc   != NULL) *ret_sc   = vsc_root;
  if (ret_mode != NULL) *ret_mode = vmode_root;

  ESL_DPRINTF1(("RefITrInsideScan() return score: %10.4f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* NEVERREACHED */
}

/* Function: TrCYKScanHB()
 * Incept:   EPN, Thu Aug 25 15:19:28 2011
 *
 * Purpose:  An HMM banded scanning TrCYK implementation. Takes a
 *           CM_TR_HB_MX data structure which is indexed [v][j][d]
 *           with only cells within the bands allocated (different
 *           than other (non-HB) scanning function's convention of
 *           [j][v][d]). QDBs are not used.
 *
 *           This function is very similar to FTrInsideScanHB(). Any changes
 *           should be mirrored there.
 *
 *           This version is not prefixed with 'Fast' because I didn't
 *           successfully optimize it. There are if statements such as
 *           (do_J_v) in the lowest (for d) loops of the recursion which
 *           seem like they should be able to be changed to get a faster
 *           implementation. However, I was unsuccessful in making it
 *           noticeably faster. It may be possible to accelerate with
 *           a significant overhaul, but since it is not the rate limiting
 *           step currently (CP9 band determination is about 5-10X slower)
 *           there's no motivation to do that now.
 *
 * Args:     cm        - the model    [0..M-1]
 *           errbuf    - for returning error messages
 *           mx        - the dp matrix, only cells within bands in cm->cp9b will be valid.
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           pass_idx  - pipeline pass index, tells us which modes to allow and trunc penalties to use
 *           dsq       - the sequence [1..(j0-i0+1)]
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           cutoff    - minimum score to report
 *           hitlist   - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3  - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff- ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi  - RETURN: min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj  - RETURN: max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_mode  - RETURN: mode of best overall hit (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc    - RETURN: score of best overall hit
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEINCONCEIVABLE if bands allow a hit > L, errbuf filled.
 *           eslEINVAL if no marginal mode is allowed for state 0, given the bands, errbuf filled.
 *           eslERANGE if required HMM banded matrix size exceeds <size_limit>, errbuf filled.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
TrCYKScanHB(CM_t *cm, char *errbuf, CM_TR_HB_MX *mx, float size_limit, int pass_idx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
	    int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, char *ret_mode, float *ret_sc)
{
  int      status;
  GammaHitMx_t *gamma = NULL;  /* semi-HMM for hit resoultion */
  float    sc;                 /* a temporary score */
  int     *bestr;              /* best root state for d at current j */
  char    *bestmode;           /* best mode for parsetree for d at current j */
  float   *bestsc;             /* best score for parsetree for d at current j */
  int      v,y,z;	       /* indices for states  */
  int      j,d,i,k;            /* indices in sequence dimensions */
  float    Lsc, Rsc;           /* temporary scores */
  int      yoffset;	       /* y=base+offset -- counter in child states that v can transit to */
  int     *yvalidA;            /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;             /* [0..d..W-1] probability of local end emissions of length d */
  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      sd;                 /* StateDelta(cm->sttype[v]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[v] */
  int      sdr;                /* StateRightDelta(cm->sttype[v] */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y, dp_z;   /* offset d index for states v, y, z */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dp_y_sdr;           /* dp_y - sdr, often for jp_y_sdr */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  float    vsc_root = IMPOSSIBLE; /* score of best hit */
  float    vmode_root;         /* alignment mode of best overall alignment (that has score = vsc_root) */
  float    bsc_full;           /* score of best hit that emits full sequence i0..j0 */
  float    bmode_full;         /* alignment mode of best overall parse that emits full sequence */
  int      W;                  /* max d over all hdmax[v][j] for all valid v, j */
  double **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int      jp;                 /* j index in act */
  int      do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t  envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* variables specific to truncated scanning */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z, do_J_0; /* is J matrix valid for state v, y, z, 0? */
  int      do_L_v, do_L_y, do_L_z, do_L_0; /* is L matrix valid for state v, y, z, 0? */
  int      do_R_v, do_R_y, do_R_z, do_R_0; /* is R matrix valid for state v, y, z, 0? */
  int      do_T_v, do_T_y, do_T_z, do_T_0; /* is T matrix valid for state v, y, z, 0? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* Contract check */
  if(dsq == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "TrCYKScanHB(), dsq is NULL.\n");
  if (mx == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "TrCYKScanHB(), mx is NULL.\n");
  if (cm->cp9b == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "TrCYKScanHB(), cm->cp9 is NULL.\n");

  ESL_DPRINTF1(("cm->search_opts & CM_SEARCH_HMMALNBANDS: %d\n", cm->search_opts & CM_SEARCH_HMMALNBANDS));

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b   = cm->cp9b;
  int        *jmin   = cp9b->jmin;
  int        *jmax   = cp9b->jmax;
  int       **hdmin  = cp9b->hdmin;
  int       **hdmax  = cp9b->hdmax;

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* from <pass_idx>: determine which matrices we need to fill in and
   * the appropriate truncation penalty index to use.
   */
  if((status = cm_TrFillFromPassIdx(pass_idx, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status,       errbuf, "TrCYKScanHB(), unexpected pass idx: %d", pass_idx);
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1)                        ESL_FAIL(eslEINCOMPAT, errbuf, "TrCYKScanHB(), unexpected pass idx: %d", pass_idx);

  /* ensure an alignment to ROOT_S (v==0) is possible */
  if (! (cp9b->Jvalid[0] || (fill_L && cp9b->Lvalid[0]) || (fill_R && cp9b->Rvalid[0]) || (fill_T &&cp9b->Tvalid[0]))) {
	ESL_FAIL(eslEINVAL, errbuf, "TrCYKScanHB(): no marginal mode is allowed for state 0");
  }

  /* Allocations and initializations  */
  /* grow the matrix based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo(cm, mx, errbuf, cp9b, (j0-i0+1), size_limit)) != eslOK) return status;

  /* set W as j0-i0+1 (this may exceed max size of a hit our bands will allow,
   * but that's okay b/c W is only used for sizing of act and bestr vectors */
  W = j0-i0+1;
  /* make sure our bands won't allow a hit bigger than W (this could be modified to only execute in debugging mode) */
  for(j = jmin[0]; j <= jmax[0]; j++) {
	if(W < (hdmax[0][(j-jmin[0])])) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "TrCYKScanHB(), band allows a hit (j:%d hdmax[0][j]:%d) greater than j0-i0+1 (%" PRId64 ")", j, hdmax[0][(j-jmin[0])], j0-i0+1);
  }

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (W+1));
  for(d = 0; d <= W; d++) el_scA[d] = cm->el_selfsc * d;

  /* allocate bestr, bestsc, bestmode arrays */
  ESL_ALLOC(bestr,    sizeof(int)   * (W+1));
  ESL_ALLOC(bestsc,   sizeof(float) * (W+1));
  ESL_ALLOC(bestmode, sizeof(char)  * (W+1));

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0)           esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(j0-i0+1, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
	/* pre-fill act, different than non-HMM banded scanner b/c our main loop doesn't step j through residues */
	for(j = i0; j <= j0; j++) {
	  jp = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (j index for act) */
	  esl_vec_DCopy(act[(jp-1)%(W+1)], cm->abc->K, act[jp%(W+1)]);
	  esl_abc_DCount(cm->abc, act[jp%(W+1)], dsq[j], 1.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost to ROOT_S, we handle that differently */
	float const *esc_v   = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v   = cm->tsc[v];  /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v]; /* marginal left  emission scores for state v */
	float const *rmesc_v = cm->rmesc[v]; /* marginal right emission scores for state v */
	sd     = StateDelta(cm->sttype[v]);
	sdl    = StateLeftDelta(cm->sttype[v]);
	sdr    = StateRightDelta(cm->sttype[v]);
	jn     = jmin[v];
	jx     = jmax[v];
	do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	/* re-initialize the J, L and R decks if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	if(do_J_v) {
	  if(hdmin[v][jp_v] >= sd) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sd;
	    dp_v = sd - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Jalpha[v][jp_v][dp_v] = el_scA[d-sd]  + cm->endsc[v];
	  }
	}
	if(do_L_v) {
	  if(hdmin[v][jp_v] >= sdl) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdl;
	    dp_v = sdl - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Lalpha[v][jp_v][dp_v] = el_scA[d-sdl]  + cm->endsc[v];
	  }
	}
	if(do_R_v) {
	  if(hdmin[v][jp_v] >= sdr) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdr;
	    dp_v = sdr - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Ralpha[v][jp_v][dp_v] = el_scA[d-sdr]  + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	if(do_J_v) Jalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_L_v) Lalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_R_v) Ralpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IL states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1]
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i    = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	  /* We need to treat R differently from and J and L here, by
	   * doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][jp_v][dp_v])
	   * before we can start to calculate Ralpha[v][jp_v][dp_v].
	   */
	  /* Handle J and L first */
	  if(do_J_v || do_L_v) {
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	      if(do_J_y || do_L_y) {
		jp_y_sdr = j - jmin[y] - sdr;

		if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		}
	      }
	    }
	    if(do_J_v) {
	      Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]];
	      Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    if(do_L_v) {
	      Lalpha[v][jp_v][dp_v] = (d >= 2) ? Lalpha[v][jp_v][dp_v] + esc_v[dsq[i]]: esc_v[dsq[i]];
	      Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    i--;
	  }

	  if(do_R_v) {
	    /* Handle R separately */
	    Rsc = Ralpha[v][jp_v][dp_v]; /* this sc will be IMPOSSIBLE */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      if((do_J_y || do_R_y) && (y != v)) { /* (y != v) part is to disallow IL self transits in R mode */
		jp_y_sdr = j - jmin[y] - sdr;

		/* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,L above) */
		if((d) >= hdmin[y][jp_y_sdr] && (d) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y = d - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_y) Rsc = ESL_MAX(Rsc, Jalpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		  if(do_R_y) Rsc = ESL_MAX(Rsc, Ralpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		}
	      }
	    } /* end of for (yvalid_idx = 0... loop */
	    Ralpha[v][jp_v][dp_v] = Rsc;
	    /* we use Rsc instead of Ralpha cell in above loop because
	     * Ralpha[v][jp_v][dp_v] may be the same cell as
	     * Ralpha[y][jp_y_sdr][dp_y] if we're an IL state
	     */
	  }
	}
	  }
	}
	else if(cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IR states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1].
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */

	  /* The first MR_st/IR_st 'for (j...' loop is for J and R matrices which use the same set of j values */
	  if(do_J_v || do_R_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;
	  j_sdr = j - sdr;

	  /* determine which children y we can legally transit to for v, j */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    /* We need to treat L differently from and J and R here, by
	     * doing separate 'for (yoffset...' loops for J because we
	     * have to fully calculate Jalpha[v][jp_v][dp_v]) before we
	     * can start to calculate Lalpha[v][jp_v][dp_v].
	     */
	    /* Handle J and R first */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	      if(do_J_y || do_R_y) {
		jp_y_sdr = j - jmin[y] - sdr;

		if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		}
	      }
	    }
	    if(do_J_v) {
	      Jalpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	      Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    if(do_R_v) {
	      Ralpha[v][jp_v][dp_v] = (d >= 2) ? Ralpha[v][jp_v][dp_v] + esc_v[dsq[j]] : esc_v[dsq[j]];
	      Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	  }
	}
	  }
	  /* Handle L separately */
	  if(do_L_v) {
	/* The second MR_st/IR_st 'for (j...' loop is for the L matrix which use a different set of j values */
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;

	  /* determine which children y we can legally transit to for v, j */
	  /* we use 'j' and not 'j_sdr' here for the L matrix, differently from J and R matrices above */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if(y != v       && /* y == v when yoffset == 0 && v is an IR state: we don't want to allow IR self transits in L mode */
	       j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j is valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    Lsc = Lalpha[v][jp_v][dp_v]; /* this sc will be IMPOSSIBLE */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      /* Note if we're an IL state, we can't self transit in R mode, this was ensured above when we set up yvalidA[] (xref:ELN3,p5)*/
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      if(do_L_y || do_J_y) {
		/* we use 'jp_y=j-min[y]' here, not 'jp_y_sdr=j-jmin[y]-sdr' (which we used in the corresponding loop for J,R above) */
		jp_y = j - jmin[y];

		/* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,R above) */
		if((d) >= hdmin[y][jp_y] && (d) <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		  dp_y = d - hdmin[y][jp_y];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		  if(do_J_y) Lsc = ESL_MAX(Lsc, Jalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		  if(do_L_y) Lsc = ESL_MAX(Lsc, Lalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		}
	      }
	    } /* end of for (yvalid_idx = 0... loop */
	    Lalpha[v][jp_v][dp_v] = Lsc;
	    /* we use Lsc instead of Lalpha cell in above loop because
	     * Lalpha[v][jp_v][dp_v] may be the same cell as
	     * Lalpha[y][jp_y_sdr][dp_y] if we're an IR state
	     */
	  }
	}
	  }
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* The first MP_st 'for (jp_v...' loop is for J and R matrices which use the same set of j values */
	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;
	/* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	if((do_J_v && do_J_y) || (do_R_v && (do_J_y || do_R_y))) {
	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    if(do_J_v && do_J_y) {
	      /* J matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sd   = dn - hdmin[y][jp_y_sdr] - sd;

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
		ESL_DASSERT1((dp_v      >= 0 && dp_v       <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y_sd   >= 0 && dp_y_sd    <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      }
	    }

	    if(do_R_v && (do_R_y || do_J_y)) {
	      /* R matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sdr);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sdr);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sdr  = dn - hdmin[y][jp_y_sdr] - sdr;
	      /* for {L,R}alpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		/* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
		ESL_DASSERT1((dp_y_sdr  >= 0 && dp_y_sdr   <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		if(do_J_y) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sdr] + tsc);
		if(do_R_y) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sdr] + tsc);
	      }
	    }
	  }
	}

	if(do_L_v && (do_L_y || do_J_y)) {
	  /* The second MP_st 'for (jp_v...' loop is for L matrix, which uses a different set of j values from J and R */
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y] (follows from (j >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y] (follows from (j <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y = jn - jmin[y];
	  /* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y     >= 0 && jp_y     <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	   * d >= hdmin[v][jp_v]
	   * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	   * d <= hdmax[v][jp_v]
	   * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	   * this reduces to two ESL_MAX calls
	   */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y] + sdr);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y] + sdr);
	    dpn       = dn - hdmin[v][jp_v];
	    dpx       = dx - hdmin[v][jp_v];
	    dp_y_sdr  = dn - hdmin[y][jp_y] - sdr;
	    /* for Lalpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
	      /* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
	      ESL_DASSERT1((dp_y_sdr >= 0 && dp_y_sdr  <= (hdmax[y][jp_y]     - hdmin[y][jp_y])));
	      if(do_J_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y_sdr] + tsc);
	      if(do_L_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y_sdr] + tsc);
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	i     = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++)
	  {
	    /*if(i < i0 || j > j0) {
	      printf("dsq[i:%d]: %d\n", i, dsq[i]);
	      printf("dsq[j:%d]: %d\n", j, dsq[j]);
	      printf("esc_v[%d]: %.5f\n", dsq[i]*cm->abc->Kp+dsq[j], esc_v[dsq[i]*cm->abc->Kp+dsq[j]]);;
	      printf("i0: %" PRId64 " j0: %" PRId64 "\n", i0, j0);
	      }*/
	    if(d >= 2) {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	      if(do_L_v) Lalpha[v][jp_v][dp_v] += lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] += rmesc_v[dsq[j]];
	    }
	    else {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      if(do_L_v) Lalpha[v][jp_v][dp_v] = lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] = rmesc_v[dsq[j]];
	    }
	    i--;
	  }
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	  if(do_J_v) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_L_v) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_R_v) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S (! E && ! B && ! ML && ! IL && ! MR && ! IR) */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	if((do_J_v && do_J_y) || (do_L_v && do_L_y) || (do_R_v && do_R_y)) {
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	  jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y_sdr = jn - jmin[y] - sdr;

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	    dpn     = dn - hdmin[v][jp_v];
	    dpx     = dx - hdmin[v][jp_v];
	    dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc);

	      /* an easy to overlook case: if d == 0, ensure L and R values are IMPOSSIBLE */
	      if(dp_v == dpn && dn == 0) { /* d is 0 */
		if(do_L_v) Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		if(do_R_v) Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      }
	    }
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	  do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	  do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	  do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	  do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;
	  do_T_z = cp9b->Tvalid[z] && fill_T ? TRUE : FALSE; /* will be FALSE, z is not a B_st */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	i = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the {J,L,R} matrix y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop)) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   *
	   * To update a cell in the T matrix with a sum of an R matrix value for y
	   * and a L matrix value for z, there are 2 additional inequalities to satisfy:
	   * (7) k != 0
	   * (8) k != d
	   * We ensure 7 and 8 in the loop below.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      if(do_J_v && do_J_y && do_J_z) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if(do_L_v && do_J_y && do_L_z) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      if(do_R_v && do_R_y && do_J_z) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if(k != 0 && k != d) {
		if(do_T_v && do_R_y && do_L_z) Talpha[v][jp_v][dp_v] = ESL_MAX(Talpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      }
	    }
	  }
	}
	  }

	  /* two additional special cases in trCYK (these are not in standard CYK).
	   * we do these in their own for(j.. { for(d.. { } } loops b/c one
	   * is independent of z, the other of y, unlike the above loop which is dependent
	   * on both.
	   */
	  if(do_L_v && (do_J_y || do_L_y)) {
	jn = (jmin[v] > jmin[y]) ? jmin[v] : jmin[y];
	jx = (jmax[v] < jmax[y]) ? jmax[v] : jmax[y];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[y] && j <= jmax[y]));
	  dn = (hdmin[v][jp_v] > hdmin[y][jp_y]) ? hdmin[v][jp_v] : hdmin[y][jp_y];
	  dx = (hdmax[v][jp_v] < hdmax[y][jp_y]) ? hdmax[v][jp_v] : hdmax[y][jp_y];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_y = d - hdmin[y][jp_y];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]));
	    if(do_J_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y]);
	    if(do_L_y) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y]);
	  }
	}
	  }
	  if(do_R_v && (do_J_z || do_R_z)) {
	jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_z = j - jmin[z];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[z] && j <= jmax[z]));
	  dn = (hdmin[v][jp_v] > hdmin[z][jp_z]) ? hdmin[v][jp_v] : hdmin[z][jp_z];
	  dx = (hdmax[v][jp_v] < hdmax[z][jp_z]) ? hdmax[v][jp_v] : hdmax[z][jp_z];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_z = d - hdmin[z][jp_z];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]));
	    if(do_J_z) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Jalpha[z][jp_z][dp_z]);
	    if(do_R_z) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], Ralpha[z][jp_z][dp_z]);
	  }
	}
	  }
	} /* finished calculating deck v. */
#if eslDEBUGLEVEL >= 3
	  /* print alpha matrices - caution: these will be big! */
	  if(cm->stid[v] == BIF_B) {
	    /* the main j loop */
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Tvalid[v] && NOT_IMPOSSIBLE(Talpha[v][jp_v][dp_v])) ? Talpha[v][jp_v][dp_v] : -9999.9);
	      }
	    }
	  }
	  if((cm->stid[v] == BEGL_S) || (cm->stid[v] == BEGR_S)) {
	    /* the main j loop */
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       -9999.9);
	      }
	    }
	  }
	  else {
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       -9999.9);
	      }
	    }
	  }
	  printf("\n");
#endif
  } /* end of for (v = cm->M-1; v > 0; v--) */

  /* update gamma, by specifying all hits with j < jmin[0] are impossible */
  if(gamma != NULL) {
	for(j = i0; j < jmin[v]; j++) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, -1, -1,
				      NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				      bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  /* Now handle from ROOT_S, state 0. So far we haven't touched
   * the {J,L,R,T}alpha[0] decks at all since initialization and here
   * we'll only update at most 1 cell in each, the one pertaining
   * to a full alignment [0][L][L].
   *
   * In truncated alignment the only way out of ROOT_S in local or
   * global mode is via a 'truncated begin' with a score (penalty)
   * from cm->trp into any emitting state. The penalty was calculated
   * in cm_tr_penalties_Create() and differs depending on whether we
   * are in local or global mode and the value of 'pty_idx' which was
   * determined by the passed in value <pass_idx>.
   *
   * We also determine best* arrays here for reporting hits.
   */

  do_J_0 = cp9b->Jvalid[0]           ? TRUE : FALSE;
  do_L_0 = cp9b->Lvalid[0] && fill_L ? TRUE : FALSE;
  do_R_0 = cp9b->Rvalid[0] && fill_R ? TRUE : FALSE;
  do_T_0 = cp9b->Tvalid[0] && fill_T ? TRUE : FALSE;

  v = 0;
  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	/* initialize bestr, bestsc, bestmode */
	esl_vec_ISet(bestr,  (W+1), 0); /* init bestr to 0, all hits are rooted at 0 unless we find a better local begin below */
	esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);
	for(i = 0; i <= W; i++) bestmode[i] = TRMODE_UNKNOWN;

	for (y = 1; y < cm->M; y++) {
	  trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][y] : cm->trp->g_ptyAA[pty_idx][y];
	  if(NOT_IMPOSSIBLE(trpenalty) &&
	 (j >= jmin[y] && j <= jmax[y])) {  /* j is within state y's band */
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE;

	jp_y = j - jmin[y];
	dn   = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	dx   = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);

	if(do_J_0 && do_J_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Jalpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Jalpha[0][jp_v][dp_v]) {
	      Jalpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_J;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_L_0 && do_L_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Lalpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Lalpha[0][jp_v][dp_v]) {
	      Lalpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_L;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_R_0 && do_R_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Ralpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Ralpha[0][jp_v][dp_v]) {
	      Ralpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_R;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_T_0 && do_T_y && cm->sttype[y] == B_st) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Talpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Talpha[0][jp_v][dp_v]) {
	      Talpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_T;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	  }
	}

	/* if necessary, report all hits with valid d for this j, either to gamma or tmp_hitlist */
	if(gamma != NULL) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, bestmode, W, act)) != eslOK) return status;
	}
	if(tmp_hitlist != NULL) {
	  if((status = ReportHitsGreedily(cm, errbuf, pass_idx,        j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, bestmode, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	}
  } /* end of 'for (j = jmin[v]; j <= jmax[v]'... */
  /*FILE *fp1; fp1 = fopen("tmp.ismx", "w");   cm_tr_hb_mx_Dump(fp1, mx); fclose(fp1);*/

  /* update gamma, by specifying all hits with j > jmax[0] are impossible */
  if(gamma != NULL) {
	for(j = jmax[v]+1; j <= j0; j++) {
	  if((status = UpdateGammaHitMx(cm, errbuf, pass_idx, gamma, j, -1, -1,
				    NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				    bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  /* find the best scoring hit, and update envelope boundaries if nec */
  vsc_root   = IMPOSSIBLE;
  vmode_root = TRMODE_UNKNOWN;
  bsc_full   = IMPOSSIBLE;
  bmode_full = TRMODE_UNKNOWN;
  v = 0;
  jpn = 0;
  jpx = jmax[v] - jmin[v];
  for(jp_v = jpn; jp_v <= jpx; jp_v++) {
	dpn     = 0;
	dpx     = hdmax[v][jp_v] - hdmin[v][jp_v];
	for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	  if(do_J_0 && Jalpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Jalpha[0][jp_v][dp_v];
	vmode_root = TRMODE_J;
	  }
	  if(do_L_0 && Lalpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Lalpha[0][jp_v][dp_v];
	vmode_root = TRMODE_L;
	  }
	  if(do_R_0 && Ralpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Ralpha[0][jp_v][dp_v];
	vmode_root = TRMODE_R;
	  }
	  if(do_T_0 && Talpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Talpha[0][jp_v][dp_v];
	vmode_root = TRMODE_T;
	  }
	}
	/* update envelope boundaries, if nec */
	if(do_env_defn) {
	  j = jp_v + jmin[v];
	  for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	if((do_J_0 && Jalpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_L_0 && Lalpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_R_0 && Ralpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_T_0 && Talpha[0][jp_v][dp_v] >= env_cutoff)) {
	  i = j - (dp_v + hdmin[v][jp_v]) + 1;
	  envi = ESL_MIN(envi, i);
	  envj = ESL_MAX(envj, j);
	}
	  }
	}
  }
  /* find the best score and mode that spans the full sequence */
  if(j0 >= jmin[0] && j0 <= jmax[0]) {
	jp_v = j0-jmin[0];
	if(W >= hdmin[0][jp_v] && W <= hdmax[0][jp_v]) {
	  dp_v = W-hdmin[0][jp_v];
	  if(do_J_0 && Jalpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Jalpha[0][jp_v][dp_v];
	bmode_full = TRMODE_J;
	  }
	  if(do_L_0 && Lalpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Lalpha[0][jp_v][dp_v];
	bmode_full = TRMODE_L;
	  }
	  if(do_R_0 && Ralpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Ralpha[0][jp_v][dp_v];
	bmode_full = TRMODE_R;
	  }
	  if(do_T_0 && Talpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Talpha[0][jp_v][dp_v];
	bmode_full = TRMODE_T;
	  }
	}
  }

  free(el_scA);
  free(yvalidA);
  free(bestr);
  free(bestmode);
  free(bestsc);
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	/*cm_tophits_Dump(stdout, tmp_hitlist);*/
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	/*cm_tophits_Dump(stdout, hitlist);*/
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set return values */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }
  if(ret_sc   != NULL) { *ret_sc   = vsc_root;   }
  if(ret_mode != NULL) { *ret_mode = vmode_root; }

  ESL_DPRINTF1(("TrCYKScanHB() return sc: %f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return status; /* never reached */
}

/* Function: FTrInsideScanHB()
 * Incept:   EPN, Wed Sep  7 11:31:29 2011
 *
 * Purpose:  An HMM banded scanning TrInside implementation. Takes a
 *           CM_TR_HB_MX data structure which is indexed [v][j][d]
 *           with only cells within the bands allocated (different
 *           than other (non-HB) scanning function's convention of
 *           [j][v][d]). QDBs are not used.
 *
 *           This function is very similar to TrCYKScanHB(). Any changes
 *           should be mirrored there.
 *
 *           This version is not prefixed with 'Fast' because I didn't
 *           successfully optimize it. There are if statements such as
 *           (do_J_v) in the lowest (for d) loops of the recursion which
 *           seem like they should be able to be changed to get a faster
 *           implementation. However, I was unsuccessful in making it
 *           noticeably faster. It may be possible to accelerate with
 *           a significant overhaul, but since it is not the rate limiting
 *           step currently (CP9 band determination is about 5-10X slower)
 *           there's no motivation to do that now.
 *
 * Args:     cm        - the model    [0..M-1]
 *           errbuf    - for returning error messages
 *           mx        - the dp matrix, only cells within bands in cm->cp9b will be valid.
 *           size_limit- max number of Mb for DP matrix, if matrix is bigger return eslERANGE
 *           pass_idx  - pipeline pass index, tells us which modes to allow and trunc penalties to use
 *           dsq       - the sequence [1..(j0-i0+1)]
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           cutoff    - minimum score to report
 *           hitlist   - CM_TOPHITS hitlist to add to; if NULL, don't add to it
 *           do_null3  - TRUE to do NULL3 score correction, FALSE not to
 *           env_cutoff- ret_envi..ret_envj will include all hits that exceed this bit sc
 *           ret_envi  - min position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_envj  - max position in any hit w/sc >= env_cutoff, set to -1 if no such hits exist, NULL if not wanted
 *           ret_mode  - RETURN: mode of best overall hit (TRMODE_J | TRMODE_L | TRMODE_R | TRMODE_T)
 *           ret_sc    - RETURN: score of best overall hit (vsc[0])
 *
 * Returns:  eslOK on success and RETURN variables updated (or not if NULL).
 *           eslEINCOMPAT on contract violation, errbuf if filled with informative error message.
 *           eslEINVAL if no marginal mode is allowed for state 0, given the bands, errbuf filled.
 *           eslEINCONCEIVABLE if bands allow a hit > L, errbuf filled.
 *           eslERANGE if required HMM banded matrix size exceeds <size_limit>, errbuf filled.
 *           eslEMEM if out of memory, errbuf if filled with informative error message.
 */
int
FTrInsideScanHB(CM_t *cm, char *errbuf, CM_TR_HB_MX *mx, float size_limit, int pass_idx, ESL_DSQ *dsq, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist,
		int do_null3, float env_cutoff, int64_t *ret_envi, int64_t *ret_envj, char *ret_mode, float *ret_sc)
{
  int      status;
  GammaHitMx_t *gamma = NULL;  /* semi-HMM for hit resoultion */
  float    sc;                 /* a temporary score */
  int     *bestr;              /* best root state for d at current j */
  char    *bestmode;           /* best mode for parsetree for d at current j */
  float   *bestsc;             /* best score for parsetree for d at current j */
  int      v,y,z;	       /* indices for states  */
  int      j,d,i,k;	       /* indices in sequence dimensions */
  float    Lsc, Rsc;           /* temporary scores */
  int      yoffset;	       /* y=base+offset -- counter in child states that v can transit to */
  int     *yvalidA;            /* [0..MAXCONNECT-1] TRUE if v->yoffset is legal transition (within bands) */
  float   *el_scA;             /* [0..d..W-1] probability of local end emissions of length d */
  /* indices used for handling band-offset issues, and in the depths of the DP recursion */
  int      sd;                 /* StateDelta(cm->sttype[v]) */
  int      sdl;                /* StateLeftDelta(cm->sttype[v] */
  int      sdr;                /* StateRightDelta(cm->sttype[v] */
  int      jp_v, jp_y, jp_z;   /* offset j index for states v, y, z */
  int      jp_y_sdr;           /* jp_y - sdr */
  int      j_sdr;              /* j - sdr */
  int      jn, jx;             /* current minimum/maximum j allowed */
  int      jpn, jpx;           /* minimum/maximum jp_v */
  int      dp_v, dp_y, dp_z;   /* offset d index for states v, y, z */
  int      dn, dx;             /* current minimum/maximum d allowed */
  int      dp_y_sd;            /* dp_y - sd */
  int      dp_y_sdr;           /* dp_y - sdr, often for jp_y_sdr */
  int      dpn, dpx;           /* minimum/maximum dp_v */
  int      kp_z;               /* k (in the d dim) index for state z in alpha w/mem eff bands */
  int      kn, kx;             /* current minimum/maximum k value */
  float    tsc;                /* a transition score */
  int      yvalid_idx;         /* for keeping track of which children are valid */
  int      yvalid_ct;          /* for keeping track of which children are valid */
  float    vsc_root = IMPOSSIBLE; /* score of best hit */
  float    vmode_root;         /* alignment mode of best overall alignment (that has score = vsc_root) */
  float    bsc_full;           /* best overall score that emits full sequence i0..j0 */
  float    bmode_full;         /* alignment mode of best overall parse that emits full sequence */
  int      W;                  /* max d over all hdmax[v][j] for all valid v, j */
  double **act;                /* [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1) */
  int      jp;                 /* j index in act */
  int      do_env_defn;        /* TRUE to calculate envi, envj, FALSE not to (TRUE if ret_envi != NULL or ret_envj != NULL */
  int64_t  envi, envj;         /* min/max positions that exist in any hit with sc >= env_cutoff */
  CM_TOPHITS *tmp_hitlist = NULL; /* temporary hitlist, containing possibly overlapping hits */
  int       h;                  /* counter over hits */

  /* variables specific to truncated scanning */
  int      fill_L, fill_R, fill_T; /* must we fill in the L, R, and T matrices? */
  int      do_J_v, do_J_y, do_J_z, do_J_0; /* is J matrix valid for state v, y, z, 0? */
  int      do_L_v, do_L_y, do_L_z, do_L_0; /* is L matrix valid for state v, y, z, 0? */
  int      do_R_v, do_R_y, do_R_z, do_R_0; /* is R matrix valid for state v, y, z, 0? */
  int      do_T_v, do_T_y, do_T_z, do_T_0; /* is T matrix valid for state v, y, z, 0? */
  int      pty_idx;                /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;              /* truncation penalty, differs based on pty_idx and if we're local or global */

  /* Contract check */
  if(dsq == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FTrInsideScanHB(), dsq is NULL.\n");
  if (mx == NULL)       ESL_FAIL(eslEINCOMPAT, errbuf, "FTrInsideScanHB(), mx is NULL.\n");
  if (cm->cp9b == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "FTrInsideScanHB(), cm->cp9b is NULL.\n");

  ESL_DPRINTF1(("cm->search_opts & CM_SEARCH_HMMALNBANDS: %d\n", cm->search_opts & CM_SEARCH_HMMALNBANDS));

  /* variables used for memory efficient bands */
  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b   = cm->cp9b;
  int        *jmin   = cp9b->jmin;
  int        *jmax   = cp9b->jmax;
  int       **hdmin  = cp9b->hdmin;
  int       **hdmax  = cp9b->hdmax;

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* from <pass_idx>: determine which matrices we need to fill in and
   * the appropriate truncation penalty index to use.
   */
  if((status = cm_TrFillFromPassIdx(pass_idx, &fill_L, &fill_R, &fill_T)) != eslOK) ESL_FAIL(status,       errbuf, "FTrInsideScanHB(), unexpected pass idx: %d", pass_idx);
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1)                        ESL_FAIL(eslEINCOMPAT, errbuf, "FTrInsideScanHB(), unexpected pass idx: %d", pass_idx);

  /* ensure an alignment to ROOT_S (v==0) is possible */
  if (! (cp9b->Jvalid[0] || (fill_L && cp9b->Lvalid[0]) || (fill_R && cp9b->Rvalid[0]) || (fill_T &&cp9b->Tvalid[0]))) {
	ESL_FAIL(eslEINVAL, errbuf, "FTrInsideScanHB(): no marginal mode is allowed for state 0");
  }

  /* Allocations and initializations  */
  /* grow the matrix based on the current sequence and bands */
  if((status = cm_tr_hb_mx_GrowTo(cm, mx, errbuf, cp9b, (j0-i0+1), size_limit)) != eslOK) return status;

  /* set W as j0-i0+1 (this may exceed max size of a hit our bands will allow,
   * but that's okay b/c W is only used for sizing of act and bestr vectors */
  W = j0-i0+1;
  /* make sure our bands won't allow a hit bigger than W (this could be modified to only execute in debugging mode) */
  for(j = jmin[0]; j <= jmax[0]; j++) {
	if(W < (hdmax[0][(j-jmin[0])])) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "FTrInsideScanHB(), band allows a hit (j:%d hdmax[0][j]:%d) greater than j0-i0+1 (%" PRId64 ")", j, hdmax[0][(j-jmin[0])], j0-i0+1);
  }

  /* precalcuate all possible local end scores, for local end emits of 1..W residues */
  ESL_ALLOC(el_scA, sizeof(float) * (W+1));
  for(d = 0; d <= W; d++) el_scA[d] = cm->el_selfsc * d;

  /* allocate bestr, bestsc, bestmode arrays */
  ESL_ALLOC(bestr,    sizeof(int)   * (W+1));
  ESL_ALLOC(bestsc,   sizeof(float) * (W+1));
  ESL_ALLOC(bestmode, sizeof(char)  * (W+1));

  /* yvalidA[0..cnum[v]] will hold TRUE for states y for which a transition is legal
   * (some transitions are impossible due to the bands) */
  ESL_ALLOC(yvalidA, sizeof(int) * MAXCONNECT);
  esl_vec_ISet(yvalidA, MAXCONNECT, FALSE);

  /* initialize all cells of the matrix to IMPOSSIBLE */
  if(mx->Jncells_valid > 0) esl_vec_FSet(mx->Jdp_mem, mx->Jncells_valid, IMPOSSIBLE);
  if(mx->Lncells_valid > 0 && fill_L) esl_vec_FSet(mx->Ldp_mem, mx->Lncells_valid, IMPOSSIBLE);
  if(mx->Rncells_valid > 0 && fill_R) esl_vec_FSet(mx->Rdp_mem, mx->Rncells_valid, IMPOSSIBLE);
  if(mx->Tncells_valid > 0 && fill_T) esl_vec_FSet(mx->Tdp_mem, mx->Tncells_valid, IMPOSSIBLE);

  /* If we were passed a master hitlist <hitlist>, either create a
   * gamma hit matrix for resolving overlaps optimally (if
   * cm->search_opts & CM_SEARCH_CMNOTGREEDY) or create a temporary
   * hitlist that will store overlapping hits, in that case, we'll
   * remove overlaps greedily before copying the hits to the master
   * <hitlist>.
   */
  gamma       = NULL;
  tmp_hitlist = NULL;
  if(hitlist != NULL) {
	if(cm->search_opts & CM_SEARCH_CMNOTGREEDY) {
	  gamma = CreateGammaHitMx(j0-i0+1, i0, cutoff);
	}
	else {
	  tmp_hitlist = cm_tophits_Create();
	}
  }

  /* if do_null3: allocate and initialize act vector */
  if(do_null3) {
	ESL_ALLOC(act, sizeof(double *) * (W+1));
	for(i = 0; i <= W; i++) {
	  ESL_ALLOC(act[i], sizeof(double) * cm->abc->K);
	  esl_vec_DSet(act[i], cm->abc->K, 0.);
	}
	/* pre-fill act, different than non-HMM banded scanner b/c our main loop doesn't step j through residues */
	for(j = i0; j <= j0; j++) {
	  jp = j-i0+1; /* j is actual index in dsq, jp_g is offset j relative to start i0 (j index for act) */
	  esl_vec_DCopy(act[(jp-1)%(W+1)], cm->abc->K, act[jp%(W+1)]);
	  esl_abc_DCount(cm->abc, act[jp%(W+1)], dsq[j], 1.);
	}
  }
  else act = NULL;

  /* initialize envelope boundary variables */
  do_env_defn = (ret_envi != NULL || ret_envj != NULL) ? TRUE : FALSE;
  envi = j0+1;
  envj = i0-1;

  /* Main recursion */
  for (v = cm->M-1; v > 0; v--) { /* almost down to ROOT_S, we handle that differently */
	float const *esc_v   = cm->oesc[v]; /* emission scores for state v */
	float const *tsc_v   = cm->tsc[v];  /* transition scores for state v */
	float const *lmesc_v = cm->lmesc[v]; /* marginal left  emission scores for state v */
	float const *rmesc_v = cm->rmesc[v]; /* marginal right emission scores for state v */
	sd     = StateDelta(cm->sttype[v]);
	sdl    = StateLeftDelta(cm->sttype[v]);
	sdr    = StateRightDelta(cm->sttype[v]);
	jn     = jmin[v];
	jx     = jmax[v];
	do_J_v = cp9b->Jvalid[v]           ? TRUE : FALSE;
	do_L_v = cp9b->Lvalid[v] && fill_L ? TRUE : FALSE;
	do_R_v = cp9b->Rvalid[v] && fill_R ? TRUE : FALSE;
	do_T_v = cp9b->Tvalid[v] && fill_T ? TRUE : FALSE;

	/* re-initialize the J, L and R decks if we can do a local end from v */
	if(NOT_IMPOSSIBLE(cm->endsc[v])) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	if(do_J_v) {
	  if(hdmin[v][jp_v] >= sd) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sd;
	    dp_v = sd - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Jalpha[v][jp_v][dp_v] = el_scA[d-sd]  + cm->endsc[v];
	  }
	}
	if(do_L_v) {
	  if(hdmin[v][jp_v] >= sdl) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdl;
	    dp_v = sdl - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Lalpha[v][jp_v][dp_v] = el_scA[d-sdl]  + cm->endsc[v];
	  }
	}
	if(do_R_v) {
	  if(hdmin[v][jp_v] >= sdr) {
	    d    = hdmin[v][jp_v];
	    dp_v = 0;
	  }
	  else {
	    d    = sdr;
	    dp_v = sdr - hdmin[v][jp_v];
	  }
	  for (; d <= hdmax[v][jp_v]; dp_v++, d++) {
	    Ralpha[v][jp_v][dp_v] = el_scA[d-sdr]  + cm->endsc[v];
	  }
	}
	  }
	}
	/* otherwise this state's deck has already been initialized to IMPOSSIBLE */

	if(cm->sttype[v] == E_st) {
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j-jmin[v];
	ESL_DASSERT1((hdmin[v][jp_v] == 0));
	ESL_DASSERT1((hdmax[v][jp_v] == 0));
	if(do_J_v) Jalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_L_v) Lalpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	if(do_R_v) Ralpha[v][jp_v][0] = 0.; /* for End states, d must be 0 */
	  }
	}
	else if(cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IL states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1]
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	yvalid_ct = 0;
	j_sdr = j - sdr;

	/* determine which children y we can legally transit to for v, j */
	for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	  if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr valid for state y? */

	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	  i    = j - d + 1;
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	  /* We need to treat R differently from and J and L here, by
	   * doing separate 'for (yoffset...' loops for J and R
	   * because we have to fully calculate Jalpha[v][jp_v][dp_v])
	   * before we can start to calculate Ralpha[v][jp_v][dp_v].
	   */
	  /* Handle J and L first */
	  if(do_J_v || do_L_v) {
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	      if(do_J_y || do_L_y) {
		jp_y_sdr = j - jmin[y] - sdr;

		if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		}
	      }
	    }
	    if(do_J_v) {
	      Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]];
	      Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    if(do_L_v) {
	      Lalpha[v][jp_v][dp_v] = (d >= 2) ? Lalpha[v][jp_v][dp_v] + esc_v[dsq[i]] : esc_v[dsq[i]];
	      Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    i--;
	  }

	  if(do_R_v) {
	    /* Handle R separately */
	    Rsc = Ralpha[v][jp_v][dp_v]; /* this sc will be IMPOSSIBLE */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      if((do_J_y || do_R_y) && (y != v)) { /* (y != v) part is to disallow IL self transits in R mode */
		jp_y_sdr = j - jmin[y] - sdr;

		/* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,L above) */
		if((d) >= hdmin[y][jp_y_sdr] && (d) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y = d - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_y) Rsc = FLogsum(Rsc, Jalpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		  if(do_R_y) Rsc = FLogsum(Rsc, Ralpha[y][jp_y_sdr][dp_y] + tsc_v[yoffset]);
		}
	      }
	    } /* end of for (yvalid_idx = 0... loop */
	    Ralpha[v][jp_v][dp_v] = Rsc;
	    /* we use Rsc instead of Ralpha cell in above loop because
	     * Ralpha[v][jp_v][dp_v] may be the same cell as
	     * Ralpha[y][jp_y_sdr][dp_y] if we're an IL state
	     */
	  }
	}
	  }
	}
	else if(cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  /* update {J,L,R}alpha[v][jp_v][dp_v] cells, for IR states, loop
	   * nesting order is: for j { for d { for y { } } } because they
	   * can self transit, and a {J,L,R}alpha[v][j][d] cell must be
	   * complete (that is we must have looked at all children y)
	   * before can start calc'ing for {J,L,R}alpha[v][j][d+1].
	   * We could be slightly more efficient if we separated out
	   * MR from IR b/c self-transits in MRs are impossible, but
	   * we don't do that here. */

	  /* The first MR_st/IR_st 'for (j...' loop is for J and R matrices which use the same set of j values */
	  if(do_J_v || do_R_v) {
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;
	  j_sdr = j - sdr;

	  /* determine which children y we can legally transit to for v, j */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if((j_sdr) >= jmin[y] && ((j_sdr) <= jmax[y])) yvalidA[yvalid_ct++] = yoffset; /* is j-sdr is valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    /* We need to treat L differently from and J and R here, by
	     * doing separate 'for (yoffset...' loops for J because we
	     * have to fully calculate Jalpha[v][jp_v][dp_v]) before we
	     * can start to calculate Lalpha[v][jp_v][dp_v].
	     */
	    /* Handle J and R first */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	      if(do_J_y || do_R_y) {
		jp_y_sdr = j - jmin[y] - sdr;

		if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) { /* make sure d is valid for this v, j and y */
		  dp_y_sd = d - sd - hdmin[y][jp_y_sdr];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		  if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		  if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc_v[yoffset]);
		}
	      }
	    }
	    if(do_J_v) {
	      Jalpha[v][jp_v][dp_v] += esc_v[dsq[j]];
	      Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	    if(do_R_v) {
	      Ralpha[v][jp_v][dp_v] = (d >= 2) ? Ralpha[v][jp_v][dp_v] + esc_v[dsq[j]] : esc_v[dsq[j]];
	      Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	    }
	  }
	}
	  }
	  /* Handle L separately */
	  if(do_L_v) {
	/* The second MR_st/IR_st 'for (j...' loop is for the L matrix which use a different set of j values */
	for (j = jmin[v]; j <= jmax[v]; j++) {
	  jp_v = j - jmin[v];
	  yvalid_ct = 0;

	  /* determine which children y we can legally transit to for v, j */
	  /* we use 'j' and not 'j_sdr' here for the L matrix, differently from J and R matrices above */
	  for (y = cm->cfirst[v], yoffset = 0; y < (cm->cfirst[v] + cm->cnum[v]); y++, yoffset++)
	    if(y != v       && /* y == v when yoffset == 0 && v is an IR state: we don't want to allow IR self transits in L mode */
	       j >= jmin[y] && j <= jmax[y]) yvalidA[yvalid_ct++] = yoffset; /* is j is valid for state y? */

	  for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) { /* for each valid d for v, j */
	    dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha */

	    Lsc = Lalpha[v][jp_v][dp_v]; /* this sc will be IMPOSSIBLE */
	    for (yvalid_idx = 0; yvalid_idx < yvalid_ct; yvalid_idx++) { /* for each valid child y, for v, j */
	      /* Note if we're an IL state, we can't self transit in R mode, this was ensured above when we set up yvalidA[] (xref:ELN3,p5)*/
	      yoffset = yvalidA[yvalid_idx];
	      y = cm->cfirst[v] + yoffset;
	      do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	      do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	      if(do_L_y || do_J_y) {
		/* we use 'jp_y=j-min[y]' here, not 'jp_y_sdr=j-jmin[y]-sdr' (which we used in the corresponding loop for J,R above) */
		jp_y = j - jmin[y];

		/* we use 'd' and 'dp_y' here, not 'd-sd' and 'dp_y_sd' (which we used in the corresponding loop for J,R above) */
		if((d) >= hdmin[y][jp_y] && (d) <= hdmax[y][jp_y]) { /* make sure d is valid for this v, j and y */
		  dp_y = d - hdmin[y][jp_y];
		  ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v] - hdmin[v][jp_v])));
		  ESL_DASSERT1((dp_y    >= 0 && dp_y     <= (hdmax[y][jp_y] - hdmin[y][jp_y])));
		  if(do_J_y) Lsc = FLogsum(Lsc, Jalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		  if(do_L_y) Lsc = FLogsum(Lsc, Lalpha[y][jp_y][dp_y] + tsc_v[yoffset]);
		}
	      }
	    } /* end of for (yvalid_idx = 0... loop */
	    Lalpha[v][jp_v][dp_v] = Lsc;
	    /* we use Lsc instead of Lalpha cell in above loop because
	     * Lalpha[v][jp_v][dp_v] may be the same cell as
	     * Lalpha[y][jp_y_sdr][dp_y] if we're an IR state
	     */
	  }
	}
	  }
	}
	else if(cm->sttype[v] == MP_st) {
	  /* MP states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	/* The first MP_st 'for (jp_v...' loop is for J and R matrices which use the same set of j values */
	/* j must satisfy:
	 * j >= jmin[v]
	 * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	 * j <= jmax[v]
	 * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	 * this reduces to two ESL_MAX calls
	 */
	jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	jpn = jn - jmin[v];
	jpx = jx - jmin[v];
	jp_y_sdr = jn - jmin[y] - sdr;
	/* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	if((do_J_v && do_J_y) || (do_R_v && (do_J_y || do_R_y))) {
	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    if(do_J_v && do_J_y) {
	      /* J matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sd   = dn - hdmin[y][jp_y_sdr] - sd;

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
		ESL_DASSERT1((dp_v      >= 0 && dp_v       <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
		ESL_DASSERT1((dp_y_sd   >= 0 && dp_y_sd    <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      }
	    }

	    if(do_R_v && (do_R_y || do_J_y)) {
	      /* R matrix: */
	      /* d must satisfy:
	       * d >= hdmin[v][jp_v]
	       * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	       * d <= hdmax[v][jp_v]
	       * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	       * this reduces to two ESL_MAX calls
	       */
	      dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sdr);
	      dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sdr);
	      dpn       = dn - hdmin[v][jp_v];
	      dpx       = dx - hdmin[v][jp_v];
	      dp_y_sdr  = dn - hdmin[y][jp_y_sdr] - sdr;
	      /* for {L,R}alpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	      for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
		/* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
		ESL_DASSERT1((dp_y_sdr  >= 0 && dp_y_sdr   <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
		if(do_J_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sdr] + tsc);
		if(do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sdr] + tsc);
	      }
	    }
	  }
	}

	if(do_L_v && (do_L_y || do_J_y)) {
	  /* The second MP_st 'for (jp_v...' loop is for L matrix, which uses a different set of j values from J and R */
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y] (follows from (j >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y] (follows from (j <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]);
	  jx = ESL_MIN(jmax[v], jmax[y]);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y = jn - jmin[y];
	  /* for Lalpha, we use 'jp_y=j-min[y]' instead of 'jp_y_sdr=j-jmin[y]-sdr' */

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y     >= 0 && jp_y     <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	   * d >= hdmin[v][jp_v]
	   * d >= hdmin[y][jp_y_sd]+sd (follows from (d-sd >= hdmin[y][jp_y_sd]))
	   * d <= hdmax[v][jp_v]
	   * d <= hdmax[y][jp_y_sd]+sd (follows from (d-sd <= hdmax[y][jp_y_sd]))
	   * this reduces to two ESL_MAX calls
	   */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y] + sdr);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y] + sdr);
	    dpn       = dn - hdmin[v][jp_v];
	    dpx       = dx - hdmin[v][jp_v];
	    dp_y_sdr  = dn - hdmin[y][jp_y] - sdr;
	    /* for Lalpha, we use 'dp_y_sdr' instead of 'dy_y_sd' */

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sdr++) {
	      /* we use 'dp_y_sdr' here, not 'dp_y_sd' (which we used in the corresponding loop for J above) */
	      ESL_DASSERT1((dp_y_sdr >= 0 && dp_y_sdr  <= (hdmax[y][jp_y]     - hdmin[y][jp_y])));
	      if(do_J_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y_sdr] + tsc);
	      if(do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y_sdr] + tsc);
	    }
	  }
	}
	  }
	  /* add in emission score */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	i     = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v], dp_v = 0; d <= hdmax[v][jp_v]; d++, dp_v++)
	  {
	    /*if(i < i0 || j > j0) {
	      printf("dsq[i:%d]: %d\n", i, dsq[i]);
	      printf("dsq[j:%d]: %d\n", j, dsq[j]);
	      printf("esc_v[%d]: %.5f\n", dsq[i]*cm->abc->Kp+dsq[j], esc_v[dsq[i]*cm->abc->Kp+dsq[j]]);;
	      printf("i0: %" PRId64 " j0: %" PRId64 "\n", i0, j0);
	      }*/
	    if(d >= 2) {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] += esc_v[dsq[i]*cm->abc->Kp+dsq[j]];
	      if(do_L_v) Lalpha[v][jp_v][dp_v] += lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] += rmesc_v[dsq[j]];
	    }
	    else {
	      if(do_J_v) Jalpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      if(do_L_v) Lalpha[v][jp_v][dp_v] = lmesc_v[dsq[i]];
	      if(do_R_v) Ralpha[v][jp_v][dp_v] = rmesc_v[dsq[j]];
	    }
	    i--;
	  }
	  }
	  /* ensure all cells are >= IMPOSSIBLE */
	  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v  = j - jmin[v];
	for (dp_v = 0; dp_v <= (hdmax[v][jp_v] - hdmin[v][jp_v]); dp_v++) {
	  if(do_J_v) Jalpha[v][jp_v][dp_v] = ESL_MAX(Jalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_L_v) Lalpha[v][jp_v][dp_v] = ESL_MAX(Lalpha[v][jp_v][dp_v], IMPOSSIBLE);
	  if(do_R_v) Ralpha[v][jp_v][dp_v] = ESL_MAX(Ralpha[v][jp_v][dp_v], IMPOSSIBLE);
	}
	  }
	}
	else if(cm->sttype[v] != B_st) { /* entered if state v is D or S (! E && ! B && ! ML && ! IL && ! MR && ! IR) */
	  /* D, S states cannot self transit, this means that all cells in
	   * alpha[v] are independent of each other, only depending on
	   * alpha[y] for previously calc'ed y.  We can do the for loops
	   * in any nesting order, this implementation does what I think
	   * is most efficient: for y { for j { for d { } } }
	   */
	  for (y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	yoffset = y - cm->cfirst[v];
	tsc = tsc_v[yoffset];

	if((do_J_v && do_J_y) || (do_L_v && do_L_y) || (do_R_v && do_R_y)) {
	  /* j must satisfy:
	   * j >= jmin[v]
	   * j >= jmin[y]+sdr (follows from (j-sdr >= jmin[y]))
	   * j <= jmax[v]
	   * j <= jmax[y]+sdr (follows from (j-sdr <= jmax[y]))
	   * this reduces to two ESL_MAX calls
	   */
	  jn = ESL_MAX(jmin[v], jmin[y]+sdr);
	  jx = ESL_MIN(jmax[v], jmax[y]+sdr);
	  jpn = jn - jmin[v];
	  jpx = jx - jmin[v];
	  jp_y_sdr = jn - jmin[y] - sdr;

	  for (jp_v = jpn; jp_v <= jpx; jp_v++, jp_y_sdr++) {
	    ESL_DASSERT1((jp_v >= 0 && jp_v <= (jmax[v]-jmin[v])));
	    ESL_DASSERT1((jp_y_sdr >= 0 && jp_y_sdr <= (jmax[y]-jmin[y])));

	    /* d must satisfy:
	     * d >= hdmin[v][jp_v]
	     * d >= hdmin[y][jp_y_sdr]+sd (follows from (d-sd >= hdmin[y][jp_y_sdr]))
	     * d <= hdmax[v][jp_v]
	     * d <= hdmax[y][jp_y_sdr]+sd (follows from (d-sd <= hdmax[y][jp_y_sdr]))
	     * this reduces to two ESL_MAX calls
	     */
	    dn = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y_sdr] + sd);
	    dx = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y_sdr] + sd);
	    dpn     = dn - hdmin[v][jp_v];
	    dpx     = dx - hdmin[v][jp_v];
	    dp_y_sd = dn - hdmin[y][jp_y_sdr] - sd;

	    for (dp_v = dpn; dp_v <= dpx; dp_v++, dp_y_sd++) {
	      ESL_DASSERT1((dp_v    >= 0 && dp_v     <= (hdmax[v][jp_v]     - hdmin[v][jp_v])));
	      ESL_DASSERT1((dp_y_sd >= 0 && dp_y_sd  <= (hdmax[y][jp_y_sdr] - hdmin[y][jp_y_sdr])));
	      if(do_J_v && do_J_y) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_L_v && do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y_sdr][dp_y_sd] + tsc);
	      if(do_R_v && do_R_y) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y_sdr][dp_y_sd] + tsc);

	      /* an easy to overlook case: if d == 0, set L and R values to IMPOSSIBLE */
	      if(dp_v == dpn && dn == 0) { /* d is 0 */
		if(do_L_v) Lalpha[v][jp_v][dp_v] = IMPOSSIBLE;
		if(do_R_v) Ralpha[v][jp_v][dp_v] = IMPOSSIBLE;
	      }
	    }
	  }
	}
	  }
	  /* no emission score to add */
	}
	else { /* B_st */
	  y = cm->cfirst[v]; /* left  subtree */
	  z = cm->cnum[v];   /* right subtree */

	  do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	  do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	  do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	  do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE; /* will be FALSE, y is not a B_st */

	  do_J_z = cp9b->Jvalid[z]           ? TRUE : FALSE;
	  do_L_z = cp9b->Lvalid[z] && fill_L ? TRUE : FALSE;
	  do_R_z = cp9b->Rvalid[z] && fill_R ? TRUE : FALSE;
	  do_T_z = cp9b->Tvalid[z] && fill_T ? TRUE : FALSE; /* will be FALSE, z is not a B_st */

	  /* Any valid j must be within both state v and state z's j band
	   * I think jmin[v] <= jmin[z] is guaranteed by the way bands are
	   * constructed, but we'll check anyway.
	   */
	  jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	  jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	  /* the main j loop */
	  for (j = jn; j <= jx; j++) {
	jp_v = j - jmin[v];
	jp_y = j - jmin[y];
	jp_z = j - jmin[z];
	kn = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
		kn = ESL_MAX(kn, 0); /* kn must be non-negative, added with fix to bug i36 */
	/* kn satisfies inequalities (1) and (3) (listed below)*/
	kx = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];
	/* kn satisfies inequalities (2) and (4) (listed below)*/
	i = j - hdmin[v][jp_v] + 1;
	for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++, i--) {
	  dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */

	  /* Find the first k value that implies a valid cell in the {J,L,R} matrix y and z decks.
	   * This k must satisfy the following 6 inequalities (some may be redundant):
	   * (1) k >= j-jmax[y];
	   * (2) k <= j-jmin[y];
	   *     1 and 2 guarantee (j-k) is within state y's j band
	   *
	   * (3) k >= hdmin[z][j-jmin[z]];
	   * (4) k <= hdmax[z][j-jmin[z]];
	   *     3 and 4 guarantee k is within z's j=(j), d band
	   *
	   * (5) k >= d-hdmax[y][j-jmin[y]-k];
	   * (6) k <= d-hdmin[y][j-jmin[y]-k];
	   *     5 and 6 guarantee (d-k) is within state y's j=(j-k) d band
	   *
	   * kn and kx were set above (outside (for (dp_v...) loop) that
	   * satisfy 1-4 (b/c 1-4 are d-independent and k-independent)
	   * RHS of inequalities 5 and 6 are dependent on k, so we check
	   * for these within the next for loop.
	   *
	   * To update a cell in the T matrix with a sum of an R matrix value for y
	   * and a L matrix value for z, there are 2 additional inequalities to satisfy:
	   * (7) k != 0
	   * (8) k != d
	   * We ensure 7 and 8 in the loop below.
	   */
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      /* for current k, all 6 inequalities have been satisified
	       * so we know the cells corresponding to the platonic
	       * matrix cells alpha[v][j][d], alpha[y][j-k][d-k], and
	       * alpha[z][j][k] are all within the bands. These
	       * cells correspond to alpha[v][jp_v][dp_v],
	       * alpha[y][jp_y-k][d-hdmin[jp_y-k]-k],
	       * and alpha[z][jp_z][k-hdmin[jp_z]];
	       */
	      kp_z = k-hdmin[z][jp_z];
	      dp_y = d-hdmin[y][jp_y-k];
	      if(do_J_v && do_J_y && do_J_z) Jalpha[v][jp_v][dp_v] = FLogsum(Jalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if(do_L_v && do_J_y && do_L_z) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      if(do_R_v && do_R_y && do_J_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Jalpha[z][jp_z][kp_z]);
	      if((k != 0) && (k != d)) {
		if(do_T_v && do_R_y && do_L_z) Talpha[v][jp_v][dp_v] = FLogsum(Talpha[v][jp_v][dp_v], Ralpha[y][jp_y-k][dp_y - k] + Lalpha[z][jp_z][kp_z]);
	      }
	    }
	  }
	}
	  }

	  /* two additional special cases in trCYK (these are not in standard CYK).
	   * we do these in their own for(j.. { for(d.. { } } loops b/c one
	   * is independent of z, the other of y, unlike the above loop which is dependent
	   * on both.
	   */
	  if(do_L_v && (do_J_y || do_L_y)) {
	jn = (jmin[v] > jmin[y]) ? jmin[v] : jmin[y];
	jx = (jmax[v] < jmax[y]) ? jmax[v] : jmax[y];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[y] && j <= jmax[y]));
	  dn = (hdmin[v][jp_v] > hdmin[y][jp_y]) ? hdmin[v][jp_v] : hdmin[y][jp_y];
	  dx = (hdmax[v][jp_v] < hdmax[y][jp_y]) ? hdmax[v][jp_v] : hdmax[y][jp_y];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_y = d - hdmin[y][jp_y];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]));
	    if(do_J_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Jalpha[y][jp_y][dp_y]);
	    if(do_L_y) Lalpha[v][jp_v][dp_v] = FLogsum(Lalpha[v][jp_v][dp_v], Lalpha[y][jp_y][dp_y]);
	  }
	}
	  }
	  if(do_R_v && (do_J_z || do_R_z)) {
	jn = (jmin[v] > jmin[z]) ? jmin[v] : jmin[z];
	jx = (jmax[v] < jmax[z]) ? jmax[v] : jmax[z];
	for (j = jn; j <= jx; j++) {
	  jp_v = j - jmin[v];
	  jp_z = j - jmin[z];
	  ESL_DASSERT1((j >= jmin[v] && j <= jmax[v]));
	  ESL_DASSERT1((j >= jmin[z] && j <= jmax[z]));
	  dn = (hdmin[v][jp_v] > hdmin[z][jp_z]) ? hdmin[v][jp_v] : hdmin[z][jp_z];
	  dx = (hdmax[v][jp_v] < hdmax[z][jp_z]) ? hdmax[v][jp_v] : hdmax[z][jp_z];
	  for(d = dn; d <= dx; d++) {
	    dp_v = d - hdmin[v][jp_v];
	    dp_z = d - hdmin[z][jp_z];
	    ESL_DASSERT1((d >= hdmin[v][jp_v] && d <= hdmax[v][jp_v]));
	    ESL_DASSERT1((d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]));
	    if(do_J_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Jalpha[z][jp_z][dp_z]);
	    if(do_R_z) Ralpha[v][jp_v][dp_v] = FLogsum(Ralpha[v][jp_v][dp_v], Ralpha[z][jp_z][dp_z]);
	  }
	}
	  }
	} /* finished calculating deck v. */
#if eslDEBUGLEVEL >= 3
	  /* print alpha matrices - caution: these will be big! */
	  if(cm->stid[v] == BIF_B) {
	    /* the main j loop */
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Tvalid[v] && NOT_IMPOSSIBLE(Talpha[v][jp_v][dp_v])) ? Talpha[v][jp_v][dp_v] : -9999.9);
	      }
	    }
	  }
	  if((cm->stid[v] == BEGL_S) || (cm->stid[v] == BEGR_S)) {
	    /* the main j loop */
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       -9999.9);
	      }
	    }
	  }
	  else {
	    for (j = jmin[v]; j <= jmax[v]; j++) {
	      jp_v = j - jmin[v];
	      for (d = hdmin[v][jp_v]; d <= hdmax[v][jp_v]; d++) {
		dp_v = d - hdmin[v][jp_v];  /* d index for state v in alpha w/mem eff bands */
		printf("H j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		       j, v, d,
		       (cp9b->Jvalid[v] && NOT_IMPOSSIBLE(Jalpha[v][jp_v][dp_v])) ? Jalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Lvalid[v] && NOT_IMPOSSIBLE(Lalpha[v][jp_v][dp_v])) ? Lalpha[v][jp_v][dp_v] : -9999.9,
		       (cp9b->Rvalid[v] && NOT_IMPOSSIBLE(Ralpha[v][jp_v][dp_v])) ? Ralpha[v][jp_v][dp_v] : -9999.9,
		       -9999.9);
	      }
	    }
	  }
	  printf("\n");
#endif
  } /* end of for (v = cm->M-1; v > 0; v--) */

  /* update gamma, by specifying all hits with j < jmin[0] are impossible */
  if(gamma != NULL) {
	for(j = i0; j < jmin[v]; j++) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, -1, -1,
				      NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				      bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  /* Now handle from ROOT_S, state 0. So far we haven't touched
   * the {J,L,R,T}alpha[0] decks at all since initialization and here
   * we'll only update at most 1 cell in each, the one pertaining
   * to a full alignment [0][L][L].
   *
   * In truncated alignment the only way out of ROOT_S in local or
   * global mode is via a 'truncated begin' with a score (penalty)
   * from cm->trp into any emitting state. The penalty was calculated
   * in cm_tr_penalties_Create() and differs depending on whether we
   * are in local or global mode and the value of 'pty_idx' which was
   * determined by the passed in value <pass_idx>.
   *
   * We also determine best* arrays here for reporting hits.
   */

  do_J_0 = cp9b->Jvalid[0]           ? TRUE : FALSE;
  do_L_0 = cp9b->Lvalid[0] && fill_L ? TRUE : FALSE;
  do_R_0 = cp9b->Rvalid[0] && fill_R ? TRUE : FALSE;
  do_T_0 = cp9b->Tvalid[0] && fill_T ? TRUE : FALSE;

  v = 0;
  for (j = jmin[v]; j <= jmax[v]; j++) {
	jp_v = j - jmin[v];
	/* initialize bestr, bestsc, bestmode */
	esl_vec_ISet(bestr,  (W+1), 0); /* init bestr to 0, all hits are rooted at 0 unless we find a better local begin below */
	esl_vec_FSet(bestsc, (W+1), IMPOSSIBLE);
	for(i = 0; i <= W; i++) bestmode[i] = TRMODE_UNKNOWN;

	for (y = 1; y < cm->M; y++) {
	  trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][y] : cm->trp->g_ptyAA[pty_idx][y];
	  if(NOT_IMPOSSIBLE(trpenalty) &&
	 (j >= jmin[y] && j <= jmax[y])) {  /* j is within state y's band */
	do_J_y = cp9b->Jvalid[y]           ? TRUE : FALSE;
	do_L_y = cp9b->Lvalid[y] && fill_L ? TRUE : FALSE;
	do_R_y = cp9b->Rvalid[y] && fill_R ? TRUE : FALSE;
	do_T_y = cp9b->Tvalid[y] && fill_T ? TRUE : FALSE;

	jp_y = j - jmin[y];
	dn   = ESL_MAX(hdmin[v][jp_v], hdmin[y][jp_y]);
	dx   = ESL_MIN(hdmax[v][jp_v], hdmax[y][jp_y]);

	if(do_J_0 && do_J_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Jalpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Jalpha[0][jp_v][dp_v]) {
	      Jalpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_J;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_L_0 && do_L_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Lalpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Lalpha[0][jp_v][dp_v]) {
	      Lalpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_L;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_R_0 && do_R_y) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Ralpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Ralpha[0][jp_v][dp_v]) {
	      Ralpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_R;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	if(do_T_0 && do_T_y && cm->sttype[y] == B_st) {
	  dp_v = dn - hdmin[v][jp_v];
	  dp_y = dn - hdmin[y][jp_y];
	  for(d = dn; d <= dx; d++, dp_v++, dp_y++) {
	    sc = Talpha[y][jp_y][dp_y] + trpenalty;
	    if (sc > Talpha[0][jp_v][dp_v]) {
	      Talpha[0][jp_v][dp_v] = sc;
	      if(sc > bestsc[d]) {
		bestsc[d]   = sc;
		bestmode[d] = TRMODE_T;
		bestr[d]    = y;
	      }
	    }
	  }
	}
	  }
	}

	/* if necessary, report all hits with valid d for this j, either to gamma or tmp_hitlist */
	if(gamma != NULL) {
	  if((status = UpdateGammaHitMx  (cm, errbuf, pass_idx, gamma, j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, bestmode, W, act)) != eslOK) return status;
	}
	if(tmp_hitlist != NULL) {
	  if((status = ReportHitsGreedily(cm, errbuf, pass_idx,        j, hdmin[0][jp_v], hdmax[0][jp_v], bestsc, bestr, bestmode, W, act, i0, j0, cutoff, tmp_hitlist)) != eslOK) return status;
	}
  }

  /* update gamma, by specifying all hits with j > jmax[0] are impossible */
  if(gamma != NULL) {
	for(j = jmax[v]+1; j <= j0; j++) {
	  if((status = UpdateGammaHitMx(cm, errbuf, pass_idx, gamma, j, -1, -1,
				    NULL, /* NULL for bestsc tells UpdateGammaHitMx() no hits are possible for this j */
				    bestr, NULL, W, act)) != eslOK) return status;
	}
  }

  /* find the best scoring hit, and update envelope boundaries if nec */
  vsc_root   = IMPOSSIBLE;
  vmode_root = TRMODE_UNKNOWN;
  bsc_full   = IMPOSSIBLE;
  bmode_full = TRMODE_UNKNOWN;
  v = 0;
  jpn = 0;
  jpx = jmax[v] - jmin[v];
  for(jp_v = jpn; jp_v <= jpx; jp_v++) {
	dpn     = 0;
	dpx     = hdmax[v][jp_v] - hdmin[v][jp_v];
	for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	  if(do_J_0 && Jalpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Jalpha[0][jp_v][dp_v];
	vmode_root = TRMODE_J;
	  }
	  if(do_L_0 && Lalpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Lalpha[0][jp_v][dp_v];
	vmode_root = TRMODE_L;
	  }
	  if(do_R_0 && Ralpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Ralpha[0][jp_v][dp_v];
	vmode_root = TRMODE_R;
	  }
	  if(do_T_0 && Talpha[0][jp_v][dp_v] > vsc_root) {
	vsc_root   = Talpha[0][jp_v][dp_v];
	vmode_root = TRMODE_T;
	  }
	}
	/* update envelope boundaries, if nec */
	if(do_env_defn) {
	  j = jp_v + jmin[v];
	  for(dp_v = dpn; dp_v <= dpx; dp_v++) {
	if((do_J_0 && Jalpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_L_0 && Lalpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_R_0 && Ralpha[0][jp_v][dp_v] >= env_cutoff) ||
	   (do_T_0 && Talpha[0][jp_v][dp_v] >= env_cutoff)) {
	  i = j - (dp_v + hdmin[v][jp_v]) + 1;
	  envi = ESL_MIN(envi, i);
	  envj = ESL_MAX(envj, j);
	}
	  }
	}
  }
  /* find the best score and mode that spans the full sequence */
  if(j0 >= jmin[0] && j0 <= jmax[0]) {
	jp_v = j0-jmin[0];
	if(W >= hdmin[0][jp_v] && W <= hdmax[0][jp_v]) {
	  dp_v = W-hdmin[0][jp_v];
	  if(do_J_0 && Jalpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Jalpha[0][jp_v][dp_v];
	bmode_full = TRMODE_J;
	  }
	  if(do_L_0 && Lalpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Lalpha[0][jp_v][dp_v];
	bmode_full = TRMODE_L;
	  }
	  if(do_R_0 && Ralpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Ralpha[0][jp_v][dp_v];
	bmode_full = TRMODE_R;
	  }
	  if(do_T_0 && Talpha[0][jp_v][dp_v] > bsc_full) {
	bsc_full   = Talpha[0][jp_v][dp_v];
	bmode_full = TRMODE_T;
	  }
	}
  }

  free(el_scA);
  free(yvalidA);
  free(bestr);
  free(bestmode);
  free(bestsc);
  if (act != NULL) {
	for(i = 0; i <= W; i++) free(act[i]);
	free(act);
  }

  /* If recovering hits in a non-greedy manner, do the gamma traceback, then free gamma */
  if(gamma != NULL) {
	TBackGammaHitMx(gamma, hitlist, i0, j0);
	FreeGammaHitMx(gamma);
  }
  /* If reporting hits in a greedy manner, remove overlaps greedily from the tmp_hitlist
   * then copy remaining hits to master <hitlist>. Then free tmp_hitlist.
   */
  if(tmp_hitlist != NULL) {
	for(h = 0; h < tmp_hitlist->N; h++) tmp_hitlist->unsrt[h].srcL = j0; /* so overlaps can be removed */
	cm_tophits_SortForOverlapRemoval(tmp_hitlist);
	/* cm_tophits_Dump(stdout, tmp_hitlist); */
	if((status = cm_tophits_RemoveOrMarkOverlaps(tmp_hitlist, FALSE, errbuf)) != eslOK) return status;
	for(h = 0; h < tmp_hitlist->N; h++) {
	  if(! (tmp_hitlist->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if((status = cm_tophits_CloneHitMostly(tmp_hitlist, h, hitlist)) != eslOK) ESL_FAIL(status, errbuf, "problem copying hit to hitlist, out of memory?");
	  }
	}
	/* cm_tophits_Dump(stdout, hitlist); */
	cm_tophits_Destroy(tmp_hitlist);
  }

  /* set envelope return variables if nec */
  if(ret_envi != NULL) { *ret_envi = (envi == j0+1) ? -1 : envi; }
  if(ret_envj != NULL) { *ret_envj = (envj == i0-1) ? -1 : envj; }

  if (ret_sc   != NULL) *ret_sc   = vsc_root;
  if (ret_mode != NULL) *ret_mode = vmode_root;

  ESL_DPRINTF1(("FTrInsideScanHB() return sc: %f\n", vsc_root));
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return 0.; /* never reached */
}

/* Function: cm_TrFillFromPassIdx()
 * Date:     EPN, Wed Feb 15 15:16:45 2012
 *
 * Purpose: Given a pipeline pass index, determine which
 *          of the marginal matrices we need to fill
 *          in to find the alignment in that mode.
 *
 *          Return TRUE/FALSE values in <ret_fill_{L,R,T}>.
 *          Note that we always must fill in J matrices so a fill_J
 *          value is unnecessary, it's implicitly true.
 *
 * Args:     mode       - optimal mode
 *           ret_fill_L - RETURN: should we fill in L based on <ret_mode>?
 *           ret_fill_R - RETURN: should we fill in R based on <ret_mode>?
 *           ret_fill_T - RETURN: should we fill in T based on <ret_mode>?
 *
 * Throws:   eslEINVAL if pass_idx is not PLI_PASS_5P_ONLY_FORCE, PLI_PASS_3P_ONLY_FORCE,
 *           PLI_PASS_5P_AND_3P_FORCE, or PLI_PASS_5P_AND_3P_ANY.
 */
int
cm_TrFillFromPassIdx(int pass_idx, int *ret_fill_L, int *ret_fill_R, int *ret_fill_T)
{
  int fill_L, fill_R, fill_T;
  int invalid_idx = FALSE;

  fill_L = fill_R = fill_T = FALSE;
  switch(pass_idx) {
  case PLI_PASS_5P_AND_3P_FORCE: fill_L = fill_R = fill_T = TRUE; break;
  case PLI_PASS_5P_AND_3P_ANY:   fill_L = fill_R = fill_T = TRUE; break;
  case PLI_PASS_5P_ONLY_FORCE:   fill_R = TRUE; break;
  case PLI_PASS_3P_ONLY_FORCE:   fill_L = TRUE; break;
  default: invalid_idx = TRUE; break;
  }

  if(ret_fill_L != NULL) *ret_fill_L = fill_L;
  if(ret_fill_R != NULL) *ret_fill_R = fill_R;
  if(ret_fill_T != NULL) *ret_fill_T = fill_T;

  if(invalid_idx) return eslEINVAL;
  return eslOK;
}

/*****************************************************************
 * Benchmark driver
 *****************************************************************/
#ifdef IMPL_TRUNC_SEARCH_BENCHMARK
/* Next line is optimized (debugging not on) on wyvern:
 * gcc   -o benchmark-trunc-search -std=gnu99 -O3 -fomit-frame-pointer -malign-double -fstrict-aliasing -pthread -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_TRUNC_SEARCH_BENCHMARK cm_dpsearch_trunc.c -linfernal -lhmmer -leasel -lm
 * gcc   -o benchmark-trunc-search -std=gnu99 -g -Wall -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DIMPL_TRUNC_SEARCH_BENCHMARK cm_dpsearch_trunc.c -linfernal -lhmmer -leasel -lm
 * ./benchmark-trunc-search <cmfile>
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",           0 },
  { "-s",        eslARG_INT,    "181", NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>, '0' for one-time arbitrary", 0 },
  { "-e",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "emit sequences from CM, don't randomly create them", 0 },
  { "-g",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "search in glocal mode [default: local]", 0 },
  { "-T",        eslARG_REAL,    "5.", NULL, NULL,  NULL,  NULL, NULL, "set bit score reporting threshold as <x>",       0 },
  { "--orig",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also search with original trCYK",                0},
  { "--dc",      eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also search with D&C trCYK",                     0},
  { "--noqdb",   eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "don't use QDBs", 0},
  { "--i27",     eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "reproduce Kolbe, Eddy 2009 marginal score calculation", 0 },
  { "--hb",      eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also run HMM banded scanning trCYK", 0 },
  { "--onlyhb",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "only run HMM banded scanning trCYK", 0 },
  { "--ins",     eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also run trInside", 0 },
  { "--tau",     eslARG_REAL,   "5e-6",NULL, "0<x<1",NULL, NULL, NULL, "set tail loss prob for --hb to <x>", 0 },
  { "--cp9noel", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, "-g",           "turn OFF local ends in cp9 HMMs", 0 },
  { "--cp9gloc", eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, "-g,--cp9noel", "configure CP9 HMM in glocal mode", 0 },
  { "--thresh1", eslARG_REAL,  "0.01", NULL, NULL,  NULL,  NULL,  NULL, "set HMM bands thresh1 to <x>", 0 },
  { "--thresh2", eslARG_REAL,  "0.99", NULL, NULL,  NULL,  NULL,  NULL, "set HMM bands thresh2 to <x>", 0 },
  { "--sizelimit",eslARG_REAL, "128.", NULL, "x>0", NULL,  NULL,  NULL, "set maximum allowed size of HB matrices to <x> Mb", 0 },
  { "--anytrunc",eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL,"--5ponly,--3ponly",   "allow truncated hits anywhere in the sequence", 0 },
  { "--5ponly",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL,"--anytrunc,--3ponly", "only allow 5' truncations", 0 },
  { "--3ponly",  eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL,"--anytrunc,--5ponly", "only allow 3' truncations", 0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile>";
static char banner[] = "benchmark driver for scanning trCYK implementations";

int
main(int argc, char **argv)
{
  int             status;
  ESL_GETOPTS    *go      = esl_getopts_CreateDefaultApp(options, 2, argc, argv, banner, usage);
  CM_t           *cm;
  ESL_STOPWATCH  *w       = esl_stopwatch_Create();
  ESL_ALPHABET   *abc     = NULL;
  int             L;
  ESL_DSQ        *dsq;
  int             i;
  float           sc;
  char            mode;
  char           *cmfile = esl_opt_GetArg(go, 1);
  char           *seqfile = esl_opt_GetArg(go, 2);
  CM_FILE        *cmfp;	/* open input CM file stream */
  ESL_SQFILE     *sqfp  = NULL;  /* open sequence input file stream */
  ESL_SQ         *sq    = NULL;  /* a sequence */
  char            errbuf[eslERRBUFSIZE];
  Parsetree_t    *tr    = NULL;
  float           size_limit = esl_opt_GetReal(go, "--sizelimit");
  float           save_tau, save_cp9b_thresh1, save_cp9b_thresh2;
  float           hbmx_Mb, trhbmx_Mb;
  int             qdbidx;
  int             pass_idx;

  /* open CM file */
  if ((status = cm_file_Open(cmfile, NULL, FALSE, &(cmfp), errbuf)) != eslOK) cm_Fail(errbuf);
  if ((status = cm_file_Read(cmfp, TRUE, &abc, &cm))                != eslOK) cm_Fail(cmfp->errbuf);
  cm_file_Close(cmfp);

  /* open the sequence file */
  status = esl_sqfile_OpenDigital(cm->abc, seqfile, eslSQFILE_UNKNOWN, NULL, &sqfp);
  if (status == eslENOTFOUND)    esl_fatal("File %s doesn't exist or is not readable\n", seqfile);
  else if (status == eslEFORMAT) esl_fatal("Couldn't determine format of sequence file %s\n", seqfile);
  else if (status == eslEINVAL)  esl_fatal("Can't autodetect stdin or .gz.");
  else if (status != eslOK)      esl_fatal("Sequence file open failed with error %d.\n", status);

  /* configure cm */
  if(! esl_opt_GetBoolean(go, "-g")) {
	cm->config_opts |= CM_CONFIG_LOCAL;
	if(! esl_opt_GetBoolean(go, "--cp9gloc")) {
	  cm->config_opts |= CM_CONFIG_HMMLOCAL;
	  if(! esl_opt_GetBoolean(go, "--cp9noel")) cm->config_opts |= CM_CONFIG_HMMEL;
	}
  }
  if( esl_opt_GetBoolean(go, "--noqdb")) cm->search_opts |= CM_SEARCH_NONBANDED;
  cm->config_opts |= CM_CONFIG_TRUNC;
  cm->config_opts |= CM_CONFIG_SCANMX;
  cm->config_opts |= CM_CONFIG_TRSCANMX;
  cm->tau = esl_opt_GetReal(go, "--tau");  /* this will be DEFAULT_TAU unless changed at command line */
  qdbidx = esl_opt_GetBoolean(go, "--noqdb") ? SMX_NOQDB : SMX_QDB1_TIGHT;
  if (esl_opt_IsUsed(go, "--thresh1")) { cm->cp9b->thresh1 = esl_opt_GetReal(go, "--thresh1"); }
  if (esl_opt_IsUsed(go, "--thresh2")) { cm->cp9b->thresh2 = esl_opt_GetReal(go, "--thresh2"); }

  if     (esl_opt_GetBoolean(go, "--anytrunc")) pass_idx = PLI_PASS_5P_AND_3P_ANY;
  else if(esl_opt_GetBoolean(go, "--5ponly"))   pass_idx = PLI_PASS_5P_ONLY_FORCE;
  else if(esl_opt_GetBoolean(go, "--3ponly"))   pass_idx = PLI_PASS_3P_ONLY_FORCE;
  else                                          pass_idx = PLI_PASS_5P_AND_3P_FORCE;

  if((status = cm_Configure(cm, errbuf, -1)) != eslOK) cm_Fail(errbuf);

  /* setup logsum lookups (could do this only if nec based on options, but this is safer) */
  init_ilogsum();
  FLogsumInit();

  if(esl_opt_GetBoolean(go, "--i27")) {
	SetMarginalScores_reproduce_i27(cm);
  }

  save_tau = cm->tau;
  save_cp9b_thresh1 = cm->cp9b->thresh1;
  save_cp9b_thresh2 = cm->cp9b->thresh2;

  i = 0;
  sq = esl_sq_CreateDigital(cm->abc);
  while((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	i++;
	L = sq->n;
	dsq = sq->dsq;
	cm->search_opts &= ~CM_SEARCH_INSIDE;

	cm->tau = save_tau;
	cm->cp9b->thresh1 = save_cp9b_thresh1;
	cm->cp9b->thresh2 = save_cp9b_thresh2;

	if(esl_opt_GetBoolean(go, "--hb") || esl_opt_GetBoolean(go, "--onlyhb")) {
	  cm->align_opts  |= CM_ALIGN_HBANDED;

	  esl_stopwatch_Start(w);
	  while(1) {
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				   TRUE,  /* doing search? */
				   PLI_PASS_STD_ANY,  /* we are not allowing truncated alignments */
				   0)) != eslOK) cm_Fail(errbuf);
	if((status = cm_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, &hbmx_Mb)) != eslOK) return status;
	if(hbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	printf("  CYK 0 tau: %10g  hbmx_Mb: %10.2f\n", cm->tau, hbmx_Mb);
	cm->tau *= 2.;
	  }

	  esl_stopwatch_Stop(w);
	  printf("%4d %-30s %17s", i, "HMM Band calc:", "");
	  esl_stopwatch_Display(stdout, w, "CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = FastCYKScanHB(cm, errbuf, cm->hb_mx, size_limit, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastCYKScanHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = FastFInsideScanHB(cm, errbuf, cm->hb_mx, size_limit, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastFInsideScanHB(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  /* Calculate HMM bands. We'll tighten tau and recalculate bands until
	   * the resulting HMM banded matrix is under our size limit.
	   */
	  cm->tau = save_tau;
	  while(1) {
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, 1, L, cm->cp9b,
				   TRUE,  /* doing search? */
				   pass_idx, 0)) != eslOK) cm_Fail(errbuf);
	if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, L, NULL, NULL, NULL, NULL, &trhbmx_Mb)) != eslOK) return status;
	if(trhbmx_Mb < size_limit) break; /* our matrix will be small enough, break out of while(1) */
	if(cm->tau > 0.01)         cm_Fail("tau reached limit, unable to create matrix smaller than size limit of %.2f Mb\n", size_limit);
	printf("TrCYK 0 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	cm->tau *= 2.;
	cm->cp9b->thresh1 *= 2.;
	cm->cp9b->thresh2 -= (1.0-cm->cp9b->thresh2);
	cm->cp9b->thresh1 = ESL_MIN(0.25, cm->cp9b->thresh1);
	cm->cp9b->thresh2 = ESL_MAX(0.25, cm->cp9b->thresh2);
	  }
	  printf("TrCYK 1 tau: %10g  thresh1: %10g  thresh2: %10g  trhbmx_Mb: %10.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, trhbmx_Mb);
	  esl_stopwatch_Stop(w);
	  printf("%4d %-30s %17s", i, "HMM Band calc:", "");
	  esl_stopwatch_Display(stdout, w, "CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = TrCYKScanHB(cm, errbuf, cm->trhb_mx, size_limit, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0.,  NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (mode: %s)", i, "TrCYKScanHB(): ", sc, MarginalMode(mode));
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if(esl_opt_GetBoolean(go, "--ins")) {
	esl_stopwatch_Start(w);
	if((status = FTrInsideScanHB(cm, errbuf, cm->trhb_mx, size_limit, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0.,  NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	printf("%4d %-30s %10.4f bits (mode: %s)", i, "FTrInsideScanHB(): ", sc, MarginalMode(mode));
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	  }
	}

	if(! esl_opt_GetBoolean(go, "--onlyhb")) {
	  esl_stopwatch_Start(w);
	  if((status = FastCYKScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastCYKScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  esl_stopwatch_Start(w);
	  if((status = RefCYKScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefCYKScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = RefTrCYKScan(cm, errbuf, cm->trsmx, qdbidx,  pass_idx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (mode: %s)", i, "RefTrCYKScan(): ", sc, MarginalMode(mode));
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if(esl_opt_GetBoolean(go, "--orig")) {
	esl_stopwatch_Start(w);
	sc = TrCYK_Inside(cm, dsq, L, 0, 1, L, pass_idx, TRUE, FALSE, &tr);
	printf("%4d %-30s %10.4f bits ", i, "TrCYK_Inside():   ", sc);
	esl_stopwatch_Stop(w);
	esl_stopwatch_Display(stdout, w, " CPU time: ");
	FreeParsetree(tr);
	tr = NULL;
	  }
	}

	if(esl_opt_GetBoolean(go, "--dc")) {
	  esl_stopwatch_Start(w);
	  sc = TrCYK_DnC(cm, dsq, L, 0, 1, L, pass_idx, TRUE, &tr);
	  printf("%4d %-30s %10.4f bits ", i, "TrCYK_DnC():      ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	  FreeParsetree(tr);
	  tr = NULL;
	}

	if(esl_opt_GetBoolean(go, "--ins")) {
	  cm->search_opts  |= CM_SEARCH_INSIDE;

	  esl_stopwatch_Start(w);
	  if((status = RefITrInsideScan(cm, errbuf, cm->trsmx, qdbidx, pass_idx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &mode, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits (mode: %s)", i, "RefITrInsideScan(): ", sc, MarginalMode(mode));
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = FastIInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastIInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = RefIInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefIInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = FastFInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "FastFInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = RefFInsideScan(cm, errbuf, cm->smx, qdbidx, dsq, 1, L, 0., NULL, FALSE, 0., NULL, NULL, NULL, &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", i, "RefFInsideScan(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	printf("\n");
	esl_sq_Reuse(sq);
	if(tr != NULL) { FreeParsetree(tr); tr = NULL; }
  }
  FreeCM(cm);
  esl_sq_Destroy(sq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_getopts_Destroy(go);
  return 0;
}
#endif /*IMPL_TRUNC_SEARCH_BENCHMARK*/

/*** End of inlined file: cm_dpsearch_trunc.c ***/


/*** Start of inlined file: cm_dpsmall.c ***/
/*################################################################
 * smallcyk's external API:
 *
 * CYKDivideAndConquer()    - The divide and conquer algorithm. Align
 *                            a model to a (sub)sequence.
 * CYKInside()              - Align model to (sub)sequence, using normal
 *                            CYK/Inside algorithm.
 * CYKInsideScore()         - Calculate the CYK/Inside score of optimal
 *                            alignment, without recovering the alignment;
 *                            allows timing CYK/Inside without blowing
 *                            out memory, for large target RNAs.
 *
 * CYKDemands()             - Print a bunch of info comparing predicted d&c
 *                            time/memory requirements to standard CYK/inside
 *                            time/memory requirements.
 *
 * All of these functions can take query dependent bands (dmin
 * and dmax) or have them passed as NULL.
 *################################################################
 */


/* The dividers and conquerors.
 */
static float generic_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			      int r, int vend, int i0, int j0);
static float wedge_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			    int r, int z, int i0, int j0);
static void  v_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			int r, int z, int i0, int i1, int j1, int j0, int useEL);

/* The alignment engines.
 */
static float inside(CM_t *cm, ESL_DSQ *dsq, int L,
		    int r, int z, int i0, int j0, int do_full,
		    float ***alpha, float ****ret_alpha,
		    struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		    void ****ret_shadow, int allow_begin, int *ret_b, float *ret_bsc);
static void  outside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0,
		     int do_full, float ***beta, float ****ret_beta,
		     struct deckpool_s *dpool, struct deckpool_s **ret_dpool);
static float vinside(CM_t *cm, ESL_DSQ *dsq, int L,
		     int r, int z, int i0, int i1, int j1, int j0, int useEL,
		     int do_full, float ***a, float ****ret_a,
		     struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		     char ****ret_shadow,
		     int allow_begin, int *ret_b, float *ret_bsc);
static void  voutside(CM_t *cm, ESL_DSQ *dsq, int L,
		      int r, int z, int i0, int i1, int j1, int j0, int useEL,
		      int do_full, float ***beta, float ****ret_beta,
		      struct deckpool_s *dpool, struct deckpool_s **ret_dpool);

/* The traceback routines.
 */
static float insideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
		     int r, int z, int i0, int j0, int allow_begin,
		     int *dmin, int *dmax);
static float vinsideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
		      int r, int z, int i0, int i1, int j1, int j0, int useEL,
		      int allow_begin, int *dmin, int *dmax);

/* The size calculators.
 */
float insideT_size(CM_t *cm, int L, int r, int z, int i0, int j0);
float vinsideT_size(CM_t *cm, int r, int z, int i0, int i1, int j1, int j0);
static int   cyk_deck_count(CM_t *cm, int r, int z);
static int   cyk_extra_decks(CM_t *cm);

/* The memory management routines are in infernal.h so hmmband.c can access them
 */

/*******************************************************************************
 * EPN: Banded functions are named *_b()
 * Functions that I don't think need a banded version are indicated with a U
 * before their names.
 *
 * To change *most* of the following code from banded to normal versions, two
 * 'replace-string's would be done :
 * (1) replace '_b(' with '(' : to replace all banded function calls with calls
 *     to their non-banded versions.
 * (2) replace ', dmin, dmax)' with ')' : all banded functions have exactly
 *     two extra variables passed in, dmin a pointer to an int array with minimum
 *     bands, and dmax, a pointer to an int array with maximum bands.  Further,
 *     these are always the last two variables passed into a function.
 *
 * There are two classes of changes that were made to the original functions
 * to make (what I think are) functioning banded versions (*_b()).
 *
 * Class 1 : vjd deck changes - using dmin and dmax as bands
 * Class 2 : vji deck changes - using imin and imax (derived from dmin and dmax)
 *
 * Class 2 changes occur only within v problems, only functions : v_splitter_b(),
 * vinside_b(), and voutside_b().
 *
 * The class 1 changes are more straightforward relative to the class 2 changes.
 * This is completely due to the fact that the vjd coordinate system directly
 * uses d (distance of subsequence in parse tree rooted at state v) which
 * corresponds conveniently with dmin and dmax.
 *
 * Class 1 changes are usually involved with a for loop that involves
 * the d index in either the alpha or the beta matrix.  The original for loops
 * are simply replaced with a new for loop that enforces the bands.
 *
 * Class 2 changes that involve the vji decks involve several offset variables
 * because the implicit d value for a given vji cell has to be calculated.  The
 * formula for that conversion is simple :   d = j-i+1
 * in the code however, jp and ip are used where jp = j-j1 and ip = i-i0.
 * so we have :  d = (jp+j1) - (ip+i0) + 1
 *
 * The way this is handled is only one possible way (and not necessarily the best way)
 * but saves some calculations from being repeated and is somewhat consistent with
 * analagous code elsewhere.  Also the way it's handled here is somewhat general
 * and could be easily changed.
 *
 * That approach is to use an imin[] and imax[] vector, somewhat analagous to
 * dmin[] and dmax[], indexed by states where states in the imin
 * and imax vectors are offset (usually by r or w1) because v problems don't involve
 * the entire set of 0..M-1 states.  Because determining a d for a given vji
 * cell depends on both jp and ip, we can't calculate the bands for a given
 * state (vji deck) independent of jp.  Therefore, imin[] and imax[] are calculated
 * independent of jp, and jp must be added within a for(jp...) loop to determine
 * the actual band in the i dimension.
 *
 * So imin[v-r] = j1-i0-dmax[v]+1;
 *    imax[v-r] = j1-i0-dmin[v]+1;
 *
 * Here's an example of using imin and imax within a for(jp ... ) loop :
 *	  for (jp = 0; jp <= j0-j1; jp++)
 *	    {
 * 	      if((imax[v-r]+jp) > (i1-i0)) ip = (i1-i0);
 *	      else ip = imax[v-r] + jp;
 * 	      for(; ip >= imin[v-r]+jp && ip >= 0; ip--) {
 *
 * Code where bands are used in the vji deck are marked with "Bands used ip X" where X
 * is a number (1-19).  Some of these sections have been commented out as I slowly
 * realized they were mistakes or unnecessary.  There are, admittedly scattered, notes
 * on how I arrived at each of these in :
 * ~nawrocki/lab/rRNA/inf/infernal_0426/banded_testing_0207/00LOG
 *
 * Other changes of both class 1 and 2 involves imposing the bands during
 * the initialization step of the alpha matrix.  These changes
 * add additional code that sets all cells outside the bands to IMPOSSIBLE.
 *
 *******************************************************************************/

/* The banded dividers and conquerors.
 */
static float generic_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
				int r, int vend, int i0, int j0, int *dmin, int *dmax);
static float wedge_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			      int r, int z, int i0, int j0, int *dmin, int *dmax);
static void  v_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			  int r, int z, int i0, int i1, int j1, int j0, int useEL,
			  int *dmin, int *dmax);

/* The banded alignment engines.
 */
static float inside_b(CM_t *cm, ESL_DSQ *dsq, int L,
		      int r, int z, int i0, int j0,
		      int do_full,
		      float ***alpha, float ****ret_alpha,
		      struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		      void ****ret_shadow,
		      int allow_begin, int *ret_b, float *ret_bsc,
		      int *dmin, int *dmax);
static void  outside_b(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0,
		       int do_full, float ***beta, float ****ret_beta,
		       struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		       int *dmin, int *dmax);
static float vinside_b(CM_t *cm, ESL_DSQ *dsq, int L,
		       int r, int z, int i0, int i1, int j1, int j0, int useEL,
		       int do_full, float ***a, float ****ret_a,
		       struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		       char ****ret_shadow,
		       int allow_begin, int *ret_b, float *ret_bsc,
		       int *dmin, int *dmax);
static void  voutside_b(CM_t *cm, ESL_DSQ *dsq, int L,
			int r, int z, int i0, int i1, int j1, int j0, int useEL,
			int do_full, float ***beta, float ****ret_beta,
			struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
			int *dmin, int *dmax);

/* No banded versions of the traceback routines because the non-banded
 * functions can be used.*/

/* No banded size calculators right now. */

/*******************************************************************************
 * 05.24.05
 * EPN MEMORY EFFICIENT BANDED VERSIONS OF SELECTED FUNCTIONS
 * Memory efficient banded functions are named *_b_me()
 *
 * These functions are modified from their originals to make the memory
 * efficient banded FULL (not D&C) CYK implementation work.  These functions
 * are dubbed 'memory efficient' because they only allocate cells of the
 * alpha or shadow matrix which are within the bands.  The non-memory efficient
 * functions (*_b()) still allocate the same memory as the non-banded functions,
 * but only use the cells within the bands, here we actually don't even allocate
 * unnecessary cells.  The only real difficulty implementing memory efficient
 * bands is in being able to determine what cell alpha[v][j][d] from the
 * non-memory efficient code corresponds to in the memory-efficient code (we'll
 * call the corresponding cell a[v'][j'][d'] or a[vp][jp][dp]).  The reason
 * v != v'; j != j' and d != d' is because the primes are offset due to the
 * fact that some of the original alpha matrix deck (a[v]) has not been allocated
 * due to the bands.  Therefore all of the differences between the *_b_me() functions
 * and their *_b() versions is to deal with the offset issue.
 *
 * All changes from the original (non-memory efficient) banded code have been
 * marked with comments beginning 'CYK Full ME Bands Used'.
 *
 * There are only two functions that need seperate _b_me() versions, because
 * the non D&C alignment algorithm only involves three functions, CYKInside(),
 * inside(), and insideT(), and the CYKInside() is really only a wrapper,
 * for which the memory efficient implementation has no effect, so all we
 * need is inside_b_me() and insideT_b_me().
 *
 *******************************************************************************/

/* The alignment engines.
 */
static float inside_b_me(CM_t *cm, ESL_DSQ *dsq, int L,
			 int r, int z, int i0, int j0,
			 int do_full,
			 float ***alpha, float ****ret_alpha,
			 void ****ret_shadow,
			 int allow_begin, int *ret_b, float *ret_bsc,
			 int *dmin, int *dmax);

/* The traceback routines.
 * At first, it wasn't immediately obvious that a *_me version of
 * this function was needed, but there's some crazy offset issues. [EPN]
 */

static float insideT_b_me(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
			  int r, int z, int i0, int j0, int allow_begin,
			  int *dmin, int *dmax);

/* Function: CYKDivideAndConquer()
 * Date:     SRE, Sun Jun  3 19:32:14 2001 [St. Louis]
 *
 * Purpose:  Align a CM to a (sub)sequence using the divide and conquer
 *           algorithm. Return the score (in bits) and a traceback
 *           structure.
 *
 *           The simplest call to this, for a model cm and a sequence
 *           dsq of length L and no bands on d:
 *               CYKDivideAndConquer(cm, dsq, L, 0, 1, &tr, NULL, NULL);
 *           which will align the model to the entire sequence. (The alignment
 *           will be global w.r.t the sequence.)
 *
 *           Sometimes we already know the second state in the traceback:
 *           a CYKScan() will tell us r, for a 0->r local begin transition.
 *           (It also tells us i0, j0: the bounds of a high-scoring subsequence
 *           hit in the target sequence.)  We take all this information in
 *           as a shortcut. The 0->r transition is still counted
 *           towards the score. That is, CYKDivideAndConquer() always
 *           gives a parsetree rooted at state 0, the root, and the sc
 *           we return is the score for that complete parse tree.
 *
 * Args:     cm     - the covariance model
 *           dsq    - the digitized sequence, 1..L
 *           L      - length of sequence
 *           r      - root of subgraph to align to target subseq (usually 0, the model's root)
 *           i0     - start of target subsequence (often 1, beginning of sq)
 *           j0     - end of target subsequence (often L, end of sq)
 *           ret_tr - RETURN: traceback (pass NULL if trace isn't wanted)
 *           dmin   - minimum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *           dmax   - maximum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *
 * Returns: score of the alignment in bits.
 */
float
CYKDivideAndConquer(CM_t *cm, ESL_DSQ *dsq, int L, int r, int i0, int j0, Parsetree_t **ret_tr,
		    int *dmin, int *dmax)
{
  Parsetree_t *tr;
  float        sc;
  int          z;

  /*printf("alignment strategy:CYKDivideAndConquer:nb:small\n");*/
  /* Trust, but verify.
   * Check out input parameters.
   */
  if (cm->stid[r] != ROOT_S) {
	if (! (cm->flags & CMH_LOCAL_BEGIN)) cm_Fail("internal error: we're not in local mode, but r is not root");
	if (cm->stid[r] != MATP_MP && cm->stid[r] != MATL_ML &&
	cm->stid[r] != MATR_MR && cm->stid[r] != BIF_B)
	  cm_Fail("internal error: trying to do a local begin at a non-mainline start");
  }

  /* Create a parse tree structure.
   * The traceback machinery expects to build on a start state already
   * in the parsetree, so initialize by adding the root state.
   */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, i0, j0, 0); /* init: attach the root S */
  z  = cm->M-1;
  sc = 0.;

  /* If r != 0, we already know we're starting with a local entry transition 0->r;
   * add that node too, and count the begin transition towards the score. We have
   * just done our one allowed local begin, so allow_begin becomes FALSE.
   */
  if (r != 0)
	{
	  InsertTraceNode(tr, 0,  TRACE_LEFT_CHILD, i0, j0, r);
	  z  =  CMSubtreeFindEnd(cm, r);
	  sc =  cm->beginsc[r];
	}

  /* Start the divide and conquer recursion: call the generic_splitter()
   * or generic_splitter_b() on the whole DP cube.
   */
  if(dmin == NULL && dmax == NULL)
	sc += generic_splitter(cm, dsq, L, tr, r, z, i0, j0);
  else
	sc += generic_splitter_b(cm, dsq, L, tr, r, z, i0, j0, dmin, dmax);

  /* Free memory and return
   */
  if (ret_tr != NULL) *ret_tr = tr; else FreeParsetree(tr);
  ESL_DPRINTF1(("returning from CYKDivideAndConquer() sc : %f\n", sc));
  return sc;
}

/* Function: CYKInside()
 * Date:     SRE, Sun Jun  3 19:48:33 2001 [St. Louis]
 *
 * Purpose:  Wrapper for the insideT() routine - solve
 *           a full alignment problem, return the traceback
 *           and the score, without dividing & conquering.
 *
 *           Analogous to CYKDivideAndConquer() in many respects;
 *           see the more extensive comments in that function for
 *           more details on shared aspects.
 *
 * Args:     cm     - the covariance model
 *           sq    - the sequence, 1..L
 *           r      - root of subgraph to align to target subseq (usually 0, the model's root)
 *           i0     - start of target subsequence (often 1, beginning of sq)
 *           j0     - end of target subsequence (often L, end of sq)
 *           ret_tr - RETURN: traceback (pass NULL if trace isn't wanted)
 *           dmin   - minimum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *           dmax   - maximum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *
 * Returns:  score of the alignment in bits.
 */
float
CYKInside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int i0, int j0, Parsetree_t **ret_tr,
	  int *dmin, int *dmax)
{
  Parsetree_t *tr;
  int          z;
  float        sc;

  /* Trust, but verify.
   * Check out input parameters.
   */
  if (cm->stid[r] != ROOT_S) {
	if (! (cm->flags & CMH_LOCAL_BEGIN)) cm_Fail("internal error: we're not in local mode, but r is not root");
	if (cm->stid[r] != MATP_MP && cm->stid[r] != MATL_ML &&
	cm->stid[r] != MATR_MR && cm->stid[r] != BIF_B)
	  cm_Fail("internal error: trying to do a local begin at a non-mainline start");
  }

  /* Create the parse tree, and initialize.
   */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0); /* init: attach the root S */
  z  = cm->M-1;
  sc = 0.;

  /* Deal with case where we already know a local entry transition 0->r
   */
  if (r != 0)
	{
	  InsertTraceNode(tr, 0,  TRACE_LEFT_CHILD, i0, j0, r);
	  z  =  CMSubtreeFindEnd(cm, r);
	  sc =  cm->beginsc[r];
	}

  /* Solve the whole thing with one call to insideT.
   */
  /* if we're non-banded use the original function */
  if(dmin == NULL && dmax == NULL)
	sc += insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0),
		  dmin, dmax);
  /* if we're using query dependent bands, call the
   * memory efficient QDB alignment version.
   */
  else
	sc += insideT_b_me(cm, dsq, L, tr, r, z, i0, j0, (r==0),
	  dmin, dmax);
  /* To call the non-memory efficient version, uncomment
   * the following line: */
  /*sc += insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0),    dmin, dmax);*/

  if (ret_tr != NULL) *ret_tr = tr; else FreeParsetree(tr);
  return sc;
}

/* Function: CYKInsideScore()
 * Date:     SRE, Tue Apr  9 05:21:22 2002 [St. Louis]
 *
 * Purpose:  Wrapper for the inside() routine. Solve
 *           a full alignment problem in one pass of inside,
 *           in memory-saving mode, returning only the score.
 *
 *           Fairly useless. Written just to obtain timings
 *           for SSU and LSU alignments, for comparison to
 *           divide and conquer.
 *
 *           Analogous to CYKDivideAndConquer() in many respects;
 *           see the more extensive comments in that function for
 *           more details on shared aspects.
 *
 * Args:     cm     - the covariance model
 *           dsq    - the sequence, 1..L
 *           L      - length of sequence
 *           r      - root of subgraph to align to target subseq (usually 0, the model's root)
 *           i0     - start of target subsequence (often 1, beginning of sq)
 *           j0     - end of target subsequence (often L, end of sq)
 *           dmin   - minimum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *           dmax   - maximum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *
 * Returns:  score of the alignment in bits.
 */
float
CYKInsideScore(CM_t *cm, ESL_DSQ *dsq, int L, int r, int i0, int j0, int *dmin, int *dmax)
{
  int    z;
  float  sc;

  z           = cm->M-1;
  sc          = 0.;

  if (r != 0)
	{
	  z  =  CMSubtreeFindEnd(cm, r);
	  sc =  cm->beginsc[r];
	}

  if(dmin == NULL && dmax == NULL)
	sc +=  inside(cm, dsq, L, r, z, i0, j0, FALSE,
		  NULL, NULL, NULL, NULL, NULL,
		  (r==0), NULL, NULL);
  else
	sc +=  inside_b(cm, dsq, L, r, z, i0, j0, FALSE,
		    NULL, NULL, NULL, NULL, NULL,
		    (r==0), NULL, NULL, dmin, dmax);

  return sc;
}

/* Function: CYKDemands()
 * Date:     SRE, Sun Jun  3 20:00:54 2001 [St. Louis]
 *
 * Purpose:  Print out information on the computational
 *           complexity of an alignment problem for divide
 *           and conquer versus the full CYK.
 *
 * Args:     cm     - the model
 *           L      - length of sequence.
 *           dmin   - minimum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *           dmax   - maximum d bound for each state v; [0..v..M-1] (NULL if non-banded)
 *           be_quiet - TRUE to not print info, just return number of DP calcs
 *
 * Returns: (float) the total number of DP calculations, either using QDB (if
 *                  dmin & dmax are non-NULL) or not using QDB.
 */
float
CYKDemands(CM_t *cm, int L, int *dmin, int *dmax, int be_quiet)
{
  float Mb_per_deck;    /* megabytes per deck */
  int   bif_decks;	/* bifurcation decks  */
  int   nends;		/* end decks (only need 1, even for multiple E's */
  int   maxdecks;	/* maximum # of decks needed by CYKInside() */
  int   extradecks;     /* max # of extra decks needed for bifurcs */
  float smallmemory;	/* how much memory small version of CYKInside() needs */
  float bigmemory;	/* how much memory a full CYKInside() would take */
  float dpcells;	/* # of dp cells */
  float bifcalcs;	/* # of inner loops executed for bifurcation calculations */
  float bifcalcs_b;	/* # of inner loops executed for bifurcation calculations in QDB */
  float dpcalcs;	/* # of inner loops executed for non-bif calculations */
  float dpcalcs_b;	/* # of inner loops executed for bifurcation calculations in QDB */
  int   j;
  float avg_Mb_per_banded_deck;    /* average megabytes per deck in mem efficient big mode */
  int   v, y, z, d, kmin, kmax; /* for QDB calculations */

  Mb_per_deck = size_vjd_deck(L, 1, L);
  bif_decks   = CMCountStatetype(cm, B_st);
  nends       = CMCountStatetype(cm, E_st);
  maxdecks    = cyk_deck_count(cm, 0, cm->M-1);
  extradecks  = cyk_extra_decks(cm);
  smallmemory = (float) maxdecks * Mb_per_deck;
  bifcalcs = 0.;
  for (j = 0; j <= L; j++)
	bifcalcs += (float)(j+1)*(float)(j+2)/2.;
  bifcalcs *= (float) bif_decks;
  dpcalcs = (float) (L+2)*(float)(L+1)*0.5*(float) (cm->M - bif_decks - nends +1);
  if(dmin == NULL && dmax == NULL)
	{
	  bigmemory   = (float) (cm->M - nends +1) * Mb_per_deck;
	  dpcells     = (float) (L+2)*(float)(L+1)*0.5*(float) (cm->M - nends +1);
	  avg_Mb_per_banded_deck = 0.; /* irrelevant */
	}
  else
	{
	  dpcells = 0.;
	  dpcalcs_b = 0.;
	  for(v = 0; v < cm->M; v++)
	{
	  dpcells   += (float) (L+1) * (float) (dmax[v] - dmin[v] + 1.);
	  if(cm->sttype[v] != B_st)
	    dpcalcs_b   += (float) (L+1) * (float) (dmax[v] - dmin[v] + 1.);
	  for(d = dmin[v]; d <= dmax[v]; d++)
	    {
	      dpcells -= (float) d; /* subtract out cells for which d <= j */
	      if(cm->sttype[v] != B_st)
		dpcalcs_b   -= (float) d;
	    }
	}
	  bigmemory   = (sizeof(float) * dpcells) / 1000000.;
	  avg_Mb_per_banded_deck = bigmemory / ((float) cm->M -nends + 1);
	  /* bigmemory and avg_Mb_per_banded_deck should be treated as approximates,
	   * I'm not sure if they're exactly correct. EPN, Mon Nov  6 07:56:13 2006 */

	  /* for QDB, to get bifcalcs, we need to count all the cells within the bands on
	   * left and right childs y and z of v, that are consistent with band on v
	   * there's probably a more efficient way of doing this. */
	  bifcalcs_b = 0.;
	  for (v = 0; v < cm->M; v++)
	{
	  if(cm->sttype[v] == B_st)
	    {
	      y = cm->cfirst[v];
	      z = cm->cnum[v];
	      for (j = 0; j <= L; j++)
		{
		  for (d = dmin[v]; d <= dmax[v] && d <= j; d++)
		    {
		      if(dmin[z] > (d-dmax[y])) kmin = dmin[z];
		      else kmin = d-dmax[y];
		      if(kmin < 0) kmin = 0;
		      if(dmax[z] < (d-dmin[y])) kmax = dmax[z];
		      else kmax = d-dmin[y];
		      if(kmin <= kmax)
			bifcalcs_b += (float)(kmax - kmin + 1);
		    }
		}
	    }
	}
	}

  if(dmin == NULL && dmax == NULL)
	{
	  if(!be_quiet)
	{
	  printf("CYK cpu/memory demand estimates:\n");
	  printf("Mb per cyk deck:                  %.4f\n", Mb_per_deck);
	  printf("# of decks (M):                   %d\n",   cm->M);
	  printf("# of decks needed in small CYK:   %d\n",   maxdecks);
	  printf("# of extra decks needed:          %d\n",   extradecks);
	  printf("RAM needed for full CYK, Mb:      %.2f\n", bigmemory);
	  printf("RAM needed for small CYK, Mb:     %.2f\n", smallmemory);
	  printf("# of dp cells, total:             %.3g\n", dpcells);
	  printf("# of non-bifurc dp cells:         %.3g\n", dpcalcs);
	  printf("# of bifurcations:                %d\n",   bif_decks);
	  printf("# of bifurc dp inner loop calcs:  %.3g\n", bifcalcs);
	  printf("# of dp inner loops:              %.3g\n", dpcalcs+bifcalcs);
	}
	  return (dpcalcs + bifcalcs);
	}
  else /* QDB */
	{
	  if(!be_quiet)
	{
	  printf("QDB CYK cpu/memory demand estimates:\n");
	  printf("Mb per cyk deck:                     %.4f\n", Mb_per_deck);
	  printf("Avg Mb per QDB cyk deck:             %.4f\n", avg_Mb_per_banded_deck);
	  printf("# of decks (M):                      %d\n",   cm->M);
	  printf("# of decks needed in small QDB CYK:  %d\n",   maxdecks);
	  printf("# of extra decks needed:             %d\n",   extradecks);
	  printf("RAM needed for full QDB CYK, Mb:     %.2f\n", bigmemory);
	  printf("RAM needed for small QDB CYK, Mb:    %.2f\n", smallmemory);
	  printf("# of QDB dp cells, total:            %.3g\n", dpcells);
	  printf("# of QDB non-bifurc dp cells:        %.3g\n", dpcalcs_b);
	  printf("# of bifurcations:                   %d\n",   bif_decks);
	  printf("# of QDB bifurc dp inner loop calcs: %.3g\n", bifcalcs_b);
	  printf("# of QDB dp inner loops:             %.3g\n", dpcalcs_b+bifcalcs_b);
	  printf("Estimated small CYK QDB aln speedup: %.4f\n", ((dpcalcs+bifcalcs)/(dpcalcs_b+bifcalcs_b)));
	}
	  return (dpcalcs_b + bifcalcs_b);
	}
}

/* Function: CYKNonQDBSmallMbNeeded()
 * Date:     EPN, Fri May 27 11:43:56 2011
 *
 * Purpose:  Return number of Mb needed for non-QDB
 *           divide and conquer CYK.
 *
 * Args:     cm     - the model
 *           L      - length of sequence.
 *
 * Returns: Number of Mb required.
 */
float
CYKNonQDBSmallMbNeeded(CM_t *cm, int L)
{
  float Mb_per_deck;    /* megabytes per deck */
  int   maxdecks;	/* maximum # of decks needed by CYKInside() */
  float smallmemory;	/* how much memory small version of CYKInside() needs */

  Mb_per_deck = size_vjd_deck(L, 1, L);
  maxdecks    = cyk_deck_count(cm, 0, cm->M-1);
  smallmemory = (float) maxdecks * Mb_per_deck;
  return smallmemory;
}

/*################################################################
 * The dividers and conquerors.
 *################################################################*/

/* Function: generic_splitter()
 * Date:     SRE, Sat May 12 15:08:38 2001 [CSHL]
 *
 * Purpose:  Solve a "generic problem": best parse of
 *           a possibly bifurcated subgraph cm^r_z to
 *           a substring sq->sq[i0..j0]. r is usually a start
 *           state (S_st) but may be any non-end state type in
 *           the case of local alignment begins (ROOT 0->r).
 *           z is always an end state (E_st).
 *
 *           Given: a cm subgraph from r..z
 *                  a subsequence from i0..j0
 *           Attaches the optimal trace T{r..z}, exclusive of r
 *           and inclusive of z, to tr.
 *
 *           A full divide & conquer never terminates
 *           in generic_splitter; the recursion must
 *           terminate in v_splitter and wedge_splitter;
 *           so we don't test an end-of-recursion boundary.
 *
 * Args:     cm          - model
 *           sq          - sequence, digitized, 1..L
 *           tr          - the traceback we're adding on to.
 *           r           - index of the root state of this problem in the model
 *           z           - index of an end state (E_st) in the model
 *           i0          - start in the sequence (1..L)
 *           j0          - end in the sequence (1..L)
 *
 * Returns:  score of the optimal parse of sq(i0..j0) with cm^r_z
 */
static float
generic_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
		 int r, int z, int i0, int j0)
{
  float ***alpha;
  float ***beta;
  struct deckpool_s *pool;
  int      v,w,y;		/* state indices */
  int      wend, yend;		/* indices for end of subgraphs rooted at w,y */
  int      jp;			/* j': relative position in subseq, 0..W */
  int      W;			/* length of subseq i0..j0 */
  float    sc;			/* tmp variable for a score */
  int      j,d,k;		/* sequence indices */
  float    best_sc;		/* optimal score at the optimal split point */
  int      best_k;		/* optimal k for the optimal split */
  int      best_d;		/* optimal d for the optimal split */
  int      best_j;		/* optimal j for the optimal split */
  int      tv;			/* remember the position of a bifurc in the trace. */
  int      b1,b2;		/* argmax_v for 0->v local begin transitions */
  float    b1_sc, b2_sc;	/* max_v scores for 0->v local begin transitions */

  /* 1. If the generic problem is small enough, solve it with inside^T,
   *    and append the trace to tr.
   */
  if (insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT) {
	ESL_DPRINTF2(("Solving a generic w/ insideT - G%d[%s]..%d[%s], %d..%d\n",
		  r, UniqueStatetype(cm->stid[r]),
		  z, UniqueStatetype(cm->stid[z]),
		  i0, j0));
	sc = insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0),
		NULL, NULL); /* two NULLs mean 'don't use bands' */

	return sc;
  }

  /* 2. Traverse down from r, find first bifurc.
   *    The lowest a bifurc could be: B-S-E/S-IL-E = vend-5
   *
   */
  for (v = r; v <= z-5; v++)
	if (cm->sttype[v] == B_st) break; /* found the first bifurcation, now v */

  /* 3. If there was no bifurcation, this is a wedge problem; solve it
   *    with wedge_splitter.
   */
  if (v > z-5) {		/* no bifurc? it's a wedge problem  */
	if (cm->sttype[z] != E_st) cm_Fail("inconceivable.");
	sc = wedge_splitter(cm, dsq, L, tr, r, z, i0, j0);
	return sc;
  }

  /* Set up the state quartet r,v,w,y for a divide and conquer
   * solution of the generic problem.
   */
  w = cm->cfirst[v];		/* index of left S  */
  y = cm->cnum[v];		/* index right S    */
  if (w < y) { wend = y-1; yend = z; }
  else       { yend = w-1; wend = z; }

  /* Calculate alpha[w] deck and alpha[y] deck.
   * We also get b1: best choice for 0->b local begin. b1_sc is the score if we do this.
   * Analogous for b2, b2_sc on the other side.
   */
  inside(cm, dsq, L, w, wend, i0, j0, BE_EFFICIENT, NULL,  &alpha, NULL, &pool, NULL,
	 (r==0), &b1, &b1_sc);
  inside(cm, dsq, L, y, yend, i0, j0, BE_EFFICIENT, alpha, &alpha, pool, &pool, NULL,
	 (r==0), &b2, &b2_sc);

  /* Calculate beta[v] deck (stick it in alpha). Let the pool get free'd.
   * (If we're doing local alignment, deck M is the beta[EL] deck.)
   */
  outside(cm, dsq, L, r, v, i0, j0, BE_EFFICIENT, alpha, &beta, pool, NULL);

  /* Find the optimal split at the B.
   */
  W = j0-i0+1;
  best_sc = IMPOSSIBLE;
  for (jp = 0; jp <= W; jp++)
	{
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	for (k = 0; k <= d; k++)
	  if ((sc = alpha[w][j-k][d-k] + alpha[y][j][k] + beta[v][j][d]) > best_sc)
	    {
	      best_sc = sc;
	      best_k  = k;
	      best_j  = j;
	      best_d  = d;
	    }
	}

  /* Local alignment only: maybe we're better off in EL?
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	for (d = jp; d >= 0; d--)
	  if ((sc = beta[cm->M][j][d]) > best_sc) {
	    best_sc = sc;
	    best_k  = -1;	/* special flag for local end, EL. */
	    best_j  = j;
	    best_d  = d;
	  }
	  }
  }

  /* Local alignment only: maybe we're better off in ROOT?
   */
  if (r == 0 && cm->flags & CMH_LOCAL_BEGIN) {
	if (b1_sc > best_sc) {
	  best_sc = b1_sc;
	  best_k  = -2;		/* flag for using local begin into left wedge w..wend */
	  best_j  = j0;
	  best_d  = W;
	}
	if (b2_sc > best_sc) {
	  best_sc = b2_sc;
	  best_k  = -3;		/* flag for using local begin into right wedge y..yend */
	  best_j  = j0;
	  best_d  = W;
	}
  }

  /* Free now, before recursing.
   * The two alpha matrices and the beta matrix
   * actually all point to the same memory, since no
   * decks in Inside and Outside needed to overlap.
   * Free 'em all in one call.
   */
  free_vjd_matrix(alpha, cm->M, i0, j0);

  /* If we're in EL, instead of B, the optimal alignment is entirely
   * in a V problem that's still above us. The TRUE flag sets useEL.
   */
  if (best_k == -1) {
	v_splitter(cm, dsq, L, tr, r, v, i0, best_j-best_d+1, best_j, j0, TRUE);
	return best_sc;
  }

  /* Else: if we're in the root 0, we know which r we did our local begin into.
   * We have a generic problem rooted there. The FALSE flag disallows
   * any further local begins.
   */
  if (best_k == -2) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b1);
	z = CMSubtreeFindEnd(cm, b1);
	generic_splitter(cm, dsq, L, tr, b1, z, i0, j0);
	return best_sc;
  }
  if (best_k == -3) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b2);
	z = CMSubtreeFindEnd(cm, b2);
	generic_splitter(cm, dsq, L, tr, b2, z, i0, j0);
	return best_sc;
  }

  /* Else (the usual case), ok, we did use B in the optimal split.
   * Split now into a V problem and two generic problems, and recurse
   * left fragment: i1 = j-d+1, j1 = j-k, vroot = w, vend = wend
   * right frag:    i2 = j-k+1, j2 = j,   vroot = y, vend = yend
   *
   * The problems must be solved in a particular order, since we're
   * constructing the trace in a postorder traversal.
   */
  ESL_DPRINTF2(("Generic splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		v, UniqueStatetype(cm->stid[v]),
		i0, best_j-best_d+1, best_j, j0));
  ESL_DPRINTF2(("   generic: G%d[%s]..%d[%s], %d..%d\n",
		w,    UniqueStatetype(cm->stid[w]),
		wend, UniqueStatetype(cm->stid[wend]),
		best_j-best_d+1, best_j-best_k));
  ESL_DPRINTF2(("   generic: G%d[%s]..%d[%s], %d..%d\n",
		y,    UniqueStatetype(cm->stid[y]),
		yend, UniqueStatetype(cm->stid[yend]),
		best_j-best_k+1, best_j));

  v_splitter(cm, dsq, L, tr, r, v, i0, best_j-best_d+1, best_j, j0, FALSE);
  tv = tr->n-1;

  InsertTraceNode(tr, tv, TRACE_LEFT_CHILD, best_j-best_d+1, best_j-best_k, w);
  generic_splitter(cm, dsq, L, tr, w, wend, best_j-best_d+1, best_j-best_k);
  InsertTraceNode(tr, tv, TRACE_RIGHT_CHILD, best_j-best_k+1, best_j, y);
  generic_splitter(cm, dsq, L, tr, y, yend, best_j-best_k+1, best_j);

  return best_sc;
}

/* Function: wedge_splitter()
 * Date:     SRE, Sun May 13 08:44:15 2001 [CSHL genome mtg]
 *
 * Purpose:  Solve a "wedge problem": best parse of an
 *           unbifurcated subgraph cm^r..z to a substring
 *           sq->sq[i0..j0]. r may be a start state (when
 *           the wedge problem comes from being a special case
 *           of a generic problem) or a non-insert state
 *           (D, MP, ML, MR) (when the wedge comes from a
 *           previous wedge_splitter), or indeed, any non-end
 *           state (when wedge comes from a local begin).
 *           z, however, is always an end state.
 *
 *           Attaches the optimal trace T(r..z), exclusive
 *           of r and inclusive of z, to the growing trace tr.
 *
 *           Deal with a divide and conquer boundary condition:
 *           the next non-insert state after r is the end state z.
 *           All remaining sequence of i0..j0 that r doesn't emit
 *           must be dealt with by insert states.
 *
 * Args:     cm          - model
 *           sq          - digitized sequence 1..L
 *           tr          - the traceback we're adding on to.
 *           r           - index of the first state in the subgraph
 *           z           - index of an end state (E_st) in the model
 *           i0          - start in the sequence (1..L)
 *           j0          - end in the sequence (1..L)
 *
 * Returns:  The score of the best parse in bits.
 */
static float
wedge_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z, int i0, int j0)
{
  float ***alpha;
  float ***beta;
  struct deckpool_s *pool;
  float sc;
  float best_sc;
  int   v,w,y;
  int   W;
  int   d, jp, j;
  int   best_v, best_d, best_j;
  int   midnode;
  int   b;	/* optimal local begin: b = argmax_v alpha_v(i0,j0) + t_0(v) */
  float bsc;	/* score for optimal local begin      */

  /* 1. If the wedge problem is either a boundary condition,
   *    or small enough, solve it with inside^T and append
   *    the trace to tr.
   *    It's formally possible that someone could set RAMLIMIT
   *    to something so small that even the boundary condition
   *    couldn't be done with inside^T - but that'd be a silly
   *    thing to do, so we ignore RAMLIMIT in that case.
   */
  if (cm->ndidx[z] == cm->ndidx[r] + 1 ||
	  insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT)
	{
	  ESL_DPRINTF2(("Solving a wedge:   G%d[%s]..%d[%s], %d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		z, UniqueStatetype(cm->stid[z]),
		i0,j0));
	  sc = insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0),
		   NULL, NULL); /* two NULLs mean 'don't use bands' */

	  return sc;
	}

  /* 2. Find our split set, w..y
   *    We choose the node in the middle.
   *    This can't be a BIF_nd (we're a wedge), or an END_nd (midnode
   *    can't be z) but it could be any other node including
   *    begin nodes (i.e. it might be that w==y).
   */
  midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r]) / 2);
  w = cm->nodemap[midnode];
  y = cm->cfirst[w]-1;

  /* 3. Calculate inside up to w, and outside down to y.
   *    We rely on a side effect of how deallocation works
   *    in these routines; the w..y decks are guaranteed
   *    to be retained.
   *    b will contain the optimal 0->v state for a local begin, and bsc
   *    is the score for using it.
   *    beta[cm->M] will contain the EL deck, if needed for local ends.
   */
  inside(cm, dsq, L, w, z, i0, j0, BE_EFFICIENT,
	 NULL, &alpha, NULL, &pool, NULL,
	 (r==0), &b, &bsc);
  outside(cm, dsq, L, r, y, i0, j0, BE_EFFICIENT, NULL, &beta, pool, NULL);

  /* 4. Find the optimal split at the split set: best_v, best_d, best_j
   */
  W = j0-i0+1;
  best_sc = IMPOSSIBLE;
  for (v = w; v <= y; v++)
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	for (d = 0; d <= jp; d++)
	  if ((sc = alpha[v][j][d] + beta[v][j][d]) > best_sc)
	    {
	      best_sc = sc;
	      best_v  = v;
	      best_d  = d;
	      best_j  = j;
	    }
	  }

  /* Local alignment ends only: maybe we're better off in EL,
   * not in the split set?
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	for (d = 0; d <= jp; d++)
	  if ((sc = beta[cm->M][j][d]) > best_sc) {
	    best_sc = sc;
	    best_v  = -1;	/* flag for local alignment. */
	    best_j  = j;
	    best_d  = d;
	  }
	  }
  }

  /* Local alignment begins only: maybe we're better off in the root.
   */
  if (r==0 && (cm->flags & CMH_LOCAL_BEGIN)) {
	if (bsc > best_sc) {
	  best_sc = bsc;
	  best_v  = -2;		/* flag for local alignment */
	  best_j  = j0;
	  best_d  = W;
	}
  }

  /* free now, before recursing!
   */
  free_vjd_matrix(alpha, cm->M, i0, j0);
  free_vjd_matrix(beta,  cm->M, i0, j0);

  /* If we're in EL, instead of the split set, the optimal alignment
   * is entirely in a V problem that's still above us. The TRUE
   * flag sets useEL. It doesn't matter which state in the split
   * set w..y we use as the end of the graph; vinside() will have to
   * initialize the whole thing to IMPOSSIBLE anyway.
   */
  if (best_v == -1) {
	v_splitter(cm, dsq, L, tr, r, w, i0, best_j-best_d+1, best_j, j0, TRUE);
	return best_sc;
  }

  /* If we're in the root because of a local begin, the local alignment
   * is entirely in a wedge problem that's still below us, rooted at b.
   * The FALSE flag prohibits any more local begins in this and subsequent
   * problems.
   */
  if (best_v == -2) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b);
	wedge_splitter(cm, dsq, L, tr, b, z, i0, j0);
	return best_sc;
  }

  /* Else (usual case): the optimal split into a V problem and a wedge problem:
   *    i1 = best_j-best_d+1, j1 = best_j
   *    the V problem:     r..v, i0..i1, j1..j0
   *    the wedge problem: v..z, i1..j1
   *
   *    These have to solved in the order given because we're
   *    constructing the trace in postorder traversal.
   */
  ESL_DPRINTF2(("Wedge splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		best_v, UniqueStatetype(cm->stid[best_v]),
		i0, best_j-best_d+1, best_j, j0));
  ESL_DPRINTF2(("   wedge:   G%d[%s]..%d[%s], %d..%d\n",
		best_v, UniqueStatetype(cm->stid[best_v]),
		z, UniqueStatetype(cm->stid[z]),
		best_j-best_d+1, best_j));

  v_splitter(cm, dsq, L, tr, r, best_v, i0, best_j-best_d+1, best_j, j0, FALSE);
  wedge_splitter(cm, dsq, L, tr, best_v, z, best_j-best_d+1, best_j);
  return best_sc;
}

/* Function: v_splitter()
 * Date:     SRE, Thu May 31 19:47:57 2001 [Kaldi's]
 *
 * Purpose:  Solve a "V problem": best parse of an unbifurcated
 *           subgraph cm^r..z to a one-hole subsequence
 *           i0..i1 // j1..j0.
 *
 *           Attaches the optimal trace T(r..z), exclusive of
 *           r, inclusive of z, to the growing trace tr.
 *
 *           r and z can be any non-insert state.
 *
 * Args:     cm          -  model
 *           sq          - digitized sequence 1..L
 *           tr          - the traceback we're adding on to.
 *           r           - index of the first state in the subgraph
 *           z           - index of the last state in the subgraph
 *           i0,i1       - first part of the subsequence (1..L)
 *           j1,j0       - second part of the subsequence (1..L)
 *           useEL       - TRUE if i1,j1 aligned to EL, not z
 *
 * Returns:  (void)
 */
static void
v_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
	   int r, int z, int i0, int i1, int j1, int j0,
	   int useEL)
{
  float ***alpha, ***beta;      /* inside and outside matrices */
  struct deckpool_s *pool;      /* pool for holding alloced decks */
  float sc;			/* tmp variable holding a score */
  int   v,w,y;			/* state indexes */
  int   ip,jp;
  int   best_v;
  int   best_i, best_j;		/* optimal i', j' split point */
  float best_sc;		/* score at optimal split point */
  int   midnode;
  int   b;			/* optimal choice for a 0->b local begin  */
  float bsc;			/* score if we use the local begin */

  /* 1. If the V problem is either a boundary condition, or small
   *    enough, solve it with v_inside^T and append the trace to tr.
   *    (With local alignment, we might even see a lone B state
   *     get handed to v_splitter(); hence the r==z case.)
   */
   if (cm->ndidx[z] == cm->ndidx[r] + 1 || r == z ||
	  vinsideT_size(cm, r, z, i0, i1, j1, j0) < RAMLIMIT)
	{
	  ESL_DPRINTF2(("Solving a V:   G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		z, UniqueStatetype(cm->stid[z]),
		i0,j1,j1,j0));
	  vinsideT(cm, dsq, L, tr, r, z, i0, i1, j1, j0, useEL, (r==0),
		NULL, NULL); /* two NULLs mean 'don't use bands' */
	  return;
	}

  /* 2. Find our split set, w..y.
   *    Choose the node in the middle.
   */
  midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r]) / 2);
  w = cm->nodemap[midnode];
  y = cm->cfirst[w]-1;

  /* 3. Calculate v_inside up to w, and v_outside down to y.
   *    As with wedge_splitter(), we rely on a side effect of how
   *    deallocation works, so the w..y decks are retained
   *    in alpha and beta even though we're in small memory mode.
   *    beta[cm->M] is the EL deck, needed for local ends.
   */
  vinside (cm, dsq, L, w, z, i0, i1, j1, j0, useEL, BE_EFFICIENT,
	   NULL, &alpha, NULL, &pool, NULL, (r==0), &b, &bsc);
  voutside(cm, dsq, L, r, y, i0, i1, j1, j0, useEL, BE_EFFICIENT,
	   NULL, &beta,  pool, NULL);

  /* 4. Find the optimal split: v, ip, jp.
   */
  best_sc = IMPOSSIBLE;
  for (v = w; v <= y; v++)
	for (ip = 0; ip <= i1-i0; ip++)
	  for (jp = 0; jp <= j0-j1; jp++)
	if ((sc = alpha[v][jp][ip] + beta[v][jp][ip]) > best_sc)
	  {
	    best_sc = sc;
	    best_v  = v;
	    best_i  = ip + i0;
	    best_j  = jp + j1;
	  }

  /* Local alignment ends: maybe we're better off in EL, not
   * the split set?
   */
  if (useEL && (cm->flags & CMH_LOCAL_END)) {
	for (ip = 0; ip <= i1-i0; ip++)
	  for (jp = 0; jp <= j0-j1; jp++)
	if ((sc = beta[cm->M][jp][ip]) > best_sc) {
	  best_sc = sc;
	  best_v  = -1;
	  best_i  = ip + i0;
	  best_j  = jp + j1;
	}
  }

  /* Local alignment begins: maybe we're better off in root...
   */
  if (r==0 && (cm->flags & CMH_LOCAL_BEGIN)) {
	if (bsc > best_sc) {
	  best_sc = bsc;
	  best_v  = -2;
	  best_i  = i0;
	  best_j  = j0;
	}
  }

  /* Free now, before recursing!
   */
  free_vji_matrix(alpha, cm->M, j1, j0);
  free_vji_matrix(beta,  cm->M, j1, j0);

  /* If we're in EL, instead of the split set, the optimal
   * alignment is entirely in a V problem that's still above us.
   * The TRUE flag sets useEL; we propagate allow_begin.
   */
  if (best_v == -1) {
	v_splitter(cm, dsq, L, tr, r, w, i0, best_i, best_j, j0, TRUE);
	return;
  }

  /* If we used a local begin, the optimal alignment is
   * entirely in a V problem that's still below us, rooted
   * at b, for the entire one-hole sequence. The FALSE
   * flag prohibits more local begin transitions; we propagate
   * useEL.
   */
  if (best_v == -2) {
	if (b != z)
	  {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b);
	  }
	v_splitter(cm, dsq, L, tr, b, z, i0, i1, j1, j0, useEL);
	return;
  }

  /* The optimal split into two V problems:
   *    V:   r..v, i0..i', j'..j0
   *    V:   v..z, i'..i1, j1..j'
   * Solve in this order, because we're constructing the
   * trace in postorder traversal.
   */
  ESL_DPRINTF2(("V splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		best_v, UniqueStatetype(cm->stid[best_v]),
		i0, best_i, best_j, j0));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		best_v, UniqueStatetype(cm->stid[best_v]),
		z, UniqueStatetype(cm->stid[z]),
		best_i, i1, j1, best_j));

  v_splitter(cm, dsq, L, tr, r,      best_v, i0,     best_i, best_j, j0, FALSE);
  v_splitter(cm, dsq, L, tr, best_v, z,      best_i, i1,     j1,     best_j, useEL);
  return;
}

/*****************************************************************
 * The alignment engines:
 *     inside   - given generic or wedge problem G^r_z to i0..j0, return score and matrix
 *     outside  - given unbifurcated G^r_z to i0..j0, return matrix
 *
 *     vinside  - given V problem G^r_z to i0..i1//j1..j0, return score and matrix
 *     voutside - given unbifurcated G^r_z to i0..i1//j1..j0, return matrix
 ******************************************************************/

/* Function: inside()
 * Date:     SRE, Mon Aug  7 13:15:37 2000 [St. Louis]
 *
 * Purpose:  Run the inside phase of a CYK alignment algorithm, on a
 *           subsequence from i0..j0, using a subtree of a model
 *           anchored at a start state vroot, and ending at an end
 *           state vend. (It is a feature of the model layout in
 *           a CM structure that all subtrees are contiguous in the
 *           model.)
 *
 *           A note on the loop conventions. We're going to keep the
 *           sequence (sq) and the matrix (alpha) in the full coordinate
 *           system: [0..v..M-1][0..j..L][0..d..j]. However, we're
 *           only calculating a part of that matrix: only vroot..vend
 *           in the decks, i0-1..j in the rows, and up to j0-i0+1 in
 *           the columns (d dimension). Where this is handled the most
 *           is in two variables: W, which is the length of the subsequence
 *           (j0-i0+1), and is oft used in place of L in the usual CYK;
 *           and jp (read: j'), which is the *relative* j w.r.t. the
 *           subsequence, ranging from 0..W, and then d ranges from
 *           0 to jp, and j is calculated from jp (i0-1+jp).
 *
 *           The caller is allowed to provide us with a preexisting
 *           matrix and/or deckpool (thru "alpha" and "dpool"), or
 *           have them newly created by passing NULL. If we pass in an
 *           alpha, we expect that alpha[vroot..vend] are all NULL
 *           decks already; any other decks <vroot and >vend will
 *           be preserved. If we pass in a dpool, the decks *must* be
 *           sized for the same subsequence i0,j0.
 *
 *           Note that the (alpha, ret_alpha) calling idiom allows the
 *           caller to provide an existing matrix or not, and to
 *           retrieve the calculated matrix or not, in any combination.
 *
 *           We also deal with local begins, by keeping track of the optimal
 *           state that we could enter and account for the whole target
 *           sequence: b = argmax_v  alpha_v(i0,j0) + log t_0(v),
 *           and bsc is the score for that.
 *
 *           If vroot==0, i0==1, and j0==L (e.g. a complete alignment),
 *           the optimal alignment might use a local begin transition, 0->b,
 *           and we'd have to be able to trace that back. For any
 *           problem where the caller sets allow_begin, we return a valid b
 *           (the optimal 0->b choice) and bsc (the score if 0->b is used).
 *           If a local begin is part of the optimal parse tree, the optimal
 *           alignment score returned by inside() will be bsc and yshad[0][L][L]
 *           will be USE_LOCAL_BEGIN, telling insideT() to check b and
 *           start with a local 0->b entry transition. When inside()
 *           is called on smaller subproblems (v != 0 || i0 > 1 || j0
 *           < L), we're using inside() as an engine in divide &
 *           conquer, and we don't use the overall return score nor
 *           shadow matrices, but we do need allow_begin, b, and bsc for
 *           divide&conquer to sort out where a local begin might be used.
 *
 * Args:     cm        - the model    [0..M-1]
 *           sq        - the sequence [1..L]
 *           vroot     - first start state of subtree (0, for whole model)
 *           vend      - last end state of subtree (cm->M-1, for whole model)
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           do_full   - if TRUE, we save all the decks in alpha, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the uppermost deck (vroot) is valid
 *                       at the end.
 *           alpha     - if non-NULL, this is an existing matrix, with NULL
 *                       decks for vroot..vend, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_alpha - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated decks sized
 *                       for this subsequence i0..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..j0 subseq,
 *                       because of the size of the subseq decks.
 *           ret_shadow- if non-NULL, the caller wants a shadow matrix, because
 *                       he intends to do a traceback.
 *           allow_begin- TRUE to allow 0->b local alignment begin transitions.
 *           ret_b     - best local begin state, or NULL if unwanted
 *           ret_bsc   - score for using ret_b, or NULL if unwanted
 *
 *
 * Returns: Score of the optimal alignment.
 */
static float
inside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
	   float ***alpha, float ****ret_alpha,
	   struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
	   void ****ret_shadow,
	   int allow_begin, int *ret_b, float *ret_bsc)
{
  int      status;
  float  **end;         /* we re-use the end deck. */
  int      nends;       /* counter that tracks when we can release end deck to the pool */
  int     *touch;       /* keeps track of how many higher decks still need this deck */
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      W;		/* subsequence length */
  int      jp;		/* j': relative position in the subsequence  */
  void  ***shadow;      /* shadow matrix for tracebacks */
  int    **kshad;       /* a shadow deck for bifurcations */
  char   **yshad;       /* a shadow deck for every other kind of state */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */

  /* Allocations and initializations
   */
  b   = -1;
  bsc = IMPOSSIBLE;
  W   = j0-i0+1;		/* the length of the subsequence -- used in many loops  */
				/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();
  if (! deckpool_pop(dpool, &end))
	end = alloc_vjd_deck(L, i0, j0);
  nends = CMSubtreeCountStatetype(cm, vroot, E_st);
  for (jp = 0; jp <= W; jp++) {
	j = i0+jp-1;		/* e.g. j runs from 0..L on whole seq */
	end[j][0] = 0.;
	for (d = 1; d <= jp; d++) end[j][d] = IMPOSSIBLE;
  }

  /* if caller didn't give us a matrix, make one.
   * It's important to allocate for M+1 decks (deck M is for EL, local
   * alignment) - even though Inside doesn't need EL, Outside does,
   * and we might reuse this memory in a call to Outside.
   */
  if (alpha == NULL) {
	ESL_ALLOC(alpha, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) alpha[v] = NULL;
  }

  ESL_ALLOC(touch, sizeof(int) * (cm->M+1));
  for (v = 0;     v < vroot; v++) touch[v] = 0;
  for (v = vroot; v <= vend; v++) touch[v] = cm->pnum[v];
  for (v = vend+1;v < cm->M; v++) touch[v] = 0;

  /* The shadow matrix, if caller wants a traceback.
   * We do some pointer tricks here to save memory. The shadow matrix
   * is a void ***. Decks may either be char ** (usually) or
   * int ** (for bifurcation decks). Watch out for the casts.
   * For most states we only need
   * to keep y as traceback info, and y <= 6. For bifurcations,
   * we need to keep k, and k <= L, and L might be fairly big.
   * (We could probably limit k to an unsigned short ... anyone
   * aligning an RNA > 65536 would need a big computer... but
   * we'll hold off on that for now. We could also pack more
   * traceback pointers into a smaller space since we only really
   * need 3 bits, not 8.)
   */
  if (ret_shadow != NULL) {
	ESL_ALLOC(shadow, sizeof(void **) * cm->M);
	for (v = 0; v < cm->M; v++) shadow[v] = NULL;
  }

  /* Main recursion
   */
  for (v = vend; v >= vroot; v--)
	{
	  /* First we need a deck to fill in.
	   * 1. if we're an E, reuse the end deck (and it's already calculated)
	   * 2. else, see if we can take something from the pool
	   * 3. else, allocate a new deck.
	   */
	  if (cm->sttype[v] == E_st) {
	alpha[v] = end; continue;
	  }
	  if (! deckpool_pop(dpool, &(alpha[v])))
	alpha[v] = alloc_vjd_deck(L, i0, j0);

	  if (ret_shadow != NULL) {
	if (cm->sttype[v] == B_st) {
	  kshad     = alloc_vjd_kshadow_deck(L, i0, j0);
	  shadow[v] = (void **) kshad;
	} else {
	  yshad     = alloc_vjd_yshadow_deck(L, i0, j0);
	  shadow[v] = (void **) yshad;
	}
	  }

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = 0; d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d]  = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }
		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
//printf("j%2d v%2d ",j,v);
//for (d = 0; d <= W && d <= j; d++) { printf("%10.2e ",alpha[v][j][d]); }
//printf("\n");
	  }
	}
	  else if (cm->sttype[v] == B_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = 0; d <= jp; d++)
	      {
		y = cm->cfirst[v];
		z = cm->cnum[v];

		alpha[v][j][d] = alpha[y][j][d] + alpha[z][j][0];
		if (ret_shadow != NULL) kshad[j][d] = 0;
		for (k = 1; k <= d; k++)
		  if ((sc = alpha[y][j-k][d-k] + alpha[z][j][k]) > alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) kshad[j][d] = k;
		  }
		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
//printf("j%2d v%2d ",j,v);
//for (d = 0; d <= W && d <= j; d++) { printf("%10.2e ",alpha[v][j][d]); }
//printf("\n");
	  }
	}
	  else if (cm->sttype[v] == MP_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    if (jp > 0) alpha[v][j][1] = IMPOSSIBLE;
	    for (d = 2; d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j-1][d-2] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }

		i = j-d+1;
		if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
		else
		  alpha[v][j][d] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
//printf("j%2d v%2d ",j,v);
//for (d = 0; d <= W && d <= j; d++) { printf("%10.2e ",alpha[v][j][d]); }
//printf("\n");
	  }
	}
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == ML_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    for (d = 1; d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }

		i = j-d+1;
		if (dsq[i] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][dsq[i]];
		else
		  alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
//printf("j%2d v%2d ",j,v);
//for (d = 0; d <= W && d <= j; d++) { printf("%10.2e ",alpha[v][j][d]); }
//printf("\n");
	  }
	}
	  else if (cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    for (d = 1; d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }
		if (dsq[j] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][dsq[j]];
		else
		  alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
//printf("j%2d v%2d ",j,v);
//for (d = 0; d <= W && d <= j; d++) { printf("%10.2e ",alpha[v][j][d]); }
//printf("\n");
	  }
	}				/* finished calculating deck v. */

	  /* Check for local begin getting us to the root.
	   * This is "off-shadow": if/when we trace back, we'll handle this
	   * case separately (and we'll know to do it because we'll immediately
	   * see a USED_LOCAL_BEGIN flag in the shadow matrix, telling us
	   * to jump right to state b; see below)
	   */
	  if (allow_begin && alpha[v][j0][W] + cm->beginsc[v] > bsc)
	{
	  b   = v;
	  bsc = alpha[v][j0][W] + cm->beginsc[v];
	}

	  /* Check for whether we need to store an optimal local begin score
	   * as the optimal overall score, and if we need to put a flag
	   * in the shadow matrix telling insideT() to use the b we return.
	   */
	  if (allow_begin && v == 0 && bsc > alpha[0][j0][W]) {
	alpha[0][j0][W] = bsc;
	if (ret_shadow != NULL) yshad[j0][W] = USED_LOCAL_BEGIN;
	  }

	  /* Now, if we're trying to reuse memory in our normal mode (e.g. ! do_full):
	   * Look at our children; if they're fully released, take their deck
	   * into the pool for reuse.
	   */
	  if (! do_full) {
	if (cm->sttype[v] == B_st)
	  { /* we can definitely release the S children of a bifurc. */
	    y = cm->cfirst[v]; deckpool_push(dpool, alpha[y]); alpha[y] = NULL;
	    z = cm->cnum[v];   deckpool_push(dpool, alpha[z]); alpha[z] = NULL;
	  }
	else
	  {
	    for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	      {
		touch[y]--;
		if (touch[y] == 0)
		  {
		    if (cm->sttype[y] == E_st) {
		      nends--;
		      if (nends == 0) { deckpool_push(dpool, end); end = NULL;}
		    } else
		      deckpool_push(dpool, alpha[y]);
		    alpha[y] = NULL;
		  }
	      }
	  }
	  }
  } /* end loop over all v */

  /* debug_print_alpha(alpha, cm, L);*/

  /* Now we free our memory.
   * if we've got do_full set, all decks vroot..vend are now valid (end is shared).
   * else, only vroot deck is valid now and all others vroot+1..vend are NULL,
   * and end is NULL.
   * We could check this status to be sure (and we used to) but now we trust.
   */
  sc       = alpha[vroot][j0][W];
  if (ret_b != NULL)   *ret_b   = b;    /* b is -1 if allow_begin is FALSE. */
  if (ret_bsc != NULL) *ret_bsc = bsc;  /* bsc is IMPOSSIBLE if allow_begin is FALSE */

  /* If the caller doesn't want the matrix, free it (saving the decks in the pool!)
   * Else, pass it back to him.
   */
  if (ret_alpha == NULL) {
	for (v = vroot; v <= vend; v++) /* be careful of our reuse of the end deck -- free it only once */
	  if (alpha[v] != NULL) {
	if (cm->sttype[v] != E_st) { deckpool_push(dpool, alpha[v]); alpha[v] = NULL; }
	else end = alpha[v];
	  }
	if (end != NULL) { deckpool_push(dpool, end); end = NULL; }
	free(alpha);
  } else *ret_alpha = alpha;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	while (deckpool_pop(dpool, &end)) free_vjd_deck(end, i0, j0);
	deckpool_free(dpool);
  } else {
	*ret_dpool = dpool;
  }

  free(touch);
  if (ret_shadow != NULL) *ret_shadow = shadow;
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return 0.; /* never reached */
}

/* Function: outside()
 * Date:     SRE, Tue Aug  8 10:42:52 2000 [St. Louis]
 *
 * Purpose:  Run the outside version of a CYK alignment algorithm,
 *           on a subsequence i0..j0 of a digitized sequence sq [1..L],
 *           using a linear segment of a model anchored at a start state
 *           (possibly the absolute root, 0) or (MP,ML,MR,D) and ending at an end
 *           state, bifurcation state, or (MP|ML|MR|D) vend. There must be no
 *           start, end, or bifurcation states in the path other than
 *           these termini: this is not a full Outside implementation,
 *           it is only the bit that's necessary in the divide
 *           and conquer alignment algorithm.
 *
 *           Much of the behavior in calling conventions, etc., is
 *           analogous to the cyk_inside_engine(); see its preface
 *           for more info.
 *
 *           At the end of the routine, the bottom deck (vend) is valid.
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           vroot     - first state of linear model segment (S; MP|ML|MR|D)
 *           vend      - last state of linear model segment  (B; E; MP|ML|MR|D)
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           do_full   - if TRUE, we save all the decks in beta, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the lowermost deck (vend) is valid
 *                       at the end.
 *           beta      - if non-NULL, this is an existing matrix, with NULL
 *                       decks for vroot..vend, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_beta  - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated decks sized
 *                       for this subsequence i0..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..j0 subseq,
 *                       because of the size of the subseq decks.
 */
static void
outside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0,
	int do_full, float ***beta, float ****ret_beta,
	struct deckpool_s *dpool, struct deckpool_s **ret_dpool)
{
  int      status;
  int      v,y;			/* indices for states */
  int      j,d,i;		/* indices in sequence dimensions */
  float    sc;			/* a temporary variable holding a score */
  int     *touch;               /* keeps track of how many lower decks still need this deck */
  float    escore;		/* an emission score, tmp variable */
  int      W;			/* subsequence length */
  int      jp;			/* j': relative position in the subsequence, 0..W */
  int      voffset;		/* index of v in t_v(y) transition scores */
  int      w1,w2;		/* bounds of split set */

  /* Allocations and initializations
   */
  W = j0-i0+1;		/* the length of the subsequence: used in many loops */

  			/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();

  /* if caller didn't give us a matrix, make one.
   * Allocate room for M+1 decks because we might need the EL deck (M)
   * if we're doing local alignment.
   */
  if (beta == NULL) {
	ESL_ALLOC(beta, sizeof(float **) * (cm->M+1));
	for (v = 0; v < cm->M+1; v++) beta[v] = NULL;
  }

  /* Initialize the root deck.
   * If the root is in a split set, initialize the whole split set.
   */
  w1 = cm->nodemap[cm->ndidx[vroot]]; /* first state in split set */
  if (cm->sttype[vroot] == B_st) {    /* special boundary case of Outside on a single B state. */
	w2 = w1;
	if (vend != vroot) cm_Fail("oh no. not again.");
  } else
	w2 = cm->cfirst[w1]-1;	      /* last state in split set w1<=vroot<=w2 */

  for (v = w1; v <= w2; v++) {
	if (! deckpool_pop(dpool, &(beta[v])))
	  beta[v] = alloc_vjd_deck(L, i0, j0);
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	beta[v][j][d] = IMPOSSIBLE;
	}
  }
  beta[vroot][j0][W] = 0;

  /* Initialize the EL deck at M, if we're doing local alignment w.r.t. ends.
   */
  if (cm->flags & CMH_LOCAL_END) {
	if (! deckpool_pop(dpool, &(beta[cm->M])))
	  beta[cm->M] = alloc_vjd_deck(L, i0, j0);
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	beta[cm->M][j][d] = IMPOSSIBLE;
	}

	/* We have to worry about vroot -> EL transitions.
	 * since we start the main recursion at w2+1. This requires a
	 * laborious partial unroll of the main recursion, grabbing
	 * the stuff relevant to a beta[EL] calculation for just the
	 * vroot->EL transition.
	 */
	if (NOT_IMPOSSIBLE(cm->endsc[vroot])) {
	  switch (cm->sttype[vroot]) {
	  case MP_st:
	if (W < 2) break;
	if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
	else
	  escore = DegeneratePairScore(cm->abc, cm->esc[vroot], dsq[i0], dsq[j0]);
	beta[cm->M][j0-1][W-2] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-2)) + escore;

	if (beta[cm->M][j0-1][W-2] < IMPOSSIBLE) beta[cm->M][j0-1][W-2] = IMPOSSIBLE;
	break;
	  case ML_st:
	  case IL_st:
	if (W < 1) break;
	if (dsq[i0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) dsq[i0]];
	else
	  escore = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[vroot]);
	beta[cm->M][j0][W-1] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-1)) + escore;

	if (beta[cm->M][j0][W-1] < IMPOSSIBLE) beta[cm->M][j0][W-1] = IMPOSSIBLE;
	break;
	  case MR_st:
	  case IR_st:
	if (W < 1) break;
	if (dsq[j0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) dsq[j0]];
	else
	  escore = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[vroot]);
	beta[cm->M][j0-1][W-1] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-1)) + escore;

	if (beta[cm->M][j0-1][W-1] < IMPOSSIBLE) beta[cm->M][j0-1][W-1] = IMPOSSIBLE;
	break;
	  case S_st:
	  case D_st:
	beta[cm->M][j0][W] = cm->endsc[vroot] +
	  (cm->el_selfsc * W);
	if (beta[cm->M][j0][W] < IMPOSSIBLE) beta[cm->M][j0][W] = IMPOSSIBLE;
	break;
	  case B_st:		/* can't start w/ bifurcation at vroot. */
	  default: cm_Fail("bogus parent state %d\n", cm->sttype[vroot]);
	  }
	}
  }

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;      v < w1; v++) touch[v] = 0; /* note: top of split set w1, not vroot */

  for (v = vend+1; v < cm->M; v++) touch[v] = 0;
  for (v = w1; v <= vend; v++) {
	if (cm->sttype[v] == B_st) touch[v] = 2; /* well, we'll never use this, but set it anyway. */
	else                       touch[v] = cm->cnum[v];
  }

  /* Main loop down through the decks
   */
  for (v = w2+1; v <= vend; v++)
	{
	  /* First we need to fetch a deck of memory to fill in;
	   * we try to reuse a deck but if one's not available we allocate
	   * a fresh one.
	   */
	  if (! deckpool_pop(dpool, &(beta[v])))
	beta[v] = alloc_vjd_deck(L, i0, j0);

	  /* Init the whole deck to IMPOSSIBLE
	   */
	  for (jp = W; jp >= 0; jp--) {
	j = i0-1+jp;
	for (d = jp; d >= 0; d--)
	  beta[v][j][d] = IMPOSSIBLE;
	  }

	  /* If we can do a local begin into v, also init with that.
	   * By definition, beta[0][j0][W] == 0.
	   */
	  if (vroot == 0 && i0 == 1 && j0 == L && (cm->flags & CMH_LOCAL_BEGIN))
	beta[v][j0][W] = cm->beginsc[v];

	  /* main recursion:
	   */
	  for (jp = W; jp >= 0; jp--) {
	j = i0-1+jp;
	for (d = jp; d >= 0; d--)
	  {
	    i = j-d+1;
	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      if (y < vroot) continue; /* deal with split sets */
	      voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	      switch(cm->sttype[y]) {
	      case MP_st:
		if (j == j0 || d == jp) continue; /* boundary condition */

		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);

		if ((sc = beta[y][j+1][d+2] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case ML_st:
	      case IL_st:
		if (d == jp) continue;	/* boundary condition (note when j=0, d=0*/

		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);

		if ((sc = beta[y][j][d+1] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case MR_st:
	      case IR_st:
		if (j == j0) continue;

		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);

		if ((sc = beta[y][j+1][d+1] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		if ((sc = beta[y][j][d] + cm->tsc[y][voffset]) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      default: cm_Fail("bogus child state %d\n", cm->sttype[y]);
	      }/* end switch over states*/
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (beta[v][j][d] < IMPOSSIBLE) beta[v][j][d] = IMPOSSIBLE;

	  } /* ends loop over d. We know all beta[v][j][d] in this row j*/
	  }/* end loop over jp. We know the beta's for the whole deck.*/

	  /* Deal with local alignment end transitions v->EL
	   * (EL = deck at M.)
	   */
	  if (NOT_IMPOSSIBLE(cm->endsc[v])) {
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	    {
	      i = j-d+1;
	      switch (cm->sttype[v]) {
	      case MP_st:
		if (j == j0 || d == jp) continue; /* boundary condition */
		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
		if ((sc = beta[v][j+1][d+2] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case ML_st:
	      case IL_st:
		if (d == jp) continue;
		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
		if ((sc = beta[v][j][d+1] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		  /*(cm->el_selfsc * (d+1)) + escore) > beta[cm->M][j][d])*/
		  beta[cm->M][j][d] = sc;
		break;
	      case MR_st:
	      case IR_st:
		if (j == j0) continue;
		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
		if ((sc = beta[v][j+1][d+1] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		     /*(cm->el_selfsc * (d+1)) + escore) > beta[cm->M][j][d])*/
		  beta[cm->M][j][d] = sc;
		break;
	      case S_st:
	      case D_st:
	      case E_st:
		if ((sc = beta[v][j][d] + cm->endsc[v] +
		     (cm->el_selfsc * d)) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case B_st:
	      default: cm_Fail("bogus parent state %d\n", cm->sttype[v]);
		/* note that although B is a valid vend for a segment we'd do
				   outside on, B->EL is set to be impossible, by the local alignment
				   config. There's no point in having a B->EL because B is a nonemitter
				   (indeed, it would introduce an alignment ambiguity). The same
		   alignment case is handled by the X->EL transition where X is the
		   parent consensus state (S, MP, ML, or MR) above the B. Thus,
		   this code is relying on the NOT_IMPOSSIBLE() test, above,
		   to make sure the sttype[vend]=B case gets into this switch.
		*/
	      } /* end switch over parent state type v */
	    } /* end inner loop over d */
	} /* end outer loop over jp */
	  } /* end conditional section for dealing w/ v->EL local end transitions */

	  /* Look at v's parents; if we're reusing memory (! do_full)
	   * push the parents that we don't need any more into the pool.
	   */
	  if (! do_full) {
	for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	  touch[y]--;
	  if (touch[y] == 0) { deckpool_push(dpool, beta[y]); beta[y] = NULL; }
	}
	  }
	} /* end loop over decks v. */

#if 0
  /* SRE: this code is superfluous, yes??? */
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, zero-scoring EL->EL transitions.
   * (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = W; jp > 0; jp--) { /* careful w/ boundary here */
	  j = i0-1+jp;
	  for (d = jp-1; d >= 0; d--) /* careful w/ boundary here */
	if ((sc = beta[cm->M][j][d+1]) > beta[cm->M][j][d])
	  beta[cm->M][j][d] = sc;
	}
  }
#endif

  /* If the caller doesn't want the matrix, free it.
   * (though it would be *stupid* for the caller not to want the
   * matrix in the current implementation...)
   */
  if (ret_beta == NULL) {
	for (v = w1; v <= vend; v++) /* start at w1 - top of split set - not vroot */
	  if (beta[v] != NULL) { deckpool_push(dpool, beta[v]); beta[v] = NULL; }
	if (cm->flags & CMH_LOCAL_END) {
	  deckpool_push(dpool, beta[cm->M]);
	  beta[cm->M] = NULL;
	}
	free(beta);
  } else *ret_beta = beta;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	float **a;
	while (deckpool_pop(dpool, &a)) free_vjd_deck(a, i0, j0);
	deckpool_free(dpool);
  } else {
	*ret_dpool = dpool;
  }
  free(touch);
  return;

 ERROR:
  cm_Fail("Memory allocation error.\n");
}

/* Function: vinside()
 * Date:     SRE, Sat Jun  2 09:24:51 2001 [Kaldi's]
 *
 * Purpose:  Run the inside phase of the CYK alignment algorithm for
 *           a V problem: an unbifurcated CM subgraph from
 *           r..z, aligned to a one-hole subsequence
 *           i0..i1 // j1..j0, exclusive of z,i1,j1.
 *
 *           This is done in the vji coord system, where
 *           both our j and i coordinates are transformed.
 *           The Platonic matrix runs [j1..j0][i0..i1].
 *           The actual matrix runs [0..j0-j1][0..i1-i0].
 *           To transform a sequence coord i to a transformed
 *           coord i', subtract i0; to transform i' to i,
 *           add i0.
 *
 *           The conventions for alpha and dpool are the
 *           same as cyk_inside_engine().
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           r         - first start state of subtree (0, for whole model)
 *           z         - last end state of subtree (cm->M-1, for whole model)
 *           i0,i1     - first subseq part of the V problem
 *           j1,j0     - second subseq part
 *           useEL     - if TRUE, V problem ends at EL/i1/j1, not z/i1/j1
 *           do_full   - if TRUE, we save all the decks in alpha, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the uppermost deck (r) is valid
 *                       at the end.
 *           a         - if non-NULL, this is an existing matrix, with NULL
 *                       decks for r..z, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_a     - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated vji decks sized
 *                       for this subsequence i0..i1//j0..j1.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..i1//j0..j1 subseq
 *                       because of the size of the subseq decks.
 *           ret_shadow- if non-NULL, the caller wants a shadow matrix, because
 *                       he intends to do a traceback.
 *           allow_begin- TRUE to allow 0->b local alignment begin transitions.
 *           ret_b     - best local begin state, or NULL if unwanted
 *           ret_bsc   - score for using ret_b, or NULL if unwanted

 *
 * Returns:  score.
 */
static float
vinside(CM_t *cm, ESL_DSQ *dsq, int L,
	int r, int z, int i0, int i1, int j1, int j0, int useEL,
	int do_full, float ***a, float ****ret_a,
	struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
	char ****ret_shadow,
	int allow_begin, int *ret_b, float *ret_bsc)
{
  int      status;
  char  ***shadow;              /* the shadow matrix -- traceback ptrs -- memory is kept */
  int     v,i,j;
  int     w1,w2;		/* bounds of the split set */
  int     jp, ip;		/* j' and i' -- in the matrix coords */
  int    *touch;                /* keeps track of whether we can free a deck yet or not */
  int     y, yoffset;
  float   sc;			/* tmp variable holding a score */
  int      b;			/* best local begin state */
  float    bsc;			/* score for using the best local begin state */

  /*printf("***in vinside()****\n");
	printf("\tr  : %d\n", r);
	printf("\tz  : %d\n", z);
	printf("\ti0 : %d\n", i0);
	printf("\ti1 : %d\n", i1);
	printf("\tj1 : %d\n", j1);
	printf("\tj0 : %d\n", j0);
  */

  /* Allocations, initializations.
   * Remember to allocate for M+1 decks, in case we reuse this
   * memory for a local alignment voutside() calculation.
   */
  b   = -1;
  bsc = IMPOSSIBLE;
  if (dpool == NULL) dpool = deckpool_create();
  if (a == NULL) {
	ESL_ALLOC(a, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) a[v] = NULL;
  }
				/* the whole split set w<=z<=y must be initialized */
  w1 = cm->nodemap[cm->ndidx[z]];
  w2 = cm->cfirst[w1]-1;
  for (v = w1; v <= w2; v++) {
	if (! deckpool_pop(dpool, &(a[v])))
	  a[v] = alloc_vji_deck(i0, i1, j1, j0);
	for (jp = 0; jp <= j0-j1; jp++)
	  for (ip = 0; ip <= i1-i0; ip++)
	a[v][jp][ip] = IMPOSSIBLE;
  }

  if (ret_shadow != NULL) {
	ESL_ALLOC(shadow, sizeof(char **) * cm->M);
	for (v = 0; v < cm->M; v++) shadow[v] = NULL;
  }

  /* Initialize the one non-IMPOSSIBLE cell as a boundary
   * condition.
   * If local alignment (useEL=1), we must connect z to EL;
   * we would init a[EL][0][i1-i0] = 0. But, we're not explicitly
   * keeping an EL deck, we're swallowing it into the recursion.
   * So, we unroll a chunk of the main recursion;
   * we have to laboriously figure out from the statetype z
   * and our position where and what our initialization is.
   * Else, for global alignments, we simply connect to z,0,i1-i0.
   */
  ip = i1-i0;
  jp = 0;
  if (! useEL)
	a[z][jp][ip] = 0.;
  else
	{
	  if (ret_shadow != NULL)
	shadow[z] = alloc_vji_shadow_deck(i0,i1,j1,j0);

	  switch (cm->sttype[z]) {
	  case D_st:
	  case S_st:
	/*a[z][jp][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
	if (ret_shadow != NULL) shadow[z][jp][ip] = USED_EL;
	break;
	  case MP_st:
	if (i0 == i1 || j1 == j0) break;
	/*a[z][jp+1][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp+1][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
	if (dsq[i1-1] < cm->abc->K && dsq[j1+1] < cm->abc->K)
	  a[z][jp+1][ip-1] += cm->esc[z][(int) (dsq[i1-1]*cm->abc->K+dsq[j1+1])];
	else
	  a[z][jp+1][ip-1] += DegeneratePairScore(cm->abc, cm->esc[z], dsq[i1-1], dsq[j1+1]);
	if (ret_shadow != NULL) shadow[z][jp+1][ip-1] = USED_EL;
	if (a[z][jp+1][ip-1] < IMPOSSIBLE) a[z][jp+1][ip-1] = IMPOSSIBLE;
	break;
	  case ML_st:
	  case IL_st:
	if (i0==i1) break;
	/*a[z][jp][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
	if (dsq[i1-1] < cm->abc->K)
	  a[z][jp][ip-1] += cm->esc[z][(int) dsq[i1-1]];
	else
	  a[z][jp][ip-1] += esl_abc_FAvgScore(cm->abc, dsq[i1-1], cm->esc[z]);
	if (ret_shadow != NULL) shadow[z][jp][ip-1] = USED_EL;
	if (a[z][jp][ip-1] < IMPOSSIBLE) a[z][jp][ip-1] = IMPOSSIBLE;
	break;
	  case MR_st:
	  case IR_st:
	if (j1==j0) break;
	/*a[z][jp+1][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp+1][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
	if (dsq[j1+1] < cm->abc->K)
	  a[z][jp+1][ip] += cm->esc[z][(int) dsq[j1+1]];
	else
	  a[z][jp+1][ip] += esl_abc_FAvgScore(cm->abc, dsq[j1+1], cm->esc[z]);
	if (ret_shadow != NULL) shadow[z][jp+1][ip] = USED_EL;
	if (a[z][jp+1][ip] < IMPOSSIBLE) a[z][jp+1][ip] = IMPOSSIBLE;
	break;
	  }

	} /* done initializing the appropriate cell for useEL=TRUE */

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;   v < r;  v++) touch[v] = 0;
  for (v = r;   v <= w2; v++) touch[v] = cm->pnum[v]; /* note w2 not z: to bottom of split set */
  for (v = w2+1; v < cm->M; v++) touch[v] = 0;

  /* A special case. If vinside() is called on empty sequences,
   * we might do a begin transition right into z.
   */
  if (allow_begin && j0-j1 == 0 && i1-i0 == 0)
	{
	  b   = z;
	  bsc = a[z][0][0] + cm->beginsc[z];
	  if (z == 0) {
	a[0][0][0] = bsc;
	if (ret_shadow != NULL) shadow[0][0][0] = USED_LOCAL_BEGIN;
	  }
	}

  /* Main recursion
   */
  for (v = w1-1; v >= r; v--)
	{
	  /* Get a deck and a shadow deck.
	   */
	  if (! deckpool_pop(dpool, &(a[v])))
	a[v] = alloc_vji_deck(i0,i1,j1,j0);
	  if (ret_shadow != NULL)
	shadow[v] = alloc_vji_shadow_deck(i0,i1,j1,j0);
				/* reassert our definition of a V problem */
	  if (cm->sttype[v] == E_st || cm->sttype[v] == B_st || (cm->sttype[v] == S_st && v > r))
	cm_Fail("you told me you wouldn't ever do that again.");

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	{
	  for (jp = 0; jp <= j0-j1; jp++)
	    for (ip = i1-i0; ip >= 0; ip--) {
	      /*printf("D S jp : %d | ip : %d\n", jp, ip);*/
	      y = cm->cfirst[v];
	      a[v][jp][ip]      = a[y][jp][ip] + cm->tsc[v][0];
	      /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
	      if (ret_shadow != NULL) shadow[v][jp][ip] = (char) 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	} else if (cm->sttype[v] == MP_st) {
	  for (ip = i1-i0; ip >= 0; ip--) a[v][0][ip] = IMPOSSIBLE; /* boundary condition */

	  for (jp = 1; jp <= j0-j1; jp++) {
	    j = jp+j1;
	    a[v][jp][i1-i0] = IMPOSSIBLE; /* boundary condition */
	    for (ip = i1-i0-1; ip >= 0; ip--) {
	      /*printf("MP jp : %d | ip : %d\n", jp, ip);*/
	      i = ip+i0;
	      y = cm->cfirst[v];
	      a[v][jp][ip] = a[y][jp-1][ip+1] + cm->tsc[v][0];
	      /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
	      if (ret_shadow != NULL) shadow[v][jp][ip] = (char) 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp-1][ip+1] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		   {
		     a[v][jp][ip] = sc;
		     /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		     if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		   }
	      if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
	      else
		a[v][jp][ip] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {

	  for (jp = 0; jp <= j0-j1; jp++) {
	    a[v][jp][i1-i0] = IMPOSSIBLE; /* boundary condition */
	    for (ip = i1-i0-1; ip >= 0; ip--) {
	      /*printf("ML IL jp : %d | ip : %d\n", jp, ip);*/
	      i = ip+i0;
	      y = cm->cfirst[v];
	      a[v][jp][ip] = a[y][jp][ip+1] + cm->tsc[v][0];
	      if (ret_shadow != NULL) shadow[v][jp][ip] = 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		/*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }

	      if (dsq[i] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][dsq[i]];
	      else
		a[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  for (ip = i1-i0; ip >= 0; ip--) a[v][0][ip] = IMPOSSIBLE; /* boundary condition */

	  for (jp = 1; jp <= j0-j1; jp++) {
	    j = jp+j1;
	    for (ip = i1-i0; ip >= 0; ip--) {
	      /*printf("MR IR jp : %d | ip : %d\n", jp, ip);*/
	      y = cm->cfirst[v];
	      a[v][jp][ip]      = a[y][jp-1][ip] + cm->tsc[v][0];
	      /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
	      if (ret_shadow != NULL) shadow[v][jp][ip] = 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip] = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    /*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }

	      if (dsq[j] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][dsq[j]];
	      else
		a[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} /* finished calculating deck v */

	  /* Check for local begin getting us to the root.
	   */
	  if (allow_begin && a[v][j0-j1][0] + cm->beginsc[v] > bsc)
	{
	  b   = v;
	  bsc = a[v][j0-j1][0] + cm->beginsc[v];
	}

	  /* Check whether we need to store the local begin score
	   * for a possible traceback.
	   */
	  if (allow_begin && v == 0 && bsc > a[0][j0-j1][0])
	{
	  a[0][j0-j1][0] = bsc;
	  if (ret_shadow != NULL) shadow[v][j0-j1][0] = USED_LOCAL_BEGIN;
	}

	  /* Now, try to reuse memory under v.
	   */
	  if (! do_full) {
	for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	  {
	    touch[y]--;
	    if (touch[y] == 0) {
	      deckpool_push(dpool, a[y]);
	      a[y] = NULL;
	    }
	  }
	  }
	} /* end loop over v; we now have a complete matrix */

  /* Keep the score.
   */
  sc = a[r][j0-j1][0];
  if (ret_b != NULL)   *ret_b   = b;    /* b is -1 if allow_begin is FALSE. */
  if (ret_bsc != NULL) *ret_bsc = bsc;  /* bsc is IMPOSSIBLE if allow_begin is FALSE */

  /* If the caller doesn't want the score matrix back, blow
   * it away (saving decks in the pool). Else, pass it back.
   */
  if (ret_a == NULL) {
	for (v = r; v <= w2; v++)	/* note: go all the way to the bottom of the split set */
	  if (a[v] != NULL) {
	deckpool_push(dpool, a[v]);
	a[v] = NULL;
	  }
	free(a);
  } else *ret_a = a;

  /* If caller doesn't want the deck pool, blow it away.
   * Else, pass it back.
   */
  if (ret_dpool == NULL) {
	float **foo;
	while (deckpool_pop(dpool, &foo))
	  free_vji_deck(foo, j1,j0);
	deckpool_free(dpool);
  } else *ret_dpool = dpool;

  free(touch);
  if (ret_shadow != NULL) *ret_shadow = shadow;
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return 0.; /* never reached */
}

/* Function: voutside()
 * Date:     SRE, Sun Jun  3 15:44:41 2001 [St. Louis]
 *
 * Purpose:  Run the outside version of a CYK alignment algorithm for
 *           a V problem: an unbifurcated CM subgraph from r..z, aligned
 *           to a one-whole subsequence i0..i1//j1..j0, exclusive of
 *           z, i1, j1.
 *
 *           This is done in the vji coordinate system, where both
 *           our j and i coordinates are transformed. The Platonic
 *           ideal matrix runs [j1..j0][i0..i1]. The implemented
 *           matrix runs [0..j0-j1][0..i1-i0].
 *
 *           Much of the behavior in calling conventions, etc., is
 *           analogous to inside() and vinside(); see their prefaces
 *           for more info. Unlike the inside engines, we never
 *           need to calculate a shadow matrix - outside engines are
 *           only used for divide and conquer steps.
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           r         - first state of linear model segment (S; MP, ML, MR, or D)
 *           z         - last state of linear model segment (B; MP, ML, MR, or D)
 *           i0,i1     - subsequence before the hole  (1..L)
 *           j1,j0     - subsequence after the hole (1..L)
 *           useEL     - if TRUE, worry about local alignment.
 *           do_full   - if TRUE, we save all the decks in beta, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the lowermost decks (inc. z) are valid
 *                       at the end.
 *           beta      - if non-NULL, this is an existing matrix, with NULL
 *                       decks for r..z, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_beta  - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated vji decks sized
 *                       for this subsequence i0..i1//j1..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..i1//j1..j0 subseq,
 *                       because of the size of the subseq decks.
 */
static void
voutside(CM_t *cm, ESL_DSQ *dsq, int L,
	 int r, int z, int i0, int i1, int j1, int j0, int useEL,
	 int do_full, float ***beta, float ****ret_beta,
	 struct deckpool_s *dpool, struct deckpool_s **ret_dpool)
{
  int      status;
  int      v,y;			/* indices for states */
  int      i,j;			/* indices in sequence dimensions */
  int      ip, jp;		/* transformed sequence indices */
  float    sc;			/* a temporary variable holding a score */
  int     *touch;               /* keeps track of how many lower decks still need this deck */
  float    escore;		/* an emission score, tmp variable */
  int      voffset;		/* index of v in t_v(y) transition scores */

  /* Allocations and initializations
   */
  			/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();

  /* If caller didn't give us a matrix, make one.
   * Remember to allow for deck M, the EL deck, for local alignments.
   */
  if (beta == NULL) {
	ESL_ALLOC(beta, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) beta[v] = NULL;
  }
  /* Initialize the root deck. This probably isn't the most efficient way to do it.
   */
  if (! deckpool_pop(dpool, &(beta[r])))
	beta[r] = alloc_vji_deck(i0,i1,j1,j0);
  for (jp = 0; jp <= j0-j1; jp++) {
	for (ip = 0; ip <= i1-i0; ip++)
	  beta[r][jp][ip] = IMPOSSIBLE;
  }
  beta[r][j0-j1][0] = 0;

  /* Initialize the EL deck, if we're in local mode w.r.t. ends.
   * Deal with the special initialization case of the root state r
   * immediately transitioning to EL, if we're supposed to use EL.
   */
  if (useEL && cm->flags & CMH_LOCAL_END) {
	if (! deckpool_pop(dpool, &(beta[cm->M])))
	  beta[cm->M] = alloc_vji_deck(i0,i1,j1,j0);
	for (jp = 0; jp <= j0-j1; jp++) {
	  for (ip = 0; ip <= i1-i0; ip++)
	beta[cm->M][jp][ip] = IMPOSSIBLE;
	}
  }
  if (useEL && NOT_IMPOSSIBLE(cm->endsc[r])) {
	switch(cm->sttype[r]) {
	case MP_st:
	  if (i0 == i1 || j1 == j0) break;
	  if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
	escore = cm->esc[r][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
	  else
	escore = DegeneratePairScore(cm->abc, cm->esc[r], dsq[i0], dsq[j0]);
	  beta[cm->M][j0-j1-1][1] = cm->endsc[r] +
	(cm->el_selfsc * ((j0-1)-(i0+1)+1)) + escore;
	  break;
	case ML_st:
	case IL_st:
	  if (i0 == i1) break;
	  if (dsq[i0] < cm->abc->K)
	escore = cm->esc[r][(int) dsq[i0]];
	  else
	escore = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[r]);
	  beta[cm->M][j0-j1][1] = cm->endsc[r] +
	(cm->el_selfsc * ((j0)-(i0+1)+1)) + escore;
	  break;
	case MR_st:
	case IR_st:
	  if (j0==j1) break;
	  if (dsq[j0] < cm->abc->K)
	escore = cm->esc[r][(int) dsq[j0]];
	  else
	escore = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[r]);
	  beta[cm->M][j0-j1-1][0] = cm->endsc[r] +
	(cm->el_selfsc * ((j0-1)-(i0)+1)) + escore;
	  break;
	case S_st:
	case D_st:
	  beta[cm->M][j0-j1][0] = cm->endsc[r] +
	(cm->el_selfsc * ((j0)-(i0)+1));
	  break;
	default:  cm_Fail("bogus parent state %d\n", cm->sttype[r]);
	}
  }

  /* Initialize the "touch" array, used for figuring out
   * when a deck is no longer touched, so it can be free'd.
   */
  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;   v < r;     v++) touch[v] = 0;
  for (v = z+1; v < cm->M; v++) touch[v] = 0;
  for (v = r;   v <= z;    v++) {
	if (cm->sttype[v] == B_st) touch[v] = 2; /* well, we never use this, but be complete */
	else                       touch[v] = cm->cnum[v];
  }

  /* Main loop down through the decks
   */
  for (v = r+1; v <= z; v++)
	{
	  /* First we need to fetch a deck of memory to fill in;
	   * we try to reuse a deck but if one's not available we allocate
	   * a fresh one.
	   */
	  if (! deckpool_pop(dpool, &(beta[v])))
	beta[v] = alloc_vji_deck(i0,i1,j1,j0);

	  /* Init the whole deck to IMPOSSIBLE.
	   */
	  for (jp = j0-j1; jp >= 0; jp--)
	for (ip = 0; ip <= i1-i0; ip++)
	  beta[v][jp][ip] = IMPOSSIBLE;

	  /* If we can get into deck v by a local begin transition, do an init
	   * with that.
	   */
	  if (r == 0 && i0 == 1 && j0 == L && (cm->flags & CMH_LOCAL_BEGIN))
	{
	  if (cm->beginsc[v] > beta[v][j0-j1][0])
	    beta[v][j0-j1][0] = cm->beginsc[v];
	}

	  /* main recursion:
	   */
	  for (jp = j0-j1; jp >= 0; jp--) {
	j = jp+j1;
	for (ip = 0; ip <= i1-i0; ip++)
	  {
	    i = ip+i0;

	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      if (y < r) continue; /* deal with split sets */
	      voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	      switch(cm->sttype[y]) {
	      case MP_st:
		if (j == j0 || i == i0) continue; /* boundary condition */
		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);

		if ((sc = beta[y][jp+1][ip-1]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case ML_st:
	      case IL_st:
		if (i == i0) continue;	/* boundary condition */

		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);

		if ((sc = beta[y][jp][ip-1]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case MR_st:
	      case IR_st:
		if (j == j0) continue;

		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);

		if ((sc = beta[y][jp+1][ip]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		if ((sc = beta[y][jp][ip] + cm->tsc[y][voffset]) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      default: cm_Fail("bogus parent state %d\n", cm->sttype[y]);
	      }/* end switch over states*/
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (beta[v][jp][ip] < IMPOSSIBLE) beta[v][jp][ip] = IMPOSSIBLE;

	  } /* ends loop over ip. We know all beta[v][jp][ip] in this row jp */

	  }/* end loop over jp. We know the beta's for the whole deck.*/

	  /* Deal with local alignment
	   * transitions v->EL, if we're doing local alignment and there's a
	   * possible transition.
	   */
	  if (useEL && NOT_IMPOSSIBLE(cm->endsc[v])) {
	for (jp = j0-j1; jp >= 0; jp--) {
	  j = jp+j1;
	  for (ip = 0; ip <= i1-i0; ip++)
	    {
	      i = ip+i0;
	      switch (cm->sttype[v]) {
	      case MP_st:
		if (j == j0 || i == i0) continue; /* boundary condition */
		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
		if ((sc = beta[v][jp+1][ip-1] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1)) + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case ML_st:
	      case IL_st:
		if (i == i0) continue;
		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
		if ((sc = beta[v][jp][ip-1] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1)) + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case MR_st:
	      case IR_st:
		if (j == j0) continue;
		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
		if ((sc = beta[v][jp+1][ip] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1)) + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case S_st:
	      case D_st:
	      case E_st:
		if ((sc = beta[v][jp][ip] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1))) > beta[cm->M][jp][ip])
		    beta[cm->M][jp][ip] = sc;
		break;
	      default:  cm_Fail("bogus parent state %d\n", cm->sttype[y]);
	      } /* end switch over parent v state type */
	    } /* end loop over ip */
	} /* end loop over jp */
	  }

	  /* Finished deck v.
	   * now look at its parents; if we're reusing memory (! do_full)
	   * push the parents that we don't need any more into the pool.
	   */
	  if (! do_full) {
	for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	  touch[y]--;
	  if (touch[y] == 0) {
	    deckpool_push(dpool, beta[y]);
	    beta[y] = NULL;
	  }
	}
	  }

	} /* end loop over decks v. */

#if 0
  /* superfluous code, I think...*/
  /* Deal with the last step needed for local alignment
   * w.r.t. ends: left-emitting, zero-scoring EL->EL transitions.
   */
  if (useEL && cm->flags & CMH_LOCAL_END) {
	for (jp = j0-j1; jp >= 0; jp--)
	  for (ip = 1; ip <= i1-i0; ip++) /* careful w/ boundary here */
	if ((sc = beta[cm->M][jp][ip-1]) > beta[cm->M][jp][ip])
	  beta[cm->M][jp][ip] = sc;
  }
#endif

  /* If the caller doesn't want the matrix, free it.
   * (though it would be *stupid* for the caller not to want the
   * matrix in the current implementation!)
   */
  if (ret_beta == NULL) {
	for (v = r; v <= z; v++)
	  if (beta[v] != NULL) { deckpool_push(dpool, beta[v]); beta[v] = NULL; }
	if (cm->flags & CMH_LOCAL_END) {
	  deckpool_push(dpool, beta[cm->M]);
	  beta[cm->M] = NULL;
	}
	free(beta);
  } else *ret_beta = beta;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	float **a;
	while (deckpool_pop(dpool, &a))
	  free_vji_deck(a,j1,j0);
	deckpool_free(dpool);
  } else *ret_dpool = dpool;

  free(touch);
  return;

 ERROR:
  cm_Fail("Memory allocation error.\n");
}

/*****************************************************************
 * The traceback routines
 *   insideT  - run inside(), append trace in postorder traversal
 *   vinsideT - run vinside(), append trace in postorder traversal
 *****************************************************************/

/* Function: insideT()
 * Date:     SRE, Fri Aug 11 12:08:18 2000 [Pittsburgh]
 *
 * Purpose:  Call inside, get vjd shadow matrix;
 *           then trace back. Append the trace to a given
 *           traceback, which already has state r at tr->n-1.
 *
 *           If we're not in banded mode, dmin and dmax should
 *           be passed in as NULL.
 */
static float
insideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
	int r, int z, int i0, int j0,
	int allow_begin, int *dmin, int *dmax)
{

  int       status;
  void   ***shadow;             /* the traceback shadow matrix */
  float     sc;			/* the score of the CYK alignment */
  ESL_STACK *pda;                /* stack that tracks bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, j, subseq len */
  int       k;
  int       y, yoffset;
  int       bifparent;
  int       b;
  float     bsc;

  if(dmin == NULL && dmax == NULL)
	{
	  sc = inside(cm, dsq, L, r, z, i0, j0,
		  BE_EFFICIENT,	/* memory-saving mode */
		  NULL, NULL,	/* manage your own matrix, I don't want it */
		  NULL, NULL,	/* manage your own deckpool, I don't want it */
		  &shadow,	/* return a shadow matrix to me. */
		  allow_begin,  /* TRUE to allow local begins */
		  &b, &bsc);	/* if allow_begin is TRUE, gives info on optimal b */
	}
  else
	{
	  sc = inside_b(cm, dsq, L, r, z, i0, j0,
		    BE_EFFICIENT,/* memory-saving mode */
		    NULL, NULL,	 /* manage your own matrix, I don't want it */
		    NULL, NULL,	 /* manage your own deckpool, I don't want it */
		    &shadow,	 /* return a shadow matrix to me. */
		    allow_begin, /* TRUE to allow local begins */
		    &b, &bsc,	 /* if allow_begin is TRUE, gives info on optimal b */
		    dmin, dmax); /* the bands */
	}

  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;
  v = r;
  j = j0;
  i = i0;
  d = j0-i0+1;

  /*printf("Starting traceback in insideT()\n");*/
  while (1) {
	if (cm->sttype[v] == B_st) {
	  k = ((int **) shadow[v])[j][d];   /* k = len of right fragment */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;	/* remember the end j    */
	  if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;	/* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;	/* remember the trace index of the parent B state */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  y = cm->cfirst[v];
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	} else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	} else {
	  yoffset = ((char **) shadow[v])[j][d];

	  /*printf("v : %d | r : %d | z : %d | i0 : %d | \n", v, r, z, i0);*/
	  /*printf("\tyoffset : %d\n", yoffset);*/
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    cm_Fail("'Inconceivable!'\n'You keep using that word...'");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL)
	{	/* a local alignment end */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	  v = cm->M;		/* now we're in EL. */
	}
	  else if (yoffset == USED_LOCAL_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	  v = b;
	}
	  else
	{
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	}
  }
  esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  free_vjd_shadow_matrix(shadow, cm, i0, j0);
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* NEVERREACHED */
}

/* Function: vinsideT()
 * Date:     SRE, Sat Jun  2 14:40:13 2001 [St. Louis]
 *
 * Purpose:  Call vinside(), get vji shadow matrix for a V problem;
 *           then trace back. Append the trace to a
 *           given traceback, which has state r already at
 *           t->n-1.
 *
 *           If we're not in banded mode, dmin and dmax should
 *           be passed in as NULL.
 */
static float
vinsideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
	 int r, int z, int i0, int i1, int j1, int j0, int useEL,
	 int allow_begin, int *dmin, int *dmax)
{
  char ***shadow;
  float   sc;
  int     v,y;
  int     j,i;
  int     jp,ip;
  int     yoffset;
  int     b;
  float   bsc;

  /* If we can deduce the traceback unambiguously without
   * doing any DP... do it.
   */
  if (r == z) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, r);
	return 0.;
  }

  if(dmin == NULL && dmax == NULL)
	{
	  sc = vinside(cm, dsq, L, r, z, i0, i1, j1, j0, useEL,
		   BE_EFFICIENT,	/* memory-saving mode */
		   NULL, NULL,	/* manage your own matrix, I don't want it */
		   NULL, NULL,	/* manage your own deckpool, I don't want it */
		   &shadow,      	/* return a shadow matrix to me. */
		   allow_begin,     /* TRUE to allow local begin transitions */
		   &b, &bsc);       /* info on optimal local begin */
	}
  else
	{
	  sc = vinside_b(cm, dsq, L, r, z, i0, i1, j1, j0, useEL,
		     BE_EFFICIENT,	/* memory-saving mode */
		     NULL, NULL,	/* manage your own matrix, I don't want it */
		     NULL, NULL,	/* manage your own deckpool, I don't want it */
		     &shadow,      	/* return a shadow matrix to me. */
		     allow_begin,       /* TRUE to allow local begin transitions */
		     &b, &bsc,          /* info on optimal local begin */
		     dmin, dmax);
	}
  /* We've got a complete shadow matrix. Trace it back. We know
   * that the trace will begin with the start state r, at i0,j0
   * (e.g. jp=j0-j1, ip=0)
   */
  v = r;
  j = j0;
  i = i0;

  /*printf("Starting traceback in vinsideT()\n");*/
  while (1) {
	jp = j-j1;
	ip = i-i0;

	/* 1. figure out the next state (deck) in the shadow matrix.
	 */
	/*printf("v : %d | jp : %d | ip : %d | i0 : %d | \n", v, jp, ip, i0);*/
	yoffset = shadow[v][jp][ip];
	/*printf("\tyoffset : %d\n", yoffset);*/

	/* 2. figure out the i,j for state y, which is dependent
	 *    on what v emits (if anything)
	 */
	switch (cm->sttype[v]) {
	case D_st:            break;
	case MP_st: i++; j--; break;
	case ML_st: i++;      break;
	case MR_st:      j--; break;
	case IL_st: i++;      break;
	case IR_st:      j--; break;
	case S_st:            break;
	default:    cm_Fail("'Inconceivable!'\n'You keep using that word...'");
	}

	/* If the traceback pointer (yoffset) is -1, that's a special
	 * flag for a local alignment end, e.g. transition to EL (state "M").
	 */
	if (yoffset == USED_EL)
	  {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	break;			/* one way out of the while loop */
	  }
	else if (yoffset == USED_LOCAL_BEGIN)
	  {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	v = b;
	if (! useEL && v == z) break; /* the other way out of the while loop */
	  }
	else
	  {
	/*    Attach y,i,j to the trace. This new node always attaches
	 *    to the end of the growing trace -- e.g. trace node
	 *    tr->n-1.
	 */
	y = cm->cfirst[v] + yoffset;
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	v = y;
	if (! useEL && v == z) break; /* the other way out of the while loop */
	  }
  }

  /* We're done. Our traceback has just ended. We have just attached
   * state z for i1,j1; it is in the traceback at node tr->n-1.
   */
  free_vji_shadow_matrix(shadow, cm->M, j1, j0);
  return sc;
}

/*****************************************************************
 * The size calculators:
 *    insideT_size()   - Mb required by insideT
 *    vinsideT_size()  - Mb required by vinsideT
 *****************************************************************/

/* Function: insideT_size()
 * Date:     SRE, Sun Jun  3 17:56:08 2001 [St. Louis]
 *
 * Purpose:  Calculate the # of Mb required to run insideT()
 *           and solve a generic or wedge problem without any
 *           more divide/conquer.
 */
float
insideT_size(CM_t *cm, int L, int r, int z, int i0, int j0)
{
  float Mb;
  int   maxdecks;
  int   nends;
  int   nbif;

  nends = CMSegmentCountStatetype(cm, r, z, E_st);
  nbif  = CMSegmentCountStatetype(cm, r, z, B_st);
  maxdecks = cyk_deck_count(cm, r, z);

  Mb = (float) (sizeof(float **) * cm->M) / 1000000.;  /* the score matrix */
  Mb += (float) maxdecks * size_vjd_deck(L, i0, j0);
  Mb += (float) (sizeof(int) * cm->M) / 1000000.;      /* the touch array */

  Mb += (float) (sizeof(void **) * cm->M) / 1000000.;
  Mb += (float) (z-r+1-nends-nbif) * size_vjd_yshadow_deck(L, i0, j0);
  Mb += (float) nbif * size_vjd_kshadow_deck(L, i0, j0);

  return Mb;
}

float
vinsideT_size(CM_t *cm, int r, int z, int i0, int i1, int j1, int j0)
{
  float Mb;
  int   maxdecks;

  Mb = (float) (sizeof(float **) * cm->M) / 1000000.;
  maxdecks = cyk_deck_count(cm, r, z);
  Mb += maxdecks * size_vji_deck(i0,i1,j1,j0);
  Mb += (float)(z-r) * size_vji_shadow_deck(i0,i1,j1,j0);
  return Mb;
}

/* Function: cyk_deck_count()
 * Date:     SRE, Sun Jun  3 20:05:18 2001 [St. Louis]
 *
 * Purpose:  calculate and return the maximum number of
 *           decks that would be required in memory to
 *           solve an alignment problem involving a CM
 *           subgraph from r..z.
 *
 *           For a whole model, except for trivially small models with no
 *           stacked base pairs, this is almost invariably
 *           10+1+cyk_extra_decks(): MATP-MATP connections require
 *           10 decks (6 states in current node, 4 states in connected
 *           split set of next node). We share 1 end state deck. All
 *           other decks are retained S decks, needed for bifurcation
 *           calculations.
 */
static int
cyk_deck_count(CM_t *cm, int r, int z)
{
  int       status;
  ESL_STACK *pda;	/* pushdown stack simulating the deck pool */
  int       v,w,y;	/* state indices */
  int       nends;
  int       ndecks;
  int      *touch;	/* keeps track of how many higher decks still need this deck */

  /* Initializations, mirroring key parts of CYKInside()
   */
  ndecks = 1;			/* deck z, which we always need to start with. */
  nends  = CMSegmentCountStatetype(cm, r, z, E_st);
  pda    = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0; v < r;     v++) touch[v] = 0;
  for (v = r; v < z;     v++) touch[v] = cm->pnum[v];
  for (v = z; v < cm->M; v++) touch[v] = 0;

  for (v = z; v >= r; v--)
	{
	  if (cm->sttype[v] != E_st) {
	if (esl_stack_IPop(pda, &y) == eslEOD) ndecks++; /* simulated allocation of a new deck */
	  }

	  if (cm->sttype[v] == B_st) { /* release both S children of a bifurc */
	w = cm->cfirst[v];
	y = cm->cnum[v];
	if((status =esl_stack_IPush(pda, w)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, y)) != eslOK) goto ERROR;
	  } else {
	for (w = cm->cfirst[v]; w < cm->cfirst[v]+cm->cnum[v]; w++)
	  {
	    touch[w]--;
	    if (touch[w] == 0)
	      {
		if (cm->sttype[w] == E_st) {
		  nends--;
		  if (nends == 0) { if((status = esl_stack_IPush(pda, cm->M-1)) != eslOK) goto ERROR; }
		} else
		  if((status = esl_stack_IPush(pda, w)) != eslOK) goto ERROR;
	      }
	  }
	  }
	}
  free(touch);
  esl_stack_Destroy(pda);
  return ndecks;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return 0; /* never reached */
}

/* Function: cyk_extra_decks()
 * Date:     SRE, Sun Apr  7 14:42:48 2002 [St. Louis]
 *
 * Purpose:  Calculate the number of extra
 *           decks that will be needed to accommodate bifurc
 *           calculations.
 *
 * Args:     cm - the model.
 *
 * Returns:  # of extra decks.
 */
static int
cyk_extra_decks(CM_t *cm)
{
  int  max;
  int  x;
  int  v;

  max = x = 0;
  for (v = cm->M-1; v >= 0; v--)
	{
	  if      (cm->sttype[v] == S_st) x++;
	  else if (cm->sttype[v] == B_st) x-=2;
	  if (x > max) max = x;
	}
  return max-1;			/* discount ROOT S */
}

/*################################################################
 * The memory management routines.
 ################################################################*/

/*################################################################*/
/* Functions: deckpool_*()
 * Date:      SRE, Wed Aug  2 10:43:17 2000 [St. Louis]
 *
 * Purpose:   Implementation of a pushdown stack for storing decks
 *            of the inside or outside dynamic programming matrices, with the
 *            usual _create, _push, _pop, and _free API.
 *
 *            The deck pool allows us to efficiently reuse memory,
 *            so long as our DP algorithms step through the decks
 *            as their outermost loop.
 *
 *            Works for either coordinate system (vjd or vji)
 *            and subseq variants, because it's simply managing
 *            a deck as a float **.
 */
struct deckpool_s *
deckpool_create(void)
{
  int status;
  struct deckpool_s *dpool;

  ESL_ALLOC(dpool, sizeof(struct deckpool_s));
  dpool->block  = 10;		/* configurable if you want */
  ESL_ALLOC(dpool->pool, sizeof(float **) * dpool->block);
  dpool->nalloc = dpool->block;;
  dpool->n      = 0;
  return dpool;
 ERROR:
  cm_Fail("Memory allocation error.\n");
  return NULL; /* never reached */
}
void
deckpool_push(struct deckpool_s *dpool, float **deck)
{
  int   status;
  void *tmp;
  if (dpool->n == dpool->nalloc) {
	dpool->nalloc += dpool->block;
	ESL_RALLOC(dpool->pool, tmp, sizeof(float **) * dpool->nalloc);
  }
  dpool->pool[dpool->n] = deck;
  dpool->n++;
  ESL_DPRINTF3(("deckpool_push\n"));
  return;
 ERROR:
  cm_Fail("Memory reallocation error.\n");
}
int
deckpool_pop(struct deckpool_s *d, float ***ret_deck)
{
  if (d->n == 0) { *ret_deck = NULL; return 0;}
  d->n--;
  *ret_deck = d->pool[d->n];
  ESL_DPRINTF3(("deckpool_pop\n"));
  return 1;
}
void
deckpool_free(struct deckpool_s *d)
{
  free(d->pool);
  free(d);
}
/*================================================================*/

/*################################################################*/
/* Functions: *_vjd_*
 * Date:     SRE, Sat Aug 12 16:27:37 2000 [Titusville]
 *
 * Purpose:  Allocation and freeing of 3D matrices and 2D decks
 *           in the vjd coord system. These can be called on
 *           subsequences i..j, not just the full sequence 1..L,
 *           so they need i,j... if you're doing the full sequence
 *           just pass 1,L.
 *
 *           Also deal with shadow matrices and shadow decks in the
 *           vjd coordinate system. Note that bifurcation shadow decks
 *           need more dynamic range than other shadow decks, hence
 *           a separation into "kshadow" (BIFURC) and "yshadow" (other
 *           states) decks, and some casting shenanigans in
 *           a full ***shadow matrix.
 *
 *           Values in yshad are offsets to the next connected state,
 *           or a flag for local alignment. Possible offsets range from
 *           0..5 (maximum of 6 connected states). The flags are
 *           USED_LOCAL_BEGIN (101) and USED_EL (102), defined at
 *           the top of this file. Only yshad[0][L][L] (e.g. root state 0,
 *           aligned to the whole sequence) may be set to USED_LOCAL_BEGIN.
 *           (Remember that the dynamic range of yshad, as a char, is
 *           0..127, in ANSI C; we don't know if a machine will make it
 *           signed or unsigned.)
 */
float **
alloc_vjd_deck(int L, int i, int j)
{
  int status;
  float **a;
  int     jp;
  ESL_DPRINTF3(("alloc_vjd_deck : %.4f\n", size_vjd_deck(L,i,j)));
  ESL_ALLOC(a, sizeof(float *) * (L+1)); /* always alloc 0..L rows, some of which are NULL */
  for (jp = 0;   jp < i-1;    jp++) a[jp]     = NULL;
  for (jp = j+1; jp <= L;     jp++) a[jp]     = NULL;
  for (jp = 0;   jp <= j-i+1; jp++) ESL_ALLOC(a[jp+i-1], sizeof(float) * (jp+1));
  return a;
 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
float
size_vjd_deck(int L, int i, int j)
{
  float Mb;
  int   jp;
  Mb = (float) (sizeof(float *) * (L+1));
  for (jp = 0; jp <= j-i+1; jp++)
	Mb += (float) (sizeof(float) * (jp+1));
  return (Mb / 1000000.);
}
void
free_vjd_deck(float **a, int i, int j)
{
  int jp;
  for (jp = 0; jp <= j-i+1; jp++) if (a[jp+i-1] != NULL) free(a[jp+i-1]);
  free(a);
}
void
free_vjd_matrix(float ***a, int M, int i, int j)
{
  int v;
  for (v = 0; v <= M; v++)
	if (a[v] != NULL)		/* protect against double free's of reused decks (ends) */
	  { free_vjd_deck(a[v], i, j); a[v] = NULL; }
  free(a);
}
char **
alloc_vjd_yshadow_deck(int L, int i, int j)
{
  int status;
  char **a;
  int    jp;
  ESL_ALLOC(a, sizeof(char *) * (L+1)); /* always alloc 0..L rows, same as alloc_deck */
  for (jp = 0;   jp < i-1;    jp++) a[jp] = NULL;
  for (jp = j+1; jp <= L;     jp++) a[jp] = NULL;
  for (jp = 0;   jp <= j-i+1; jp++) ESL_ALLOC(a[jp+i-1], sizeof(char) * (jp+1));
  return a;
 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
float
size_vjd_yshadow_deck(int L, int i, int j)
{
  float  Mb;
  int    jp;
  Mb = (float) (sizeof(char *) * (L+1));
  for (jp = 0; jp <= j-i+1; jp++)
	Mb += (float) (sizeof(char) * (jp+1));
  return Mb / 1000000.;
}
void
free_vjd_yshadow_deck(char **a, int i, int j)
{
  int jp;
  for (jp = 0; jp <= j-i+1; jp++) if (a[jp+i-1] != NULL) free(a[jp+i-1]);
  free(a);
}
int **
alloc_vjd_kshadow_deck(int L, int i, int j)
{
  int status;
  int **a;
  int   jp;
  ESL_ALLOC(a, sizeof(int *) * (L+1)); /* always alloc 0..L rows, same as alloc_deck */
  for (jp = 0;   jp <  i-1;   jp++) a[jp] = NULL;
  for (jp = 0;   jp <= j-i+1; jp++) ESL_ALLOC(a[jp+i-1], sizeof(int) * (jp+1));
  for (jp = j+1; jp <= L;     jp++) a[jp] = NULL;
  return a;
 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
float
size_vjd_kshadow_deck(int L, int i, int j)
{
  float Mb;
  int   jp;

  Mb = (float)(sizeof(int *) * (L+1));
  for (jp = 0;   jp <= j-i+1; jp++)
	Mb += (float) (sizeof(int) * (jp+1));
  return Mb / 1000000.;
}
void
free_vjd_kshadow_deck(int **a, int i, int j)
{
  int jp;
  /*11.14.05 old line: for (jp = 0; jp <= j-i+1; jp++) if (a[jp+i-1] != NULL) free(a[jp]);*/
  for (jp = 0; jp <= j-i+1; jp++) if (a[jp+i-1] != NULL) free(a[jp-i+1]);
  free(a);
}
void
free_vjd_shadow_matrix(void ***shadow, CM_t *cm, int i, int j)
{
  int v;
  for (v = 0; v < cm->M; v++)
	if (shadow[v] != NULL) {
	  if (cm->sttype[v] == B_st) free_vjd_kshadow_deck((int **)  shadow[v], i, j);
	  else                       free_vjd_yshadow_deck((char **) shadow[v], i, j);
	  shadow[v] = NULL;
	}
  free(shadow);
}
/*================================================================*/

/*################################################################*/
/* Functions: *_vji_*
 * Date:     SRE, Sat Aug 12 16:44:55 2000 [Titusville]
 *
 * Purpose:  Allocation and freeing of 3D matrices and 2D decks
 *           in the vji coordinate system. Since these are used
 *           only for solving V problems, they work only
 *           on a defined cube in the 3D matrix: they need
 *           two triplets (r, i0, j0), (z, i1, j1)
 *           defining the known optimal endpoints of a segment from
 *           an S state to a B state.
 *
 *           By definition of V problems, there's no B states
 *           in between, so the shadow matrix doesn't need any
 *           special casting tricks the way the more generally
 *           used vjd system does.
 */
float **                 /* allocation of a score deck. */
alloc_vji_deck(int i0, int i1, int j1, int j0)
{
  int status;
  float **a;
  int     jp;
  ESL_DPRINTF3(("alloc_vji_deck : %.4f\n", size_vji_deck(i0,i1,j1,j0)));
  ESL_ALLOC(a, sizeof(float *) * (j0-j1+1));
  for (jp = 0; jp <= j0-j1; jp++)
	ESL_ALLOC(a[jp], sizeof(float)*(i1-i0+1));
  return a;
 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
float
size_vji_deck(int i0, int i1, int j1, int j0)
{
  float Mb;
  int   jp;
  Mb = (float)(sizeof(float *) * (j0-j1+1));
  for (jp = 0; jp <= j0-j1; jp++)
	Mb += (float)(sizeof(float)*(i1-i0+1));
  return Mb / 1000000.;
}
void			/* free'ing a score deck */
free_vji_deck(float **a, int j1, int j0)
{
  int jp;
  ESL_DPRINTF3(("free_vji_deck called\n"));
  for (jp = 0; jp <= j0-j1; jp++)
	if (a[jp] != NULL) free(a[jp]);
  free(a);
}
void
free_vji_matrix(float ***a, int M, int j1, int j0)
{
  int v;
  /* Free the whole matrix - even if we used only a subset of
   * the decks, all initialization routines init all decks 0..M
   * to NULL, so this is safe. (see bug #i2).
   */
  for (v = 0; v <= M; v++)
	if (a[v] != NULL) { free_vji_deck(a[v], j1, j0); a[v] = NULL; }
  free(a);
}
char **		        /* allocation of a traceback ptr (shadow matrix) deck */
alloc_vji_shadow_deck(int i0, int i1, int j1, int j0)
{
  int status;
  char **a;
  int     jp;
  ESL_ALLOC(a, sizeof(char *) * (j0-j1+1));
  for (jp = 0; jp <= j0-j1; jp++)
	ESL_ALLOC(a[jp], sizeof(char)*(i1-i0+1));
  return a;
 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
float		        /* allocation of a traceback ptr (shadow matrix) deck */
size_vji_shadow_deck(int i0, int i1, int j1, int j0)
{
  float   Mb;
  int     jp;
  Mb = (float)(sizeof(char *) * (j0-j1+1));
  for (jp = 0; jp <= j0-j1; jp++)
	Mb += (float)(sizeof(char)*(i1-i0+1));
  return Mb / 1000000;
}
void	                /* free'ing a shadow deck */
free_vji_shadow_deck(char **a, int j1, int j0)
{
  int jp;
  for (jp = 0; jp <= j0-j1; jp++)
	if (a[jp] != NULL) free(a[jp]);
  free(a);
}
void
free_vji_shadow_matrix(char ***a, int M, int j1, int j0)
{
  int v;
  for (v = 0; v < M; v++)
	if (a[v] != NULL) { free_vji_shadow_deck(a[v], j1, j0); a[v] = NULL; }
  free(a);
}

/*################################################################
 * Unused code -
 *     a reference implementation of the real Outside() algorithm,
 *     including bifurcations.
 *################################################################*/
#if 0
/* Function: CYKOutside()
 * Date:     SRE, Mon Aug  7 07:45:37 2000 [St. Louis]
 */
void
CYKOutside(CM_t *cm, ESL_DSQ *dsq, int L, float ***alpha)
{
  int      status;
  float ***beta;		/* the scoring cube [v=0..M-1][j=0..L][d=0..j]*/
  int      v,y,z;		/* indices for states */
  int      j,d,i,k;		/* indices in sequence dimensions */
  float    sc;			/* a temporary variable holding a score */
  struct deckpool_s *dpool;     /* a pool of decks for beta that we can reuse */
  int     *touch;               /* keeps track of how many lower decks still need this deck */
  float    escore;		/* an emission score, tmp variable */

  /* Allocations and initializations
   */
  ESL_ALLOC(beta, (sizeof(float **) * cm->M));
  for (v = 0; v < cm->M; v++) beta[v] = NULL;

  dpool = deckpool_create();

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0; v < cm->M; v++)
	if (cm->sttype[v] == B_st) touch[v] = 2;
	else                       touch[v] = cm->cnum[v];

  for (j = 0; j <= L; j++)
	for (d = 0; d <= j; j++)
	  beta[0][j][d] = IMPOSSIBLE; /* can prob speed this initialization up */
  beta[0][L][L] = 0;

  /* Main loop down through the decks
   */
  /* EPN bug fix 05.25.06. Durbin et. al. p.287 CM Outside alg uses state
   * indices 1..M, with state 1 = ROOT_S, so there's an off-by-one
   * w.r.t this implementation. Following loop followed Durbin convention,
   * but should follow implemented convention:
   * OLD LINE: for (v = 2; v < cm->M; v++)
   */
  for (v = 1; v < cm->M; v++)
	{
	  /* First we need to fetch a deck of memory to fill in;
	   * we try to reuse a deck but if one's not available we allocate
	   * a fresh one.
	   */
	  if (! deckpool_pop(dpool, &(beta[v])))
	beta[v] = alloc_vjd_deck(L, 1, L);

	  /* main recursion:
	   */
	  for (j = L; j >= 0; j--)
	for (d = j; d >= 0; d--)
	  {
	    if (cm->stid[v] == BEGL_S)
	      {
		y = cm->plast[v];	/* the parent bifurcation    */
		z = cm->cnum[y];	/* the other (right) S state */

		beta[v][j][d] = beta[y][j][d] + alpha[z][j][0]; /* init on k=0 */
		for (k = 1; k <= L-j; k++)
		  if ((sc = beta[y][j+k][d+k] + alpha[z][j+k][k]) > beta[v][j][d])
		    beta[v][j][d] = sc;
	      }
	    else if (cm->stid[v] == BEGR_S)
	      {
		y = cm->plast[v];	        /* the parent bifurcation    */
		z = cm->cfirst[y];	/* the other (left) S state */

		beta[v][j][d] = beta[y][j][d] + alpha[z][j-d][0];	/* init on k=0 */
		for (k = 1; k <= j-d; k++)
		  if ((sc = beta[y][j][d+k] + alpha[z][j-d][k]) > beta[v][j][d])
		    beta[v][j][d] = sc;
	      }
	    else
	      {
		alpha[v][j][d] = IMPOSSIBLE;
		i = j-d+1;
		for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
		  switch(cm->sttype[j]) {
		  case MP_st:
		    if (d == j || d == j-1) continue; /* boundary condition */

		    if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		      escore = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		    else
		      escore = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);

		    if ((sc = beta[y][j+1][d+2] + cm->tsc[y][v] + escore) > beta[v][j][d])
		      beta[v][j][d] = sc;
		    break;

		  case ML_st:
		  case IL_st:
		    if (d == j) continue;	/* boundary condition (note when j=0, d=0*/

		    if (dsq[i-1] < cm->abc->K)
		      escore = cm->esc[y][(int) dsq[i-1]];
		    else
		      escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);

		    if ((sc = beta[y][j][d+1] + cm->tsc[y][v] + escore) > beta[v][j][d])
		      beta[v][j][d] = sc;
		    break;

		  case MR_st:
		  case IR_st:
		    if (d == j || j == L) continue;

		    if (dsq[j+1] < cm->abc->K)
		      escore = cm->esc[y][(int) dsq[j+1]];
		    else
		      escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);

		    if ((sc = beta[y][j+1][d+1] + cm->tsc[y][v] + escore) > beta[v][j][d])
		      beta[v][j][d] = sc;
		    break;

		  case B_st:
		  case E_st:
		  case D_st:
		    if ((sc = beta[y][j][d] + cm->tsc[y][v]) > beta[v][j][d])
		      beta[v][j][d] = sc;
		    break;

		  default: cm_Fail("bogus parent state %d\n", cm->sttype[y]);
		  }/* end switch over states*/
		}
	      }/*ends our handling of beta[v][j][d] */
	    if (beta[v][j][d] < IMPOSSIBLE) beta[v][j][d] = IMPOSSIBLE;
	  }

	  /* Finished deck v.
	   * now worry about reuse of memory in beta:
	   */
	  for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--)
	{
	  touch[y]--;
	  if (touch[y] == 0) {
	    deckpool_push(dpool, beta[y]);
	    beta[y] = NULL;
	  }
	}
	} /* end loop over decks v. */

  free(touch);
  /*dpool*/
  /*beta*/
  return;
 ERROR:
  cm_Fail("Memory allocation error.");
}
#endif

/*################################################################
 * The banded dividers and conquerors.
 *################################################################*/

/* Function: generic_splitter_b()
 *           EPN 05.19.05
 * *based on generic_splitter(), only difference is bands are used :
 * Date:     SRE, Sat May 12 15:08:38 2001 [CSHL]
 *
 * Purpose:  Solve a "generic problem": best parse of
 *           a possibly bifurcated subgraph cm^r_z to
 *           a substring dsq[i0..j0]. r is usually a start
 *           state (S_st) but may be any non-end state type in
 *           the case of local alignment begins (ROOT 0->r).
 *           z is always an end state (E_st).
 *
 *           Given: a cm subgraph from r..z
 *                  a subsequence from i0..j0
 *           Attaches the optimal trace T{r..z}, exclusive of r
 *           and inclusive of z, to tr.
 *
 *           A full divide & conquer never terminates
 *           in generic_splitter; the recursion must
 *           terminate in v_splitter and wedge_splitter;
 *           so we don't test an end-of-recursion boundary.
 *
 * Args:     cm          - model
 *           sq          - digitized sequence 1..L
 *           tr          - the traceback we're adding on to.
 *           r           - index of the root state of this problem in the model
 *           z           - index of an end state (E_st) in the model
 *           i0          - start in the sequence (1..L)
 *           j0          - end in the sequence (1..L)
 *           dmin   - minimum d bound for each state v; [0..v..M-1]
 *           dmax   - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns:  score of the optimal parse of dsq(i0..j0) with cm^r_z
 */
static float
generic_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
		 int r, int z, int i0, int j0, int *dmin, int *dmax)
{
  float ***alpha;
  float ***beta;
  struct deckpool_s *pool;
  int      v,w,y;		/* state indices */
  int      wend, yend;		/* indices for end of subgraphs rooted at w,y */
  int      jp;			/* j': relative position in subseq, 0..W */
  int      W;			/* length of subseq i0..j0 */
  float    sc;			/* tmp variable for a score */
  int      j,d,k;		/* sequence indices */
  float    best_sc;		/* optimal score at the optimal split point */
  int      best_k;		/* optimal k for the optimal split */
  int      best_d;		/* optimal d for the optimal split */
  int      best_j;		/* optimal j for the optimal split */
  int      tv;			/* remember the position of a bifurc in the trace. */
  int      b1,b2;		/* argmax_v for 0->v local begin transitions */
  float    b1_sc, b2_sc;	/* max_v scores for 0->v local begin transitions */

  /* 1. If the generic problem is small enough, solve it with insideT,
   *    and append the trace to tr.
   */
  if (insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT) {
	ESL_DPRINTF2(("Solving a generic w/ insideT - G%d[%s]..%d[%s], %d..%d\n",
		  r, UniqueStatetype(cm->stid[r]),
		  z, UniqueStatetype(cm->stid[z]),
		  i0, j0));
	sc = insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0), dmin, dmax);
	return sc;
  }

  /* 2. Traverse down from r, find first bifurc.
   *    The lowest a bifurc could be: B-S-E/S-IL-E = vend-5
   *
   */
  for (v = r; v <= z-5; v++)
	if (cm->sttype[v] == B_st) break; /* found the first bifurcation, now v */

  /* 3. If there was no bifurcation, this is a wedge problem; solve it
   *    with wedge_splitter.
   */
  if (v > z-5) {		/* no bifurc? it's a wedge problem  */
	if (cm->sttype[z] != E_st) cm_Fail("inconceivable.");
	sc = wedge_splitter_b(cm, dsq, L, tr, r, z, i0, j0, dmin, dmax);
	return sc;
  }

  /* Set up the state quartet r,v,w,y for a divide and conquer
   * solution of the generic problem.
   */
  w = cm->cfirst[v];		/* index of left S  */
  y = cm->cnum[v];		/* index right S    */
  if (w < y) { wend = y-1; yend = z; }
  else       { yend = w-1; wend = z; }

  /* Calculate alpha[w] deck and alpha[y] deck.
   * We also get b1: best choice for 0->b local begin. b1_sc is the score if we do this.
   * Analogous for b2, b2_sc on the other side.
   */
  inside_b(cm, dsq, L, w, wend, i0, j0, BE_EFFICIENT, NULL,  &alpha, NULL, &pool, NULL,
	   (r==0), &b1, &b1_sc, dmin, dmax);
  inside_b(cm, dsq, L, y, yend, i0, j0, BE_EFFICIENT, alpha, &alpha, pool, &pool, NULL,
	   (r==0), &b2, &b2_sc, dmin, dmax);

  /* Calculate beta[v] deck (stick it in alpha). Let the pool get free'd.
   * (If we're doing local alignment, deck M is the beta[EL] deck.)
   */
  outside_b(cm, dsq, L, r, v, i0, j0, BE_EFFICIENT, alpha, &beta, pool, NULL, dmin, dmax);

  /* Find the optimal split at the B.
   */
  W = j0-i0+1;
  best_sc = IMPOSSIBLE;
  for (jp = 0; jp <= W; jp++)
	{
	  j = i0-1+jp;
	  /* Bands used */
	  /* old line : for (d = 0; d <= jp; d++) */
	  for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	for (k = 0; k <= d; k++)
	  if ((sc = alpha[w][j-k][d-k] + alpha[y][j][k] + beta[v][j][d]) > best_sc)
	    {
	      best_sc = sc;
	      best_k  = k;
	      best_j  = j;
	      best_d  = d;
	    }
	}

  /* Local alignment only: maybe we're better off in EL?
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	/* There is no band on the EL state */
	for (d = 0; d <= jp; d++)
	  if ((sc = beta[cm->M][j][d]) > best_sc) {
	    best_sc = sc;
	    best_k  = -1;	/* special flag for local end, EL. */
	    best_j  = j;
	    best_d  = d;
	  }
	  }
  }

  /* Local alignment only: maybe we're better off in ROOT?
   */
  if (r == 0 && cm->flags & CMH_LOCAL_BEGIN) {
	if (b1_sc > best_sc) {
	  best_sc = b1_sc;
	  best_k  = -2;		/* flag for using local begin into left wedge w..wend */
	  best_j  = j0;
	  best_d  = W;
	}
	if (b2_sc > best_sc) {
	  best_sc = b2_sc;
	  best_k  = -3;		/* flag for using local begin into right wedge y..yend */
	  best_j  = j0;
	  best_d  = W;
	}
  }

  /* Free now, before recursing.
   * The two alpha matrices and the beta matrix
   * actually all point to the same memory, since no
   * decks in Inside and Outside needed to overlap.
   * Free 'em all in one call.
   */
  free_vjd_matrix(alpha, cm->M, i0, j0);

  /* If we're in EL, instead of B, the optimal alignment is entirely
   * in a V problem that's still above us. The TRUE flag sets useEL.
   */
  if (best_k == -1) {
	v_splitter_b(cm, dsq, L, tr, r, v, i0, best_j-best_d+1, best_j, j0, TRUE, dmin, dmax);
	return best_sc;
  }

  /* Else: if we're in the root 0, we know which r we did our local begin into.
   * We have a generic problem rooted there. The FALSE flag disallows
   * any further local begins.
   */
  if (best_k == -2) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b1);
	z = CMSubtreeFindEnd(cm, b1);
	generic_splitter_b(cm, dsq, L, tr, b1, z, i0, j0, dmin, dmax);
	return best_sc;
  }
  if (best_k == -3) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b2);
	z = CMSubtreeFindEnd(cm, b2);
	generic_splitter_b(cm, dsq, L, tr, b2, z, i0, j0, dmin, dmax);
	return best_sc;
  }

  /* Else (the usual case), ok, we did use B in the optimal split.
   * Split now into a V problem and two generic problems, and recurse
   * left fragment: i1 = j-d+1, j1 = j-k, vroot = w, vend = wend
   * right frag:    i2 = j-k+1, j2 = j,   vroot = y, vend = yend
   *
   * The problems must be solved in a particular order, since we're
   * constructing the trace in a postorder traversal.
   */
  ESL_DPRINTF2(("Generic splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		v, UniqueStatetype(cm->stid[v]),
		i0, best_j-best_d+1, best_j, j0));
  ESL_DPRINTF2(("   generic: G%d[%s]..%d[%s], %d..%d\n",
		w,    UniqueStatetype(cm->stid[w]),
		wend, UniqueStatetype(cm->stid[wend]),
		best_j-best_d+1, best_j-best_k));
  ESL_DPRINTF2(("   generic: G%d[%s]..%d[%s], %d..%d\n",
		y,    UniqueStatetype(cm->stid[y]),
		yend, UniqueStatetype(cm->stid[yend]),
		best_j-best_k+1, best_j));

  v_splitter_b(cm, dsq, L, tr, r, v, i0, best_j-best_d+1, best_j, j0, FALSE, dmin, dmax);
  tv = tr->n-1;

  InsertTraceNode(tr, tv, TRACE_LEFT_CHILD, best_j-best_d+1, best_j-best_k, w);
  generic_splitter_b(cm, dsq, L, tr, w, wend, best_j-best_d+1, best_j-best_k, dmin, dmax);
  InsertTraceNode(tr, tv, TRACE_RIGHT_CHILD, best_j-best_k+1, best_j, y);
  generic_splitter_b(cm, dsq, L, tr, y, yend, best_j-best_k+1, best_j, dmin, dmax);

  return best_sc;
}

/* Function: wedge_splitter_b()
 *           EPN 05.19.05
 * *based on wedge_splitter(), only difference is bands are used :
 * Date:     SRE, Sun May 13 08:44:15 2001 [CSHL genome mtg]
 *
 * Purpose:  Solve a "wedge problem": best parse of an
 *           unbifurcated subgraph cm^r..z to a substring
 *           dsq[i0..j0]. r may be a start state (when
 *           the wedge problem comes from being a special case
 *           of a generic problem) or a non-insert state
 *           (D, MP, ML, MR) (when the wedge comes from a
 *           previous wedge_splitter), or indeed, any non-end
 *           state (when wedge comes from a local begin).
 *           z, however, is always an end state.
 *
 *           Attaches the optimal trace T(r..z), exclusive
 *           of r and inclusive of z, to the growing trace tr.
 *
 *           Deal with a divide and conquer boundary condition:
 *           the next non-insert state after r is the end state z.
 *           All remaining sequence of i0..j0 that r doesn't emit
 *           must be dealt with by insert states.
 *
 * Args:     cm          - model
 *           dsq         - digitized sequence 1..L
 *           L           - length of dsq
 *           tr          - the traceback we're adding on to.
 *           r           - index of the first state in the subgraph
 *           z           - index of an end state (E_st) in the model
 *           i0          - start in the sequence (1..L)
 *           j0          - end in the sequence (1..L)
 *           dmin   - minimum d bound for each state v; [0..v..M-1]
 *           dmax   - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns:  The score of the best parse in bits.
 */
static float
wedge_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z, int i0, int j0,
		 int *dmin, int *dmax)
{
  float ***alpha;
  float ***beta;
  struct deckpool_s *pool;
  float sc;
  float best_sc;
  int   v,w,y;
  int   W;
  int   d, jp, j;
  int   best_v, best_d, best_j;
  int   midnode;
  int   b;	/* optimal local begin: b = argmax_v alpha_v(i0,j0) + t_0(v) */
  float bsc;	/* score for optimal local begin      */

  /* 1. If the wedge problem is either a boundary condition,
   *    or small enough, solve it with inside^T and append
   *    the trace to tr.
   *    It's formally possible that someone could set RAMLIMIT
   *    to something so small that even the boundary condition
   *    couldn't be done with inside^T - but that'd be a silly
   *    thing to do, so we ignore RAMLIMIT in that case.
   */
  if (cm->ndidx[z] == cm->ndidx[r] + 1 ||
	  insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT)
	{
	  ESL_DPRINTF2(("Solving a wedge:   G%d[%s]..%d[%s], %d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		z, UniqueStatetype(cm->stid[z]),
		i0,j0));
	  sc = insideT(cm, dsq, L, tr, r, z, i0, j0, (r==0), dmin, dmax);
	  return sc;
	}

  /* 2. Find our split set, w..y
   *    We choose the node in the middle.
   *    This can't be a BIF_nd (we're a wedge), or an END_nd (midnode
   *    can't be z) but it could be any other node including
   *    begin nodes (i.e. it might be that w==y).
   */
  midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r]) / 2);
  w = cm->nodemap[midnode];
  y = cm->cfirst[w]-1;

  /* 3. Calculate inside up to w, and outside down to y.
   *    We rely on a side effect of how deallocation works
   *    in these routines; the w..y decks are guaranteed
   *    to be retained.
   *    b will contain the optimal 0->v state for a local begin, and bsc
   *    is the score for using it.
   *    beta[cm->M] will contain the EL deck, if needed for local ends.
   */
  inside_b(cm, dsq, L, w, z, i0, j0, BE_EFFICIENT,
	   NULL, &alpha, NULL, &pool, NULL,
	   (r==0), &b, &bsc, dmin, dmax);
  outside_b(cm, dsq, L, r, y, i0, j0, BE_EFFICIENT, NULL, &beta, pool, NULL,
  dmin, dmax);

  /* 4. Find the optimal split at the split set: best_v, best_d, best_j
   */
  W = j0-i0+1;
  best_sc = IMPOSSIBLE;
  for (v = w; v <= y; v++)
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	  if ((sc = alpha[v][j][d] + beta[v][j][d]) > best_sc)
	    {
	      best_sc = sc;
	      best_v  = v;
	      best_d  = d;
	      best_j  = j;
	    }
	  }

  /* Local alignment ends only: maybe we're better off in EL,
   * not in the split set?
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = 0; jp <= W; jp++)
	  {
	j = i0-1+jp;
	/* There is no band on the EL state */
	for (d = 0; d <= jp; d++)
	  if ((sc = beta[cm->M][j][d]) > best_sc) {
	    best_sc = sc;
	    best_v  = -1;	/* flag for local alignment. */
	    best_j  = j;
	    best_d  = d;
	  }
	  }
  }

  /* Local alignment begins only: maybe we're better off in the root.
   */
  if (r==0 && (cm->flags & CMH_LOCAL_BEGIN)) {
	if (bsc > best_sc) {
	  best_sc = bsc;
	  best_v  = -2;		/* flag for local alignment */
	  best_j  = j0;
	  best_d  = W;
	}
  }

  /* free now, before recursing!
   */
  free_vjd_matrix(alpha, cm->M, i0, j0);
  free_vjd_matrix(beta,  cm->M, i0, j0);

  /* If we're in EL, instead of the split set, the optimal alignment
   * is entirely in a V problem that's still above us. The TRUE
   * flag sets useEL. It doesn't matter which state in the split
   * set w..y we use as the end of the graph; vinside() will have to
   * initialize the whole thing to IMPOSSIBLE anyway.
   */
  if (best_v == -1) {
	v_splitter_b(cm, dsq, L, tr, r, w, i0, best_j-best_d+1, best_j, j0, TRUE, dmin, dmax);
	return best_sc;
  }

  /* If we're in the root because of a local begin, the local alignment
   * is entirely in a wedge problem that's still below us, rooted at b.
   * The FALSE flag prohibits any more local begins in this and subsequent
   * problems.
   */
  if (best_v == -2) {
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b);
	wedge_splitter_b(cm, dsq, L, tr, b, z, i0, j0, dmin, dmax);
	return best_sc;
  }

  /* Else (usual case): the optimal split into a V problem and a wedge problem:
   *    i1 = best_j-best_d+1, j1 = best_j
   *    the V problem:     r..v, i0..i1, j1..j0
   *    the wedge problem: v..z, i1..j1
   *
   *    These have to solved in the order given because we're
   *    constructing the trace in postorder traversal.
   */
  ESL_DPRINTF2(("Wedge splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		best_v, UniqueStatetype(cm->stid[best_v]),
		i0, best_j-best_d+1, best_j, j0));
  ESL_DPRINTF2(("   wedge:   G%d[%s]..%d[%s], %d..%d\n",
		best_v, UniqueStatetype(cm->stid[best_v]),
		z, UniqueStatetype(cm->stid[z]),
		best_j-best_d+1, best_j));

  v_splitter_b(cm, dsq, L, tr, r, best_v, i0, best_j-best_d+1, best_j, j0, FALSE,
	       dmin, dmax);
  wedge_splitter_b(cm, dsq, L, tr, best_v, z, best_j-best_d+1, best_j, dmin, dmax);
  return best_sc;
}

/* Function: vsplitter_b()
 *           EPN 05.19.05
 * *based on vsplitter(), only difference is bands are used :
 *
 * Date:     SRE, Thu May 31 19:47:57 2001 [Kaldi's]
 *
 * Purpose:  Solve a "V problem": best parse of an unbifurcated
 *           subgraph cm^r..z to a one-hole subsequence
 *           i0..i1 // j1..j0.
 *
 *           Attaches the optimal trace T(r..z), exclusive of
 *           r, inclusive of z, to the growing trace tr.
 *
 *           r and z can be any non-insert state.
 *
 * Args:     cm          -  model
 *           dsq         - digitized sequence 1..L
 *           L           - length of dsq
 *           tr          - the traceback we're adding on to.
 *           r           - index of the first state in the subgraph
 *           z           - index of the last state in the subgraph
 *           i0,i1       - first part of the subsequence (1..L)
 *           j1,j0       - second part of the subsequence (1..L)
 *           useEL       - TRUE if i1,j1 aligned to EL, not z
 *           dmin        - minimum d bound for each state v; [0..v..M-1]
 *           dmax        - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns:  (void)
 */
static void
v_splitter_b(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
	   int r, int z, int i0, int i1, int j1, int j0,
	   int useEL, int *dmin, int *dmax)
{
  float ***alpha, ***beta;      /* inside and outside matrices */
  struct deckpool_s *pool;      /* pool for holding alloced decks */
  float sc;			/* tmp variable holding a score */
  int   v,w,y;			/* state indexes */
  int   ip,jp;
  int   best_v;
  int   best_i, best_j;		/* optimal i', j' split point */
  float best_sc;		/* score at optimal split point */
  int   midnode;
  int   b;			/* optimal choice for a 0->b local begin  */
  float bsc;			/* score if we use the local begin */
  int     *imin;                /* minimum i bound for each state v; [0..y-w]
								 * calculated using *dmin; offset from v, the
				 * band that corresponds to state v, is imin[v-w] */
  int     *imax;                /* maximum i bound for each state v; [0..y-w]
								 * calculated using *dmax; offset from v, the
				 * band that corresponds to state v, is imax[v-w] */

  /* 1. If the V problem is either a boundary condition, or small
   *    enough, solve it with v_inside^T and append the trace to tr.
   *    (With local alignment, we might even see a lone B state
   *     get handed to v_splitter(); hence the r==z case.)
   */
   if (cm->ndidx[z] == cm->ndidx[r] + 1 || r == z ||
	  vinsideT_size(cm, r, z, i0, i1, j1, j0) < RAMLIMIT)
	{
	  ESL_DPRINTF2(("Solving a V:   G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		z, UniqueStatetype(cm->stid[z]),
		i0,j1,j1,j0));
	  vinsideT(cm, dsq, L, tr, r, z, i0, i1, j1, j0, useEL, (r==0), dmin, dmax);
	  return;
	}

  /* 2. Find our split set, w..y.
   *    Choose the node in the middle.
   */
  midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r]) / 2);
  w = cm->nodemap[midnode];
  y = cm->cfirst[w]-1;

  /* 3. Calculate v_inside up to w, and v_outside down to y.
   *    As with wedge_splitter(), we rely on a side effect of how
   *    deallocation works, so the w..y decks are retained
   *    in alpha and beta even though we're in small memory mode.
   *    beta[cm->M] is the EL deck, needed for local ends.
   */
  vinside_b (cm, dsq, L, w, z, i0, i1, j1, j0, useEL, BE_EFFICIENT,
	     NULL, &alpha, NULL, &pool, NULL, (r==0), &b, &bsc,
	     dmin, dmax);
  voutside_b(cm, dsq, L, r, y, i0, i1, j1, j0, useEL, BE_EFFICIENT,
	     NULL, &beta,  pool, NULL, dmin, dmax);

  /* 4. Find the optimal split: v, ip, jp.
   */
  /* Bands used ip 1A */
  imin = malloc(sizeof (int) * (y-w+1));
  imax = malloc(sizeof (int) * (y-w+1));

  best_sc = IMPOSSIBLE;
  for (v = w; v <= y; v++)
	{
	  /* Bands used ip 1B */

	  /* Fill imin[v-w] and imax[v-w] as we go, one of many ways to handle imin and imax
	   * Remember state indices in imin and imax are offset from v because imin and
	   * imax run [0..y-w], ==> dmin[v] corresponds to imin[v-w]
	   */

	  imin[v-w] = j1-i0-dmax[v]+1;
	  imax[v-w] = j1-i0-dmin[v]+1;

	  /*orig lines : for (ip = 0; ip <= i1-i0; ip++)
	   *                    for (jp = 0; jp <= j0-j1; jp++)
	   *the order is switched here because the band on ip depends
	   *on jp.
	   */
	  for (jp = 0; jp <= j0-j1; jp++)
	{
	  if((imin[v-w]+jp) < 0) ip = 0;
	  else ip = imin[v-w]+jp;
	  for (; (ip <= imax[v-w]+jp) && ip <= (i1-i0); ip++)
	    if ((sc = alpha[v][jp][ip] + beta[v][jp][ip]) > best_sc)
	      {
		best_sc = sc;
		best_v  = v;
		best_i  = ip + i0;
		best_j  = jp + j1;
	      }
	}
	}
  /* Local alignment ends: maybe we're better off in EL, not
   * the split set?
   */
  if (useEL && (cm->flags & CMH_LOCAL_END)) {
	/* There is no band on the EL state */
	for (ip = 0; ip <= i1-i0; ip++)
	  for (jp = 0; jp <= j0-j1; jp++)
	if ((sc = beta[cm->M][jp][ip]) > best_sc) {
	  best_sc = sc;
	  best_v  = -1;
	  best_i  = ip + i0;
	  best_j  = jp + j1;
	}
  }

  /* Local alignment begins: maybe we're better off in root...
   */
  if (r==0 && (cm->flags & CMH_LOCAL_BEGIN)) {
	if (bsc > best_sc) {
	  best_sc = bsc;
	  best_v  = -2;
	  best_i  = i0;
	  best_j  = j0;
	}
  }

  /* Free now, before recursing!
   */
  free_vji_matrix(alpha, cm->M, j1, j0);
  free_vji_matrix(beta,  cm->M, j1, j0);

  /* If we're in EL, instead of the split set, the optimal
   * alignment is entirely in a V problem that's still above us.
   * The TRUE flag sets useEL; we propagate allow_begin.
   */
  if (best_v == -1) {
	v_splitter_b(cm, dsq, L, tr, r, w, i0, best_i, best_j, j0, TRUE, dmin, dmax);
	return;
  }

  /* If we used a local begin, the optimal alignment is
   * entirely in a V problem that's still below us, rooted
   * at b, for the entire one-hole sequence. The FALSE
   * flag prohibits more local begin transitions; we propagate
   * useEL.
   */
  if (best_v == -2) {
	if (b != z)
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, b);
	v_splitter_b(cm, dsq, L, tr, b, z, i0, i1, j1, j0, useEL, dmin, dmax);
	return;
  }

  /* The optimal split into two V problems:
   *    V:   r..v, i0..i', j'..j0
   *    V:   v..z, i'..i1, j1..j'
   * Solve in this order, because we're constructing the
   * trace in postorder traversal.
   */
  ESL_DPRINTF2(("V splitter:\n"));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		r, UniqueStatetype(cm->stid[r]),
		best_v, UniqueStatetype(cm->stid[best_v]),
		i0, best_i, best_j, j0));
  ESL_DPRINTF2(("   V:       G%d[%s]..%d[%s], %d..%d//%d..%d\n",
		best_v, UniqueStatetype(cm->stid[best_v]),
		z, UniqueStatetype(cm->stid[z]),
		best_i, i1, j1, best_j));

  v_splitter_b(cm, dsq, L, tr, r,      best_v, i0,     best_i, best_j, j0, FALSE,
	       dmin, dmax);
  v_splitter_b(cm, dsq, L, tr, best_v, z,      best_i, i1,     j1,     best_j, useEL,
	       dmin, dmax);

  free(imax);
  free(imin);
  return;
}

/*****************************************************************
 * The alignment engines, using bands:
 *     inside_b   - given generic or wedge problem G^r_z to i0..j0, return score and matrix
 *     outside_b  - given unbifurcated G^r_z to i0..j0, return matrix
 *
 *     vinside_b  - given V problem G^r_z to i0..i1//j1..j0, return score and matrix
 *     voutside_b - given unbifurcated G^r_z to i0..i1//j1..j0, return matrix
 ******************************************************************/

/* Function: inside_b()
 *           EPN 05.19.05
 * *based on inside(), only difference is bands are used :
 * Date:     SRE, Mon Aug  7 13:15:37 2000 [St. Louis]
 *
 * Purpose:  (See inside())
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           vroot     - first start state of subtree (0, for whole model)
 *           vend      - last end state of subtree (cm->M-1, for whole model)
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           do_full   - if TRUE, we save all the decks in alpha, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the uppermost deck (vroot) is valid
 *                       at the end.
 *           alpha     - if non-NULL, this is an existing matrix, with NULL
 *                       decks for vroot..vend, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_alpha - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated decks sized
 *                       for this subsequence i0..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..j0 subseq,
 *                       because of the size of the subseq decks.
 *           ret_shadow- if non-NULL, the caller wants a shadow matrix, because
 *                       he intends to do a traceback.
 *           allow_begin- TRUE to allow 0->b local alignment begin transitions.
 *           ret_b     - best local begin state, or NULL if unwanted
 *           ret_bsc   - score for using ret_b, or NULL if unwanted
 *           dmin   - minimum d bound for each state v; [0..v..M-1]
 *           dmax   - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns: Score of the optimal alignment.
 */
static float
inside_b(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
	 float ***alpha, float ****ret_alpha,
	 struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
	 void ****ret_shadow,
	 int allow_begin, int *ret_b, float *ret_bsc,
	 int *dmin, int *dmax)
{
  int      status;
  float  **end;         /* we re-use the end deck. */
  int      nends;       /* counter that tracks when we can release end deck to the pool */
  int     *touch;       /* keeps track of how many higher decks still need this deck */
  int      v,y,z;	/* indices for states  */
  int      j,d,i,k;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      W;		/* subsequence length */
  int      jp;		/* j': relative position in the subsequence  */
  void  ***shadow;      /* shadow matrix for tracebacks */
  int    **kshad;       /* a shadow deck for bifurcations */
  char   **yshad;       /* a shadow deck for every other kind of state */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */
  int      kmax;        /* for B_st's, maximum k value consistent with bands*/

  /* Allocations and initializations
   */
  b   = -1;
  bsc = IMPOSSIBLE;
  W   = j0-i0+1;		/* the length of the subsequence -- used in many loops  */
				/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();
  if (! deckpool_pop(dpool, &end))
	end = alloc_vjd_deck(L, i0, j0);
  nends = CMSubtreeCountStatetype(cm, vroot, E_st);
  for (jp = 0; jp <= W; jp++) {
	j = i0+jp-1;		/* e.g. j runs from 0..L on whole seq */
	end[j][0] = 0.;
	for (d = 1; d <= jp; d++) end[j][d] = IMPOSSIBLE;
  }

  /* if caller didn't give us a matrix, make one.
   * It's important to allocate for M+1 decks (deck M is for EL, local
   * alignment) - even though Inside doesn't need EL, Outside does,
   * and we might reuse this memory in a call to Outside.
   */
  if (alpha == NULL) {
	ESL_ALLOC(alpha, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) alpha[v] = NULL;
  }

  ESL_ALLOC(touch,  sizeof(int) * cm->M);
  for (v = 0;     v < vroot; v++) touch[v] = 0;
  for (v = vroot; v <= vend; v++) touch[v] = cm->pnum[v];
  for (v = vend+1;v < cm->M; v++) touch[v] = 0;

  /* The shadow matrix, if caller wants a traceback.
   * We do some pointer tricks here to save memory. The shadow matrix
   * is a void ***. Decks may either be char ** (usually) or
   * int ** (for bifurcation decks). Watch out for the casts.
   * For most states we only need
   * to keep y as traceback info, and y <= 6. For bifurcations,
   * we need to keep k, and k <= L, and L might be fairly big.
   * (We could probably limit k to an unsigned short ... anyone
   * aligning an RNA > 65536 would need a big computer... but
   * we'll hold off on that for now. We could also pack more
   * traceback pointers into a smaller space since we only really
   * need 3 bits, not 8.)
   */
  if (ret_shadow != NULL) {
	ESL_ALLOC(shadow, sizeof(void **) * cm->M);
	for (v = 0; v < cm->M; v++) shadow[v] = NULL;
  }

  /* Main recursion
   */
  for (v = vend; v >= vroot; v--)
	{
	  /* First we need a deck to fill in.
	   * 1. if we're an E, reuse the end deck (and it's already calculated)
	   * 2. else, see if we can take something from the pool
	   * 3. else, allocate a new deck.
	   */
	  if (cm->sttype[v] == E_st) {
	alpha[v] = end; continue;
	  }
	  if (! deckpool_pop(dpool, &(alpha[v])))
	alpha[v] = alloc_vjd_deck(L, i0, j0);

	  if (ret_shadow != NULL) {
	if (cm->sttype[v] == B_st) {
	  kshad     = alloc_vjd_kshadow_deck(L, i0, j0);
	  shadow[v] = (void **) kshad;
	} else {
	  yshad     = alloc_vjd_yshadow_deck(L, i0, j0);
	  shadow[v] = (void **) yshad;
	}
	  }

	  /* Impose bands by setting all cells outside the bands to 0
	   * This is independent of state type so we do it outside
	   * the following set of if then statements.
	   */

	  for (jp = 0; jp <= W; jp++) {
	j = i0-1+jp;
	for (d = 0; d < dmin[v] && d <= jp; d++)
	  alpha[v][j][d] = IMPOSSIBLE;
	for (d = dmax[v]+1; d <= jp;     d++)
	  alpha[v][j][d] = IMPOSSIBLE;
	  }

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d]  = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }
		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == B_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		z = cm->cnum[v];
		/* Careful, in qdb, we only want to look at alpha cells that are
		 * within the bands for all states involved (v, y and z) */
		/* k is the length of the right fragment */
		if(dmin[z] > (d-dmax[y])) k = dmin[z];
		else k = d-dmax[y];
		if(k < 0) k = 0;

		if(dmax[z] < (d-dmin[y])) kmax = dmax[z];
		else kmax = d-dmin[y];

		if(k <= kmax)
		  {
		    alpha[v][j][d] = alpha[y][j-k][d-k] + alpha[z][j][k];
		    if (ret_shadow != NULL) kshad[j][d] = k;
		    for (k=k+1; k <= kmax; k++)
		      {
			if ((sc = alpha[y][j-k][d-k] + alpha[z][j][k]) > alpha[v][j][d]) {
			  alpha[v][j][d] = sc;
			  if (ret_shadow != NULL) kshad[j][d] = k;
			}
		      }
		  }
		else alpha[v][j][d] = IMPOSSIBLE;
		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == MP_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    if (jp > 0) alpha[v][j][1] = IMPOSSIBLE;
	    /* dmin[v] must be >= 2 */
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j-1][d-2] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }

		i = j-d+1;
		if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
		else
		  alpha[v][j][d] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == ML_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    /* dmin[v] must be >= 1 */
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) >  alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }

		i = j-d+1;
		if (dsq[i] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][dsq[i]];
		else
		  alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    alpha[v][j][0] = IMPOSSIBLE;
	    /* dmin[v] must be >= 1 */
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][d] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d]) {
		    alpha[v][j][d] = sc;
		    if (ret_shadow != NULL) yshad[j][d] = yoffset;
		  }
		if (dsq[j] < cm->abc->K)
		  alpha[v][j][d] += cm->esc[v][dsq[j]];
		else
		  alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);

		if (alpha[v][j][d] < IMPOSSIBLE) alpha[v][j][d] = IMPOSSIBLE;
	      }
	  }
	}				/* finished calculating deck v. */

	  /* Check for local begin getting us to the root.
	   * This is "off-shadow": if/when we trace back, we'll handle this
	   * case separately (and we'll know to do it because we'll immediately
	   * see a USED_LOCAL_BEGIN flag in the shadow matrix, telling us
	   * to jump right to state b; see below)
	   */
	  if (allow_begin && alpha[v][j0][W] + cm->beginsc[v] > bsc)
	{
	  b   = v;
	  bsc = alpha[v][j0][W] + cm->beginsc[v];
	}

	  /* Check for whether we need to store an optimal local begin score
	   * as the optimal overall score, and if we need to put a flag
	   * in the shadow matrix telling insideT() to use the b we return.
	   */
	  if (allow_begin && v == 0 && bsc > alpha[0][j0][W]) {
	alpha[0][j0][W] = bsc;
	if (ret_shadow != NULL) yshad[j0][W] = USED_LOCAL_BEGIN;
	  }

	  /* Now, if we're trying to reuse memory in our normal mode (e.g. ! do_full):
	   * Look at our children; if they're fully released, take their deck
	   * into the pool for reuse.
	   */
	  if (! do_full) {
	if (cm->sttype[v] == B_st)
	  { /* we can definitely release the S children of a bifurc. */
	    y = cm->cfirst[v]; deckpool_push(dpool, alpha[y]); alpha[y] = NULL;
	    z = cm->cnum[v];   deckpool_push(dpool, alpha[z]); alpha[z] = NULL;
	  }
	else
	  {
	    for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	      {
		touch[y]--;
		if (touch[y] == 0)
		  {
		    if (cm->sttype[y] == E_st) {
		      nends--;
		      if (nends == 0) { deckpool_push(dpool, end); end = NULL;}
		    } else
		      deckpool_push(dpool, alpha[y]);
		    alpha[y] = NULL;
		  }
	      }
	  }
	  }
  } /* end loop over all v */

  /* Now we free our memory.
   * if we've got do_full set, all decks vroot..vend are now valid (end is shared).
   * else, only vroot deck is valid now and all others vroot+1..vend are NULL,
   * and end is NULL.
   * We could check this status to be sure (and we used to) but now we trust.
   */
  sc       = alpha[vroot][j0][W];
  if (ret_b != NULL)   *ret_b   = b;    /* b is -1 if allow_begin is FALSE. */
  if (ret_bsc != NULL) *ret_bsc = bsc;  /* bsc is IMPOSSIBLE if allow_begin is FALSE */

  /* If the caller doesn't want the matrix, free it (saving the decks in the pool!)
   * Else, pass it back to him.
   */
  if (ret_alpha == NULL) {
	for (v = vroot; v <= vend; v++) /* be careful of our reuse of the end deck -- free it only once */
	  if (alpha[v] != NULL) {
	if (cm->sttype[v] != E_st) { deckpool_push(dpool, alpha[v]); alpha[v] = NULL; }
	else end = alpha[v];
	  }
	if (end != NULL) { deckpool_push(dpool, end); end = NULL; }
	free(alpha);
  } else *ret_alpha = alpha;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	while (deckpool_pop(dpool, &end)) free_vjd_deck(end, i0, j0);
	deckpool_free(dpool);
  } else {
	*ret_dpool = dpool;
  }

  free(touch);
  if (ret_shadow != NULL) *ret_shadow = shadow;
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/* Function: outside_b()
 *           EPN 05.19.05
 * *based on outside(), only difference is bands are used :
 *
 * Date:     SRE, Tue Aug  8 10:42:52 2000 [St. Louis]
 * Purpose:  (See outside())
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           vroot     - first state of linear model segment (S; MP|ML|MR|D)
 *           vend      - last state of linear model segment  (B; E; MP|ML|MR|D)
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           do_full   - if TRUE, we save all the decks in beta, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the lowermost deck (vend) is valid
 *                       at the end.
 *           beta      - if non-NULL, this is an existing matrix, with NULL
 *                       decks for vroot..vend, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_beta  - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated decks sized
 *                       for this subsequence i0..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..j0 subseq,
 *                       because of the size of the subseq decks.
 *           dmin      - minimum d bound for each state v; [0..v..M-1]
 *           dmax      - maximum d bound for each state v; [0..v..M-1]
 */
static void
outside_b(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0,
	  int do_full, float ***beta, float ****ret_beta,
	  struct deckpool_s *dpool, struct deckpool_s **ret_dpool, int *dmin, int *dmax)
{
  int      status;
  int      v,y;			/* indices for states */
  int      j,d,i;		/* indices in sequence dimensions */
  float    sc;			/* a temporary variable holding a score */
  int     *touch;               /* keeps track of how many lower decks still need this deck */
  float    escore;		/* an emission score, tmp variable */
  int      W;			/* subsequence length */
  int      jp;			/* j': relative position in the subsequence, 0..W */
  int      voffset;		/* index of v in t_v(y) transition scores */
  int      w1,w2;		/* bounds of split set */
  int      dv;                  /* StateDelta() for state v */

  /* Allocations and initializations
   */
  W = j0-i0+1;		/* the length of the subsequence: used in many loops */

  			/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();

  /* if caller didn't give us a matrix, make one.
   * Allocate room for M+1 decks because we might need the EL deck (M)
   * if we're doing local alignment.
   */
  if (beta == NULL) {
	ESL_ALLOC(beta, sizeof(float **) * (cm->M+1));
	for (v = 0; v < cm->M+1; v++) beta[v] = NULL;
  }

  /* Initialize the root deck.
   * If the root is in a split set, initialize the whole split set.
   */
  w1 = cm->nodemap[cm->ndidx[vroot]]; /* first state in split set */
  if (cm->sttype[vroot] == B_st) {    /* special boundary case of Outside on a single B state. */
	w2 = w1;
	if (vend != vroot) cm_Fail("oh no. not again.");
  } else
	w2 = cm->cfirst[w1]-1;	      /* last state in split set w1<=vroot<=w2 */

  for (v = w1; v <= w2; v++) {
	if (! deckpool_pop(dpool, &(beta[v])))
	  beta[v] = alloc_vjd_deck(L, i0, j0);
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	beta[v][j][d] = IMPOSSIBLE;
	}
  }
  beta[vroot][j0][W] = 0;

  /* Initialize the EL deck at M, if we're doing local alignment w.r.t. ends.
   */
  if (cm->flags & CMH_LOCAL_END) {
	if (! deckpool_pop(dpool, &(beta[cm->M])))
	  beta[cm->M] = alloc_vjd_deck(L, i0, j0);
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  for (d = 0; d <= jp; d++)
	beta[cm->M][j][d] = IMPOSSIBLE;
	}

	/* We have to worry about vroot -> EL transitions.
	 * since we start the main recursion at w2+1. This requires a
	 * laborious partial unroll of the main recursion, grabbing
	 * the stuff relevant to a beta[EL] calculation for just the
	 * vroot->EL transition.
	 */
	if (NOT_IMPOSSIBLE(cm->endsc[vroot])) {
	  switch (cm->sttype[vroot]) {
	  case MP_st:
	if (W < 2) break;
	if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
	else
	  escore = DegeneratePairScore(cm->abc, cm->esc[vroot], dsq[i0], dsq[j0]);
	beta[cm->M][j0-1][W-2] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-2)) + escore;
	if (beta[cm->M][j0-1][W-2] < IMPOSSIBLE) beta[cm->M][j0-1][W-2] = IMPOSSIBLE;
	break;
	  case ML_st:
	  case IL_st:
	if (W < 1) break;
	if (dsq[i0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) dsq[i0]];
	else
	  escore = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[vroot]);
	beta[cm->M][j0][W-1] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-1)) + escore;
	if (beta[cm->M][j0][W-1] < IMPOSSIBLE) beta[cm->M][j0][W-1] = IMPOSSIBLE;
	break;
	  case MR_st:
	  case IR_st:
	if (W < 1) break;
	if (dsq[j0] < cm->abc->K)
	  escore = cm->esc[vroot][(int) dsq[j0]];
	else
	  escore = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[vroot]);
	beta[cm->M][j0-1][W-1] = cm->endsc[vroot] +
	  (cm->el_selfsc * (W-1)) + escore;
	if (beta[cm->M][j0-1][W-1] < IMPOSSIBLE) beta[cm->M][j0-1][W-1] = IMPOSSIBLE;
	break;
	  case S_st:
	  case D_st:
	beta[cm->M][j0][W] = cm->endsc[vroot] +
	  (cm->el_selfsc * W);
	if (beta[cm->M][j0][W] < IMPOSSIBLE) beta[cm->M][j0][W] = IMPOSSIBLE;
	break;
	  case B_st:		/* can't start w/ bifurcation at vroot. */
	  default: cm_Fail("bogus parent state %d\n", cm->sttype[vroot]);
	  }
	}
  }

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;      v < w1; v++) touch[v] = 0; /* note: top of split set w1, not vroot */
  for (v = vend+1; v < cm->M; v++) touch[v] = 0;
  for (v = w1; v <= vend; v++) {
	if (cm->sttype[v] == B_st) touch[v] = 2; /* well, we'll never use this, but set it anyway. */
	else                       touch[v] = cm->cnum[v];
  }

  /* Main loop down through the decks
   */
  for (v = w2+1; v <= vend; v++)
	{
	  /* First we need to fetch a deck of memory to fill in;
	   * we try to reuse a deck but if one's not available we allocate
	   * a fresh one.
	   */
	  if (! deckpool_pop(dpool, &(beta[v])))
	beta[v] = alloc_vjd_deck(L, i0, j0);

	  /* Init the whole deck to IMPOSSIBLE
	   */
	  for (jp = W; jp >= 0; jp--) {
	j = i0-1+jp;
	for (d = jp; d >= 0; d--)
	  beta[v][j][d] = IMPOSSIBLE;
	  }

	  /* If we can do a local begin into v, also init with that.
	   * By definition, beta[0][j0][W] == 0.
	   */
	  if ((vroot == 0 && i0 == 1 && j0 == L && (cm->flags & CMH_LOCAL_BEGIN))
	  && (dmin[v] <= W && dmax[v] >= W))
	  beta[v][j0][W] = cm->beginsc[v];

	  /* main recursion:
	   */
	  for (jp = W; jp >= 0; jp--) {
	j = i0-1+jp;
	if((dmax[v]) > jp) d = jp;
	else d = (dmax[v]);
	for (; d >= (dmin[v]); d--)
	  {
	    i = j-d+1;
	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      if (y < vroot) continue; /* deal with split sets */
	      voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	      switch(cm->sttype[y]) {
	      case MP_st:
		if (j == j0 || d == jp) continue; /* boundary condition */

		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);

		if ((sc = beta[y][j+1][d+2] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case ML_st:
	      case IL_st:
		if (d == jp) continue;	/* boundary condition (note when j=0, d=0*/

		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);

		if ((sc = beta[y][j][d+1] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case MR_st:
	      case IR_st:
		if (j == j0) continue;

		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);

		if ((sc = beta[y][j+1][d+1] + cm->tsc[y][voffset] + escore) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		if ((sc = beta[y][j][d] + cm->tsc[y][voffset]) > beta[v][j][d])
		  beta[v][j][d] = sc;
		break;

	      default: cm_Fail("bogus child state %d\n", cm->sttype[y]);
	      }/* end switch over states*/
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (beta[v][j][d] < IMPOSSIBLE) beta[v][j][d] = IMPOSSIBLE;

	  } /* ends loop over d. We know all beta[v][j][d] in this row j*/
	  }/* end loop over jp. We know the beta's for the whole deck.*/

	  /* Deal with local alignment end transitions v->EL
	   * (EL = deck at M.)
	   */
	  if (NOT_IMPOSSIBLE(cm->endsc[v])) {
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  /* Careful here, we're filling in beta[cm->M][j][d] which is unbanded
	   * by adding beta[v][j+{0,1}][d+dv] to endsc[v], and we know there's a
	   * band on v, so we can save time here as follows:
	   */
	  dv = StateDelta(cm->sttype[v]);
	  for (d = (dmin[v]-dv); d <= (dmax[v]-dv) && d <= jp; d++)
	    {
	      i = j-d+1;
	      switch (cm->sttype[v]) {
	      case MP_st:
		if (j == j0 || d == jp) continue; /* boundary condition */
		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
		if ((sc = beta[v][j+1][d+2] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case ML_st:
	      case IL_st:
		if (d == jp) continue;
		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
		if ((sc = beta[v][j][d+1] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case MR_st:
	      case IR_st:
		if (j == j0) continue;
		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
		if ((sc = beta[v][j+1][d+1] + cm->endsc[v] +
		     (cm->el_selfsc * d) + escore) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case S_st:
	      case D_st:
	      case E_st:
		if ((sc = beta[v][j][d] + cm->endsc[v] +
		     (cm->el_selfsc * d)) > beta[cm->M][j][d])
		  beta[cm->M][j][d] = sc;
		break;
	      case B_st:
	      default: cm_Fail("bogus parent state %d\n", cm->sttype[v]);
		/* note that although B is a valid vend for a segment we'd do
				   outside on, B->EL is set to be impossible, by the local alignment
				   config. There's no point in having a B->EL because B is a nonemitter
				   (indeed, it would introduce an alignment ambiguity). The same
		   alignment case is handled by the X->EL transition where X is the
		   parent consensus state (S, MP, ML, or MR) above the B. Thus,
		   this code is relying on the NOT_IMPOSSIBLE() test, above,
		   to make sure the sttype[vend]=B case gets into this switch.
		*/
	      } /* end switch over parent state type v */
	    } /* end inner loop over d */
	} /* end outer loop over jp */
	  } /* end conditional section for dealing w/ v->EL local end transitions */

	/* Look at v's parents; if we're reusing memory (! do_full)
	 * push the parents that we don't need any more into the pool.
	 */
	if (! do_full) {
	for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	  touch[y]--;
	  if (touch[y] == 0) { deckpool_push(dpool, beta[y]); beta[y] = NULL; }
	}
	  }
	} /* end loop over decks v. */

#if 0
  /* SRE: this code is superfluous, yes??? */
  /* Deal with last step needed for local alignment
   * w.r.t. ends: left-emitting, zero-scoring EL->EL transitions.
   * (EL = deck at M.)
   */
  if (cm->flags & CMH_LOCAL_END) {
	for (jp = W; jp > 0; jp--) { /* careful w/ boundary here */
	  j = i0-1+jp;
	  /* There is no band on the EL state */
	  for (d = jp-1; d >= 0; d--)
	if ((sc = beta[cm->M][j][d+1]) > beta[cm->M][j][d])
	  beta[cm->M][j][d] = sc;
	}
  }
#endif

  /* If the caller doesn't want the matrix, free it.
   * (though it would be *stupid* for the caller not to want the
   * matrix in the current implementation...)
   */
  if (ret_beta == NULL) {
	for (v = w1; v <= vend; v++) /* start at w1 - top of split set - not vroot */
	  if (beta[v] != NULL) { deckpool_push(dpool, beta[v]); beta[v] = NULL; }
	if (cm->flags & CMH_LOCAL_END) {
	  deckpool_push(dpool, beta[cm->M]);
	  beta[cm->M] = NULL;
	}
	free(beta);
  } else *ret_beta = beta;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	float **a;
	while (deckpool_pop(dpool, &a)) free_vjd_deck(a, i0, j0);
	deckpool_free(dpool);
  } else {
	*ret_dpool = dpool;
  }
  free(touch);
  return;
 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function: vinside_b()
 *           EPN 05.19.05
 * *based on vinside(), only difference is bands are used :
 *
 * Date:     SRE, Sat Jun  2 09:24:51 2001 [Kaldi's]
 *
 * Purpose:  Run the inside phase of the CYK alignment algorithm for
 *           a V problem: an unbifurcated CM subgraph from
 *           r..z, aligned to a one-hole subsequence
 *           i0..i1 // j1..j0, exclusive of z,i1,j1.
 *
 *           This is done in the vji coord system, where
 *           both our j and i coordinates are transformed.
 *           The Platonic matrix runs [j1..j0][i0..i1].
 *           The actual matrix runs [0..j0-j1][0..i1-i0].
 *           To transform a sequence coord i to a transformed
 *           coord i', subtract i0; to transform i' to i,
 *           add i0.
 *
 *           The conventions for alpha and dpool are the
 *           same as cyk_inside_engine().
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           r         - first start state of subtree (0, for whole model)
 *           z         - last end state of subtree (cm->M-1, for whole model)
 *           i0,i1     - first subseq part of the V problem
 *           j1,j0     - second subseq part
 *           useEL     - if TRUE, V problem ends at EL/i1/j1, not z/i1/j1
 *           do_full   - if TRUE, we save all the decks in alpha, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the uppermost deck (r) is valid
 *                       at the end.
 *           a         - if non-NULL, this is an existing matrix, with NULL
 *                       decks for r..z, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_a     - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated vji decks sized
 *                       for this subsequence i0..i1//j0..j1.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..i1//j0..j1 subseq
 *                       because of the size of the subseq decks.
 *           ret_shadow- if non-NULL, the caller wants a shadow matrix, because
 *                       he intends to do a traceback.
 *           allow_begin- TRUE to allow 0->b local alignment begin transitions.
 *           ret_b     - best local begin state, or NULL if unwanted
 *           ret_bsc   - score for using ret_b, or NULL if unwanted
 *           dmin      - minimum d bound for each state v; [0..v..M-1]
 *           dmax      - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns:  score.
 */
static float
vinside_b(CM_t *cm, ESL_DSQ *dsq, int L,
	int r, int z, int i0, int i1, int j1, int j0, int useEL,
	int do_full, float ***a, float ****ret_a,
	struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
	char ****ret_shadow,
	int allow_begin, int *ret_b, float *ret_bsc, int *dmin, int *dmax)
{
  int     status;
  char  ***shadow;              /* the shadow matrix -- traceback ptrs -- memory is kept */
  int     v,i,j;
  int     w1,w2;		/* bounds of the split set */
  int     jp, ip;		/* j' and i' -- in the matrix coords */
  int    *touch;                /* keeps track of whether we can free a deck yet or not */
  int     y, yoffset;
  float   sc;			/* tmp variable holding a score */
  int      b;			/* best local begin state */
  float    bsc;			/* score for using the best local begin state */
  int     *imin;                /* minimum i bound for each state v; [0..w1-r]
								 * calculated using *dmin; offset from v, the
				 * band that corresponds to state v, is imin[v-r] */
  int     *imax;                /* maximum i bound for each state v; [0..w1-r]
								 * calculated using *dmax; offset from v, the
				 * band that corresponds to state v, is imax[v-r] */

  /*debugging block*/
  /*printf("***in vinside_b()****\n");
  printf("\tr  : %d\n", r);
  printf("\tz  : %d\n", z);
  printf("\ti0 : %d\n", i0);
  printf("\ti1 : %d\n", i1);
  printf("\tj1 : %d\n", j1);
  printf("\tj0 : %d\n", j0);
  */

  /* Allocations, initializations.
   * Remember to allocate for M+1 decks, in case we reuse this
   * memorry for a local alignment voutside() calculation.
   */
  b   = -1;
  bsc = IMPOSSIBLE;
  if (dpool == NULL) dpool = deckpool_create();
  if (a == NULL) {
	ESL_ALLOC(a, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) a[v] = NULL;
  }
				/* the whole split set w<=z<=y must be initialized */
  w1 = cm->nodemap[cm->ndidx[z]];
  w2 = cm->cfirst[w1]-1;

  /* Bands used ip 3 */
  /* Allocate imin and imax */

  imin = malloc(sizeof (int) * (w1-r+1));
  imax = malloc(sizeof (int) * (w1-r+1));

  for (v = w1; v <= w2; v++) {
	if (! deckpool_pop(dpool, &(a[v])))
	  a[v] = alloc_vji_deck(i0, i1, j1, j0);
	for (jp = 0; jp <= j0-j1; jp++)
	  for (ip = 0; ip <= i1-i0; ip++)
	a[v][jp][ip] = IMPOSSIBLE;
  }

  if (ret_shadow != NULL) {
	ESL_ALLOC(shadow, sizeof(char **) * cm->M);
	for (v = 0; v < cm->M; v++) shadow[v] = NULL;
  }

  /* Initialize the one non-IMPOSSIBLE cell as a boundary
   * condition.
   * If local alignment (useEL=1), we must connect z to EL;
   * we would init a[EL][0][i1-i0] = 0. But, we're not explicitly
   * keeping an EL deck, we're swallowing it into the recursion.
   * So, we unroll a chunk of the main recursion;
   * we have to laboriously figure out from the statetype z
   * and our position where and what our initialization is.
   * Else, for global alignments, we simply connect to z,0,i1-i0.
   */

  ip = i1-i0;
  jp = 0;

  if (! useEL)
	a[z][jp][ip] = 0.;
  else
	{
	  if (ret_shadow != NULL)
	shadow[z] = alloc_vji_shadow_deck(i0,i1,j1,j0);

	  switch (cm->sttype[z]) {
	  case D_st:
	  case S_st:
	/*a[z][jp][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
	if (ret_shadow != NULL) shadow[z][jp][ip] = USED_EL;
	break;
	  case MP_st:
	if (i0 == i1 || j1 == j0) break;
	/*a[z][jp+1][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp+1][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));

	if (dsq[i1-1] < cm->abc->K && dsq[j1+1] < cm->abc->K)
	  a[z][jp+1][ip-1] += cm->esc[z][(int) (dsq[i1-1]*cm->abc->K+dsq[j1+1])];
	else
	  a[z][jp+1][ip-1] += DegeneratePairScore(cm->abc, cm->esc[z], dsq[i1-1], dsq[j1+1]);
	if (ret_shadow != NULL) shadow[z][jp+1][ip-1] = USED_EL;
	if (a[z][jp+1][ip-1] < IMPOSSIBLE) a[z][jp+1][ip-1] = IMPOSSIBLE;
	break;
	  case ML_st:
	  case IL_st:
	if (i0==i1) break;
	/*a[z][jp][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));

	if (dsq[i1-1] < cm->abc->K)
	  a[z][jp][ip-1] += cm->esc[z][(int) dsq[i1-1]];
	else
	  a[z][jp][ip-1] += esl_abc_FAvgScore(cm->abc, dsq[i1-1], cm->esc[z]);
	if (ret_shadow != NULL) shadow[z][jp][ip-1] = USED_EL;
	if (a[z][jp][ip-1] < IMPOSSIBLE) a[z][jp][ip-1] = IMPOSSIBLE;
	break;
	  case MR_st:
	  case IR_st:
	if (j1==j0) break;
	/*a[z][jp+1][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - StateDelta(cm->sttype[z])));*/
	a[z][jp+1][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));

	if (dsq[j1+1] < cm->abc->K)
	  a[z][jp+1][ip] += cm->esc[z][(int) dsq[j1+1]];
	else
	  a[z][jp+1][ip] += esl_abc_FAvgScore(cm->abc, dsq[j1+1], cm->esc[z]);
	if (ret_shadow != NULL) shadow[z][jp+1][ip] = USED_EL;
	if (a[z][jp+1][ip] < IMPOSSIBLE) a[z][jp+1][ip] = IMPOSSIBLE;
	break;
	  }
	} /* done initializing the appropriate cell for useEL=TRUE */

  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;   v < r;  v++) touch[v] = 0;
  for (v = r;   v <= w2; v++) touch[v] = cm->pnum[v]; /* note w2 not z: to bottom of split set */
  for (v = w2+1; v < cm->M; v++) touch[v] = 0;

  /* A special case. If vinside() is called on empty sequences,
   * we might do a begin transition right into z.
   */

  /* EPN 05.19.05
	 We are setting alpha cells in the following block, we should make
	 sure they're within the bands */

  if (allow_begin && j0-j1 == 0 && i1-i0 == 0)
	{
	  b   = z;
	  bsc = a[z][0][0] + cm->beginsc[z];
	  if (z == 0) {
	a[0][0][0] = bsc;
	if (ret_shadow != NULL) shadow[0][0][0] = USED_LOCAL_BEGIN;
	  }
	}

  /* Main recursion
   */
  for (v = w1-1; v >= r; v--)
	{
	  /* Get a deck and a shadow deck.
	   */
	  if (! deckpool_pop(dpool, &(a[v])))
	a[v] = alloc_vji_deck(i0,i1,j1,j0);
	  if (ret_shadow != NULL)
	shadow[v] = alloc_vji_shadow_deck(i0,i1,j1,j0);

	  /* Bands used ip 8 */
	  /* First fill imin[v] and imax[v] */

	  /* debugging block */
	  /*
	  if((dmin[v] > (j0-i0+1)) || (dmax[v] < (j1-i1+1)))
	{
	  printf("ERROR vinside_b() whole deck is outside bands\n");
	  printf("v : %d\n", v);
	  printf("dmin[v] : %d\n", dmin[v]);
	  printf("dmax[v] : %d\n", dmax[v]);
	  printf("i0 : %d\n", i0);
	  printf("i1 : %d\n", i1);
	  printf("j1 : %d\n", j1);
	  printf("j0 : %d\n", j0);
	}
	  */

	  imin[v-r] = j1-i0-dmax[v]+1;
	  imax[v-r] = j1-i0-dmin[v]+1;

	  /* Bands used ip 8 continued */
	  /* Impose bands by setting all cells outside the bands to IMPOSSIBLE
	   * This is independent of state type so we do it outside
	   * the following set of if then statements.
	   * Alternatively, it could be done within each of the following
	   * if(cm->sttype[v] == *) statements - matter of style I suppose.
	   */

	  for (jp = 0; jp <= j0-j1; jp++) {
	for (ip = 0; ip < (imin[v-r]+jp) && ip<=(i1-i0); ip++)
	  {
	    a[v][jp][ip] = IMPOSSIBLE;
	  }
	if((imax[v-r]+jp) > (i1-i0)) ip = (i1-i0+1);
	else ip = imax[v-r]+jp+1;
	if(ip < 0) ip = 0;
	for (; ip <= (i1-i0); ip++)
	  {
	    a[v][jp][ip] = IMPOSSIBLE;
	  }
	  }
	  /* reassert our definition of a V problem */
	  if (cm->sttype[v] == E_st || cm->sttype[v] == B_st || (cm->sttype[v] == S_st && v > r))
	cm_Fail("you told me you wouldn't ever do that again.");

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	{
	  for (jp = 0; jp <= j0-j1; jp++)
	    {
	      /* Bands used ip 9 */
	      /* old line :  for (ip = i1-i0; ip >= 0; ip--) { */
	      /* Use the imin[v-r] and imax[v-r] we have already set (see Bands used ip 3B) */
	      /* Remember 'state' indices in imin and imax are offset from v because imin and
		 imax run [0..z-r], ==> dmin[v] corresponds to imin[v-r] */
	      if((imax[v-r]+jp) > (i1-i0)) ip = (i1-i0);
	      else ip = imax[v-r] + jp;
	      for(; ip >= imin[v-r]+jp && ip >= 0; ip--) {
		y = cm->cfirst[v];
		a[v][jp][ip]      = a[y][jp][ip] + cm->tsc[v][0];
		if (ret_shadow != NULL) shadow[v][jp][ip] = (char) 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		   > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		  if ((sc = a[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		    {
		      a[v][jp][ip] = sc;
		      if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		    }
		if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	      }
	    }
	} else if (cm->sttype[v] == MP_st) {

	  /* EPN following line redundant? are these cells already IMPOSSIBLE
	     due to band imposition */

	  for (ip = i1-i0; ip >= 0; ip--) a[v][0][ip] = IMPOSSIBLE; /* boundary condition */

	  for (jp = 1; jp <= j0-j1; jp++) {
	    j = jp+j1;
	    a[v][jp][i1-i0] = IMPOSSIBLE; /* boundary condition */
	    /* Bands used ip 10 */
	    /* old line :  for (ip = i1-i0-1; ip >= 0; ip--) { */
	    /* Use the imin[v-w1] and imax[v-w1] we have already set (see Bands used ip 3B) */
	    /* Remember 'state' indices in imin and imax are offset from v because imin and
	       imax run [0..z-r], ==> dmin[v] corresponds to imin[v-r] */
	    if((imax[v-r]+jp) > (i1-i0-1)) ip = (i1-i0-1);
	    else ip = imax[v-r] + jp;
	    for(; ip >= imin[v-r]+jp && ip >= 0; ip--) {
	      i = ip+i0;
	      y = cm->cfirst[v];
	      a[v][jp][ip] = a[y][jp-1][ip+1] + cm->tsc[v][0];
	      if (ret_shadow != NULL) shadow[v][jp][ip] = (char) 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp-1][ip+1] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }
	      if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
	      else
		a[v][jp][ip] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {

	  for (jp = 0; jp <= j0-j1; jp++) {
	    a[v][jp][i1-i0] = IMPOSSIBLE; /* boundary condition */
	    /* Bands used ip 11 */
	    /* old line :  for (ip = i1-i0-1; ip >= 0; ip--) { */
	    /* Use the imin[v-w1] and imax[v-w1] we have already set (see Bands used ip 3B) */
	    /* Remember 'state' indices in imin and imax are offset from v because imin and
	       imax run [0..z-r], ==> dmin[v] corresponds to imin[v-r] */
	    if((imax[v-r]+jp) > (i1-i0-1)) ip = (i1-i0-1);
	    else ip = imax[v-r] + jp;
	    for(; ip >= imin[v-r]+jp && ip >= 0; ip--) {
	      i = ip+i0;
	      y = cm->cfirst[v];
	      a[v][jp][ip] = a[y][jp][ip+1] + cm->tsc[v][0];
	      if (ret_shadow != NULL) shadow[v][jp][ip] = 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip]      = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		/*printf("set a[%d][%d][%d] to %f\n", v, jp, ip, sc);*/
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }

	      if (dsq[i] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][dsq[i]];
	      else
		a[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  /* EPN following line redundant? are these cells already IMPOSSIBLE
	     due to band imposition */
	  for (ip = i1-i0; ip >= 0; ip--) a[v][0][ip] = IMPOSSIBLE; /* boundary condition */

	  for (jp = 1; jp <= j0-j1; jp++) {
	    j = jp+j1;
	    /* Bands used ip 12 */
	    /* old line :  for (ip = i1-i0; ip >= 0; ip--) { */
	    /* Use the imin[v-w1] and imax[v] we have already set (see Bands used ip 3B) */
	    /* Remember 'state' indices in imin and imax are offset from v because imin and
	       imax run [0..z-r], ==> dmin[v] corresponds to imin[v-r] */
	    /*05.20 for (ip = imax[v-r]; ip >= imin[v-r]; ip--) {		*/
	    if((imax[v-r]+jp) > (i1-i0)) ip = (i1-i0);
	    else ip = imax[v-r] + jp;
	    for(; ip >= imin[v-r]+jp && ip >= 0; ip--) {
	      y = cm->cfirst[v];
	      a[v][jp][ip]      = a[y][jp-1][ip] + cm->tsc[v][0];
	      if (ret_shadow != NULL) shadow[v][jp][ip] = 0;
	      if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) &&
		  ((cm->endsc[v] + (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v]))))
		  > a[v][jp][ip])) {
		a[v][jp][ip] = cm->endsc[v] +
		  (cm->el_selfsc * (((jp+j1)-(ip+i0)+1) - StateDelta(cm->sttype[v])));
		if (ret_shadow != NULL) shadow[v][jp][ip] = USED_EL;
	      }
	      for (yoffset = 1; yoffset < cm->cnum[v]; yoffset++)
		if ((sc = a[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) >  a[v][jp][ip])
		  {
		    a[v][jp][ip] = sc;
		    if (ret_shadow != NULL) shadow[v][jp][ip] = (char) yoffset;
		  }

	      if (dsq[j] < cm->abc->K)
		a[v][jp][ip] += cm->esc[v][dsq[j]];
	      else
		a[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
	      if (a[v][jp][ip] < IMPOSSIBLE) a[v][jp][ip] = IMPOSSIBLE;
	    }
	  }
	} /* finished calculating deck v */

	  /* Check for local begin getting us to the root.
	   */
	  if (allow_begin && a[v][j0-j1][0] + cm->beginsc[v] > bsc)
	{
	  b   = v;
	  bsc = a[v][j0-j1][0] + cm->beginsc[v];
	}

	  /* Check whether we need to store the local begin score
	   * for a possible traceback.
	   */
	  if (allow_begin && v == 0 && bsc > a[0][j0-j1][0])
	{
	  a[0][j0-j1][0] = bsc;
	  if (ret_shadow != NULL) shadow[v][j0-j1][0] = USED_LOCAL_BEGIN;
	}

	  /* Now, try to reuse memory under v.
	   */
	  if (! do_full) {
	for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	  {
	    touch[y]--;
	    if (touch[y] == 0) {
	      deckpool_push(dpool, a[y]);
	      a[y] = NULL;
	    }
	  }
	  }
	} /* end loop over v; we now have a complete matrix */

  /* Keep the score.
   */
  sc = a[r][j0-j1][0];
  if (ret_b != NULL)   *ret_b   = b;    /* b is -1 if allow_begin is FALSE. */
  if (ret_bsc != NULL) *ret_bsc = bsc;  /* bsc is IMPOSSIBLE if allow_begin is FALSE */

  /* If the caller doesn't want the score matrix back, blow
   * it away (saving decks in the pool). Else, pass it back.
   */
  if (ret_a == NULL) {
	for (v = r; v <= w2; v++)	/* note: go all the way to the bottom of the split set */
	  if (a[v] != NULL) {
	deckpool_push(dpool, a[v]);
	a[v] = NULL;
	  }
	free(a);
  } else *ret_a = a;

  /* If caller doesn't want the deck pool, blow it away.
   * Else, pass it back.
   */
  if (ret_dpool == NULL) {
	float **foo;
	while (deckpool_pop(dpool, &foo))
	  free_vji_deck(foo, j1,j0);
	deckpool_free(dpool);
  } else *ret_dpool = dpool;

  free(touch);
  free(imax);
  free(imin);
  if (ret_shadow != NULL) *ret_shadow = shadow;
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/* Function: voutside_b()
 *           EPN 05.19.05
 * *based on voutside(), only difference is bands are used :
 *
 * Date:     SRE, Sun Jun  3 15:44:41 2001 [St. Louis]
 *
 * Purpose:  Run the outside version of a CYK alignment algorithm for
 *           a V problem: an unbifurcated CM subgraph from r..z, aligned
 *           to a one-whole subsequence i0..i1//j1..j0, exclusive of
 *           z, i1, j1.
 *
 *           This is done in the vji coordinate system, where both
 *           our j and i coordinates are transformed. The Platonic
 *           ideal matrix runs [j1..j0][i0..i1]. The implemented
 *           matrix runs [0..j0-j1][0..i1-i0].
 *
 *           Much of the behavior in calling conventions, etc., is
 *           analogous to inside() and vinside(); see their prefaces
 *           for more info. Unlike the inside engines, we never
 *           need to calculate a shadow matrix - outside engines are
 *           only used for divide and conquer steps.
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           r         - first state of linear model segment (S; MP, ML, MR, or D)
 *           z         - last state of linear model segment (B; MP, ML, MR, or D)
 *           i0,i1     - subsequence before the hole  (1..L)
 *           j1,j0     - subsequence after the hole (1..L)
 *           useEL     - if TRUE, worry about local alignment.
 *           do_full   - if TRUE, we save all the decks in beta, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the lowermost decks (inc. z) are valid
 *                       at the end.
 *           beta      - if non-NULL, this is an existing matrix, with NULL
 *                       decks for r..z, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_beta  - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated vji decks sized
 *                       for this subsequence i0..i1//j1..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..i1//j1..j0 subseq,
 *                       because of the size of the subseq decks.
 *           dmin      - minimum d bound for each state v; [0..v..M-1]
 *           dmax      - maximum d bound for each state v; [0..v..M-1]
 *
 */
static void
voutside_b(CM_t *cm, ESL_DSQ *dsq, int L,
	   int r, int z, int i0, int i1, int j1, int j0, int useEL,
	   int do_full, float ***beta, float ****ret_beta,
	   struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
	   int *dmin, int *dmax)
{
  int      status;
  int      v,y;			/* indices for states */
  int      i,j;			/* indices in sequence dimensions */
  int      ip, jp;		/* transformed sequence indices */
  float    sc;			/* a temporary variable holding a score */
  int     *touch;               /* keeps track of how many lower decks still need this deck */
  float    escore;		/* an emission score, tmp variable */
  int      voffset;		/* index of v in t_v(y) transition scores */
  int     *imin;                /* minimum i bound for each state v; [0..r-z]
								 * calculated using *dmin; offset from v, the
				 * band that corresponds to state v, is imin[v-r] */
  int     *imax;                /* maximum i bound for each state v; [0..r-z]
								 * calculated using *dmax; offset from v, the
				 * band that corresponds to state v, is imax[v-r] */
  int      dv;                  /* state delta */

  /* Allocations and initializations
   */
  			/* if caller didn't give us a deck pool, make one */
  if (dpool == NULL) dpool = deckpool_create();

  /* If caller didn't give us a matrix, make one.
   * Remember to allow for deck M, the EL deck, for local alignments.
   */
  if (beta == NULL) {
	ESL_ALLOC(beta, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) beta[v] = NULL;
  }
  /* Initialize the root deck. This probably isn't the most efficient way to do it.
   */
  if (! deckpool_pop(dpool, &(beta[r])))
	beta[r] = alloc_vji_deck(i0,i1,j1,j0);
  for (jp = 0; jp <= j0-j1; jp++) {
	for (ip = 0; ip <= i1-i0; ip++)
	  beta[r][jp][ip] = IMPOSSIBLE;
  }
  /* Bands used ip 15 */
  /* We want to make sure that imin[0] <= 0; but we don't have imin[0] */
  /* First calculate imin[0], then assert its less than 0, not sure
	 if this is necessary, imin[0] == 0 may be guaranteed, I'll use
	 the assert here to be safe*/
  /* Note imin[0] corresponds to state r */

  imin = malloc(sizeof (int) * (z-r+1));
  imax = malloc(sizeof (int) * (z-r+1));

  /* debugging block */
  /*
  if((dmin[r] > (j0-i0)) || (dmax[r] < (j1-i1)))
	{
	  printf("ERROR voutside_b()\n");
	  printf("v : %d\n", r);
	  printf("dmin[v] : %d\n", dmin[r]);
	  printf("dmax[v] : %d\n", dmax[r]);
	  printf("i0 : %d\n", i0);
	  printf("i1 : %d\n", i1);
	  printf("j1 : %d\n", j1);
	  printf("j0 : %d\n", j0);
	}
  */

  assert(dmin[r] <= (j0-i0)+1);
  assert(dmax[r] >= (j1-i1)+1);

  imin[0] = j1-i0-dmax[r]+1;
  imax[0] = j1-i0-dmin[r]+1;

  assert(imin[0] <= 0);

  beta[r][j0-j1][0] = 0;

  /* Initialize the EL deck, if we're in local mode w.r.t. ends.
   * Deal with the special initialization case of the root state r
   * immediately transitioning to EL, if we're supposed to use EL.
   */

  if (useEL && cm->flags & CMH_LOCAL_END) {
	if (! deckpool_pop(dpool, &(beta[cm->M])))
	  beta[cm->M] = alloc_vji_deck(i0,i1,j1,j0);
	for (jp = 0; jp <= j0-j1; jp++) {
	  for (ip = 0; ip <= i1-i0; ip++)
	beta[cm->M][jp][ip] = IMPOSSIBLE;
	}
  }
  if (useEL && NOT_IMPOSSIBLE(cm->endsc[r])) {
	switch(cm->sttype[r]) {
	case MP_st:
	  if (i0 == i1 || j1 == j0) break;
	  if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
	escore = cm->esc[r][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
	  else
	escore = DegeneratePairScore(cm->abc, cm->esc[r], dsq[i0], dsq[j0]);
	  beta[cm->M][j0-j1-1][1] = cm->endsc[r] +
	(cm->el_selfsc * ((j0-1)-(i0+1)+1)) + escore;
	  break;
	case ML_st:
	case IL_st:
	  if (i0 == i1) break;
	  if (dsq[i0] < cm->abc->K)
	escore = cm->esc[r][(int) dsq[i0]];
	  else
	escore = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[r]);
	  beta[cm->M][j0-j1][1] = cm->endsc[r] +
	(cm->el_selfsc * ((j0)-(i0+1)+1)) + escore;
	  break;
	case MR_st:
	case IR_st:
	  if (j0==j1) break;
	  if (dsq[j0] < cm->abc->K)
	escore = cm->esc[r][(int) dsq[j0]];
	  else
	escore = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[r]);
	  beta[cm->M][j0-j1-1][0] = cm->endsc[r] +
	(cm->el_selfsc * ((j0-1)-(i0)+1)) + escore;
	  break;
	case S_st:
	case D_st:
	  beta[cm->M][j0-j1][0] = cm->endsc[r] +
	(cm->el_selfsc * ((j0)-(i0)+1));
	  break;
	default:  cm_Fail("bogus parent state %d\n", cm->sttype[r]);
	}
  }

  /* Initialize the "touch" array, used for figuring out
   * when a deck is no longer touched, so it can be free'd.
   */
  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0;   v < r;     v++) touch[v] = 0;
  for (v = z+1; v < cm->M; v++) touch[v] = 0;
  for (v = r;   v <= z;    v++) {
	if (cm->sttype[v] == B_st) touch[v] = 2; /* well, we never use this, but be complete */
	else                       touch[v] = cm->cnum[v];
  }

  /* Main loop down through the decks
   */
  for (v = r+1; v <= z; v++)
	{
	  /* Bands used ip 16 */
	  /* Fill imin[v-r+1] and imax[v-r+1] as we go, one of many ways to handle imin and imax */
	  /* Remember 'state' indices in imin and imax are offset from v because imin and
	 imax run [0..z-r+1], ==> dmin[v] corresponds to imin[v-r] */

	  imin[v-r] = j1-i0-dmax[v]+1;
	  imax[v-r] = j1-i0-dmin[v]+1;

	  /* An awkward situation here.  If dmin[v] > i1, imin[v-r] will be 0
	 however, we don't want to query ANY cells (in other words
	 none of the following for(ip*) loops should ever be entered)
	 because in this case the whole vji deck is outside the bands, so
	 the bestsc we want is IMPOSSIBLE (which was set before the
	 for (v = w; v <= y; v++) loop).  There is probably a better
		 way to do this but I'll explicitly check for this situation.
		 Note - it's okay if dmax < i0 (which also means the entire
		 deck is outside the bands) because this will make the
		 for(ip*) loops always evaluate to false because imin[v-r] will
		 be 0 and imax[v-r] will be < 0.*/
	  /* This situation is recapitulated in v_splitter_b() */

	  /* unnecssary 05.22
	 05.20 code : if(dmin[v] > i1) imin[v-r] = imax[v-r]+1;  */
	 /* now the for(ip) loops
						    will never be entered
						    (see above comments) */

	  /* First we need to fetch a deck of memory to fill in;
	   * we try to reuse a deck but if one's not available we allocate
	   * a fresh one.
	   */
	  if (! deckpool_pop(dpool, &(beta[v])))
	beta[v] = alloc_vji_deck(i0,i1,j1,j0);

	  /* Init the whole deck to IMPOSSIBLE.
	   */
	  for (jp = j0-j1; jp >= 0; jp--)
	for (ip = 0; ip <= i1-i0; ip++)
	  beta[v][jp][ip] = IMPOSSIBLE;

	  /* We've set the whole matrix to impossible, everything outside bands must be impossible */

	  /* If we can get into deck v by a local begin transition, do an init
	   * with that.
	   */
	  if (r == 0 && i0 == 1 && j0 == L && (cm->flags & CMH_LOCAL_BEGIN))
	{
	  if (cm->beginsc[v] > beta[v][j0-j1][0])
	    beta[v][j0-j1][0] = cm->beginsc[v];
	}

	  /* main recursion:
	   */
	  for (jp = j0-j1; jp >= 0; jp--) {
	j = jp+j1;
	/* Bands used ip 17 */
	/* old line :	for (ip = 0; ip <= i1-i0; ip++) */
	/* Remember 'state' indices in imin and imax are offset from v because imin and
	   imax run [0..z-r+1], ==> dmin[v] corresponds to imin[v-r] */
	/* 05.20 for (ip = imin[v-r]; ip <= imax[v-r]; ip++) */

	if((imin[v-r]+jp) < 0) ip = 0;
		else ip = imin[v-r]+jp;
		for(; ip <= imax[v-r] + jp && ip <= (i1-i0); ip++)
	  {
	    i = ip+i0;

	    for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	      if (y < r) continue; /* deal with split sets */
	      voffset = v - cm->cfirst[y]; /* gotta calculate the transition score index for t_y(v) */

	      switch(cm->sttype[y]) {
	      case MP_st:
		if (j == j0 || i == i0) continue; /* boundary condition */

		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);

		if ((sc = beta[y][jp+1][ip-1]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case ML_st:
	      case IL_st:
		if (i == i0) continue;	/* boundary condition */

		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);

		if ((sc = beta[y][jp][ip-1]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case MR_st:
	      case IR_st:
		if (j == j0) continue;

		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[y][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);

		if ((sc = beta[y][jp+1][ip]+cm->tsc[y][voffset]+escore) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      case S_st:
	      case E_st:
	      case D_st:
		if ((sc = beta[y][jp][ip] + cm->tsc[y][voffset]) > beta[v][jp][ip])
		  beta[v][jp][ip] = sc;
		break;

	      default: cm_Fail("bogus parent state %d\n", cm->sttype[y]);
	      }/* end switch over states*/
	    } /* ends for loop over parent states. we now know beta[v][j][d] for this d */
	    if (beta[v][jp][ip] < IMPOSSIBLE) beta[v][jp][ip] = IMPOSSIBLE;

	  } /* ends loop over ip. We know all beta[v][jp][ip] in this row jp */

	  }/* end loop over jp. We know the beta's for the whole deck.*/

	  /* Deal with local alignment
	   * transitions v->EL, if we're doing local alignment and there's a
	   * possible transition.
	   */
	  if (useEL && NOT_IMPOSSIBLE(cm->endsc[v])) {
	for (jp = j0-j1; jp >= 0; jp--) {
	  j = jp+j1;
	  /* Careful here, we're filling in beta[cm->M][jp][ip] which is unbanded
	   * by adding beta[v][jp+{0,1}][ip-{0,1}] to endsc[v], and we know there's a
	   * i band on v (imin[v-r]..imax[v-r], so we can save time here as follows:
	   */
	  dv = StateDelta(cm->sttype[v]);
	  if((imin[v-r]+jp+dv) < 0) ip = 0;
	  else ip = imin[v-r]+jp+dv;
	  for(; (ip<=imax[v-r]+jp+dv) && ip <= (i1-i0); ip++)
	    {
	      i = ip+i0;
	      switch (cm->sttype[v]) {
	      case MP_st:
		if (j == j0 || i == i0) continue; /* boundary condition */
		if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
		else
		  escore = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
		if ((sc = beta[v][jp+1][ip-1] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1))
		     + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case ML_st:
	      case IL_st:
		if (i == i0) continue;
		if (dsq[i-1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[i-1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
		if ((sc = beta[v][jp][ip-1] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1))
		     + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case MR_st:
	      case IR_st:
		if (j == j0) continue;
		if (dsq[j+1] < cm->abc->K)
		  escore = cm->esc[v][(int) dsq[j+1]];
		else
		  escore = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
		if ((sc = beta[v][jp+1][ip] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1))
		     + escore) > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      case S_st:
	      case D_st:
	      case E_st:
		if ((sc = beta[v][jp][ip] + cm->endsc[v] +
		     (cm->el_selfsc * (j-i+1)))
		     > beta[cm->M][jp][ip])
		  beta[cm->M][jp][ip] = sc;
		break;
	      default:  cm_Fail("bogus parent state %d\n", cm->sttype[y]);
	      } /* end switch over parent v state type */
	    } /* end loop over ip */
	} /* end loop over jp */
	  }

	  /* Finished deck v.
	   * now look at its parents; if we're reusing memory (! do_full)
	   * push the parents that we don't need any more into the pool.
	   */
	  if (! do_full) {
	for (y = cm->plast[v]; y > cm->plast[v]-cm->pnum[v]; y--) {
	  touch[y]--;
	  if (touch[y] == 0) {
	    deckpool_push(dpool, beta[y]);
	    beta[y] = NULL;
	  }
	}
	  }

	} /* end loop over decks v. */

#if 0
  /* superfluous code, I think...*/
  /* Deal with the last step needed for local alignment
   * w.r.t. ends: left-emitting, zero-scoring EL->EL transitions.
   */
  if (useEL && cm->flags & CMH_LOCAL_END) {
	for (jp = j0-j1; jp >= 0; jp--)
	  {
	/* Bands used ip 19 */
	/* Actually the bands are not used here, because there are no bands for
	   state cm->M.  I'll just leave the unbanded code alone here.  Not sure
	   how to think about bands in terms of local alignment??? */
	for (ip = 1; ip <= i1-i0; ip++) /* careful w/boundary here */
	  if ((sc = beta[cm->M][jp][ip-1]) > beta[cm->M][jp][ip])
	    beta[cm->M][jp][ip] = sc;
	  }
  }
#endif

  /* If the caller doesn't want the matrix, free it.
   * (though it would be *stupid* for the caller not to want the
   * matrix in the current implementation!)
   */
  if (ret_beta == NULL) {
	for (v = r; v <= z; v++)
	  if (beta[v] != NULL) { deckpool_push(dpool, beta[v]); beta[v] = NULL; }
	if (cm->flags & CMH_LOCAL_END) {
	  deckpool_push(dpool, beta[cm->M]);
	  beta[cm->M] = NULL;
	}
	free(beta);
  } else *ret_beta = beta;

  /* If the caller doesn't want the deck pool, free it.
   * Else, pass it back to him.
   */
  if (ret_dpool == NULL) {
	float **a;
	while (deckpool_pop(dpool, &a))
	  free_vji_deck(a,j1,j0);
	deckpool_free(dpool);
  } else *ret_dpool = dpool;

  free(touch);
  free(imax);
  free(imin);
  return;
 ERROR:
  cm_Fail("Memory allocation error.");
}

/* For the Full CYK memory efficient banded implementation we need
 *  banded versions of some of the memory management routines
 *
 * The D&C banded implementation is not memory efficient, in that
 * it requires the same amount of memory as the non-banded D&C implementation.
 * This means that we still allocate the same memory as we would without bands,
 * we just set all cells of alpha or beta that are outside of the bands to
 * IMPOSSIBLE.  Because of this we should be able to use the same memory management
 * routines as the non-banded implementation.
 *
 * Therefore we can use the D&C memory routines for banded D&C.
 */

/*################################################################*/
/* EPN *_banded_vjd_*
   adapted from *_vjd_* from SRE*/

/* Functions: *_vjd_*
 * Date:     SRE, Sat Aug 12 16:27:37 2000 [Titusville]
 *
 * Purpose:  Allocation and freeing of 3D matrices and 2D decks
 *           in the vjd coord system. These can be called on
 *           subsequences i..j, not just the full sequence 1..L,
 *           so they need i,j... if you're doing the full sequence
 *           just pass 1,L.
 *
 *           Also deal with shadow matrices and shadow decks in the
 *           vjd coordinate system. Note that bifurcation shadow decks
 *           need more dynamic range than other shadow decks, hence
 *           a separation into "kshadow" (BIFURC) and "yshadow" (other
 *           states) decks, and some casting shenanigans in
 *           a full ***shadow matrix.
 *
 *           Values in yshad are offsets to the next connected state,
 *           or a flag for local alignment. Possible offsets range from
 *           0..5 (maximum of 6 connected states). The flags are
 *           USED_LOCAL_BEGIN (101) and USED_EL (102), defined at
 *           the top of this file. Only yshad[0][L][L] (e.g. root state 0,
 *           aligned to the whole sequence) may be set to USED_LOCAL_BEGIN.
 *           (Remember that the dynamic range of yshad, as a char, is
 *           0..127, in ANSI C; we don't know if a machine will make it
 *           signed or unsigned.)
 */
float **
alloc_banded_vjd_deck(int L, int i, int j, int min, int max)
{
  int     status;
  float **a;
  int     jp;
  int     bw; /* width of band, depends on jp, so we need to calculate
	         this inside the jp loop*/

  /*printf("in alloc banded vjd deck, L : %d, i : %d, j : %d, min : %d, max : %d\n", L, i, j, min, max);*/

  ESL_DPRINTF3(("alloc_vjd_deck : %.4f\n", size_vjd_deck(L,i,j)));
  ESL_ALLOC(a, sizeof(float *) * (L+1)); /* always alloc 0..L rows, some of which are NULL */
  for (jp = 0;   jp < i-1;    jp++) a[jp]     = NULL;
  for (jp = j+1; jp <= L;     jp++) a[jp]     = NULL;
  for (jp = 0; jp <= j-i+1; jp++)
	{
	  if(jp > max)
	bw = max - min + 1;
	  else
	bw = jp - (min) + 1;

	  if(bw > 0)
	{
	  /*printf("\tallocated a[%d]\n", jp+i-1);*/
	  ESL_ALLOC(a[jp+i-1], sizeof(float) * bw);
	}
	  else
	{
	  a[jp+i-1] = NULL;
	  /*printf("\tdid not allocate a[%d]\n", jp+i-1);*/
	}
	}
  return a;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

char **
alloc_banded_vjd_yshadow_deck(int L, int i, int j, int min, int max)
{
  int    status;
  char **a;
  int    jp;
  int    bw; /* width of band, depends on jp, so we need to calculate
	        this inside the jp loop*/

  ESL_ALLOC(a, sizeof(char *) * (L+1)); /* always alloc 0..L rows, same as alloc_deck */
  for (jp = 0;   jp < i-1;    jp++) a[jp] = NULL;
  for (jp = j+1; jp <= L;     jp++) a[jp] = NULL;
  for (jp = 0;   jp <= j-i+1; jp++)
	{
	  if(jp > max)
	bw = max - min + 1;
	  else
	bw = jp - min + 1;
	  if(bw > 0)
	{
	  ESL_ALLOC(a[jp+i-1], sizeof(char) * (bw));
	}
	  else a[jp+i-1] = NULL;
	}
  return a;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}
int **
alloc_banded_vjd_kshadow_deck(int L, int i, int j, int min, int max)
{
  int   status;
  int **a;
  int   jp;
  int     bw; /* width of band, depends on jp, so we need to calculate
	         this inside the jp loop*/

  ESL_ALLOC(a, sizeof(int *) * (L+1)); /* always alloc 0..L rows, same as alloc_deck */
  for (jp = 0;   jp <  i-1;   jp++) a[jp] = NULL;
  for (jp = j+1; jp <= L;     jp++) a[jp] = NULL;
  for (jp = 0;   jp <= j-i+1; jp++)
	{
	  if(jp > max) bw = max - min + 1;
	  else bw = jp - min + 1;
	  if(bw > 0)
	{
	  ESL_ALLOC(a[jp+i-1], sizeof(int) * bw);
	}
	  else a[jp+i-1] = NULL;
	}

  return a;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/******************************************************************/
/* The below functions were written during debugging, and print
   out either the shadow or alpha matrix.  They are kept
   here just in case they're needed again.  Note : the functions
   that print out the entire matrix are really only useful
   when the BE_PARANOID flag is set, meaning that decks are
   never freed until the end.
*/
/*================================================================*/
/* EPN 05.09.05
   debug_print_shadow()
 * Function: debug_print_shadow
 *
 * Purpose:  Print shadow matrix
 */

void
debug_print_shadow(void ***shadow, CM_t *cm, int L)
{
  int v, j, d;
  int yoffset;

  printf("\nPrinting alpha matrix :\n");
  printf("************************************\n");
  for(v = 0; v < cm->M; v++)
	{
	  printf("====================================\n");
	  for(j = 0; j <= L; j++)
	{
	  printf("------------------------------------\n");
	  for(d = 0; d <= j; d++)
	    {
	      if(cm->sttype[v] == E_st)
		{
		  printf("END state\n");
		}
	      else
		{
		  if(cm->sttype[v] == B_st)
		    {
		      yoffset = ((int **) shadow[v])[j][d];
		      printf("INT  shadow[%2d][%2d][%2d] : %d\n", v, j, d, yoffset);
		    }
		  else
		    {
		      yoffset = ((int **) shadow[v])[j][d];
		      printf("CHAR shadow[%2d][%2d][%2d] : %d\n", v, j, d, yoffset);
		    }
		}
	    }
	}
	}
  printf("****************\n\n");
}

/* EPN 05.16.05
   debug_print_shadow_banded()
 * Function: debug_print_shadow_banded
 *
 * Purpose:  Print banded shadow matrix
 */

void
debug_print_shadow_banded(void ***shadow, CM_t *cm, int L, int *dmin, int *dmax)
{
  int v, j, d, vdp;
  int yoffset;

  printf("\nPrinting banded shadow matrix :\n");
  printf("************************************\n");
  for(v = 0; v < cm->M; v++)
	{
	  printf("====================================\n");
	  for(j = 0; j <= L; j++)
	{
	  printf("------------------------------------\n");
	  /* there may be a problem with using j and not jp */
	  for (d = dmin[v]; d <= dmax[v] && d <= j; d++)
	    {
	      vdp = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */
	      if(cm->sttype[v] == E_st)
		{
		  printf("END state\n");
		}
	      else
		{
		  if(cm->sttype[v] == B_st)
		    {
		      yoffset = ((int **) shadow[v])[j][vdp];
		      printf("INT  shadow[%2d][%2d][%2d] : %d | d is %d\n", v, j, vdp, yoffset, d);
		    }
		  else
		    {
		      yoffset = ((int **) shadow[v])[j][vdp];
		      printf("CHAR shadow[%2d][%2d][%2d] : %d | d is %d\n", v, j, vdp, yoffset, d);
		    }
		}
	    }
	}
	}
  printf("****************\n\n");
}

/* EPN 05.16.05
   debug_print_shadow_banded_deck()
 * Function: debug_print_shadow_banded_deck
 *
 * Purpose:  Print banded shadow matrix deck
 */

void
debug_print_shadow_banded_deck(int v, void ***shadow, CM_t *cm, int L, int *dmin, int *dmax)
{
  int j, d, vdp;
  int yoffset;

  printf("\nPrinting banded shadow matrix deck for v : %d:\n", v);
  printf("====================================\n");
  for(j = 0; j <= L; j++)
	{
	  printf("------------------------------------\n");
	  /* there may be a problem with using j and not jp*/
	  for (d = dmin[v]; d <= dmax[v] && d <= j; d++)
	{
	  vdp = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */

	  if(cm->sttype[v] == E_st)
	    {
	      printf("END state\n");
	    }
	  else
	    {
	      yoffset = ((char **) shadow[v])[j][vdp];
	      printf("shadow_banded[%2d][%2d][%2d] : %d| d is %d\n", v, j, vdp, yoffset, d);
	    }
	}
	}
}

/* EPN 05.09.05
   debug_print_alpha_banded()
 * Function: debug_print_alpha_banded
 *
 * Purpose:  Print alpha matrix
 */
void
debug_print_alpha_banded(float ***alpha, CM_t *cm, int L, int *dmin, int *dmax)
{
  int v, j, d, vdp, max_v;

  printf("\nPrinting banded alpha matrix :\n");
  printf("************************************\n");
  max_v = cm->M-1;
  if(cm->flags & CMH_LOCAL_BEGIN)
	{
	  max_v = cm->M;
	}
  for(v = 0; v <= max_v; v++)
	{
	  printf("====================================\n");
	  for(j = 0; j <= L; j++)
	{
	  printf("------------------------------------\n");
	  for (d = dmin[v]; d <= dmax[v] && d <= j; d++)
	    {
	      vdp = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */
	      printf("alpha[%2d][%2d][%2d] : %6.2f | d is %d\n", v, j, vdp, alpha[v][j][vdp], d);
	    }
	}
	}
  printf("****************\n\n");
}

/* EPN 05.09.05
   debug_print_alpha()
 * Function: debug_print_alpha
 *
 * Purpose:  Print alpha matrix
 */

void
debug_print_alpha(float ***alpha, CM_t *cm, int L)
{
  int v, j, d, max_v;

  printf("\nPrinting alpha matrix :\n");
  printf("************************************\n");
  max_v = cm->M-1;
  if(cm->flags & CMH_LOCAL_BEGIN)
	{
	  max_v = cm->M;
	}
  for(v = 0; v <= max_v; v++)
	{
	  printf("====================================\n");
	  for(j = 0; j <= L; j++)
	{
	  printf("------------------------------------\n");
	  for(d = 0; d <= j; d++)
	    {
	      printf("alpha[%2d][%2d][%2d] : %6.2f\n", v, j, d, alpha[v][j][d]);
	    }
	}
	}
  printf("****************\n\n");
}

/* EPN Memory efficient banded functions */
/* Function: inside_b_me()
 *
 * Based on inside(), only difference is bands are used :
 * further the bands are used in a memory-efficient way
 * Another big difference is that we can't employ the deck
 * reuse strategy because the size of each deck depends
 * on the band for that state, so each deck can be different.
 *
 * Comments below are from inside():
 *
 * Date:     SRE, Mon Aug  7 13:15:37 2000 [St. Louis]
 *
 * Purpose:  Run the inside phase of a CYK alignment algorithm, on a
 *           subsequence from i0..j0, using a subtree of a model
 *           anchored at a start state vroot, and ending at an end
 *           state vend. (It is a feature of the model layout in
 *           a CM structure that all subtrees are contiguous in the
 *           model.)
 *
 *           A note on the loop conventions. We're going to keep the
 *           sequence (dsq) and the matrix (alpha) in the full coordinate
 *           system: [0..v..M-1][0..j..L][0..d..j]. However, we're
 *           only calculating a part of that matrix: only vroot..vend
 *           in the decks, i0-1..j in the rows, and up to j0-i0+1 in
 *           the columns (d dimension). Where this is handled the most
 *           is in two variables: W, which is the length of the subsequence
 *           (j0-i0+1), and is oft used in place of L in the usual CYK;
 *           and jp (read: j'), which is the *relative* j w.r.t. the
 *           subsequence, ranging from 0..W, and then d ranges from
 *           0 to jp, and j is calculated from jp (i0-1+jp).
 *
 *           The caller is allowed to provide us with a preexisting
 *           matrix and/or deckpool (thru "alpha" and "dpool"), or
 *           have them newly created by passing NULL. If we pass in an
 *           alpha, we expect that alpha[vroot..vend] are all NULL
 *           decks already; any other decks <vroot and >vend will
 *           be preserved. If we pass in a dpool, the decks *must* be
 *           sized for the same subsequence i0,j0.
 *
 *           Note that the (alpha, ret_alpha) calling idiom allows the
 *           caller to provide an existing matrix or not, and to
 *           retrieve the calculated matrix or not, in any combination.
 *
 *           We also deal with local begins, by keeping track of the optimal
 *           state that we could enter and account for the whole target
 *           sequence: b = argmax_v  alpha_v(i0,j0) + log t_0(v),
 *           and bsc is the score for that.
 *
 *           If vroot==0, i0==1, and j0==L (e.g. a complete alignment),
 *           the optimal alignment might use a local begin transition, 0->b,
 *           and we'd have to be able to trace that back. For any
 *           problem where the caller sets allow_begin, we return a valid b
 *           (the optimal 0->b choice) and bsc (the score if 0->b is used).
 *           If a local begin is part of the optimal parse tree, the optimal
 *           alignment score returned by inside() will be bsc and yshad[0][L][L]
 *           will be USE_LOCAL_BEGIN, telling insideT() to check b and
 *           start with a local 0->b entry transition. When inside()
 *           is called on smaller subproblems (v != 0 || i0 > 1 || j0
 *           < L), we're using inside() as an engine in divide &
 *           conquer, and we don't use the overall return score nor
 *           shadow matrices, but we do need allow_begin, b, and bsc for
 *           divide&conquer to sort out where a local begin might be used.
 *
 * Args:     cm        - the model    [0..M-1]
 *           dsq       - the sequence [1..L]
 *           L         - length of the dsq
 *           vroot     - first start state of subtree (0, for whole model)
 *           vend      - last end state of subtree (cm->M-1, for whole model)
 *           i0        - first position in subseq to align (1, for whole seq)
 *           j0        - last position in subseq to align (L, for whole seq)
 *           do_full   - if TRUE, we save all the decks in alpha, instead of
 *                       working in our default memory-efficient mode where
 *                       we reuse decks and only the uppermost deck (vroot) is valid
 *                       at the end.
 *           alpha     - if non-NULL, this is an existing matrix, with NULL
 *                       decks for vroot..vend, and we'll fill in those decks
 *                       appropriately instead of creating a new matrix
 *           ret_alpha - if non-NULL, return the matrix with one or more
 *                       decks available for examination (see "do_full")
 *           dpool     - if non-NULL, this is an existing deck pool, possibly empty,
 *                       but usually containing one or more allocated decks sized
 *                       for this subsequence i0..j0.
 *           ret_dpool - if non-NULL, return the deck pool for reuse -- these will
 *                       *only* be valid on exactly the same i0..j0 subseq,
 *                       because of the size of the subseq decks.
 *           ret_shadow- if non-NULL, the caller wants a shadow matrix, because
 *                       he intends to do a traceback.
 *           allow_begin- TRUE to allow 0->b local alignment begin transitions.
 *           ret_b     - best local begin state, or NULL if unwanted
 *           ret_bsc   - score for using ret_b, or NULL if unwanted
 *           dmin      - minimum d bound for each state v; [0..v..M-1]
 *           dmax      - maximum d bound for each state v; [0..v..M-1]
 *
 * Returns: Score of the optimal alignment.
 */
static float
inside_b_me(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
	    float ***alpha, float ****ret_alpha,
	    void ****ret_shadow,
	    int allow_begin, int *ret_b, float *ret_bsc,
	    int *dmin, int *dmax)
{
  int      status;
  float  **end;         /* we re-use the end deck. */
  int      nends;       /* counter that tracks when we can release end deck to the pool */
  int     *touch;       /* keeps track of how many higher decks still need this deck */
  int      v,y,z;	/* indices for states  */
  int      j,d,i;	/* indices in sequence dimensions */
  float    sc;		/* a temporary variable holding a score */
  int      yoffset;	/* y=base+offset -- counter in child states that v can transit to */
  int      W;		/* subsequence length */
  int      jp;		/* j': relative position in the subsequence  */
  void  ***shadow;      /* shadow matrix for tracebacks */
  int    **kshad;       /* a shadow deck for bifurcations */
  char   **yshad;       /* a shadow deck for every other kind of state */
  int      b;		/* best local begin state */
  float    bsc;		/* score for using the best local begin state */

  /* variables used for memory efficient bands */
  int      dp_v;           /* d index for state v in alpha w/mem eff bands */
  int      dp_y;           /* d index for state y in alpha w/mem eff bands */
  int      dp_z;           /* d index for state z in alpha w/mem eff bands */
  int      kp;             /* k prime - keeps track of what k should be now
			     that we're using memory efficient bands */
  int      Wp;             /* W also changes depending on state */

  /* Allocations and initializations
   */
  b   = -1;
  bsc = IMPOSSIBLE;
  W   = j0-i0+1;		/* the length of the subsequence -- used in many loops  */
				/* if caller didn't give us a deck pool, make one */
  end = alloc_vjd_deck(L, i0, j0);
  nends = CMSubtreeCountStatetype(cm, vroot, E_st);
  for (jp = 0; jp <= W; jp++) {
	j = i0+jp-1;		/* e.g. j runs from 0..L on whole seq */
	end[j][0] = 0.;
	for (d = 1; d <= jp; d++) end[j][d] = IMPOSSIBLE;
  }

  /* if caller didn't give us a matrix, make one.
   * It's important to allocate for M+1 decks (deck M is for EL, local
   * alignment) - even though Inside doesn't need EL, Outside does,
   * and we might reuse this memory in a call to Outside.
   */
  if (alpha == NULL) {
	ESL_ALLOC(alpha, sizeof(float **) * (cm->M+1));
	for (v = 0; v <= cm->M; v++) alpha[v] = NULL;
  }

  ESL_ALLOC(touch, (sizeof(int) * cm->M));
  for (v = 0;     v < vroot; v++) touch[v] = 0;
  for (v = vroot; v <= vend; v++) touch[v] = cm->pnum[v];
  for (v = vend+1;v < cm->M; v++) touch[v] = 0;

  /* The shadow matrix, if caller wants a traceback.
   * We do some pointer tricks here to save memory. The shadow matrix
   * is a void ***. Decks may either be char ** (usually) or
   * int ** (for bifurcation decks). Watch out for the casts.
   * For most states we only need
   * to keep y as traceback info, and y <= 6. For bifurcations,
   * we need to keep k, and k <= L, and L might be fairly big.
   * (We could probably limit k to an unsigned short ... anyone
   * aligning an RNA > 65536 would need a big computer... but
   * we'll hold off on that for now. We could also pack more
   * traceback pointers into a smaller space since we only really
   * need 3 bits, not 8.)
   */
  if (ret_shadow != NULL) {
	ESL_ALLOC(shadow, sizeof(void **) * cm->M);
	for (v = 0; v < cm->M; v++) shadow[v] = NULL;
  }

  /* Main recursion
   */
  for (v = vend; v >= vroot; v--)
	{
	  /* First we need a deck to fill in.
	   * 1. if we're an E, reuse the end deck (and it's already calculated)
	   * 2. else, see if we can take something from the pool
	   * 3. else, allocate a new deck.
	   */
	  if (cm->sttype[v] == E_st) {
	alpha[v] = end; continue;
	  }
	  alpha[v] = alloc_banded_vjd_deck(L, i0, j0, dmin[v], dmax[v]);

	  if (ret_shadow != NULL) {
	if (cm->sttype[v] == B_st) {
	  kshad     = alloc_banded_vjd_kshadow_deck(L, i0, j0, dmin[v], dmax[v]);
	  shadow[v] = (void **) kshad;
	} else {
	  yshad     = alloc_banded_vjd_yshadow_deck(L, i0, j0, dmin[v], dmax[v]);
	  shadow[v] = (void **) yshad;
	}
	  }

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		dp_v = d - dmin[v];  /* d index for state v in alpha w/mem eff bands */

		alpha[v][j][dp_v] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][dp_v]  = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  {
		    dp_y = d - dmin[y+yoffset];  /* d index for state (y+yoffset)
						   in alpha w/mem eff bands */
		    /* check to make sure the cell we're about to query is within the
		       bands for state y; this might be more complex than necessary */
		    if((dp_y >= 0) && ((dp_y < (jp - (dmin[y+yoffset]) + 1))
				       && (dp_y < (dmax[y+yoffset] - dmin[y+yoffset] + 1))))
		      {
			if ((sc = alpha[y+yoffset][j][dp_y] + cm->tsc[v][yoffset]) >  alpha[v][j][dp_v]) {
			  alpha[v][j][dp_v] = sc;
			  if (ret_shadow != NULL) yshad[j][dp_v] = yoffset;
			}
		      }
		  }
		if (alpha[v][j][dp_v] < IMPOSSIBLE) alpha[v][j][dp_v] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == B_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		z = cm->cnum[v];

		/* The changes made to this section of code in the memory efficient
		 * banded implementation are the most complex changes necessary to
		 * get memory efficiency.  The reason is because there are indices in
		 * two other states for a B_st, y and z (instead of just y).  This
		 * means that when we're dealing with a dp_v that is d minus a v-state
		 * specific offset, we also have to worry about the y-state offset
		 * and z-state offset.
		 * Let's set kp as the equivalent of k from the old code, but
		 * now we have to take into account the offsets.  To remain as
		 * consistent as possible with the old code, we will keep the
		 * indexing in z the same in the recursion, and figure out what
		 * the corresponding indices involving state y are.
		 * So the old recursion code is :
		 *
		 * for (jp = 0; jp <= W; jp++) {
		 * j = i0-1+jp;
		 * for (d = 0; d <= jp; d++)
		 * {
		 *   alpha[v][j][d] = alpha[y][j][d] + alpha[z][j][0]; *INIT*
		 *   if (ret_shadow != NULL) kshad[j][d] = 0;
		 *   for (k = 1; k <= d; k++)
		 *   *RECURSION*
		 *   if ((sc = alpha[y][j-k][d-k] + alpha[z][j][k]) > alpha[v][j][d]) {
		 *     alpha[v][j][d] = sc;
		 *     if (ret_shadow != NULL) kshad[j][d] = k; }
		 *
		 * So we'll minimally change alpha[z][j][k] to alpha[z][j][kp]
		 * The INIT may change because although alpha[z][j][0] MUST be
		 * within the bands (because dmin[z] >= 0), the corresponding
		 * cell in alpha[y] might not be within the bands for y.
		 * That cell is alpha[y][j-dmin[z]-kp][d-dmin[y]-dmin[z]-kp]
		 * because k = kp + dmin[z] (it probably takes some time writing
		 * down the new and old equations, and staring and thinking for a
		 * while - I would write down more here - but this is already pretty
		 * verbose ... ).
		 *
		 * Therefore we can't just start with k (or kp)  = 0
		 * (like the old code did), because that might not be valid.
		 *
		 * First we need to determine the smallest kp for which we can
		 * do a valid traceback, which means the alpha cell for both the y
		 * state and z state are within the bands.  For a kp to be valid given
		 * the following code, the following three inequalities have to be
		 * true.
		 *
		 * (1) d-dmin[z]-kp <= dmax[y]
		 * (2) d-dmin[z]-kp >= dmin[y]
		 * (3) kp <= dmax[z]-dmin[z]
		 *
		 * (1) and (2) need to be satisified to guarantee that the cell we
		 * are going to access in the alpha[y] deck is within the bands for
		 * state y.  (3) is necessary to guarantee that the cell we are
		 * going to access in the alpha[z] deck is within the bands for
		 * state z.
		 * We can rearrange 1 and 2 :
		 *
		 * (1) kp >= d-dmax[y]-dmin[z]
		 * (2) kp <= d-dmin[y]-dmin[z]
		 *
		 * First to check to see if ANY kp is valid, we can first
		 * check to make sure that (d-dmin[y]-dmin[z]) (RHS of (2))
		 * is >= 0.  If not, then kp can never be 0 or greater.
		 * So it can never be valid. So we check for this at
		 * the beginning.
		 *
		 * So, to find the minimal kp that satisfies (1), (2) and (3)
		 * I set kp = d-dmax[y]-dmin[z], and then check that it kp >= 0
		 * If kp < 0, we set it to 0.  Then we check to make sure kp
		 * satisfies (3) (It has to satisfy (2) if it satisfies (1)
		 * because dmax[y] >= dmin[y]).  This is our *INIT* assignment.
		 * Next we incrementally step through all valid kp values, we'll need
		 * a for loop with two conditions to check in the 'while' portion.
		 * Namely, that kp satisfies inequalities (2) and (3), that is
		 * kp <= (d-dmin[y]-dmin[z]) and kp <= (dmax[z]-dmin[z])
		 * This is marked in the code by *RECUR*
		 *
		 * Also, we want to make sure the while statement from the
		 * original for loop (non-banded) is also satisfied.  This
		 * statement is k <= d.  We're dealing with kp, and k = kp+dmin[z]
		 * so this statement becomes kp <= d-dmin[z].  However, inequality
		 * (2) (kp <= d-dmin[y]-dmin[z]) takes care of this because dmin[y] >= 0
		 *
		 */
		dp_v = d - dmin[v];  /* d index for state v in alpha w/mem eff bands */
		dp_y = d - dmin[y];  /* d index for state y in alpha w/mem eff bands */
		dp_z = d - dmin[z];  /* d index for state z in alpha w/mem eff bands */

		/* First make sure we have any valid kp, we know from inequality (2)
		   that kp <= d-dmin[y]-dmin[z] so if this is < 0 then no kp
		   is valid (see notes above) */

		if((d-dmin[y]-dmin[z]) >= 0)
		{
		  if(jp < dmax[y]) kp = d-dmin[z]-jp;
		  else kp = d-dmin[z]-dmax[y];
		  if(kp < 0) kp = 0;
		  if(kp <= dmax[z] - dmin[z]) /* make sure its valid in deck alpha[z] */
		    {
		      alpha[v][j][dp_v] = alpha[y][j-dmin[z]-kp][d-dmin[y]-dmin[z]-kp]
			+ alpha[z][j][kp];
		      if (ret_shadow != NULL) kshad[j][dp_v] = kp;
		      for (kp = kp+1; kp <= (d-dmin[y]-dmin[z]) && kp <= (dmax[z]-dmin[z]);
			   kp++)
			{
			  /* the following if statement ensures that the alpha cell for
			     state y and the cell for state z that we are about to query
			     is in fact within the bands for state y and state z respectively*/
			  if ((sc = alpha[y][j-dmin[z]-kp][d-dmin[y]-dmin[z]-kp]
			       + alpha[z][j][kp]) > alpha[v][j][dp_v])
			    {
			      alpha[v][j][dp_v] = sc;
			      if (ret_shadow != NULL) kshad[j][dp_v] = kp;
			    }
			}
		    }
		}
		else alpha[v][j][dp_v] = IMPOSSIBLE;
		/*else cm_Fail("cell in alpha matrix was not filled in due to bands.\n");*/
		if (alpha[v][j][dp_v] < IMPOSSIBLE) alpha[v][j][dp_v] = IMPOSSIBLE;
	      }
	  }
	}
	  else if (cm->sttype[v] == MP_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    /* We assume dmin[v] >= 2 (it has to be) */
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		dp_v = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */
		alpha[v][j][dp_v] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if(ret_shadow != NULL) yshad[j][dp_v] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  {
		    dp_y = d - dmin[y+yoffset];  /* d index for state (y+yoffset)
						   in alpha w/mem eff bands */
		    /* the following if statement ensures that the alpha cell for
		       state y that we are about to query is in fact within the
		       bands for state y */
		    if(((dp_y-2) >= 0) && (((dp_y-2) < (jp - (dmin[y+yoffset]) + 1))
					   && ((dp_y-2) < (dmax[y+yoffset] - dmin[y+yoffset] + 1))))
		      {
			if ((sc = alpha[y+yoffset][j-1][dp_y-2] + cm->tsc[v][yoffset]) >  alpha[v][j][dp_v])
			  {
			    alpha[v][j][dp_v] = sc;
			    if (ret_shadow != NULL) yshad[j][dp_v] = yoffset;
			  }
		      }
		  }
		i = j-d+1;
		if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
		  alpha[v][j][dp_v] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
		else
		  alpha[v][j][dp_v] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);

		if (alpha[v][j][dp_v] < IMPOSSIBLE) alpha[v][j][dp_v] = IMPOSSIBLE;
		/* CYK Full ME Bands used 7 end block */
	      }
	  }
	}
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == ML_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;

	    /* we assume dmin[v] >= 1, it has to be */
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		dp_v = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */
		alpha[v][j][dp_v] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][dp_v] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  {
		    dp_y = d - dmin[y+yoffset];  /* d index for state (y+yoffset)
						   in alpha w/mem eff bands */
		    /* the following if statement ensures that the alpha cell for
		       state y that we are about to query is in fact within the
		       bands for state y */
		    if(((dp_y-1) >= 0) && (((dp_y-1) < (jp - (dmin[y+yoffset]) + 1))
				      && ((dp_y-1) < (dmax[y+yoffset] - dmin[y+yoffset] + 1))))
		      {
			if ((sc = alpha[y+yoffset][j][dp_y-1] + cm->tsc[v][yoffset]) >  alpha[v][j][dp_v])
			  {
			    alpha[v][j][dp_v] = sc;
			    if (ret_shadow != NULL) yshad[j][dp_v] = yoffset;
			  }
		      }
		  }
		i = j-d+1;
		if (dsq[i] < cm->abc->K)
		  alpha[v][j][dp_v] += cm->esc[v][dsq[i]];
		else
		  alpha[v][j][dp_v] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
		if (alpha[v][j][dp_v] < IMPOSSIBLE) alpha[v][j][dp_v] = IMPOSSIBLE;
		/* CYK Full ME Bands used 9 end block */
	      }
	  }
	}
	  else if (cm->sttype[v] == IR_st || cm->sttype[v] == MR_st)
	{
	  for (jp = 0; jp <= W; jp++) {
	    j = i0-1+jp;
	    for (d = dmin[v]; d <= dmax[v] && d <= jp; d++)
	      {
		y = cm->cfirst[v];
		dp_v = d - dmin[v]; /* d index for state v in alpha w/mem eff bands */
		alpha[v][j][dp_v] = cm->endsc[v] + (cm->el_selfsc * (d-StateDelta(cm->sttype[v])));
		/* treat EL as emitting only on self transition */
		if (ret_shadow != NULL) yshad[j][dp_v] = USED_EL;
		for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
		  {
		    dp_y = d - dmin[y+yoffset];  /* d index for state (y+yoffset)
						   in alpha w/mem eff bands */
		    /* the following if statement ensures that the alpha cell for
		       state y that we are about to query is in fact within the
		       bands for state y */
		    if(((dp_y-1) >= 0) && (((dp_y-1) < (jp - (dmin[y+yoffset]) + 1))
				      && ((dp_y-1) < (dmax[y+yoffset] - dmin[y+yoffset] + 1))))
		      {
			if ((sc = alpha[y+yoffset][j-1][dp_y-1] + cm->tsc[v][yoffset]) > alpha[v][j][dp_v])
			  {
			    alpha[v][j][dp_v] = sc;
			    if (ret_shadow != NULL) yshad[j][dp_v] = yoffset;
			  }
		      }
		  }
		if (dsq[j] < cm->abc->K)
		  alpha[v][j][dp_v] += cm->esc[v][dsq[j]];
		else
		  alpha[v][j][dp_v] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);

		if (alpha[v][j][dp_v] < IMPOSSIBLE) alpha[v][j][dp_v] = IMPOSSIBLE;
		/* CYK Full ME Bands used 11 end block */
	      }
	  }
	}				/* finished calculating deck v. */

	  /* The following loops originally access alpha[v][j0][W] but the index W will be
	 in different positions due to the bands */

	  Wp = W - dmin[v];
	  /* We need to make sure that Wp is within the bands */
	  if(Wp >= 0 && Wp <= (dmax[v] - dmin[v]))
	{
	  /* Check for local begin getting us to the root.
	   * This is "off-shadow": if/when we trace back, we'll handle this
	   * case separately (and we'll know to do it because we'll immediately
	   * see a USED_LOCAL_BEGIN flag in the shadow matrix, telling us
	   * to jump right to state b; see below)
	   */
	  if (allow_begin && alpha[v][j0][Wp] + cm->beginsc[v] > bsc)
	    {
	      b   = v;
	      bsc = alpha[v][j0][Wp] + cm->beginsc[v];
	    }

	  /* Check for whether we need to store an optimal local begin score
	   * as the optimal overall score, and if we need to put a flag
	   * in the shadow matrix telling insideT() to use the b we return.
	   */
	  if (allow_begin && v == 0 && bsc > alpha[0][j0][Wp]) {
	    alpha[0][j0][Wp] = bsc;
	    if (ret_shadow != NULL) yshad[j0][Wp] = USED_LOCAL_BEGIN;
	  }
	}
	  /* In the non-banded code, we used the deck reuse strategy, however, here
	 we can't do that, because for each state, the bands are different, so
	 we can't use old decks, but rather must allocate a new one, and free
	 the old one. */

	  if (! do_full) {
	if (cm->sttype[v] == B_st)
	  {
	    /* we can definitely release the S children of a bifurc. */
	    y = cm->cfirst[v];
	    z = cm->cnum[v];
	    free_vjd_deck(alpha[y], i0, j0);
	    alpha[y] = NULL;
	    free_vjd_deck(alpha[z], i0, j0);
	    alpha[z] = NULL;
	  }
	else
	  {
	    for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	      {
		touch[y]--;
		if (touch[y] == 0)
		  {
		    if (cm->sttype[y] == E_st) {
		      nends--;
		      /* Original code : if (nends == 0) { deckpool_push(dpool, end); end = NULL;} */
		      /* ME code deletes the previous line, we don't mess with end, because
			 it is used later */
		    } else
		      free_vjd_deck(alpha[y], i0, j0);
		    alpha[y] = NULL;
		  }
	      }
	  }
	  }
  } /* end loop over all v */

  /* Now we free our memory.
   * if we've got do_full set, all decks vroot..vend are now valid (end is shared).
   * else, only vroot deck is valid now and all others vroot+1..vend are NULL,
   * and end is NULL.
   * We could check this status to be sure (and we used to) but now we trust.
   */

  /* CYK Full ME Bands used 14 */
  /* original line :  sc       = alpha[vroot][j0][W];*/
  Wp = W - dmin[vroot];
  sc       = alpha[vroot][j0][Wp];

  if (ret_b != NULL)   *ret_b   = b;    /* b is -1 if allow_begin is FALSE. */
  if (ret_bsc != NULL) *ret_bsc = bsc;  /* bsc is IMPOSSIBLE if allow_begin is FALSE */

  /* If the caller doesn't want the matrix, free it (saving the decks in the pool!)
   * Else, pass it back to him.
   */
  if (ret_alpha == NULL) {
	for (v = vroot; v <= vend; v++) /* be careful of our reuse of the end deck -- free it only once */
	  if (alpha[v] != NULL) {
	if (cm->sttype[v] != E_st) { free_vjd_deck(alpha[v], i0, j0); alpha[v] = NULL; }
	else end = alpha[v];
	  }
	if (end != NULL) { free_vjd_deck(end, i0, j0); end = NULL; }
	free(alpha);
  } else *ret_alpha = alpha;

  free(touch);
  if (ret_shadow != NULL) *ret_shadow = shadow;
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/* Function: insideT_b_me()
 *           EPN 05.24.05
 * *based on insideT(), only difference is memory efficient bands are used :
 *
 * Date:     SRE, Fri Aug 11 12:08:18 2000 [Pittsburgh]
 *
 * Purpose:  Call inside, get vjd shadow matrix;
 *           then trace back. Append the trace to a given
 *           traceback, which already has state r at tr->n-1.
 */
static float
insideT_b_me(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
	     int r, int z, int i0, int j0,
	     int allow_begin, int *dmin, int *dmax)
{
  int       status;
  void   ***shadow;             /* the traceback shadow matrix */
  float     sc;			/* the score of the CYK alignment */
  ESL_STACK *pda;                /* stack that tracks bifurc parent of a right start */
  int       v,j,d,i;		/* indices for state, j, subseq len */
  int       k;
  int       y, yoffset;
  int       bifparent;
  int       b;
  float     bsc;
  int       dp;                 /* dp: d' d offset in current state v's band; dp = d - dmin[v] */
  int       kp;                 /* dp: k' k offset in current state v's band; kp = k - dmin[v] */

  sc = inside_b_me(cm, dsq, L, r, z, i0, j0,
		   BE_EFFICIENT,	/* memory-saving mode */
		   NULL, NULL,	        /* manage your own matrix, I don't want it */
		   &shadow,		/* return a shadow matrix to me. */
		   allow_begin,         /* TRUE to allow local begins */
		   &b, &bsc,	        /* if allow_begin is TRUE, gives info on optimal b */
		   dmin, dmax);

  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;
  v = r;
  j = j0;
  i = i0;
  d = j0-i0+1;

  while (1) {
	if(v == cm->M)
	  dp = d;
	else
	  dp = d - dmin[v];
	if(v != cm->M)
	  {
	assert(d <= dmax[v]);
	assert(d >= dmin[v]);
	  }
	if (cm->sttype[v] == B_st) {
	  assert(v >= 0);
	  kp = ((int **) shadow[v])[j][dp];   /* kp = offset len of right fragment */
	  z = cm->cnum[v];
	  k = kp + dmin[z];  /* k = len of right fragment */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;	/* remember the end j    */
	  if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;	/* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;	/* remember the trace index of the parent B state */
	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  y = cm->cfirst[v];
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	} else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  /* Note: we don't pop dp below, but d, because we're either in an E state
	   * in which case d must be 0, or the EL state, which has no
	   * dmin and dmax band, so if we pop dp and add dmin[v] to get d,
	   * we'll f*** everything up, as Sam Griffiths-Jones found
	   * when preparing Rfam 8.0 on 08.04.06.
	   */
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
				/* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	} else {
	  yoffset = ((char **) shadow[v])[j][dp];
	  if((((int) yoffset) != USED_LOCAL_BEGIN) && (((int) yoffset) != USED_EL))
	{
	  if(!((yoffset >= 0) && yoffset <= cm->M))
	    y = cm->cfirst[v] + yoffset;
	}
	  if((yoffset != USED_LOCAL_BEGIN) && (yoffset != USED_EL))
	assert(yoffset >= 0 &&  yoffset <= cm->M);
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    cm_Fail("'Inconceivable!'\n'You keep using that word...'");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL)
	{	/* a local alignment end */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	  v = cm->M;		/* now we're in EL. */
	}
	  else if (yoffset == USED_LOCAL_BEGIN)
	{ /* local begin; can only happen once, from root */
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	  v = b;
	}
	  else
	{
	  y = cm->cfirst[v] + yoffset;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	}
  }
  esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  free_vjd_shadow_matrix(shadow, cm, i0, j0);
  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* NEVERREACHED */
}

/*** End of inlined file: cm_dpsmall.c ***/


/*** Start of inlined file: cm_file.c ***/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef HMMER_THREADS
#include <pthread.h>
#endif



/* Magic numbers identifying binary formats.
 * Do not change the old magics! Necessary for backwards compatibility.
 */
#if 0 /* temporarily remove all the magic; write backwards compat stuff later */
static unsigned int v01magic = 0xe3edb0b1; /* v0.1 binary: "cm01" + 0x80808080 */
#endif

static uint32_t  v1a_magic  = 0xe3edb0b2; /* v1.1 binary: "cm02" + 0x80808080 */
static uint32_t  v1a_fmagic = 0xb1e1e6f3; /* 1/a binary MSV/SSV file: "1afs" = 0x 31 61 66 73  + 0x80808080 */
/* Note: 's' at end of 1afs is arbitrary. It is consistent with H3's
 * trailing 's' iforSSE binary files, but in Infernal this is used
 * whether we're building for SSE or VMX (since this code is neither
 * SSE nor VMX-specific). I suppose we could say it stands for SSV,
 * with 'f' for filter... Also, http://www.ascii-code.com/ and
 * hmmer/src/impl_sse/io.c might be useful to determine how each code
 * derives from its text string.
 */

static int read_asc_1p1_cm(CM_FILE *hfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm);
static int read_bin_1p1_cm(CM_FILE *hfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm);
static int read_asc_1p0_cm(CM_FILE *hfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm);

static int   write_bin_string(FILE *fp, char *s);
static int   read_bin_string (FILE *fp, char **ret_s);

static char *prob2ascii(float p, float null);
static float ascii2prob(char *s, float null);
static int is_integer(char *s);
static int is_real(char *s);

/* from p7_hmmfile.c, for reading p7 filters */
static uint32_t  v3a_magic = 0xe8ededb6; /* 3/a binary: "hmm6" + 0x80808080 */
static uint32_t  v3b_magic = 0xe8ededb7; /* 3/b binary: "hmm7" + 0x80808080 */
static uint32_t  v3c_magic = 0xe8ededb8; /* 3/c binary: "hmm8" + 0x80808080 */
static uint32_t  v3d_magic = 0xe8ededb9; /* 3/d binary: "hmm9" + 0x80808080 */
static uint32_t  v3e_magic = 0xe8ededb0; /* 3/e binary: "hmm0" + 0x80808080 */
static uint32_t  v3f_magic = 0xe8ededba; /* 3/f binary: "hmma" + 0x80808080 */

static int read_asc30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm);
static int read_bin30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm);

/*****************************************************************
 * 1. The CM_FILE object for reading CMs.
 *****************************************************************/
static int open_engine(char *filename, char *env, CM_FILE **ret_cmfp, int do_ascii_only, int allow_1p0, char *errbuf);

/* Function:  cm_file_Open()
 * Synopsis:  Open an CM file <filename>.
 * Incept:    EPN, Fri Jun 17 09:42:13 2011
 *            SRE, Tue Dec 21 10:44:38 2010 [Zaragoza] (p7_hmmfile_OpenE())
 *
 * Purpose:   Open an CM file <filename>, and prepare to read the first
 *            CM from it.
 *
 *            The format should be INFERNAL1/a or more recent.  If
 *            <allow_1p0>, we also allow the file to be in Infernal
 *            v1.0 to v1.0.2 ascii format.
 *
 *            We look for <filename> relative to the current working
 *            directory. Additionally, if we don't find it in the cwd
 *            and <env> is non-NULL, we will look for <filename>
 *            relative to one or more directories in a colon-delimited
 *            list obtained from the environment variable <env>. For
 *            example, if we had <setenv INFERNALDB
 *            /misc/db/Rfam:/misc/db/Pfam> in the environment, a
 *            CM application might pass "INFERNALDB" as <env>.
 *
 *            As a special case, if <filename> is "-", then CMs will
 *            be read from <stdin>. In this case, <env> has no effect.
 *
 *            As another special case, if <filename> ends in a <.gz>
 *            suffix, the file is assumed to be compressed by GNU
 *            <gzip>, and it is opened for reading from a pipe with
 *            <gunzip -dc>. This feature is only available on
 *            POSIX-compliant systems that have a <popen()> call, and
 *            <HAVE_POPEN> is defined by the configure script at
 *            compile time.
 *
 * Args:      filename  - CM file to open; or "-" for <stdin>
 *            env       - list of paths to look for <cmfile> in, in
 *                        addition to current working dir; or <NULL>
 *            allow_1p0 - TRUE to allow 1.0 formatted files
 *            ret_cmfp  - RETURN: opened <P7_CMFILE>.
 *            errbuf    - error message buffer: <NULL>, or a ptr
 *                        to <eslERRBUFSIZE> chars of allocated space.
 *
 * Returns:   <eslOK> on success, and the open <CM_FILE> is returned
 *            in <*ret_cmfp>.
 *
 *            <eslENOTFOUND> if <filename> can't be opened for
 *            reading, even after the list of directories in <env> (if
 *            any) is checked.
 *
 *            <eslEFORMAT> if <filename> is not in a recognized Infernal
 *            CM file format.
 *
 *            On either type of error, if a non-NULL <errbuf> was provided,
 *            a useful user error message is left in it.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
cm_file_Open(char *filename, char *env, int allow_1p0, CM_FILE **ret_cmfp, char *errbuf)
{
  return open_engine(filename, env, ret_cmfp, FALSE, allow_1p0, errbuf);
}

/* Function:  cm_file_OpenNoDB()
 * Synopsis:  Open only a CM flatfile, even if pressed db exists.
 * Incept:    SRE, Tue Dec 21 10:52:35 2010 [Zaragoza]
 *
 * Purpose:   Same as <cm_file_OpenE()> except that if a pressed
 *            database exists for <filename>, it is ignored. Only
 *            <filename> itself is opened.
 *
 *            hmmpress needs this call. Otherwise, it opens a press'ed
 *            database that it may be about to overwrite.
 */
int
cm_file_OpenNoDB(char *filename, char *env, int allow_1p0, CM_FILE **ret_cmfp, char *errbuf)
{
  return open_engine(filename, env, ret_cmfp, TRUE, allow_1p0, errbuf);
}

/* Function:  cm_file_OpenBuffer()
 * Incept:    EPN, Fri Jun 17 09:47:34 2011
 *            MSF, Thu Aug 19 2010 [Janelia] (p7_hmmfile_OpenBuffer())
 *
 * Purpose:   Perparse a buffer containing an ascii CM for parsing.
 *
 *            As another special case, if <filename> ends in a <.gz>
 *            suffix, the file is assumed to be compressed by GNU
 *            <gzip>, and it is opened for reading from a pipe with
 *            <gunzip -dc>. This feature is only available on
 *            POSIX-compliant systems that have a <popen()> call, and
 *            <HAVE_POPEN> is defined by the configure script at
 *            compile time.
 *
 * Args:      filename - CM file to open; or "-" for <stdin>
 *            env      - list of paths to look for <cmfile> in, in
 *                       addition to current working dir; or <NULL>
 *            ret_cmfp  - RETURN: opened <CM_FILE>.
 *
 * Returns:   <eslOK> on success, and the open <CM_FILE> is returned
 *            in <*ret_cmfp>.
 *
 *            <eslENOTFOUND> if <filename> can't be opened for
 *            reading, even after the list of directories in <env> (if
 *            any) is checked.
 *
 *            <eslEFORMAT> if <filename> is not in a recognized HMMER
 *            CM file format.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
cm_file_OpenBuffer(char *buffer, int size, int allow_1p0, CM_FILE **ret_cmfp)
{
  CM_FILE    *cmfp = NULL;
  int         status;
  char       *tok;
  int         toklen;

  ESL_ALLOC(cmfp, sizeof(CM_FILE));
  cmfp->f            = NULL;
  cmfp->fname        = NULL;
  cmfp->do_gzip      = FALSE;
  cmfp->do_stdin     = FALSE;
  cmfp->newly_opened = TRUE;	/* well, it will be, real soon now */
  cmfp->is_pressed   = FALSE;
#ifdef HMMER_THREADS
  cmfp->syncRead     = FALSE;
#endif
  cmfp->parser       = NULL;
  cmfp->efp          = NULL;
  cmfp->ffp          = NULL;
  cmfp->pfp          = NULL;
  cmfp->ssi          = NULL;
  cmfp->errbuf[0]    = '\0';

  if ((cmfp->efp = esl_fileparser_CreateMapped(buffer, size))         == NULL)   { status = eslEMEM; goto ERROR; }
  if ((status = esl_fileparser_SetCommentChar(cmfp->efp, '#'))        != eslOK)  goto ERROR;
  if ((status = esl_fileparser_GetToken(cmfp->efp, &tok, &toklen))    != eslOK)  goto ERROR;

  if      (             strcmp("INFERNAL1/a", tok) == 0) { cmfp->format = CM_FILE_1a; cmfp->parser = read_asc_1p1_cm; }
  else if (allow_1p0 && strcmp("INFERNAL-1",  tok) == 0) { cmfp->format = CM_FILE_1;  cmfp->parser = read_asc_1p0_cm; }

  if (cmfp->parser == NULL) { status = eslEFORMAT; goto ERROR; }

  *ret_cmfp = cmfp;
  return eslOK;

 ERROR:
  if (cmfp != NULL) cm_file_Close(cmfp);
  *ret_cmfp = NULL;
  if      (status == eslEMEM)       return status;
  else if (status == eslENOTFOUND)  return status;
  else                              return eslEFORMAT;
}

/* open_engine()
 *
 * Implements the file opening functions:
 * <cm_file_Open()>, <cm_file_OpenNoDB()>,
 * See their comments above.
 *
 * Only returns three types of errors:
 *    eslENOTFOUND - file (the CM file) or program (gzip, for .gz files) not found
 *    eslEFORMAT   - bad CM file format (or format of associated file)
 *    eslEMEM      - allocation failure somewhere
 * <errbuf>, if non-NULL, will contain a useful error message.
 *
 */
static int
open_engine(char *filename, char *env, CM_FILE **ret_cmfp, int do_ascii_only, int allow_1p0, char *errbuf)
{
  CM_FILE    *cmfp     = NULL;
  char       *envfile  = NULL;	/* full path to filename after using environment  */
  char       *dbfile   = NULL;	/* constructed name of an index or binary db file */
  char       *cmd      = NULL;	/* constructed gzip -dc pipe command              */
  int         status;
  int         n       = strlen(filename);
  union { char c[4]; uint32_t n; } magic;
  char       *tok;
  int         toklen;

  ESL_ALLOC(cmfp, sizeof(CM_FILE));
  cmfp->f            = NULL;
  cmfp->fname        = NULL;
  cmfp->do_gzip      = FALSE;
  cmfp->do_stdin     = FALSE;
  cmfp->newly_opened = TRUE;	/* well, it will be, real soon now */
  cmfp->is_pressed   = FALSE;
  cmfp->is_binary    = FALSE;
#ifdef HMMER_THREADS
  cmfp->syncRead     = FALSE;
#endif
  cmfp->parser       = NULL;
  cmfp->efp          = NULL;
  cmfp->hfp          = NULL;
  cmfp->ffp          = NULL;
  cmfp->pfp          = NULL;
  cmfp->ssi          = NULL;
  cmfp->errbuf[0]    = '\0';

  /* 1. There's two special reading modes that have limited indexing
   *    and optimization capability: reading from standard input, and
   *    reading a gzip'ped file. Once we've set one of these up and set
   *    either the <do_stdin> or <do_gzip> flag, we won't try to open
   *    any associated indexes or binary database files.
   */
  if (strcmp(filename, "-") == 0) /* "-" means read from stdin */
	{
	  cmfp->f        = stdin;
	  cmfp->do_stdin = TRUE;
	  if ((status = esl_strdup("[STDIN]", -1, &(cmfp->fname))) != eslOK)   ESL_XFAIL(status, errbuf, "esl_strdup failed; shouldn't happen");
	}
#ifdef HAVE_POPEN
  else if (n > 3 && strcmp(filename+n-3, ".gz") == 0) /* a <*.gz> filename means read via gunzip pipe */
	{
	  if (! esl_FileExists(filename))	                                   ESL_XFAIL(eslENOTFOUND, errbuf, ".gz file %s not found or not readable", filename);
	  if ((status = esl_sprintf(&cmd, "gzip -dc %s", filename)) != eslOK)  ESL_XFAIL(status,       errbuf, "when setting up .gz pipe: esl_sprintf() failed");
	  if ((cmfp->f = popen(cmd, "r")) == NULL)                             ESL_XFAIL(eslENOTFOUND, errbuf, "gzip -dc %s failed; gzip not installed or not in PATH?", filename);
	  if ((status = esl_strdup(filename, n, &(cmfp->fname))) != eslOK)     ESL_XFAIL(status,       errbuf, "esl_strdup() failed, shouldn't happen");
	  cmfp->do_gzip  = TRUE;
	  free(cmd); cmd = NULL;
	}
#endif /*HAVE_POPEN: gzip mode */

  /* 2. If <cmfp->f> is still NULL, then we're in the usual situation
   *    of looking for a file on disk. It may either be in the cwd, or
   *    in one of the directories listed in the <env> string. Find it,
   *    open it to <cmfp->f>, and set <cmfp->filename>. The
   *    <cmfp->filename> string will be used later to construct the
   *    names of expected index and binary database files.
   */
  if (cmfp->f == NULL)
	{
	  if ((cmfp->f = fopen(filename, "r")) != NULL)
	{
	  if ((status = esl_strdup(filename, n, &(cmfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
	}
	  else if (esl_FileEnvOpen(filename, env, &(cmfp->f), &envfile) == eslOK)
	{
	  n = strlen(envfile);
	  if ((status = esl_strdup(envfile, n, &(cmfp->fname)))     != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
	  free(envfile); envfile = NULL;
	}
	  else
	{ /* temporarily copy filename over to cmfp->fname, even though we haven't opened anything: we'll next try to open <filename>.h3m  */
	  if ((status = esl_strdup(filename, n, &(cmfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
	}
	}
  /* <cmfp->f> may *still* be NULL, if <filename> is a press'ed database and ASCII file is deleted */

  /* 3. Look for the binary model file component of a press'ed CM database.
   *
   *    If <cmfp->f> is still NULL, this is our last chance to find it.
   *    (The ASCII base file may have been deleted to save space, leaving
   *    binary press'ed files.)
   *
   * If we've been asked to open only an ASCII file -- because we're being
   * called by cmpress, for example! -- then don't do this.
   */
  if (! do_ascii_only && ! cmfp->do_stdin && ! cmfp->do_gzip)
	{
	  FILE *tmpfp;
	  /* if we opened an ASCII file in the INFERNALDB directory, cmfp->fname contains fully qualified name of file including the path */
	  if ((status = esl_sprintf(&dbfile, "%s.i1m", cmfp->fname) != eslOK)) ESL_XFAIL(status, errbuf, "esl_sprintf() failed; shouldn't happen");

	  if ((tmpfp = fopen(dbfile, "rb")) != NULL)
	{
	  if (cmfp->f != NULL) fclose(cmfp->f); /* preferentially read the .i1m file, not the original */
	  cmfp->f = tmpfp;
	  cmfp->is_pressed = TRUE;
	  free(cmfp->fname);
	  if ((status = esl_strdup(dbfile, -1, &(cmfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
	}
	  else if (cmfp->f == NULL && esl_FileEnvOpen(dbfile, env, &(cmfp->f), &envfile) == eslOK)
	{ /* found a binary-only press'ed db in one of the env directories. */
	  free(cmfp->fname);
	  if ((status = esl_strdup(envfile, -1, &(cmfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed; shouldn't happen");
	  cmfp->is_pressed = TRUE;
	}
	  free(dbfile); dbfile = NULL;
	}

  /* 4. <cmfp->f> must now point to a valid model input stream: if not, we fail.
   */
  if (cmfp->f == NULL)
	{
	  if (env) ESL_XFAIL(eslENOTFOUND, errbuf, "CM file %s not found (nor an .i1m binary of it); also looked in %s", filename, env);
	  else     ESL_XFAIL(eslENOTFOUND, errbuf, "CM file %s not found (nor an .i1m binary of it)",                    filename);
	}

  /* 5. Set up the HMM file <cmfp->hfp> that we'll use to read p7
   *     filter HMMs from within the CM file. We do this before we
   *     handle press'd model files, so we can set <cmfp->hfp->ffp>
   *     and <cmfp->hfp->pfp> if necessary.
   *
   */
  ESL_ALLOC(cmfp->hfp, sizeof(P7_HMMFILE));

  if (!cmfp->do_stdin && !cmfp->do_gzip) {
	if ((cmfp->hfp->f = fopen(cmfp->fname, "r")) == NULL) goto ERROR;
  }
  else if (cmfp->do_stdin) {
	cmfp->hfp->f = stdin;
  }
#ifdef HAVE_POPEN /* gzip functionality */
  else if (cmfp->do_gzip)  {  /* will only possibly be TRUE if HAVE_POPEN */
	/* we don't open the file separately for cmfp->hfp in gzip case,
	 * which works fine (since we're never a press'd db) but we have
	 * to be careful when closing cmfp in cm_file_Close().
	 */
	cmfp->hfp->f = cmfp->f;
  }
#endif
  cmfp->hfp->do_gzip      = cmfp->do_gzip;
  cmfp->hfp->do_stdin     = cmfp->do_stdin;
  cmfp->hfp->newly_opened = TRUE;	/* well, it will be, real soon now */
  cmfp->hfp->is_pressed   = cmfp->is_pressed;
#ifdef HMMER_THREADS
  cmfp->hfp->syncRead     = FALSE;
#endif
  cmfp->hfp->parser       = NULL;
  cmfp->hfp->efp          = NULL;
  cmfp->hfp->ffp          = NULL;
  cmfp->hfp->pfp          = NULL;
  cmfp->hfp->ssi          = NULL;      /* not sure if this should point to cmfp->ssi */
  cmfp->hfp->errbuf[0]    = '\0';
  if ((status = esl_strdup(cmfp->fname, -1, &(cmfp->hfp->fname))) != eslOK) goto ERROR;

  /* 6. If we found and opened a binary model file .i1m, open the rest of
   *     the press'd model files. (this can't be true if do_ascii_only is set).
   *     Note that we set cmfp->hfp->ffp and cmfp->hfp->pfp at the end of the
   *     function after we've
   */
  if (cmfp->is_pressed)
	{
	  /* here we rely on the fact that the suffixes are .i1{mfpi}, to construct other names from .i1m file name !! */
	  n = strlen(cmfp->fname); 	/* so, n = '\0', n-1 = 'm'  */
	  esl_strdup(cmfp->fname, n, &dbfile);

	  dbfile[n-1] = 'f';	/* the MSV filter part of the optimized sequence profiles (HMMs) */
	  if ((cmfp->ffp      = fopen(dbfile, "rb")) == NULL) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed CM file; but no .i1f file found", cmfp->fname);
	  if ((cmfp->hfp->ffp = fopen(dbfile, "rb")) == NULL) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed CM file; but no .i1f file found", cmfp->fname);

	  dbfile[n-1] = 'p';	/* the remainder of the optimized sequence profiles (HMMs) */
	  if ((cmfp->hfp->pfp = fopen(dbfile, "rb")) == NULL) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed CM file; but no .i1p file found", cmfp->fname);

	  dbfile[n-1] = 'i';	/* the SSI index for the .i1m file */
	  status = esl_ssi_Open(dbfile, &(cmfp->ssi));
	  if      (status == eslENOTFOUND) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed CM file; but no .i1i file found", cmfp->fname);
	  else if (status == eslEFORMAT)   ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed CM file; but format of its .i1i file unrecognized", cmfp->fname);
	  else if (status == eslERANGE)    ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed CM file; but its .i1i file is 64-bit and your system is 32-bit", cmfp->fname);
	  else if (status != eslOK)        ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed CM file; but failed to open its .i1i file", cmfp->fname);

	  free(dbfile); dbfile = NULL;
	}
  else
	{
	  if ((status = esl_sprintf(&dbfile, "%s.ssi", cmfp->fname)) != eslOK) ESL_XFAIL(status, errbuf, "esl_sprintf() failed");

	  status = esl_ssi_Open(dbfile, &(cmfp->ssi)); /* not finding an SSI file is ok. we open it if we find it. */
	  if      (status == eslEFORMAT)   ESL_XFAIL(status, errbuf, "a %s.ssi file exists (an SSI index), but its SSI format is not recognized",     cmfp->fname);
	  else if (status == eslERANGE)    ESL_XFAIL(status, errbuf, "a %s.ssi file exists (an SSI index), but is 64-bit, and your system is 32-bit", cmfp->fname);
	  else if (status != eslOK && status != eslENOTFOUND) ESL_XFAIL(status, errbuf, "esl_ssi_Open() failed");
	  free(dbfile); dbfile = NULL;
	}

  /* 7. Check for binary file format. A pressed db is automatically binary: verify. */
  if (! fread((char *) &(magic.n), sizeof(uint32_t), 1, cmfp->f))  ESL_XFAIL(eslEFORMAT, errbuf, "File exists, but appears to be empty?");
  if      (magic.n == v1a_magic) { cmfp->format = CM_FILE_1a; cmfp->parser = read_bin_1p1_cm; cmfp->is_binary = TRUE; }
  else if (cmfp->is_pressed) ESL_XFAIL(eslEFORMAT, errbuf, "Binary format tag in %s unrecognized\nCurrent Infernal format is INFERNAL1/a. Previous binary formats are not supported.", cmfp->fname);

  /* 8. Checks for ASCII file format */
  if (cmfp->parser == NULL)
	{
	  /* Does the magic appear to be binary, yet we didn't recognize it? */
	  if (magic.n & 0x80000000) ESL_XFAIL(eslEFORMAT, errbuf, "Format tag appears binary, but unrecognized\nCurrent Infernal format is INFERNAL1/a. Previous binary formats are not supported.");

	  if ((cmfp->efp = esl_fileparser_Create(cmfp->f))                     == NULL)  ESL_XFAIL(eslEMEM, errbuf, "internal error in esl_fileparser_Create()");
	  if ((status = esl_fileparser_SetCommentChar(cmfp->efp, '#'))        != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_SetCommentChar()");
	  if ((status = esl_fileparser_NextLinePeeked(cmfp->efp, magic.c, 4)) != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_NextLinePeeked()");
	  if ((status = esl_fileparser_GetToken(cmfp->efp, &tok, &toklen))    != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_GetToken()");

	  if      (                 strcmp("INFERNAL1/a", tok) == 0) { cmfp->format = CM_FILE_1a; cmfp->parser = read_asc_1p1_cm; }
	  else if ((  allow_1p0) && strcmp("INFERNAL-1",  tok) == 0) { cmfp->format = CM_FILE_1;  cmfp->parser = read_asc_1p0_cm; }
	  else if ((! allow_1p0) && strcmp("INFERNAL-1",  tok) == 0) { ESL_XFAIL(eslEFORMAT, errbuf, "Format tag is '%s': use cmconvert to reformat Infernal v1.0 to v1.0.2 CM files to current format", tok); }
	  else                                                       { ESL_XFAIL(eslEFORMAT, errbuf, "Format tag is '%s': unrecognized or not supported.", tok); }
	}

  *ret_cmfp = cmfp;
  return eslOK;

 ERROR:
  if (cmd     != NULL)  free(cmd);
  if (dbfile  != NULL)  free(dbfile);
  if (envfile != NULL)  free(envfile);
  if (cmfp    != NULL)  cm_file_Close(cmfp);
  *ret_cmfp = NULL;
  if      (status == eslEMEM)       return status;
  else if (status == eslENOTFOUND)  return status;
  else                              return eslEFORMAT;
}

/* Function:  cm_file_Close()
 * Incept:    EPN, Fri Jun 17 10:06:42 2011
 *            SRE, Wed Jan  3 18:48:44 2007 [Casa de Gatos] (p7_hmmfile_Close())
 *
 * Purpose:   Closes an open CM file <cmfp>.
 *
 * Returns:   (void)
 */
void
cm_file_Close(CM_FILE *cmfp)
{
  if (cmfp == NULL) return;

#ifdef HAVE_POPEN /* gzip functionality */
  if (cmfp->do_gzip && cmfp->f != NULL) {
	pclose(cmfp->f);
	/* careful here: in gzip mode we defined cmfp->hfp->f == cmfp->f,
	 * instead of reopening for cmfp->hfp->f, so we need to set
	 * cmfp->hfp->f to NULL so p7_hmmfile_Close() doesn't try to close
	 * it.
	 */
	if(cmfp->f == cmfp->hfp->f) { /* this should be TRUE */
	  cmfp->hfp->f = NULL;
	}
	cmfp->f = NULL;
  }
#endif
  if (!cmfp->do_gzip && !cmfp->do_stdin && cmfp->f != NULL) fclose(cmfp->f);
  if (cmfp->ffp   != NULL) fclose(cmfp->ffp);
  if (cmfp->pfp   != NULL) fclose(cmfp->pfp);
  if (cmfp->fname != NULL) free(cmfp->fname);
  if (cmfp->efp   != NULL) esl_fileparser_Destroy(cmfp->efp);
  if (cmfp->ssi   != NULL) esl_ssi_Close(cmfp->ssi);
#ifdef HMMER_THREADS
  if (cmfp->syncRead)      pthread_mutex_destroy (&cmfp->readMutex);
#endif

  if(cmfp->hfp != NULL) p7_hmmfile_Close(cmfp->hfp);

  free(cmfp);
}

#ifdef HMMER_THREADS
/* Function:  cm_file_CreateLock()
 * Incept:    EPN, Fri Jun 17 10:07:06 2011
 *            MSF, Wed July 15 2009 (p7_hmmfile_CreateLock())
 *
 * Purpose:   Create a lock to syncronize readers.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_file_CreateLock(CM_FILE *cmfp)
{
  int status;

  if (cmfp == NULL) return eslEINVAL;

  /* make sure the lock is not created twice */
  if (!cmfp->syncRead)
	{
	  cmfp->syncRead = TRUE;
	  status = pthread_mutex_init(&cmfp->readMutex, NULL);
	  if (status != 0) goto ERROR;
	}

  /* create lock on hmm files as well */
  if (cmfp->hfp != NULL)
	if((status = p7_hmmfile_CreateLock(cmfp->hfp)) != eslOK) goto ERROR;

  return eslOK;

 ERROR:
  cmfp->syncRead = FALSE;
  return eslFAIL;
}
#endif
/*----------------- end, CM_FILE object ----------------------*/

/*****************************************************************
 * 2. Writing CM files.
 *****************************************************************/
static int multiline(FILE *fp, const char *pfx, char *s);

/* Function:  cm_file_WriteASCII()
 * Synopsis:  Write an Infernal 1.1 ASCII save file.
 * Incept:    EPN, Fri Jun 17 10:07:46 2011
 *            SRE, Tue May 19 09:39:31 2009 [Janelia] (p7_hmmfile_WriteASCII())
 *
 * Purpose:   Write a covariance model <cm> in an ASCII save file format to
 *            an open stream <fp>.
 *
 *            Currently only outputs in the default standard format,
 *            so format must be <CM_FILE_1a> or <-1> (which specifies
 *            the current default format be used).
 *            In the future other formats will be accepted.
 *
 * Args:      fp     - open stream for writing
 *            format - -1 for default format, or a 1.x format code like <CM_FILE_1a>
 *            cm     - CM to save
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEINVAL> if <format> isn't a valid 3.0 format code.
 */
int
cm_file_WriteASCII(FILE *fp, int format, CM_t *cm)
{
  int x, v, nd, y;

  if((cm->flags & CMH_LOCAL_BEGIN) || (cm->flags & CMH_LOCAL_END)) cm_Fail("cm_file_WriteASCII(): CM is in local mode");

  if (format == -1) format = CM_FILE_1a;

  if   (format == CM_FILE_1a) fprintf(fp, "INFERNAL1/a [%s | %s]\n", INFERNAL_VERSION, INFERNAL_DATE);
  else ESL_EXCEPTION(eslEINVAL, "invalid CM file format code");

  fprintf(fp, "NAME     %s\n", cm->name);
  if (cm->acc)  fprintf(fp, "ACC      %s\n", cm->acc);
  if (cm->desc) fprintf(fp, "DESC     %s\n", cm->desc);
  fprintf(fp, "STATES   %d\n", cm->M);
  fprintf(fp, "NODES    %d\n", cm->nodes);
  fprintf(fp, "CLEN     %d\n", cm->clen);
  fprintf(fp, "W        %d\n", cm->W);
  fprintf(fp, "ALPH     %s\n", esl_abc_DecodeType(cm->abc->type));
  fprintf(fp, "RF       %s\n", (cm->flags & CMH_RF)   ? "yes" : "no");
  fprintf(fp, "CONS     %s\n", (cm->flags & CMH_CONS) ? "yes" : "no");
  fprintf(fp, "MAP      %s\n", (cm->flags & CMH_MAP)  ? "yes" : "no");
  if (cm->ctime   != NULL) fprintf  (fp, "DATE     %s\n", cm->ctime);
  if (cm->comlog  != NULL) multiline(fp, "COM     ",     cm->comlog);
  fprintf(fp, "PBEGIN   %g\n", cm->pbegin);
  fprintf(fp, "PEND     %g\n", cm->pend);
  fprintf(fp, "WBETA    %g\n", cm->beta_W);
  fprintf(fp, "QDBBETA1 %g\n", cm->qdbinfo->beta1);
  fprintf(fp, "QDBBETA2 %g\n", cm->qdbinfo->beta2);
  fprintf(fp, "N2OMEGA  %6g\n",cm->null2_omega);
  fprintf(fp, "N3OMEGA  %6g\n",cm->null3_omega);
  fprintf(fp, "ELSELF   %.8f\n",cm->el_selfsc);
  fprintf(fp, "NSEQ     %d\n", cm->nseq);
  fprintf(fp, "EFFN     %f\n",cm->eff_nseq);
  if (cm->flags & CMH_CHKSUM)  fprintf(fp, "CKSUM    %u\n", cm->checksum); /* unsigned 32-bit */
  fputs("NULL    ", fp);
  for (x = 0; x < cm->abc->K; x++) { fprintf(fp, "%6s ", prob2ascii(cm->null[x], 1/(float)(cm->abc->K))); }
  fputc('\n', fp);
  if (cm->flags & CMH_GA)  fprintf(fp, "GA       %.2f\n", cm->ga);
  if (cm->flags & CMH_TC)  fprintf(fp, "TC       %.2f\n", cm->tc);
  if (cm->flags & CMH_NC)  fprintf(fp, "NC       %.2f\n", cm->nc);

  if (cm->flags & CMH_FP7) {
	fprintf(fp, "EFP7GF   %.4f %.5f\n", cm->fp7_evparam[CM_p7_GFMU],  cm->fp7_evparam[CM_p7_GFLAMBDA]);
  }
  if (cm->flags & CMH_EXPTAIL_STATS)
	{
	  /* make sure our dbsize values can be cast to a long reliably,
	   * even on 32 bit systems (<= 2 Gb), they certainly should be,
	   * max value in cmcalibrate is 160Mb. (This is related to bug
	   * i31.)
	   */
	  if(cm->expA[EXP_CM_LC]->dbsize > (2000. * 1000000.)) ESL_EXCEPTION(eslEINVAL, "invalid dbsize (too big) EXP_CM_LC");
	  if(cm->expA[EXP_CM_GC]->dbsize > (2000. * 1000000.)) ESL_EXCEPTION(eslEINVAL, "invalid dbsize (too big) EXP_CM_GC");
	  if(cm->expA[EXP_CM_LI]->dbsize > (2000. * 1000000.)) ESL_EXCEPTION(eslEINVAL, "invalid dbsize (too big) EXP_CM_LI");
	  if(cm->expA[EXP_CM_GI]->dbsize > (2000. * 1000000.)) ESL_EXCEPTION(eslEINVAL, "invalid dbsize (too big) EXP_CM_GI");

	  fprintf(fp, "ECMLC    %.5f  %10.5f  %10.5f  %10ld  %10d  %.6f\n",
	      cm->expA[EXP_CM_LC]->lambda, cm->expA[EXP_CM_LC]->mu_extrap, cm->expA[EXP_CM_LC]->mu_orig,
	      (long) (cm->expA[EXP_CM_LC]->dbsize + 0.5), cm->expA[EXP_CM_LC]->nrandhits, cm->expA[EXP_CM_LC]->tailp);
	  fprintf(fp, "ECMGC    %.5f  %10.5f  %10.5f  %10ld  %10d  %.6f\n",
	      cm->expA[EXP_CM_GC]->lambda, cm->expA[EXP_CM_GC]->mu_extrap, cm->expA[EXP_CM_GC]->mu_orig,
	      (long) (cm->expA[EXP_CM_GC]->dbsize + 0.5), cm->expA[EXP_CM_GC]->nrandhits, cm->expA[EXP_CM_GC]->tailp);
	  fprintf(fp, "ECMLI    %.5f  %10.5f  %10.5f  %10ld  %10d  %.6f\n",
	      cm->expA[EXP_CM_LI]->lambda, cm->expA[EXP_CM_LI]->mu_extrap, cm->expA[EXP_CM_LI]->mu_orig,
	      (long) (cm->expA[EXP_CM_LI]->dbsize + 0.5), cm->expA[EXP_CM_LI]->nrandhits, cm->expA[EXP_CM_LI]->tailp);
	  fprintf(fp, "ECMGI    %.5f  %10.5f  %10.5f  %10ld  %10d  %.6f\n",
	      cm->expA[EXP_CM_GI]->lambda, cm->expA[EXP_CM_GI]->mu_extrap, cm->expA[EXP_CM_GI]->mu_orig,
	      (long) (cm->expA[EXP_CM_GI]->dbsize + 0.5), cm->expA[EXP_CM_GI]->nrandhits, cm->expA[EXP_CM_GI]->tailp);
	}

  /* main model section */
  fputs("CM\n", fp);

  /* Create emit map if nec, so we can output map, consensus and rf info appropriately */
  if(cm->emap == NULL) {
	cm->emap = CreateEmitMap(cm);
	if(cm->emap == NULL) ESL_EXCEPTION(eslEINVAL, "unable to create an emit map");
  }

  for (v = 0; v < cm->M; v++) {
	nd = cm->ndidx[v];

	/* Node line. node type and additional per-consensus position annotation */
	if (cm->nodemap[nd] == v) {
	  fprintf(fp, "%45s[ %-4s %4d ]", "", Nodetype(cm->ndtype[nd]), nd);

	  /* additional annotation */
	  /* map (optional) */
	  if(cm->flags & CMH_MAP) {
	if     (cm->ndtype[nd] == MATP_nd) fprintf(fp, " %6d %6d", cm->map[cm->emap->lpos[nd]], cm->map[cm->emap->rpos[nd]]);
	else if(cm->ndtype[nd] == MATL_nd) fprintf(fp, " %6d %6s", cm->map[cm->emap->lpos[nd]], "-");
	else if(cm->ndtype[nd] == MATR_nd) fprintf(fp, " %6s %6d", "-", cm->map[cm->emap->rpos[nd]]);
	else 	                           fprintf(fp, " %6s %6s", "-", "-");
	  }
	  else { /* no map annotation */
	fprintf(fp, " %6s %6s", "-", "-");
	  }
	  /* consensus sequence (mandatory) */
	  if     (cm->ndtype[nd] == MATP_nd) fprintf(fp, " %c %c", cm->consensus[cm->emap->lpos[nd]], cm->consensus[cm->emap->rpos[nd]]);
	  else if(cm->ndtype[nd] == MATL_nd) fprintf(fp, " %c %c", cm->consensus[cm->emap->lpos[nd]], '-');
	  else if(cm->ndtype[nd] == MATR_nd) fprintf(fp, " %c %c", '-', cm->consensus[cm->emap->rpos[nd]]);
	  else 	                         fprintf(fp, " %c %c", '-', '-');
	  /* RF (optional) */
	  if(cm->flags & CMH_RF) {
	if     (cm->ndtype[nd] == MATP_nd) fprintf(fp, " %c %c", cm->rf[cm->emap->lpos[nd]], cm->rf[cm->emap->rpos[nd]]);
	else if(cm->ndtype[nd] == MATL_nd) fprintf(fp, " %c %c", cm->rf[cm->emap->lpos[nd]], '-');
	else if(cm->ndtype[nd] == MATR_nd) fprintf(fp, " %c %c", '-', cm->rf[cm->emap->rpos[nd]]);
	else 	                           fprintf(fp, " %c %c", '-', '-');
	  }
	  else { /* no RF annotation */
	fprintf(fp, " %c %c", '-', '-');
	  }
	  fputs("\n", fp);
	}

	/* State line, w/ parents, children, dmin2, dmin1, dmax1, dmax2, transitions and emissions */
	fprintf(fp, "    %2s %5d %5d %1d %5d %5d %5d %5d %5d %5d ",
	    Statetype(cm->sttype[v]), v,
	    cm->plast[v], cm->pnum[v],
	    cm->cfirst[v], cm->cnum[v],
	    cm->qdbinfo->dmin2[v], cm->qdbinfo->dmin1[v],
	    cm->qdbinfo->dmax1[v], cm->qdbinfo->dmax2[v]);

	/* Transitions */
	if (cm->sttype[v] != B_st) {
	  for (x = 0; x < cm->cnum[v]; x++) {
	fprintf(fp, "%7s ", prob2ascii(cm->t[v][x], 1.));
	  }
	}
	else {
	  x = 0;
	}
	for (; x < 6; x++) {
	  fprintf(fp, "%7s ", "");
	}

	/* Emissions */
	if (cm->sttype[v] == MP_st) {
	  for (x = 0; x < cm->abc->K; x++) {
	for (y = 0; y < cm->abc->K; y++) {
	  fprintf(fp, "%6s ", prob2ascii(cm->e[v][x*cm->abc->K+y], cm->null[x]*cm->null[y]));
	}
	  }
	}
	else if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st || cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	  for (x = 0; x < cm->abc->K; x++) {
	fprintf(fp, "%6s ", prob2ascii(cm->e[v][x], cm->null[x]));
	  }
	}
	fputs("\n", fp);
  }
  fputs("//\n", fp);

  /* print additional p7 hmms if any */
  if(cm->flags & CMH_FP7 && cm->fp7 != NULL) {
	p7_hmmfile_WriteASCII(fp, -1, cm->fp7);
  }
  return eslOK;
}

/* Function:  cm_file_WriteBinary()
 * Incept:    EPN, Fri Jun 17 11:01:17 2011
 *            SRE, Wed Jan  3 13:50:26 2007 [Janelia] (p7_hmmfile_WriteBinary())
 * Purpose:   Writes an CM to a file in INFERNAL binary format.
 *
 *            Legacy binary file formats will eventually be supported
 *            by specifying the <format> code, but currently only one
 *            valid format exists. Passing <-1> as format specifies
 *            the default current standard format; pass a valid
 *            code such as <CM_FILE_1a> to select a specific
 *            binary format.
 *
 * Returns:   <eslOK> on success. File position of start of fp7 is
 *            sent back in <*opt_fp7_offset> if it is non-NULL. If no
 *            fp7 is written, (<*opt_fp7_offset> is 0) and caller will
 *            know no fp7 is written because (cm->fp7 == NULL) || (!
 *            (cm->flags & CMH_FP7)).  <eslFAIL> if any writes fail
 *            (for instance, if disk fills up, which did happen during
 *            testing!).
 *
 * Throws:    <eslEINVAL> if <format> isn't a valid 3.0 format code.
 */
int
cm_file_WriteBinary(FILE *fp, int format, CM_t *cm, off_t *opt_fp7_offset)
{
  int v, z;
  off_t fp7_offset;

  if((cm->flags & CMH_LOCAL_BEGIN) || (cm->flags & CMH_LOCAL_END)) cm_Fail("cm_file_WriteASCII(): CM is in local mode");

  if (format == -1) format = CM_FILE_1a;

  /* ye olde magic number */
  if      (format == CM_FILE_1a) { if (fwrite((char *) &(v1a_magic), sizeof(uint32_t), 1, fp) != 1) return eslFAIL; }
  else ESL_EXCEPTION(eslEINVAL, "invalid CM file format code");

  /* info necessary for sizes of things
   */
  if (fwrite((char *) &(cm->flags),      sizeof(int),  1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->M),          sizeof(int),  1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->nodes),      sizeof(int),  1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->clen),       sizeof(int),  1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->abc->type),  sizeof(int),  1,   fp) != 1) return eslFAIL;

  /* main model section
   */

  if (fwrite((char *) cm->sttype,         sizeof(char), cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->ndidx,          sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->stid,           sizeof(char), cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->cfirst,         sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->cnum,           sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->plast,          sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->pnum,           sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->nodemap,        sizeof(int),  cm->nodes, fp) != cm->nodes) return eslFAIL;
  if (fwrite((char *) cm->ndtype,         sizeof(char), cm->nodes, fp) != cm->nodes) return eslFAIL;
  if (fwrite((char *) cm->qdbinfo->dmin1, sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->qdbinfo->dmax1, sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->qdbinfo->dmin2, sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;
  if (fwrite((char *) cm->qdbinfo->dmax2, sizeof(int),  cm->M,     fp) != cm->M)     return eslFAIL;

  for (v = 0; v < cm->M; v++) {
	if (fwrite((char *) cm->t[v], sizeof(float), MAXCONNECT,            fp) != MAXCONNECT)              return eslFAIL;
	if (fwrite((char *) cm->e[v], sizeof(float), cm->abc->K*cm->abc->K, fp) != (cm->abc->K*cm->abc->K)) return eslFAIL;
  }

  /* annotation section
   */
  if (                           write_bin_string(fp, cm->name) != eslOK)                                       return eslFAIL;
  if ((cm->flags & CMH_ACC)  && (write_bin_string(fp, cm->acc)  != eslOK))                                      return eslFAIL;
  if ((cm->flags & CMH_DESC) && (write_bin_string(fp, cm->desc) != eslOK))                                      return eslFAIL;
  if ((cm->flags & CMH_RF)   && (fwrite((char *) cm->rf,          sizeof(char), cm->clen+2, fp) != cm->clen+2)) return eslFAIL; /* +2: 1..clen and trailing \0 */
  if ((cm->flags & CMH_CONS) && (fwrite((char *) cm->consensus,   sizeof(char), cm->clen+2, fp) != cm->clen+2)) return eslFAIL; /* consensus is mandatory */
  if ((cm->flags & CMH_MAP)  && (fwrite((char *) cm->map,         sizeof(int),  cm->clen+1, fp) != cm->clen+1)) return eslFAIL; /* +2: 1..clen and trailing \0 */
  if (fwrite((char *) &(cm->W), sizeof(int),      1,   fp) != 1) return eslFAIL;

  if ((write_bin_string(fp, cm->ctime))  != eslOK) return eslFAIL;
  if ((write_bin_string(fp, cm->comlog)) != eslOK) return eslFAIL;

  if (fwrite((char *) &(cm->pbegin),         sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->pend),           sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->beta_W),         sizeof(double),   1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->qdbinfo->beta1), sizeof(double),   1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->qdbinfo->beta2), sizeof(double),   1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->null2_omega),    sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->null3_omega),    sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->el_selfsc),      sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->nseq),           sizeof(int),      1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->eff_nseq),       sizeof(float),    1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm->checksum),       sizeof(uint32_t), 1,   fp) != 1) return eslFAIL;
  if (fwrite((char *) cm->null,              sizeof(float), cm->abc->K, fp) != cm->abc->K) return eslFAIL;

  /* Rfam cutoffs
   */
  if ((cm->flags & CMH_GA) && (fwrite((char *) &(cm->ga), sizeof(float),    1,   fp) != 1)) return eslFAIL;
  if ((cm->flags & CMH_TC) && (fwrite((char *) &(cm->tc), sizeof(float),    1,   fp) != 1)) return eslFAIL;
  if ((cm->flags & CMH_NC) && (fwrite((char *) &(cm->nc), sizeof(float),    1,   fp) != 1)) return eslFAIL;

  /* E-value parameters
   */
  if (cm->flags & CMH_FP7) { /* should always be true */
	if (fwrite((char *) &(cm->fp7_evparam[CM_p7_GFMU]),     sizeof(float), 1, fp) != 1) return eslFAIL;
	if (fwrite((char *) &(cm->fp7_evparam[CM_p7_GFLAMBDA]), sizeof(float), 1, fp) != 1) return eslFAIL;
  }
  if (cm->flags & CMH_EXPTAIL_STATS) {
	long dbsize_long;
	for(z = 0; z < EXP_NMODES; z++) {
	  /* make sure our dbsize values can be cast to a long reliably,
	   * even on 32 bit systems (<= 2 Gb), they certainly should be,
	   * max value in cmcalibrate is 160Mb. (This is related to bug
	   * i31.)
	   */
	  if(cm->expA[z]->dbsize > (2000. * 1000000.)) ESL_EXCEPTION(eslEINVAL, "invalid dbsize (too big)");
	  dbsize_long = (long) cm->expA[z]->dbsize + 0.5;
	  if (fwrite((char *) &(cm->expA[z]->lambda),    sizeof(double), 1, fp) != 1) return eslFAIL;
	  if (fwrite((char *) &(cm->expA[z]->mu_extrap), sizeof(double), 1, fp) != 1) return eslFAIL;
	  if (fwrite((char *) &(cm->expA[z]->mu_orig),   sizeof(double), 1, fp) != 1) return eslFAIL;
	  if (fwrite((char *) &(dbsize_long),            sizeof(long),   1, fp) != 1) return eslFAIL;
	  if (fwrite((char *) &(cm->expA[z]->nrandhits), sizeof(int),    1, fp) != 1) return eslFAIL;
	  if (fwrite((char *) &(cm->expA[z]->tailp),     sizeof(double), 1, fp) != 1) return eslFAIL;
	}
  }

  /* finally, write the filter p7 HMM */
  fp7_offset = 0;
  /* fp7_offset remains 0 if we don't write a fp7, caller will know that no
   * fp7 was written if (! (cm->flags & CMH_FP7)) || cm->fp7 == NULL
   */
  if(cm->flags & CMH_FP7 && cm->fp7 != NULL) {
	if(opt_fp7_offset != NULL) {
	  /* figure out offset only if we are returning it, otherwise it's irrelevant and can cause a failure
	   * in some cases (e.g. cmconvert -b test.cm | cat > /dev/null), this was bug i41
	   */
	  if((fp7_offset = ftello(fp)) == -1) ESL_EXCEPTION(eslEINVAL, "failed to determine file position for p7 filter");
	}
	p7_hmmfile_WriteBinary(fp, -1, cm->fp7);
  }

  if(opt_fp7_offset != NULL) *opt_fp7_offset = fp7_offset;
  return eslOK;
}
/*----------------- end, save file output  ----------------------*/

/* Function: write_bin_string()
 * Date:     SRE, Wed Oct 29 13:49:27 1997 [TWA 721 over Canada]
 *
 * Purpose:  Write a string in binary save format: an integer
 *           for the string length (including \0), followed by
 *           the string.
 *
 * Return:   <eslOK> on success;
 *           <eslFAIL> if a write fails due to system error, such
 *           as a filled disk (as happened in testing).
 */
static int
write_bin_string(FILE *fp, char *s)
{
  int len;
  if (s != NULL)
	{
	  len = strlen(s) + 1;
	  if (fwrite((char *) &len, sizeof(int),  1,   fp) != 1)   return eslFAIL;
	  if (fwrite((char *) s,    sizeof(char), len, fp) != len) return eslFAIL;
	}
  else
	{
	  len = 0;
	  if (fwrite((char *) &len, sizeof(int), 1, fp) != 1)      return eslFAIL;
	}
  return eslOK;
}

/*****************************************************************
 * 3. API for reading CMs in various formats.
 *****************************************************************/

/* Function:  cm_file_Read()
 * Incept:    EPN, Tue Jun 21 10:41:54 2011
 *            SRE, Sat Jan  6 18:04:58 2007 [Casa de Gatos] (p7_hmmfile_Read())
 *
 * Purpose:   Read the next CM from open save file <cmfp>, and
 *            optionally return this newly allocated CM in <opt_cm>.
 *            (The optional return is so that an application is
 *            only interested in whether the file contains a valid
 *            CM or not -- for example, to verify that a file contains
 *            only a single CM instead of a database of them.)
 *
 *            Read a p7 filter HMM (if one exists) for the CM if
 *            <read_fp7> is TRUE, else, don't read one. This allows us
 *            to read only the CM if we're using a pressed file in
 *            cmscan and already have read the p7 filter HMM
 *            previously. However be careful with this, because caller
 *            will have problems if it tries to read the file
 *            sequentially with <read_fp7> as FALSE because file
 *            offset will not be at the beginning of the next CM upon
 *            return, it will be at the beginning of the p7 filter for
 *            the last CM read, if one exists.
 *
 *            Caller may or may not already know what alphabet the CM
 *            is expected to be in.  A reference to the pointer to the
 *            current alphabet is passed in <*ret_abc>. If the alphabet
 *            is unknown, pass <*ret_abc = NULL>, and when the
 *            new HMM is read, an appropriate new alphabet object is
 *            allocated and passed back to the caller in <*ret_abc>.
 *            If the alphabet is already known, <ret_abc> points to
 *            that object ptr, and the new CM's alphabet type is
 *            verified to agree with it. This mechanism allows an
 *            application to let the first CM determine the alphabet
 *            type for the application, while still keeping the
 *            alphabet under the application's scope of control.
 *
 * Returns:   <eslOK> on success, and the newly allocated CM is
 *            optionally returned via <opt_cm>. Additionally, if
 *            <ret_abc> pointed to <NULL>, it now points to a newly
 *            allocated alphabet.
 *
 *            Returns <eslEOF> if no CMs remain in the file; this may
 *            indicate success or failure, depending on what the
 *            caller is expecting.
 *
 *            Returns <eslEFORMAT> on any format problems, including
 *            premature end of data or bad magic at the start of a
 *            binary file. An informative error message is left in
 *            <cmfp->errbuf>; the filename (fully qualified, if opened
 *            in a directory specified by an <env> list) is in
 *            <cmfp->fname>; and if <cmfp->efp> is non-<NULL>, the CM
 *            file is in an ASCII text format, and the caller may also
 *            obtain the line number at which the format error was
 *            detected, in <cmfp->efp->linenumber>, and use it to
 *            format informative output for a user.
 *
 *            Returns <eslEINCOMPAT> if the caller passed a known
 *            alphabet (a non-<NULL> <*ret_abc>), but the alphabet
 *            of the CM doesn't match this expectation.
 *
 *            Upon any return that is not <eslOK>, <*opt_cm> is
 *            <NULL> and <*ret_abc> is left unchanged from what caller
 *            passed it as.
 *
 * Throws:    <eslEMEM> upon an allocation error.
 *            <eslESYS> on failure of other system calls, such
 *            as file positioning functions (<fseeko()> or <ftello()>.
 */
int
cm_file_Read(CM_FILE *cmfp, int read_fp7, ESL_ALPHABET **ret_abc,  CM_t **opt_cm)
{
  /* A call to SSI to remember file position may eventually go here.  */
  return (*cmfp->parser)(cmfp, read_fp7, ret_abc, opt_cm);
}

/* Function:  cm_file_PositionByKey()
 * Synopsis:  Use SSI to reposition file to start of named CM.
 * Incept:    EPN, Tue Jun 21 10:46:33 2011
 *            SRE, Mon Jun 18 10:57:15 2007 [Janelia] (p7_hmmfile_PositionByKey())
 *
 * Purpose:   Reposition <cmfp> so the next CM we read will be the
 *            one named (or accessioned) <key>.
 *
 * Returns:   <eslOK> on success.
 *
 *            Returns <eslENOTFOUND> if <key> isn't found in the index for
 *            <cmfp>.
 *
 *            Returns <eslEFORMAT> is something goes wrong trying to
 *            read the index, indicating a file format problem in the
 *            SSI file.
 *
 *            In the event of either error, the state of <cmfp> is left
 *            unchanged.
 *
 * Throws:    <eslEMEM> on allocation failure, or <eslESYS> on system i/o
 *            call failure, or <eslEINVAL> if <cmfp> doesn't have an SSI
 *            index or is not a seekable stream.
 */
int
cm_file_PositionByKey(CM_FILE *cmfp, const char *key)
{
  uint16_t fh;
  off_t    offset;
  int      status;

  if (cmfp->ssi == NULL) ESL_EXCEPTION(eslEINVAL, "Need an open SSI index to call cm_file_PositionByKey()");
  if ((status = esl_ssi_FindName(cmfp->ssi, key, &fh, &offset, NULL, NULL)) != eslOK) return status;
  if (fseeko(cmfp->f, offset, SEEK_SET) != 0)    ESL_EXCEPTION(eslESYS, "fseek failed");

  cmfp->newly_opened = FALSE;	/* because we're poised on the magic number, and must read it */
  return eslOK;
}

/* Function:  cm_file_Position()
 * Synopsis:  Reposition file to a given offset.
 * Incept:    EPN, Tue Jun 21 10:47:48 2011
 *            MSF Wed Nov 4, 2009 [Janelia] (p7_hmmfile_Position())
 *
 * Purpose:   Reposition <cmfp> to position <offset>.
 *
 * Returns:   <eslOK> on success.
 *
 *            In the event an error, the state of <cmfp> is left
 *            unchanged.
 *
 * Throws:    <eslESYS> on system i/o call failure, or <eslEINVAL> if
 *            <cmfp> is not a seekable stream.
 */
int
cm_file_Position(CM_FILE *cmfp, const off_t offset)
{
  if (fseeko(cmfp->f, offset, SEEK_SET) != 0)    ESL_EXCEPTION(eslESYS, "fseek failed");

  cmfp->newly_opened = FALSE;	/* because we're poised on the magic number, and must read it */
  return eslOK;
}

/*------------------- end, input API ----------------------------*/

/*****************************************************************
 * 4. API for reading/writing p7 HMMs/profiles to filter for CMs.
 *****************************************************************/

/* Function:  cm_p7_hmmfile_Read()
 * Incept:    EPN, Fri Jul 22 09:21:53 2011
 *
 * Purpose:   Position an HMM save file <cmfp->hfp> to <offset> and
 *            read an HMM from it at that position. Return the HMM
 *            in <ret_hmm>.
 *
 *            Caller must already know the alphabet the HMM is
 *            expected to be in, passed in as <abc>.  If the alphabet
 *            for the HMM is of a different type than <abc>, we return
 *            eslEINCOMPAT.
 *
 * Returns:   <eslOK> on success, and the newly allocated HMM is
 *            in <ret_hmm>.
 *
 *            Returns <eslEOF> if no HMMs remain in the file; this
 *            is a failure, as we expect there to be one at <offset>.
 *
 *            Returns <eslEFORMAT> on any format problems, including
 *            premature end of data or bad magic at the start of a
 *            binary file. An informative error message is left in
 *            <cmfp->errbuf>; the filename (fully qualified, if opened
 *            in a directory specified by an <env> list) is in
 *            <cmfp->fname>; and if <cmfp->hfp->efp> is non-<NULL>,
 *            the HMM file is in an ASCII text format, and the caller
 *            may also obtain the line number at which the format
 *            error was detected, in <cmfp->hfp->efp->linenumber>, and
 *            use it to format informative output for a user.
 *
 *            Returns <eslEINCOMPAT> if the alphabet of the HMM doesn't
 *            match the expectation in <abc>.
 *
 *            Upon any return that is not <eslOK>, <*ret_hmm> is
 *            <NULL>.
 *
 * Throws:    <eslEMEM> upon an allocation error.
 *            <eslESYS> on failure of other system calls, such
 *            as file positioning functions (<fseeko()> or <ftello()>.
 */
int
cm_p7_hmmfile_Read(CM_FILE *cmfp, ESL_ALPHABET *abc, off_t offset, P7_HMM **ret_hmm)
{
  int      status;
  P7_HMM  *hmm  = NULL;
  char    *tok1 = NULL;
  uint32_t magic;

#ifdef HMMER_THREADS
  if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	/* lock the mutex to prevent other threads from reading the file at the same time */
	if (cmfp->hfp->syncRead) {
	  if (pthread_mutex_lock (&cmfp->hfp->readMutex) != 0) ESL_EXCEPTION(eslESYS, "mutex lock failed");
	}
  }
#endif
  if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	if (fseeko(cmfp->hfp->f, offset, SEEK_SET) != 0) ESL_XFAIL(eslEINCOMPAT, cmfp->errbuf, "Failed to set position for HMM file parser");
  }

  /* set the parser if it's unset (which it is only for first HMM read from cmfp->hfp) */
  if(cmfp->hfp->parser == NULL) {
	if(cmfp->is_binary) { /* CM file is binary, HMM file must be too */
	  if (! fread((char *) &(magic), sizeof(uint32_t), 1, cmfp->hfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Failed to read magic number at start of p7 additional filters");
	  if      (magic == v3a_magic) { cmfp->hfp->format = p7_HMMFILE_3a; cmfp->hfp->parser = read_bin30hmm; }
	  else if (magic == v3b_magic) { cmfp->hfp->format = p7_HMMFILE_3b; cmfp->hfp->parser = read_bin30hmm; }
	  else if (magic == v3c_magic) { cmfp->hfp->format = p7_HMMFILE_3c; cmfp->hfp->parser = read_bin30hmm; }
	  else if (magic == v3d_magic) { cmfp->hfp->format = p7_HMMFILE_3d; cmfp->hfp->parser = read_bin30hmm; }
	  else if (magic == v3e_magic) { cmfp->hfp->format = p7_HMMFILE_3e; cmfp->hfp->parser = read_bin30hmm; }
	  else if (magic == v3f_magic) { cmfp->hfp->format = p7_HMMFILE_3f; cmfp->hfp->parser = read_bin30hmm; }
	  else    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Unknown magic number for p7 HMM filter");
	}
	else { /* CM file is ascii, HMM file must be too */
	  if(cmfp->hfp->efp != NULL) ESL_XFAIL(eslEINVAL, cmfp->errbuf, "HMM ascii file parsers are out of sync");
	  if ((cmfp->hfp->efp = esl_fileparser_Create(cmfp->hfp->f)) == NULL)   { status = eslEMEM; goto ERROR; }
	  if ((status = esl_fileparser_SetCommentChar(cmfp->hfp->efp, '#'))        != eslOK)  goto ERROR;
	  if ((status = esl_fileparser_GetToken(cmfp->hfp->efp, &tok1, NULL))      != eslOK)  goto ERROR;

	  if      (strcmp("HMMER3/f", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3f; cmfp->hfp->parser = read_asc30hmm; }
	  else if (strcmp("HMMER3/e", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3e; cmfp->hfp->parser = read_asc30hmm; }
	  else if (strcmp("HMMER3/d", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3d; cmfp->hfp->parser = read_asc30hmm; }
	  else if (strcmp("HMMER3/c", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3c; cmfp->hfp->parser = read_asc30hmm; }
	  else if (strcmp("HMMER3/b", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3b; cmfp->hfp->parser = read_asc30hmm; }
	  else if (strcmp("HMMER3/a", tok1) == 0) { cmfp->hfp->format = p7_HMMFILE_3a; cmfp->hfp->parser = read_asc30hmm; }
	  else    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Unknown format for p7 HMM filter");
	}
  }

  /* read the HMM */
  status = p7_hmmfile_Read(cmfp->hfp, &abc, &hmm);
  if      (status == eslEOD)       ESL_XFAIL(status, cmfp->errbuf, "read failed, CM file may be truncated?");
  else if (status == eslEFORMAT)   ESL_XFAIL(status, cmfp->errbuf, "bad file format for HMM filter");
  else if (status == eslEINCOMPAT) ESL_XFAIL(status, cmfp->errbuf, "HMM filters are of different alphabets");
  else if (status != eslOK)        ESL_XFAIL(status, cmfp->errbuf, "Unexpected error in reading HMM filters");

#ifdef HMMER_THREADS
  if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	if (cmfp->hfp->syncRead) {
	  if (pthread_mutex_unlock (&cmfp->hfp->readMutex) != 0) ESL_EXCEPTION(eslESYS, "mutex unlock failed");
	}
  }
#endif

  *ret_hmm = hmm;
  return status;

 ERROR:
#ifdef HMMER_THREADS
  if(cmfp->hfp->f != NULL) {
	if (cmfp->hfp->syncRead) {
	  if (pthread_mutex_unlock (&cmfp->hfp->readMutex) != 0) ESL_EXCEPTION(eslESYS, "mutex unlock failed");
	}
  }
#endif

  if(hmm != NULL) p7_hmm_Destroy(hmm);
  *ret_hmm = NULL;
  return status;
}

/* Function:  cm_p7_oprofile_Write()
 * Synopsis:  Write an optimized p7 profile in two files.
 * Incept:    EPN, Fri Jul  8 06:57:50 2011
 *
 * Purpose:   Write the MSV filter part of <om> to open binary stream
 *            <ffp>, and the rest of the model to <pfp>. These two
 *            streams will typically be <.i1f> and <.i1p> files
 *            being created by cmpress.
 *
 *            Most of the work is done by p7_oprofile_Write(). This
 *            function is only necessary to write five pieces of data
 *            that are specific to CMs to the MSV file and one
 *            to the profile file:
 *
 *            1. <cm_offset>: the position in the corresponding <.i1m>
 *            file at which the CM corresponding to the optimized
 *            profile can be found.
 *
 *            2. <cm_clen>:  consensus length of the CM this p7 is a
 *            filter for.
 *
 *            3. <cm_W>:     window length of the CM this p7 is a
 *            filter for.
 *
 *            4. <cm_nbp>:   number of base pairs in CM (if 0, pipeline
 *            will be run in HMM only mode.
 *
 *            5. <gfmu>:     glocal forward mu for this <om>
 *
 *            6. <gflambda>: glocal forward lambda for this <om>
 *
 * Args:      ffp            - open binary stream for saving MSV filter part
 *            pfp            - open binary stream for saving rest of profile
 *            cm_offset      - disk offset for CM in <.i1m> file that corresponds
 *                             to this profile
 *            cm_clen        - consensus length of CM corresponding to this om (usually om->M)
 *            cm_W           - window length for the CM
 *            cm_nbp         - number of basepairs in the CM
 *            gfmu           - E value mu param for glocal forward for this om
 *            gflambda       - E value lambda param for glocal forward for this om
 *            om             - optimized profile to save
 *
 * Returns:   <eslOK> on success.
 *
 *            Returns <eslFAIL> on any write failure; for example,
 *            if disk is full.
 *
 * Throws:    (no abnormal error conditions)
 */
int
cm_p7_oprofile_Write(FILE *ffp, FILE *pfp, off_t cm_offset, int cm_clen, int cm_W, int cm_nbp, float gfmu, float gflambda, P7_OPROFILE *om)
{
  /* <ffp> is the part of the oprofile that MSVFilter() needs */
  if (fwrite((char *) &(v1a_fmagic),     sizeof(uint32_t), 1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm_offset),      sizeof(off_t),    1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm_clen),        sizeof(int),      1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm_W),           sizeof(int),      1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(cm_nbp),         sizeof(int),      1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(gfmu),           sizeof(float),    1,  ffp) != 1) return eslFAIL;
  if (fwrite((char *) &(gflambda),       sizeof(float),    1,  ffp) != 1) return eslFAIL;

  /* <pfp> gets the rest of the oprofile, we don't need to write anything extra, so
   * p7_oprofile_Write handles it all */

  /* pass to p7_oprofile_Write to do the rest */
  return p7_oprofile_Write(ffp, pfp, om);
}

/* Function:  cm_p7_oprofile_Position()
 * Synopsis:  Reposition the hmm filter file part of a CM file to an offset.
 * Incept:    EPN, Fri Jul 22 10:49:41 2011
 *            MSF, Thu Oct 15, 2009 [Janelia] (p7_oprofile_Position())
 *
 * Purpose:   Reposition an open <cmfp->ffp> to offset <offset>.
 *            <offset> would usually be the first byte of a
 *            desired hmm record.
 *
 * Returns:   <eslOK>     on success;
 *            <eslEOF>    if no data can be read from this position.
 *
 * Throws:    <eslEINVAL>  if the <sqfp> is not positionable.
 *            <eslEFORMAT> if no msv profile opened.
 *            <eslESYS>    if the fseeko() call fails.
 */
int
cm_p7_oprofile_Position(CM_FILE *cmfp, off_t offset)
{
  if (cmfp->ffp == NULL)  ESL_EXCEPTION(eslEFORMAT, cmfp->errbuf, "no MSV profile file; cmpress probably wasn't run");
  if (cmfp->do_stdin)     ESL_EXCEPTION(eslEINVAL, "can't Position() in standard input");
  if (cmfp->do_gzip)      ESL_EXCEPTION(eslEINVAL, "can't Position() in a gzipped file");
  if (offset < 0)         ESL_EXCEPTION(eslEINVAL, "bad offset");

  if (fseeko(cmfp->ffp, offset, SEEK_SET) != 0) ESL_EXCEPTION(eslESYS, "fseeko() failed");

  return eslOK;
}

/* Function:  cm_p7_oprofile_ReadMSV()
 * Synopsis:  Read MSV filter part of an optimized profile.
 * Incept:    EPN, Fri Jul  8 08:19:58 2011
 *
 * Purpose:   Read the MSV filter part of a p7 filter profile from the
 *            <.i1f> file associated with an open CM file <cmfp>.
 *            Allocate a new model, populate it with this minimal
 *            MSV filter information, and return a pointer to them
 *            in <*ret_om>. Return pointers to additional information
 *            on the model in <*ret_cm_offset>, <*ret_cm_clen> and
 *            <*ret_cm_W>.
 *
 *            Our alphabet may get set by the first HMM we read.  If
 *            <*byp_abc> is <NULL> at start, create a new alphabet and
 *            return a pointer to it in <*byp_abc>. If <*byp_abc> is
 *            non-<NULL>, it is assumed to be a pointer to an existing
 *            alphabet; we verify that the HMM's alphabet matches it
 *            and <*ret_abc> isn't changed.  This is the same
 *            convention used by <cm_file_Read()>.
 *
 *            The <.i1f> file was opened automatically, if it existed,
 *            when the CM file was opened with <cm_file_Open()>.
 *
 *            When no more HMMs remain in the file, return <eslEOF>.
 *
 *            Most of the work is done by p7_oprofile_ReadMSV(). This
 *            function is only necessary to read five pieces of data
 *            that are specific to CMs. See cm_p7_oprofile_Write()
 *            for more explanation.
 *
 *            If <read_scores> is TRUE: read all the MSV data
 *            (including scores) using p7_oprofile_ReadMSV().
 *            If <read_scores> is FALSE: read only the MSV info
 *            (no scores) using p7_oprofile_ReadInfoMSV().
 *
 *
 * Args:      cmfp    - open CM file, with associated .i1p file
 *            byp_abc - BYPASS: <*byp_abc == ESL_ALPHABET *> if known;
 *                              <*byp_abc == NULL> if desired;
 *                              <NULL> if unwanted.
 *            ret_cm_offset   - RETURN: offset of CM  each om corresponds to
 *            ret_cm_clen     - RETURN: clen of CM each om corresponds to
 *            ret_cm_W        - RETURN: W of CM each om corresponds to
 *            ret_cm_nbp      - RETURN: number of bps in CM each om corresponds to
 *            ret_gfmu        - RETURN: glocal fwd mu the om
 *            ret_gflambda    - RETURN: glocal forward lambda the om
 *            ret_om          - RETURN: the read <om> with MSV filter
 *                              data filled in.
 *
 * Returns:   <eslOK> on success. <*ret_om> is allocated here;
 *            caller free's with <p7_oprofile_Destroy()>.
 *            <*byp_abc> is allocated here if it was requested;
 *            caller free's with <esl_alphabet_Destroy()>.
 *
 *            Returns <eslEFORMAT> if <cmfp> has no <.i1f> file open,
 *            or on any parsing error.
 *
 *            Returns <eslEINCOMPAT> if the HMM we read is incompatible
 *            with the existing alphabet <*byp_abc> led us to expect.
 *
 *            On any returned error, <cmfp->errbuf> contains an
 *            informative error message.
 *
 * Throws:    <eslEMEM> on allocation error.
 */
int
cm_p7_oprofile_ReadMSV(CM_FILE *cmfp, int read_scores, ESL_ALPHABET **byp_abc, off_t *ret_cm_offset, int *ret_cm_clen, int *ret_cm_W, int *ret_cm_nbp, float *ret_gfmu, float *ret_gflambda, P7_OPROFILE **ret_om)
{
  int status         = eslOK;      /* return status */
  uint32_t magic;                  /* magic number used to verify format */
  off_t cm_offset;                 /* offset of the corresponding CM  in cmfp->mfp */
  int   cm_clen;                   /* CM consensus length (will likely be om->M) */
  int   cm_W;                      /* CM window length (will likely differ from om->max_length) */
  int   cm_nbp;                    /* number of basepairs in CM (if 0 pipeline will be run in HMM only mode) */
  float gfmu;                      /* glocal fwd mu parameter for current hmm */
  float gflambda;                  /* glocal fwd lambda parameter for current hmm */
  P7_OPROFILE *om = NULL;          /* the om we've read */

  if (cmfp->errbuf != NULL) cmfp->errbuf[0] = '\0';
  if (cmfp->ffp == NULL)    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "no MSV profile file; cmpress probably wasn't run");

  if (feof(cmfp->ffp))                                           { status = eslEOF; goto ERROR; } /* normal EOF: no more profiles */
  if (! fread( (char *) &magic, sizeof(uint32_t), 1, cmfp->ffp)) { status = eslEOF; goto ERROR; }
  if (magic != v1a_fmagic)  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "bad magic; not a CM database?");

  if (! fread( (char *) &cm_offset,       sizeof(off_t),    1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM offset");
  if (! fread( (char *) &cm_clen,         sizeof(int),      1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM consensus length");
  if (! fread( (char *) &cm_W,            sizeof(int),      1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM window length (W)");
  if (! fread( (char *) &cm_nbp,          sizeof(int),      1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM number of bps");
  if (! fread( (char *) &gfmu,            sizeof(int),      1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read glocal fwd mu parameter");
  if (! fread( (char *) &gflambda,        sizeof(int),      1, cmfp->ffp)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read glocal fwd lambda parameter");

  /* move HMM file position (cmfp->hfp->ffp) to where we are in CM file (cmfp->ffp) */
  if (fseeko(cmfp->hfp->ffp, ftello(cmfp->ffp), SEEK_SET) != 0)               ESL_XFAIL(eslEINCOMPAT, cmfp->errbuf, "failed to set position for HMM file parser (MSV)");
  if (read_scores) {
	if ((status = p7_oprofile_ReadMSV(cmfp->hfp, byp_abc, &om))     != eslOK) ESL_XFAIL(status,       cmfp->errbuf, "failed to read MSV filter model");
  }
  else {
	if ((status = p7_oprofile_ReadInfoMSV(cmfp->hfp, byp_abc, &om)) != eslOK) ESL_XFAIL(status,       cmfp->errbuf, "failed to read MSV info");
  }
  /* move CM file position (cmfp->ffp) to where we are in HMM file (cmfp->hfp->ffp) */
  if (fseeko(cmfp->ffp, ftello(cmfp->hfp->ffp), SEEK_SET) != 0) ESL_XFAIL(eslEINCOMPAT, cmfp->errbuf, "Failed to set position for CM file parser (MSV)");

  if(ret_cm_offset != NULL) *ret_cm_offset  = cm_offset;
  if(ret_cm_clen   != NULL) *ret_cm_clen    = cm_clen;
  if(ret_cm_W      != NULL) *ret_cm_W       = cm_W;
  if(ret_cm_nbp    != NULL) *ret_cm_nbp     = cm_nbp;
  if(ret_gfmu      != NULL) *ret_gfmu       = gfmu;
  if(ret_gflambda  != NULL) *ret_gflambda   = gflambda;
  if(ret_om        != NULL) *ret_om         = om;
  return eslOK;

 ERROR:
  if (om != NULL) p7_oprofile_Destroy(om);
  if (ret_om != NULL) *ret_om = NULL;
  return status;
}

/* Function:  cm_p7_oprofile_ReadBlockMSV()
 * Synopsis:  Read the next block of MSV filter parts from a HMM file.
 * Incept:    EPN, Thu Jul 21 04:44:19 2011
 *
 * Purpose:   Reads a block of the MSV filter parts of optimized
 *            p7 profiles from open cm file <cmfp> into
 *            <hmmBlock>.
 *
 *            Most of the work is done by p7_oprofile_ReadMSV(). This
 *            function is only necessary to read five pieces of data
 *            that are specific to CMs. See cm_p7_oprofile_Write()
 *            for more explanation.
 *
 * Args:      cmfp    - open CM file, with associated .i1f file
 *            idx0    - the index of the next profile in the file (0 if first profile)
 *            byp_abc - BYPASS: <*byp_abc == ESL_ALPHABET *> if known;
 *                              <*byp_abc == NULL> if desired;
 *                              <NULL> if unwanted.
 *            hmmBlock- RETURN: the block of profiles.
 *
 * Returns:   <eslOK> on success; block in <hmmBlock>.
 *
 *            Returns <eslEFORMAT> if <cmfp> has no <.i1f> file open,
 *            or on any parsing error.
 *
 *            Returns <eslEINCOMPAT> if any HMM we read is incompatible
 *            with the existing alphabet <*byp_abc> led us to expect.
 *
 *            Returns <eslEOF> when there is no profiles left in the
 *            file (including first attempt to read an empty file).
 */
int
cm_p7_oprofile_ReadBlockMSV(CM_FILE *cmfp, int64_t idx0, ESL_ALPHABET **byp_abc, CM_P7_OM_BLOCK *hmmBlock)
{
  int status         = eslOK;      /* return status */
  int i;

  hmmBlock->count = 0;
  hmmBlock->idx0  = idx0;
  for (i = 0; i < hmmBlock->listSize; ++i)
	{
	  status = cm_p7_oprofile_ReadMSV(cmfp, TRUE, byp_abc,
				      &(hmmBlock->cm_offsetA[i]),
				      &(hmmBlock->cm_clenA[i]),
				      &(hmmBlock->cm_WA[i]),
				      &(hmmBlock->cm_nbpA[i]),
				      &(hmmBlock->gfmuA[i]),
				      &(hmmBlock->gflambdaA[i]),
				      &(hmmBlock->list[i]));
	  if (status != eslOK) break;
	  ++hmmBlock->count;
	}
  /* create the MSV data */
  for (i = 0; i < hmmBlock->count; ++i) {
	hmmBlock->msvdataA[i] = p7_hmm_ScoreDataCreate(hmmBlock->list[i], FALSE);
  }
  /* initiate the clan idx data, caller will need to fill this if nec */
  for (i = 0; i < hmmBlock->count; ++i) {
	hmmBlock->clan_idxA[i] = -1;
  }

  /* EOF will be returned only in the case were no profiles were read */
  if (status == eslEOF && i > 0) status = eslOK;

  return status;
}

/*----------------- end of API for p7 filters ----------------------*/

/*****************************************************************
 * 5.  Private, specific profile CM file format parsers.
 *****************************************************************/

/* Parsing save files from INFERNAL 1.x
 * All parsers follow the same API.
 *
 * Returns <eslOK> on success, and if <opt_cm> is non-NULL,
 * <*opt_cm> points at a newly allocated CM.
 *
 * Additionally, if <*ret_abc> was NULL, then a new alphabet is
 * allocated according to the alphabet type of this CM, and returned
 * thru <ret_abc>.  This allocation mechanism allows a main()
 * application that doesn't yet know its alphabet to determine the
 * alphabet when the first CM is read, while also allowing an
 * application to allocate its own alphabet and assure that the
 * input CMs are appropriate for that alphabet.
 *
 * Returns <eslEOF> when no CM remains in the file, indicating a
 * normal end-of-file.
 *
 * Two types of "normal error" may happen, which the caller must check
 * for. Returns <eslEFORMAT> on any save file format error, including
 * bad magic (i.e. this is not an INFERNAL file at all). Returns
 * <eslEINCOMPAT> if the expected alphabet (a non-<NULL> alphabet
 * specified by <*ret_abc>) does not match the alphabet type of the
 * HMM.
 *
 * When these normal errors occur, the caller can construct its error
 * message from:
 *    <cmfp->errbuf>:    contains an informative error message
 *    <cmfp->fname>:     name of the CM file (or '-' if STDIN)
 * and if <cmfp->efp> is non-<NULL>, the CM file is in ASCII text,
 * and the caller may also use:
 *    <cmfp->efp->linenumber>: line on which the parse error occurred.
 *
 * Throws:     <eslEMEM> on allocation error.
 *             <eslESYS> if a system i/o call fails.
 *             In cases of error (including both thrown error and normal error), <*ret_abc>
 *             is left in its original state as passed by the caller, and <*ret_hmm> is
 *             returned <NULL>.
 */
static int
read_asc_1p1_cm(CM_FILE *cmfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm)
{
  int           status;
  ESL_ALPHABET *abc  = NULL;
  CM_t         *cm   = NULL;
  P7_HMM       *hmm  = NULL;
  char         *tag  = NULL;
  char         *tok1 = NULL;
  char         *tok2 = NULL;
  char         *tok3 = NULL;
  char         *tok4 = NULL;
  char         *tok5 = NULL;
  char         *tok6 = NULL;
  int           alphatype;
  off_t         offset = 0;
  off_t         fp7_offset = 0;
  int           v, x, y, nd;            /* counters */
  int           read_fp7_stats = FALSE;
  uint32_t      cm_statstracker = 0; /* for making sure we have all CM E-value stats, if we have any */
  int           exp_mode;
  int           read_el_selfsc = FALSE; /* set to true when we read ELSELF line */

  /* temporary parameters, for storing values prior to their allocation in the CM */
  float *tmp_null          = NULL;
  float  tmp_fp7_gfmu;
  float  tmp_fp7_gflambda;
  double tmp_qdbbeta1;
  double tmp_qdbbeta2;

  /* temporary per-node annotation, will be converted to per-consensus position once the model
   * architecture is known, after the full model is read */
  char *tmp_rf_left    = NULL;
  char *tmp_rf_right   = NULL;
  char *tmp_cons_left  = NULL;
  char *tmp_cons_right = NULL;
  int  *tmp_map_left   = NULL;
  int  *tmp_map_right  = NULL;

  cmfp->errbuf[0] = '\0';

  if (cmfp->newly_opened)
	{
	  offset            = 0;
	  cmfp->newly_opened = FALSE;
	}
  else
	{
	  /* Record where this CM starts on disk */
	  if ((! cmfp->do_stdin) && (! cmfp->do_gzip) && (offset = ftello(cmfp->f)) < 0)   ESL_XEXCEPTION(eslESYS, "ftello() failed");

	  /* First line of file: "INFERNAL1/a". Allocate shell for CM annotation information (we don't know M,nodes yet) */
	  if ((status = esl_fileparser_NextLine(cmfp->efp))                   != eslOK)  goto ERROR;  /* EOF here is normal; could also be a thrown EMEM */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tag, NULL)) != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "unexpected absence of tokens on data line");

	  if      (cmfp->format == CM_FILE_1a) { if (strcmp(tag, "INFERNAL1/a") != 0)    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Didn't find INFERNAL1/a tag: bad format or not an INFERNAL save file?"); }
	  else                                                                           ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No such CM file format code: this shouldn't happen");
	}

  if ((cm = CreateCMShell()) == NULL)   ESL_XFAIL(eslEMEM,    cmfp->errbuf, "allocation failure, CM shell");
  cm->offset = offset;

  /* Header section */
  while ((status = esl_fileparser_NextLine(cmfp->efp)) == eslOK)
	{
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tag, NULL))     != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "Premature end of line");

	  if (strcmp(tag, "NAME") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No name found on NAME line");
	cm_SetName(cm, tok1);
	  }

	  else if (strcmp(tag, "ACC") == 0)  {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No accession found on ACC line");
	cm_SetAccession(cm, tok1);
	  }

	  else if (strcmp(tag, "DESC") == 0) {
	if ((status = esl_fileparser_GetRemainingLine(cmfp->efp, &tok1))      != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No description found on DESC line");
	cm_SetDescription(cm, tok1);
	  }

	  else if (strcmp(tag, "STATES") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "Number of model states not found on STATES line");
	if ((cm->M = atoi(tok1))                                              == 0)  	  ESL_XFAIL(status,    cmfp->errbuf, "Invalid number of states %s on STATES line", tok1);
	  }

	  else if (strcmp(tag, "NODES") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "Number of model nodes not found on NODES line");
	if ((cm->nodes = atoi(tok1))                                          == 0)  	  ESL_XFAIL(status,    cmfp->errbuf, "Invalid number of nodes %s on NODES line", tok1);
	  }

	  else if (strcmp(tag, "CLEN") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No consensus length found on CLEN line");
	if ((cm->clen = atoi(tok1))                                           == 0)   	  ESL_XFAIL(status,    cmfp->errbuf, "Invalid consensus length %s on CLEN line", tok1);
	  }

	  else if (strcmp(tag, "W") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No consensus length found on W line");
	if ((cm->W = atoi(tok1))                                              == 0)   	  ESL_XFAIL(status,    cmfp->errbuf, "Invalid consensus length %s on W line", tok1);
	  }

	  else if (strcmp(tag, "ALPH") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    cmfp->errbuf, "No alphabet type found on ALPH");
	if ((alphatype = esl_abc_EncodeType(tok1))                        == eslUNKNOWN)  ESL_XFAIL(status,    cmfp->errbuf, "Unrecognized alphabet type %s", tok1);
	if (*ret_abc == NULL) {
	  if ((abc = esl_alphabet_Create(alphatype))                        == NULL) 	  ESL_XFAIL(eslEMEM,   cmfp->errbuf, "Failed to create alphabet");
	} else {
	  if ((*ret_abc)->type != alphatype)	                                          ESL_XFAIL(eslEINCOMPAT,cmfp->errbuf,"Alphabet type mismatch: was %s, but current CM says %s", esl_abc_DecodeType( (*ret_abc)->type), tok1);
	  abc = *ret_abc;
	}
	  }

	  else if (strcmp(tag, "RF") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    cmfp->errbuf, "No yes/no found for RF line");
	if      (strcasecmp(tok1, "yes") == 0) cm->flags |= CMH_RF;
	else if (strcasecmp(tok1, "no")  != 0)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "RF header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "CONS") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "No yes/no found for CONS line");
	if      (strcasecmp(tok1, "yes") == 0) cm->flags |= CMH_CONS;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT,  cmfp->errbuf, "CONS header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "MAP") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "No yes/no found for MAP line");
	if      (strcasecmp(tok1, "yes") == 0) cm->flags |= CMH_MAP;
	else if (strcasecmp(tok1, "no")  != 0)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MAP header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "DATE") == 0) {
	if ((status = esl_fileparser_GetRemainingLine(cmfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "No date found on DATE line");
	if (esl_strdup(tok1, -1, &(cm->ctime))                                 != eslOK)  ESL_XFAIL(eslEMEM,    cmfp->errbuf, "strdup() failed to set date");
	  }

	  else if (strcmp(tag, "COM") == 0) {
	/* just skip the first token; it's something like [1], numbering the command lines */
	if ((status = esl_fileparser_GetTokenOnLine  (cmfp->efp, &tok1, NULL)) != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "No command number on COM line");
	if ((status = esl_fileparser_GetRemainingLine(cmfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "No command on COM line");
	if (cm->comlog == NULL) {
	  if (esl_strdup(tok1, -1, &(cm->comlog))                              != eslOK)  ESL_XFAIL(eslEMEM,    cmfp->errbuf, "esl_strdup() failed");
	} else {
	  if (esl_strcat(&(cm->comlog), -1, "\n", -1)                          != eslOK)  ESL_XFAIL(eslEMEM,    cmfp->errbuf, "esl_strcat() failed");
	  if (esl_strcat(&(cm->comlog), -1, tok1,  -1)                         != eslOK)  ESL_XFAIL(eslEMEM,    cmfp->errbuf, "esl_strcat() failed");
	}
	  }

	  else if (strcmp(tag, "PBEGIN") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows PBEGIN tag");
	if ((cm->pbegin = atof(tok1)) <= 0.0f)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid beta on PBEGIN line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "PEND") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows PEND tag");
	if ((cm->pend = atof(tok1)) <= 0.0f)                                              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid beta on PEND line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "WBETA") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows WBETA tag");
	if ((cm->beta_W = atof(tok1)) <= 0.0f)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid beta on WBETA line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "QDBBETA1") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows QDBBETA tag");
	if ((tmp_qdbbeta1 = atof(tok1)) <= 0.0f)                                          ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid beta on QDBBETA line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "QDBBETA2") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows QDBBETA tag");
	if ((tmp_qdbbeta2 = atof(tok1)) <= 0.0f)                                          ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid beta on QDBBETA line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "N2OMEGA") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows N2OMEGA tag");
	if ((cm->null2_omega = atof(tok1)) <= 0.0f)                                       ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid omega on N2OMEGA line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "N3OMEGA") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows N3OMEGA tag");
	if ((cm->null3_omega = atof(tok1)) <= 0.0f)                                       ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid omega on N3OMEGA line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "ELSELF") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows ELSELF tag");
	cm->el_selfsc = atof(tok1);
	read_el_selfsc = TRUE;
	  }

	  else if (strcmp(tag, "NSEQ") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows NSEQ tag");
	if ((cm->nseq = atoi(tok1)) == 0)                                                 ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid nseq on NSEQ line: should be integer, not %s", tok1);
	  }

	  else if (strcmp(tag, "EFFN") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows EFFN tag");
	if ((cm->eff_nseq = atof(tok1)) < (-1.*eslSMALLX1))                               ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid eff_nseq on EFFN line: should be a positive real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "CKSUM") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Nothing follows CKSUM tag");
	cm->checksum = atoll(tok1); /* if atoi(), then you may truncate uint32_t checksums > 2^31-1 */
	cm->flags |= CMH_CHKSUM;
	  }

	  else if (strcmp(tag, "NULL") == 0) {
	if(abc == NULL) ESL_XFAIL(status,     cmfp->errbuf, "Read NULL line before ALPH line, ALPH line must come first");
	ESL_ALLOC(tmp_null, sizeof(float) * abc->K);
	for (x = 0; x < abc->K; x++) {
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on NULL line");
	  tmp_null[x] = ascii2prob(tok1, (1./(float) abc->K));
	}
	  }

	  else if (strcmp(tag, "GA") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on GA line");
	cm->ga     = atof(tok1);
	cm->flags |= CMH_GA;
	  }

	  else if (strcmp(tag, "TC") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on TC line");
	cm->tc     = atof(tok1);
	cm->flags |= CMH_TC;
	  }

	  else if (strcmp(tag, "NC") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on NC line");
	cm->nc     = atof(tok1);
	cm->flags |= CMH_NC;
	  }

	  else if (strcmp(tag, "EFP7GF") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on EFP7GF line"); /* tau */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on EFP7GF line"); /* lambda   */
	tmp_fp7_gfmu     = atof(tok1);
	tmp_fp7_gflambda = atof(tok2);
	read_fp7_stats = TRUE;
	  }

	  else if (strncmp(tag, "ECM", 3) == 0) { /* one of 4 possible CM E-value lines */
	/* determine which one */
	if      (strncmp(tag+3, "LC", 2) == 0) { exp_mode = EXP_CM_LC; cm_statstracker += 1; }
	else if (strncmp(tag+3, "GC", 2) == 0) { exp_mode = EXP_CM_GC; cm_statstracker += 2; }
	else if (strncmp(tag+3, "LI", 2) == 0) { exp_mode = EXP_CM_LI; cm_statstracker += 4; }
	else if (strncmp(tag+3, "GI", 2) == 0) { exp_mode = EXP_CM_GI; cm_statstracker += 8; }
	else                                   { ESL_XFAIL(status, cmfp->errbuf, "Invalid tag beginning with ECM"); }
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* lambda    */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* mu_extrap */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok3, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* mu_orig   */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok4, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* dbsize    */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok5, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* nrandhits */
	if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok6, NULL))   != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on ECM.. line"); /* tailp     */
	if (cm->expA == NULL) {
	  ESL_ALLOC(cm->expA, sizeof(ExpInfo_t *) * EXP_NMODES);
	  for(x = 0; x < EXP_NMODES; x++) { cm->expA[x] = CreateExpInfo(); }
	}
	cm->expA[exp_mode]->lambda    = atof(tok1);
	cm->expA[exp_mode]->mu_extrap = atof(tok2);
	cm->expA[exp_mode]->mu_orig   = atof(tok3);
	cm->expA[exp_mode]->dbsize    = atof(tok4); /* store as double, even though it was written as a long */
	cm->expA[exp_mode]->nrandhits = atoi(tok5);
	cm->expA[exp_mode]->tailp     = atof(tok6);
	cm->expA[exp_mode]->is_valid  = TRUE;
	  }
	  else if (strcmp(tag, "CM") == 0) {
	/* skip the remainder of this line */
	if ((status = esl_fileparser_NextLine(cmfp->efp)) != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data before main model section");
	break;
	  }
	} /* end, loop over possible header tags */
  if (status != eslOK) goto ERROR;

  /* Done reading the header information.
   * Check that everything is ok and mandatory info is present before moving on.
   */
  if (cm->M     < 1)      ESL_XFAIL(status, cmfp->errbuf, "Failed to read STATES line in header section");
  if (cm->nodes < 1)      ESL_XFAIL(status, cmfp->errbuf, "Failed to read NODES line in header section");
  if (cm->clen  < 1)      ESL_XFAIL(status, cmfp->errbuf, "Failed to read CLEN line in header section");
  if (cm->W     < 1)      ESL_XFAIL(status, cmfp->errbuf, "Failed to read W line in header section");
  if (! read_el_selfsc)   ESL_XFAIL(status, cmfp->errbuf, "Failed to read ELSELF line in header section");
  if (! read_fp7_stats)   ESL_XFAIL(status, cmfp->errbuf, "Failed to read EFP7GF line in header section");
  if (cm->name == NULL)   ESL_XFAIL(status, cmfp->errbuf, "Failed to read NAME line in header section");
  if (abc      == NULL)   ESL_XFAIL(status, cmfp->errbuf, "Failed to read ALPH line in header section");
  if (tmp_null == NULL)   ESL_XFAIL(status, cmfp->errbuf, "Failed to read NULL line in header section");

  /* Check to make sure we parsed CM E-value stats correctly.
   */
  if (cm->expA != NULL) {
	if      (cm_statstracker == 15) cm->flags |= CMH_EXPTAIL_STATS;
	else if (cm_statstracker != 0)  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Missing one or more ECM.. parameter lines");
  }

  /* Allocate body of CM now that # states (M) and # nodes (nnodes) are known */
  CreateCMBody(cm, cm->nodes, cm->M, cm->clen, abc);

  /* Copy values we stored in temp parameters awaiting CM allocation in CreateCMBody() */
  esl_vec_FCopy(tmp_null, abc->K, cm->null); /* cm->null allocated in CreateCMBody */
  cm->qdbinfo->beta1 = tmp_qdbbeta1;
  cm->qdbinfo->beta2 = tmp_qdbbeta2;

  /* Allocate and initialize temporary parameters for values we can't store
   * until after we've  read the full model and are able to construct an emit map */
  ESL_ALLOC(tmp_map_left,  sizeof(int) * cm->nodes);
  ESL_ALLOC(tmp_map_right, sizeof(int) * cm->nodes);
  esl_vec_ISet(tmp_map_left,  cm->nodes, -1);
  esl_vec_ISet(tmp_map_right, cm->nodes, -1);

  ESL_ALLOC(tmp_rf_left,  sizeof(char) * (cm->nodes+1));
  ESL_ALLOC(tmp_rf_right, sizeof(char) * (cm->nodes+1));
  tmp_rf_left[cm->nodes]  = '\0';
  tmp_rf_right[cm->nodes] = '\0';

  ESL_ALLOC(tmp_cons_left,  sizeof(char) * (cm->nodes+1));
  ESL_ALLOC(tmp_cons_right, sizeof(char) * (cm->nodes+1));
  tmp_cons_left[cm->nodes]  = '\0';
  tmp_cons_right[cm->nodes] = '\0';

  nd = -1;
  cm->clen = 0;

  for (v = 0; v < cm->M; v++)
	{
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))     != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data before main model section");

	  /* Ah, a node line. Process it and get the following line.
	   */
	  if (*tok1 == '[')
	{
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 1);
	  if ((x = NodeCode(tok1)) == -1)                                                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid node type %s", tok1);
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 2);
	  if (!is_integer(tok1))                                                         ESL_XFAIL(status,     cmfp->errbuf, "Invalid node index on node line: should be integer >= 0, not %s", tok1);
	  nd = atoi(tok1);
	  if (nd <  0)                                                                   ESL_XFAIL(status,     cmfp->errbuf, "Invalid node index on node line: should be integer >= 0, not %s", tok1);
	  if (nd >= cm->nodes)                                                           ESL_XFAIL(status,     cmfp->errbuf, "Invalid node index on node line: should not exceed %d, read %s", cm->nodes, tok1);
	  cm->ndtype[nd]  = x;
	  if     (cm->ndtype[nd] == MATP_nd) cm->clen+=2;
	  else if(cm->ndtype[nd] == MATL_nd) cm->clen++;
	  else if(cm->ndtype[nd] == MATR_nd) cm->clen++;
	  cm->nodemap[nd] = v;

	  /* chew up ']' */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 3);

	  /* read annotation: MAP, consensus sequence and RF. Proper format depends on node type.
	   */
	  /* MAP (optional: CMH_MAP? yes, else no */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 4);
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok2, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 5);
	  if      ((cm->flags & CMH_MAP) && cm->ndtype[nd] == MATP_nd) {
	    if (!is_integer(tok1))                                                       ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st MAP value on MATP node line: should be positive integer, not %s", tok1);
	    if (!is_integer(tok2))                                                       ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd MAP value on MATP node line: should be positive integer, not %s", tok2);
	    tmp_map_left[nd]  = atoi(tok1);
	    tmp_map_right[nd] = atoi(tok2);
	  }
	  else if((cm->flags & CMH_MAP) && cm->ndtype[nd] == MATL_nd) {
	    if (!is_integer(tok1))                                                       ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st MAP value on MATL node line: should be positive integer, not %s", tok1);
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd MAP value on MATL node line: should be '-', not %s", tok2);
	    tmp_map_left[nd]  = atoi(tok1);
	    tmp_map_right[nd] = -1;
	  }
	  else if((cm->flags & CMH_MAP) && cm->ndtype[nd] == MATR_nd) {
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st MAP value on MATR node line: should be '-', not %s", tok1);
	    if (!is_integer(tok2))                                                       ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd MAP value on MATR node line: should be positive integer, not %s", tok2);
	    tmp_map_left[nd]  = -1;
	    tmp_map_right[nd] = atoi(tok2);
	  }
	  else { /* either (! (cm->flags & CMH_MAP)) or ndtype is not MATP, MATL nor MATR */
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st MAP value on node line: should be '-', not %s", tok1);
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd MAP value on node line: should be '-', not %s", tok2);
	    tmp_map_left[nd]  = -1;
	    tmp_map_right[nd] = -1;
	  }

	  /* consensus sequence (optional: CMH_CONS? yes, else no */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 6);
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok2, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 7);
	  if     ((cm->flags & CMH_CONS) && (cm->ndtype[nd] == MATP_nd)) {
	    tmp_cons_left[nd]  = *tok1;
	    tmp_cons_right[nd] = *tok2;
	  }
	  else if((cm->flags & CMH_CONS) && cm->ndtype[nd] == MATL_nd) {
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd consensus character on MATL node line: should be '-', not %s", tok2);
	    tmp_cons_left[nd]  = *tok1;
	    tmp_cons_right[nd] = *tok2;
	  }
	  else if((cm->flags & CMH_CONS) && cm->ndtype[nd] == MATR_nd) {
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st consensus character on MATR node line: should be '-', not %s", tok1);
	    tmp_cons_left[nd]  = *tok1;
	    tmp_cons_right[nd] = *tok2;
	  }
	  else { /* either (! (cm->flags & CMH_CONS) or ndtype is not MATP, MATL nor MATR */
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st consensus character on node line: should be '-', not %s", tok1);
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd consensus character on node line: should be '-', not %s", tok2);
	    tmp_cons_left[nd]  = *tok1;
	    tmp_cons_right[nd] = *tok2;
	  }

	  /* RF (optional: CMH_RF? yes, else no */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 8);
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok2, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on node line: expected %d, got %d", 10, 9);
	  if      ((cm->flags & CMH_RF) && cm->ndtype[nd] == MATP_nd) {
	    tmp_rf_left[nd]  = *tok1;
	    tmp_rf_right[nd] = *tok2;
	  }
	  else if((cm->flags & CMH_RF) && cm->ndtype[nd] == MATL_nd) {
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd RF character on MATL node line: should be '-', not %s", tok2);
	    tmp_rf_left[nd]  = *tok1;
	    tmp_rf_right[nd] = *tok2;
	  }
	  else if((cm->flags & CMH_RF) && cm->ndtype[nd] == MATR_nd) {
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st RF character on MATR node line: should be '-', not %s", tok1);
	    tmp_rf_left[nd]  = *tok1;
	    tmp_rf_right[nd] = *tok2;
	  }
	  else { /* either (! (cm->flags & CMH_RF)) or ndtype is not MATP, MATL nor MATR */
	    if (*tok1 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 1st RF character on node line: should be '-', not %s", tok1);
	    if (*tok2 != '-')                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid 2nd RF character on node line: should be '-', not %s", tok2);
	    tmp_rf_left[nd]  = *tok1;
	    tmp_rf_right[nd] = *tok2;
	  }
	  if ((status = esl_fileparser_NextLine(cmfp->efp))                    != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data in main model: no state %d line", v);
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state line: expected at least %d, got %d", 8, 0);
	} /* done with node line */

	  /* Process state line.
	   * <statecode> <v> <plast> <pnum> <cfirst> <cnum> <dmin2> <dmin1> <dmax1> <dmax2> <transition probs (variable number)> <emission probs (variable number)>
	   */

	  /* <statecode> */
	  if((cm->sttype[v] = StateCode(tok1)) == -1)                                        ESL_XFAIL(status,     cmfp->errbuf, "Invalid state type %s\n", tok1);

	  /* <v> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 1);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid state index on state line: should be integer >= 0, not %s", tok1);
	  if (atoi(tok1) != v)                                                               ESL_XFAIL(status,     cmfp->errbuf, "Invalid state index on state line: should be %d, not %s", v, tok1);

	  /* <plast> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 2);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid plast value on state line: should be integer, not %s", tok1);
	  cm->plast[v] = atoi(tok1);

	  /* <pnum> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 3);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid pnum value on state line: should be integer, not %s", tok1);
	  cm->pnum[v] = atoi(tok1);

	  /* <cfirst> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 4);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid cfirst value on state line: should be integer, not %s", tok1);
	  cm->cfirst[v] = atoi(tok1);

	  /* <cnum> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 5);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid cnum value on state line: should be integer, not %s", tok1);
	  cm->cnum[v] = atoi(tok1);

	  /* <dmin2> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 6);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid dmin2 value on state line: should be integer, not %s", tok1);
	  cm->qdbinfo->dmin2[v] = atoi(tok1);

	  /* <dmin1> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 6);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid dmin1 value on state line: should be integer, not %s", tok1);
	  cm->qdbinfo->dmin1[v] = atoi(tok1);

	  /* <dmax1> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 7);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid dmax1 value on state line: should be integer, not %s", tok1);
	  cm->qdbinfo->dmax1[v] = atoi(tok1);

	  /* <dmax2> */
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8, 7);
	  if (! is_integer(tok1))                                                            ESL_XFAIL(status,     cmfp->errbuf, "Invalid dmax2 value on state line: should be integer, not %s", tok1);
	  cm->qdbinfo->dmax2[v] = atoi(tok1);

	  /* Transition probabilities. */
	  if (cm->sttype[v] != B_st) {
	for (x = 0; x < cm->cnum[v]; x++) {
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected at least %d, got %d", v, 8+cm->cnum[v], 8+x);
	  if ((! is_real(tok1) && (*tok1 != '*')))                                           ESL_XFAIL(status,     cmfp->errbuf, "Invalid transition score %d on state line: should be real number or '*', not %s", x+1, tok1);
	  cm->t[v][x] = ascii2prob(tok1, 1.);
	}
	  }
	  /* Emission probabilities. */
	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st || cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)     ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected %d, got %d", v, 8+cm->cnum[v]+cm->abc->K, 8+cm->cnum[v]+x);
	  if ((! is_real(tok1) && (*tok1 != '*')))                                           ESL_XFAIL(status,     cmfp->errbuf, "Invalid emission score %d on state line: should be real number or '*', not %s", x+1, tok1);
	  cm->e[v][x] = ascii2prob(tok1, cm->null[x]);
	}
	  }
	  else if (cm->sttype[v] == MP_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  for (y = 0; y < cm->abc->K; y++) {
	    if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL)) != eslOK)   ESL_XFAIL(status,     cmfp->errbuf, "Too few fields on state %d line: expected %d, got %d", v, 8+cm->cnum[v]+(cm->abc->K*cm->abc->K), 8+cm->cnum[v]+(x*cm->abc->K)+y);
	    if ((! is_real(tok1) && (*tok1 != '*')))                                         ESL_XFAIL(status,     cmfp->errbuf, "Invalid emission score %d on state line: should be real number or '*', not %s", (x*cm->abc->K)+y+1, tok1);
	    cm->e[v][x*cm->abc->K+y] = ascii2prob(tok1, cm->null[x]*cm->null[y]);
	  }
	}
	  }
	  cm->ndidx[v] = nd;
	  cm->stid[v]  = DeriveUniqueStateCode(cm->ndtype[nd], cm->sttype[v]);
	  if ((status = esl_fileparser_NextLine(cmfp->efp))                            != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data in main model: no state %d line", v+1);
	} /* end of loop over states */
  /* The closing // */
  if ((status = esl_fileparser_GetTokenOnLine(cmfp->efp, &tok1, NULL))        != eslOK)  ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data: missing //?");
  if (strcmp(tok1, "//")                                                      != 0)      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Expected closing //; found %s instead", tok1);

  /* Finally, read the filter HMM for this CM, unless we're explicitly told not to */
  if(read_fp7) {
	if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	  if((fp7_offset = ftello(cmfp->f)) < 0) ESL_XFAIL(eslESYS, cmfp->errbuf, "ftello() failed");
	}
	else {
	  fp7_offset = -1; /* this is irrelevant if stdin or gzip mode, cm_p7_hmmfile_Read will ignore it */
	}
	if((status = cm_p7_hmmfile_Read(cmfp, abc, fp7_offset, &hmm)) != eslOK) goto ERROR;
	if((status = cm_SetFilterHMM(cm, hmm, tmp_fp7_gfmu, tmp_fp7_gflambda)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Unable to set filter HMM for CM");
	if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	  /* now position the CM file to the end of the HMM we just read */
	  if (fseeko(cmfp->f, ftello(cmfp->hfp->f), SEEK_SET) != 0) ESL_XFAIL(eslESYS, cmfp->errbuf, "Failed to set position for CM file parser after reading filter HMMs");
	}
  }

  CMRenormalize(cm);
  cm->qdbinfo->setby = CM_QDBINFO_SETBY_CMFILE;
  cm->W_setby        = CM_W_SETBY_CMFILE;

  /* Create emit map now that we know the model architecture */
  cm->emap = CreateEmitMap(cm);
  if(cm->emap == NULL) ESL_XFAIL(eslEINVAL, cmfp->errbuf, "After reading complete model, failed to create an emit map");

  /* Use emit map to map the per-node annotation to per-consensus position */
  if (cm->flags & CMH_RF) {
	cm->rf[0] = ' ';
	for(nd = 0; nd < cm->nodes; nd++) {
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) cm->rf[cm->emap->lpos[nd]] = tmp_rf_left[nd];
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) cm->rf[cm->emap->rpos[nd]] = tmp_rf_right[nd];
	}
	cm->rf[cm->clen+1] = '\0';
  }
  if (cm->flags & CMH_CONS) {
	cm->consensus[0] = ' ';
	for(nd = 0; nd < cm->nodes; nd++) {
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) cm->consensus[cm->emap->lpos[nd]] = tmp_cons_left[nd];
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) cm->consensus[cm->emap->rpos[nd]] = tmp_cons_right[nd];
	}
	cm->consensus[cm->clen+1] = '\0';
  }
  if (cm->flags & CMH_MAP) {
	cm->map[0] = 0;
	for(nd = 0; nd < cm->nodes; nd++) {
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) cm->map[cm->emap->lpos[nd]] = tmp_map_left[nd];
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) cm->map[cm->emap->rpos[nd]] = tmp_map_right[nd];
	}
  }

  if(tmp_null  != NULL) free(tmp_null);

  /* these get allocated regardless of flag status, free them */
  free(tmp_rf_left);
  free(tmp_rf_right);
  free(tmp_cons_left);
  free(tmp_cons_right);
  free(tmp_map_left);
  free(tmp_map_right);

  if (*ret_abc == NULL) *ret_abc = abc;
  if ( opt_cm != NULL)  *opt_cm = cm; else FreeCM(cm);
  return eslOK;

 ERROR:
  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc);
  if (cm       != NULL) FreeCM(cm);
  if (opt_cm   != NULL) *opt_cm = NULL;
  if      (status == eslEMEM || status == eslESYS) return status;
  else if (status == eslEOF)                       return status;
  else if (status == eslEINCOMPAT)                 return status;
  else                                             return eslEFORMAT;	/* anything else is a format error: includes premature EOF, EOL, EOD  */
}

static int
read_bin_1p1_cm(CM_FILE *cmfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm)
{
  ESL_ALPHABET *abc = NULL;
  CM_t         *cm = NULL;
  P7_HMM       *hmm = NULL;
  uint32_t      magic;
  int           alphabet_type;
  int           v, x;
  off_t         offset = 0;
  off_t         fp7_offset = 0;
  int           status;
  float         tmp_fp7_gfmu;
  float         tmp_fp7_gflambda;

  cmfp->errbuf[0] = '\0';
  if (feof(cmfp->f))  { status = eslEOF;       goto ERROR; }

  if (cmfp->newly_opened)
	{
	  offset = 0;
	  cmfp->newly_opened = FALSE;
	}
  else
	{  /* Check magic. */
	  if ((!cmfp->do_stdin) && (! cmfp->do_gzip)) {
	if ((offset = ftello(cmfp->f)) < 0)                          ESL_XEXCEPTION(eslESYS, "ftello() failed");
	  }
	  if (! fread((char *) &magic, sizeof(uint32_t), 1, cmfp->f))    { status = eslEOF;       goto ERROR; }

	  if (cmfp->format == CM_FILE_1a) { if (magic != v1a_magic)  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "bad magic number at start of CM");  }
	  else                                                       ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "no such CM file format code");
	}

  /* Allocate shell of the new CM.
   * Two-step allocation lets us read/set the flags first;
   * then the later CreateBody() call will allocate optional internal fields we need.
   */
  if ((cm = CreateCMShell()) == NULL)   ESL_XFAIL(eslEMEM,    cmfp->errbuf, "allocation failure, CM shell");
  cm->offset = offset;

  /* Get sizes of things */
  if (! fread((char *) &(cm->flags),     sizeof(int), 1, cmfp->f)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read flags");

  /* Important step that's easy to overlook: lower flags that may have
   * been up when CM was output to file, but that won't be true of the
   * CM we're about to read (since not all CM parameters go into the
   * file).
   */
  cm->flags &= ~CMH_BITS;
  cm->flags &= ~CMH_CP9;
  cm->flags &= ~CMH_CP9_TRUNC;
  cm->flags &= ~CMH_MLP7;
  cm->flags &= ~CM_IS_CONFIGURED;

  if (! fread((char *) &(cm->M),         sizeof(int), 1, cmfp->f)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read number of states");
  if (! fread((char *) &(cm->nodes),     sizeof(int), 1, cmfp->f)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read number of nodes");
  if (! fread((char *) &(cm->clen),      sizeof(int), 1, cmfp->f)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read consensus length");
  if (! fread((char *) &alphabet_type,   sizeof(int), 1, cmfp->f)) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read alphabet_type");

  /* Set or verify alphabet. */
  if (*ret_abc == NULL)	{	/* still unknown: set it, pass control of it back to caller */
	if ((abc = esl_alphabet_Create(alphabet_type)) == NULL)     ESL_XFAIL(eslEMEM, cmfp->errbuf, "allocation failed, alphabet");
  } else {			/* already known: check it */
	abc = *ret_abc;
	if (abc->type != alphabet_type)                             ESL_XFAIL(eslEINCOMPAT, cmfp->errbuf, "Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( abc->type), esl_abc_DecodeType(alphabet_type));
  }

  /* Finish the allocation of the CM
   */
  CreateCMBody(cm, cm->nodes, cm->M, cm->clen, abc);

  /* Core model probabilities. */
  if (! fread((char *) cm->sttype,         sizeof(char), cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read sttype array");
  if (! fread((char *) cm->ndidx,          sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read ndidx array");
  if (! fread((char *) cm->stid,           sizeof(char), cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read stid array");
  if (! fread((char *) cm->cfirst,         sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read cfirst array");
  if (! fread((char *) cm->cnum,           sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read cnum array");
  if (! fread((char *) cm->plast,          sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read plast array");
  if (! fread((char *) cm->pnum,           sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read pnum array");
  if (! fread((char *) cm->nodemap,        sizeof(int),  cm->nodes,  cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read nodemap array");
  if (! fread((char *) cm->ndtype,         sizeof(char), cm->nodes,  cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read ndtype array");
  if (! fread((char *) cm->qdbinfo->dmin1, sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read dmin1 array");
  if (! fread((char *) cm->qdbinfo->dmax1, sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read dmax1 array");
  if (! fread((char *) cm->qdbinfo->dmin2, sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read dmin2 array");
  if (! fread((char *) cm->qdbinfo->dmax2, sizeof(int),  cm->M,      cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read dmax2 array");

  cm->qdbinfo->setby = CM_QDBINFO_SETBY_CMFILE;
  cm->W_setby        = CM_W_SETBY_CMFILE;

  /* Create emit map now that we know the model architecture */
  cm->emap = CreateEmitMap(cm);
  if(cm->emap == NULL) ESL_XFAIL(eslEINVAL, cmfp->errbuf, "After reading complete model, failed to create an emit map");

  for (v = 0; v < cm->M; v++) {
	if (! fread((char *) cm->t[v], sizeof(float), MAXCONNECT,           cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read transitions for state %d", v);
	if (! fread((char *) cm->e[v], sizeof(float), cm->abc->K*cm->abc->K,cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read emissions for state %d", v);
  }

  /* Annotations. */
  if (read_bin_string(cmfp->f, &(cm->name)) != eslOK)                                                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read name");
  if ((cm->flags & CMH_ACC)  && read_bin_string(cmfp->f, &(cm->acc))  != eslOK)                      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read acc");
  if ((cm->flags & CMH_DESC) && read_bin_string(cmfp->f, &(cm->desc)) != eslOK)                      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read desc");
  if ((cm->flags & CMH_RF)   && ! fread((char *) cm->rf,        sizeof(char), cm->clen+2, cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read rf");        /* +2: 1..M and trailing \0 */
  if ((cm->flags & CMH_CONS) && ! fread((char *) cm->consensus, sizeof(char), cm->clen+2, cmfp->f))  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read consensus"); /* don't need to test for >=3e format, because the flag is sufficient (didn't exist pre-3e) */
  if ((cm->flags & CMH_MAP)  && ! fread((char *) cm->map, sizeof(int), cm->clen+1, cmfp->f))         ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read map");
  if (! fread((char *) &(cm->W),       sizeof(int),   1, cmfp->f))                                   ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read nseq");

  if (read_bin_string(cmfp->f, &(cm->ctime))  != eslOK)                                              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read ctime");
  if (read_bin_string(cmfp->f, &(cm->comlog)) != eslOK)                                              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read comlog");

  if (! fread((char *) &(cm->pbegin),         sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read beta_W");
  if (! fread((char *) &(cm->pend),           sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read beta_W");
  if (! fread((char *) &(cm->beta_W),         sizeof(double),   1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read beta_W");
  if (! fread((char *) &(cm->qdbinfo->beta1), sizeof(double),   1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read betaqdb1");
  if (! fread((char *) &(cm->qdbinfo->beta2), sizeof(double),   1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read betaqdb2");
  if (! fread((char *) &(cm->null2_omega),    sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read null2_omega");
  if (! fread((char *) &(cm->null3_omega),    sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read null3_omega");
  if (! fread((char *) &(cm->el_selfsc),      sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read el_selfsc");
  if (! fread((char *) &(cm->nseq),           sizeof(int),      1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read nseq");
  if (! fread((char *) &(cm->eff_nseq),       sizeof(float),    1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read eff_nseq");
  if (! fread((char *) &(cm->checksum),       sizeof(uint32_t), 1,          cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read checksum");
  if (! fread((char *) cm->null,              sizeof(float),    cm->abc->K, cmfp->f))                ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read null vector");

  /* Rfam cutoffs */
  if ((cm->flags & CMH_GA) && (! fread((char *) &(cm->ga), sizeof(float), 1, cmfp->f)))              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read GA cutoff");
  if ((cm->flags & CMH_TC) && (! fread((char *) &(cm->tc), sizeof(float), 1, cmfp->f)))              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read TC cutoff");
  if ((cm->flags & CMH_NC) && (! fread((char *) &(cm->nc), sizeof(float), 1, cmfp->f)))              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read NC cutoff");

  /* E-value parameters */
  if (cm->flags & CMH_FP7) { /* should always be true */
	if (! fread((char *) &tmp_fp7_gfmu,     sizeof(float), 1, cmfp->f))         ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read additional P7 E-value stats");
	if (! fread((char *) &tmp_fp7_gflambda, sizeof(float), 1, cmfp->f))         ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read additional P7 E-value stats");
  }
  if (cm->flags & CMH_EXPTAIL_STATS) {
	long dbsize_long;
	ESL_ALLOC(cm->expA, sizeof(ExpInfo_t *) * EXP_NMODES);
	for(x = 0; x < EXP_NMODES; x++) {
	  cm->expA[x] = CreateExpInfo();
	  if (! fread((char *) &(cm->expA[x]->lambda),    sizeof(double), 1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	  if (! fread((char *) &(cm->expA[x]->mu_extrap), sizeof(double), 1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	  if (! fread((char *) &(cm->expA[x]->mu_orig),   sizeof(double), 1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	  if (! fread((char *) &(dbsize_long),            sizeof(long),   1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	  cm->expA[x]->dbsize = (double) dbsize_long;
	  if (! fread((char *) &(cm->expA[x]->nrandhits), sizeof(int),    1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	  if (! fread((char *) &(cm->expA[x]->tailp),     sizeof(double), 1, cmfp->f))        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "failed to read CM E-value stats");
	}
  }

  /* Finally, read the filter HMM for this CM, unless we're explicitly asked not to. */
  if(read_fp7) {
	if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	  if((fp7_offset = ftello(cmfp->f)) < 0) ESL_XFAIL(eslESYS, cmfp->errbuf, "ftello() failed");
	}
	else {
	  fp7_offset = -1; /* this is irrelevant if stdin or gzip mode, cm_p7_hmmfile_Read will ignore it */
	}
	if((status = cm_p7_hmmfile_Read(cmfp, abc, fp7_offset, &hmm)) != eslOK) goto ERROR;
	if((status = cm_SetFilterHMM(cm, hmm, tmp_fp7_gfmu, tmp_fp7_gflambda)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Unable to set filter HMM for CM");
	if(!cmfp->hfp->do_stdin && !cmfp->hfp->do_gzip) {
	  /* now position the CM file to the end of the HMM we just read */
	  if (fseeko(cmfp->f, ftello(cmfp->hfp->f), SEEK_SET) != 0) ESL_XFAIL(eslESYS, cmfp->errbuf, "Failed to set position for CM file parser after reading filter HMMs");
	}
  }

  if (*ret_abc == NULL) *ret_abc = abc;	/* pass our new alphabet back to caller, if caller didn't know it already */
  if ( opt_cm != NULL)  *opt_cm  = cm;  else FreeCM(cm);
  return eslOK;

 ERROR:
  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc); /* the test is for an alphabet created here, not passed */
  if (cm     != NULL) FreeCM(cm);
  if (opt_cm != NULL) *opt_cm = NULL;
  return status;
}

/* read_asc_1p0_cm(): inputting version 1.0-->1.0.2 CM file format.
 *
 * This function was stolen from Infernal v1.0.2's
 * cm_io.c:read_ascii_cm() (which is identical to the function of the
 * same time in v1.0 and v1.0.1.), and minmally changed to work in the
 * context of new CM_FILE data structure. This version also includes
 * better error message handling.
 *
 * Note that the value of <read_fp7> is irrelevant. It is only
 * in the prototype so that read_asc_1p0_cm is consistent with
 * other parser prototypes.
 */
static int
read_asc_1p0_cm(CM_FILE *cmfp, int read_fp7, ESL_ALPHABET **ret_abc, CM_t **opt_cm)
{
  int     status;
  CM_t   *cm;
  char   *buf;
  int     n;			/* length of buf */
  char   *s;
  int     M,N;			/* number of states, nodes in model */
  int     v,x,y,nd;		/* counters for states, events, nodes */
  char   *tok;
  int     toklen;
  int     exp_flags[EXP_NMODES]; /* keep track of which exp tails we've read */
  int     exp_mode;             /* index of exp tail info               */
  int     have_exps;            /* for checking we get 0 or all exp tails*/
  int     have_ga = FALSE;      /* we have GA cutoff, needed b/c we can't set cm->flags until after CreateCMBody() call */
  int     have_tc = FALSE;      /* we have TC cutoff, needed b/c we can't set cm->flags until after CreateCMBody() call */
  int     have_nc = FALSE;      /* we have NC cutoff, needed b/c we can't set cm->flags until after CreateCMBody() call */
  int     p;                    /* counter for partitions          */
  int     i;                    /* counter over exp_modes for exp tails */
  int     alphabet_type;        /* type of ESL_ALPHABET */
  ESL_ALPHABET *abc = NULL;
  int     read_nstates = FALSE; /* TRUE once we've read the number of states */
  int     read_nnodes  = FALSE; /* TRUE once we've read the number of nodes */
  int     read_atype   = FALSE; /* TRUE once we've read the alphabet type */
  int     read_clen = FALSE;
  int     evalues_are_invalid = FALSE;  /* TRUE if the PART line reports more than 1 partition */
  int     clen = 0;
  int     npartitions = 0;
  off_t   offset = 0;

  cm  = NULL;
  buf = NULL;
  n   = 0;
  for(i = 0; i < EXP_NMODES; i++)  exp_flags[i] = FALSE;

  cmfp->errbuf[0] = '\0';

  if (cmfp->newly_opened)
	{
	  offset            = 0;
	  cmfp->newly_opened = FALSE;
	}
  else
	{
	  /* Record where this CM starts on disk */
	  if ((! cmfp->do_stdin) && (! cmfp->do_gzip) && (offset = ftello(cmfp->f)) < 0)   ESL_XEXCEPTION(eslESYS, "ftello() failed");

	  /* First line of file: "INFERNAL-1" */
	  if (feof(cmfp->f) || esl_fgets(&buf, &n, cmfp->f) != eslOK) { /* end of file, free buf and return eslEOF */
	if(buf != NULL) free(buf);
	return eslEOF;
	  }
	  if      (cmfp->format == CM_FILE_1)  { if (strncmp(buf, "INFERNAL-1", 10) != 0)    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Didn't find INFERNAL-1 tag: bad format or not an INFERNAL save file?"); }
	  else                                                                              ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No such CM file format code: this shouldn't happen");
	}

  /* Parse the header information
   * These are all tag/value.
   * Ignore unknown tags (forward compatibility).
   */
  cm = CreateCMShell();
  M  = N = -1;
  while (esl_fgets(&buf, &n, cmfp->f) != eslEOF)
	{
	  s   = buf;
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Premature end of data, prior to MODEL section");
	  else if (strcmp(tok, "NAME") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No name found on NAME line");
	  if ((status = esl_strdup(tok, toklen, &(cm->name)))             != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Problem setting name for CM");
	}
	  else if (strcmp(tok, "ACC") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No accession found on ACC line");
	  if ((status = esl_strdup(tok, toklen, &(cm->acc)))              != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Problem setting accession for CM");
	}
	  else if (strcmp(tok, "DESC") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No description found on DESC line");
	  if ((status = esl_strdup(tok, toklen, &(cm->desc)))             != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Problem setting description for CM");
	}
	  else if (strcmp(tok, "GA") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No GA threshold found on GA line");
	  cm->ga = atof(tok);
	  have_ga = TRUE;
	}
	  else if (strcmp(tok, "TC") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No TC threshold found on TC line");
	  cm->tc = atof(tok);
	  have_tc = TRUE;
	}
	  else if (strcmp(tok, "NC") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No NC threshold found on NC line");
	  cm->nc = atof(tok);
	  have_nc = TRUE;
	}
	  else if (strcmp(tok, "STATES") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No number of STATES found on STATES line");
	  M = atoi(tok);
	  read_nstates = TRUE;
	}
	  else if (strcmp(tok, "NODES") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No number of NODES found on NODES line");
	  N = atoi(tok);
	  read_nnodes = TRUE;
	}
	  else if (strcmp(tok, "ALPHABET") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No alphabet type found on ALPHABET line");
	  alphabet_type = atoi(tok);
	  /* Set or verify alphabet. */
	  if (*ret_abc == NULL)	{	/* still unknown: set it, pass control of it back to caller */
	    if ((abc = esl_alphabet_Create(alphabet_type)) == NULL)       ESL_XFAIL(eslEMEM, cmfp->errbuf, "Failed to create alphabet");
	  } else {			/* already known: check it */
	    abc = *ret_abc;
	    if ((*ret_abc)->type != alphabet_type)                        ESL_XFAIL(eslEINCOMPAT,cmfp->errbuf,"Alphabet type mismatch");
	  }
	  read_atype = TRUE;
	}
	  else if (strcmp(tok, "ELSELF") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No ELSELF score found on ELSELF line");
	  cm->el_selfsc = atof(tok);
	}
	  else if (strcmp(tok, "WBETA") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No WBETA found on WBETA line");
	  cm->beta_W = (double) atof(tok);
	}
	  else if (strcmp(tok, "NSEQ") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No name found on NAME line");
	  cm->nseq = atoi(tok);
	}
	  else if (strcmp(tok, "EFFNSEQ") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No effective seq number found on EFFNSEQ line");
	  cm->eff_nseq = atof(tok);
	}
	  else if (strcmp(tok, "CLEN") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No consensus length found on CLEN line");
	  clen = atoi(tok); /* we'll compare this to what we calculate at end of func */
	  read_clen = TRUE;
	  /* Now we have the clen and we should have the alphabet type and N and M, so we can build the
	   * full model, and set the alphabet (which we need to do before alloc'ing/setting
	   * the null model */
	  if(! (read_nstates && read_nnodes && read_atype))
	    {
	      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "ERROR, ALPHABET, STATES and NODES lines should precede CLEN line");
	    }
	  CreateCMBody(cm, N, M, clen, abc);
	}
	  /* comlog and ctime info. Careful, we want the full line, so a token becomes a full line
	   * Also we stored this data differently in version 1.0, we have to throw out the CDATE
	   * info, we don't store that anymore.
	   */
	  else if (strcmp(tok, "BCOM") == 0)
	{
	  while(isspace((int) (*s))) s++; /* chew up leading whitespace */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No build command found on BCOM line");
	  if(cm->comlog == NULL) {
	    if((status = esl_strdup(tok, toklen, &(cm->comlog))) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting build date");
	  }
	  else {
	    if((status = esl_strcat(&(cm->comlog), -1,"\n",      1)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting build date");
	    if((status = esl_strcat(&(cm->comlog), -1, tok, toklen)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting build date");
	  }
	}
	  else if (strcmp(tok, "BDATE") == 0)
	{
	  while(isspace((int) (*s))) s++; /* chew up leading whitespace */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No date found on BDATE line");
	  if (esl_strdup(tok, toklen, &(cm->ctime))                    != eslOK) ESL_XFAIL(eslEMEM,    cmfp->errbuf, "strdup() failed to set date");
	}
	  else if (strcmp(tok, "CCOM") == 0)
	{
	  while(isspace((int) (*s))) s++; /* chew up leading whitespace */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No calibrate command found on CCOM line");
	  if(cm->comlog == NULL) {
	    if((status = esl_strdup(tok, toklen, &(cm->comlog))) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting calibrate date");
	  }
	  else {
	    if((status = esl_strcat(&(cm->comlog), -1,"\n",      1)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting calibrate date");
	    if((status = esl_strcat(&(cm->comlog), -1, tok, toklen)) != eslOK) ESL_XFAIL(status, cmfp->errbuf, "Problem setting calibrate date");
	  }
	}
	  else if (strcmp(tok, "CDATE") == 0)
	{
	  while(isspace((int) (*s))) s++; /* chew up leading whitespace */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No date found on CDATE line");
	  /* we don't store this anymore */
	}
	  else if (strcmp(tok, "NULL") == 0)
	{
	  if(cm->abc == NULL) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "NULL line must be preceded by ALPHABET line");
	  /* cm-> null already allocated in CreateCMBody() */
	  for (x = 0; x < abc->K; x++)
	    {
	      if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Problem reading NULL line");
	      cm->null[x] = ascii2prob(tok, (1./(float) abc->K));
	    }
	}
	  /* exp tail distribution information */
	  else if (strcmp(tok, "PART") == 0)
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No number of partitions on PART line");
	  if (! is_integer(tok))                                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "number of partitions is not an integer on PART line");
	  npartitions = atoi(tok);
	  if(npartitions != 1) {
	    evalues_are_invalid = TRUE;
	    /* we can't deal with more than 1 partition in the current codebase, if there are more, throw away any E-value parameters we read */
	  }
	  /* else 1 partition, we can handle this (nearly all infernal
	   * 1.0--1.0.2 files should have 1 partitions, you could
	   * only create a multi-partition file with the undocument
	   * --exp-pfile option to cmcalibrate). */

	  /* Ignore the rest of this line, it includes partition start/stop info that's no longer parsed */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid PART- line");
	}
	  /* exp tail info */
	  else if ((strncmp(tok, "E-", 2) == 0) && (! evalues_are_invalid)) /* skip the E- lines if we've read more than one partition above */
	{
	  /* determine which exp tail we're reading */
	  if      (strncmp(tok+2, "LC", 2) == 0) exp_mode = EXP_CM_LC;
	  else if (strncmp(tok+2, "GC", 2) == 0) exp_mode = EXP_CM_GC;
	  else if (strncmp(tok+2, "LI", 2) == 0) exp_mode = EXP_CM_LI;
	  else if (strncmp(tok+2, "GI", 2) == 0) exp_mode = EXP_CM_GI;
	  else if (strncmp(tok+2, "LV", 2) == 0) continue; /* cp9 HMM  local viterbi, irrelevant in current format */
	  else if (strncmp(tok+2, "GV", 2) == 0) continue; /* cp9 HMM glocal viterbi, irrelevant in current format */
	  else if (strncmp(tok+2, "LF", 2) == 0) continue; /* cp9 HMM  local forward, irrelevant in current format */
	  else if (strncmp(tok+2, "GF", 2) == 0) continue; /* cp9 HMM glocal forward, irrelevant in current format */
	  else ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid xx on E-xx line");

	  /* create the expA array if this is the first E- line we've read */
	  if (cm->expA == NULL) {
	    ESL_ALLOC(cm->expA, sizeof(ExpInfo_t *) * EXP_NMODES);
	    for(x = 0; x < EXP_NMODES; x++) { cm->expA[x] = CreateExpInfo(); }
	  }

	  /* now we know what exp tail we're reading, read it */
	  /* chew up partition */
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No partition read on E-xx line");
	  p = atoi(tok);
	  if (p != 0)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid partition on E-xx line");

	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No lambda read on E-xx line");
	  if (! is_real(tok))                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "lambda not real number on E-xx line");
	  cm->expA[exp_mode]->lambda = atof(tok);

	  if ((esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No mu_extrap read on E-xx line");
	  if (! is_real(tok))                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "mu_extrap not real number on E-xx line");
	  cm->expA[exp_mode]->mu_extrap = atof(tok);

	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No mu_orig read on E-xx line");
	  if (! is_real(tok))                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "mu_orign is not real number on E-xx line");
	  cm->expA[exp_mode]->mu_orig = atof(tok);

	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No dbsize read on E-xx line");
	  if (! is_integer(tok))                                 ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "dbsize is not integer on E-xx line");
	  cm->expA[exp_mode]->dbsize = atof(tok); /* read it as a double, even though it's written as a long */

	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No nrandhits read on E-xx line");
	  if (! is_integer(tok))                                 ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "nrandhits is not integer on E-xx line");
	  cm->expA[exp_mode]->nrandhits = atoi(tok);

	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "No tailp read on E-xx line");
	  if (! is_real(tok))                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "tailp is not real number on E-xx line");
	  cm->expA[exp_mode]->tailp = atof(tok);

	  cm->expA[exp_mode]->cur_eff_dbsize = (double) (cm->expA[exp_mode]->nrandhits);
	  /* Previous line is to set cur_eff_dbsize as if database was of size cm->stats->expAA[p]->dbsize, we
	   * act as if the max hits we'll see is nrandhits, the number of hits we saw in cmcalibrate,
	   * so this is the highest possible E-value we can get.
	   * cur_eff_dbsize will be updated in cmsearch for whatever the target database size is. */
	  cm->expA[exp_mode]->is_valid = TRUE; /* set valid flag */
	  exp_flags[exp_mode] = TRUE;
	}
	  else if (strncmp(tok, "FT-", 3) == 0)
	{
	  /* filter thresholds statistics are deprecated, chew up the rest ot this line, and following two lines */
	  if ((status = esl_strtok_adv(&s, "\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid FT- line");
	  if (esl_fgets(&buf, &n, cmfp->f) == eslEOF) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Premature end to file, while reading FT- line 2");
	  if (esl_fgets(&buf, &n, cmfp->f) == eslEOF) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Premature end to file, while reading FT- line 3");
	}
	  else if (strcmp(tok, "MODEL:") == 0)
	break;
	}

  /* Done reading the header information.
   * Check that everything is ok and mandatory info is present before moving on.
   */
  if (feof(cmfp->f))      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Premature end to CM file, file truncated?");
  if (! read_nstates)     ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MODEL: line precedes STATES line");
  if (! read_nnodes)      ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MODEL: line precedes NODES line");
  if (! read_clen)        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MODEL: line precedes CLEN line");
  if (! read_atype)       ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MODEL: line precedes ALPHABET line");
  if (cm->name == NULL)   ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "MODEL: line precedes NAME line");

  /* if we have any exp tail stats, we (currently) require all of them */
  have_exps = exp_flags[0];
  for(exp_mode = 1; exp_mode < EXP_NMODES; exp_mode++)
	if(((have_exps && (!exp_flags[exp_mode]))) ||
	   ((!have_exps) && (exp_flags[exp_mode])))
	  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Some but not all E-xx lines read, expected 8");

  /* Main model section.
   */
  CMZero(cm);
  if(have_exps)  cm->flags |= CMH_EXPTAIL_STATS;
  if(have_ga)    cm->flags |= CMH_GA;
  if(have_tc)    cm->flags |= CMH_TC;
  if(have_nc)    cm->flags |= CMH_NC;
  nd = -1;
  clen = 0;
  for (v = 0; v < cm->M; v++)
	{
	  if ((status = esl_fgets(&buf, &n, cmfp->f)) != eslOK)                     ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data before main model section");
	  s = buf;
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(status,     cmfp->errbuf, "Premature end of data before main model section");

	  /* Ah, a node line. Process it and get the following line.
	   */
	  if (*tok == '[')
	{
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Too few fields on node line");
	  if ((x = NodeCode(tok)) == -1)                                            ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid node type %s", tok);
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Too few fields on node line");
	  if (!is_integer(tok))                                                     ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid node index on node line");
	  nd = atoi(tok);
	  cm->ndtype[nd]  = x;
	  if(cm->ndtype[nd] == MATP_nd) clen+=2;
	  else if(cm->ndtype[nd] == MATL_nd) clen++;
	  else if(cm->ndtype[nd] == MATR_nd) clen++;
	  cm->nodemap[nd] = v;

	  if ((status = esl_fgets(&buf, &n, cmfp->f)) != eslOK)                     ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Too few fields on NODE line");
	  s = buf;
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Too few fields on NODE line");
	}

	  /* Process state line.
	   */
	  cm->sttype[v] = StateCode(tok);
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (! is_integer(tok))                                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (atoi(tok) != v)                                                       ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (! is_integer(tok))                                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  cm->plast[v] = atoi(tok);
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (! is_integer(tok))                                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  cm->pnum[v] = atoi(tok);
	  if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (! is_integer(tok))                                                    ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  cm->cfirst[v] = atoi(tok);
	  if ((status= esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  if (! is_integer(tok))                                                   ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	  cm->cnum[v] = atoi(tok);
				/* Transition probabilities. */
	  if (cm->sttype[v] != B_st)
	{
	  for (x = 0; x < cm->cnum[v]; x++)
	    {
	      if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	      if (! is_real(tok) && *tok != '*')                                        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	      cm->t[v][x] = ascii2prob(tok, 1.);
	    }
	}
				/* Emission probabilities. */
	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st ||
	  cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    {
	      if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	      if (! is_real(tok) && *tok != '*')                                        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
	      cm->e[v][x] = ascii2prob(tok, cm->null[x]);
	    }
	}
	  else if (cm->sttype[v] == MP_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    for (y = 0; y < cm->abc->K; y++)
	      {
		if ((status = esl_strtok_adv(&s, " \t\n", &tok, &toklen, NULL)) != eslOK) ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
		if (! is_real(tok) && *tok != '*')                                        ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "Invalid state line for cm: %s state: %d", cm->name, v);
		cm->e[v][x*cm->abc->K+y] = ascii2prob(tok, cm->null[x]*cm->null[y]);
	      }
	}

	  cm->ndidx[v] = nd;
	  cm->stid[v]  = DeriveUniqueStateCode(cm->ndtype[nd], cm->sttype[v]);
	} /* end of loop over states */

  /* Advance to record separator
   */
  while (esl_fgets(&buf, &n, cmfp->f) != eslEOF)
	if (strncmp(buf, "//", 2) == 0)
	  break;

  /* EPN 10.29.06 Remove the sole source of CM ambiguities. Find and detach insert states
   *              that are 1 state before an END_E.  */
  cm_find_and_detach_dual_inserts(cm,
				  FALSE, /* Don't check END_E-1 states have 0 counts, they may not if
					  * an old version (0.7 or earlier) of cmbuild was used, or
					  * cmbuild --nodetach  was used to build the CM  */
				  TRUE); /* Detach the states by setting trans probs into them as 0.0   */

  /* check that the clen we calc'ed is the same as the CLEN line said */
  if (read_clen && clen != cm->clen)
	{
	  ESL_XFAIL(eslEFORMAT, cmfp->errbuf, "calculated consensus length %d does not equal read CLEN: %d.\n", clen, cm->clen);
	}

  /* Success.
   * Renormalize the CM, and return.
   */
  CMRenormalize(cm);

  if (buf != NULL) free(buf);
  if (*ret_abc == NULL) *ret_abc = abc;
  if ( opt_cm != NULL)  *opt_cm = cm; else FreeCM(cm);
  return eslOK;

 ERROR:
  if (buf != NULL) free(buf);
  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc);
  if (cm      != NULL) FreeCM(cm);
  if (opt_cm != NULL) *opt_cm = NULL;
  if      (status == eslEMEM || status == eslESYS) return status;
  else if (status == eslEOF)                       return status;
  else if (status == eslEINCOMPAT)                 return status;
  else                                             return eslEFORMAT;	/* anything else is a format error: includes premature EOF, EOL, EOD  */
}

/* Parsing save files from HMMER 3.x
 * All parsers follow the same API.
 *
 * Returns <eslOK> on success, and if <opt_hmm> is non-NULL,
 * <*opt_hmm> points at a newly allocated HMM.
 *
 * Additionally, if <*ret_abc> was NULL, then a new alphabet is
 * allocated according to the alphabet type of this HMM, and returned
 * thru <ret_abc>.  This allocation mechanism allows a main()
 * application that doesn't yet know its alphabet to determine the
 * alphabet when the first HMM is read, while also allowing an
 * application to allocate its own alphabet and assure that the
 * input HMMs are appropriate for that alphabet.
 *
 * Returns <eslEOF> when no HMM remains in the file, indicating a
 * normal end-of-file.
 *
 * Two types of "normal error" may happen, which the caller must check
 * for. Returns <eslEFORMAT> on any save file format error, including
 * bad magic (i.e. this is not a HMMER file at all). Returns
 * <eslEINCOMPAT> if the expected alphabet (a non-<NULL> alphabet
 * specified by <*ret_abc>) does not match the alphabet type of the
 * HMM.
 *
 * When these normal errors occur, the caller can construct its error
 * message from:
 *    <hfp->errbuf>:    contains an informative error message
 *    <hfp->fname>:     name of the HMM file (or '-' if STDIN)
 * and if <hfp->efp> is non-<NULL>, the HMM file is in ASCII text,
 * and the caller may also use:
 *    <hfp->efp->linenumber>: line on which the parse error occurred.
 *
 * Throws:     <eslEMEM> on allocation error.
 *             <eslESYS> if a system i/o call fails.
 *             In cases of error (including both thrown error and normal error), <*ret_abc>
 *             is left in its original state as passed by the caller, and <*ret_hmm> is
 *             returned <NULL>.
 */
static int
read_asc30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm)
{
  ESL_ALPHABET *abc  = NULL;
  P7_HMM       *hmm  = NULL;
  char         *tag  = NULL;
  char         *tok1 = NULL;
  char         *tok2 = NULL;
  char         *tok3 = NULL;
  char         *tok4 = NULL;
  int           alphatype;
  int           k,x;
  off_t         offset = 0;
  int           status;
  uint32_t      statstracker = 0;

  hfp->errbuf[0] = '\0';

  if (hfp->newly_opened)
	{
	  offset            = 0;
	  hfp->newly_opened = FALSE;
	}
  else
	{
	  /* Record where this HMM starts on disk */
	  if ((! hfp->do_stdin) && (! hfp->do_gzip) && (offset = ftello(hfp->f)) < 0)   ESL_XEXCEPTION(eslESYS, "ftello() failed");

	  /* First line of file: "HMMER3/f". Allocate shell for HMM annotation information (we don't know K,M yet) */
	  if ((status = esl_fileparser_NextLine(hfp->efp))                   != eslOK)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No name found on NAME line");  /* EOF here is normal; could also be a thrown EMEM */
	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL)) != eslOK)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "unexpected absence of tokens on data line");

	  if      (hfp->format == p7_HMMFILE_3f) { if (strcmp(tag, "HMMER3/f") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/f tag: bad format or not a HMMER save file?"); }
	  else if (hfp->format == p7_HMMFILE_3e) { if (strcmp(tag, "HMMER3/e") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/e tag: bad format or not a HMMER save file?"); }
	  else if (hfp->format == p7_HMMFILE_3d) { if (strcmp(tag, "HMMER3/d") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/d tag: bad format or not a HMMER save file?"); }
	  else if (hfp->format == p7_HMMFILE_3c) { if (strcmp(tag, "HMMER3/c") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/c tag: bad format or not a HMMER save file?"); }
	  else if (hfp->format == p7_HMMFILE_3b) { if (strcmp(tag, "HMMER3/b") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/b tag: bad format or not a HMMER save file?"); }
	  else if (hfp->format == p7_HMMFILE_3a) { if (strcmp(tag, "HMMER3/a") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/a tag: bad format or not a HMMER save file?"); }
	  else                                                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No such HMM file format code: this shouldn't happen");
	}

  if ((hmm = p7_hmm_CreateShell())                                   == NULL)   ESL_XFAIL(eslEMEM,    hfp->errbuf, "allocation failure, HMM shell");
  hmm->offset = offset;

  /* Header section */
  while ((status = esl_fileparser_NextLine(hfp->efp)) == eslOK)
	{
	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL))     != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "Premature end of line");

	  if (strcmp(tag, "NAME") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No name found on NAME line");
	p7_hmm_SetName(hmm, tok1);
	  }

	  else if (strcmp(tag, "ACC") == 0)  {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No accession found on ACC line");
	p7_hmm_SetAccession(hmm, tok1);
	  }

	  else if (strcmp(tag, "DESC") == 0) {
	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))      != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No description found on DESC line");
	p7_hmm_SetDescription(hmm, tok1);
	  }

	  else if (strcmp(tag, "LENG") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No model length found on LENG line");
	if ((hmm->M = atoi(tok1))                                            == 0)  	 ESL_XFAIL(status,    hfp->errbuf, "Invalid model length %s on LENG line", tok1);
	  }

	  else if (hfp->format >= p7_HMMFILE_3c && strcmp(tag, "MAXL") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No max length found on MAXL line");
	if ((hmm->max_length = atoi(tok1))                                   == 0)  	 ESL_XFAIL(status,    hfp->errbuf, "Invalid max length %s on MAXL line", tok1);
	  }

	  else if (strcmp(tag, "ALPH") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No alphabet type found on ALPH");
	if ((alphatype = esl_abc_EncodeType(tok1))                        == eslUNKNOWN) ESL_XFAIL(status,    hfp->errbuf, "Unrecognized alphabet type %s", tok1);
	if (*ret_abc == NULL) {
	  if ((abc = esl_alphabet_Create(alphatype))                        == NULL) 	 ESL_XFAIL(eslEMEM,   hfp->errbuf, "Failed to create alphabet");
	} else {
	  if ((*ret_abc)->type != alphatype)	                                         ESL_XFAIL(eslEINCOMPAT,hfp->errbuf,"Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( (*ret_abc)->type), tok1);
	  abc = *ret_abc;
	}
	  }

	  else if (strcmp(tag, "RF") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    hfp->errbuf, "No yes/no found for RF line");
	if      (strcasecmp(tok1, "yes") == 0)
	  hmm->flags |= p7H_RF;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "RF header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "MM") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    hfp->errbuf, "No yes/no found for MM line");
	if      (strcasecmp(tok1, "yes") == 0)
	  hmm->flags |= p7H_MMASK;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "MM header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "CONS") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for CONS line");
	if (strcasecmp(tok1, "yes") == 0)
	  hmm->flags |= p7H_CONS;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "CONS header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "CS") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for CS line");
	if (strcasecmp(tok1, "yes") == 0)
	  hmm->flags |= p7H_CS;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "CS header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "MAP") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for MAP line");
	if      (strcasecmp(tok1, "yes") == 0)
	  hmm->flags |= p7H_MAP;
	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "MAP header line must say yes/no, not %s", tok1);
	  }

	  else if (strcmp(tag, "DATE") == 0) {
	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No date found on DATE line");
	if (esl_strdup(tok1, -1, &(hmm->ctime))                               != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "strdup() failed to set date");
	  }

	  else if (strcmp(tag, "COM") == 0) {
	/* just skip the first token; it's something like [1], numbering the command lines */
	if ((status = esl_fileparser_GetTokenOnLine  (hfp->efp, &tok1, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No command number on COM line");
	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No command on COM line");
	if (hmm->comlog == NULL) {
	  if (esl_strdup(tok1, -1, &(hmm->comlog))                            != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strdup() failed");
	} else {
	  if (esl_strcat(&(hmm->comlog), -1, "\n", -1)                        != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
	  if (esl_strcat(&(hmm->comlog), -1, tok1,  -1)                       != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
	}
	  }

	  else if (strcmp(tag, "NSEQ") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows NSEQ tag");
	if ((hmm->nseq = atoi(tok1)) == 0)                                               ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Invalid nseq on NSEQ line: should be integer, not %s", tok1);
	  }

	  else if (strcmp(tag, "EFFN") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows EFFN tag");
	if ((hmm->eff_nseq = atof(tok1)) <= 0.0f)                                        ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Invalid eff_nseq on EFFN line: should be a real number, not %s", tok1);
	  }

	  else if (strcmp(tag, "CKSUM") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows CKSUM tag");
	hmm->checksum = atoll(tok1); /* if atoi(), then you may truncate uint32_t checksums > 2^31-1 */
	hmm->flags |= p7H_CHKSUM;
	  }

	  else if (strcmp(tag, "STATS") == 0) {
	if (hfp->format >= p7_HMMFILE_3b)
	  {
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* LOCAL */
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* MSV | VITERBI | FORWARD */
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok3, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* mu | tau */
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok4, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* lambda */
	    if (strcasecmp(tok1, "LOCAL") == 0)
	      {
		if      (strcasecmp(tok2, "MSV")     == 0)  { hmm->evparam[p7_MMU]  = atof(tok3); hmm->evparam[p7_MLAMBDA] = atof(tok4); statstracker |= 0x1; }
		else if (strcasecmp(tok2, "VITERBI") == 0)  { hmm->evparam[p7_VMU]  = atof(tok3); hmm->evparam[p7_VLAMBDA] = atof(tok4); statstracker |= 0x2; }
		else if (strcasecmp(tok2, "FORWARD") == 0)  { hmm->evparam[p7_FTAU] = atof(tok3); hmm->evparam[p7_FLAMBDA] = atof(tok4); statstracker |= 0x4; }
		else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 3", tok2);
	      } else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 2", tok1);
	  }
	else if (hfp->format == p7_HMMFILE_3a) /* reverse compatibility with 30a */
	  {
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* LOCAL */
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* VLAMBDA | VMU | FTAU */
	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok3, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* value */
	    if (strcasecmp(tok1, "LOCAL") == 0)
	      {
		if      (strcasecmp(tok2, "VLAMBDA") == 0)  { hmm->evparam[p7_MLAMBDA] = hmm->evparam[p7_VLAMBDA] = hmm->evparam[p7_FLAMBDA] = atof(tok3);  statstracker |= 0x1; }
		else if (strcasecmp(tok2, "VMU")     == 0)  {                            hmm->evparam[p7_MMU]     = hmm->evparam[p7_VMU]     = atof(tok3);  statstracker |= 0x2; }
		else if (strcasecmp(tok2, "FTAU")    == 0)  {                                                       hmm->evparam[p7_FTAU]    = atof(tok3);  statstracker |= 0x4; }
		else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 3", tok2);
	      } else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 2", tok1);
	  }
	  }

	  else if (strcmp(tag, "GA") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
	hmm->cutoff[p7_GA1] = atof(tok1);
	hmm->cutoff[p7_GA2] = atof(tok2);
	hmm->flags         |= p7H_GA;
	  }

	  else if (strcmp(tag, "TC") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
	  hmm->cutoff[p7_TC1] = atof(tok1);
	  hmm->cutoff[p7_TC2] = atof(tok2);
	  hmm->flags         |= p7H_TC;
	  }

	  else if (strcmp(tag, "NC") == 0) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
	  hmm->cutoff[p7_NC1] = atof(tok1);
	  hmm->cutoff[p7_NC2] = atof(tok2);
	  hmm->flags         |= p7H_NC;
	  }

	  else if (strcmp(tag, "HMM") == 0)
	break;
	} /* end, loop over possible header tags */
  if (status != eslOK) goto ERROR;

  /* If we saw one STATS line, we need all 3. (True for both 3/a and 3/b formats) */
  if      (statstracker == 0x7) hmm->flags |= p7H_STATS;
  else if (statstracker != 0x0) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Missing one or more STATS parameter lines");

  /* Skip main model header lines; allocate body of HMM now that K,M are known */
  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
  if ((status = p7_hmm_CreateBody(hmm, hmm->M, abc))                          != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to allocate body of the new HMM");
  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");

  /* Optional model composition (filter null model) may immediately follow headers */
  if (strcmp(tok1, "COMPO") == 0) {
	for (x = 0; x < abc->K; x++)  {
	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on COMPO line");
	  hmm->compo[x] = (*tok1 == '*' ? 0.0 : expf(-1.0 * atof(tok1)));
	}
	hmm->flags |= p7H_COMPO;
	if ((status = esl_fileparser_NextLine(hfp->efp))                          != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data after COMPO line");
	if ((esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))                != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data after COMPO line");
  }

  /* First two lines are node 0: insert emissions, then transitions from node 0 (begin) */

  hmm->ins[0][0] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
  for (x = 1; x < abc->K; x++) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on insert line, node 0: expected %d, got %d\n", abc->K, x);
	hmm->ins[0][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
  }
  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no node 0 transition line");
  for (x = 0; x < p7H_NTRANSITIONS; x++) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on begin (0) transition line");
	hmm->t[0][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
  }

  /* The main model section. */
  for (k = 1; k <= hmm->M; k++)
	{
	  if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
	  if (atoi(tok1) != k)                                                               ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected match line to start with %d (of %d); saw %s", k, hmm->M, tok1);

	  for (x = 0; x < abc->K; x++) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on match line, node %d: expected %d, got %d\n", k, abc->K, x);
	  hmm->mat[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
	  }

	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing MAP field on match line for node %d: should at least be -", k);
	  if (hmm->flags & p7H_MAP) hmm->map[k] = atoi(tok1);

	  if (hfp->format >= p7_HMMFILE_3e) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing CONS field on match line for node %d: should at least be -", k);
	if (hmm->flags & p7H_CONS) hmm->consensus[k] = *tok1;
	  }

	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing RF field on match line for node %d: should at least be -",  k);
	  if (hmm->flags & p7H_RF) hmm->rf[k]   = *tok1;

	  if (hfp->format >= p7_HMMFILE_3f) {
		if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing MM field on match line for node %d: should at least be -", k);
		if (hmm->flags & p7H_MMASK) hmm->mm[k] = *tok1;
	  }

	  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing CS field on match line for node %d: should at least be -",  k);
	  if (hmm->flags & p7H_CS) hmm->cs[k]   = *tok1;

	  if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no insert emission line, node %d", k);
	  for (x = 0; x < abc->K; x++) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on insert line, node %d: expected %d, got %d\n", k, abc->K, x);
	hmm->ins[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
	  }

	  if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no transition line, node %d", k);
	  for (x = 0; x < p7H_NTRANSITIONS; x++) {
	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on transition line, node %d: expected %d, got %d\n", k, abc->K, x);
	hmm->t[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
	  }
	}

  /* The closing // */
  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
  if (strcmp(tok1, "//")                                                      != 0)      ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected closing //; found %s instead", tok1);

  /* legacy issues */
  if (hfp->format < p7_HMMFILE_3e && (status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to set consensus on legacy HMM format");

  /* Finish up. */
  if (hmm->flags & p7H_RF)   { hmm->rf[0]        = ' '; hmm->rf[hmm->M+1]        = '\0'; }
  if (hmm->flags & p7H_MMASK){ hmm->mm[0]        = ' '; hmm->mm[hmm->M+1]        = '\0'; }
  if (hmm->flags & p7H_CONS) { hmm->consensus[0] = ' '; hmm->consensus[hmm->M+1] = '\0'; }
  if (hmm->flags & p7H_CS)   { hmm->cs[0]        = ' '; hmm->cs[hmm->M+1]        = '\0'; }
  if (hmm->flags & p7H_MAP)  { hmm->map[0]       = 0; }
  if (hmm->name == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No NAME found for HMM");
  if (hmm->M    <= 0)       ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No LENG found for HMM (or LENG <= 0)");
  if (abc       == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No ALPH found for HMM");

  if (*ret_abc == NULL) *ret_abc = abc;
  if ( opt_hmm != NULL) *opt_hmm = hmm; else p7_hmm_Destroy(hmm);
  return eslOK;

 ERROR:
  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc);
  if (hmm     != NULL) p7_hmm_Destroy(hmm);
  if (opt_hmm != NULL) *opt_hmm = NULL;
  if      (status == eslEMEM || status == eslESYS) return status;
  else if (status == eslEOF)                       return status;
  else if (status == eslEINCOMPAT)                 return status;
  else                                             return eslEFORMAT;	/* anything else is a format error: includes premature EOF, EOL, EOD  */
}

static int
read_bin30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm)
{
  ESL_ALPHABET *abc = NULL;
  P7_HMM       *hmm = NULL;
  uint32_t      magic;
  int           alphabet_type;
  int           k;
  off_t         offset = 0;
  int           status;

  hfp->errbuf[0] = '\0';
  if (feof(hfp->f))                                             { status = eslEOF;       goto ERROR; }

  if (hfp->newly_opened)
	{
	  offset = 0;
	  hfp->newly_opened = FALSE;
	}
  else
	{  /* Check magic. */
	  if ((!hfp->do_stdin) && (! hfp->do_gzip)) {
	if ((offset = ftello(hfp->f)) < 0)                          ESL_XEXCEPTION(eslESYS, "ftello() failed");
	  }
	  if (! fread((char *) &magic, sizeof(uint32_t), 1, hfp->f))    { status = eslEOF;       goto ERROR; }

	  if      (hfp->format == p7_HMMFILE_3f) { if (magic != v3f_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else if (hfp->format == p7_HMMFILE_3e) { if (magic != v3e_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else if (hfp->format == p7_HMMFILE_3d) { if (magic != v3d_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else if (hfp->format == p7_HMMFILE_3c) { if (magic != v3c_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else if (hfp->format == p7_HMMFILE_3b) { if (magic != v3b_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else if (hfp->format == p7_HMMFILE_3a) { if (magic != v3a_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
	  else                                                              ESL_XFAIL(eslEFORMAT, hfp->errbuf, "no such HMM file format code");
	}

  /* Allocate shell of the new HMM.
   * Two-step allocation lets us read/set the flags first;
   * then the later CreateBody() call will allocate optional internal fields we need.
   */
  if ((hmm = p7_hmm_CreateShell()) == NULL)                     ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, HMM shell");
  hmm->offset = offset;

  /* Get sizes of things */
  /* xref J5/114 for a legacy use of <flags> for optional acc, desc annotation */
  if (! fread((char *) &(hmm->flags),  sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read flags");
  if (! fread((char *) &(hmm->M),      sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read model size M");
  if (! fread((char *) &alphabet_type, sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read alphabet_type");

  /* Set or verify alphabet. */
  if (*ret_abc == NULL)	{	/* still unknown: set it, pass control of it back to caller */
	if ((abc = esl_alphabet_Create(alphabet_type)) == NULL)     ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, alphabet");
  } else {			/* already known: check it */
	abc = *ret_abc;
	if (abc->type != alphabet_type)                             ESL_XFAIL(eslEINCOMPAT, hfp->errbuf, "Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( abc->type), esl_abc_DecodeType(alphabet_type));
  }

  /* Finish the allocation of the HMM
   */
  if ((status = p7_hmm_CreateBody(hmm, hmm->M, abc)) != eslOK)  ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, HMM body");

  /* Core model probabilities. */
  for (k = 1; k <= hmm->M; k++)
	if (! fread((char *) hmm->mat[k], sizeof(float), hmm->abc->K,      hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read mat[%d]", k);
  for (k = 0; k <= hmm->M; k++)
	if (! fread((char *) hmm->ins[k], sizeof(float), hmm->abc->K,      hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ins[%d]", k);
  for (k = 0; k <= hmm->M; k++)
	if (! fread((char *) hmm->t[k],   sizeof(float), p7H_NTRANSITIONS, hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read t[%d]", k);

  /* Annotations. */
  if (read_bin_string(hfp->f, &(hmm->name)) != eslOK)                                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read name");
  if ((hmm->flags & p7H_ACC)  && read_bin_string(hfp->f, &(hmm->acc))  != eslOK)                     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read acc");
  if ((hmm->flags & p7H_DESC) && read_bin_string(hfp->f, &(hmm->desc)) != eslOK)                     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read desc");
  if ((hmm->flags & p7H_RF)   && ! fread((char *) hmm->rf,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read rf");   /* +2: 1..M and trailing \0 */
  if ((hmm->flags & p7H_MMASK)&& ! fread((char *) hmm->mm,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read mm");   /* +2: 1..M and trailing \0 */
  if ((hmm->flags & p7H_CONS) && ! fread((char *) hmm->consensus, sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read consensus"); /* don't need to test for >=3e format, because the flag is sufficient (didn't exist pre-3e) */
  if ((hmm->flags & p7H_CS)   && ! fread((char *) hmm->cs,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read cs");
  if ((hmm->flags & p7H_CA)   && ! fread((char *) hmm->ca,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ca");
  if (read_bin_string(hfp->f, &(hmm->comlog)) != eslOK)                                              ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read comlog");
  if (! fread((char *) &(hmm->nseq),       sizeof(int),   1, hfp->f))                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read nseq");
  if (! fread((char *) &(hmm->eff_nseq),   sizeof(float), 1, hfp->f))                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read eff_nseq");
  if (hfp->format >= p7_HMMFILE_3c) {
	if (! fread((char *) &(hmm->max_length), sizeof(int),   1, hfp->f))                         ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read max_length");
  }
  if (read_bin_string(hfp->f, &(hmm->ctime))  != eslOK)                                       ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ctime");
  if ((hmm->flags & p7H_MAP)  && ! fread((char *) hmm->map, sizeof(int), hmm->M+1, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read map");
  if (! fread((char *) &(hmm->checksum), sizeof(uint32_t),1,hfp->f))                          ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read checksum");

  /* E-value parameters and Pfam cutoffs */
  if (hfp->format >= p7_HMMFILE_3b) {
	if (! fread((char *) hmm->evparam, sizeof(float), p7_NEVPARAM, hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read statistical params");
  } else if (hfp->format == p7_HMMFILE_3a) {
	/* a backward compatibility mode. 3/a files stored 3 floats: LAMBDA, MU, TAU. Read 3 #'s and carefully copy/rearrange them into new 6 format */
	if (! fread((char *) hmm->evparam, sizeof(float), 3,           hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read statistical params");
	hmm->evparam[p7_FLAMBDA] = hmm->evparam[0];
	hmm->evparam[p7_FTAU]    = hmm->evparam[2];
	hmm->evparam[p7_VLAMBDA] = hmm->evparam[0];
	hmm->evparam[p7_VMU]     = hmm->evparam[1];
	hmm->evparam[p7_MLAMBDA] = hmm->evparam[p7_VLAMBDA];
	hmm->evparam[p7_MMU]     = hmm->evparam[p7_VMU];
  }
  if (! fread((char *) hmm->cutoff,  sizeof(float), p7_NCUTOFFS, hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read Pfam score cutoffs");
  if ((hmm->flags & p7H_COMPO) && ! fread((char *) hmm->compo, sizeof(float), hmm->abc->K, hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read model composition");

  /* other legacy issues */
  if (hfp->format < p7_HMMFILE_3e && (status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to set consensus on legacy HMM format");

  if (*ret_abc == NULL) *ret_abc = abc;	/* pass our new alphabet back to caller, if caller didn't know it already */
  if ( opt_hmm != NULL) *opt_hmm = hmm; else p7_hmm_Destroy(hmm);
  return eslOK;

 ERROR:
  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc); /* the test is for an alphabet created here, not passed */
  if (hmm     != NULL) p7_hmm_Destroy(hmm);
  if (opt_hmm != NULL) *opt_hmm = NULL;
  return status;
}
/*--------------- end, private format parsers -------------------*/

/*****************************************************************
 * 6. Other private functions involved in i/o
 *****************************************************************/

/*****************************************************************
 * Some miscellaneous utility functions
 *****************************************************************/

/* Function: read_bin_string()
 * Date:     SRE, Wed Oct 29 14:03:23 1997 [TWA 721]
 *
 * Purpose:  Read in a string from a binary file, where
 *           the first integer is the length (including '\0').
 *           If the length is 0, <*ret_s> is set to <NULL>.
 *
 *           This is a reasonable convention for storing/ reading
 *           strings in binary files. Note that because the length is
 *           inclusive of '\0', there's a difference between a NULL
 *           string and an empty string.
 *
 * Args:     fp       - FILE to read from
 *           ret_s    - string to read into
 *
 * Return:   <eslOK> on success. ret_s is malloc'ed here.
 *           <eslEOD> if a read fails - likely because no more
 *             data in file.
 *
 * Throws    <eslEMEM> on allocation error.
 */
static int
read_bin_string(FILE *fp, char **ret_s)
{
  int   status;
  char *s = NULL;
  int   len;

  if (! fread((char *) &len, sizeof(int), 1, fp)) { status = eslEOD; goto ERROR; }
  if (len > 0) {
	ESL_ALLOC(s,  (sizeof(char) * len));
	if (! fread((char *) s, sizeof(char), len, fp)) { status = eslEOD; goto ERROR; }
  }
  *ret_s = s;
  return eslOK;

 ERROR:
  if (s != NULL) free(s);
  *ret_s = NULL;
  return status;
}

/* Function: prob2ascii()
 *
 * Purpose:  Format a probability for output to an ASCII save
 *           file. Returns a ptr to a static internal buffer.
 *
 */
static char *
prob2ascii(float p, float null)
{
  static char buffer[32];

  if (p == 0.0) return "*";
  sprintf(buffer, "%.3f", sreLOG2(p/null));
  return buffer;
}

/* Function: ascii2prob()
 *
 * Purpose:  Convert a saved string back to a probability.
 */
static float
ascii2prob(char *s, float null)
{
  return (*s == '*') ? 0. : exp(atof(s)/1.44269504)*null;
}

/* EPN, Tue Aug  7 15:54:15 2007
 * is_integer() and is_real(), savagely ripped verbatim out
 * of Easel's esl_getopts.c, where they were private.
 */
/* Function: is_integer()
 *
 * Returns TRUE if <s> points to something that atoi() will parse
 * completely and convert to an integer.
 */
static int
is_integer(char *s)
{
  int hex = 0;

  if (s == NULL) return 0;
  while (isspace((int) (*s))) s++;      /* skip whitespace */
  if (*s == '-' || *s == '+') s++;      /* skip leading sign */
				        /* skip leading conversion signals */
  if ((strncmp(s, "0x", 2) == 0 && (int) strlen(s) > 2) ||
	  (strncmp(s, "0X", 2) == 0 && (int) strlen(s) > 2))
	{
	  s += 2;
	  hex = 1;
	}
  else if (*s == '0' && (int) strlen(s) > 1)
	s++;
				/* examine remainder for garbage chars */
  if (!hex)
	while (*s != '\0')
	  {
	if (!isdigit((int) (*s))) return 0;
	s++;
	  }
  else
	while (*s != '\0')
	  {
	if (!isxdigit((int) (*s))) return 0;
	s++;
	  }
  return 1;
}

/* is_real()
 *
 * Returns TRUE if <s> is a string representation
 * of a valid floating point number, convertable
 * by atof().
 */
static int
is_real(char *s)
{
  int gotdecimal = 0;
  int gotexp     = 0;
  int gotreal    = 0;

  if (s == NULL) return 0;

  while (isspace((int) (*s))) s++; /* skip leading whitespace */
  if (*s == '-' || *s == '+') s++; /* skip leading sign */

  /* Examine remainder for garbage. Allowed one '.' and
   * one 'e' or 'E'; if both '.' and e/E occur, '.'
   * must be first.
   */
  while (*s != '\0')
	{
	  if (isdigit((int) (*s))) 	gotreal++;
	  else if (*s == '.')
	{
	  if (gotdecimal) return 0; /* can't have two */
	  if (gotexp) return 0;     /* e/E preceded . */
	  else gotdecimal++;
	}
	  else if (*s == 'e' || *s == 'E')
	{
	  if (gotexp) return 0;	/* can't have two */
	  else gotexp++;
	}
	  else if (isspace((int) (*s)))
	break;
	  s++;
	}

  while (isspace((int) (*s))) s++;         /* skip trailing whitespace */
  if (*s == '\0' && gotreal) return 1;
  else return 0;
}

/*---------------- end, private utilities -----------------------*/

/*****************************************************************
 * 7. Legacy v1.0 ascii file format output.
 *****************************************************************/

/* Function:  cm_file_Write1p0Ascii()
 * Incept:    EPN, Tue Feb 28 14:35:47 2012
 *
 * Purpose:   Write a CM in version 1.0 format.
 *            cm_io.c:write_ascii_cm() from Infernal 1.0.2
 *            was used as the starting point for this function.
 *
 *            Calibration parameters: E-values and HMM filter
 *            thresholds are not written here. This is because 1.0
 *            expects either both E-values and HMM filter thresholds
 *            or neither and HMM filter thresholds don't exist
 *            in the new format.
 *
 * Returns: eslOK on success;
 */
int
cm_file_Write1p0ASCII(FILE *fp, CM_t *cm)
{
  int status;
  int v,x,y,nd;
  char *comlog2print  = NULL;

  fprintf(fp, "INFERNAL-1 [converted from %s]\n", INFERNAL_VERSION);

  fprintf(fp,                          "NAME     %s\n", cm->name);
  if (cm->acc  != NULL)    fprintf(fp, "ACC      %s\n", cm->acc);
  if (cm->desc != NULL)    fprintf(fp, "DESC     %s\n", cm->desc);
  /* Rfam cutoffs */
  if (cm->flags & CMH_GA)  fprintf(fp, "GA       %.2f\n", cm->ga);
  if (cm->flags & CMH_TC)  fprintf(fp, "TC       %.2f\n", cm->tc);
  if (cm->flags & CMH_NC)  fprintf(fp, "NC       %.2f\n", cm->nc);
  fprintf(fp, "STATES   %d\n",   cm->M);
  fprintf(fp, "NODES    %d\n",   cm->nodes);
  fprintf(fp, "ALPHABET %d\n",   cm->abc->type);
  fprintf(fp, "ELSELF   %.8f\n", cm->el_selfsc);
  fprintf(fp, "WBETA    %g\n",   cm->beta_W);
  fprintf(fp, "NSEQ     %d\n",   cm->nseq);
  fprintf(fp, "EFFNSEQ  %.3f\n", cm->eff_nseq);
  fprintf(fp, "CLEN     %d\n",   cm->clen);

  /* Print out the BCOM line as the cm->comlog string up to the first
   * '\n' or the end of the string. Print cm->ctime as BDATE. We
   * don't print CCOM and CDATE. This should be okay because we won't
   * likely have E-value and HMM filter stats since we're probably
   * converting from a 1.1 or later file. But it is possible we're
   * converting from a 1.0 file to a 1.0 file in which case we output
   * E-value stats and filter threshold stats but no CCOM and CDATE
   * lines.  This won't affect the parsing of the file by 1.0 though.
   */
  if(cm->comlog != NULL) {
	ESL_ALLOC(comlog2print, sizeof(char) * (strlen(cm->comlog)+1));
	x = 0;
	while(x < strlen(cm->comlog) && cm->comlog[x] != '\n') { comlog2print[x] = cm->comlog[x]; x++; }
	comlog2print[x] = '\0';
	fprintf(fp, "BCOM     %s\n", comlog2print);
	free(comlog2print);
  }
  if(cm->ctime != NULL) fprintf(fp, "BDATE    %s\n", cm->ctime);

  fputs(      "NULL    ", fp);
  for (x = 0; x < cm->abc->K; x++)
	fprintf(fp, "%6s ", prob2ascii(cm->null[x], 1/(float)(cm->abc->K)));
  fputs("\n", fp);

  /* E-value statistics skipped in converted output
   * mainly because HMM filter thresholds no longer exist
   * in current version so we can't output them here.
   */
  /* main model section */
  fputs("MODEL:\n", fp);
  for (v = 0; v < cm->M; v++)
	{
	  nd = cm->ndidx[v];

	  /* Node line.
	   */
	  if (cm->nodemap[nd] == v)
	fprintf(fp, "\t\t\t\t[ %-4s %4d ]\n", Nodetype(cm->ndtype[nd]), nd);

	  /* State line, w/ parents, children, and transitions
	   */
	  fprintf(fp, "    %2s %5d %5d %1d %5d %5d ",
	      Statetype(cm->sttype[v]), v,
	      cm->plast[v], cm->pnum[v],
	      cm->cfirst[v], cm->cnum[v]);
	  if (cm->sttype[v] != B_st)
	for (x = 0; x < cm->cnum[v]; x++)
	  fprintf(fp, "%7s ", prob2ascii(cm->t[v][x], 1.));
	  else x = 0;
	  for (; x < 6; x++)
	fprintf(fp, "%7s ", "");

	  /* Emission line
	   */
	  if (cm->sttype[v] == MP_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    for (y = 0; y < cm->abc->K; y++)
	      fprintf(fp, "%6s ", prob2ascii(cm->e[v][x*cm->abc->K+y], cm->null[x]*cm->null[y]));
	}
	  else if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st || cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	{
	  for (x = 0; x < cm->abc->K; x++)
	    fprintf(fp, "%6s ", prob2ascii(cm->e[v][x], cm->null[x]));
	}
	  fputs("\n", fp);
	}
  fputs("//\n", fp);
  return eslOK;

 ERROR:
  ESL_EXCEPTION(eslEMEM, "out of memory");
  return status;
}

/* multiline()
 *
 * Stolen from HMMER3, verbatim.
 *
 * Used to print the command log to ASCII save files.
 *
 * Given a record (like the comlog) that contains
 * multiple lines, print it as multiple lines with
 * a given prefix. e.g.:
 *
 * given:   "COM   ", "foo\nbar\nbaz"
 * print:   COM   1 foo
 *          COM   2 bar
 *          COM   3 baz
 *
 * If <s> is NULL, no-op. Otherwise <s> must be a <NUL>-terminated
 * string.  It does not matter if it ends in <\n> or not. <pfx>
 * must be a valid <NUL>-terminated string; it may be empty.
 *
 * Args:     fp:   FILE to print to
 *           pfx:  prefix for each line
 *           s:    line to break up and print; tolerates a NULL
 *
 * Returns: <eslOK> on success.
 *
 * Throws:  <eslEWRITE> on write error.
 */
static int
multiline(FILE *fp, const char *pfx, char *s)
{
  char *sptr  = s;
  char *end   = NULL;
  int   n     = 0;
  int   nline = 1;

  do {
	end = strchr(sptr, '\n');

	if (end != NULL)                  /* if there's no \n left, end == NULL */
	  {
  n = end - sptr;                       /* n chars exclusive of \n */
  if (fprintf(fp, "%s [%d] ", pfx, nline++) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
  if (fwrite(sptr, sizeof(char), n, fp)    != n) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");  /* using fwrite lets us write fixed # of chars   */
  if (fprintf(fp, "\n")                     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");  /* while writing \n w/ printf allows newline conversion */
  sptr += n + 1;                       /* +1 to get past \n */
	  }
	else
	  {
  if (fprintf(fp, "%s [%d] %s\n", pfx, nline++, sptr) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); /* last line */
	  }
  } while (end != NULL  && *sptr != '\0');   /* *sptr == 0 if <s> terminates with a \n */
  return eslOK;
}

/*****************************************************************
 * 8. Benchmark driver.
 *****************************************************************/
#ifdef CM_FILE_BENCHMARK
/*
  gcc -pthread -std=gnu99 -g -Wall -static -o cm_file_benchmark -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DCM_FILE_BENCHMARK cm_file.c -linfernal -lhmmer -leasel -lm
  icc -pthread                 -O3 -static -o cm_file_benchmark -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DCM_FILE_BENCHMARK cm_file.c -linfernal -lhmmer -leasel -lm
  ./cm_file_benchmark Rfam.cm
 */


#include <stdlib.h>
#include <stdio.h>


static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                  docgroup*/
  { "-h",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",  0 },
  { "-a",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "include time of CM configuration", 0 },
  { "-v",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "verbose: print model info as they're read", 0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <CM file>";
static char banner[] = "benchmark driver for CM input";

int
main(int argc, char **argv)
{
  ESL_GETOPTS   *go       = cm_CreateDefaultApp(options, 1, argc, argv, banner, usage);
  ESL_STOPWATCH *w        = esl_stopwatch_Create();
  ESL_STOPWATCH *w2       = esl_stopwatch_Create();
  ESL_ALPHABET  *abc      = NULL;
  char          *cmfile   = esl_opt_GetArg(go, 1);
  CM_FILE       *cmfp     = NULL;
  CM_t          *cm       = NULL;
  int            nmodel   = 0;
  uint64_t       tot_clen = 0;
  int            status;
  int            be_verbose = esl_opt_GetBoolean(go, "-v");
  char           errbuf[eslERRBUFSIZE];

  esl_stopwatch_Start(w);

  status = cm_file_Open(cmfile, NULL, FALSE, &cmfp, errbuf);
  if      (status == eslENOTFOUND) cm_Fail("File existence/permissions problem in trying to open CM file %s.\n%s\n", cmfile, errbuf);
  else if (status == eslEFORMAT)   cm_Fail("File format problem in trying to open CM file %s.\n%s\n",                cmfile, errbuf);
  else if (status != eslOK)        cm_Fail("Unexpected error %d in opening CM file %s.\n%s\n",               status, cmfile, errbuf);
  if      (cmfp->do_gzip)          cm_Fail("Reading gzipped CM files is not supported");
  if      (cmfp->do_stdin)         cm_Fail("Reading CM files from stdin is not supported");

  if(be_verbose) esl_stopwatch_Start(w2);
  while ((status = cm_file_Read(cmfp, &abc, &cm)) == eslOK)
	{
	  nmodel++;
	  tot_clen += cm->clen;

	  if (esl_opt_GetBoolean(go, "-a")) {
	if((status = cm_Configure(cm, errbuf, -1)) != eslOK) cm_Fail(errbuf);
	  }

	  if(be_verbose) {
	esl_stopwatch_Stop(w2);
	printf("%-30s  ", cm->name);
	esl_stopwatch_Display(stdout, w2, "CPU time: ");
	esl_stopwatch_Start(w2);
	  }
	  FreeCM(cm);
	}
  if      (status == eslEFORMAT)   cm_Fail("bad file format in CM file %s\n%s",             cmfile, cmfp->errbuf);
  else if (status == eslEINCOMPAT) cm_Fail("CM file %s contains different alphabets\n%s",   cmfile, cmfp->errbuf);
  else if (status != eslEOF)       cm_Fail("Unexpected error in reading CMs from %s\n%s",   cmfile, cmfp->errbuf);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time: ");
  printf("# number of models: %d\n", nmodel);
  printf("# total clen:       %" PRId64 "\n", tot_clen);

  cm_file_Close(cmfp);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_stopwatch_Destroy(w2);
  esl_getopts_Destroy(go);
  return 0;
}
#endif /*cm_FILE_BENCHMARK*/
/*---------------- end, benchmark driver ------------------------*/

/*****************************************************************
 * 9. Example.
 *****************************************************************/
/* On using the example to test error messages from cm_file_Open():
 *    Message
 *  --------------
 *  .gz file missing/not readable     \rm test.cm.gz; touch test.cm.gz; src/cmfile_example test.cm.gz
 *  gzip -dc doesn't exist            \cp testsuite/20aa.cm test.cm; gzip test.cm; sudo mv /usr/bin/gzip /usr/bin/gzip.old; src/cmfile_example test.cm.gz
 *  cm file not found                 \rm test.cm; src/cmfile_example test.cm
 *  bad SSI file format               \cp testsuite/20aa.cm test.cm; \rm test.cm.ssi; touch test.cm.ssi; src/cmfile_example test.cm
 *  64-bit SSI on 32-bit sys
 *  empty file                        \rm test.cm; touch test.cm
 *  unrecognized format (binary)      cat testsuite/20aa.cm > test.cm; src/cmpress test.cm; \rm test.cm; [edit test.cm.h3m, delete first byte]
 *  unrecognized format (ascii)       cat testsuite/20aa.cm | sed -e 's/^HMMER3\/b/HMMER3\/x/' > test.hmm
 *
 */

#ifdef CMFILE_EXAMPLE
/* gcc -g -Wall -DCMFILE_EXAMPLE -I. -I../easel -L. -L../easel -o cmfile_example cm_file.c -linfernal -lhmmer -leasel -lm
 */

int
main(int argc, char **argv)
{
  char         *cmfile = argv[1];
  CM_FILE      *cmfp   = NULL;
  CM_t         *cm     = NULL;
  ESL_ALPHABET *abc    = NULL;
  char          errbuf[eslERRBUFSIZE];
  int           status;

  /* An example of reading a single CM from a file, and checking that it is the only one. */
  status = cm_file_Open(cmfile, NULL, FALSE, &cmfp, errbuf);
  if      (status == eslENOTFOUND) cm_Fail("File existence/permissions problem in trying to open CM file %s.\n%s\n", cmfile, errbuf);
  else if (status == eslEFORMAT)   cm_Fail("File format problem in trying to open CM file %s.\n%s\n",                cmfile, errbuf);
  else if (status != eslOK)        cm_Fail("Unexpected error %d in opening CM file %s.\n%s\n",               status, cmfile, errbuf);

  status = cm_file_Read(cmfp, TRUE, &abc, &cm);
  if      (status == eslEFORMAT)   cm_Fail("Bad file format in CM file %s:\n%s\n",          cmfp->fname, cmfp->errbuf);
  else if (status == eslEINCOMPAT) cm_Fail("CM in %s is not in the expected %s alphabet\n", cmfp->fname, esl_abc_DecodeType(abc->type));
  else if (status == eslEOF)       cm_Fail("Empty CM file %s? No CM data found.\n",         cmfp->fname);
  else if (status != eslOK)        cm_Fail("Unexpected error in reading CMs from %s\n",     cmfp->fname);

  status = cm_file_Read(cmfp, TRUE, &abc, NULL);
  if (status != eslEOF)            cm_Fail("CM file %s does not contain just one CM\n", cmfp->fname);

  cm_file_Close(cmfp);

  cm_file_WriteASCII(stdout, -1, cm);

  esl_alphabet_Destroy(abc);
  FreeCM(cm);
  return 0;
}
#endif /*CMFILE_EXAMPLE*/
/*----------------------- end, example --------------------------*/

/*****************************************************************
 * Infernal - inference of RNA secondary structure alignments
 * Version 1.1.2; July 2016
 * Copyright (C) 2016 Howard Hughes Medical Institute.
 * Other copyrights also apply. See the COPYRIGHT file for a full list.
 *
 * Infernal is distributed under the terms of the GNU General Public License
 * (GPLv3). See the LICENSE file for details.
 *
 * SVN $Id$
 * SVN $URL$
 *****************************************************************/

/*** End of inlined file: cm_file.c ***/


/*** Start of inlined file: cm_modelconfig.c ***/


#include <string.h>


static void  cm_localize(CM_t *cm, float p_internal_entry, float p_internal_exit);
static  int  cp9_sw_config(CP9_t *hmm, float pentry, float pexit, int do_match_local_cm, int first_cm_ndtype);
static  int  cp9_EL_local_ends_config(CP9_t *cp9, CM_t *cm, char *errbuf);
static void  cp9_renormalize_exits(CP9_t *hmm);

/* Function: cm_Configure()
 * Date:     EPN, Thu Jan  4 06:36:09 2007
 *           EPN, Fri Dec  9 15:27:29 2011 [updated prior to 1.1 release]
 *
 * Purpose:  Configure a CM. Configuration options are in
 *           cm->config_opts.
 *
 *           CM data structures that are always built or initialized:
 *
 *           - emitmap (if not yet built)
 *
 *           - all HMM banded matrices for the CM (hb_mx, hb_omx, hb_emx,
 *             hb_shmx, trhb_mx, trhb_omx, trhb_emx, trhb_shmx)
 *
 *           - CP9 HMMs (cp9, Lcp9, Rcp9, Tcp9)
 *
 *           - CP9 associated data structures (cp9map, cp9b, cp9_mx,
 *             cp9_bmx)
 *
 *           - maximum-likelihood P7 HMM (mlp7; filter p7 HMM fp7 is
 *             read from the CM file).
 *
 *           Optional configuration:
 *
 *           - CM and cp9 HMMs (built in this function) are put
 *             into local mode if cm->config_opts & CM_CONFIG_LOCAL.
 *
 *           - QDBs and W are recalculated if cm->qdbinfo isn't
 *             already set (cm->qdbinfo->setby =
 *             CM_QDBINFO_SETBY_INIT) or if cm->config_opts &
 *             CM_CONFIG_QDB.
 *
 *           - W is also recalculated if cm->config_opts &
 *             CM_CONFIG_W.
 *
 *           - all non-banded matrices for the CM (nbmx, onbmx,
 *             trnbmx, tronbmx, enbmx, trenbmx, shnbmx, trshnbmx)
 *
 *           - the scan matrix (smx) is created if cm->config_opts &
 *             CM_CONFIG_SMX
 *
 *
 * Args:     cm             - the covariance model
 *           errbuf         - for error messages
 *           W_from_cmdline - W set on cmdline, -1 if W not set on cmdline (usually -1)
 *
 * Returns:   <eslOK> on success.
 *            <eslEINVAL> on contract violation.
 *            <eslEMEM> on memory allocation error.
 */
int
cm_Configure(CM_t *cm, char *errbuf, int W_from_cmdline)
{
  return cm_ConfigureSub(cm, errbuf, W_from_cmdline, NULL, NULL);
}

/* Function: cm_ConfigureSub()
 * Date:     EPN, Thu Jan  4 06:36:09 2007
 *           EPN, Fri Dec  9 15:27:29 2011 [updated prior to 1.1 release]
 *
 * Purpose:  See cm_Configure()'s Purpose above. This function
 *           actually does the work for cm_Configure(). Both functions
 *           exist so we can take two additional parameters in the
 *           rare case that we're configuring a model that is a
 *           sub-model of another CM. If <sub_mother_cm> and
 *           <sub_mother_map> are non-NULL, <cm> is a sub CM
 *           constructed from <sub_mother_cm>. In this case, we're
 *           doing alignment and are constructing a new sub CM for
 *           each target sequence so running time should be
 *           minimized. Special functions for building the CP9 HMMs
 *           and for logoddsifying the model are called that are
 *           faster than the normal versions b/c they can just copy
 *           some of the parameters of the mother model instead of
 *           calc'ing them.
 *
 * Args:     cm             - the covariance model
 *           errbuf         - for error messages
 *           W_from_cmdline - W set on cmdline, -1 if W not set on cmdline (usually -1)
 *           mother_cm      - if non-NULL, <cm> is a sub CM construced from
 *                            <mother_cm>. In this case we use <mother_map>
 *                            to help streamline the two steps that dominate the
 *                            running time of this function (b/c speed is an issue):
 *                            building a cp9 HMM, and logoddsifying the model.
 *           mother_map     - must be non-NULL iff <mother_cm> is non-NULL, the
 *                            map from <cm> to <mother_cm>.
 *
 * Returns:   <eslOK> on success.
 *            <eslEINVAL> on contract violation.
 *            <eslEMEM> on memory allocation error.
 *            <eslFAIL> on other failure (errbuf filled)
 */
int
cm_ConfigureSub(CM_t *cm, char *errbuf, int W_from_cmdline, CM_t *mother_cm, CMSubMap_t *mother_map)
{
  int   status;
  float swentry, swexit;
  int   have_mother;

  have_mother = (mother_cm != NULL && mother_map != NULL) ? TRUE : FALSE;

  /* contract check */
  if(mother_cm != NULL && mother_map == NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, mother_cm != NULL but mother_map == NULL (both must be NULL or both non-NULL).");
  if(mother_cm == NULL && mother_map != NULL)            ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, mother_cm == NULL but mother_map != NULL (both must be NULL or both non-NULL).");
  if(have_mother && (cm->config_opts & CM_CONFIG_LOCAL)) ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, configuring a sub CM, but CM_CONFIG_LOCAL config flag up.");
  if((  cm->config_opts & CM_CONFIG_HMMLOCAL) &&
	 (! (cm->config_opts & CM_CONFIG_LOCAL)))    ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, cp9 is to be configured locally, but CM is not");
  if((  cm->config_opts & CM_CONFIG_HMMEL) &&
	 (! (cm->config_opts & CM_CONFIG_HMMLOCAL))) ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, cp9 is to be configured without local entries exists but with ELs on");
  if((cm->config_opts & CM_CONFIG_TRUNC) && (cm->config_opts & CM_CONFIG_SUB)) ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, incompatible configuration options: CM_CONFIG_TRUNC and CM_CONFIG_SUB");
  if((cm->config_opts & CM_CONFIG_LOCAL) && (cm->config_opts & CM_CONFIG_SUB)) ESL_FAIL(eslEINCOMPAT, errbuf, "Configuring CM, incompatible configuration options: CM_CONFIG_LOCAL and CM_CONFIG_SUB");

  /* validate the CM */
  if((status = cm_Validate(cm, 0.0001, errbuf)) != eslOK) return status;

  /* verify we're not already configured */
  if((status = cm_nonconfigured_Verify(cm, errbuf)) != eslOK) { status = eslEINCOMPAT; return status; }
  /* cm_nonconfigured_Verify() checked that everything that should be
   * NULL in <cm> is NULL, so we don't have to check below.
   */

  /* Build the emitmap, if necessary */
  if(cm->emap == NULL) cm->emap = CreateEmitMap(cm);

  /* Define W and set up query dependent bands. This is confusing. We need
   * the user to be able to set W on the command line if they want, but W
   * and the QDBs used to define the CM_SCAN_MX (created later) are dependent
   * on one another.
   *
   * If W was set on the command line (W_from_cmdline != -1):
   * Set W, and calculate QDBs if nec, without redefining W.
   *
   * Else, if W was not set on the command line (W_from_cmdline ==
   * -1): Calculate QDBs if nec, and redefine W using beta=cm->beta_W,
   * which may or may not have been changed by caller from what BETA_W
   * was in the CM file.
   *
   * Then, W (regardless of how it was set) is enforced when the scan
   * matrix is created, i.e. no dmin/dmax values from cm->qdbinfo
   * that exceed W will be treated as begin equal to W.
   */
  if(W_from_cmdline != -1) {
	cm->W       = W_from_cmdline;
	cm->W_setby = CM_W_SETBY_CMDLINE;
  }
  /* If nec, set up the query dependent bands (it's important to do this before creating the ml p7 HMM (which needs to know cm->W)) */
  if((cm->config_opts & CM_CONFIG_QDB)    ||
	 (cm->config_opts & CM_CONFIG_W_BETA) ||
	 (cm->qdbinfo->setby == CM_QDBINFO_SETBY_INIT)) {
	if(W_from_cmdline != -1) {
	  if((status = CalculateQueryDependentBands(cm, errbuf, cm->qdbinfo,
						ESL_MIN(cm->qdbinfo->beta1, cm->qdbinfo->beta2), NULL, /* don't redefine W, we just set it above as W_from_cmdline */
						NULL, NULL, NULL)) != eslOK) return status;
	}
	else {
	  if((status = CalculateQueryDependentBands(cm, errbuf, cm->qdbinfo,
						cm->beta_W, &(cm->W), /* do redefine W, as that calc'ed with cm->beta_W */
						NULL, NULL, NULL)) != eslOK) return status;
	  cm->W_setby = CM_W_SETBY_BANDCALC;
	}
  }

  /* Allocate the HMM banded matrices, these are originally
   * very small and only grown as needed. Optionally create
   * the truncated alignment matrices.
   */
  cm->hb_mx    = cm_hb_mx_Create(cm->M);
  cm->hb_omx   = cm_hb_mx_Create(cm->M);
  cm->hb_emx   = cm_hb_emit_mx_Create(cm);
  cm->hb_shmx  = cm_hb_shadow_mx_Create(cm);
  if(cm->config_opts & CM_CONFIG_TRUNC) {
	cm->trhb_mx   = cm_tr_hb_mx_Create(cm);
	cm->trhb_omx  = cm_tr_hb_mx_Create(cm);
	cm->trhb_emx  = cm_tr_hb_emit_mx_Create(cm);
	cm->trhb_shmx = cm_tr_hb_shadow_mx_Create(cm);
  }

  /* If nec, create the nonbanded matrices (usually we won't, these get real big) */
  if(cm->config_opts & CM_CONFIG_NONBANDEDMX) {
	cm->nb_mx     = cm_mx_Create(cm->M);
	cm->nb_omx    = cm_mx_Create(cm->M);
	cm->nb_emx    = cm_emit_mx_Create(cm);
	cm->nb_shmx   = cm_shadow_mx_Create(cm);
	if(cm->config_opts & CM_CONFIG_TRUNC) {
	  cm->trnb_mx   = cm_tr_mx_Create(cm);
	  cm->trnb_omx  = cm_tr_mx_Create(cm);
	  cm->trnb_emx  = cm_tr_emit_mx_Create(cm);
	  cm->trnb_shmx = cm_tr_shadow_mx_Create(cm);
	}
  }

  /* If nec, create the scan matrix and truncated scan matrix */
  /* (we could the check size of matrices first, return error if too big, but don't currently) */
  if(cm->config_opts & CM_CONFIG_SCANMX) {
	if((status = cm_scan_mx_Create(cm, errbuf, TRUE, TRUE, &(cm->smx)))      != eslOK) return status;
  }
  if(cm->config_opts & CM_CONFIG_TRSCANMX) {
	if((status = cm_tr_scan_mx_Create(cm, errbuf, TRUE, TRUE, &(cm->trsmx))) != eslOK) return status;
  }

  /* Build the CP9 HMM and associated data. It's important
   * to do this before setting up CM for local mode.
   */
  if(have_mother) {
	if((status = sub_build_cp9_hmm_from_mother(cm, errbuf, mother_cm, mother_map, &(cm->cp9), &(cm->cp9map), FALSE, 0.0001, 0)) != eslOK) return status;
  }
  else {
	if((status = build_cp9_hmm(cm, errbuf, FALSE, 0.0001, 0, &(cm->cp9), &(cm->cp9map))) != eslOK) return status;
  }
  cm->cp9b = AllocCP9Bands(cm->M, cm->cp9->M);
  /* create the CP9 matrices, we init to 1 row, which is tiny so it's okay
   * that we have two of them, we only grow them as needed, cp9_bmx is
   * only needed if we're doing Forward -> Backward -> Posteriors.
   */
  cm->cp9_mx  = CreateCP9Matrix(1, cm->cp9->M);
  cm->cp9_bmx = CreateCP9Matrix(1, cm->cp9->M);
  cm->flags |= CMH_CP9; /* raise the CP9 flag */

  /* Configure for truncated search/alignment. */
  if(cm->config_opts & CM_CONFIG_TRUNC) {
	/* (1) Define truncated alignment penalty probabilities (cm->trp).
	 * 'FALSE' informs the function not to ignore inserts, that is to
	 * allow truncated begins into insert states. This is the
	 * hard-coded behavior. We'd only set it to TRUE if we were
	 * testing the code, because in that case a validation is
	 * performed that isn't possible with truncated begins into
	 * inserts allowed.
	 */
	if((cm->trp = cm_tr_penalties_Create(cm, FALSE, errbuf)) == NULL) ESL_FAIL(eslFAIL, errbuf, "couldn't create truncation penalties for the CM");
	/* cm_tr_penalties_Dump(stdout, cm, cm->trp); */

	/* (2) Setup Lcp9, Rcp9, Tcp9 CP9 HMMs
	 * Clone the globally configured CP9 HMM cm->cp9 before its put
	 * into local mode into each of cm->Lcp9, cm->Rcp9, cm->Tcp9 and
	 * configure them for their specific mode of truncated alignment.
	 * cm->cp9 is not yet logoddsified and so bit scores will not
	 * be copied into Lcp9, Rcp9, Tcp9. This is important because
	 * we want to be as efficient as possible, and only want to
	 * logoddsify each cp9 exactly once, which will occur after
	 * they've been configured into their specific locality mode.
	 */
	if((cm->Lcp9 = cp9_Clone(cm->cp9)) == NULL) ESL_FAIL(eslFAIL, errbuf, "couldn't clone cm->cp9 to get cm->Lcp9");
	if((cm->Rcp9 = cp9_Clone(cm->cp9)) == NULL) ESL_FAIL(eslFAIL, errbuf, "couldn't clone cm->cp9 to get cm->Rcp9");
	if((cm->Tcp9 = cp9_Clone(cm->cp9)) == NULL) ESL_FAIL(eslFAIL, errbuf, "couldn't clone cm->cp9 to get cm->Tcp9");

	/* L mode alignment, 3' truncation: begin into node 1, equiprobable ends */
	swentry = 0.;
	swexit  = ((float) cm->cp9->M - 1.) / (float) cm->cp9->M;
	cp9_sw_config(cm->Lcp9, swentry, swexit, FALSE, cm->ndtype[1]); /* FALSE: let I_0, D_1, I_M be reachable */
	/* R mode alignment, 5' truncation: equiprobable begins, end out of node M */
	swentry = ((float) cm->cp9->M - 1.) / (float) cm->cp9->M;
	swexit  = 0.;
	cp9_sw_config(cm->Rcp9, swentry, swexit, FALSE, cm->ndtype[1]); /* FALSE: let I_0, D_1, I_M be reachable */
	/* T mode alignment, 5' and 3' truncation: equiprobable begins, equiprobable ends */
	swentry = ((float) cm->cp9->M - 1.) / (float) cm->cp9->M;
	swexit  = ((float) cm->cp9->M - 1.) / (float) cm->cp9->M;
	cp9_sw_config(cm->Tcp9, swentry, swexit, FALSE, cm->ndtype[1]); /* FALSE: let I_0, D_1, I_M be reachable */

	cm->flags |= CMH_CP9_TRUNC;
	/* don't logoddsify Lcp9, Rcp9, Tcp9 yet, wait until the end of
	 * the function, after we potentially turn on EL local ends below
	 */
  }

  /* Configure the CM and cm->cp9 for local alignment and cm->Lcp9,
   * cm->Rcp9, cm->Tcp9 for EL-type local ends, if necessary */
  if(cm->config_opts & CM_CONFIG_LOCAL) {
	cm_localize(cm, cm->pbegin, cm->pend);
	if(cm->config_opts & CM_CONFIG_HMMLOCAL) { /* contract enforced CM_CONFIG_HMMLOCAL only raised if CM_CONFIG_LOCAL raised */
	  cp9_sw_config(cm->cp9, cm->pbegin, cm->pbegin, FALSE, cm->ndtype[1]); /* FALSE: let I_0, D_1, I_M be reachable */
	  /* set up EL-type local ends, if necessary */
	  if(cm->config_opts & CM_CONFIG_HMMEL) {
	if((status = cp9_EL_local_ends_config(cm->cp9, cm, errbuf)) != eslOK) return status;
	if(cm->flags & CMH_CP9_TRUNC) {
	  if((status = cp9_EL_local_ends_config(cm->Lcp9, cm, errbuf)) != eslOK) return status;
	  if((status = cp9_EL_local_ends_config(cm->Rcp9, cm, errbuf)) != eslOK) return status;
	  if((status = cp9_EL_local_ends_config(cm->Tcp9, cm, errbuf)) != eslOK) return status;
	}
	  }
	}
  }

  /* Possibly configure cm->cp9 for submodel alignment (contract
	 enforced that if CM_CONFIG_SUB, CM_CONFIG_LOCAL and
	 CM_CONFIG_TRUNC must both be FALSE) */
  if(cm->config_opts & CM_CONFIG_SUB) {
	swentry= ((cm->cp9->M)-1.)/cm->cp9->M; /* all start pts equiprobable, including 1 */
	swexit = ((cm->cp9->M)-1.)/cm->cp9->M; /* all end   pts equiprobable, including M */
	cp9_sw_config(cm->cp9, swentry, swexit, FALSE, cm->ndtype[1]); /* FALSE: let I_0, D_1, I_M be reachable */
  }

  /* We need to ensure that cm->el_selfsc * W >= IMPOSSIBLE
   * (cm->el_selfsc is the score for an EL self transition) This is
   * done because we potentially multiply cm->el_selfsc * W, and add
   * that to IMPOSSIBLE.
   */
  if((cm->el_selfsc * cm->W) < IMPOSSIBLE) {
	cm->el_selfsc  = (IMPOSSIBLE / (cm->W+1));
	cm->iel_selfsc = -INFTY;
  }

  /* Compute log odds scores. This will create cm->cmcons as well, which requires scores. */
  if(have_mother) {
	if((status = SubCMLogoddsify(cm, errbuf, mother_cm, mother_map)) != eslOK) return status;
  }
  else {
	if((status = CMLogoddsify(cm)) != eslOK) ESL_FAIL(status, errbuf, "problem logodisfying CM");
  }
  CP9Logoddsify(cm->cp9);
  if(cm->flags & CMH_CP9_TRUNC) {
	CP9Logoddsify(cm->Lcp9);
	CP9Logoddsify(cm->Rcp9);
	CP9Logoddsify(cm->Tcp9);
  }

  /* Finally, build the ml p7 HMM, which requires cm->cmcons */
  if((status = cm_cp9_to_p7(cm, cm->cp9, errbuf)) != eslOK) return status;

  /*debug_print_cm_params(stdout, cm);
	debug_print_cp9_params(stdout, cm->cp9, TRUE);
	debug_print_cp9_params(stdout, cm->Lcp9, TRUE);
	debug_print_cp9_params(stdout, cm->Rcp9, TRUE);
	debug_print_cp9_params(stdout, cm->Tcp9, TRUE);*/

  cm->flags |= CM_IS_CONFIGURED;

  return eslOK;
}

/* Function: cm_CalculateLocalBeginProbs()
 * Incept:   EPN, Fri Dec  9 05:20:35 2011
 *
 * Purpose:
 *
 *           Calculate local begin probabilities. The transitions in
 *           <t> should be for a CM in global mode, not local mode. By
 *           specifying <t> as not necessarily equal to <cm->t>, we
 *           can calculate local begin probs for a model already in
 *           local mode.
 *
 * Args:     cm               - the covariance model
 *           p_internal_start - prob mass to spread for local begins
 *           t                - [0..M-1][0..MAXCONNECT-1] transition probabilities (not necessarily cm->t)
 *           begin            - [0..M-1] standard local begin probs to set
 *
 * Returns:  eslOK on success
 *           eslEMEM if out of memory
 */

int
cm_CalculateLocalBeginProbs(CM_t *cm, float p_internal_start, float **t, float *begin)
{
  int nd;			/* counter over nodes */
  int nstarts;			/* number of possible internal starts */
  float p;                      /* p_internal_start / nstarts */

  /* Count "internal" nodes: MATP, MATL, MATR, and BIF nodes.
   * Ignore all start nodes, and also node 1 (which is always the
   * "first" node and gets an entry prob of 1-p_internal_start).
   */
  nstarts = 0;
  for (nd = 2; nd < cm->nodes; nd++) {
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
		cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BIF_nd)
	  nstarts++;
  }

  /* Set begin probs (standard local begins) */
  esl_vec_FSet(begin, cm->M, 0.);
  /* Node 1 gets prob 1-p_internal_start. */
  begin[cm->nodemap[1]] = 1.-p_internal_start;
  /* Remaining nodes share p_internal_start. */
  p = p_internal_start / (float) nstarts;
  for (nd = 2; nd < cm->nodes; nd++) {
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
		cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BIF_nd)
	  begin[cm->nodemap[nd]] = p;
  }
  return eslOK;
}

/* Function: cm_localize()
 * Incept:   EPN, Tue Nov 29 13:46:29 2011 [updated]
 *
 * Purpose:  Configure a CM for local alignment by spreading
 *           <p_internal_start> local entry probability evenly across
 *           all internal nodes, and by spreading <p_internal_exit>
 *           local exit probability evenly across all internal nodes.
 *
 *           Local entry probabilities for truncated alignment
 *           (cm->trbegin and cm->trbeginsc) are configured slightly
 *           differently, to allow inserts at the ends of the
 *           alignment. As with standard local begins,
 *           <p_internal_start> is spread evenly across all <nstarts>
 *           internal nodes, but entries into inserts are also
 *           allowed. The <p_internal_start>/<nstarts> probability
 *           for each node is divided between match and insert states
 *           of that node using a <psi> vector, psi[v] is the expected
 *           number of times state v is entered.
 *
 *           Note: to reproduce how Diana scored truncated alignments
 *           in the Kolbe and Eddy 2009 paper, set trbegin[v] to
 *           (2 / (cm->clen * (cm->clen + 1))) for all v.
 *
 *           Local end probability is spread evenly across all states
 *           from which local ends are permitted (see code).
 *
 *           We exploit the fact that we know we are a local static
 *           function called only by cm_ConfigureSub() and don't do
 *           any checking of the CM because cm_ConfigureSub() already
 *           has done that. If we were callable by other functions
 *           we'd want to make sure the CM wasn't already in local
 *           mode, at least.
 *
 * Args:     cm               - the covariance model
 *           p_internal_start - prob mass to spread for local begins
 *           p_internal_exit  - prob mass to spread for local ends
 */

void
cm_localize(CM_t *cm, float p_internal_start, float p_internal_exit)
{
  int status;
  int v;			/* counter over states */
  int nd;			/* counter over nodes */
  int nexits;			/* number of possible internal ends */
  float denom;

  /* Local begins: */
  cm_CalculateLocalBeginProbs(cm, p_internal_start, cm->t, cm->begin);
  /* Erase the previous transition probs from node 0. The only way out
   * of node 0 in standard scanners/aligners is going to be local
   * begin transitions from the root v=0 directly to MATP_MP, MATR_MR,
   * MATL_ML, and BIF_B states. In truncated scanners/aligners we also
   * allow transitions into inserts, see comments in CalculateLocalBeginProbs().
   *
   * First we want to save the transition probs we're about to zero,
   * so we don't lose that information in case we need it subsequently
   * cm->root_trans is NULL prior to this.
   */
  if(cm->root_trans == NULL) { /* otherwise they've already been set */
	ESL_ALLOC(cm->root_trans, sizeof(float) * cm->cnum[0]);
	esl_vec_FCopy(cm->t[0], cm->cnum[0], cm->root_trans);
  }
  esl_vec_FSet(cm->t[0], cm->cnum[0], 0.);
	cm->flags |= CMH_LOCAL_BEGIN;

  /* Local ends:
   * Count internal nodes MATP, MATL, MATR, BEGL, BEGR that aren't
   * adjacent to END nodes.
   */
  nexits = 0;
  for (nd = 1; nd < cm->nodes; nd++) {
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	 cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	 cm->ndtype[nd] == BEGR_nd) &&
	cm->ndtype[nd+1] != END_nd)
	  nexits++;
  }
  /* Spread the exit probability across internal nodes.
   * Currently does not compensate for the decreasing probability
   * of reaching a node, the way HMMER does: therefore the probability
   * of exiting at later nodes is actually lower than the probability
   * of exiting at earlier nodes. This should be a small effect.
   */
  for (v = 0; v < cm->M; v++) cm->end[v] = 0.;
  for (nd = 1; nd < cm->nodes; nd++) {
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	 cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	 cm->ndtype[nd] == BEGR_nd) &&
	cm->ndtype[nd+1] != END_nd)
	  {
	v = cm->nodemap[nd];
	cm->end[v] = p_internal_exit / (float) nexits;
				/* renormalize the main model transition distribution */
	denom = esl_vec_FSum(cm->t[v], cm->cnum[v]);
	denom += cm->end[v];
	esl_vec_FScale(cm->t[v], cm->cnum[v], 1./denom);
	/* cm->t[v] vector will purposefully no longer sum to 1.,
	 * if we were to append cm->end[v] as a new number in the vector, it would sum to 1.
	 */
	  }
  }
  cm->flags |= CMH_LOCAL_END;

  /* new probs invalidate log odds scores if we had them */
  cm->flags &= ~CMH_BITS;

  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function: cp9_sw_config()
 * Incept:   EPN 05.30.06
 *           based on SRE's Plan7SWConfig() from HMMER's plan7.c
 *           EPN, Mon Dec 12 04:35:28 2011 [Updated, made local in cm_modelconfig.c]
 *
 * Purpose:  Set the alignment independent parameters of
 *           a CM Plan 9 model to hmmsw (Smith/Waterman) configuration.
 *
 * Notes:    The desideratum for begin/end probs is that all fragments ij
 *           (starting at match i, ending at match j) are
 *           equiprobable -- there is no information in the choice of
 *           entry/exit. There are M(M+1)/2 possible choices of ij, so
 *           each must get a probability of 2/M(M+1). This prob is the
 *           product of a begin, an end, and all the not-end probs in
 *           the path between i,j.
 *
 *           Thus: entry/exit is asymmetric because of the left/right
 *           nature of the HMM/profile. Entry probability is distributed
 *           simply by assigning p_x = pentry / (M-1) to M-1
 *           internal match states. However, the same approach doesn't
 *           lead to a flat distribution over exit points. Exit p's
 *           must be corrected for the probability of a previous exit
 *           from the model. Requiring a flat distribution over exit
 *           points leads to an easily solved piece of algebra, giving:
 *                      p_1 = pexit / (M-1)
 *                      p_x = p_1 / (1 - (x-1) p_1)
 *
 *           Modified EPN, Thu Feb  7 15:54:16 2008, as follows:
 *           To better match a locally configured CM, if <do_match_local_cm>
 *           we disallow insertions before the first (emitting) match state,
 *           (from I_0), and after the final (emitting) match state,
 *           (from I_M). I_0 maps to ROOT_IL and I_M maps to ROOT_IR
 *           which can never be entered in a locally configured CM
 *           (b/c the ROOT_S state MUST jump into a local begin state, which
 *            are always match states>). Also we disallow a M_0->D_1 transition
 *           because these would be impossible in a locally configured CM.
 *
 *           <do_match_local_cm> is usually TRUE, unless we're configuring
 *           the CP9 specifically for eventual sub CM alignment, where
 *           the goal is simply find the most likely start/end point
 *           of the alignment with this CP9 (in that case we want
 *           I_0 and I_M reachable).
 *
 *           HMM probabilities are modified, but HMM is only
 *           logoddsified to get valid bit scores before leaving the
 *           function if it had valid bit scores upon entering.
 *
 * Args:     hmm    - the CM Plan 9 model w/ data-dep prob's valid
 *           pentry - probability of an internal entry somewhere;
 *                    will be evenly distributed over M-1 match states
 *           pexit  - probability of an internal exit somewhere;
 *                    will be distributed over M-1 match states.
 *           do_match_local_cm - TRUE to make I_0, D_1 and I_M unreachable
 *                    to better match a locally configured CM.
 *           first_cm_ndtype - only used if do_match_local_cm is TRUE
 *                             if it's MATL or MATP then D_1 should be unreachable (it is in the CM)
 *                             if it's MATR or MATP then D_M should be unreachable (it is in the CM)
 *
 * Return:   (void)
 *           HMM probabilities are modified.
 */
int
cp9_sw_config(CP9_t *hmm, float pentry, float pexit, int do_match_local_cm, int first_cm_ndtype)
{
  float basep;			/* p1 for exits: the base p */
  int   k;			/* counter over states      */
  float d;
  int   had_bits;

  had_bits = (hmm->flags & CPLAN9_HASBITS) ? TRUE : FALSE;

  /* No special (*x* states in Plan 7) states in CM Plan 9 */

  /* Configure entry.
   */
  if(do_match_local_cm) {
	hmm->t[0][CTMI] = 0.;
	hmm->t[0][CTMM] = 0.;  /* already was 0.0, transition from M_0 to M_1 is begin[1] */
	hmm->t[0][CTMEL] = 0.; /* already was 0.0, can never do a local end from M_0 */
	if((first_cm_ndtype == MATL_nd) || (first_cm_ndtype == MATP_nd)) { /* CM can't possibly reach the CM delete state that maps to D_1, make D_1 unreachable too */
	  hmm->t[0][CTMD] = 0.;
	}

	hmm->t[hmm->M][CTMI] = 0.;
	hmm->t[hmm->M][CTDI] = 0.;
	if((first_cm_ndtype == MATR_nd) || (first_cm_ndtype == MATP_nd)) { /* CM can't possibly reach the CM delete state that maps to D_M, make D_M unreachable too */
	  hmm->t[hmm->M][CTMD] = 0.;
	}

	/* renormalize transitions out of M_M */
	d = esl_vec_FSum(hmm->t[hmm->M], cp9_TRANS_NMATCH) + hmm->end[hmm->M];
	esl_vec_FScale(hmm->t[hmm->M], cp9_TRANS_NMATCH, 1./d);
	hmm->end[hmm->M] /= d;

	/* renormalize transitions out of D_M */
	esl_vec_FNorm(hmm->t[hmm->M] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE);	/* delete */
  }

  hmm->begin[1] = (1. - pentry) * (1. - (hmm->t[0][CTMI] + hmm->t[0][CTMD] + hmm->t[0][CTMEL]));
  esl_vec_FSet(hmm->begin+2, hmm->M-1, (pentry * (1.- (hmm->t[0][CTMI] + hmm->t[0][CTMD] + hmm->t[0][CTMEL]))) / (float)(hmm->M-1));
  /* note: hmm->t[0][CTMEL] == 0. (can't locally end from begin)
   *       and if do_match_local_cm, hmm->t[0][CTMI] and hmm->t[0][CTMD] were just set to 0.
   */

  /* Configure exit.
   * Don't touch hmm->end[hmm->M]
   */

  basep = pexit / (float) (hmm->M-1);
  for (k = 1; k < hmm->M; k++)
	hmm->end[k] = basep / (1. - basep * (float) (k-1));
  cp9_renormalize_exits(hmm);
  /*for (k = 1; k <= hmm->M; k++) printf("after renormalizing: end[%d]: %f\n", k, hmm->end[k]);*/

  hmm->flags       &= ~CPLAN9_HASBITS; /* reconfig invalidates log-odds scores */
  hmm->flags       |= CPLAN9_LOCAL_BEGIN; /* local begins now on */
  hmm->flags       |= CPLAN9_LOCAL_END;   /* local ends now on */

  /* only call CP9Logoddsify() if we had valid scores upon entering */
  if(had_bits) CP9Logoddsify(hmm);

  return eslOK;
}

/* Function: cp9_EL_local_ends_config()
 * Incept:   EPN, Tue Jun 19 09:50:52 2007
 *           EPN, Mon Dec 12 04:38:23 2011 [Updated, made local in cm_modelconfig.c]
 *
 * Purpose:  Turn EL local ends in a CM Plan 9 HMM on based on
 *           the local end probs in the CM.
 *
 *           HMM probabilities are modified, but HMM is only
 *           logoddsified to get valid bit scores before leaving the
 *           function if it had valid bit scores upon entering.

 * Args:     cp9 - the cp9 HMM
 *           cm  - the CM the cp9 was built from
 *
 * Return:   eslOK on success.
 *           eslEINVAL on any error, errbuf is filled.
 */
int
cp9_EL_local_ends_config(CP9_t *cp9, CM_t *cm, char *errbuf)
{
  /* Contract checks */
  if(cp9->M != cm->clen)     ESL_FAIL(eslEINVAL, errbuf, "cp9 and cm model length do not match");
  if(cm->cp9map == NULL)     ESL_FAIL(eslEINVAL, errbuf, "cm->cp9map is NULL when trying to setup ELs in cp9");
  if(cp9->flags & CPLAN9_EL) ESL_FAIL(eslEINVAL, errbuf, "trying to setup ELs in a cp9, but CPLAN_EL flag already raised");

  int v;
  int k;                     /* counter over HMM nodes */
  int nd;
  int seen_exit;
  float to_el_prob;
  float norm_factor;
  int   nexits;
  int   had_bits = (cp9->flags & CPLAN9_HASBITS) ? TRUE : FALSE;

  /* If the CM has local ends on, check to make sure all non-zero
   * local end probabilities in the CM are identical (within reasonable
   * precision), use that probability to set all HMM transitions to
   * EL states.
   */
  if(cm->flags & CMH_LOCAL_END) {
	seen_exit  = FALSE;
	to_el_prob = 0.;
	for(v = 0; v < cm->M; v++) {
	  nd = cm->ndidx[v];
	  if (((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	  cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	  cm->ndtype[nd] == BEGR_nd) &&
	 cm->ndtype[nd+1] != END_nd) && cm->nodemap[nd] == v) {
	/* this should have a non-zero local end probability */
	if(fabs(cm->end[v] - 0.) < eslSMALLX1) ESL_FAIL(eslEINVAL, errbuf, "cp9_el_local_ends_config(), CM state %d has local end prob of 0.", v);
	if(! seen_exit) {
	  to_el_prob = cm->end[v];
	  seen_exit  = TRUE;
	}
	else if(fabs(to_el_prob - cm->end[v]) > eslSMALLX1) {
	  ESL_FAIL(eslEINVAL, errbuf, "cp9_el_local_ends_config(), not all CM states EL probs are identical.\n");
	}
	  }
	}
	if(! seen_exit && cm->nodes != 3) ESL_FAIL(eslEINVAL, errbuf, "cp9_el_local_ends_config(), cm->nodes != 3, but all CM local end probs are zero.");
  }
  else {
	/* CM_LOCAL_END flag is down, local ends are off in the CM
	 * We figure out what the local end prob would be given cm->pend
	 * and set the HMM local end probs based on that.
	 * First, count internal nodes MATP, MATL, MATR, BEGL, BEGR that aren't
	 * adjacent to END nodes.
	 */
	nexits = 0;
	for (nd = 1; nd < cm->nodes; nd++) {
	  if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	   cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	   cm->ndtype[nd] == BEGR_nd) &&
	  cm->ndtype[nd+1] != END_nd)
	nexits++;
	}
	to_el_prob = cm->pend / (float) nexits;
  }

  /* transitions from HMM node 0 to EL is impossible */
  cp9->t[0][CTMEL] = 0.;
  for(k = 1; k <= cp9->M; k++)
	{
	  if(cp9->has_el[k])
	{
	  cp9->t[k][CTMEL] = to_el_prob;
	  norm_factor = 1. - (cp9->t[k][CTMEL] / (1. - cp9->end[k]));
	  cp9->t[k][CTMM] *= norm_factor;
	  cp9->t[k][CTMI] *= norm_factor;
	  cp9->t[k][CTMD] *= norm_factor;
	  /* cp9->end[k] untouched */
	}
	}
  cp9->flags &= ~CPLAN9_HASBITS;	/* clear the log-odds ready flag */

  /* only call CP9Logoddsify() if we had valid scores upon entering */
  if(had_bits) CP9Logoddsify(cp9);

  cp9->flags |= CPLAN9_EL;          /* EL end locals now on */
  /*debug_print_cp9_params(cp9);*/

  return eslOK;
}

/* Function: cp9_renormalize_exits()
 * Incept:   EPN 05.30.06
 *           based on SRE's Plan7RenormalizeExits() from HMMER2's plan7.c.
 *           EPN, Mon Dec 12 04:49:29 2011 [Updated, made local in cm_modelconfig.c]
 *
 * Purpose:  Renormalize just the match state transitions;
 *           for instance, after a Config() function has
 *           modified the exit distribution.
 *
 * Args:     hmm - hmm to renormalize
 *
 * Returns:  void
 */
void
cp9_renormalize_exits(CP9_t *hmm)
{
  int   k;
  float d;

  /* We can't exit from node 0 so we start renormalizing at node 1 */
  for (k = 1; k < hmm->M; k++) {
	d = esl_vec_FSum(hmm->t[k], 4);
	/* esl_vec_FScale(hmm->t[k], 4, 1./(d + d*hmm->end[k])); */
	esl_vec_FScale(hmm->t[k], 4, (1.-hmm->end[k])/d);
  }
  /* Take care of hmm->M node, which is special */
  d = hmm->t[hmm->M][CTMI] + hmm->t[hmm->M][CTMEL]; /* CTMD is IMPOSSIBLE, CTMM is hmm->end[hmm-M] */
  if(! (fabs(d-0.) < eslSMALLX1)) { /* don't divide by d if it's zero */
	hmm->t[hmm->M][CTMI] *= (1.-hmm->end[hmm->M])/d;
	hmm->t[hmm->M][CTMEL] *= (1.-hmm->end[hmm->M])/d;
  }

  hmm->flags &= ~CPLAN9_HASBITS; /* reconfig invalidates log-odds scores */

  return;
}

/*** End of inlined file: cm_modelconfig.c ***/


/*** Start of inlined file: cm_modelmaker.c ***/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>


static int check_for_pknots(char *cs, int alen);
static int check_for_el(const ESL_DSQ *ax, const ESL_ALPHABET *abc, const int *used_el, const int *nxt_mi, const int *nxt_el, int i0, int j0, int *ret_goto_el, int *ret_i, int *ret_j);

/* Function: HandModelmaker()
 * Incept:   SRE 29 Feb 2000 [Seattle]; from COVE 2.0 code
 *
 * Purpose:  The customer always knows best.
 *
 *           Construct a model given a stated structure. The structure
 *           is provided via a "ss_cons" (consensus structure) line, as would
 *           occur in an annotated SELEX or Stockholm file. Only > and < characters
 *           in this line are interpreted (as base pairs). Pseudoknots,
 *           if annotated, are ignored.
 *
 *           Match vs. insert can be determined one of three ways,
 *           depending on the values of <use_rf> and <use_wts>.
 *           1. <use_rf> == FALSE and <use_wts> == TRUE:
 *              Default. The assignment is made by <gapthresh>; for
 *              columns with fractional occurence of gaps (considering
 *              sequence weights) is greater than this, the column is
 *              assigned to insert.
 *           2. <use_rf> == FALSE and <use_wts> == FALSE:
 *              Same as 1, but sequence weights are not considered in
 *              fractional occurence of gaps. (This was default in
 *              Infernal up through version 1.0.2).
 *           3. <use_rf> == TRUE and <use_wts> == FALSE:
 *              case): Match positions are defined as all non-gap
 *              positions in the msa->rf annotation.
 *           4. <use_rf> == TRUE and <use_wts> == TRUE:
 *              Not allowed. Contract violation.
 *
 *           Both rf and cs are provided in the msa structure.
 *
 *           If <use_el> is TRUE, we consider models with '~' in
 *           msa->rf as local end (EL) emission columns. These are not
 *           insert columns, nor match columns but get modeled with
 *           the EL state. As of now, <use_el> should only be TRUE if
 *           called internally using a Infernal constructed
 *           <msa>. That is, we do not expect it to be called during
 *           cmbuild's build procedure. So we expected the use of EL
 *           columns in athe MSA to always be valid.
 *
 * Args:     msa       - multiple alignment to build model from
 *           errbuf    - for error messages
 *           use_rf    - TRUE to use RF annotation to determine match/insert
 *           use_el    - TRUE to model RF '~' columns with the E state
 *           use_wts   - TRUE to consider sequence weights from msa when determining match/insert
 *           gapthresh - fraction of gaps to allow in a match column (if use_rf=FALSE)
 *           ret_cm    - RETURN: new model                (maybe NULL)
 *           ret_gtr   - RETURN: guide tree for alignment (maybe NULL)
 *
 * Return:   eslOK on success;
 *
 * Throws:   eslEINCOMPAT on contract violation, ret_cm and ret_gtr set to NULL.
 *           eslEINVAL on invalid input, ret_cm and ret_gtr set to NULL.
 */
int
HandModelmaker(ESL_MSA *msa, char *errbuf, int use_rf, int use_el, int use_wts, float gapthresh, CM_t **ret_cm, Parsetree_t **ret_gtr)
{
  int          status;
  CM_t        *cm        = NULL; /* new covariance model                       */
  Parsetree_t *gtr       = NULL; /* guide tree for alignment                   */
  ESL_STACK   *pda       = NULL; /* pushdown stack used in building gtr        */
  int         *matassign = NULL; /* 1..alen   array; 0=insert col, 1=match col */
  int         *elassign  = NULL; /* 1..alen   array; 0=match/ins col, 1=EL col */
  int         *ct        = NULL; /* 0..alen-1 base pair partners array         */
  int          apos;		 /* counter over columns of alignment          */
  int          idx;		 /* counter over sequences in the alignment    */
  int          v;		 /* index of current node                      */
  int          i,j,k;	         /* subsequence indices                        */
  int  type;			 /* type of node we're working on              */
  int  diff, bestdiff, bestk;    /* used while finding optimal split points    */
  int  nnodes;			 /* number of nodes in CM                      */
  int  nstates;			 /* number of states in CM                     */
  int  clen;                     /* consensus length of the model              */
  int *c2a_map = NULL;           /* [1..clen]      map from consensus (match) positions to alignment positions */
  int *a2c_map = NULL;           /* [1..msa->alen] map from alignment positions to consensus (match) positions,
				  * insert alignment positions = 0 */
  int  cpos;                     /* consensus position counter */
  int  k_cpos, i_cpos, j_cpos;   /* consensus position that k, i, j (alignment positions) correspond to */
  int  kp;                       /* k prime, closest alignment position that is consensus to the right of k (that is kp >= k) */
  float gaps = 0.;               /* counter over gaps */
  int  el_i, el_j;               /* i and j, before accounting for ELs */

  /* Contract check */
  if (msa->ss_cons == NULL)            ESL_XFAIL(eslEINCOMPAT, errbuf, "HandModelmaker(): No consensus structure annotation available for the alignment.");
  if (! (msa->flags & eslMSA_DIGITAL)) ESL_XFAIL(eslEINCOMPAT, errbuf, "HandModelmaker(): MSA is not digitized.");
  if (  use_rf && msa->rf  == NULL)    ESL_XFAIL(eslEINCOMPAT, errbuf, "HandModelmaker(): No reference annotation available for the alignment.");
  if (! use_rf && msa->wgt == NULL)    ESL_XFAIL(eslEINCOMPAT, errbuf, "HandModelmaker(): use_rf is FALSE, and msa->wgt is NULL.");
  if (  use_rf && use_wts)             ESL_XFAIL(eslEINCOMPAT, errbuf, "HandModelmaker(): use_rf is TRUE and use_wts is TRUE, if use_rf is TRUE, use_wts must be FALSE.");

  /* 1. Determine match/insert assignments
   *    matassign is 1..alen. Values are 1 if a match column, 0 if insert column.
   *
   *    EPN, Wed Sep 29 13:26:51 2010
   *    Post-v1.0.2 change, if (use_rf == FALSE) and (use_wts == TRUE):
   *    match/insert columns are defined based on gap frequency in the
   *    alignment *taking weights into account*. That is <= gapthresh
   *    of the fraction of weighted sequences must have gaps to define
   *    an match column.  Previously (infernal v0.1->1.0.2)
   *    <= gapthresh of the actual number of sequences (unweighted)
   *    need have gaps to be a match, this is still allowed if (use_wts
   *    is FALSE).
   */
  ESL_ALLOC(matassign, sizeof(int) * (msa->alen+1));

  /* Watch for off-by-one. rf is [0..alen-1]; matassign is [1..alen] */
  if (use_rf) {
	/* Define match based on RF char, if gap or missing ('-_.~')
	 * then insert, else match.
	 *
	 * It's impt we don't count '~' as a match column b/c we don't
	 * want a match column to have RF == '~' in a cmalign output
	 * alignment as that would screw the merging of subalignments in
	 * cmalign, which assumes '~' RF columns are EL inserts.
	 */
	for (apos = 1; apos <= msa->alen; apos++)
	  matassign[apos] = ((esl_abc_CIsGap    (msa->abc, msa->rf[apos-1])) || /* CIsGap     returns true for '.', '_' and '-' only (they're equivalent, see create_rna() in esl_alphabet.c()) */
			 (esl_abc_CIsMissing(msa->abc, msa->rf[apos-1])))   /* CIsMissing returns true for '~' only */
			  ? FALSE : TRUE;
  }
  else if(! use_wts) {
	for (apos = 1; apos <= msa->alen; apos++) {
	  gaps = 0.;
	  for (idx = 0; idx < msa->nseq; idx++)
	if (esl_abc_XIsGap(msa->abc, msa->ax[idx][apos])) gaps += 1.0;
	  matassign[apos] = ((gaps / (float) msa->nseq) > gapthresh) ? 0 : 1;
	}
  }
  else {
	for (apos = 1; apos <= msa->alen; apos++) {
	  gaps = 0.;
	  for (idx = 0; idx < msa->nseq; idx++)
	if (esl_abc_XIsGap(msa->abc, msa->ax[idx][apos])) gaps += msa->wgt[idx];
	  matassign[apos] = ((gaps / (float) msa->nseq) > gapthresh) ? 0 : 1;
	}
  }

  /* 2. Determine EL assignments, if necessary.
   *    elassign is 1..alen. Values are 1 if a EL column, 0 if match or insert column.
   *    If <use_el> is FALSE, we set all values to FALSE. The contract enforced
   *    that if <use_el> is TRUE, <use_rf> must also be TRUE. Since RF '~' columns
   *    are defined as inserts if <use_rf> is TRUE, we're guaranteed that no
   *    RF '~' column will have matassign == TRUE at this point.
   */

  ESL_ALLOC(elassign, sizeof(int) * (msa->alen+1));
  if (use_el) {
	elassign[0] = FALSE; /* out of bounds */
	for (apos = 1; apos <= msa->alen; apos++)
	  elassign[apos] = (esl_abc_CIsMissing(msa->abc, msa->rf[apos-1])) ? TRUE : FALSE;
	/* sanity check */
	for (apos = 1; apos <= msa->alen; apos++)
	  if(matassign[apos] && elassign[apos]) ESL_XFAIL(eslEINVAL, errbuf, "HandModelmaker(): position %d assigned as match and EL", apos);
  }
  else {
	esl_vec_ISet(elassign, msa->alen+1, FALSE);
  }

  /* 3. Determine a "ct" array, base-pairing partners for each position.
   *    Disallow/ignore pseudoknots by removing them prior to making the ct array.
   *    ct[] values give the index of a base pairing partner, or 0 for unpaired positions.
   *    Even though msa->ss_cons is in the 0..alen-1 coord system of msa, ct[]
   *    comes back in the 1..alen coord system of dsq.
   */
  esl_wuss_nopseudo(msa->ss_cons, msa->ss_cons); /* remove pknots in place */
  ESL_ALLOC(ct, (msa->alen+1) * sizeof(int));
  if (esl_wuss2ct(msa->ss_cons, msa->alen, ct) == eslESYNTAX) ESL_XFAIL(eslEINVAL, errbuf, "HandModelMaker(): consensus structure string is inconsistent");
  else if (esl_wuss2ct(msa->ss_cons, msa->alen, ct) != eslOK)  goto ERROR;

  /* 4. Make sure the consensus structure "ct" is consistent with the match assignments.
   *    Wipe out all structure in insert columns; including the base-paired
   *    partner of insert-assigned columns. Also create a map from consensus positions
   *    to alignment positions (c2a_map) and vice versa (a2c_map), we'll use this
   *    to choose optimal k for bifurcations below.
   */
  clen = 1;
  for (apos = 1; apos <= msa->alen; apos++) {
	if (! matassign[apos]) {
	  if (ct[apos] != 0)  ct[ct[apos]] = 0;
	  ct[apos] = 0;
	}
	else clen++;
  }
  /* build c2a_map and a2c_map, we need clen before we can allocate c2a_map, hence the second apos=1..alen loop */
  ESL_ALLOC(c2a_map, sizeof(int) * (clen+1));
  ESL_ALLOC(a2c_map, sizeof(int) * (msa->alen+1));
  c2a_map[0] = 0; /* invalid */
  a2c_map[0] = 0; /* invalid */
  cpos = 1;
  for (apos = 1; apos <= msa->alen; apos++) {
	if(matassign[apos]) {
	  a2c_map[apos] = cpos;
	  c2a_map[cpos] = apos;
	  cpos++;
	}
	else a2c_map[apos] = 0;
  }

  /* 5. Construct a guide tree.
   *    This code is borrowed from yarn's KHS2Trace().
   *
   *    We also keep track of how many states we'll need in the final CM,
   *    so we'll know how much to allocate -- and the number of nodes,
   *    for informational purposes.
   */
  nstates = nnodes = 0;
  gtr = CreateParsetree(25);	/* the parse tree we'll grow        */
  pda = esl_stack_ICreate();    /* a pushdown stack for our indices */
  if(pda == NULL) goto ERROR;
  clen = 0;

  /* Construction strategy has to make sure we number the nodes in
   * preorder traversal: for bifurcations, we can't attach the right
   * child until we've fully traversed the left side. Therefore, we have
   * to push what we intend to attach, and pop it later. And since we
   * don't know an index for the node until we attach it, we have no
   * place to put the node's data except the stack -- so we have to
   * push several numbers onto the stack: what type of node, what
   * subseq it's responsible for (emitl...emitr), and what node
   * index it attaches to.
   */
  if((status = esl_stack_IPush(pda, -1))        != eslOK) goto ERROR;	/* what node it's attached to */
  if((status = esl_stack_IPush(pda, 1))         != eslOK) goto ERROR;	/* emitl */
  if((status = esl_stack_IPush(pda, msa->alen)) != eslOK) goto ERROR;	/* emitr */
  if((status = esl_stack_IPush(pda, ROOT_nd))   != eslOK) goto ERROR;	/* "state" (e.g. node type) */

  while (esl_stack_IPop(pda, &type) != eslEOD) /* pop a node type to attach */
	{
	  esl_stack_IPop(pda, &j);
	  esl_stack_IPop(pda, &i); /* i..j == subseq we're responsible for */
	  esl_stack_IPop(pda, &v); /* v = index of parent node in gtr */

	  /* We'll skip EL columns but need to remember what i and j would
	   * be if we didn't: <el_i> and <el_j>. Then, we can set emitr
	   * for MATL and emitl for MATR as <el_j> and <el_i> respectively.
	   * If <use_el> is FALSE, i == el_i and j == el_j.
	   */
	  if(use_el) {
	el_i = i;
	el_j = j;
	while(i <= msa->alen && elassign[i]) i++;
	while(j >= 1         && elassign[j]) j--;
	if(i > (msa->alen+1)) ESL_XFAIL(eslEINVAL, errbuf, "HandModelmaker(): problem with local ends (RF='~') during model construction");
	if(j < 0)             ESL_XFAIL(eslEINVAL, errbuf, "HandModelmaker(): problem with local ends (RF='~') during model construction");
	  }
	  else {
	el_i = i;
	el_j = j;
	  }

	  /* This node accounts for i..j, but we usually don't know how yet.
	   * Six possibilities:
	   *    i > j; this is an END state; do nothing.
	   *    this is already assigned as a BEGIN; push i,j
	   *    i is unpaired; this is a MATL state; push i+1, j
	   *    j is unpaired; this is a MATR state; push i,j-1
	   *    i,j pair to each other; this is a MATP state; push i+1,j-1
	   *    i,j pair but not to each other; this is a BIFURC state;
	   *        pick mid ip <= mid < jp; push BEGIN i,mid and working i,mid,
	   *        and push BEGIN mid+1,j and working mid+1,j
	   */
	  if (i > j) {
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, END_nd);
	nstates += 1;		/* END_nd -> E_st */
	nnodes++;
	  }

	  else if (type == ROOT_nd) { /* try to push i,j; but deal with INSL and INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, ROOT_nd);
	for (; i <= j; i++) if (matassign[i] || elassign[i]) break;
	for (; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;	/* here v==0 always. */
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* ROOT_nd -> S_st, IL_st, IR_st */
	nnodes++;
	  }

	  else if (type == BEGL_nd) {    /* no inserts */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, BEGL_nd);
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 1;		/* BEGL_nd -> S_st */
	nnodes++;
	  }

	  else if (type == BEGR_nd)  { /* look for INSL */
	v = InsertTraceNode(gtr, v, TRACE_RIGHT_CHILD, i, j, BEGR_nd);
	for (; i <= j; i++) if (matassign[i] || elassign[i]) break;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 2;		/* BEGR_nd -> S_st IL_st */
	nnodes++;
	  }

	  else if (ct[i] == 0) {
	 	/* i unpaired. This is a MATL node; allow INSL */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, el_j, MATL_nd);
	for (i = i+1; i <= j; i++) if (matassign[i] || elassign[i]) break;
	if((status = esl_stack_IPush(pda, v))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, el_j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* MATL_nd -> ML_st, D_st, IL_st */
	nnodes++;
	clen += 1;
	  }

	  else if (ct[j] == 0) { 	/* j unpaired. MATR node. Deal with INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, el_i, j, MATR_nd);
	for (j = j-1; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, v))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, el_i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j))    != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* MATR_nd -> MR_st, D_st, IL_st */
	nnodes++;
	clen += 1;
	  }

	  else if (ct[i] == j) { /* i,j paired to each other. MATP. deal with INSL, INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, MATP_nd);
	for (i = i+1; i <= j; i++) if (matassign[i] || elassign[i]) break;
	for (j = j-1; j >= i; j--) if (matassign[j] || elassign[j]) break;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 6;		/* MATP_nd -> MP_st, ML_st, MR_st, D_st, IL_st, IR_st */
	nnodes++;
	clen += 2;
	  }

	  else /* i,j paired but not to each other. BIFURC. no INS. */
	{
	  /* Here's the first of two places where we can optimize the topology
		   * of a CM. (The other comes from choosing a state traversal order when
		   * building the CM.) Imagine a multifurcation of four domains:
		   *   [1]..[2]..[3]..[4]
		   * The "default leftwise" rule means that BEGL/INSL generates the
		   * intervening sequences, so we must model the four stems as:
		   *   [1],    ..[2],    ..[3],   ..[4]
		   * but we have a choice of how we bifurcate:
		   *   (1,2)(3,4)    1,(2,(3,4))   ((1,2),3),4
		   * Our choice affects the time and memory requirements of a divide
		   * conquer alignment algorithm. (1,(2,(3,4)) is most efficient for
		   * memory; (1,2)(3,4) is most efficient for time.
		   *
		   * So we may want to choose carefully from several possible split
		   * points k (3, in the above example). A priori we only know one
		   * possible midpoint precisely: ct[i]+1, the next base after closing
		   * domain 1. We can find the others by scanning for them, and we can
		   * be reasonably efficient about scanning by using ct[] to instantly
		   * skip subdomains.
	   */
	  /* One possible rule: optimize by finding most balanced split.
		   * Each stop of the following loop gives a possible midpoint k, which is
		   * then evaluated, keeping track of the best split so far.
		   */
	  /* EPN, Tue Sep 9 07:41:28 2008
	   * Revised this code block to pick optimal choice of k based
	   * on split lengths of consensus (match) positions instead
	   * of alignment positions, this actually yields most
	   * 'balanced' split as described above because DP operates
	   * on consensus positions, not alignment positions (which
	   * are affected by inserts in the input msa). Motivation for
	   * this revision was to allow merging of two alignments
	   * created by two runs cmalign to the same CM, which is done
	   * by converting both alignments to guidetrees, then each
	   * aligned seq to a parsetree then converting all parsetrees
	   * from both alignments to a single msa. Prior to the
	   * revision the specific guidetree built from an alignment
	   * was subject to the number of inserts in the msas, so we
	   * couldn't guarantee that both msas would yield the same
	   * guidetree, which was problematic. In other words, prior
	   * to this the SS_cons and RF annotation didn't determine
	   * the guidetree, but rather the SS_cons *and* the number
	   * and spacing of the inserts determined the guidetree; now
	   * the SS_cons and RF annotation completely determine the
	   * guidetree.
	   */
	  v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, BIF_nd);

	  i_cpos = a2c_map[i];
	  j_cpos = a2c_map[j];
	  bestk = ct[i]+1;
	  bestdiff = msa->alen+1; /* effectively infinity, difference in left/right subtree lengths can never exceed this */
	  for (k = ct[i] + 1; k <= ct[j]; k = ct[k] + 1)
	    {
	      /* set kp as the closest consensus position to k to the
	       * right (right side was chosen (over left) arbitrarily,
	       * practically it won't matter, as long as we always
	       * look the same way (right or left)) b/c what we really want
	       * is this choice to be deterministic based on SS_cons alone,
	       * that is a specific SS_cons yields same guide tree always,
	       * regardless of length and placement of inserts.
	       */
	      kp = k;
	      while(a2c_map[kp] == 0) kp++; /* increment kp until it's a consensus position */
	      k_cpos = a2c_map[kp];
	      diff = abs((k_cpos-i_cpos) - (j_cpos-k_cpos+1));
	      /* diff = abs(cons length modeled by left child minus cons length modeled by right child),
	       * Note that left child is i_cpos..k_cpos-1, right child is k_cpos..j_cpos
	       */

	      if (diff < bestdiff) {
		bestdiff = diff;
		bestk    = k;
	      }
	      while (ct[k] == 0) k++; /* at end of this while, k will be a paired, (and therefore consensus) position */
	    }
				/* push the right BEGIN node first */
	  if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, bestk)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, BEGR_nd)) != eslOK) goto ERROR;
				/* then push the left BEGIN node */
	  if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, bestk-1)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, BEGL_nd)) != eslOK) goto ERROR;
	  nstates += 1;		/* BIF_nd -> B_st */
	  nnodes++;
	}
	}	/* while something's on the stack */
  esl_stack_Destroy(pda);
  free(ct);

  /* Ok, we've converted ct into gtr -- gtr is a tree structure
   * telling us the arrangement of consensus nodes. Now do the drill
   * for constructing a full model using this guide tree. We only have
   * to do this step if we're returning a CM though. (Sometimes caller
   * may only want gtr.)
   */
  if(ret_cm != NULL) {
	cm = CreateCM(nnodes, nstates, clen, msa->abc);
	if((status = cm_from_guide(cm, errbuf, gtr, FALSE)) != eslOK) return status; /* FALSE says, we're not building a sub CM that will never be localized */
	CMZero(cm);
	cm->clen = clen;

	/* new in v1.1: fill cm->map (always) and fill cm->rf (if use_rf) */
	/* cm->map is identical to c2a_map, copy it */
	if(cm->map != NULL) free(cm->map); /* this is paranoid, it will be NULL */
	ESL_ALLOC(cm->map, sizeof(int) * (cm->clen+1));
	esl_vec_ICopy(c2a_map, (cm->clen+1), cm->map);
	cm->flags |= CMH_MAP;

	/* if <use_rf> == TRUE, msa->rf is transferred to cm->rf, from consensus positions */
	if(use_rf == TRUE) { /* if use_rf is TRUE, msa->rf is non-NULL */
	  if(cm->rf != NULL) free(cm->rf); /* this is paranoid, it will be NULL */
	  ESL_ALLOC(cm->rf, sizeof(char) * (cm->clen+2));
	  cm->rf[0] = ' ';
	  for(cpos = 1; cpos <= cm->clen; cpos++)
	cm->rf[cpos] = msa->rf[c2a_map[cpos]-1]; /* watch off-by-one in msa's rf */
	  cm->rf[cm->clen+1] = '\0';
	  cm->flags |= CMH_RF;
	}
  }

  if(matassign != NULL) free(matassign);
  if(elassign  != NULL) free(elassign);
  if(c2a_map   != NULL) free(c2a_map);
  if(a2c_map   != NULL) free(a2c_map);
  if (ret_cm  != NULL) *ret_cm  = cm;  else if(cm  != NULL) FreeCM(cm);
  if (ret_gtr != NULL) *ret_gtr = gtr; else if(gtr != NULL) FreeParsetree(gtr);
  return eslOK;

 ERROR:
  if(matassign != NULL) free(matassign);
  if(elassign  != NULL) free(elassign);
  if(c2a_map   != NULL) free(c2a_map);
  if(a2c_map   != NULL) free(a2c_map);
  if(cm        != NULL) FreeCM(cm);
  if(gtr       != NULL) FreeParsetree(gtr);
  if(ret_cm    != NULL) *ret_cm  = NULL;
  if(ret_gtr   != NULL) *ret_gtr = NULL;
  if(status == eslEMEM) ESL_FAIL(eslEMEM, errbuf, "HandModelmaker(): memory allocation error.");
  return status; /* never reached */
}

/* Function: cm_from_guide()
 * Date:     SRE, Sat Jul 29 09:25:49 2000 [St. Louis]
 *
 * Purpose:  given a guide tree and an allocated CM,
 *           fill in all the structural information of the CM.
 *
 * Args:     cm  - allocated cm to construct
 *           errbuf - for error messages
 *           gtr - guide tree
 *           will_never_localize- TRUE if we're building a sub CM that we will never localize.
 *                                This is only relevant b/c we can allow 'invalid' CMs in this case.
 *                                An invalid CM is one that, if localized, could not generate all
 *                                possible sequences (see comments in code below).
 *                                We allow sub CMs to be invalid b/c we don't want cmalign to die
 *                                when a target seq results in a sub CM that is invalid in the middle
 *                                of a run. This is a pure hack and relies UNSAFELY on the assumption
 *                                that the sub CM will never be localized (though in the current
 *                                implementation sub CMs are only used by cmalign in global mode, thus
 *                                they never are localized). Still, we don't raise a flag in the
 *                                CM to prevent downstream localization, which is dangerous - if the
 *                                implementation changes to allow sub CMs to become localized. Even then
 *                                though the risk is small b/c an invalid CM only is a problem if we
 *                                try to align a single residue sequence to it (again, see comments below
 *                                for more explanation).
 *
 * Returns:  eslOK on success;
 */
int
cm_from_guide(CM_t *cm, char *errbuf, Parsetree_t *gtr, int will_never_localize)
{
  int         status;
  ESL_STACK  *pda;              /* pushdown stack used for traversing gtr */
  int         v;		/* what node we're working on (in gtr index system)*/
  int         node;		/* what node (preorder traversal numbering of CM) */
  int         state;		/* what state (preorder traversal numbering of CM) */
  int         clen;		/* current count of consensus length   */
  int  nxtnodetype;		/* type of a child node (e.g. MATP_nd) */
  int  prvnodetype;		/* type of a parent node (e.g. MATP_nd) */

  /* Some CM structural configuration info:
   * child_count[] gives how many states are connectable in a child node.
   * parent_count[] gives how many states are connectable in a parent node.
   */
 				/* BIF, MATP, MATL, MATR, BEGL, BEGR, ROOT, END */
  int child_count[] =             {  1,    4,    2,    2,    1,    1,    0,   1};
  int parent_count[] =            {  1,    6,    3,    3,    1,    2,    3,   0};

  node = state = clen = 0;
  pda = esl_stack_ICreate();
  if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;		/* push ROOT_nd onto the stack */
  while (esl_stack_IPop(pda, &v) != eslEOD)
	{

	  if      (gtr->state[v] == BIF_nd) {
	prvnodetype = gtr->state[gtr->prv[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node ] = BIF_nd;

	cm->sttype[state] = B_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = BIF_B;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = -1; /* we fill this in later, when we see the BEGR... */
	if((status = esl_stack_IPush(pda, state)) != eslOK) goto ERROR;	/* ... the trick we use to remember the connection */
	cm->plast[state] = state-1;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtr[v])) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == MATP_nd) {
	nxtnodetype = gtr->state[gtr->nxtl[v]];
	prvnodetype = gtr->state[gtr->prv[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node ] = MATP_nd;
	clen             += 2;

	cm->sttype[state] = MP_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_MP;
	cm->cfirst[state] = state+4;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state-1;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = ML_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_ML;
	cm->cfirst[state] = state+3;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state-2;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = MR_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_MR;
	cm->cfirst[state] = state+2;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state-3;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = D_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_D;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state-4;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = IL_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_IL;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 5;
	state++;

	cm->sttype[state] = IR_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATP_IR;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 6;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == MATL_nd) {
	nxtnodetype = gtr->state[gtr->nxtl[v]];
	prvnodetype = gtr->state[gtr->prv[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node ] = MATL_nd;
	clen             += 1;

	cm->sttype[state] = ML_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATL_ML;
	cm->cfirst[state] = state+2;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state-1;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = D_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATL_D;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state-2;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = IL_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATL_IL;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 3;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == MATR_nd) {
	nxtnodetype = gtr->state[gtr->nxtl[v]];
	prvnodetype = gtr->state[gtr->prv[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node ] = MATR_nd;
	clen             += 1;

	cm->sttype[state] = MR_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATR_MR;
	cm->cfirst[state] = state+2;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state-1;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = D_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATR_D;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state-2;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	cm->sttype[state] = IR_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = MATR_IR;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 3;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == BEGL_nd) {
	nxtnodetype = gtr->state[gtr->nxtl[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node]  = BEGL_nd;

	cm->sttype[state] = S_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = BEGL_S;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = child_count[nxtnodetype];
	cm->plast[state] = state-1;
	cm->pnum[state]   = 1;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == BEGR_nd) {
	int bifparent;

	nxtnodetype = gtr->state[gtr->nxtl[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node]  = BEGR_nd;

	/* A trick: we need to attach this start state to the previous
	 * bifurcation. We stored the bif state index by pushing it onto
	 * the pda -- retrieve it now.
	 */
	esl_stack_IPop(pda, &bifparent);
	cm->cnum[bifparent] = state; /* remember, cnum overloaded for bif: idx of right child */

	cm->sttype[state] = S_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = BEGR_S;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = bifparent;
	cm->pnum[state]   = 1;
	state++;

	cm->sttype[state] = IL_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = BEGR_IL;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 2;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == ROOT_nd) {
	nxtnodetype = gtr->state[gtr->nxtl[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node]  = ROOT_nd;

	cm->sttype[state] = S_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = ROOT_S;
	cm->cfirst[state] = state+1;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = -1;
	cm->pnum[state]   = 0;
	state++;

	cm->sttype[state] = IL_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = ROOT_IL;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 2 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 2;
	state++;

	cm->sttype[state] = IR_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = ROOT_IR;
	cm->cfirst[state] = state;
	cm->cnum[state]   = 1 + child_count[nxtnodetype];
	cm->plast[state] = state;
	cm->pnum[state]   = 3;
	state++;

	node++;
	if((status = esl_stack_IPush(pda, gtr->nxtl[v])) != eslOK) goto ERROR;
	  }

	  else if (gtr->state[v] == END_nd) {
	prvnodetype = gtr->state[gtr->prv[v]];

	cm->nodemap[node] = state;
	cm->ndtype[node]  = END_nd;

	cm->sttype[state] = E_st;
	cm->ndidx[state]  = node;
	cm->stid[state]   = END_E;
	cm->cfirst[state] = -1;
	cm->cnum[state]   = 0;
	cm->plast[state] = state-1;
	cm->pnum[state]   = parent_count[prvnodetype];
	state++;

	node++;
	  }
	}
  esl_stack_Destroy(pda);
  cm->M     = state;
  cm->nodes = node;
  cm->clen  = clen;

  if(!will_never_localize) { /* input arg tells us we may localize this CM, check it's valid,
			      * if we won't localize it, then we don't check */
	/* A couple of checks to make sure our CM is valid for local alignment/search.
	 * The following is invalid:
	 * 1. CMs with exactly 3 nodes. This must be either {ROOT, MATL, END} or
	 *    {ROOT, MATP, END}. Either way a local end is impossible b/c local ends
	 *    from nodes adjacent to end states are impossible. This is bad. Even
	 *    worse is a {ROOT, MATL, END} model can't emit/align more than a single
	 *    residue in local mode (ROOT_IL, ROOT_IR are unreachable, and so is MATL_IL,
	 *    b/c it was detached to remove an ambiguity with ROOT_IR).
	 * 2. CMs with 0 MATL, MATR and BIF nodes. The reason is because such a CM only has
	 *    a ROOT, a bunch of MATPs and an END, and it is impossible to align a single
	 *    residue to such a model when it's in local mode.
	 */
	if(cm->nodes == 3) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_from_guide(), it's illegal to construct a CM of only 3 nodes.");
	if((CMCountNodetype(cm, MATL_nd) == 0) && (CMCountNodetype(cm, MATR_nd) == 0) && (CMCountNodetype(cm,BIF_nd) == 0)) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_from_guide(), it's illegal to construct a CM with 0 MATL, MATR and BIF nodes.");
  }
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "cm_from_guide(): memory allocation error.");
  return eslEMEM; /* NEVERREACHED */
}

/* Function: Transmogrify()
 * Date:     SRE, Mon Jul 31 14:30:58 2000 [St. Louis]
 *
 * Purpose:  Construct a "fake" parsetree for a given aligned sequence (ax),
 *           given a new CM structure (cm) and a guide tree (gtr).
 *
 *           Local alignment is only partially handled. EL emissions
 *           are handled by transiting to EL and emitted the required
 *           number of residues. <used_el> allows us to determine when
 *           this is necessary. Silent EL visits are never used
 *           however since it is (currently) impossible to distinguish
 *           them from a string of deletes. Local begins are not
 *           handled since there is no way to distinguish these from a
 *           string of deletes either (although we could if we
 *           annotated <ax> with '~' before and after the first and
 *           final emitted residues). Finally, truncated alignments
 *           are not handled, although, presumably we could, again
 *           with '~' in <ax>. If this function is revisited to add
 *           support for local begins and truncated begins/ends, refer
 *           to the Transmogrify() function in version 1.0.2, which
 *           partially implemented local begins using '~'.
 *
 *           Note, if <used_el> contains any TRUE values (i.e. any
 *           columns of the MSA are represented by EL) then the
 *           guide tree <gtr> should have been built by calling
 *           HandModelmaker() with <use_el> == TRUE. The caller
 *           must ensure this (we don't do it here). If not,
 *           we'll likely encounter an error in this function due
 *           to invalid input that is inconsistent with <gtr>.
 *
 * Args:     cm      - the new covariance model
 *           errbuf  - buffer for error messages
 *           gtr     - guide tree
 *           ax      - a digitized aligned sequence [1..L]
 *           used_el - used_el[x] = 1, if alnment position x is an alignment
 *                     column for EL (local end) emissions. Can be NULL
 *                     if no positions are EL positions.
 *           alen    - length of the alignment
 *           ret_tr  - parsetree, created here
 *
 * Returns:  eslOK on success.
 *
 * Throws:   eslEMEM if out of memory; errbuf filled, *ret_tr set to NULL.
 *           eslEINVAL on invalid input; errbuf filled, *ret_tr set to NULL.
 */
int
Transmogrify(CM_t *cm, char *errbuf, Parsetree_t *gtr, ESL_DSQ *ax, int *used_el, int alen, Parsetree_t **ret_tr)
{
  int          status;
  Parsetree_t *tr = NULL;
  int          node;		/* index of the node in *gtr* we're currently working on */
  int          state;		/* index of a state in the *CM*                          */
  int          type;		/* a unique statetype                                    */
  ESL_STACK   *pda = NULL;      /* pushdown automaton for positions in tr  */
  int          tidx;		/* index *in the parsetree tr* of the state we're supposed to attach to next */
  int          i,j;      	/* coords in aseq */
  int          ended;		/* TRUE if we've transited to EL and ended */
  int         *nxt_mi = NULL;  /* [1..apos..alen] nxt_mi[apos] is next alignment position > apos that
			        * includes a residue emitted from a match or insert state (not from the
			        * EL position).
			        */
  int         *nxt_el = NULL;  /* [1..apos..alen] nxt_el[apos] is next alignment position > apos that
			        * includes a residue emitted from the EL state (not from a match or insert
			        * state).
			        */
  int         apos, apos2, prv_mi, prv_el; /* helpers for filling nxt_emit_mi, nxt_emit_el */
  int         goto_el;         /* TRUE if we should transit to EL, FALSE if not */

  tr  = CreateParsetree(25);
  pda = esl_stack_ICreate();

  ended   = FALSE;

  /* If used_el is non-NULL then we need to fill <nxt_mi> with the next match/insert
   * emission and next EL emission <nxt_el> so we can identify transitions to EL
   * when necessary.
   */
  if(used_el != NULL) {
	ESL_ALLOC(nxt_mi, sizeof(int) * (alen+1));
	ESL_ALLOC(nxt_el, sizeof(int) * (alen+1));
	esl_vec_ISet(nxt_mi, (alen+1), alen+1);
	esl_vec_ISet(nxt_el, (alen+1), alen+1);
	prv_mi   = 0;
	prv_el   = 0;
	for (apos = 1; apos <= alen; apos++) {
	  if(! esl_abc_XIsGap(cm->abc, ax[apos])) {
	if(used_el[apos]) { /* an EL emission */
	  for(apos2 = prv_el; apos2 < apos; apos2++) nxt_el[apos2] = apos;
	  prv_el = apos;
	}
	else { /* an emit but not from an EL */
	  for(apos2 = prv_mi; apos2 < apos; apos2++) nxt_mi[apos2] = apos;
	  prv_mi = apos;
	}
	  }
	}
	/* don't worry about final consecutive string of gaps/ELs for nxt_mi/nxt_el, these were initialized to alen+1, which is correct */
  }

  /* Because the gtr is already indexed in a preorder traversal,
   * we can preorder traverse it easily w/ a for loop...
   */
  tidx = -1;			/* first state to attach to; -1 is special case for attaching root */
  for (node = 0; node < cm->nodes; node++)
	{
	  /* A (big) switch on node type.
	   */
	  switch (gtr->state[node]) { /* e.g. switch on node type: */

	/* The root node.
	 * Assume ROOT_S=0, ROOT_IL=1, ROOT_IR=2.
	 * ended is always FALSE when we get here.
	 */
	  case ROOT_nd:
	tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], 0);
	for (i = gtr->emitl[node]; i < gtr->emitl[gtr->nxtl[node]]; i++) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[i])) && (used_el == NULL || (! used_el[i]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, gtr->emitr[node], 1);
	  }
	}
	for (j = gtr->emitr[node]; j > gtr->emitr[gtr->nxtl[node]]; j--) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[j])) && (used_el == NULL || (! used_el[j]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, 2);
	  }
	}
	break;

	/* A bifurcation node.
	 * Assume that we'll process the BEGL node next; push info
	 * for BEGR onto the PDA.
	 * If we ended above here, the B doesn't go into the parsetree.
	 */
	  case BIF_nd:
	if (ended) break;
	state = CalculateStateIndex(cm, node, BIF_B);
	tidx  = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], state);
	if((status = esl_stack_IPush(pda, ended))   != eslOK) goto ERROR; /* remember our ending status */
	if((status = esl_stack_IPush(pda, tidx))    != eslOK) goto ERROR; /* remember index in tr; we pop in BEGR */
	break;

	/* A MATP node.
	 * If we see '-','-' in the seq and we ended already,
	 * then we did an EL above here, just skip the node.
		 * Else, this is a real state: emission or deletion.
		 *    If we thought we ended, that's invalid input.
		 *    Else, attach this guy.
	 */
	  case MATP_nd:
	if (esl_abc_XIsGap(cm->abc, ax[gtr->emitl[node]])) {
	  if (esl_abc_XIsGap(cm->abc, ax[gtr->emitr[node]])) type = MATP_D;
	  else                                               type = MATP_MR;
	} else {
	  if (esl_abc_XIsGap(cm->abc, ax[gtr->emitr[node]])) type = MATP_ML;
	  else                                               type = MATP_MP;
	}
	if (type == MATP_D && ended) break; /* used an EL above here, skip the node */
	if (ended) ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify(): MATP_nd we've ended but see an emission, ELs probably incorrectly handled");

	state = CalculateStateIndex(cm, node, type);
	tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], state);

	if(type == MATP_MP && used_el != NULL && cm->ndtype[node+1] != END_nd) {
	  /* Check if we should use an EL. */
	  if((status = check_for_el(ax, cm->abc, used_el, nxt_mi, nxt_el, gtr->emitl[node]+1, gtr->emitr[node]-1, &goto_el, &i, &j)) != eslOK) {
	    ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify() MATP_nd ELs incorrectly handled");
	  }
	  if(goto_el) {
	    state = cm->M;
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	    ended = TRUE;
	  }
	}
	if(ended) break;

	state = CalculateStateIndex(cm, node, MATP_IL);
	for (i = gtr->emitl[node]+1; i < gtr->emitl[gtr->nxtl[node]]; i++) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[i])) && (used_el == NULL || (! used_el[i]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, gtr->emitr[node]-1, state);
	  }
	}

	state = CalculateStateIndex(cm, node, MATP_IR);
	for (j = gtr->emitr[node]-1; j > gtr->emitr[gtr->nxtl[node]]; j--) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[j])) && (used_el == NULL || (! used_el[j]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	  }
	}
	break;

	/* A MATL node.
	 * If we see '-','-' in the seq and we ended already,
	 * then we did an EL above here, just skip the node.
	 * Else, this is a real state (emission or deletion).
	 *   If we thought we ended, this is invalid input.
	 *   Else, attach this guy.
	 */
	  case MATL_nd:
	if (esl_abc_XIsGap(cm->abc, ax[gtr->emitl[node]])) type = MATL_D;
	else                                               type = MATL_ML;
	if (type == MATL_D && ended) break; /* used an EL above here, skip this node */
	if (ended) ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify(): MATL_nd we've ended but see an emission, ELs probably incorrectly handled");

	state = CalculateStateIndex(cm, node, type);
	tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], state);

	if(type == MATL_ML && used_el != NULL && cm->ndtype[node+1] != END_nd) {
	  /* Check if we should use an EL. */
	  if((status = check_for_el(ax, cm->abc, used_el, nxt_mi, nxt_el, gtr->emitl[node]+1, gtr->emitr[node], &goto_el, &i, &j)) != eslOK) {
	    ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify() MATL_nd ELs incorrectly handled");
	  }
	  if(goto_el) {
	    state = cm->M;
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	    ended = TRUE;
	  }
	}
	if(ended) break;

	state = CalculateStateIndex(cm, node, MATL_IL);
	for (i = gtr->emitl[node]+1; i < gtr->emitl[gtr->nxtl[node]]; i++) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[i])) && (used_el == NULL || (! used_el[i]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, gtr->emitr[node], state);
	  }
	}
	break;

	/* MATR node.
	 * Similar logic as MATL above.
	 */
	case MATR_nd:
	if (esl_abc_XIsGap(cm->abc, ax[gtr->emitr[node]])) type = MATR_D;
	else                                               type = MATR_MR;
	if (type == MATR_D && ended) break; /* used an EL above here, skip this node */
	if (ended) ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify(): MATR_nd we've ended but see an emission, ELs probably incorrectly handled");

	state = CalculateStateIndex(cm, node, type);
	tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], state);
	if(type == MATR_MR && used_el != NULL && cm->ndtype[node+1] != END_nd) {
	  /* Check if we should use an EL */
	  if((status = check_for_el(ax, cm->abc, used_el, nxt_mi, nxt_el, gtr->emitl[node], gtr->emitr[node]-1, &goto_el, &i, &j)) != eslOK) {
	    ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify() MATR_nd ELs incorrectly handled");
	  }
	  if(goto_el) {
	    state = cm->M;
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	    ended = TRUE;
	  }
	}
	if(ended) break;

	state = CalculateStateIndex(cm, node, MATR_IR);
	for (j = gtr->emitr[node]-1; j > gtr->emitr[gtr->nxtl[node]]; j--) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[j])) && (used_el == NULL || (! used_el[j]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], j, state);
	  }
	}
	break;

	/* BEGL_nd.
	 * If ended, skip node.
	 * Else, attach it.
	 */
	  case BEGL_nd:
	if (ended)     break;
	state = CalculateStateIndex(cm, node, BEGL_S);
	tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, gtr->emitl[node], gtr->emitr[node], state);

	if(cm->ndtype[node+1] != END_nd && used_el != NULL) {
	  /* Check if we should use an EL. Same rule as above for MATP, MATL, MATR */
	  if((status = check_for_el(ax, cm->abc, used_el, nxt_mi, nxt_el, gtr->emitl[node], gtr->emitr[node], &goto_el, &i, &j)) != eslOK) {
	    ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify() MATR_nd ELs incorrectly handled");
	  }
	  if(goto_el) {
	    state = cm->M;
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	    ended = TRUE;
	  }
	}
	break;

	/* BEGR_nd.
	 * Pop off info on whether we ended above this node in the CM.
	 * If ended, skip node.
	 * Logic different than BEGL above, because BEGR is dealing
	 * with an insert left state. For the insert, if we think
	 * we've ended already, that's an invalid input.
	 */
	case BEGR_nd:
	esl_stack_IPop(pda, &tidx);    /* recover parent bifurcation's index in trace */
	esl_stack_IPop(pda, &ended);   /* did we end above here? */

	if(ended)      break;
	state = CalculateStateIndex(cm, node, BEGR_S);
	tidx = InsertTraceNode(tr, tidx, TRACE_RIGHT_CHILD, gtr->emitl[node], gtr->emitr[node], state);

	if(cm->ndtype[node+1] != END_nd && used_el != NULL) {
	  /* Check if we should use an EL. Same rule as above for MATP, MATL, MATR, BEGL */
	  if((status = check_for_el(ax, cm->abc, used_el, nxt_mi, nxt_el, gtr->emitl[node], gtr->emitr[node], &goto_el, &i, &j)) != eslOK) {
	    ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify() MATR_nd ELs incorrectly handled");
	  }
	  if(goto_el) {
	    state = cm->M;
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, j, state);
	    ended = TRUE;
	  }
	}
	if(ended) break;

	state = CalculateStateIndex(cm, node, BEGR_IL);
	for (i = gtr->emitl[node]; i < gtr->emitl[gtr->nxtl[node]]; i++) {
	  if ((! esl_abc_XIsGap(cm->abc, ax[i])) && (used_el == NULL || (! used_el[i]))) {
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, i, gtr->emitr[node], state);
	  }
	}
	break;

	/* An END node.
	 * If we've already ended (on EL), skip.
	 */
	case END_nd:
	  if (! ended) {
	    state = CalculateStateIndex(cm, node, END_E);
	    tidx = InsertTraceNode(tr, tidx, TRACE_LEFT_CHILD, -1, -1, state);
	  }
	  break;

	default:
	  ESL_XFAIL(eslEINVAL, errbuf, "Transmogrify(): bogus node type");
	  }
	}
  if(pda    != NULL) esl_stack_Destroy(pda);
  if(nxt_mi != NULL) free(nxt_mi);
  if(nxt_el != NULL) free(nxt_el);

  *ret_tr = tr;
  return eslOK;

 ERROR:
  if(pda    != NULL) esl_stack_Destroy(pda);
  if(nxt_mi != NULL) free(nxt_mi);
  if(nxt_el != NULL) free(nxt_el);
  if(tr     != NULL) FreeParsetree(tr);
  *ret_tr = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "Out of memory");
  /* if status != eslEMEM, we've already filled errbuf, so we just return */
  return status;
}

/* Function:  check_for_el
 * Date:      EPN, Fri May 25 13:48:01 2012
 *
 * Purpose:   Helper function for Transmogrify(). Check if the
 *            aligned sequence in <ax> from <i0> to <j0> implies
 *            we should transition to an EL state and emit
 *            all residues between <i0> and <j0>.
 *
 *            The rule is that we should go to an EL if i0..j0 are all
 *            gaps OR EL columns, with at least 1 EL emission AND all
 *            EL columns in that stretch are contiguous. If all of
 *            these are true we should transit to an EL, else we
 *            shouldn't.
 *
 *            Caller should have made sure we're called only from
 *            states from which a legal EL is possible, and set <i0>
 *            and <j0> appropriately.
 *
 *            See definitions/comments in Transmogrify() for
 *            meaning of arguments.
 *
 * Returns:   eslOK on success. <ret_goto_el> is set to TRUE
 *            if we should transit to EL and <ret_i> and
 *            <ret_j> are set to boundaries of EL emissions
 *            in ax. If we should not transit to EL,
 *            <ret_goto_el> is set to FALSE, and <ret_i>
 *            <ret_j> are set to 0.
 *
 * Throws:    eslEINVAL if somethings wrong with the input,
 *            <ret_goto_el> is set to FALSE, <ret_i> and <ret_j>
 *            are set to FALSE.
 */
static int
check_for_el(const ESL_DSQ *ax, const ESL_ALPHABET *abc, const int *used_el, const int *nxt_mi, const int *nxt_el, int i0, int j0, int *ret_goto_el, int *ret_i, int *ret_j)
{
  int i, j, i2;
  int goto_el = FALSE;

  if(nxt_mi[i0-1] > nxt_el[i0-1] && nxt_mi[i0-1] > j0 && nxt_el[i0-1] <= j0) {
	/* gaps or ELs w/at least 1 EL emission stretch from i0..j0 => probably use an EL */
	/* determine first (i) and final (j) EL emission positions */
	i = i0;
	j = j0;
	while(esl_abc_XIsGap(abc, ax[i]) && i <= j0) i++;
	while(esl_abc_XIsGap(abc, ax[j]) && j >= i0) j--;
	if(i > j0 || (! used_el[i])) goto ERROR;
	if(j < i0 || (! used_el[j])) goto ERROR;
	/* final check: use EL if i..j are all EL positions, else don't.
	 * we may have two discontiguous EL blocks implying two ELs further down.
	 */
	for(i2 = i; i2 <= j; i2++) if(! used_el[i2]) break;
	if(i2 == j+1) goto_el = TRUE;

  }

  *ret_goto_el = goto_el;
  if(goto_el) *ret_i = i;
  else        *ret_i = 0;
  if(goto_el) *ret_j = j;
  else        *ret_j = 0;

  return eslOK;

 ERROR:
  *ret_goto_el = FALSE;
  *ret_i       = 0;
  *ret_j       = 0;
  return eslEINVAL;
}

/* Function: ConsensusModelmaker()
 * EPN 08.29.06 based closely on HandModelmaker:
 *              SRE 29 Feb 2000 [Seattle]; from COVE 2.0 code
 *
 * Purpose:  Construct a model given a stated structure. The structure
 *           is provided via a "ss_cons" (consensus structure) line, as would
 *           occur in an annotated SELEX or Stockholm file. Only > and < characters
 *           in this line are interpreted (as base pairs). Pseudoknots,
 *           if annotated, are ignored.
 *
 *           All positions/columns of the given structure are considered
 *           consensus, and this is the difference b/t this function and
 *           HandModelmaker. Also, this function does not take in a MSA
 *           data structure. It was originally written for building a
 *           new CM (a sub CM) that models a contiguous subset of columns
 *           of it's template (mother) CM.
 *
 * Args:     abc       - the alphabet
 *           errbuf    - for error messages
 *           ss_cons   - input consensus structure string
 *           clen      - length of ss_cons, number of consensus columns
 *           building_sub_model - TRUE if building a sub CM (usually TRUE)
 *           ret_cm    - RETURN: new model                      (maybe NULL)
 *           ret_gtr   - RETURN: guide tree for alignment (maybe NULL)
 *
 * Return:   eslOK on success;
 *           eslEINCOMPAT on contract violation
 */
int
ConsensusModelmaker(const ESL_ALPHABET *abc, char *errbuf, char *ss_cons, int clen, int building_sub_model, CM_t **ret_cm, Parsetree_t **ret_gtr)
{
  int             status;
  CM_t           *cm  = NULL;   /* new covariance model                       */
  Parsetree_t    *gtr = NULL;	/* guide tree for alignment                   */
  ESL_STACK      *pda = NULL;	/* pushdown stack used in building gtr        */
  int            *ct  = NULL;	/* 0..alen-1 base pair partners array         */
  int             v;		/* index of current node                      */
  int             i,j,k;	/* subsequence indices                        */
  int  type;			/* type of node we're working on              */
  int  diff, bestdiff, bestk;   /* used while finding optimal split points    */
  int  nnodes;			/* number of nodes in CM                      */
  int  nstates;			/* number of states in CM                     */
  int  obs_clen;                /* observed (MATL+MATR+2*MATP) consensus len  */

  if (ss_cons == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "No consensus structure annotation available in ConsensusModelmaker().");

  /* 1. Determine a "ct" array, base-pairing partners for each position.
   *    Disallow/ignore pseudoknots by removing them prior to making the ct array.
   *    ct[] values give the index of a base pairing partner, or 0 for unpaired positions.
   *    Even though ss_cons is in the 0..clen-1 coord system of msa, ct[]
   *    comes back in the 1..alen coord system of the sequence.
   */
  esl_wuss_nopseudo(ss_cons, ss_cons); /* remove pknots in place */
  ESL_ALLOC(ct, (clen+1) * sizeof(int));
  if ((status = esl_wuss2ct(ss_cons, clen, ct)) != eslOK) ESL_FAIL(status, errbuf, "Consensus string is inconsisent in ConsensusModelMaker().");

  /* 2. Construct a guide tree.
   *    This codes is borrowed from HandModelmaker(), where it
   *    was originally borrowed from yarn's KHS2Trace().
   *
   *    We also keep track of how many states we'll need in the final CM,
   *    so we'll know how much to allocate -- and the number of nodes,
   *    for informational purposes.
   */
  nstates = nnodes = 0;
  gtr = CreateParsetree(25);	/* the parse tree we'll grow        */
  pda = esl_stack_ICreate();    /* a pushdown stack for our indices */
  obs_clen = 0;

  /* Construction strategy has to make sure we number the nodes in
   * preorder traversal: for bifurcations, we can't attach the right
   * child until we've fully traversed the left side. Therefore, we have
   * to push what we intend to attach, and pop it later. And since we
   * don't know an index for the node until we attach it, we have no
   * place to put the node's data except the stack -- so we have to
   * push several numbers onto the stack: what type of node, what
   * subseq it's responsible for (emitl...emitr), and what node
   * index it attaches to.
   *
   * Note that we have to deal with the fact that ct is off-by-one
   * in both indices and values: e.g. the base pairing partner
   * j of residue i is ct[i-1]-1.
   */
  if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* what node it's attached to */
  if((status = esl_stack_IPush(pda, 1)) != eslOK) goto ERROR;		/* emitl */
  if((status = esl_stack_IPush(pda, clen)) != eslOK) goto ERROR;	/* emitr */
  if((status = esl_stack_IPush(pda, ROOT_nd)) != eslOK) goto ERROR;	/* "state" (e.g. node type) */

  while (esl_stack_IPop(pda, &type) != eslEOD) /* pop a node type to attach */
	{
	  esl_stack_IPop(pda, &j);
	  esl_stack_IPop(pda, &i); /* i..j == subseq we're responsible for */
	  esl_stack_IPop(pda, &v); /* v = index of parent node in gtr */

	  /* This node accounts for i..j, but we usually don't know how yet.
	   * Six possibilities:
	   *    i > j; this is an END state; do nothing.
	   *    this is already assigned as a BEGIN; push i,j
	   *    i is unpaired; this is a MATL state; push i+1, j
	   *    j is unpaired; this is a MATR state; push i,j-1
	   *    i,j pair to each other; this is a MATP state; push i+1,j-1
	   *    i,j pair but not to each other; this is a BIFURC state;
	   *        pick mid ip <= mid < jp; push BEGIN i,mid and working i,mid,
	   *        and push BEGIN mid+1,j and working mid+1,j
	   */
	  if (i > j) {
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, END_nd);
	nstates += 1;		/* END_nd -> E_st */
	nnodes++;
	  }

	  else if (type == ROOT_nd) { /* try to push i,j; but deal with INSL and INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, ROOT_nd);
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;	/* here v==0 always. */
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* ROOT_nd -> S_st, IL_st, IR_st */
	nnodes++;
	  }

	  else if (type == BEGL_nd) {    /* no inserts */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, BEGL_nd);
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 1;		/* BEGL_nd -> S_st */
	nnodes++;
	  }

	  else if (type == BEGR_nd)  { /* look for INSL */
	v = InsertTraceNode(gtr, v, TRACE_RIGHT_CHILD, i, j, BEGR_nd);
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 2;		/* BEGR_nd -> S_st IL_st */
	nnodes++;
	  }

	  else if (ct[i] == 0) {
	 	/* i unpaired. This is a MATL node; allow INSL */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, MATL_nd);
	i++;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* MATL_nd -> ML_st, D_st, IL_st */
	nnodes++;
	obs_clen++;
	  }

	  else if (ct[j] == 0) { 	/* j unpaired. MATR node. Deal with INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, MATR_nd);
	j--;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 3;		/* MATR_nd -> MR_st, D_st, IL_st */
	nnodes++;
	obs_clen++;
	  }

	  else if (ct[i] == j) { /* i,j paired to each other. MATP. deal with INSL, INSR */
	v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, MATP_nd);
	i++;
	j--;
	if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	if((status = esl_stack_IPush(pda, DUMMY_nd)) != eslOK) goto ERROR; /* we don't know yet what the next node will be */
	nstates += 6;		/* MATP_nd -> MP_st, ML_st, MR_st, D_st, IL_st, IR_st */
	nnodes++;
	obs_clen += 2;
	  }

	  else /* i,j paired but not to each other. BIFURC. no INS. */
	{
	  /* Here's the first of two places where we can optimize the topology
		   * of a CM. (The other comes from choosing a state traversal order when
		   * building the CM.) Imagine a multifurcation of four domains:
		   *   [1]..[2]..[3]..[4]
		   * The "default leftwise" rule means that BEGL/INSL generates the
		   * intervening sequences, so we must model the four stems as:
		   *   [1],    ..[2],    ..[3],   ..[4]
		   * but we have a choice of how we bifurcate:
		   *   (1,2)(3,4)    1,(2,(3,4))   ((1,2),3),4
		   * Our choice affects the time and memory requirements of a divide
		   * conquer alignment algorithm. (1,(2,(3,4)) is most efficient for
		   * memory; (1,2)(3,4) is most efficient for time.
		   *
		   * So we may want to choose carefully from several possible split
		   * points k (3, in the above example). A priori we only know one
		   * possible midpoint precisely: ct[i]+1, the next base after closing
		   * domain 1. We can find the others by scanning for them, and we can
		   * be reasonably efficient about scanning by using ct[] to instantly
		   * skip subdomains.
	   */
	  /* One possible rule: optimize by finding most balanced split.
		   * Each stop of the following loop gives a possible midpoint k, which is
		   * then evaluated, keeping track of the best split so far.
		   */
	  /* EPN, Tue Sep 9 07:41:28 2008
	   * Note: HandModelmaker() was revised at precisely this point to chose
	   * k based on split lengths of consensus positions (instead of alignment
	   * positions), but we don't need that revision here b/c all positions
	   * are consensus so this code was already doing what the revised HandModelmaker()
	   * code now does. This is why this code block in Hand*() is more complex
	   * than the one here.
	   */
	  v = InsertTraceNode(gtr, v, TRACE_LEFT_CHILD, i, j, BIF_nd);

	  bestk    = ct[i]+1;
	  bestdiff = clen+1; /* effectively infinity, difference in left/right subtree lengths can never exceed this */
	  for (k = ct[i] + 1; k <= ct[j]; k = ct[k] + 1)
	    {
	      diff = abs((k-i) - (j-k+1));
	      /* diff = abs(cons length modeled by left child minus cons length modeled by right child),
	       * Note that left child is i..k-1, right child is k..j
	       */
	      if (diff < bestdiff) {
		bestdiff = diff;
		bestk    = k;
	      }
	      while (ct[k] == 0) k++;
	    }
				/* push the right BEGIN node first */
	  if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, bestk)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, BEGR_nd)) != eslOK) goto ERROR;
				/* then push the left BEGIN node */
	  if((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, i)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, bestk-1)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, BEGL_nd)) != eslOK) goto ERROR;
	  nstates += 1;		/* BIF_nd -> B_st */
	  nnodes++;
	}
	}	/* while something's on the stack */
  if(obs_clen != clen) cm_Fail("ConsensusModelMaker(): obs_clen: %d != passed in clen: %d\n", obs_clen, clen);
  esl_stack_Destroy(pda);
  free(ct);

  /* OK, we've converted ct into gtr -- gtr is a tree structure
   * telling us the arrangement of consensus nodes. Now do the drill
   * for constructing a full model using this guide tree. We only have
   * to do this step if we're returning a CM though. (Sometimes caller
   * may only want gtr.)
   */
  if(ret_cm != NULL) {
	cm = CreateCM(nnodes, nstates, clen, abc);
	if((status = cm_from_guide(cm, errbuf, gtr, building_sub_model)) != eslOK) return status;
	CMZero(cm);
	cm->clen = clen;
	/* note map and rf stay NULL (invalid) we could copy them from their mother,
	 * but not in this function (because we don't have the mother CM here) */
  }

  if (ret_cm  != NULL) *ret_cm  = cm;  else if(cm  != NULL) FreeCM(cm);
  if (ret_gtr != NULL) *ret_gtr = gtr; else if(gtr != NULL) FreeParsetree(gtr);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "ConsensusModelMaker(): memory allocation error.");
  return eslEMEM; /* never reached */

}

/**************************************************************************
 * EPN 09.25.06 [Parkway Hotel St. Louis, MO]
 * cm_find_and_detach_dual_inserts()
 *
 * Given a CM (potentially in counts form), find cases where two
 * insert states insert at the same position (due to an ambiguity in the
 * CM architecture). We know from the way CMs are constructed in
 * HandModelmaker() that one of these states must be an IL or IR state
 * immediately prior to an END_E state, and by the way counts are
 * collected in ParseTreeCount() that this END_E-1 state will
 * not be filled with any counts from the input seed sequences.
 * However, to be safe, there's an option to this function
 * to check to make sure both of these guarantees hold.
 *
 * Usually if this option is enabled with do_check=TRUE, the
 * CM is in counts form so its possible to check to make sure
 * the END_E-1 has 0 counts. Also, in this case the other option,
 * do_detach is set to FALSE to tell the function not to detach
 * the insert quite yet, we want to wait until the model has
 * been priorified - and once it has we revisit this function
 * with the do_check option as FALSE and do_detach as TRUE.
 * With do_detach == TRUE, we 'detach' the END_E-1 state by
 * setting all transitions into it as 0.0, making it impossible
 * to reach.
 *
 * There should be exactly 1 dual insert for every END_E state.
 *
 * Args:
 * CM_t  cm,
 * int   do_check;           TRUE to check the
 * Returns: TRUE on success if all dual inserts are found and detached.
 */
int
cm_find_and_detach_dual_inserts(CM_t *cm, int do_check, int do_detach)
{

  int          status;
  CMEmitMap_t *emap;         /* consensus emit map for the cm */
  int *cc2lins_map;
  int *cc2rins_map;
  int cc;
  int nd;
  int end_e_ct;
  int detach_ct;
  int v;

  end_e_ct = 0;
  detach_ct = 0;

  /* Determine the number of END_E states in the model, this
   * will be the number of inserts we want to detach.
   */
  for(v = 0; v <= cm->M; v++)
	if(cm->sttype[v] == E_st)
	  end_e_ct++;

  emap = CreateEmitMap(cm);
  /*DumpEmitMap(stdout, emap, cm);*/

  /* Based on the emitmap, make map of which nodes have an insert state that
   * inserts AFTER (in case of *lmap) and BEFORE (in case of *rmap)
   * each consensus node.
   * cc2lins_map[cc] = v, where cm state v is an IL_st that
   *                           emits after consensus column cc.
   * cc2rins_map[cc] = v, where cm state v is an IR_st that
   *                           emits after consensus column cc.
   * if no such state exists the value will be -1.
   */

  /* Allocate and initialize */
  ESL_ALLOC(cc2lins_map, sizeof(int) * (emap->clen + 1));
  ESL_ALLOC(cc2rins_map, sizeof(int) * (emap->clen + 1));
  for(cc = 0; cc <= emap->clen; cc++)
	{
	  cc2lins_map[cc] = -1;
	  cc2rins_map[cc] = -1;
	}
  /* fill in the map */
  /* ROOT is special */
  cc2lins_map[0] = 1; /* ROOT_IL */
  cc2rins_map[emap->clen] = 2; /* ROOT_IR */
  for(nd = 0; nd < cm->nodes; nd++)
	{
	  switch (cm->ndtype[nd]) {
	  case MATP_nd:
	cc2lins_map[emap->lpos[nd]] = cm->nodemap[nd] + 4; /* MATP_IL */
	cc2rins_map[emap->rpos[nd] - 1] = cm->nodemap[nd] + 5; /* MATP_IR */
	break;

	  case MATL_nd:
	cc2lins_map[emap->lpos[nd]] = cm->nodemap[nd] + 2; /* MATL_IL */
	break;

	  case MATR_nd:
	cc2rins_map[emap->rpos[nd] - 1] = cm->nodemap[nd] + 2; /* MATR_IR */
	break;

	  case BEGR_nd:
	cc2lins_map[emap->lpos[nd]] = cm->nodemap[nd] + 1; /* BEGR_IL */
	break;

	  default: {} /*do nothing*/
	  }
	}

  for(cc = 0; cc <= emap->clen; cc++)
	{
	  if(cc2lins_map[cc] != -1 && cc2rins_map[cc] != -1)
	{
	  detach_ct++;
	  /* Found a dual insert. */
	  if(do_check)
	    {
	      if(!(cm_check_before_detaching(cm, cc2lins_map[cc], cc2rins_map[cc])))
		cm_Fail("ERROR cm_check_before_detaching() returned false\n");
	    }
	  if(do_detach)
	    if(!(cm_detach_state(cm, cc2lins_map[cc], cc2rins_map[cc])))
	      cm_Fail("ERROR cm_detach_state() returned false\n");
	}
	}

  FreeEmitMap(emap);
  free(cc2lins_map);
  free(cc2rins_map);

  if(detach_ct != end_e_ct)
	return FALSE;
  else
	return TRUE;

 ERROR:
  cm_Fail("Memory allocation error.");
  return FALSE; /* never reached */
}

/**************************************************************************
 * EPN 09.18.06
 * cm_detach_state()
 *
 * Given two insert states that map to the same state in the original,
 * template CM, detach one of the them from the rest of the model by
 * setting all transitions into it to 0.0. We choose the state to detach
 * as the state that is immediately prior to an END_E in the sub_cm.
 * This will always be the case because the sole source of alignment
 * ambiguity in the CM architecture always involves 1 insert state
 * immediately before an END_E.
 *
 * Args:
 * CM_t  cm,
 * int   insert1;
 * int   insert2;
 * Returns: TRUE on success if insert1 or insert2 is a state immediately
 *          before an END_E, and we've detached it.
 *          FALSE otherwise
 */
int
cm_detach_state(CM_t *cm, int insert1, int insert2)
{
  /*printf("\t**in cm_detach_state: insert1: %d | insert2: %d\n", insert1, insert2);*/

  int ret_val;
  int x, y;
  int to_detach;
  int x_offset;

  ret_val = FALSE;

  if(insert1 == insert2)
	cm_Fail("ERROR in cm_detach_state: insert1==insert2:%d\n", insert1);

  if(cm->sttype[insert1+1] == E_st)
	{
	  ret_val = TRUE;
	  to_detach = insert1;
	}
  else
	{
	  if(cm->sttype[insert2+1] != E_st)
	cm_Fail("ERROR: in cm_detach_state insert1: %d and insert2: %d neither map to END_E-1 states.\n", insert1, insert2);
	  if(ret_val)
	cm_Fail("ERROR: in cm_detach_state insert1: %d and insert2: %d both map to END_E-1 states.\n", insert1, insert2);
	  ret_val = TRUE;
	  to_detach = insert2;
	}
  if(ret_val)
	{
	  /* Determine if we're detaching an IL_st, or the rare case of a MATP_IR st */
	  if(cm->sttype[to_detach] == IL_st)
	x_offset = 0;
	  else
	{
	  if(cm->stid[to_detach] != MATP_IR)
	    cm_Fail("ERROR: in cm_detach_state trying to detach a non-IL, non-MATP_IR state!\n");
	  x_offset = 1; /* MATP_* -> MATP_IR is second possible transition for MATP_*,
			 * unless * == MATP_IR, but we don't get there in for loop below. */
	}
	  for (y = cm->pnum[to_detach]-1; y >= 1; y--)
	/* y >= 1 means we never get to
	 * to_detach->to_detach prob, which is irrelevant. */
	{
	  x = cm->plast[to_detach] - y;
	  cm->t[x][x_offset] = 0.0; /* x is a split set state in same node
			      * as insert1, we're setting transition
			      * from x -> to_detach as impossible.
			      */
	  /* Renormalize transitions out of x */
	  esl_vec_FNorm(cm->t[x], cm->cnum[x]);
	  /*printf("****setting transition probabilitity of x: %d to to_detach: %d cm->t[x][%d] as 0.0\n", x, to_detach, x_offset);*/
	}
	}
  return ret_val;
}

/**************************************************************************
 * EPN 09.25.06
 * cm_check_before_detaching()
 *
 * Given two insert states that map to the same state in a CM, and
 * given the CM in counts form (after being filled with counts from
 * the parses implicit in the seed alignment), check the following
 * two guarantees are met:
 * (a) exactly one of the two inserts is immediately prior to an END_E
 *     state (END_E - 1).
 * (b) the END_E - 1 state has been parameterized with 0 counts from
 *     the input alignment.
 *
 * NOTE: A special case is when insert1 is the MATP_IL and insert2 the
 *       MATP_IR of the same MATP node. This is the only case where
 *       the insert state to be detached is not an IL state, but rather
 *       the MATP_IR (but the guarantees still hold, the MATP_IR is
 *       END_E - 1, and always gets 0 counts)
 *
 * Args:
 * CM_t  cm,
 * int   insert1;
 * int   insert2;
 * Returns: TRUE on success if insert1 or insert2 follow the guarantees
 *          FALSE otherwise
 */
int
cm_check_before_detaching(CM_t *cm, int insert1, int insert2)
{
  int ret_val;
  int i, yoffset;
  int to_detach;
  /*int to_keep;*/
  float diff;

  ret_val = FALSE;

  if(insert1 == insert2)
	cm_Fail("ERROR in cm_check_before_detaching(), insert1==insert2 (%d)\n", insert1);

  if(cm->sttype[insert1+1] == E_st)
	{
	  ret_val = TRUE;
	  to_detach = insert1;
	  /*to_keep   = insert2;*/
	}
  if(cm->sttype[insert2+1] == E_st)
	{
	  if(ret_val)
	cm_Fail("ERROR: in cm_check_before_detaching() insert1: %d and insert2: %d both map to END_E-1 states.\n", insert1, insert2);
	  ret_val = TRUE;
	  to_detach = insert2;
	  /*to_keep   = insert1;*/
	}

  /* check to make sure we have 0.0 counts in to_detach */
  if(ret_val)
	{
	  for(i = 0; i < cm->abc->K; i++)
	{
	  if(cm->e[to_detach][i] >= 0.)
	    diff = cm->e[to_detach][i] - 0.;
	  else
	    diff = 0. - cm->e[to_detach][i];
	  if(diff > 0.000001)
	    cm_Fail("ERROR, to_detach state: %d e->[%d] is non-zero but rather %f\n", to_detach, i, cm->e[to_detach][i]);
	}
	  for(yoffset = 0; yoffset < cm->cnum[to_detach]; yoffset++)
	{
	  /*printf("to_detach t[%d] cts: %f\n", yoffset, cm->t[to_detach][yoffset]);*/
	  if(cm->t[to_detach][yoffset] >= 0.)
	    diff = cm->t[to_detach][yoffset] - 0.;
	  else
	    diff = 0. - cm->t[to_detach][yoffset];
	  if(diff > 0.000001)
	    cm_Fail("ERROR, to_detach state: %d t->[%d] is non-zero but rather %f\n", to_detach, yoffset, cm->t[to_detach][yoffset]);
	}
	}
  return ret_val;
}

/* Functions: clean_cs()
 * Date:      SRE, Fri May 17 14:52:42 2002 [St. Louis]
 *
 * Purpose:   Verify and (if needed) clean the consensus structure annotation.
 */
int
clean_cs(char *cs, int alen, int be_quiet)
{
  int   status;
  int   i;
  int  *ct;
  int   nright = 0;
  int   nleft = 0;
  int   nbad = 0;
  char  example;
  int   first;
  int   has_pseudoknots = FALSE;

  /* 1. Check if we have a good CS line with >= 0 pseudoknotted
   *    base pairs.
   */
  ESL_ALLOC(ct, (alen+1) * sizeof(int));
  if (esl_wuss2ct(cs, alen, ct) != eslOK)
	cm_Fail("Consensus structure string is inconsistent");
  free(ct);

  /* 2. CS line is good, check for and remove pseudoknots
   *    if necessary. */
  if (check_for_pknots(cs, alen)) {
	has_pseudoknots = TRUE;
	if(!be_quiet) printf("    [Consensus structure has annotated pseudoknots that will be ignored.]\n");
	fflush(stdout);
  }
  else return TRUE; /* we're good, no need to clean it, there's no
		     * pseudoknots */

  /* 3. Delete everything we don't recognize.
   */
  for (i = 0; i < alen; i++)
	{
	  if      (strchr("{[(<", cs[i]) != NULL) nleft++;
	  else if (strchr(">)]}", cs[i]) != NULL) nright++;
	  else if (strchr(":_-,.~", cs[i]) != NULL) ;
	  else if (has_pseudoknots && isalpha((int) cs[i])) cs[i] = '.';
	  else {	/* count bad chars; remember first one; replace w/gap */
	if (nbad == 0) { example = cs[i]; first = i; }
	nbad++;
	cs[i] = '.';
	  }
	}
  if (nbad > 0) {
	if(!be_quiet) printf("    [Removed %d bad chars from consensus line. Example: a %c at position %d.]\n",
	   nbad, example, first);
	fflush(stdout);
  }

  /* Check it again.
   */
  ESL_ALLOC(ct, (alen+1) * sizeof(int));
  status = esl_wuss2ct(cs, alen, ct);
  free(ct);
  if(status == eslOK)
	return TRUE;
  printf("    [Failed to parse the consensus structure line.]\n");
  return FALSE;

 ERROR:
  cm_Fail("Memory allocation error.");
  return FALSE; /* never reached */
}

/* Functions: check_for_pknots()
 * Date:      EPN, Mon Aug  6 14:46:24 2007
 *
 * Purpose:   Simple check for pseudoknots in a consensus structure annotation.
 *            ASSUMES: CS has already been checked for consistency.
 */
static int
check_for_pknots(char *cs, int alen)
{
  int i;
  for (i = 0; i < alen; i++)
	{
	  if (isalpha((int) cs[i]))
	return TRUE; /* assumes we know the CS is consistent */
	}
  return FALSE;
}

/* Function:  cm_zero_flanking_insert_counts()
 * Synopsis:  Zero transition counts involved with ROOT_IL and ROOT_IR.
 * Incept:    EPN, Tue Apr  3 14:16:46 2012
 *
 * Purpose:   Given a CM in counts form (in the process of being built)
 *            zero the transitions into and out of the ROOT_IL and
 *            ROOT_IR emissions. Currently only called by cmbuild.
 *            Goal is to ignore any residues in the input MSA that
 *            occur before the first or after the last consensus
 *            column. That is, after this function is finished the CM
 *            should be identical to one in counts form that was built
 *            from an identical MSA with zero residues before the first
 *            consensus position and after the last.
 *
 * Returns:   eslOK on success;
 * Throws:    eslFAIL if CM does not seem to be in counts form, errbuf filled.
 */
int
cm_zero_flanking_insert_counts(CM_t *cm, char *errbuf)
{
  int status;

  /* verify model is not yet configured */
  if((status = cm_nonconfigured_Verify(cm, errbuf)) != eslOK) return status;

  /* There are four possible node types for node 1 (node following the
   * ROOT node), BIF, MATP, MATL and MATR. We add the counts from ROOT_IL
   * and ROOT_IR into each non-insert state in node 1 to the count from
   * ROOT_S into that non-insert state. After doing this, the counts
   * will be as if the ROOT_IL and ROOT_IR emissions did not exist
   * in the input MSA the counts were collected from.
   */

  /* For all cases, first set counts from ROOT_S -> ROOT_IL and
   * ROOT_S -> ROOT_IR to zero
   */
  cm->t[0][0] = 0.; /* ROOT_S -> ROOT_IL */
  cm->t[0][1] = 0.; /* ROOT_S -> ROOT_IR */

  if(cm->ndtype[1] == BIF_nd) {
	cm->t[0][2] += cm->t[1][2]; /* ROOT_S->BIF_B += ROOT_IL->BIF_B */
	cm->t[0][2] += cm->t[2][1]; /* ROOT_S->BIF_B += ROOT_IR->BIF_B */
  }
  else if(cm->ndtype[1] == MATP_nd) {
	cm->t[0][2] += cm->t[1][2]; /* ROOT_S->MATP_MP += ROOT_IL->MATP_MP */
	cm->t[0][2] += cm->t[2][1]; /* ROOT_S->MATP_MP += ROOT_IR->MATP_MP */

	cm->t[0][3] += cm->t[1][3]; /* ROOT_S->MATP_ML += ROOT_IL->MATP_ML */
	cm->t[0][3] += cm->t[2][2]; /* ROOT_S->MATP_ML += ROOT_IR->MATP_ML */

	cm->t[0][4] += cm->t[1][4]; /* ROOT_S->MATP_MR += ROOT_IL->MATP_MR */
	cm->t[0][4] += cm->t[2][3]; /* ROOT_S->MATP_MR += ROOT_IR->MATP_MR */

	cm->t[0][5] += cm->t[1][5]; /* ROOT_S->MATP_D  += ROOT_IL->MATP_D  */
	cm->t[0][5] += cm->t[2][4]; /* ROOT_S->MATP_D  += ROOT_IR->MATP_D  */
  }
  else { /* MATL_nd or MATR_nd */
	cm->t[0][2] += cm->t[1][2]; /* ROOT_S->MAT{L,R}_M{L,R} += ROOT_IL->MAT{L,R}_M{L,R} */
	cm->t[0][2] += cm->t[2][1]; /* ROOT_S->MAT{L,R}_M{L,R} += ROOT_IR->MAT{L,R}_M{L,R} */

	cm->t[0][3] += cm->t[1][3]; /* ROOT_S->MAT{L,R}_D      += ROOT_IL->MAT{L,R}_D */
	cm->t[0][3] += cm->t[2][2]; /* ROOT_S->MAT{L,R}_D      += ROOT_IR->MAT{L,R}_D */
  }

  /* Final step: zero transition counts out of ROOT_IL and ROOT_IR.
   * These will be completely determined by the prior. We have to
   * do this as a final step because we needed these counts
   * above.
   */
  esl_vec_FSet(cm->t[1], MAXCONNECT, 0.);
  esl_vec_FSet(cm->t[2], MAXCONNECT, 0.);

  return eslOK;
}

/*** End of inlined file: cm_modelmaker.c ***/


/*** Start of inlined file: cm_mx.c ***/

#include <stdio.h>
#include <stdlib.h>


static int cm_scan_mx_integerize     (CM_t *cm, CM_SCAN_MX *smx, char *errbuf);
static int cm_scan_mx_floatize       (CM_t *cm, CM_SCAN_MX *smx, char *errbuf);
static int cm_scan_mx_freefloats     (CM_t *cm, CM_SCAN_MX *smx);
static int cm_scan_mx_freeintegers   (CM_t *cm, CM_SCAN_MX *smx);
static int cm_tr_scan_mx_integerize  (CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf);
static int cm_tr_scan_mx_floatize    (CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf);
static int cm_tr_scan_mx_freefloats  (CM_t *cm, CM_TR_SCAN_MX *trsmx);
static int cm_tr_scan_mx_freeintegers(CM_t *cm, CM_TR_SCAN_MX *trsmx);

/*****************************************************************
 *   1. CM_MX data structure functions,
 *      matrix of float scores for nonbanded CM alignment.
 *****************************************************************/

/* Function:  cm_mx_Create()
 * Incept:    EPN, Wed Sep 14 04:33:17 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_MX> for a CM.
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_MX *
cm_mx_Create(int M)
{
  int     status;
  CM_MX *mx = NULL;
  int     v;
  int allocL = 1;
  int allocW = 1;

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_MX));
  mx->dp     = NULL;
  mx->dp_mem = NULL;

  /* level 2: deck (state) pointers, 0.1..M, go all the way to M
   */
  ESL_ALLOC(mx->dp,  sizeof(float **) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->dp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));

  for (v = 0; v < M; v++) {
	ESL_ALLOC(mx->dp[v], sizeof(float *) * (allocL));
	mx->dp[v][0]  = mx->dp_mem + v * (allocL) * (allocW);
  }
  /* allocate EL deck */
  ESL_ALLOC(mx->dp[M], sizeof(float *) * (allocL));
  mx->dp[M][0]  = mx->dp_mem + M * (allocL) * (allocW);

  mx->M              = M;
  mx->ncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->L              = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_MX)                           +
	 (mx->M+1)    * sizeof(float **)         +  /* mx->dp[] ptrs */
	 mx->ncells_alloc * sizeof(float)        +  /* mx->dp_mem */
	 (mx->M+1) * allocL * sizeof(float *));     /* mx->dp[v][] ptrs */
  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_mx_GrowTo()
 * Incept:    EPN, Wed Sep 14 04:40:25 2011
 *
 * Purpose: Assures that a CM_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, reallocating memory as necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL deck for the matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_mx_GrowTo(CM_t *cm, CM_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t cur_size = 0;
  int64_t ncells;
  float   Mb_needed;   /* required size of matrix */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     realloced; /* did we reallocate mx->dp_mem? */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_mx_SizeNeeded(cm, errbuf, L, &ncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full matrix? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  realloced = FALSE;
  if (ncells > mx->ncells_alloc) {
	  ESL_RALLOC(mx->dp_mem, p, sizeof(float) * ncells);
	  mx->ncells_alloc = ncells;
	  realloced = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced) {
	Mb_alloc -= (float) (sizeof(float) * ncells);
	Mb_alloc += (float) (sizeof(float) * mx->ncells_alloc);
  }
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->ncells_valid = ncells;

  /* reallocate the dp[v] ptrs */
  for(v = 0; v < mx->M; v++) {
	ESL_RALLOC(mx->dp[v], p, sizeof(float *) * (L+1));
  }
  if(have_el) {
	ESL_RALLOC(mx->dp[mx->M], p, sizeof(float *) * (L+1));
  }
  else if(mx->dp[mx->M] != NULL) {
	free(mx->dp[mx->M]);
	mx->dp[mx->M] = NULL;
  }

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	for(jp = 0; jp <= L; jp++) {
	  mx->dp[v][jp] = mx->dp_mem + cur_size;
	  cur_size += jp+1;
	}
  }
  if(have_el) {
	for(jp = 0; jp <= L; jp++) {
	  mx->dp[mx->M][jp] = mx->dp_mem + cur_size;
	  cur_size += jp+1;
	}
  }
  /*printf("ncells %10" PRId64 " %10" PRId64 "\n", cur_size, mx->ncells_valid);*/
  assert(cur_size == mx->ncells_valid);
  ESL_DASSERT1((cur_size == mx->ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Wed Sep 14 04:43:42 2011
 *
 * Purpose:   Frees a <CM_MX>.
 *
 * Returns:   (void)
 */
void
cm_mx_Destroy(CM_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->dp != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->dp[v] != NULL) free(mx->dp[v]);
  }
  free(mx->dp);

  if (mx->dp_mem  != NULL)  free(mx->dp_mem);
  free(mx);
  return;
}

/* Function:  cm_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Wed Sep 14 04:44:02 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_mx_Dump(FILE *ofp, CM_MX *mx, int print_mx)
{
  int v, j, d;

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "ncells_alloc: %" PRId64 "\nncells_valid: %" PRId64 "\n", mx->ncells_alloc, mx->ncells_valid);

  if(print_mx) {
	/* DP matrix data */
	for (v = 0; v < mx->M; v++) {
	  for(j = 0; j <= mx->L; j++) {
	for(d = 0; d <= j; d++) {
	  if(mx->dp[v]) fprintf(ofp, "dp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->dp[v][j][d]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
	/* print EL deck, if it's valid */
	v = mx->M;
	if(mx->dp[v]) {
	  for(j = 0; j <= mx->L; j++) {
	for(d = 0; d <= j; d++) {
	  fprintf(ofp, "dp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->dp[v][j][d]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
  }
  return eslOK;
}

/* Function:  cm_mx_SizeNeeded()
 * Incept:    EPN, Wed Sep 14 04:44:40 2011
 *
 * Purpose: Given a model and sequence length, determine the number of
 *            cells and total size in Mb required in a CM_MX for
 *            the target.
 *
 *            Return number of cells required in <ret_ncells> and size
 *            of required matrix in Mb in <ret_Mb>.
 *
 * Args:      cm     - the CM the matrix is for
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            ret_ncells - RETURN: number of matrix cells required
 *            ret_Mb - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_ncells, float *ret_Mb)
{
  int     v;
  int64_t ncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_MX) +
	 (cm->M+1) * sizeof(float **)); /* mx->dp[] ptrs */

  for(v = 0; v < cm->M; v++) {
	Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->dp[v][] ptrs */
	ncells += (int) ((L+2) * (L+1) * 0.5);
  }
  if(have_el) ncells += (int) ((L+2) * (L+1) * 0.5); /* space for EL deck */

  Mb_needed += sizeof(float) * ncells; /* mx->dp_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_ncells != NULL) *ret_ncells = ncells;
  if(ret_Mb     != NULL) *ret_Mb      = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *   2. CM_TR_MX data structure functions,
 *      matrix of float scores for nonbanded CM alignment
 *      using Kolbe and Eddy's 'truncated' DP CYK/Inside algorithms
 *****************************************************************/

/* Function:  cm_tr_mx_Create()
 * Incept:    EPN, Sat Sep 10 11:48:37 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_MX> for a CM.
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_TR_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_MX *
cm_tr_mx_Create(CM_t *cm)
{
  int     status;
  CM_TR_MX *mx = NULL;
  int     v, b;
  int allocL = 1;
  int allocW = 1;
  int B = CMCountNodetype(cm, BIF_nd);
  int M = cm->M;

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_MX));
  mx->Jdp     = NULL;
  mx->Jdp_mem = NULL;
  mx->Ldp     = NULL;
  mx->Ldp_mem = NULL;
  mx->Rdp     = NULL;
  mx->Rdp_mem = NULL;
  mx->Tdp     = NULL;
  mx->Tdp_mem = NULL;

  /* level 2: deck (state) pointers, 0.1..M, go all the way to M
   *          remember deck M is special, it only exists in J mode,
   *          and we allocate it only if nec (if local ends are on)
   *          in cm_tr_mx_GrowTo(). We still allocate a pointer to
   *          the M state deck in all modes though, it will remain
   *          NULL always for L,R,T.
   */
  ESL_ALLOC(mx->Jdp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Ldp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Rdp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Tdp,  sizeof(float **) * (M+1)); /* ptrs to non-ROOT_S and non-B states will be NULL */

  /* level 3: dp cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->Jdp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Ldp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Rdp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Tdp_mem,  sizeof(float) * (B+1) * (allocL) * (allocW)); /* +1 is for the special ROOT_S deck */

  b = 0;
  for (v = 0; v < M; v++) {
	ESL_ALLOC(mx->Jdp[v], sizeof(float *) * (allocL));
	ESL_ALLOC(mx->Ldp[v], sizeof(float *) * (allocL));
	ESL_ALLOC(mx->Rdp[v], sizeof(float *) * (allocL));
	mx->Jdp[v][0]  = mx->Jdp_mem + v * (allocL) * (allocW);
	mx->Ldp[v][0]  = mx->Ldp_mem + v * (allocL) * (allocW);
	mx->Rdp[v][0]  = mx->Rdp_mem + v * (allocL) * (allocW);

	if(cm->sttype[v] == B_st || v == 0) { /* only B states and ROOT_S are valid */
	  ESL_ALLOC(mx->Tdp[v], sizeof(float *) * (allocL));
	  mx->Tdp[v][0] = mx->Tdp_mem + b * (allocL) * (allocW);
	  b++;
	}
	else {
	  mx->Tdp[v] = NULL;
	}
  }
  /* allocate EL deck, for J, L, and R */
  ESL_ALLOC(mx->Jdp[M], sizeof(float *) * (allocL));
  ESL_ALLOC(mx->Ldp[M], sizeof(float *) * (allocL));
  ESL_ALLOC(mx->Rdp[M], sizeof(float *) * (allocL));
  mx->Jdp[M][0]  = mx->Jdp_mem + M * (allocL) * (allocW);
  mx->Ldp[M][0]  = mx->Ldp_mem + M * (allocL) * (allocW);
  mx->Rdp[M][0]  = mx->Rdp_mem + M * (allocL) * (allocW);

  mx->Tdp[M]  = NULL;

  mx->M               = M;
  mx->B               = B;
  mx->Jncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Lncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Rncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Tncells_alloc   = (B+1)*(allocL)*(allocW);
  mx->Jncells_valid   = 0;
  mx->Lncells_valid   = 0;
  mx->Rncells_valid   = 0;
  mx->Tncells_valid   = 0;
  mx->L               = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_TR_MX)                             +
	 (4 * (mx->M+1)    * sizeof(float **))           +  /* mx->{J,L,R}dp[] ptrs */
	 mx->Jncells_alloc * sizeof(float)               +  /* mx->Jdp_mem */
	 mx->Lncells_alloc * sizeof(float)               +  /* mx->Ldp_mem */
	 mx->Rncells_alloc * sizeof(float)               +  /* mx->Rdp_mem */
	 mx->Tncells_alloc * sizeof(float)               +  /* mx->Tdp_mem */
	 (3 * (mx->M+1) * allocL * sizeof(float *))      +  /* mx->{J,L,R}dp[v][] ptrs */
	 (1 * (mx->B+1) * allocL * sizeof(float *)));       /* mx->Tdp[v][] ptrs */
  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_mx_GrowTo()
 * Incept:    EPN, Sat Sep 10 11:50:23 2011
 *
 * Purpose: Assures that a CM_TR_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, reallocating memory as necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL deck for the J matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_mx_GrowTo(CM_t *cm, CM_TR_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t Jcur_size = 0;
  int64_t Lcur_size = 0;
  int64_t Rcur_size = 0;
  int64_t Tcur_size = 0;
  int64_t Jncells;
  int64_t Lncells;
  int64_t Rncells;
  int64_t Tncells;
  float   Mb_needed;   /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     realloced_J; /* did we reallocate mx->Jdp_mem? */
  int     realloced_L; /* did we reallocate mx->Ldp_mem? */
  int     realloced_R; /* did we reallocate mx->Rdp_mem? */
  int     realloced_T; /* did we reallocate mx->Tdp_mem? */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_tr_mx_SizeNeeded(cm, errbuf, L, &Jncells, &Lncells, &Rncells, &Tncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded Tr matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded Tr matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded Tr DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full {J,L,R.T}matrices? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  realloced_J = realloced_L = realloced_R = realloced_T = FALSE;
  if (Jncells > mx->Jncells_alloc) {
	  ESL_RALLOC(mx->Jdp_mem, p, sizeof(float) * Jncells);
	  mx->Jncells_alloc = Jncells;
	  realloced_J = TRUE;
  }
  if (Lncells > mx->Lncells_alloc) {
	  ESL_RALLOC(mx->Ldp_mem, p, sizeof(float) * Lncells);
	  mx->Lncells_alloc = Lncells;
	  realloced_L = TRUE;
  }
  if (Rncells > mx->Rncells_alloc) {
	  ESL_RALLOC(mx->Rdp_mem, p, sizeof(float) * Rncells);
	  mx->Rncells_alloc = Rncells;
	  realloced_R = TRUE;
  }
  if (Tncells > mx->Tncells_alloc) {
	  ESL_RALLOC(mx->Tdp_mem, p, sizeof(float) * Tncells);
	  mx->Tncells_alloc = Tncells;
	  realloced_T = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   * This is tricky, for each matrix not reallocated, we have to adjust Mb_needed
   * so it uses previously allocated size of that matrix.
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced_J) {
	Mb_alloc -= (float) (sizeof(float) * Jncells);
	Mb_alloc += (float) (sizeof(float) * mx->Jncells_alloc);
  }
  if(! realloced_L) {
	Mb_alloc -= (float) (sizeof(float) * Lncells);
	Mb_alloc += (float) (sizeof(float) * mx->Lncells_alloc);
  }
  if(! realloced_R) {
	Mb_alloc -= (float) (sizeof(float) * Rncells);
	Mb_alloc += (float) (sizeof(float) * mx->Rncells_alloc);
  }
  if(! realloced_T) {
	Mb_alloc -= (float) (sizeof(float) * Tncells);
	Mb_alloc += (float) (sizeof(float) * mx->Tncells_alloc);
  }
  /* note if we didn't reallocate any of the four matrices, Mb_alloc == Mb_needed */
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->Jncells_valid = Jncells;
  mx->Lncells_valid = Lncells;
  mx->Rncells_valid = Rncells;
  mx->Tncells_valid = Tncells;

  /* reallocate the {J,L,R,T}dp[v] ptrs */
  for(v = 0; v < mx->M; v++) {
	ESL_RALLOC(mx->Jdp[v], p, sizeof(float *) * (L+1));
	ESL_RALLOC(mx->Ldp[v], p, sizeof(float *) * (L+1));
	ESL_RALLOC(mx->Rdp[v], p, sizeof(float *) * (L+1));
	if(cm->sttype[v] == B_st || v == 0) { /* valid for B states and the ROOT_S */
	  ESL_RALLOC(mx->Tdp[v], p, sizeof(float *) * (L+1));
	}
	else {
	  mx->Tdp[v] = NULL;
	}
  }
  if(have_el) {
	ESL_RALLOC(mx->Jdp[mx->M], p, sizeof(float *) * (L+1));
	ESL_RALLOC(mx->Ldp[mx->M], p, sizeof(float *) * (L+1));
	ESL_RALLOC(mx->Rdp[mx->M], p, sizeof(float *) * (L+1));
	/* Tdp is NULL for cm->M */
  }
  else {
	if(mx->Jdp[mx->M] != NULL) {
	  free(mx->Jdp[mx->M]);
	  mx->Jdp[mx->M] = NULL;
	}
	if(mx->Ldp[mx->M] != NULL) {
	  free(mx->Ldp[mx->M]);
	  mx->Ldp[mx->M] = NULL;
	}
	if(mx->Rdp[mx->M] != NULL) {
	  free(mx->Rdp[mx->M]);
	  mx->Rdp[mx->M] = NULL;
	}
  }

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  Jcur_size = 0;
  Lcur_size = 0;
  Rcur_size = 0;
  Tcur_size = 0;
  for(v = 0; v < mx->M; v++) {
	for(jp = 0; jp <= L; jp++) {
	  mx->Jdp[v][jp] = mx->Jdp_mem + Jcur_size;
	  mx->Ldp[v][jp] = mx->Ldp_mem + Lcur_size;
	  mx->Rdp[v][jp] = mx->Rdp_mem + Rcur_size;
	  Jcur_size += jp+1;
	  Lcur_size += jp+1;
	  Rcur_size += jp+1;
	  if(cm->sttype[v] == B_st || v == 0) { /* valid for B states and the ROOT_S */
	mx->Tdp[v][jp] = mx->Tdp_mem + Tcur_size;
	Tcur_size += jp+1;
	  }
	}
  }
  if(have_el) {
	for(jp = 0; jp <= L; jp++) {
	  mx->Jdp[mx->M][jp] = mx->Jdp_mem + Jcur_size;
	  Jcur_size += jp+1;
	}
	for(jp = 0; jp <= L; jp++) {
	  mx->Ldp[mx->M][jp] = mx->Ldp_mem + Lcur_size;
	  Lcur_size += jp+1;
	}
	for(jp = 0; jp <= L; jp++) {
	  mx->Rdp[mx->M][jp] = mx->Rdp_mem + Rcur_size;
	  Rcur_size += jp+1;
	}
  }
  /*printf("J ncells %10" PRId64 " %10" PRId64 "\n", Jcur_size, mx->Jncells_valid);
	printf("L ncells %10" PRId64 " %10" PRId64 "\n", Lcur_size, mx->Lncells_valid);
	printf("R ncells %10" PRId64 " %10" PRId64 "\n", Rcur_size, mx->Rncells_valid);
	printf("T ncells %10" PRId64 " %10" PRId64 "\n", Tcur_size, mx->Tncells_valid);*/
  assert(Jcur_size == mx->Jncells_valid);
  assert(Lcur_size == mx->Lncells_valid);
  assert(Rcur_size == mx->Rncells_valid);
  assert(Tcur_size == mx->Tncells_valid);
  ESL_DASSERT1((Jcur_size == mx->Jncells_valid));
  ESL_DASSERT1((Lcur_size == mx->Lncells_valid));
  ESL_DASSERT1((Rcur_size == mx->Rncells_valid));
  ESL_DASSERT1((Tcur_size == mx->Tncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Thu Aug 25 14:51:15 2011
 *
 * Purpose:   Frees a <CM_TR_MX>.
 *
 * Returns:   (void)
 */
void
cm_tr_mx_Destroy(CM_TR_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->Jdp != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Jdp[v] != NULL) free(mx->Jdp[v]);
  }
  free(mx->Jdp);

  if (mx->Ldp != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Ldp[v] != NULL) free(mx->Ldp[v]);
  }
  free(mx->Ldp);

  if (mx->Rdp != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Rdp[v] != NULL) free(mx->Rdp[v]);
  }
  free(mx->Rdp);

  if (mx->Tdp != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Tdp[v] != NULL) free(mx->Tdp[v]);
  }
  free(mx->Tdp);

  if (mx->Jdp_mem  != NULL)  free(mx->Jdp_mem);
  if (mx->Ldp_mem  != NULL)  free(mx->Ldp_mem);
  if (mx->Rdp_mem  != NULL)  free(mx->Rdp_mem);
  if (mx->Tdp_mem  != NULL)  free(mx->Tdp_mem);
  free(mx);
  return;
}

/* Function:  cm_tr_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Thu Aug 25 14:52:40 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_mx_Dump(FILE *ofp, CM_TR_MX *mx, char mode, int print_mx)
{
  int status;
  int v, j, d;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "B: %d\n", mx->B);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "Jncells_alloc: %" PRId64 "\nJncells_valid: %" PRId64 "\n", mx->Jncells_alloc, mx->Jncells_valid);
  fprintf(ofp, "Lncells_alloc: %" PRId64 "\nLncells_valid: %" PRId64 "\n", mx->Lncells_alloc, mx->Lncells_valid);
  fprintf(ofp, "Rncells_alloc: %" PRId64 "\nRncells_valid: %" PRId64 "\n", mx->Rncells_alloc, mx->Rncells_valid);
  fprintf(ofp, "Tncells_alloc: %" PRId64 "\nTncells_valid: %" PRId64 "\n", mx->Tncells_alloc, mx->Tncells_valid);
  fprintf(ofp, "mode: %d\n", mode);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  if(print_mx) {
	/* DP matrix data */
	for (v = 0; v < mx->M; v++) {
	  for(j = 0; j <= mx->L; j++) {
	for(d = 0; d <= j; d++) {
	  if(mx->Jdp[v])           fprintf(ofp, "Jdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Jdp[v][j][d]);
	  if(fill_L && mx->Ldp[v]) fprintf(ofp, "Ldp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Ldp[v][j][d]);
	  if(fill_R && mx->Rdp[v]) fprintf(ofp, "Rdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Rdp[v][j][d]);
	  if(fill_T && mx->Tdp[v]) fprintf(ofp, "Tdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Tdp[v][j][d]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
	/* print EL deck, if it's valid */
	v = mx->M;
	for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	if(mx->Jdp[v])           fprintf(ofp, "Jdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Jdp[v][j][d]);
	if(fill_L && mx->Ldp[v]) fprintf(ofp, "Ldp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Ldp[v][j][d]);
	if(fill_R && mx->Rdp[v]) fprintf(ofp, "Rdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Rdp[v][j][d]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
  }
  return eslOK;
}

/* Function:  cm_tr_mx_SizeNeeded()
 * Incept:    EPN, Thu Aug 25 14:55:25 2011
 *
 * Purpose: Given a model and sequence length, determine the number of
 *            cells and total size in Mb required in a CM_TR_MX for
 *            the target given the bands.
 *
 *            Return number of cells required given the
 *            in <ret_n{J,L,R,T}cells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm     - the CM the matrix is for
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            ret_Jncells - RETURN: number of J matrix cells required
 *            ret_Lncells - RETURN: number of L matrix cells required
 *            ret_Rncells - RETURN: number of R matrix cells required
 *            ret_Tncells - RETURN: number of T matrix cells required
 *            ret_Mb - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_Jncells, int64_t *ret_Lncells, int64_t *ret_Rncells, int64_t *ret_Tncells, float *ret_Mb)
{
  int     v;
  int64_t Jncells, Lncells, Rncells, Tncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  Jncells = 0;
  Lncells = 0;
  Rncells = 0;
  Tncells   = 0;
  Mb_needed = (float)
	(sizeof(CM_TR_MX)                 +
	 (4 * (cm->M+1) * sizeof(float **))); /* mx->{J,L,R,T}dp[] ptrs */

  for(v = 0; v < cm->M; v++) {
	Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Jdp[v][] ptrs */
	Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Ldp[v][] ptrs */
	Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Rdp[v][] ptrs */
	if(cm->sttype[v] == B_st || v == 0) Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Tdp[v][] ptrs */
	Jncells += (int) ((L+2) * (L+1) * 0.5);
	Lncells += (int) ((L+2) * (L+1) * 0.5);
	Rncells += (int) ((L+2) * (L+1) * 0.5);
	if(cm->sttype[v] == B_st || v == 0) Tncells += (int) ((L+2) * (L+1) * 0.5);
  }
  if(have_el) { /* space for EL deck */
	Jncells += (int) ((L+2) * (L+1) * 0.5);
	Lncells += (int) ((L+2) * (L+1) * 0.5);
	Rncells += (int) ((L+2) * (L+1) * 0.5);
  }

  Mb_needed += sizeof(float) * Jncells; /* mx->Jdp_mem */
  Mb_needed += sizeof(float) * Lncells; /* mx->Ldp_mem */
  Mb_needed += sizeof(float) * Rncells; /* mx->Rdp_mem */
  Mb_needed += sizeof(float) * Tncells; /* mx->Tdp_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_Jncells != NULL) *ret_Jncells = Jncells;
  if(ret_Lncells != NULL) *ret_Lncells = Lncells;
  if(ret_Rncells != NULL) *ret_Rncells = Rncells;
  if(ret_Tncells != NULL) *ret_Tncells = Tncells;
  if(ret_Mb      != NULL) *ret_Mb      = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *   3. CM_HB_MX data structure functions,
 *      matrix of float scores for HMM banded CM alignment/search.
 *****************************************************************/

/* Function:  cm_hb_mx_Create()
 * Incept:    EPN, Fri Oct 26 05:05:07 2007
 *
 * Purpose:   Allocate a reusable, resizeable <CM_HB_MX> for a CM
 *            given a CP9Bands_t object that defines the bands.
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_HB_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_HB_MX *
cm_hb_mx_Create(int M)
{
  int     status;
  CM_HB_MX *mx = NULL;
  int     v;
  int allocL = 1;
  int allocW = 1;

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_HB_MX));
  mx->dp     = NULL;
  mx->dp_mem = NULL;
  mx->cp9b   = NULL;

  /* level 2: deck (state) pointers, 0.1..M, go all the way to M
   *          remember deck M is special, as it has no bands, we allocate
   *          it only if nec (if local ends are on) in cm_hb_mx_GrowTo()
   */
  ESL_ALLOC(mx->dp,  sizeof(float **) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->dp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->nrowsA, sizeof(int)    * (M+1));
  for (v = 0; v <= M; v++) {
	ESL_ALLOC(mx->dp[v], sizeof(float *) * (allocL));
	mx->nrowsA[v] = allocL;
	mx->dp[v][0]  = mx->dp_mem + v * (allocL) * (allocW);
  }
  mx->M            = M;
  mx->ncells_alloc = (M+1)*(allocL)*(allocW);
  mx->ncells_valid = 0;
  mx->L            = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_HB_MX) +
	 ((mx->M+1)        * sizeof(float **))       +  /* mx->dp[] ptrs */
	 mx->ncells_alloc  * sizeof(float)           +  /* mx->dp_mem */
	 ((mx->M+1)        * sizeof(int))            +  /* mx->nrowsA */
	 ((mx->M+1) * allocL * sizeof(float *)));       /* mx->dp[v][] ptrs */
  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_hb_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_hb_mx_GrowTo()
 * Incept:    EPN, Fri Oct 26 05:19:49 2007
 *
 * Purpose:   Assures that a DP matrix <mx> is allocated
 *            for a model of exactly <mx->M> states and required number of
 *            total cells. Determines new required size from
 *            the CP9Bands_t object passed in, and reallocates if
 *            necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL deck.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_hb_mx_GrowTo(CM_t *cm, CM_HB_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t cur_size = 0;
  int64_t ncells;
  int     jbw;
  float   Mb_needed;   /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  /* contract check, number of states (M) is something we don't change
   * so check this matrix has same number of 1st dim state ptrs that
   * cp9b has */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_mx_GrowTo() entered with cp9b == NULL.\n");
  if(cp9b->cm_M != mx->M) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_mx_GrowTo() entered with mx->M: (%d) != cp9b->M (%d)\n", mx->M, cp9b->cm_M);

  if((status = cm_hb_mx_SizeNeeded(cm, errbuf, cp9b, L, &ncells, &Mb_needed)) != eslOK) return status;
  /* printf("HMM banded matrix requested size: %.2f Mb\n", Mb_needed); */
  ESL_DPRINTF2(("HMM banded matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* check if we should free and reallocate the matrix */
  if((mx->size_Mb > (0.5  * size_limit)) && /* matrix is >= 0.5 * size of our limit (based on bands from previous sequence) */
	 (mx->size_Mb > (1.25 * Mb_needed))) {  /* matrix is at least 25% bigger than we need to process current sequence */
	free(mx->dp_mem);
	mx->dp_mem = NULL;
	mx->ncells_alloc = 0;
  }

  /* must we realloc the full matrix? or can we get away with just
   * jiggering the pointers, if total required num cells is less
   * than or equal to what we already have alloc'ed?
   */
  if (ncells > mx->ncells_alloc) {
	  ESL_RALLOC(mx->dp_mem, p, sizeof(float) * ncells);
	  mx->ncells_alloc = ncells;
	  Mb_alloc = Mb_needed;
  }
  else {
	/* mx->dp_mem remains as it is allocated, set Mb_alloc accordingly
	 * (this is not just mx->size_Mb, because size of pointer arrays
	 * may change, for example)
	 */
	Mb_alloc  = Mb_needed * 1000000.; /* convert to bytes */
	Mb_alloc -= ((float) (sizeof(float) * ncells));
	Mb_alloc += ((float) (sizeof(float) * mx->ncells_alloc));
	Mb_alloc *= 0.000001; /* convert to Mb */
  }
  mx->ncells_valid = ncells;

  for(v = 0; v < mx->M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v] + 1;
	if(jbw > mx->nrowsA[v]) {
	  ESL_RALLOC(mx->dp[v], p, sizeof(float *) * jbw);
	  mx->nrowsA[v] = jbw;
	}
  }
  if(have_el) {
	jbw = L+1;
	if(jbw > mx->nrowsA[mx->M]) {
	  ESL_RALLOC(mx->dp[mx->M], p, sizeof(float *) * jbw);
	  mx->nrowsA[mx->M] = jbw;
	}
  }

  /* reset the pointers, we keep a tally of cur_size as we go,
   * we could precalc it and store it for each v,j, but that
   * would be wasteful, as we'll only use the matrix configured
   * this way once, in a banded CYK run.
   */
  cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->dp[v][jp] = mx->dp_mem + cur_size;
	  cur_size     += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
  }
  if(have_el) {
	for(jp = 0; jp <= L; jp++) {
	  mx->dp[mx->M][jp] = mx->dp_mem + cur_size;
	  cur_size     += jp + 1;
	}
  }
  ESL_DASSERT1((cur_size == mx->ncells_valid));
  /*printf("ncells %10" PRId64 " %10" PRId64 "\n", cur_size, mx->ncells_valid);*/

  mx->cp9b = cp9b; /* just a reference */

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hb_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Fri Oct 26 09:04:04 2007
 *
 * Purpose:   Frees a <CM_HB_MX>.
 *
 * Returns:   (void)
 */
void
cm_hb_mx_Destroy(CM_HB_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->dp      != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->dp[v] != NULL) free(mx->dp[v]);
  }
  free(mx->dp);

  if (mx->nrowsA  != NULL)  free(mx->nrowsA);
  if (mx->dp_mem  != NULL)  free(mx->dp_mem);
  free(mx);
  return;
}

/* Function:  cm_hb_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Fri Oct 26 09:04:46 2007
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_hb_mx_Dump(FILE *ofp, CM_HB_MX *mx, int print_mx)
{
  int v, jp, j, dp, d;

  fprintf(ofp, "M: %d\nL: %d\ncells_alloc: %" PRId64 "\nncells_valid: %" PRId64 "\n", mx->M, mx->L, mx->ncells_alloc, mx->ncells_valid);

  if(print_mx) {
	/* DP matrix data */
	for (v = 0; v < mx->M; v++) {
	  for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	j = jp + mx->cp9b->jmin[v];
	for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	  d = dp + mx->cp9b->hdmin[v][jp];
	  fprintf(ofp, "dp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->dp[v][jp][dp]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
	/* print EL deck, if it's valid */
	v = mx->M;
	if(mx->nrowsA[mx->M] == (mx->L+1)) {
	  for(j = 0; j <= mx->L; j++) {
	for(d = 0; d <= j; d++) {
	  fprintf(ofp, "dp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->dp[v][j][d]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
  }
  return eslOK;
}

/* Function:  cm_hb_mx_SizeNeeded()
 * Incept:    EPN, Thu Aug 11 14:51:04 2011
 *
 * Purpose:   Given a model and CP9_bands_t object with
 *            pre-calced bands for a target, determine the number
 *            of cells and total size in Mb required in a CM_HB_MX
 *            for the target given the bands.
 *
 *            Return number of cells required given the bands
 *            in <cp9b> in <ret_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm     - the CM the matrix is for
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            ret_ncells - RETURN: number of cells required
 *            ret_Mb - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_hb_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int L, int64_t *ret_ncells, float *ret_Mb)
{
  int     v, jp;
  int64_t ncells;
  int     jbw;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  /* contract check */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_mx_SizeNeeded() entered with cp9b == NULL.\n");

  ncells = 0;
  Mb_needed = (float)
	(sizeof(CM_HB_MX) +
	 ((cp9b->cm_M+1) * sizeof(float **)) + /* mx->dp[] ptrs */
	 ((cp9b->cm_M+1) * sizeof(int)));      /* mx->nrowsA */

  for(v = 0; v < cp9b->cm_M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v];
	Mb_needed += (float) (sizeof(float *) * (jbw+1)); /* mx->dp[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++)
	  ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
  }
  if(have_el) ncells += (int) ((L+2) * (L+1) * 0.5); /* space for EL deck */

  Mb_needed += sizeof(float) * ncells; /* mx->dp_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_ncells != NULL) *ret_ncells = ncells;
  if(ret_Mb     != NULL) *ret_Mb     = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *   4. CM_TR_HB_MX data structure functions,
 *      matrix of float scores for HMM banded CM alignment/search
 *      using Kolbe and Eddy's 'truncated' DP CYK/Inside algorithms
 *****************************************************************/

/* Function:  cm_tr_hb_mx_Create()
 * Incept:    EPN, Thu Aug 25 14:15:37 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_HB_MX> for a CM
 *            given a CP9Bands_t object that defines the bands.
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_TR_HB_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_HB_MX *
cm_tr_hb_mx_Create(CM_t *cm)
{
  int     status;
  CM_TR_HB_MX *mx = NULL;
  int     v, b;
  int allocL = 1;
  int allocW = 1;
  int B = CMCountNodetype(cm, BIF_nd);
  int M = cm->M;

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_HB_MX));
  mx->Jdp     = NULL;
  mx->Jdp_mem = NULL;
  mx->Ldp     = NULL;
  mx->Ldp_mem = NULL;
  mx->Rdp     = NULL;
  mx->Rdp_mem = NULL;
  mx->Tdp     = NULL;
  mx->Tdp_mem = NULL;
  mx->cp9b    = NULL;

  /* level 2: deck (state) pointers, 0.1..M, go all the way to M
   *          remember deck M is special, as it has no bands, we allocate
   *          it only if nec (if local ends are on) in cm_tr_hb_mx_GrowTo()
   */
  ESL_ALLOC(mx->Jdp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Ldp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Rdp,  sizeof(float **) * (M+1));
  ESL_ALLOC(mx->Tdp,  sizeof(float **) * (M+1)); /* ptrs to non-ROOT_S and non-B states will be NULL */

  /* level 3: dp cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->Jdp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Ldp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Rdp_mem,  sizeof(float) * (M+1) * (allocL) * (allocW));
  ESL_ALLOC(mx->Tdp_mem,  sizeof(float) * (B+1) * (allocL) * (allocW)); /* +1 is for the special ROOT_S deck */
  ESL_ALLOC(mx->JnrowsA,  sizeof(int)   * (M+1));
  ESL_ALLOC(mx->LnrowsA,  sizeof(int)   * (M+1));
  ESL_ALLOC(mx->RnrowsA,  sizeof(int)   * (M+1));
  ESL_ALLOC(mx->TnrowsA,  sizeof(int)   * (M+1));

  b = 0;
  for (v = 0; v < M; v++) {
	ESL_ALLOC(mx->Jdp[v], sizeof(float *) * (allocL));
	ESL_ALLOC(mx->Ldp[v], sizeof(float *) * (allocL));
	ESL_ALLOC(mx->Rdp[v], sizeof(float *) * (allocL));
	mx->Jdp[v][0]  = mx->Jdp_mem + v * (allocL) * (allocW);
	mx->Ldp[v][0]  = mx->Ldp_mem + v * (allocL) * (allocW);
	mx->Rdp[v][0]  = mx->Rdp_mem + v * (allocL) * (allocW);

	if(cm->sttype[v] == B_st || v == 0) { /* only B states and ROOT_S are valid */
	  ESL_ALLOC(mx->Tdp[v], sizeof(float *) * (allocL));
	  mx->Tdp[v][0] = mx->Tdp_mem + b * (allocL) * (allocW);
	  b++;
	  mx->TnrowsA[v] = allocL;
	}
	else {
	  mx->Tdp[v] = NULL;
	  mx->TnrowsA[v] = 0;
	}
	mx->JnrowsA[v] = allocL;
	mx->LnrowsA[v] = allocL;
	mx->RnrowsA[v] = allocL;
  }
  /* allocate EL deck, for J, L, and R */
  ESL_ALLOC(mx->Jdp[M], sizeof(float *) * (allocL));
  mx->Jdp[M][0]  = mx->Jdp_mem + M * (allocL) * (allocW);
  mx->JnrowsA[M] = allocL;

  ESL_ALLOC(mx->Ldp[M], sizeof(float *) * (allocL));
  mx->Ldp[M][0]  = mx->Ldp_mem + M * (allocL) * (allocW);
  mx->LnrowsA[M] = allocL;

  ESL_ALLOC(mx->Rdp[M], sizeof(float *) * (allocL));
  mx->Rdp[M][0]  = mx->Rdp_mem + M * (allocL) * (allocW);
  mx->RnrowsA[M] = allocL;

  mx->Tdp[M]  = NULL;

  mx->TnrowsA[M] = 0;

  mx->M               = M;
  mx->B               = B;
  mx->Jncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Lncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Rncells_alloc   = (M+1)*(allocL)*(allocW);
  mx->Tncells_alloc   = (B+1)*(allocL)*(allocW);
  mx->Jncells_valid   = 0;
  mx->Lncells_valid   = 0;
  mx->Rncells_valid   = 0;
  mx->Tncells_valid   = 0;
  mx->L               = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_TR_HB_MX)                             +
	 (4 * (mx->M+1)    * sizeof(float **))           +  /* mx->{J,L,R}dp[] ptrs */
	 mx->Jncells_alloc * sizeof(float)               +  /* mx->Jdp_mem */
	 mx->Lncells_alloc * sizeof(float)               +  /* mx->Ldp_mem */
	 mx->Rncells_alloc * sizeof(float)               +  /* mx->Rdp_mem */
	 mx->Tncells_alloc * sizeof(float)               +  /* mx->Tdp_mem */
	 (4 * (mx->M+1)    * sizeof(int))                +  /* mx->{J,L,R,T}nrowsA ptrs */
	 (3 * (mx->M+1) * allocL * sizeof(float *))      +  /* mx->{J,L,R}dp[v][] ptrs */
	 (1 * (mx->B+1) * allocL * sizeof(float *)));       /* mx->Tdp[v][] ptrs */
  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_hb_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_hb_mx_GrowTo()
 * Incept:    EPN, Thu Aug 25 14:39:00 2011
 *
 * Purpose:   Assures that a CM_TR_HB_MX matrix <mx> is allocated
 *            for a model of exactly <mx->M> states and required number of
 *            total cells. Determines new required size from
 *            the CP9Bands_t object passed in, and reallocates if
 *            necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL deck.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_hb_mx_GrowTo(CM_t *cm, CM_TR_HB_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t Jcur_size = 0;
  int64_t Lcur_size = 0;
  int64_t Rcur_size = 0;
  int64_t Tcur_size = 0;
  int64_t Jncells;
  int64_t Lncells;
  int64_t Rncells;
  int64_t Tncells;
  int     jbw;
  float   Mb_needed;   /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     realloced_J; /* did we reallocate mx->Jdp_mem? */
  int     realloced_L; /* did we reallocate mx->Ldp_mem? */
  int     realloced_R; /* did we reallocate mx->Rdp_mem? */
  int     realloced_T; /* did we reallocate mx->Tdp_mem? */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  /* contract check, number of states (M) is something we don't change
   * so check this matrix has same number of 1st dim state ptrs that
   * cp9b has */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_mx_GrowTo() entered with cp9b == NULL.\n");
  if(cp9b->cm_M != mx->M) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_mx_GrowTo() entered with mx->M: (%d) != cp9b->M (%d)\n", mx->M, cp9b->cm_M);

  if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cp9b, L, &Jncells, &Lncells, &Rncells, &Tncells, &Mb_needed)) != eslOK) return status;
  /*printf("HMM banded Tr matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("HMM banded Tr matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded Tr DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* check if we should free the matrix */
  if((mx->size_Mb > (0.5  * size_limit)) && /* matrix is >= 0.5 * size of our limit (based on bands from previous sequence) */
	 (mx->size_Mb > (1.25 * Mb_needed))) {  /* matrix is at least 25% bigger than we need to process current sequence */
	free(mx->Jdp_mem);
	free(mx->Ldp_mem);
	free(mx->Rdp_mem);
	free(mx->Tdp_mem);
	mx->Jdp_mem = NULL;
	mx->Ldp_mem = NULL;
	mx->Rdp_mem = NULL;
	mx->Tdp_mem = NULL;
	mx->Jncells_alloc = 0;
	mx->Lncells_alloc = 0;
	mx->Rncells_alloc = 0;
	mx->Tncells_alloc = 0;
  }

  /* must we realloc the full {J,L,R.T}matrices? or can we get away with just
   * jiggering the pointers, if total required num cells is less
   * than or equal to what we already have alloc'ed?
   */
  realloced_J = realloced_L = realloced_R = realloced_T = FALSE;
  if (Jncells > mx->Jncells_alloc) {
	  ESL_RALLOC(mx->Jdp_mem, p, sizeof(float) * Jncells);
	  mx->Jncells_alloc = Jncells;
	  realloced_J = TRUE;
  }
  if (Lncells > mx->Lncells_alloc) {
	  ESL_RALLOC(mx->Ldp_mem, p, sizeof(float) * Lncells);
	  mx->Lncells_alloc = Lncells;
	  realloced_L = TRUE;
  }
  if (Rncells > mx->Rncells_alloc) {
	  ESL_RALLOC(mx->Rdp_mem, p, sizeof(float) * Rncells);
	  mx->Rncells_alloc = Rncells;
	  realloced_R = TRUE;
  }
  if (Tncells > mx->Tncells_alloc) {
	  ESL_RALLOC(mx->Tdp_mem, p, sizeof(float) * Tncells);
	  mx->Tncells_alloc = Tncells;
	  realloced_T = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   * This is tricky, for each matrix not reallocated, we have to adjust Mb_needed
   * so it uses previously allocated size of that matrix.
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced_J) {
	Mb_alloc -= (float) (sizeof(float) * Jncells);
	Mb_alloc += (float) (sizeof(float) * mx->Jncells_alloc);
  }
  if(! realloced_L) {
	Mb_alloc -= (float) (sizeof(float) * Lncells);
	Mb_alloc += (float) (sizeof(float) * mx->Lncells_alloc);
  }
  if(! realloced_R) {
	Mb_alloc -= (float) (sizeof(float) * Rncells);
	Mb_alloc += (float) (sizeof(float) * mx->Rncells_alloc);
  }
  if(! realloced_T) {
	Mb_alloc -= (float) (sizeof(float) * Tncells);
	Mb_alloc += (float) (sizeof(float) * mx->Tncells_alloc);
  }
  /* note if we didn't reallocate any of the four matrices, Mb_alloc == Mb_needed */
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->Jncells_valid = Jncells;
  mx->Lncells_valid = Lncells;
  mx->Rncells_valid = Rncells;
  mx->Tncells_valid = Tncells;

  /* make sure each row is big enough */
  for(v = 0; v < mx->M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v] + 1;

	if(cp9b->Jvalid[v]) {
	  if(jbw > mx->JnrowsA[v]) {
	if(mx->Jdp[v] != NULL) ESL_RALLOC(mx->Jdp[v], p, sizeof(float *) * jbw);
	else                   ESL_ALLOC (mx->Jdp[v],    sizeof(float *) * jbw);
	mx->JnrowsA[v] = jbw;
	  }
	}
	else { /* cp9b->Jvalid[v] is FALSE */
	  if(mx->Jdp[v] != NULL) free(mx->Jdp[v]);
	  mx->Jdp[v] = NULL;
	  mx->JnrowsA[v] = 0;
	}

	if(cp9b->Lvalid[v]) {
	  if(jbw > mx->LnrowsA[v]) {
	if(mx->Ldp[v] != NULL) ESL_RALLOC(mx->Ldp[v], p, sizeof(float *) * jbw);
	else                   ESL_ALLOC (mx->Ldp[v],    sizeof(float *) * jbw);
	mx->LnrowsA[v] = jbw;
	  }
	}
	else { /* cp9b->Lvalid[v] is FALSE */
	  if(mx->Ldp[v] != NULL) free(mx->Ldp[v]);
	  mx->Ldp[v] = NULL;
	  mx->LnrowsA[v] = 0;
	}

	if(cp9b->Rvalid[v]) {
	  if(jbw > mx->RnrowsA[v]) {
	if(mx->Rdp[v] != NULL) ESL_RALLOC(mx->Rdp[v], p, sizeof(float *) * jbw);
	else                   ESL_ALLOC (mx->Rdp[v],    sizeof(float *) * jbw);
	mx->RnrowsA[v] = jbw;
	  }
	}
	else { /* cp9b->Rvalid[v] is FALSE */
	  if(mx->Rdp[v] != NULL) free(mx->Rdp[v]);
	  mx->Rdp[v] = NULL;
	  mx->RnrowsA[v] = 0;
	}

	if(cp9b->Tvalid[v]) {
	  if(jbw > mx->TnrowsA[v]) {
	if(mx->Tdp[v] != NULL) ESL_RALLOC(mx->Tdp[v], p, sizeof(float *) * jbw);
	else                   ESL_ALLOC (mx->Tdp[v],    sizeof(float *) * jbw);
	mx->TnrowsA[v] = jbw;
	  }
	}
	else { /* cp9b->Tvalid[v] is FALSE */
	  if(mx->Tdp[v] != NULL) free(mx->Tdp[v]);
	  mx->Tdp[v] = NULL;
	  mx->TnrowsA[v] = 0;
	}
  }
  if(have_el) {
	jbw = L+1;
	if(cp9b->Jvalid[mx->M]) {
	  if(jbw > mx->JnrowsA[mx->M]) {
	if(mx->Jdp[mx->M] != NULL) ESL_RALLOC(mx->Jdp[mx->M], p, sizeof(float *) * jbw);
	else                       ESL_ALLOC (mx->Jdp[mx->M],    sizeof(float *) * jbw);
	mx->JnrowsA[mx->M] = jbw;
	  }
	}
	else { /* cp9b->Jvalid[mx->M] is FALSE */
	  if(mx->Jdp[v] != NULL) free(mx->Jdp[v]);
	  mx->Jdp[v] = NULL;
	  mx->JnrowsA[v] = 0;
	}
	if(cp9b->Lvalid[mx->M]) {
	  if(jbw > mx->LnrowsA[mx->M]) {
	if(mx->Ldp[mx->M] != NULL) ESL_RALLOC(mx->Ldp[mx->M], p, sizeof(float *) * jbw);
	else                       ESL_ALLOC (mx->Ldp[mx->M],    sizeof(float *) * jbw);
	mx->LnrowsA[mx->M] = jbw;
	  }
	}
	else { /* cp9b->Lvalid[mx->M] is FALSE */
	  if(mx->Ldp[v] != NULL) free(mx->Ldp[v]);
	  mx->Ldp[v] = NULL;
	  mx->LnrowsA[v] = 0;
	}
	if(cp9b->Rvalid[mx->M]) {
	  if(jbw > mx->RnrowsA[mx->M]) {
	if(mx->Rdp[mx->M] != NULL) ESL_RALLOC(mx->Rdp[mx->M], p, sizeof(float *) * jbw);
	else                       ESL_ALLOC (mx->Rdp[mx->M],    sizeof(float *) * jbw);
	mx->RnrowsA[mx->M] = jbw;
	  }
	}
	else { /* cp9b->Rvalid[mx->M] is FALSE */
	  if(mx->Rdp[v] != NULL) free(mx->Rdp[v]);
	  mx->Rdp[v] = NULL;
	  mx->RnrowsA[v] = 0;
	}
  }
  /* Tdp is NULL for cm->M */

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  Jcur_size = 0;
  Lcur_size = 0;
  Rcur_size = 0;
  Tcur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(mx->Jdp[v] != NULL) {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->Jdp[v][jp] = mx->Jdp_mem + Jcur_size;
	Jcur_size += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(mx->Ldp[v] != NULL) {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->Ldp[v][jp] = mx->Ldp_mem + Lcur_size;
	Lcur_size += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(mx->Rdp[v] != NULL) {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->Rdp[v][jp] = mx->Rdp_mem + Rcur_size;
	Rcur_size += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(mx->Tdp[v] != NULL) {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->Tdp[v][jp] = mx->Tdp_mem + Tcur_size;
	Tcur_size += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
  }
  if(have_el) {
	if(mx->Jdp[mx->M] != NULL) {
	  for(jp = 0; jp <= L; jp++) {
	mx->Jdp[mx->M][jp] = mx->Jdp_mem + Jcur_size;
	Jcur_size += jp + 1;
	  }
	}
	if(mx->Ldp[mx->M] != NULL) {
	  for(jp = 0; jp <= L; jp++) {
	mx->Ldp[mx->M][jp] = mx->Ldp_mem + Lcur_size;
	Lcur_size += jp + 1;
	  }
	}
	if(mx->Rdp[mx->M] != NULL) {
	  for(jp = 0; jp <= L; jp++) {
	mx->Rdp[mx->M][jp] = mx->Rdp_mem + Rcur_size;
	Rcur_size += jp + 1;
	  }
	}
  }

  /*printf("J ncells %10" PRId64 " %10" PRId64 "\n", Jcur_size, mx->Jncells_valid);
	printf("L ncells %10" PRId64 " %10" PRId64 "\n", Lcur_size, mx->Lncells_valid);
	printf("R ncells %10" PRId64 " %10" PRId64 "\n", Rcur_size, mx->Rncells_valid);
	printf("T ncells %10" PRId64 " %10" PRId64 "\n", Tcur_size, mx->Tncells_valid);*/
  assert(Jcur_size == mx->Jncells_valid);
  assert(Lcur_size == mx->Lncells_valid);
  assert(Rcur_size == mx->Rncells_valid);
  assert(Tcur_size == mx->Tncells_valid);
  ESL_DASSERT1((Jcur_size == mx->Jncells_valid));
  ESL_DASSERT1((Lcur_size == mx->Lncells_valid));
  ESL_DASSERT1((Rcur_size == mx->Rncells_valid));
  ESL_DASSERT1((Tcur_size == mx->Tncells_valid));

  mx->cp9b = cp9b; /* just a reference */

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_hb_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Thu Aug 25 14:51:15 2011
 *
 * Purpose:   Frees a <CM_TR_HB_MX>.
 *
 * Returns:   (void)
 */
void
cm_tr_hb_mx_Destroy(CM_TR_HB_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->Jdp      != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Jdp[v] != NULL) free(mx->Jdp[v]);
  }
  free(mx->Jdp);

  if (mx->Ldp      != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Ldp[v] != NULL) free(mx->Ldp[v]);
  }
  free(mx->Ldp);

  if (mx->Rdp      != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Rdp[v] != NULL) free(mx->Rdp[v]);
  }
  free(mx->Rdp);

  if (mx->Tdp      != NULL) {
	for (v = 0; v <= mx->M; v++)
	  if(mx->Tdp[v] != NULL) free(mx->Tdp[v]);
  }
  free(mx->Tdp);

  if (mx->JnrowsA  != NULL)  free(mx->JnrowsA);
  if (mx->LnrowsA  != NULL)  free(mx->LnrowsA);
  if (mx->RnrowsA  != NULL)  free(mx->RnrowsA);
  if (mx->TnrowsA  != NULL)  free(mx->TnrowsA);
  if (mx->Jdp_mem  != NULL)  free(mx->Jdp_mem);
  if (mx->Ldp_mem  != NULL)  free(mx->Ldp_mem);
  if (mx->Rdp_mem  != NULL)  free(mx->Rdp_mem);
  if (mx->Tdp_mem  != NULL)  free(mx->Tdp_mem);
  free(mx);
  return;
}

/* Function:  cm_tr_hb_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Thu Aug 25 14:52:40 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_hb_mx_Dump(FILE *ofp, CM_TR_HB_MX *mx, char mode, int print_mx)
{
  int status;
  int v, jp, j, dp, d;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "B: %d\n", mx->B);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "Jncells_alloc: %" PRId64 "\nJncells_valid: %" PRId64 "\n", mx->Jncells_alloc, mx->Jncells_valid);
  fprintf(ofp, "Lncells_alloc: %" PRId64 "\nLncells_valid: %" PRId64 "\n", mx->Lncells_alloc, mx->Lncells_valid);
  fprintf(ofp, "Rncells_alloc: %" PRId64 "\nRncells_valid: %" PRId64 "\n", mx->Rncells_alloc, mx->Rncells_valid);
  fprintf(ofp, "Tncells_alloc: %" PRId64 "\nTncells_valid: %" PRId64 "\n", mx->Tncells_alloc, mx->Tncells_valid);
  fprintf(ofp, "mode: %d\n", mode);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  /* DP matrix data */
  if(print_mx) {
	for (v = 0; v < mx->M; v++) {
	  for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	j = jp + mx->cp9b->jmin[v];
	for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	  d = dp + mx->cp9b->hdmin[v][jp];
	  if(mx->Jdp[v])           fprintf(ofp, "Jdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Jdp[v][jp][dp]);
	  if(fill_L && mx->Ldp[v]) fprintf(ofp, "Ldp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Ldp[v][jp][dp]);
	  if(fill_R && mx->Rdp[v]) fprintf(ofp, "Rdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Rdp[v][jp][dp]);
	  if(fill_T && mx->Tdp[v]) fprintf(ofp, "Tdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Tdp[v][jp][dp]);
	}
	fprintf(ofp, "\n");
	  }
	  fprintf(ofp, "\n\n");
	}
	/* print EL deck, if it's valid */
	v = mx->M;
	for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	if(mx->Jdp[v] && mx->JnrowsA[v] == (mx->L+1)) fprintf(ofp, "Jdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Jdp[v][j][d]);
	if(fill_L && mx->Ldp[v] && mx->LnrowsA[v] == (mx->L+1)) fprintf(ofp, "Ldp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Ldp[v][j][d]);
	if(fill_R && mx->Rdp[v] && mx->RnrowsA[v] == (mx->L+1)) fprintf(ofp, "Rdp[v:%5d][j:%5d][d:%5d] %8.4f\n", v, j, d, mx->Rdp[v][j][d]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
  }
  return eslOK;
}

/* Function:  cm_tr_hb_mx_SizeNeeded()
 * Incept:    EPN, Thu Aug 25 14:55:25 2011
 *
 * Purpose:   Given a model and CP9_bands_t object with
 *            pre-calced bands for a target, determine the number
 *            of cells and total size in Mb required in a CM_HB_MX
 *            for the target given the bands.
 *
 *            Return number of cells required given the bands
 *            in <cp9b> in <ret_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm     - the CM the matrix is for
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            ret_Jncells - RETURN: number of J matrix cells required
 *            ret_Lncells - RETURN: number of L matrix cells required
 *            ret_Rncells - RETURN: number of R matrix cells required
 *            ret_Tncells - RETURN: number of T matrix cells required
 *            ret_Mb - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_hb_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int L, int64_t *ret_Jncells, int64_t *ret_Lncells, int64_t *ret_Rncells, int64_t *ret_Tncells, float *ret_Mb)
{
  int     v, jp;
  int64_t Jncells, Lncells, Rncells, Tncells;
  int     jbw;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  /* contract check */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_hb_mx_SizeNeeded() entered with cp9b == NULL.\n");

  Jncells = 0;
  Lncells = 0;
  Rncells = 0;
  Tncells = 0;
  Mb_needed = (float)
	(sizeof(CM_TR_HB_MX)                 +
	 (4 * (cp9b->cm_M+1) * sizeof(float **))  + /* mx->{J,L,R}dp[] ptrs */
	 (4 * (cp9b->cm_M+1) * sizeof(int)));       /* mx->{J,L,R,T}nrowsA ptrs */

  for(v = 0; v < cp9b->cm_M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v];
	if(cp9b->Jvalid[v]) {
	  Mb_needed += (float) (sizeof(float *) * (jbw+1)); /* mx->Jdp[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++) {
	Jncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(cp9b->Lvalid[v]) {
	  Mb_needed += (float) (sizeof(float *) * (jbw+1)); /* mx->Ldp[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++) {
	Lncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(cp9b->Rvalid[v]) {
	  Mb_needed += (float) (sizeof(float *) * (jbw+1)); /* mx->Rdp[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++) {
	Rncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	if(cp9b->Tvalid[v]) {
	  Mb_needed += (float) (sizeof(float *) * (jbw+1)); /* mx->Tdp[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++) {
	Tncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
  }
  if(have_el) { /* space for EL deck */
	if(cp9b->Jvalid[cp9b->cm_M]) {
	  Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Jdp[cm->M][] ptrs */
	  Jncells += (int) ((L+2) * (L+1) * 0.5);
	}
	if(cp9b->Lvalid[cp9b->cm_M]) {
	  Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Ldp[cm->M][] ptrs */
	  Lncells += (int) ((L+2) * (L+1) * 0.5);
	}
	if(cp9b->Rvalid[cp9b->cm_M]) {
	  Mb_needed += (float) (sizeof(float *) * (L+1)); /* mx->Ldp[cm->M][] ptrs */
	  Rncells += (int) ((L+2) * (L+1) * 0.5);
	}
  }

  Mb_needed += sizeof(float) * Jncells; /* mx->Jdp_mem */
  Mb_needed += sizeof(float) * Lncells; /* mx->Ldp_mem */
  Mb_needed += sizeof(float) * Rncells; /* mx->Rdp_mem */
  Mb_needed += sizeof(float) * Tncells; /* mx->Tdp_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_Jncells != NULL) *ret_Jncells = Jncells;
  if(ret_Lncells != NULL) *ret_Lncells = Lncells;
  if(ret_Rncells != NULL) *ret_Rncells = Rncells;
  if(ret_Tncells != NULL) *ret_Tncells = Tncells;
  if(ret_Mb      != NULL) *ret_Mb      = Mb_needed;

  /*printf("in cm_tr_hb_mx_SizeNeeded() returning %.2f total Mb (EL: %.2f Mb)\n",
	Mb_needed, (sizeof(float) * (L+2) * (L+1) * 0.5) * 0.000001); */

  return eslOK;
}

/*****************************************************************
 *   5. CM_SHADOW_MX data structure functions,
 *      non-banded shadow matrix for tracing back CM parses.
 *****************************************************************/

/* Function:  cm_shadow_mx_Create()
 * Incept:    EPN, Wed Sep 14 04:46:22 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_SHADOW_MX> for a CM <cm>
 *            The CM is needed so we know which decks need to be int's (BIF_B states)
 *            and which need to be char's (all other states).
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_SHADOW_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_SHADOW_MX *
cm_shadow_mx_Create(CM_t *cm)
{
  int     status;
  CM_SHADOW_MX *mx = NULL;
  int     v, b;
  int     M = cm->M;
  int allocL = 1;
  int allocW = 1;
  int B = CMCountNodetype(cm, BIF_nd);

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_SHADOW_MX));
  mx->yshadow     = NULL;
  mx->yshadow_mem = NULL;

  mx->kshadow     = NULL;
  mx->kshadow_mem = NULL;

  /* level 2: deck (state) pointers, 0.1..M-1, M (EL deck) is irrelevant for the
   *          shadow matrix.
   */
  ESL_ALLOC(mx->yshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->kshadow,  sizeof(int **)  * M);

  /* level 3: matrix cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->yshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));
  ESL_ALLOC(mx->kshadow_mem,  sizeof(int)  * ESL_MAX(1, B * allocL * allocW)); // avoid 0 malloc

  b = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == B_st) {
	  ESL_ALLOC(mx->kshadow[v], sizeof(int *) * (allocL));
	  mx->kshadow[v][0] = mx->kshadow_mem + b * (allocL) * (allocW);
	  mx->yshadow[v] = NULL;
	  b++;
	}
	else {
	  ESL_ALLOC(mx->yshadow[v], sizeof(char *) * (allocL));
	  mx->yshadow[v][0] = mx->yshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->kshadow[v] = NULL;
	}
  }
  mx->M               = M;
  mx->B               = B;
  mx->y_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->y_ncells_valid = 0;
  mx->k_ncells_alloc = (B)*(allocL)*(allocW);
  mx->k_ncells_valid = 0;
  mx->L              = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_SHADOW_MX) +
	 ((mx->M)        * sizeof(char **))            +  /* mx->yshadow[] ptrs */
	 ((mx->M)        * sizeof(int **))             +  /* mx->kshadow[] ptrs */
	 mx->y_ncells_alloc * sizeof(char)             +  /* mx->yshadow_mem */
	 mx->k_ncells_alloc * sizeof(int)              +  /* mx->kshadow_mem */
	 (mx->B           * allocL * sizeof(int *))    +  /* mx->kshadow[v][] ptrs */
	 ((mx->M - mx->B) * allocL * sizeof(char *)));    /* mx->yshadow[v][] ptrs */
	mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_shadow_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_shadow_mx_GrowTo()
 * Incept:    EPN, Wed Sep 14 04:49:55 2011
 *
 * Purpose:   Assures that a CM_SHADOW_MX <mx> is allocated
 *            for a model of exactly <mx->M> states and a sequence
 *            of length L, reallocating as necessary.
 *
 *            Checks that the matrix has been created for the current CM.
 *            Check is that  mx->yshadow[v] == NULL when v is a B_st and
 *                           mx->kshadow[v] != NULL when v is a B_st.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> if mx does not appeared to be created for this cm
 *            <eslEMEM> on memory allocation error.
 */
int
cm_shadow_mx_GrowTo(CM_t *cm, CM_SHADOW_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t y_cur_size;
  int64_t k_cur_size;
  int64_t y_ncells;
  int64_t k_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     realloced_y; /* did we reallocate mx->yshadow_mem? */
  int     realloced_k; /* did we reallocate mx->kshadow_mem? */

  if((status = cm_shadow_mx_SizeNeeded(cm, errbuf, L, &y_ncells, &k_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded shadow matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded shadow matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded shadow DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full yshadow and kshadow matrices?
   * or can we get away with just jiggering the pointers, if
   * total required num cells is less than or equal to what
   * we already have alloc'ed?
   */
  realloced_y = FALSE;
  realloced_k = FALSE;
  if (y_ncells > mx->y_ncells_alloc) {
	  ESL_RALLOC(mx->yshadow_mem, p, sizeof(char) * y_ncells);
	  mx->y_ncells_alloc = y_ncells;
	  realloced_y = TRUE;
  }
  if (k_ncells > mx->k_ncells_alloc) {
	  ESL_RALLOC(mx->kshadow_mem, p, sizeof(int) * k_ncells);
	  mx->k_ncells_alloc = k_ncells;
	  realloced_k = TRUE;
  }
  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   * This is tricky, for each matrix not reallocated, we have to adjust Mb_needed
   * so it uses previously allocated size of that matrix.
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced_y) {
	Mb_alloc -= (float) (sizeof(char) * y_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->y_ncells_alloc);
  }
  if(! realloced_k) {
	Mb_alloc -= (float) (sizeof(int) * k_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->k_ncells_alloc);
  }
  /* note if we didn't reallocate any of the four matrices, Mb_alloc == Mb_needed */
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->y_ncells_valid = y_ncells;
  mx->k_ncells_valid = k_ncells;

  /* reallocate the yshadow,kshadow[v] ptrs */
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] != B_st) {
	  ESL_RALLOC(mx->yshadow[v], p, sizeof(char *) * (L+1));
	}
	else {
	  ESL_RALLOC(mx->kshadow[v], p, sizeof(int *) * (L+1));
	}
  }

  /* reset the pointers, we keep a tally of number of cells
   * we've seen in each matrix (y_cur_size and k_cur_size) as we go,
   * we could precalc it and store it for each v,j, but that
   * would be wasteful, as we'll only use the matrix configured
   * this way once, in a banded CYK run.
   */
  y_cur_size = 0;
  k_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] != B_st) {
	  for(jp = 0; jp <= L; jp++) {
	mx->yshadow[v][jp] = mx->yshadow_mem + y_cur_size;
	y_cur_size += jp+1;
	  }
	}
	else {
	  for(jp = 0; jp <= L; jp++) {
	mx->kshadow[v][jp] = mx->kshadow_mem + k_cur_size;
	k_cur_size += jp+1;
	  }
	}
  }
  /*printf("y ncells %10" PRId64 " %10" PRId64 "\n", y_cur_size, mx->y_ncells_valid);
	printf("k ncells %10" PRId64 " %10" PRId64 "\n", k_cur_size, mx->k_ncells_valid);*/
  assert(y_cur_size == mx->y_ncells_valid);
  assert(k_cur_size == mx->k_ncells_valid);
  ESL_DASSERT1((y_cur_size == mx->y_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_shadow_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Wed Sep 14 04:53:30 2011
 *
 * Purpose:   Frees a <CM_SHADOW_MX>.
 *
 * Returns:   (void)
 */
void
cm_shadow_mx_Destroy(CM_SHADOW_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->yshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->yshadow[v] != NULL) free(mx->yshadow[v]);
  }
  free(mx->yshadow);

  if (mx->kshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->kshadow[v] != NULL) free(mx->kshadow[v]);
  }
  free(mx->kshadow);

  if (mx->yshadow_mem  != NULL)  free(mx->yshadow_mem);
  if (mx->kshadow_mem  != NULL)  free(mx->kshadow_mem);
  free(mx);
  return;
}

/* Function:  cm_shadow_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Sat Sep 10 12:21:53 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_shadow_mx_Dump(FILE *ofp, CM_t *cm, CM_SHADOW_MX *mx, int print_mx)
{
  int v, j, d;

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "B: %d\n", mx->B);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "y_ncells_alloc: %" PRId64 "\ny_ncells_valid: %" PRId64 "\n", mx->y_ncells_alloc, mx->y_ncells_valid);
  fprintf(ofp, "k_ncells_alloc: %" PRId64 "\nk_ncells_valid: %" PRId64 "\n", mx->k_ncells_alloc, mx->k_ncells_valid);

  /* yshadow/kshadow matrix data */
  if(print_mx) {
	for(v = 0; v < mx->M; v++) {
	  if(cm->sttype[v] == B_st) {
		for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	    if(mx->kshadow[v]) fprintf(ofp, "kshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->kshadow[v][j][d]);
	  }
	  fprintf(ofp, "\n");
		}
		fprintf(ofp, "\n\n");
	  }
	  else { /* ! B_st */
		for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	    if(mx->yshadow[v]) fprintf(ofp, "yshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->yshadow[v][j][d]);
 	  }
	  fprintf(ofp, "\n");
		}
		fprintf(ofp, "\n\n");
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_shadow_mx_SizeNeeded()
 * Incept:    EPN, Wed Sep 14 04:55:23 2011
 *
 * Purpose: Given a model, and a sequence length L determine the
 *            number of cells and total size in Mb required for the
 *            matrix for the target given the bands.
 *
 *            Return number of yshadow (char) cells required in
 *            <ret_ny_cells> and number of kshadow (int) cells
 *            required in <ret_nk_cells) and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            L            - length of sequence we will align
 *            ret_ny_cells - RETURN: number of required char cells (yshadow)
 *            ret_nk_cells - RETURN: number of required int  cells (kshadow)
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_shadow_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_ny_cells, int64_t *ret_nk_cells, float *ret_Mb)
{
  int     v;
  int64_t y_ncells;
  int64_t k_ncells;
  float   Mb_needed;

  y_ncells = 0;
  k_ncells = 0;
  Mb_needed = (float)
	(sizeof(CM_SHADOW_MX) +
	 ((cm->M) * sizeof(char **)) + /* mx->yshadow[] ptrs */
	 ((cm->M) * sizeof(int **)));  /* mx->kshadow[] ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == B_st) {
	  Mb_needed += (float) (sizeof(int *) * (L+1)); /* mx->kshadow[v][] ptrs */
	  k_ncells += (int) ((L+2) * (L+1) * 0.5);
	}
	else {
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->yshadow[v][] ptrs */
	  y_ncells += (int) ((L+2) * (L+1) * 0.5);
	}
  }

  Mb_needed += sizeof(int)  * k_ncells; /* mx->kshadow_mem */
  Mb_needed += sizeof(char) * y_ncells; /* mx->yshadow_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_ny_cells != NULL) *ret_ny_cells = y_ncells;
  if(ret_nk_cells != NULL) *ret_nk_cells = k_ncells;
  if(ret_Mb       != NULL) *ret_Mb        = Mb_needed;
  return eslOK;
}

/*****************************************************************
 *   6. CM_TR_SHADOW_MX data structure functions,
 *      non-banded shadow matrix for tracing back truncated CM parses
 *****************************************************************/

/* Function:  cm_tr_shadow_mx_Create()
 * Incept:    EPN, Sat Sep 10 12:10:42 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_SHADOW_MX> for a CM <cm>
 *            The CM is needed so we know which decks need to be int's (BIF_B states)
 *            and which need to be char's (all other states).
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_TR_SHADOW_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_SHADOW_MX *
cm_tr_shadow_mx_Create(CM_t *cm)
{
  int     status;
  CM_TR_SHADOW_MX *mx = NULL;
  int     v, b;
  int     M = cm->M;
  int allocL = 1;
  int allocW = 1;
  int B = CMCountNodetype(cm, BIF_nd);

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_SHADOW_MX));
  mx->Jyshadow     = NULL;
  mx->Jyshadow_mem = NULL;
  mx->Lyshadow     = NULL;
  mx->Lyshadow_mem = NULL;
  mx->Ryshadow     = NULL;
  mx->Ryshadow_mem = NULL;

  mx->Jkshadow     = NULL;
  mx->Jkshadow_mem = NULL;
  mx->Lkshadow     = NULL;
  mx->Lkshadow_mem = NULL;
  mx->Rkshadow     = NULL;
  mx->Rkshadow_mem = NULL;
  mx->Tkshadow     = NULL;
  mx->Tkshadow_mem = NULL;

  mx->Lkmode       = NULL;
  mx->Lkmode_mem   = NULL;
  mx->Rkmode       = NULL;
  mx->Rkmode_mem   = NULL;

  /* level 2: deck (state) pointers, 0.1..M-1, M (EL deck) is irrelevant for the
   *          shadow matrix.
   */
  ESL_ALLOC(mx->Jyshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->Lyshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->Ryshadow,  sizeof(char **) * M);

  ESL_ALLOC(mx->Jkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Lkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Rkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Tkshadow,  sizeof(int **)  * M);

  ESL_ALLOC(mx->Lkmode,    sizeof(char **) * M);
  ESL_ALLOC(mx->Rkmode,    sizeof(char **) * M);

  /* level 3: matrix cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->Jyshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));
  ESL_ALLOC(mx->Lyshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));
  ESL_ALLOC(mx->Ryshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));

  ESL_ALLOC(mx->Jkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));  // avoid 0 malloc
  ESL_ALLOC(mx->Lkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Rkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Tkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));

  ESL_ALLOC(mx->Lkmode_mem,   sizeof(char) * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Rkmode_mem,   sizeof(char) * ESL_MAX(1, B * allocL * allocW));

  b = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == B_st) {
	  ESL_ALLOC(mx->Jkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Lkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Rkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Tkshadow[v], sizeof(int *) * (allocL));

	  ESL_ALLOC(mx->Lkmode[v],   sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Rkmode[v],   sizeof(char *) * (allocL));

	  mx->Jkshadow[v][0] = mx->Jkshadow_mem + b * (allocL) * (allocW);
	  mx->Lkshadow[v][0] = mx->Lkshadow_mem + b * (allocL) * (allocW);
	  mx->Rkshadow[v][0] = mx->Rkshadow_mem + b * (allocL) * (allocW);
	  mx->Tkshadow[v][0] = mx->Tkshadow_mem + b * (allocL) * (allocW);

	  mx->Lkmode[v][0]   = mx->Lkmode_mem   + b * (allocL) * (allocW);
	  mx->Rkmode[v][0]   = mx->Rkmode_mem   + b * (allocL) * (allocW);

	  mx->Jyshadow[v] = NULL;
	  mx->Lyshadow[v] = NULL;
	  mx->Ryshadow[v] = NULL;
	  b++;
	}
	else {
	  ESL_ALLOC(mx->Jyshadow[v], sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Lyshadow[v], sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Ryshadow[v], sizeof(char *) * (allocL));

	  mx->Jyshadow[v][0] = mx->Jyshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Lyshadow[v][0] = mx->Lyshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Ryshadow[v][0] = mx->Ryshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Jkshadow[v] = NULL;
	  mx->Lkshadow[v] = NULL;
	  mx->Rkshadow[v] = NULL;
	  mx->Tkshadow[v] = NULL;

	  mx->Lkmode[v] = NULL;
	  mx->Rkmode[v] = NULL;
	}
  }
  mx->M               = M;
  mx->B               = B;
  mx->Jy_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Ly_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Ry_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Jy_ncells_valid = 0;
  mx->Ly_ncells_valid = 0;
  mx->Ry_ncells_valid = 0;
  mx->Jk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Lk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Rk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Tk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Jk_ncells_valid = 0;
  mx->Rk_ncells_valid = 0;
  mx->Tk_ncells_valid = 0;
  mx->L               = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_TR_SHADOW_MX) +
	 (3 * (mx->M)        * sizeof(char **))            +  /* mx->{J,L,R}yshadow[] ptrs */
	 (4 * (mx->M)        * sizeof(int **))             +  /* mx->{J,L,R,T}kshadow[] ptrs */
	 mx->Jy_ncells_alloc * sizeof(char)                +  /* mx->Jyshadow_mem */
	 mx->Ly_ncells_alloc * sizeof(char)                +  /* mx->Lyshadow_mem */
	 mx->Ry_ncells_alloc * sizeof(char)                +  /* mx->Ryshadow_mem */
	 mx->Jk_ncells_alloc * sizeof(int)                 +  /* mx->Jkshadow_mem */
	 mx->Lk_ncells_alloc * sizeof(int)                 +  /* mx->Lkshadow_mem */
	 mx->Rk_ncells_alloc * sizeof(int)                 +  /* mx->Rkshadow_mem */
	 mx->Tk_ncells_alloc * sizeof(int)                 +  /* mx->Tkshadow_mem */
	 mx->Lk_ncells_alloc * sizeof(char)                +  /* mx->Lkmode_mem */
	 mx->Rk_ncells_alloc * sizeof(char)                +  /* mx->Rkmode_mem */
	 (4 * mx->B           * allocL * sizeof(int *))    +  /* mx->{J,L,R,T}kshadow[v][] ptrs */
	 (3 * (mx->M - mx->B) * allocL * sizeof(char *)));    /* mx->{J,L,R,T}kshadow[v][] ptrs */
	mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_shadow_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_shadow_mx_GrowTo()
 * Incept:    EPN, Sat Sep 10 12:12:06 2011
 *
 * Purpose:   Assures that a CM_TR_SHADOW_MX <mx> is allocated
 *            for a model of exactly <mx->M> states and a sequence
 *            of length L, reallocating as necessary.
 *
 *            Checks that the matrix has been created for the current CM.
 *            Check is that  mx->yshadow[v] == NULL when v is a B_st and
 *                           mx->kshadow[v] != NULL when v is a B_st.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> if mx does not appeared to be created for this cm
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_shadow_mx_GrowTo(CM_t *cm, CM_TR_SHADOW_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t Jy_cur_size;
  int64_t Ly_cur_size;
  int64_t Ry_cur_size;
  int64_t Jk_cur_size;
  int64_t Lk_cur_size;
  int64_t Rk_cur_size;
  int64_t Tk_cur_size;
  int64_t Jy_ncells;
  int64_t Ly_ncells;
  int64_t Ry_ncells;
  int64_t Jk_ncells;
  int64_t Lk_ncells;
  int64_t Rk_ncells;
  int64_t Tk_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     realloced_Jy; /* did we reallocate mx->Jyshadow_mem? */
  int     realloced_Ly; /* did we reallocate mx->Lyshadow_mem? */
  int     realloced_Ry; /* did we reallocate mx->Ryshadow_mem? */
  int     realloced_Jk; /* did we reallocate mx->Jkshadow_mem? */
  int     realloced_Lk; /* did we reallocate mx->Lkshadow_mem & mx->Lkmode_mem? */
  int     realloced_Rk; /* did we reallocate mx->Rkshadow_mem & mx->Rkmode_mem? */
  int     realloced_Tk; /* did we reallocate mx->Tkshadow_mem? */

  if((status = cm_tr_shadow_mx_SizeNeeded(cm, errbuf, L, &Jy_ncells, &Ly_ncells, &Ry_ncells, &Jk_ncells, &Lk_ncells, &Rk_ncells, &Tk_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded Tr shadow matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded Tr shadow matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded Tr shadow DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full {J,L,R}yshadow and {J,L,R,T}kshadow matrices?
   * or can we get away with just jiggering the pointers, if
   * total required num cells is less than or equal to what
   * we already have alloc'ed?
   */
  realloced_Jy = realloced_Ly = realloced_Ry = FALSE;
  realloced_Jk = realloced_Lk = realloced_Rk = realloced_Tk = FALSE;
  if (Jy_ncells > mx->Jy_ncells_alloc) {
	  ESL_RALLOC(mx->Jyshadow_mem, p, sizeof(char) * Jy_ncells);
	  mx->Jy_ncells_alloc = Jy_ncells;
	  realloced_Jy = TRUE;
  }
  if (Ly_ncells > mx->Ly_ncells_alloc) {
	  ESL_RALLOC(mx->Lyshadow_mem, p, sizeof(char) * Ly_ncells);
	  mx->Ly_ncells_alloc = Ly_ncells;
	  realloced_Ly = TRUE;
  }
  if (Ry_ncells > mx->Ry_ncells_alloc) {
	  ESL_RALLOC(mx->Ryshadow_mem, p, sizeof(char) * Ry_ncells);
	  mx->Ry_ncells_alloc = Ry_ncells;
	  realloced_Ry = TRUE;
  }
  if (Jk_ncells > mx->Jk_ncells_alloc) {
	  ESL_RALLOC(mx->Jkshadow_mem, p, sizeof(int) * Jk_ncells);
	  mx->Jk_ncells_alloc = Jk_ncells;
	  realloced_Jk = TRUE;
  }
  if (Lk_ncells > mx->Lk_ncells_alloc) {
	  ESL_RALLOC(mx->Lkshadow_mem, p, sizeof(int) * Lk_ncells);
	  ESL_RALLOC(mx->Lkmode_mem,   p, sizeof(char) * Lk_ncells);
	  mx->Lk_ncells_alloc = Lk_ncells;
	  realloced_Lk = TRUE;
  }
  if (Rk_ncells > mx->Rk_ncells_alloc) {
	  ESL_RALLOC(mx->Rkshadow_mem, p, sizeof(int) * Rk_ncells);
	  ESL_RALLOC(mx->Rkmode_mem,   p, sizeof(char) * Rk_ncells);
	  mx->Rk_ncells_alloc = Rk_ncells;
	  realloced_Rk = TRUE;
  }
  if (Tk_ncells > mx->Tk_ncells_alloc) {
	  ESL_RALLOC(mx->Tkshadow_mem, p, sizeof(int) * Tk_ncells);
	  mx->Tk_ncells_alloc = Tk_ncells;
	  realloced_Tk = TRUE;
  }
  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   * This is tricky, for each matrix not reallocated, we have to adjust Mb_needed
   * so it uses previously allocated size of that matrix.
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced_Jy) {
	Mb_alloc -= (float) (sizeof(char) * Jy_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Jy_ncells_alloc);
  }
  if(! realloced_Ly) {
	Mb_alloc -= (float) (sizeof(char) * Ly_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Ly_ncells_alloc);
  }
  if(! realloced_Ry) {
	Mb_alloc -= (float) (sizeof(char) * Ry_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Ry_ncells_alloc);
  }
  if(! realloced_Jk) {
	Mb_alloc -= (float) (sizeof(int) * Jk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Jk_ncells_alloc);
  }
  if(! realloced_Lk) {
	Mb_alloc -= (float) (sizeof(int) * Lk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Lk_ncells_alloc);
  }
  if(! realloced_Rk) {
	Mb_alloc -= (float) (sizeof(int) * Rk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Rk_ncells_alloc);
  }
  if(! realloced_Tk) {
	Mb_alloc -= (float) (sizeof(int) * Tk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Tk_ncells_alloc);
  }
  /* note if we didn't reallocate any of the four matrices, Mb_alloc == Mb_needed */
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->Jy_ncells_valid = Jy_ncells;
  mx->Ly_ncells_valid = Ly_ncells;
  mx->Ry_ncells_valid = Ry_ncells;
  mx->Jk_ncells_valid = Jk_ncells;
  mx->Lk_ncells_valid = Lk_ncells;
  mx->Rk_ncells_valid = Rk_ncells;
  mx->Tk_ncells_valid = Tk_ncells;

  /* reallocate the {J,L,R,T}dp[v] ptrs */
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] != B_st) {
	  ESL_RALLOC(mx->Jyshadow[v], p, sizeof(char *) * (L+1));
	  ESL_RALLOC(mx->Lyshadow[v], p, sizeof(char *) * (L+1));
	  ESL_RALLOC(mx->Ryshadow[v], p, sizeof(char *) * (L+1));
	}
	else {
	  ESL_RALLOC(mx->Jkshadow[v], p, sizeof(int *) * (L+1));
	  ESL_RALLOC(mx->Lkshadow[v], p, sizeof(int *) * (L+1));
	  ESL_RALLOC(mx->Rkshadow[v], p, sizeof(int *) * (L+1));
	  ESL_RALLOC(mx->Tkshadow[v], p, sizeof(int *) * (L+1));
	  ESL_RALLOC(mx->Lkmode[v],   p, sizeof(char *) * (L+1));
	  ESL_RALLOC(mx->Rkmode[v],   p, sizeof(char *) * (L+1));
	}
  }

  /* reset the pointers, we keep a tally of number of cells
   * we've seen in each matrix (y_cur_size and k_cur_size) as we go,
   * we could precalc it and store it for each v,j, but that
   * would be wasteful, as we'll only use the matrix configured
   * this way once, in a banded CYK run.
   */
  Jy_cur_size = 0;
  Ly_cur_size = 0;
  Ry_cur_size = 0;
  Jk_cur_size = 0;
  Lk_cur_size = 0;
  Rk_cur_size = 0;
  Tk_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] != B_st) {
	  for(jp = 0; jp <= L; jp++) {
	mx->Jyshadow[v][jp] = mx->Jyshadow_mem + Jy_cur_size;
	mx->Lyshadow[v][jp] = mx->Lyshadow_mem + Ly_cur_size;
	mx->Ryshadow[v][jp] = mx->Ryshadow_mem + Ry_cur_size;
	Jy_cur_size += jp+1;
	Ly_cur_size += jp+1;
	Ry_cur_size += jp+1;
	  }
	}
	else {
	  for(jp = 0; jp <= L; jp++) {
	mx->Jkshadow[v][jp] = mx->Jkshadow_mem + Jk_cur_size;
	mx->Lkshadow[v][jp] = mx->Lkshadow_mem + Lk_cur_size;
	mx->Lkmode[v][jp]   = mx->Lkmode_mem   + Lk_cur_size;
	mx->Rkshadow[v][jp] = mx->Rkshadow_mem + Rk_cur_size;
	mx->Rkmode[v][jp]   = mx->Rkmode_mem   + Rk_cur_size;
	mx->Tkshadow[v][jp] = mx->Tkshadow_mem + Tk_cur_size;
	Jk_cur_size += jp+1;
	Lk_cur_size += jp+1;
	Rk_cur_size += jp+1;
	Tk_cur_size += jp+1;
	  }
	}
  }
  /*printf("Jy ncells %10" PRId64 " %10" PRId64 "\n", Jy_cur_size, mx->Jy_ncells_valid);
	printf("Ly ncells %10" PRId64 " %10" PRId64 "\n", Ly_cur_size, mx->Ly_ncells_valid);
	printf("Ry ncells %10" PRId64 " %10" PRId64 "\n", Ry_cur_size, mx->Ry_ncells_valid);
	printf("Jk ncells %10" PRId64 " %10" PRId64 "\n", Jk_cur_size, mx->Jk_ncells_valid);
	printf("Lk ncells %10" PRId64 " %10" PRId64 "\n", Lk_cur_size, mx->Lk_ncells_valid);
	printf("Rk ncells %10" PRId64 " %10" PRId64 "\n", Rk_cur_size, mx->Rk_ncells_valid);
	printf("Tk ncells %10" PRId64 " %10" PRId64 "\n", Tk_cur_size, mx->Tk_ncells_valid);
  */
  assert(Jy_cur_size == mx->Jy_ncells_valid);
  assert(Ly_cur_size == mx->Ly_ncells_valid);
  assert(Ry_cur_size == mx->Ry_ncells_valid);
  assert(Jk_cur_size == mx->Jk_ncells_valid);
  assert(Lk_cur_size == mx->Lk_ncells_valid);
  assert(Rk_cur_size == mx->Rk_ncells_valid);
  assert(Tk_cur_size == mx->Tk_ncells_valid);
  ESL_DASSERT1((Jy_cur_size == mx->Jy_ncells_valid));
  ESL_DASSERT1((Ly_cur_size == mx->Ly_ncells_valid));
  ESL_DASSERT1((Ry_cur_size == mx->Ry_ncells_valid));
  ESL_DASSERT1((Jk_cur_size == mx->Jk_ncells_valid));
  ESL_DASSERT1((Lk_cur_size == mx->Lk_ncells_valid));
  ESL_DASSERT1((Rk_cur_size == mx->Rk_ncells_valid));
  ESL_DASSERT1((Tk_cur_size == mx->Tk_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_shadow_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Sat Sep 10 12:21:26 2011
 *
 * Purpose:   Frees a <CM_TR_SHADOW_MX>.
 *
 * Returns:   (void)
 */
void
cm_tr_shadow_mx_Destroy(CM_TR_SHADOW_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->Jyshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Jyshadow[v] != NULL) free(mx->Jyshadow[v]);
  }
  free(mx->Jyshadow);

  if (mx->Lyshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lyshadow[v] != NULL) free(mx->Lyshadow[v]);
  }
  free(mx->Lyshadow);

  if (mx->Ryshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Ryshadow[v] != NULL) free(mx->Ryshadow[v]);
  }
  free(mx->Ryshadow);

  if (mx->Jkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Jkshadow[v] != NULL) free(mx->Jkshadow[v]);
  }
  free(mx->Jkshadow);

  if (mx->Lkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lkshadow[v] != NULL) free(mx->Lkshadow[v]);
  }
  free(mx->Lkshadow);

  if (mx->Rkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Rkshadow[v] != NULL) free(mx->Rkshadow[v]);
  }
  free(mx->Rkshadow);

  if (mx->Tkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Tkshadow[v] != NULL) free(mx->Tkshadow[v]);
  }
  free(mx->Tkshadow);

  if (mx->Lkmode      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lkmode[v] != NULL) free(mx->Lkmode[v]);
  }
  free(mx->Lkmode);

  if (mx->Rkmode      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Rkmode[v] != NULL) free(mx->Rkmode[v]);
  }
  free(mx->Rkmode);

  if (mx->Jyshadow_mem  != NULL)  free(mx->Jyshadow_mem);
  if (mx->Lyshadow_mem  != NULL)  free(mx->Lyshadow_mem);
  if (mx->Ryshadow_mem  != NULL)  free(mx->Ryshadow_mem);
  if (mx->Jkshadow_mem  != NULL)  free(mx->Jkshadow_mem);
  if (mx->Lkshadow_mem  != NULL)  free(mx->Lkshadow_mem);
  if (mx->Rkshadow_mem  != NULL)  free(mx->Rkshadow_mem);
  if (mx->Tkshadow_mem  != NULL)  free(mx->Tkshadow_mem);
  if (mx->Lkmode_mem    != NULL)  free(mx->Lkmode_mem);
  if (mx->Rkmode_mem    != NULL)  free(mx->Rkmode_mem);
  free(mx);
  return;
}

/* Function:  cm_tr_shadow_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Sat Sep 10 12:21:53 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_shadow_mx_Dump(FILE *ofp, CM_t *cm, CM_TR_SHADOW_MX *mx, char mode, int print_mx)
{
  int status;
  int v, j, d;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "B: %d\n", mx->B);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "Jy_ncells_alloc: %" PRId64 "\nJy_ncells_valid: %" PRId64 "\n", mx->Jy_ncells_alloc, mx->Jy_ncells_valid);
  fprintf(ofp, "Ly_ncells_alloc: %" PRId64 "\nLy_ncells_valid: %" PRId64 "\n", mx->Ly_ncells_alloc, mx->Ly_ncells_valid);
  fprintf(ofp, "Ry_ncells_alloc: %" PRId64 "\nRy_ncells_valid: %" PRId64 "\n", mx->Ry_ncells_alloc, mx->Ry_ncells_valid);
  fprintf(ofp, "Jk_ncells_alloc: %" PRId64 "\nJk_ncells_valid: %" PRId64 "\n", mx->Jk_ncells_alloc, mx->Jk_ncells_valid);
  fprintf(ofp, "Lk_ncells_alloc: %" PRId64 "\nLk_ncells_valid: %" PRId64 "\n", mx->Lk_ncells_alloc, mx->Lk_ncells_valid);
  fprintf(ofp, "Rk_ncells_alloc: %" PRId64 "\nRk_ncells_valid: %" PRId64 "\n", mx->Rk_ncells_alloc, mx->Rk_ncells_valid);
  fprintf(ofp, "Tk_ncells_alloc: %" PRId64 "\nTk_ncells_valid: %" PRId64 "\n", mx->Tk_ncells_alloc, mx->Tk_ncells_valid);
  fprintf(ofp, "mode: %d\n", mode);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  if(print_mx) {
	/* yshadow/kshadow matrix data */
	for (v = 0; v < mx->M; v++) {
	  if(cm->sttype[v] == B_st) {
	for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	    if(mx->Jkshadow[v])           fprintf(ofp, "Jkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Jkshadow[v][j][d]);
	    if(mx->Lkshadow[v] && fill_L) fprintf(ofp, "Lkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Lkshadow[v][j][d]);
	    if(mx->Rkshadow[v] && fill_R) fprintf(ofp, "Rkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Rkshadow[v][j][d]);
	    if(mx->Tkshadow[v] && fill_T) fprintf(ofp, "Tkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Tkshadow[v][j][d]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	  else { /* ! B_st */
	for(j = 0; j <= mx->L; j++) {
	  for(d = 0; d <= j; d++) {
	    if(mx->Jyshadow[v])           fprintf(ofp, "Jyshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Jyshadow[v][j][d]);
	    if(mx->Lyshadow[v] && fill_L) fprintf(ofp, "Lyshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Lyshadow[v][j][d]);
	    if(mx->Ryshadow[v] && fill_R) fprintf(ofp, "Ryshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Ryshadow[v][j][d]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_tr_shadow_mx_SizeNeeded()
 * Incept:    EPN, Sat Sep 10 12:23:10 2011
 *
 * Purpose: Given a model, and a sequence length L determine the
 *            number of cells and total size in Mb required for the
 *            matrix for the target given the bands.
 *
 *            Return number of {J,L,R}yshadow (char) cells required in
 *            <ret_{J,L,R}ny_cells> and number of {J,L,R,T}kshadow (int) cells
 *            required in <ret_{J,L,R,T}nk_cells) and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm            - the CM the matrix is for
 *            errbuf        - char buffer for reporting errors
 *            L             - length of sequence we will align
 *            ret_Jny_cells - RETURN: number of required char cells for J (Jyshadow)
 *            ret_Lny_cells - RETURN: number of required char cells for L (Lyshadow)
 *            ret_Rny_cells - RETURN: number of required char cells for R (Ryshadow)
 *            ret_Jnk_cells - RETURN: number of required int  cells for J (Jkshadow)
 *            ret_Lnk_cells - RETURN: number of required int  cells for L (Lkshadow)
 *            ret_Rnk_cells - RETURN: number of required int  cells for R (Rkshadow)
 *            ret_Tnk_cells - RETURN: number of required int  cells for T (Tkshadow)
 *            ret_Mb        - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_shadow_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_Jny_cells, int64_t *ret_Lny_cells, int64_t *ret_Rny_cells,
			   int64_t *ret_Jnk_cells, int64_t *ret_Lnk_cells, int64_t *ret_Rnk_cells, int64_t *ret_Tnk_cells, float *ret_Mb)
{
  int     v;
  int64_t Jy_ncells;
  int64_t Ly_ncells;
  int64_t Ry_ncells;
  int64_t Jk_ncells;
  int64_t Lk_ncells;
  int64_t Rk_ncells;
  int64_t Tk_ncells;
  float   Mb_needed;

  Jy_ncells = 0;
  Ly_ncells = 0;
  Ry_ncells = 0;
  Jk_ncells = 0;
  Lk_ncells = 0;
  Rk_ncells = 0;
  Tk_ncells = 0;
  Mb_needed = (float)
	(sizeof(CM_TR_SHADOW_MX) +
	 (3 * (cm->M) * sizeof(char **)) + /* mx->{J,L,R}yshadow[] ptrs */
	 (4 * (cm->M) * sizeof(int **)));  /* mx->{J,L,R,T}kshadow[] ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == B_st) {
	  Mb_needed += (float) (sizeof(int *) * (L+1)); /* mx->Jkshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(int *) * (L+1)); /* mx->Lkshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(int *) * (L+1)); /* mx->Rkshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(int *) * (L+1)); /* mx->Tkshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->Lkmode[v][] ptrs */
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->Rkmode[v][] ptrs */
	  Jk_ncells += (int) ((L+2) * (L+1) * 0.5);
	  Lk_ncells += (int) ((L+2) * (L+1) * 0.5);
	  Rk_ncells += (int) ((L+2) * (L+1) * 0.5);
	  Tk_ncells += (int) ((L+2) * (L+1) * 0.5);
	}
	else {
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->Jyshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->Lyshadow[v][] ptrs */
	  Mb_needed += (float) (sizeof(char *) * (L+1)); /* mx->Ryshadow[v][] ptrs */
	  Jy_ncells += (int) ((L+2) * (L+1) * 0.5);
	  Ly_ncells += (int) ((L+2) * (L+1) * 0.5);
	  Ry_ncells += (int) ((L+2) * (L+1) * 0.5);
	}
  }

  Mb_needed += sizeof(int)  * Jk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Lk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Rk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Tk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(char) * Lk_ncells; /* mx->Jkmode_mem   */
  Mb_needed += sizeof(char) * Rk_ncells; /* mx->Jkmode_mem   */
  Mb_needed += sizeof(char) * Jy_ncells; /* mx->Jyshadow_mem */
  Mb_needed += sizeof(char) * Ly_ncells; /* mx->Jyshadow_mem */
  Mb_needed += sizeof(char) * Ry_ncells; /* mx->Jyshadow_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_Jny_cells != NULL) *ret_Jny_cells = Jy_ncells;
  if(ret_Lny_cells != NULL) *ret_Lny_cells = Ly_ncells;
  if(ret_Rny_cells != NULL) *ret_Rny_cells = Ry_ncells;
  if(ret_Jnk_cells != NULL) *ret_Jnk_cells = Jk_ncells;
  if(ret_Lnk_cells != NULL) *ret_Lnk_cells = Lk_ncells;
  if(ret_Rnk_cells != NULL) *ret_Rnk_cells = Rk_ncells;
  if(ret_Tnk_cells != NULL) *ret_Tnk_cells = Tk_ncells;
  if(ret_Mb        != NULL) *ret_Mb        = Mb_needed;
  return eslOK;
}

/*****************************************************************
 *   7. CM_HB_SHADOW_MX data structure functions,
 *      HMM banded shadow matrix for tracing back HMM banded CM parses.
 *****************************************************************/

/* Function:  cm_hb_shadow_mx_Create()
 * Incept:    EPN, Fri Oct 26 05:05:07 2007
 *
 * Purpose:   Allocate a reusable, resizeable <CM_HB_SHADOW_MX> for a CM <cm>
 *            given a CP9Bands_t object that defines the bands. The CM
 *            is needed so we know which decks need to be int's (BIF_B states)
 *            and which need to be char's (all other states).
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_HB_SHADOW_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_HB_SHADOW_MX *
cm_hb_shadow_mx_Create(CM_t *cm)
{
  int     status;
  CM_HB_SHADOW_MX *mx = NULL;
  int     v;
  int     M = cm->M;
  int     nbifs, nb;
  int allocL = 1;
  int allocW = 1;

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_HB_SHADOW_MX));
  mx->yshadow     = NULL;
  mx->yshadow_mem = NULL;
  mx->kshadow     = NULL;
  mx->kshadow_mem = NULL;
  mx->cp9b        = NULL;

  /* level 2: deck (state) pointers, 0.1..M-1, M (EL deck) is irrelevant for the
   *          shadow matrix.
   */
  ESL_ALLOC(mx->yshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->kshadow,  sizeof(int **)  * M);

  /* level 3: matrix cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  nbifs = CMCountStatetype(cm, B_st);

  ESL_ALLOC(mx->nrowsA, sizeof(int)      * M);
  ESL_ALLOC(mx->yshadow_mem, (sizeof(char) * (M-nbifs)));
  ESL_ALLOC(mx->kshadow_mem, (sizeof(int)  * ESL_MAX(1,nbifs)));  // avoid 0 malloc

  nb = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == B_st) {
	  ESL_ALLOC(mx->kshadow[v], sizeof(int *) * (allocL));
	  mx->kshadow[v][0] = mx->kshadow_mem + nb * (allocL) * (allocW);
	  mx->yshadow[v] = NULL;
	  nb++;
	}
	else {
	  ESL_ALLOC(mx->yshadow[v], sizeof(char *) * (allocL));
	  mx->yshadow[v][0] = mx->yshadow_mem + (v-nb) * (allocL) * (allocW);
	  mx->kshadow[v] = NULL;
	}
	mx->nrowsA[v] = allocL;
  }
  mx->M              = M;
  mx->B              = nbifs;
  mx->y_ncells_alloc = (M-nbifs)*(allocL)*(allocW);
  mx->y_ncells_valid = 0;
  mx->k_ncells_alloc = (nbifs)*(allocL)*(allocW);
  mx->k_ncells_valid = 0;
  mx->L            = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_HB_SHADOW_MX) +
	 (mx->M        * sizeof(char **))            +  /* mx->yshadow[] ptrs */
	 (mx->M        * sizeof(int **))             +  /* mx->kshadow[] ptrs */
	 mx->y_ncells_alloc * sizeof(char)           +  /* mx->yshadow_mem */
	 mx->k_ncells_alloc * sizeof(int)            +  /* mx->kshadow_mem */
	 (mx->M        * sizeof(int))                +  /* mx->nrowsA */
	 (mx->B        * allocL * sizeof(int *))     +  /* mx->kshadow[v][] ptrs */
	 ((mx->M-mx->B)* allocL * sizeof(int *)));      /* mx->yshadow[v][] ptrs */
  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_hb_shadow_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_hb_shadow_mx_GrowTo()
 * Incept:    EPN, Fri Oct 26 05:19:49 2007
 *
 * Purpose:   Assures that a shadow matrix <mx> is allocated
 *            for a model of exactly <mx->M> states and required number of
 *            total cells. Determines new required size from
 *            the CP9Bands_t object passed in, and reallocates if
 *            necessary.
 *
 *            Checks that the matrix has been created for the current CM.
 *            Check is that  mx->yshadow[v] == NULL when v is a B_st and
 *                           mx->kshadow[v] != NULL when v is a B_st.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> if mx does not appeared to be created for this cm
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_hb_shadow_mx_GrowTo(CM_t *cm, CM_HB_SHADOW_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int     y_cur_size, k_cur_size = 0;
  int64_t y_ncells, k_ncells;
  int     jbw;
  float   Mb_needed;   /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */

  /* contract check, number of states (M) is something we don't change
   * so check this matrix has same number of 1st dim state ptrs that
   * cp9b has */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() entered with cp9b == NULL.\n");
  if(cp9b->cm_M != mx->M) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() entered with mx->M: (%d) != cp9b->M (%d)\n", mx->M, cp9b->cm_M);

  if((status = cm_hb_shadow_mx_SizeNeeded(cm, errbuf, cp9b, &y_ncells, &k_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("HMM banded shadow matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("HMM banded shadow matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded shadow DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* check if we should free the matrix, because it is significantly bigger than we need */
  if((mx->size_Mb > (0.5  * size_limit)) && /* matrix is >= 0.5 * size of our limit (based on bands from previous sequence) */
	 (mx->size_Mb > (1.25 * Mb_needed))) {  /* matrix is at least 25% bigger than we need to process current sequence */
	free(mx->yshadow_mem);
	free(mx->kshadow_mem);
	mx->yshadow_mem = NULL;
	mx->kshadow_mem = NULL;
	mx->y_ncells_alloc = 0;
	mx->k_ncells_alloc = 0;
  }

  /* must we realloc the full yshadow and kshadow matrices?
   * or can we get away with just jiggering the pointers, if
   * total required num cells is less than or equal to what
   * we already have alloc'ed?
   */

  /* handle yshadow */
  if (y_ncells > mx->y_ncells_alloc) {
	  ESL_RALLOC(mx->yshadow_mem, p, sizeof(char) * y_ncells);
	  mx->y_ncells_alloc = y_ncells;
	  Mb_alloc = Mb_needed;
  }
  else {
	/* mx->yshadow_mem remains as it is allocated, set Mb_alloc
	 * accordingly (this is not just mx->size_Mb, because size of
	 * pointer arrays may change, for example)
	 */
	Mb_alloc  = Mb_needed * 1000000.; /* convert to bytes */
	Mb_alloc -= ((float) (sizeof(char) * y_ncells));
	Mb_alloc += ((float) (sizeof(char) * mx->y_ncells_alloc));
	Mb_alloc *= 0.000001; /* convert to Mb */
  }
  mx->y_ncells_valid = y_ncells;

  /* handle kshadow */
  if (k_ncells > mx->k_ncells_alloc) {
	  ESL_RALLOC(mx->kshadow_mem, p, sizeof(int) * k_ncells);
	  mx->k_ncells_alloc = k_ncells;
  }
  else {
	/* mx->kshadow_mem remains as it is allocated, update Mb_alloc */
	Mb_alloc *= 1000000.; /* convert to bytes */
	Mb_alloc -= ((float) (sizeof(int) * k_ncells));
	Mb_alloc += ((float) (sizeof(int) * mx->k_ncells_alloc));
	Mb_alloc *= 0.000001; /* convert to Mb */
  }
  mx->k_ncells_valid = k_ncells;

  /* make sure each row is big enough */
  for(v = 0; v < mx->M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v] + 1;
	if(jbw > mx->nrowsA[v]) {
	  if(cm->sttype[v] == B_st) {
	if(mx->kshadow[v] == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() v is a B st %d, but mx->kshadow[v] == NULL.\n", v);
	if(mx->yshadow[v] != NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() v is a B st %d, but mx->yshadow[v] != NULL.\n", v);
	ESL_RALLOC(mx->kshadow[v], p, sizeof(int *) * jbw);
	mx->nrowsA[v] = jbw;
	  }
	  else {
	if(mx->kshadow[v] != NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() v is not a B st %d, but mx->kshadow[v] != NULL.\n", v);
	if(mx->yshadow[v] == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_GrowTo() v is not a B st %d, but mx->kshadow[v] == NULL.\n", v);
	ESL_RALLOC(mx->yshadow[v], p, sizeof(char *) * jbw);
	mx->nrowsA[v] = jbw;
	  }
	}
  }

  /* reset the pointers, we keep a tally of number of cells
   * we've seen in each matrix (y_cur_size and k_cur_size) as we go,
   * we could precalc it and store it for each v,j, but that
   * would be wasteful, as we'll only use the matrix configured
   * this way once, in a banded CYK run.
   */
  y_cur_size = k_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] == B_st) {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->kshadow[v][jp] = mx->kshadow_mem + k_cur_size;
	k_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
	else {
	  for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	mx->yshadow[v][jp] = mx->yshadow_mem + y_cur_size;
	y_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	  }
	}
  }
  ESL_DASSERT1((y_cur_size == mx->y_ncells_valid));
  ESL_DASSERT1((k_cur_size == mx->k_ncells_valid));

  mx->cp9b = cp9b; /* just a reference */

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hb_shadow_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Fri Oct 26 09:04:04 2007
 *
 * Purpose:   Frees a <CM_HB_SHADOW_MX>.
 *
 * Returns:   (void)
 */
void
cm_hb_shadow_mx_Destroy(CM_HB_SHADOW_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->yshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->yshadow[v] != NULL) free(mx->yshadow[v]);
  }
  free(mx->yshadow);

  if (mx->kshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->kshadow[v] != NULL) free(mx->kshadow[v]);
  }
  free(mx->kshadow);

  if (mx->nrowsA  != NULL)       free(mx->nrowsA);
  if (mx->yshadow_mem  != NULL)  free(mx->yshadow_mem);
  if (mx->kshadow_mem  != NULL)  free(mx->kshadow_mem);
  free(mx);
  return;
}

/* Function:  cm_hb_shadow_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Fri Oct 26 09:04:46 2007
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_hb_shadow_mx_Dump(FILE *ofp, CM_t *cm, CM_HB_SHADOW_MX *mx, int print_mx)
{
  int v, jp, j, dp, d;

  fprintf(ofp, "M: %d\nnbifs: %d\nL: %d\ny_ncells_alloc: %" PRId64 "\ny_ncells_valid: %" PRId64 "\nk_ncells_alloc: %" PRId64 "\nk_ncells_valid: %" PRId64 "\n", mx->M, mx->B, mx->L, mx->y_ncells_alloc, mx->y_ncells_valid, mx->k_ncells_alloc, mx->k_ncells_valid);

  if(print_mx) {
	/* yshadow/kshadow matrix data */
	for (v = 0; v < mx->M; v++) {
	  if(cm->sttype[v] == B_st) {
	for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	  j = jp + mx->cp9b->jmin[v];
	  for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	    d = dp + mx->cp9b->hdmin[v][jp];
	    fprintf(ofp, "kshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->kshadow[v][jp][dp]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	  else {
	for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	  j = jp + mx->cp9b->jmin[v];
	  for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	    d = dp + mx->cp9b->hdmin[v][jp];
	    fprintf(ofp, "yshad[v:%5d][j:%5d][d:%5d] %8c\n", v, j, d, mx->yshadow[v][jp][dp]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_hb_shadow_mx_SizeNeeded()
 * Incept:    EPN, Fri Aug 12 04:19:36 2011
 *
 * Purpose:   Given a model, and a CP9_bands_t object
 *            with pre-calced bands for a target, determine the number
 *            of cells and total size in Mb required for the matrix
 *            for the target given the bands.
 *
 *            Return number of yshadow (char) cells required in
 *            <ret_ny_cells> and number of kshadow (int) cells
 *            required in <ret_nk_cells) and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            cp9b         - the bands for the current target sequence
 *            ret_ny_cells - RETURN: number of required char cells (yshadow)
 *            ret_nk_cells - RETURN: number of required int  cells (kshadow)
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_hb_shadow_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int64_t *ret_ny_cells, int64_t *ret_nk_cells, float *ret_Mb)
{
  int     v, jp;
  int64_t y_ncells, k_ncells;
  int     jbw;
  float   Mb_needed;

  /* contract check */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_hb_shadow_mx_SizeNeeded() entered with cp9b == NULL.\n");

  y_ncells = k_ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_HB_SHADOW_MX) +
	 (cp9b->cm_M        * sizeof(char **))            +  /* mx->yshadow[] ptrs */
	 (cp9b->cm_M        * sizeof(int **))             +  /* mx->kshadow[] ptrs */
	 (cp9b->cm_M        * sizeof(int)));                 /* mx->nrowsA */

  for(v = 0; v < cp9b->cm_M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v];
	if(cm->sttype[v] == B_st) {
	  Mb_needed += (float) (sizeof(int *) * (jbw+1)); /* mx->kshadow[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++)
	k_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	else {
	  Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->yshadow[v][] ptrs */
	  for(jp = 0; jp <= jbw; jp++)
	y_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
  }
  Mb_needed += sizeof(char) * y_ncells; /* mx->yshadow_mem */
  Mb_needed += sizeof(int)  * k_ncells; /* mx->kshadow_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_ny_cells != NULL) *ret_ny_cells = y_ncells;
  if(ret_nk_cells != NULL) *ret_nk_cells = k_ncells;
  if(ret_Mb       != NULL) *ret_Mb       = Mb_needed;

  return eslOK;

}

/*****************************************************************
 *   8. CM_TR_HB_SHADOW_MX data structure functions,
 *      HMM banded shadow matrix for tracing back HMM banded CM parses.
 *****************************************************************/

/* Function:  cm_tr_hb_shadow_mx_Create()
 * Incept:    EPN, Wed Sep  7 15:21:02 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_HB_SHADOW_MX> for a CM <cm>
 *            given a CP9Bands_t object that defines the bands. The CM
 *            is needed so we know which decks need to be int's (BIF_B states)
 *            and which need to be char's (all other states).
 *
 *            We've set this up so it should be easy to allocate
 *            aligned memory, though we're not doing this yet.
 *
 * Returns:   a pointer to the new <CM_HB_SHADOW_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_HB_SHADOW_MX *
cm_tr_hb_shadow_mx_Create(CM_t *cm)
{
  int     status;
  CM_TR_HB_SHADOW_MX *mx = NULL;
  int     v, b;
  int     M = cm->M;
  int allocL = 1;
  int allocW = 1;
  int B = CMCountNodetype(cm, BIF_nd);

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_HB_SHADOW_MX));
  mx->Jyshadow     = NULL;
  mx->Jyshadow_mem = NULL;
  mx->Lyshadow     = NULL;
  mx->Lyshadow_mem = NULL;
  mx->Ryshadow     = NULL;
  mx->Ryshadow_mem = NULL;

  mx->Jkshadow     = NULL;
  mx->Jkshadow_mem = NULL;
  mx->Lkshadow     = NULL;
  mx->Lkshadow_mem = NULL;
  mx->Rkshadow     = NULL;
  mx->Rkshadow_mem = NULL;
  mx->Tkshadow     = NULL;
  mx->Tkshadow_mem = NULL;

  mx->Lkmode       = NULL;
  mx->Lkmode_mem   = NULL;
  mx->Rkmode       = NULL;
  mx->Rkmode_mem   = NULL;

  mx->cp9b        = NULL;

  /* level 2: deck (state) pointers, 0.1..M-1, M (EL deck) is irrelevant for the
   *          shadow matrix.
   */
  ESL_ALLOC(mx->Jyshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->Lyshadow,  sizeof(char **) * M);
  ESL_ALLOC(mx->Ryshadow,  sizeof(char **) * M);

  ESL_ALLOC(mx->Jkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Lkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Rkshadow,  sizeof(int **)  * M);
  ESL_ALLOC(mx->Tkshadow,  sizeof(int **)  * M);

  ESL_ALLOC(mx->Lkmode,    sizeof(char **) * M);
  ESL_ALLOC(mx->Rkmode,    sizeof(char **) * M);

  /* level 3: matrix cell memory, when creating only allocate 1 cell per state, for j = 0, d = 0 */
  ESL_ALLOC(mx->Jyshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));
  ESL_ALLOC(mx->Lyshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));
  ESL_ALLOC(mx->Ryshadow_mem, (sizeof(char) * (M-B) * (allocL) * (allocW)));

  ESL_ALLOC(mx->Jkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW)); // avoid 0 malloc
  ESL_ALLOC(mx->Lkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Rkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Tkshadow_mem, sizeof(int)  * ESL_MAX(1, B * allocL * allocW));

  ESL_ALLOC(mx->Lkmode_mem,   sizeof(char) * ESL_MAX(1, B * allocL * allocW));
  ESL_ALLOC(mx->Rkmode_mem,   sizeof(char) * ESL_MAX(1, B * allocL * allocW));

  ESL_ALLOC(mx->JnrowsA, sizeof(int)      * M);
  ESL_ALLOC(mx->LnrowsA, sizeof(int)      * M);
  ESL_ALLOC(mx->RnrowsA, sizeof(int)      * M);
  ESL_ALLOC(mx->TnrowsA, sizeof(int)      * M);

  b = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == B_st) {
	  ESL_ALLOC(mx->Jkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Lkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Rkshadow[v], sizeof(int *) * (allocL));
	  ESL_ALLOC(mx->Tkshadow[v], sizeof(int *) * (allocL));

	  ESL_ALLOC(mx->Lkmode[v],   sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Rkmode[v],   sizeof(char *) * (allocL));

	  mx->Jkshadow[v][0] = mx->Jkshadow_mem + b * (allocL) * (allocW);
	  mx->Lkshadow[v][0] = mx->Lkshadow_mem + b * (allocL) * (allocW);
	  mx->Rkshadow[v][0] = mx->Rkshadow_mem + b * (allocL) * (allocW);
	  mx->Tkshadow[v][0] = mx->Tkshadow_mem + b * (allocL) * (allocW);

	  mx->Lkmode[v][0]   = mx->Lkmode_mem   + b * (allocL) * (allocW);
	  mx->Rkmode[v][0]   = mx->Rkmode_mem   + b * (allocL) * (allocW);

	  mx->Jyshadow[v] = NULL;
	  mx->Lyshadow[v] = NULL;
	  mx->Ryshadow[v] = NULL;
	  b++;
	}
	else {
	  ESL_ALLOC(mx->Jyshadow[v], sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Lyshadow[v], sizeof(char *) * (allocL));
	  ESL_ALLOC(mx->Ryshadow[v], sizeof(char *) * (allocL));

	  mx->Jyshadow[v][0] = mx->Jyshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Lyshadow[v][0] = mx->Lyshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Ryshadow[v][0] = mx->Ryshadow_mem + (v-b) * (allocL) * (allocW);
	  mx->Jkshadow[v] = NULL;
	  mx->Lkshadow[v] = NULL;
	  mx->Rkshadow[v] = NULL;
	  mx->Tkshadow[v] = NULL;

	  mx->Lkmode[v] = NULL;
	  mx->Rkmode[v] = NULL;
	}
	mx->JnrowsA[v] = allocL;
	mx->LnrowsA[v] = allocL;
	mx->RnrowsA[v] = allocL;
	mx->TnrowsA[v] = allocL;
  }
  mx->M               = M;
  mx->B               = B;
  mx->Jy_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Ly_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Ry_ncells_alloc = (M-B)*(allocL)*(allocW);
  mx->Jy_ncells_valid = 0;
  mx->Ly_ncells_valid = 0;
  mx->Ry_ncells_valid = 0;
  mx->Jk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Lk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Rk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Tk_ncells_alloc = (B)*(allocL)*(allocW);
  mx->Jk_ncells_valid = 0;
  mx->Rk_ncells_valid = 0;
  mx->Tk_ncells_valid = 0;
  mx->L               = allocL; /* allocL = 1 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_TR_HB_SHADOW_MX) +
	 (3 * (mx->M)        * sizeof(char **))            +  /* mx->{J,L,R}yshadow[] ptrs */
	 (4 * (mx->M)        * sizeof(int **))             +  /* mx->{J,L,R,T}kshadow[] ptrs */
	 mx->Jy_ncells_alloc * sizeof(char)                +  /* mx->Jyshadow_mem */
	 mx->Ly_ncells_alloc * sizeof(char)                +  /* mx->Lyshadow_mem */
	 mx->Ry_ncells_alloc * sizeof(char)                +  /* mx->Ryshadow_mem */
	 mx->Jk_ncells_alloc * sizeof(int)                 +  /* mx->Jkshadow_mem */
	 mx->Lk_ncells_alloc * sizeof(int)                 +  /* mx->Lkshadow_mem */
	 mx->Rk_ncells_alloc * sizeof(int)                 +  /* mx->Rkshadow_mem */
	 mx->Tk_ncells_alloc * sizeof(int)                 +  /* mx->Tkshadow_mem */
	 mx->Lk_ncells_alloc * sizeof(char)                +  /* mx->Lkmode_mem */
	 mx->Rk_ncells_alloc * sizeof(char)                +  /* mx->Rkmode_mem */
	 (4 * (mx->M)        * sizeof(int))                +  /* mx->{J,L,R,T}nrowsA */
	 (4 * mx->B           * allocL * sizeof(int *))    +  /* mx->{J,L,R,T}kshadow[v][] ptrs */
	 (3 * (mx->M - mx->B) * allocL * sizeof(char *)));    /* mx->{J,L,R,T}kshadow[v][] ptrs */
	mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_hb_shadow_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_hb_shadow_mx_GrowTo()
 * Incept:    EPN, Wed Sep  7 12:54:32 2011
 *
 * Purpose:   Assures that a CM_TR_HB_SHADOW_MX <mx> is allocated
 *            for a model of exactly <mx->M> states and required number of
 *            total cells. Determines new required size from
 *            the CP9Bands_t object passed in, and reallocates if
 *            necessary.
 *
 *            Checks that the matrix has been created for the current CM.
 *            Check is that  mx->yshadow[v] == NULL when v is a B_st and
 *                           mx->kshadow[v] != NULL when v is a B_st.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the bands for the current target sequence
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> if mx does not appeared to be created for this cm
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_hb_shadow_mx_GrowTo(CM_t *cm, CM_TR_HB_SHADOW_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v, jp;
  int64_t Jy_cur_size;
  int64_t Ly_cur_size;
  int64_t Ry_cur_size;
  int64_t Jk_cur_size;
  int64_t Lk_cur_size;
  int64_t Rk_cur_size;
  int64_t Tk_cur_size;
  int64_t Jy_ncells;
  int64_t Ly_ncells;
  int64_t Ry_ncells;
  int64_t Jk_ncells;
  int64_t Lk_ncells;
  int64_t Rk_ncells;
  int64_t Tk_ncells;
  int     jbw;
  float   Mb_needed;   /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     realloced_Jy; /* did we reallocate mx->Jyshadow_mem? */
  int     realloced_Ly; /* did we reallocate mx->Lyshadow_mem? */
  int     realloced_Ry; /* did we reallocate mx->Ryshadow_mem? */
  int     realloced_Jk; /* did we reallocate mx->Jkshadow_mem? */
  int     realloced_Lk; /* did we reallocate mx->Lkshadow_mem & mx->Lkmode_mem? */
  int     realloced_Rk; /* did we reallocate mx->Rkshadow_mem & mx->Rkmode_mem? */
  int     realloced_Tk; /* did we reallocate mx->Tkshadow_mem? */

  /* contract check, number of states (M) is something we don't change
   * so check this matrix has same number of 1st dim state ptrs that
   * cp9b has */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_hb_shadow_mx_GrowTo() entered with cp9b == NULL.\n");
  if(cp9b->cm_M != mx->M) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_hb_shadow_mx_GrowTo() entered with mx->M: (%d) != cp9b->M (%d)\n", mx->M, cp9b->cm_M);

  if((status = cm_tr_hb_shadow_mx_SizeNeeded(cm, errbuf, cp9b, &Jy_ncells, &Ly_ncells, &Ry_ncells, &Jk_ncells, &Lk_ncells, &Rk_ncells, &Tk_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("HMM banded Tr shadow matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("HMM banded Tr shadow matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded Tr shadow DP mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* check if we should free the matrix */
  if((mx->size_Mb > (0.5  * size_limit)) && /* matrix is >= 0.5 * size of our limit (based on bands from previous sequence) */
	 (mx->size_Mb > (1.25 * Mb_needed))) {  /* matrix is at least 25% bigger than we need to process current sequence */
	free(mx->Jyshadow_mem);
	free(mx->Lyshadow_mem);
	free(mx->Ryshadow_mem);
	free(mx->Jkshadow_mem);
	free(mx->Lkshadow_mem);
	free(mx->Rkshadow_mem);
	free(mx->Tkshadow_mem);
	free(mx->Lkmode_mem);
	free(mx->Rkmode_mem);
	mx->Jyshadow_mem = NULL;
	mx->Lyshadow_mem = NULL;
	mx->Ryshadow_mem = NULL;
	mx->Jkshadow_mem = NULL;
	mx->Lkshadow_mem = NULL;
	mx->Rkshadow_mem = NULL;
	mx->Tkshadow_mem = NULL;
	mx->Lkmode_mem   = NULL;
	mx->Rkmode_mem   = NULL;
	mx->Jy_ncells_alloc = 0;
	mx->Ly_ncells_alloc = 0;
	mx->Ry_ncells_alloc = 0;
	mx->Jk_ncells_alloc = 0;
	mx->Lk_ncells_alloc = 0;
	mx->Rk_ncells_alloc = 0;
	mx->Tk_ncells_alloc = 0;
  }

  /* must we realloc the full {J,L,R}yshadow and {J,L,R,T}kshadow matrices?
   * or can we get away with just jiggering the pointers, if
   * total required num cells is less than or equal to what
   * we already have alloc'ed?
   */
  realloced_Jy = realloced_Ly = realloced_Ry = FALSE;
  realloced_Jk = realloced_Lk = realloced_Rk = realloced_Tk = FALSE;
  if (Jy_ncells > mx->Jy_ncells_alloc) {
	  ESL_RALLOC(mx->Jyshadow_mem, p, sizeof(char) * Jy_ncells);
	  mx->Jy_ncells_alloc = Jy_ncells;
	  realloced_Jy = TRUE;
  }
  if (Ly_ncells > mx->Ly_ncells_alloc) {
	  ESL_RALLOC(mx->Lyshadow_mem, p, sizeof(char) * Ly_ncells);
	  mx->Ly_ncells_alloc = Ly_ncells;
	  realloced_Ly = TRUE;
  }
  if (Ry_ncells > mx->Ry_ncells_alloc) {
	  ESL_RALLOC(mx->Ryshadow_mem, p, sizeof(char) * Ry_ncells);
	  mx->Ry_ncells_alloc = Ry_ncells;
	  realloced_Ry = TRUE;
  }
  if (Jk_ncells > mx->Jk_ncells_alloc) {
	  ESL_RALLOC(mx->Jkshadow_mem, p, sizeof(int) * Jk_ncells);
	  mx->Jk_ncells_alloc = Jk_ncells;
	  realloced_Jk = TRUE;
  }
  if (Lk_ncells > mx->Lk_ncells_alloc) {
	  ESL_RALLOC(mx->Lkshadow_mem, p, sizeof(int) * Lk_ncells);
	  ESL_RALLOC(mx->Lkmode_mem,   p, sizeof(char) * Lk_ncells);
	  mx->Lk_ncells_alloc = Lk_ncells;
	  realloced_Lk = TRUE;
  }
  if (Rk_ncells > mx->Rk_ncells_alloc) {
	  ESL_RALLOC(mx->Rkshadow_mem, p, sizeof(int) * Rk_ncells);
	  ESL_RALLOC(mx->Rkmode_mem,   p, sizeof(char) * Rk_ncells);
	  mx->Rk_ncells_alloc = Rk_ncells;
	  realloced_Rk = TRUE;
  }
  if (Tk_ncells > mx->Tk_ncells_alloc) {
	  ESL_RALLOC(mx->Tkshadow_mem, p, sizeof(int) * Tk_ncells);
	  mx->Tk_ncells_alloc = Tk_ncells;
	  realloced_Tk = TRUE;
  }
  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   * This is tricky, for each matrix not reallocated, we have to adjust Mb_needed
   * so it uses previously allocated size of that matrix.
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! realloced_Jy) {
	Mb_alloc -= (float) (sizeof(char) * Jy_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Jy_ncells_alloc);
  }
  if(! realloced_Ly) {
	Mb_alloc -= (float) (sizeof(char) * Ly_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Ly_ncells_alloc);
  }
  if(! realloced_Ry) {
	Mb_alloc -= (float) (sizeof(char) * Ry_ncells);
	Mb_alloc += (float) (sizeof(char) * mx->Ry_ncells_alloc);
  }
  if(! realloced_Jk) {
	Mb_alloc -= (float) (sizeof(int) * Jk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Jk_ncells_alloc);
  }
  if(! realloced_Lk) {
	Mb_alloc -= (float) (sizeof(int) * Lk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Lk_ncells_alloc);
  }
  if(! realloced_Rk) {
	Mb_alloc -= (float) (sizeof(int) * Rk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Rk_ncells_alloc);
  }
  if(! realloced_Tk) {
	Mb_alloc -= (float) (sizeof(int) * Tk_ncells);
	Mb_alloc += (float) (sizeof(int) * mx->Tk_ncells_alloc);
  }
  /* note if we didn't reallocate any of the four matrices, Mb_alloc == Mb_needed */
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->Jy_ncells_valid = Jy_ncells;
  mx->Ly_ncells_valid = Ly_ncells;
  mx->Ry_ncells_valid = Ry_ncells;
  mx->Jk_ncells_valid = Jk_ncells;
  mx->Lk_ncells_valid = Lk_ncells;
  mx->Rk_ncells_valid = Rk_ncells;
  mx->Tk_ncells_valid = Tk_ncells;

  /* make sure each row is big enough */
  for(v = 0; v < mx->M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v] + 1;

	if(cm->sttype[v] != B_st) {
	  if(cp9b->Jvalid[v]) {
	if(jbw > mx->JnrowsA[v]) {
	  if(mx->Jyshadow[v] != NULL) ESL_RALLOC(mx->Jyshadow[v], p, sizeof(char *)  * jbw);
	  else                        ESL_ALLOC (mx->Jyshadow[v],    sizeof(char *)  * jbw);
	  mx->JnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Jvalid[v] is FALSE */
	if(mx->Jyshadow[v] != NULL) free(mx->Jyshadow[v]);
	mx->Jyshadow[v] = NULL;
	mx->JnrowsA[v] = 0;
	  }
	  if(cp9b->Lvalid[v]) {
	if(jbw > mx->LnrowsA[v]) {
	  if(mx->Lyshadow[v] != NULL) ESL_RALLOC(mx->Lyshadow[v], p, sizeof(char *)  * jbw);
	  else                        ESL_ALLOC (mx->Lyshadow[v],    sizeof(char *)  * jbw);
	  mx->LnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Lvalid[v] is FALSE */
	if(mx->Lyshadow[v] != NULL) free(mx->Lyshadow[v]);
	mx->Lyshadow[v] = NULL;
	mx->LnrowsA[v] = 0;
	  }
	  if(cp9b->Rvalid[v]) {
	if(jbw > mx->RnrowsA[v]) {
	  if(mx->Ryshadow[v] != NULL) ESL_RALLOC(mx->Ryshadow[v], p, sizeof(char *)  * jbw);
	  else                        ESL_ALLOC (mx->Ryshadow[v],    sizeof(char *)  * jbw);
	  mx->RnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Rvalid[v] is FALSE */
	if(mx->Ryshadow[v] != NULL) free(mx->Ryshadow[v]);
	mx->Ryshadow[v] = NULL;
	mx->RnrowsA[v] = 0;
	  }
	}
	else { /* cm->sttype[v] == B_st */
	  if(cp9b->Jvalid[v]) {
	if(jbw > mx->JnrowsA[v]) {
	  if(mx->Jkshadow[v] != NULL) ESL_RALLOC(mx->Jkshadow[v], p, sizeof(int *)  * jbw);
	  else                        ESL_ALLOC (mx->Jkshadow[v],    sizeof(int *)  * jbw);
	  mx->JnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Jvalid[v] is FALSE */
	if(mx->Jkshadow[v] != NULL) free(mx->Jkshadow[v]);
	mx->Jkshadow[v] = NULL;
	mx->JnrowsA[v] = 0;
	  }
	  if(cp9b->Lvalid[v]) {
	if(jbw > mx->LnrowsA[v]) {
	  if(mx->Lkshadow[v] != NULL) ESL_RALLOC(mx->Lkshadow[v], p, sizeof(int *)  * jbw);
	  else                        ESL_ALLOC (mx->Lkshadow[v],    sizeof(int *)  * jbw);
	  if(mx->Lkmode[v] != NULL)   ESL_RALLOC(mx->Lkmode[v],   p, sizeof(char *)  * jbw);
	  else                        ESL_ALLOC (mx->Lkmode[v],      sizeof(char *)  * jbw);
	  mx->LnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Lvalid[v] is FALSE */
	if(mx->Lkshadow[v] != NULL) free(mx->Lkshadow[v]);
	if(mx->Lkmode[v]   != NULL) free(mx->Lkmode[v]);
	mx->Lkshadow[v] = NULL;
	mx->Lkmode[v]   = NULL;
	mx->LnrowsA[v] = 0;
	  }
	  if(cp9b->Rvalid[v]) {
	if(jbw > mx->RnrowsA[v]) {
	  if(mx->Rkshadow[v] != NULL) ESL_RALLOC(mx->Rkshadow[v], p, sizeof(int *)  * jbw);
	  else                        ESL_ALLOC (mx->Rkshadow[v],    sizeof(int *)  * jbw);
	  if(mx->Rkmode[v]   != NULL) ESL_RALLOC(mx->Rkmode[v],   p, sizeof(char *)  * jbw);
	  else                        ESL_ALLOC (mx->Rkmode[v],      sizeof(char *)  * jbw);
	  mx->RnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Rvalid[v] is FALSE */
	if(mx->Rkshadow[v] != NULL) free(mx->Rkshadow[v]);
	if(mx->Rkmode[v]   != NULL) free(mx->Rkmode[v]);
	mx->Rkshadow[v] = NULL;
	mx->Rkmode[v]   = NULL;
	mx->RnrowsA[v] = 0;
	  }
	  if(cp9b->Tvalid[v]) {
	if(jbw > mx->TnrowsA[v]) {
	  if(mx->Tkshadow[v] != NULL) ESL_RALLOC(mx->Tkshadow[v], p, sizeof(int *)  * jbw);
	  else                        ESL_ALLOC (mx->Tkshadow[v],    sizeof(int *)  * jbw);
	  mx->TnrowsA[v] = jbw;
	}
	  }
	  else { /* cp9b->Tvalid[v] is FALSE */
	if(mx->Tkshadow[v] != NULL) free(mx->Tkshadow[v]);
	mx->Tkshadow[v] = NULL;
	mx->TnrowsA[v] = 0;
	  }
	}
  }

  /* reset the pointers, we keep a tally of number of cells
   * we've seen in each matrix (y_cur_size and k_cur_size) as we go,
   * we could precalc it and store it for each v,j, but that
   * would be wasteful, as we'll only use the matrix configured
   * this way once, in a banded CYK run.
   */
  Jy_cur_size = 0;
  Ly_cur_size = 0;
  Ry_cur_size = 0;
  Jk_cur_size = 0;
  Lk_cur_size = 0;
  Rk_cur_size = 0;
  Tk_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] != B_st) {
	  if(mx->Jyshadow[v] != NULL) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Jyshadow[v][jp] = mx->Jyshadow_mem + Jy_cur_size;
	  Jy_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(mx->Lyshadow[v] != NULL) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Lyshadow[v][jp] = mx->Lyshadow_mem + Ly_cur_size;
	  Ly_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(mx->Ryshadow[v] != NULL) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Ryshadow[v][jp] = mx->Ryshadow_mem + Ry_cur_size;
	  Ry_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	}
	else { /* cm->sttype[v] == B_st */
	  if(mx->Jkshadow[v] != NULL) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Jkshadow[v][jp] = mx->Jkshadow_mem + Jk_cur_size;
	  Jk_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(mx->Lkshadow[v] != NULL) {
	assert(mx->Lkmode[v] != NULL);
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Lkshadow[v][jp] = mx->Lkshadow_mem + Lk_cur_size;
	  mx->Lkmode[v][jp]   = mx->Lkmode_mem   + Lk_cur_size;
	  Lk_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(mx->Rkshadow[v] != NULL) {
	assert(mx->Rkmode[v] != NULL);
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Rkshadow[v][jp] = mx->Rkshadow_mem + Rk_cur_size;
	  mx->Rkmode[v][jp]   = mx->Rkmode_mem   + Rk_cur_size;
	  Rk_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(mx->Tkshadow[v] != NULL) {
	for(jp = 0; jp <= (cp9b->jmax[v] - cp9b->jmin[v]); jp++) {
	  mx->Tkshadow[v][jp] = mx->Tkshadow_mem + Tk_cur_size;
	  Tk_cur_size        += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	}
  }
  /*printf("Jy ncells %10" PRId64 " %10" PRId64 "\n", Jy_cur_size, mx->Jy_ncells_valid);
	printf("Ly ncells %10" PRId64 " %10" PRId64 "\n", Ly_cur_size, mx->Ly_ncells_valid);
	printf("Ry ncells %10" PRId64 " %10" PRId64 "\n", Ry_cur_size, mx->Ry_ncells_valid);
	printf("Jk ncells %10" PRId64 " %10" PRId64 "\n", Jk_cur_size, mx->Jk_ncells_valid);
	printf("Lk ncells %10" PRId64 " %10" PRId64 "\n", Lk_cur_size, mx->Lk_ncells_valid);
	printf("Rk ncells %10" PRId64 " %10" PRId64 "\n", Rk_cur_size, mx->Rk_ncells_valid);
	printf("Tk ncells %10" PRId64 " %10" PRId64 "\n", Tk_cur_size, mx->Tk_ncells_valid);*/
  assert(Jy_cur_size == mx->Jy_ncells_valid);
  assert(Ly_cur_size == mx->Ly_ncells_valid);
  assert(Ry_cur_size == mx->Ry_ncells_valid);
  assert(Jk_cur_size == mx->Jk_ncells_valid);
  assert(Lk_cur_size == mx->Lk_ncells_valid);
  assert(Rk_cur_size == mx->Rk_ncells_valid);
  assert(Tk_cur_size == mx->Tk_ncells_valid);
  ESL_DASSERT1((Jy_cur_size == mx->Jy_ncells_valid));
  ESL_DASSERT1((Ly_cur_size == mx->Ly_ncells_valid));
  ESL_DASSERT1((Ry_cur_size == mx->Ry_ncells_valid));
  ESL_DASSERT1((Jk_cur_size == mx->Jk_ncells_valid));
  ESL_DASSERT1((Lk_cur_size == mx->Lk_ncells_valid));
  ESL_DASSERT1((Rk_cur_size == mx->Rk_ncells_valid));
  ESL_DASSERT1((Tk_cur_size == mx->Tk_ncells_valid));

  mx->cp9b = cp9b; /* just a reference */

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_hb_shadow_mx_Destroy()
 * Synopsis:  Frees a DP matrix.
 * Incept:    EPN, Wed Sep  7 13:28:55 2011
 *
 * Purpose:   Frees a <CM_TR_HB_SHADOW_MX>.
 *
 * Returns:   (void)
 */
void
cm_tr_hb_shadow_mx_Destroy(CM_TR_HB_SHADOW_MX *mx)
{
  if (mx == NULL) return;
  int v;

  if (mx->Jyshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Jyshadow[v] != NULL) free(mx->Jyshadow[v]);
  }
  free(mx->Jyshadow);

  if (mx->Lyshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lyshadow[v] != NULL) free(mx->Lyshadow[v]);
  }
  free(mx->Lyshadow);

  if (mx->Ryshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Ryshadow[v] != NULL) free(mx->Ryshadow[v]);
  }
  free(mx->Ryshadow);

  if (mx->Jkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Jkshadow[v] != NULL) free(mx->Jkshadow[v]);
  }
  free(mx->Jkshadow);

  if (mx->Lkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lkshadow[v] != NULL) free(mx->Lkshadow[v]);
  }
  free(mx->Lkshadow);

  if (mx->Rkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Rkshadow[v] != NULL) free(mx->Rkshadow[v]);
  }
  free(mx->Rkshadow);

  if (mx->Tkshadow      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Tkshadow[v] != NULL) free(mx->Tkshadow[v]);
  }
  free(mx->Tkshadow);

  if (mx->Lkmode      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Lkmode[v] != NULL) free(mx->Lkmode[v]);
  }
  free(mx->Lkmode);

  if (mx->Rkmode      != NULL) {
	for (v = 0; v < mx->M; v++)
	  if(mx->Rkmode[v] != NULL) free(mx->Rkmode[v]);
  }
  free(mx->Rkmode);

  if (mx->JnrowsA  != NULL)      free(mx->JnrowsA);
  if (mx->LnrowsA  != NULL)      free(mx->LnrowsA);
  if (mx->RnrowsA  != NULL)      free(mx->RnrowsA);
  if (mx->TnrowsA  != NULL)      free(mx->TnrowsA);
  if (mx->Jyshadow_mem  != NULL)  free(mx->Jyshadow_mem);
  if (mx->Lyshadow_mem  != NULL)  free(mx->Lyshadow_mem);
  if (mx->Ryshadow_mem  != NULL)  free(mx->Ryshadow_mem);
  if (mx->Jkshadow_mem  != NULL)  free(mx->Jkshadow_mem);
  if (mx->Lkshadow_mem  != NULL)  free(mx->Lkshadow_mem);
  if (mx->Rkshadow_mem  != NULL)  free(mx->Rkshadow_mem);
  if (mx->Tkshadow_mem  != NULL)  free(mx->Tkshadow_mem);
  if (mx->Lkmode_mem    != NULL)  free(mx->Lkmode_mem);
  if (mx->Rkmode_mem    != NULL)  free(mx->Rkmode_mem);
  free(mx);
  return;
}

/* Function:  cm_tr_hb_shadow_mx_Dump()
 * Synopsis:  Dump a DP matrix to a stream, for diagnostics.
 * Incept:    EPN, Wed Sep  7 13:29:01 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_hb_shadow_mx_Dump(FILE *ofp, CM_t *cm, CM_TR_HB_SHADOW_MX *mx, char mode, int print_mx)
{
  int status;
  int v, jp, j, dp, d;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "B: %d\n", mx->B);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "Jy_ncells_alloc: %" PRId64 "\nJy_ncells_valid: %" PRId64 "\n", mx->Jy_ncells_alloc, mx->Jy_ncells_valid);
  fprintf(ofp, "Ly_ncells_alloc: %" PRId64 "\nLy_ncells_valid: %" PRId64 "\n", mx->Ly_ncells_alloc, mx->Ly_ncells_valid);
  fprintf(ofp, "Ry_ncells_alloc: %" PRId64 "\nRy_ncells_valid: %" PRId64 "\n", mx->Ry_ncells_alloc, mx->Ry_ncells_valid);
  fprintf(ofp, "Jk_ncells_alloc: %" PRId64 "\nJk_ncells_valid: %" PRId64 "\n", mx->Jk_ncells_alloc, mx->Jk_ncells_valid);
  fprintf(ofp, "Lk_ncells_alloc: %" PRId64 "\nLk_ncells_valid: %" PRId64 "\n", mx->Lk_ncells_alloc, mx->Lk_ncells_valid);
  fprintf(ofp, "Rk_ncells_alloc: %" PRId64 "\nRk_ncells_valid: %" PRId64 "\n", mx->Rk_ncells_alloc, mx->Rk_ncells_valid);
  fprintf(ofp, "Tk_ncells_alloc: %" PRId64 "\nTk_ncells_valid: %" PRId64 "\n", mx->Tk_ncells_alloc, mx->Tk_ncells_valid);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  if(print_mx) {
	/* yshadow/kshadow matrix data */
	for (v = 0; v < mx->M; v++) {
	  if(cm->sttype[v] == B_st) {
	for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	  j = jp + mx->cp9b->jmin[v];
	  for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	    d = dp + mx->cp9b->hdmin[v][jp];
	    if(mx->Jkshadow[v])           fprintf(ofp, "Jkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Jkshadow[v][jp][dp]);
	    if(mx->Lkshadow[v] && fill_L) fprintf(ofp, "Lkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Lkshadow[v][jp][dp]);
	    if(mx->Rkshadow[v] && fill_R) fprintf(ofp, "Rkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Rkshadow[v][jp][dp]);
	    if(mx->Tkshadow[v] && fill_T) fprintf(ofp, "Tkshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Tkshadow[v][jp][dp]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	  else {
	for(jp = 0; jp <= mx->cp9b->jmax[v] - mx->cp9b->jmin[v]; jp++) {
	  j = jp + mx->cp9b->jmin[v];
	  for(dp = 0; dp <= mx->cp9b->hdmax[v][jp] - mx->cp9b->hdmin[v][jp]; dp++) {
	    d = dp + mx->cp9b->hdmin[v][jp];
	    if(mx->Jyshadow[v])           fprintf(ofp, "Jyshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Jyshadow[v][jp][dp]);
	    if(mx->Lyshadow[v] && fill_L) fprintf(ofp, "Lyshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Lyshadow[v][jp][dp]);
	    if(mx->Ryshadow[v] && fill_R) fprintf(ofp, "Ryshad[v:%5d][j:%5d][d:%5d] %8d\n", v, j, d, mx->Ryshadow[v][jp][dp]);
	  }
	  fprintf(ofp, "\n");
	}
	fprintf(ofp, "\n\n");
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_tr_hb_shadow_mx_SizeNeeded()
 * Incept:    EPN, Wed Sep  7 15:15:04 2011
 *
 * Purpose:   Given a model, and a CP9_bands_t object
 *            with pre-calced bands for a target, determine the number
 *            of cells and total size in Mb required for the matrix
 *            for the target given the bands.
 *
 *            Return number of {J,L,R}yshadow (char) cells required in
 *            <ret_{J,L,R}ny_cells> and number of {J,L,R,T}kshadow (int) cells
 *            required in <ret_{J,L,R,T}nk_cells) and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm               - the CM the matrix is for
 *            errbuf           - char buffer for reporting errors
 *            cp9b             - the bands for the current target sequence
 *            ret_Jny_cells - RETURN: number of required char cells for J (Jyshadow)
 *            ret_Lny_cells - RETURN: number of required char cells for L (Lyshadow)
 *            ret_Rny_cells - RETURN: number of required char cells for R (Ryshadow)
 *            ret_Jnk_cells  - RETURN: number of required int  cells for J (Jkshadow)
 *            ret_Lnk_cells  - RETURN: number of required int  cells for L (Lkshadow)
 *            ret_Rnk_cells  - RETURN: number of required int  cells for R (Rkshadow)
 *            ret_Tnk_cells  - RETURN: number of required int  cells for T (Tkshadow)
 *            ret_Mb           - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_hb_shadow_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int64_t *ret_Jny_cells, int64_t *ret_Lny_cells, int64_t *ret_Rny_cells,
			      int64_t *ret_Jnk_cells, int64_t *ret_Lnk_cells, int64_t *ret_Rnk_cells, int64_t *ret_Tnk_cells, float *ret_Mb)
{
  int     v, jp;
  int64_t Jy_ncells;
  int64_t Ly_ncells;
  int64_t Ry_ncells;
  int64_t Jk_ncells;
  int64_t Lk_ncells;
  int64_t Rk_ncells;
  int64_t Tk_ncells;
  int     jbw;
  float   Mb_needed;

  /* contract check */
  if(cp9b == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cm_tr_hb_shadow_mx_SizeNeeded() entered with cp9b == NULL.\n");

  Jy_ncells = 0;
  Ly_ncells = 0;
  Ry_ncells = 0;
  Jk_ncells = 0;
  Lk_ncells = 0;
  Rk_ncells = 0;
  Tk_ncells = 0;
  Mb_needed = (float)
	(sizeof(CM_TR_HB_SHADOW_MX) +
	 (3 * (cp9b->cm_M) * sizeof(char **)) + /* mx->{J,L,R}yshadow[] ptrs */
	 (4 * (cp9b->cm_M) * sizeof(int **))  + /* mx->{J,L,R,T}kshadow[] ptrs */
	 (4 * (cp9b->cm_M) * sizeof(int)));     /* mx->{J,L,R,T}nrowsA */

  for(v = 0; v < cp9b->cm_M; v++) {
	jbw = cp9b->jmax[v] - cp9b->jmin[v];
	if(cm->sttype[v] == B_st) {
	  if(cp9b->Jvalid[v]) {
	Mb_needed += (float) (sizeof(int *) * (jbw+1)); /* mx->Jkshadow[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Jk_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(cp9b->Lvalid[v]) {
	Mb_needed += (float) (sizeof(int *) * (jbw+1));  /* mx->Lkshadow[v][] ptrs */
	Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->Lkmode[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Lk_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(cp9b->Rvalid[v]) {
	Mb_needed += (float) (sizeof(int *) * (jbw+1));  /* mx->Rkshadow[v][] ptrs */
	Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->Rkmode[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Rk_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(cp9b->Tvalid[v]) {
	Mb_needed += (float) (sizeof(int *) * (jbw+1)); /* mx->Tkshadow[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Tk_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	}
	else { /* not a B state */
	  if(cp9b->Jvalid[v]) {
	Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->Jyshadow[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Jy_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(cp9b->Lvalid[v]) {
	Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->Lyshadow[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Ly_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	  if(cp9b->Rvalid[v]) {
	Mb_needed += (float) (sizeof(char *) * (jbw+1)); /* mx->Ryshadow[v][] ptrs */
	for(jp = 0; jp <= jbw; jp++) {
	  Ry_ncells += cp9b->hdmax[v][jp] - cp9b->hdmin[v][jp] + 1;
	}
	  }
	}
  }
  Mb_needed += sizeof(int)  * Jk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Lk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Rk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(int)  * Tk_ncells; /* mx->Jkshadow_mem */
  Mb_needed += sizeof(char) * Lk_ncells; /* mx->Jkmode_mem   */
  Mb_needed += sizeof(char) * Rk_ncells; /* mx->Jkmode_mem   */
  Mb_needed += sizeof(char) * Jy_ncells; /* mx->Jyshadow_mem */
  Mb_needed += sizeof(char) * Ly_ncells; /* mx->Jyshadow_mem */
  Mb_needed += sizeof(char) * Ry_ncells; /* mx->Jyshadow_mem */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_Jny_cells != NULL) *ret_Jny_cells = Jy_ncells;
  if(ret_Lny_cells != NULL) *ret_Lny_cells = Ly_ncells;
  if(ret_Rny_cells != NULL) *ret_Rny_cells = Ry_ncells;
  if(ret_Jnk_cells != NULL) *ret_Jnk_cells  = Jk_ncells;
  if(ret_Lnk_cells != NULL) *ret_Lnk_cells  = Lk_ncells;
  if(ret_Rnk_cells != NULL) *ret_Rnk_cells  = Rk_ncells;
  if(ret_Tnk_cells != NULL) *ret_Tnk_cells  = Tk_ncells;
  if(ret_Mb        != NULL) *ret_Mb           = Mb_needed;
  return eslOK;
}

/*****************************************************************
 *   9. CM_EMIT_MX data structure functions,
 *      matrix of float log posterior probabilities of emitted
 *      residues. Used for optimal accuracy alignment and posterior
 *      annotation of alignments.
 *****************************************************************/

/* Function:  cm_emit_mx_Create()
 * Incept:    EPN, Fri Sep 30 14:17:49 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_EMIT_MX> for a CM.
 *
 * Args:      cm:      the model
 *
 * Returns:   a pointer to the new <CM_EMIT_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_EMIT_MX *
cm_emit_mx_Create(CM_t *cm)
{
  int         status;
  CM_EMIT_MX *mx = NULL;
  int         v, l_n, r_n;
  int         allocL = 2; /* this corresponds to a sequence of length 1; mx[v][0] is always IMPOSSIBLE, mx[v][1] is residue 1 */
  int         M = cm->M;
  int         l_nstates_valid;  /* num states for which mx->l_pp[v] != NULL */
  int         r_nstates_valid;  /* num states for which mx->r_pp[v] != NULL */

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_EMIT_MX));
  mx->l_pp     = NULL;
  mx->l_pp_mem = NULL;
  mx->r_pp     = NULL;
  mx->r_pp_mem = NULL;

  /* level 2: row (state) pointers, 0.1..M, go all the way to M
   */
  ESL_ALLOC(mx->l_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->r_pp,  sizeof(float *) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 2 cells per state, for i = 0 and 1 */
  /* first count the number of valid emitting states, left and right */
  l_nstates_valid = 0;
  r_nstates_valid = 0;
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) l_nstates_valid++;
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) r_nstates_valid++;
  }
  l_nstates_valid++; /* add 1 for the special left emitting EL state, cm->M */

  ESL_ALLOC(mx->l_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->r_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));

  l_n = 0;
  r_n = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->l_pp[v] = mx->l_pp_mem + l_n * (allocL);
	  l_n++;
	}
	else {
	  mx->l_pp[v] = NULL;
	}

	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->r_pp[v] = mx->r_pp_mem + r_n * (allocL);
	  r_n++;
	}
	else {
	  mx->r_pp[v] = NULL;
	}
  }

  /* EL row */
  mx->l_pp[M] = mx->l_pp_mem + l_n * (allocL);
  mx->r_pp[M] = NULL;

  /* finally allocate the sum vector */
  ESL_ALLOC(mx->sum, sizeof(float) * allocL);

  mx->M               = M;
  mx->l_ncells_valid  = 0;
  mx->l_ncells_alloc  = (l_nstates_valid) * (allocL);
  mx->r_ncells_valid  = 0;
  mx->r_ncells_alloc  = (r_nstates_valid) * (allocL);
  mx->L               = allocL-1; /* allocL = 2 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_EMIT_MX)                      +
	 (mx->M+1)    * sizeof(float *)          +  /* mx->l_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)          +  /* mx->r_pp[] ptrs */
	 mx->l_ncells_alloc * sizeof(float)      +  /* mx->l_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)      +  /* mx->r_pp_mem */
	 (mx->L+1) * sizeof(float));                /* mx->sum */

  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_emit_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_emit_mx_GrowTo()
 * Incept:    EPN, Fri Sep 30 14:35:21 2011
 *
 * Purpose: Assures that a CM_EMIT_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, reallocating memory as necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full EL row for the matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_emit_mx_GrowTo(CM_t *cm, CM_EMIT_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v;
  int64_t l_cur_size = 0;
  int64_t r_cur_size = 0;
  int64_t l_ncells;
  int64_t r_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     l_realloced;   /* did we reallocate mx->l_pp_mem? */
  int     r_realloced;   /* did we reallocate mx->r_pp_mem? */
  int     sum_realloced; /* did we reallocate mx->sum?      */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_emit_mx_SizeNeeded(cm, errbuf, L, &l_ncells, &r_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded emit matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded emit mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full matrix? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  l_realloced = FALSE;
  r_realloced = FALSE;
  sum_realloced = FALSE;
  if (l_ncells > mx->l_ncells_alloc) {
	  ESL_RALLOC(mx->l_pp_mem, p, sizeof(float) * l_ncells);
	  mx->l_ncells_alloc = l_ncells;
	  l_realloced = TRUE;
  }
  if (r_ncells > mx->r_ncells_alloc) {
	  ESL_RALLOC(mx->r_pp_mem, p, sizeof(float) * r_ncells);
	  mx->r_ncells_alloc = r_ncells;
	  r_realloced = TRUE;
  }
  if (L > mx->L) {
	ESL_RALLOC(mx->sum, p, sizeof(float) * (L+1));
	sum_realloced = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! l_realloced) {
	Mb_alloc -= (float) (sizeof(float) * l_ncells);
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc);
  }
  if(! r_realloced) {
	Mb_alloc -= (float) (sizeof(float) * r_ncells);
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc);
  }
  if(! sum_realloced) {
	Mb_alloc -= (float) (sizeof(float) * (L+1));
	Mb_alloc += (float) (sizeof(float) * (mx->L+1));
  }
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->l_ncells_valid = l_ncells;
  mx->r_ncells_valid = r_ncells;

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  l_cur_size = 0;
  r_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->l_pp[v] = mx->l_pp_mem + l_cur_size;
	  l_cur_size += L+1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->r_pp[v] = mx->r_pp_mem + r_cur_size;
	  r_cur_size += L+1;
	}
  }
  if(have_el) {
	mx->l_pp[mx->M] = mx->l_pp_mem + l_cur_size;
	l_cur_size += L+1;
  }
  else {
	mx->l_pp[mx->M] = NULL;
  }
  mx->r_pp[mx->M] = NULL;

#if eslDEBUGLEVEL >= 1
  printf("l_ncells %10" PRId64 " %10" PRId64 "\n", l_cur_size, mx->l_ncells_valid);
  printf("r_ncells %10" PRId64 " %10" PRId64 "\n", r_cur_size, mx->r_ncells_valid);
#endif
  assert(l_cur_size == mx->l_ncells_valid);
  assert(r_cur_size == mx->r_ncells_valid);
  ESL_DASSERT1((l_cur_size == mx->l_ncells_valid));
  ESL_DASSERT1((r_cur_size == mx->r_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_emit_mx_Destroy()
 * Synopsis:  Frees a CM_EMIT_MX.
 * Incept:    EPN, Fri Sep 30 14:55:30 2011
 *
 * Purpose:   Frees a <CM_EMIT_MX>.
 *
 * Returns:   (void)
 */
void
cm_emit_mx_Destroy(CM_EMIT_MX *mx)
{
  if (mx == NULL) return;

  if (mx->l_pp     != NULL) free(mx->l_pp);
  if (mx->r_pp     != NULL) free(mx->r_pp);
  if (mx->l_pp_mem != NULL) free(mx->l_pp_mem);
  if (mx->r_pp_mem != NULL) free(mx->r_pp_mem);
  if (mx->sum      != NULL) free(mx->sum);

  free(mx);
  return;
}

/* Function:  cm_emit_mx_Dump()
 * Synopsis:  Dump a emit matrix to a stream, for diagnostics.
 * Incept:    EPN, Fri Sep 30 15:01:06 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_emit_mx_Dump(FILE *ofp, CM_t *cm, CM_EMIT_MX *mx, int print_mx)
{
  int v, i;

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "l_ncells_alloc: %" PRId64 "\nl_ncells_valid: %" PRId64 "\n", mx->l_ncells_alloc, mx->l_ncells_valid);
  fprintf(ofp, "r_ncells_alloc: %" PRId64 "\nr_ncells_valid: %" PRId64 "\n", mx->r_ncells_alloc, mx->r_ncells_valid);

  /* l_pp and r_pp matrix data */
  if(print_mx) {
	for (v = 0; v <= mx->M; v++) {
	  for(i = 0; i <= mx->L; i++) {
	if(mx->l_pp[v]) fprintf(ofp, "l_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->l_pp[v][i]), mx->l_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	if(mx->r_pp[v]) fprintf(ofp, "r_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->r_pp[v][i]), mx->r_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	  }
	  fprintf(ofp, "\n");
	}
  }
  return eslOK;
}

/* Function:  cm_emit_mx_SizeNeeded()
 * Incept:    EPN, Fri Sep 30 15:05:04 2011
 *
 * Purpose: Given a model and sequence length, determine the number of
 *            cells and total size in Mb required in a CM_EMIT_MX for
 *            the target sequence.
 *
 *            Return number of l_pp, r_pp cells required in
 *            <ret_l_ncells> and <ret_r_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            L            - the length of the current target sequence we're aligning
 *            ret_l_ncells - RETURN: number of matrix cells required
 *            ret_r_ncells - RETURN: number of matrix cells required
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_emit_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_l_ncells, int64_t *ret_r_ncells, float *ret_Mb)
{
  int     v;
  int64_t l_ncells;
  int64_t r_ncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  l_ncells = 0;
  r_ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_EMIT_MX) +
	 (cm->M+1) * sizeof(float *) + /* mx->l_pp ptrs */
	 (cm->M+1) * sizeof(float *)); /* mx->r_pp ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  l_ncells += L+1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  r_ncells += L+1;
	}
  }
  if(have_el) l_ncells += L+1; /* space for EL deck */

  Mb_needed += sizeof(float) * (l_ncells + r_ncells + (L+1)); /* mx->l_pp_mem, mx->r_pp_mem, mx->sum */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_l_ncells != NULL) *ret_l_ncells = l_ncells;
  if(ret_r_ncells != NULL) *ret_r_ncells = r_ncells;
  if(ret_Mb       != NULL) *ret_Mb      = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *  10. CM_TR_EMIT_MX data structure functions, matrix of float log
 *      posterior probabilities of emitted residues in truncated
 *      alignments. Used for optimal accuracy alignment and posterior
 *      annotation of alignments.
 *****************************************************************/

/* Function:  cm_tr_emit_mx_Create()
 * Incept:    EPN, Thu Oct  6 14:45:32 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_EMIT_MX> for a CM.
 *
 * Args:      cm: the model
 *
 * Returns:   a pointer to the new <CM_TR_EMIT_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_EMIT_MX *
cm_tr_emit_mx_Create(CM_t *cm)
{
  int            status;
  CM_TR_EMIT_MX *mx = NULL;
  int            v, l_n, r_n;
  int            allocL = 2; /* this corresponds to a sequence of length 1; mx[v][0] is always IMPOSSIBLE, mx[v][1] is residue 1 */
  int            M = cm->M;
  int            l_nstates_valid;  /* num states for which mx->Jl_pp[v] and mx->Ll_pp != NULL */
  int            r_nstates_valid;  /* num states for which mx->Jr_pp[v] and mx->Rr_pp != NULL */

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_EMIT_MX));
  mx->Jl_pp     = NULL;
  mx->Jl_pp_mem = NULL;
  mx->Ll_pp     = NULL;
  mx->Ll_pp_mem = NULL;
  mx->Jr_pp     = NULL;
  mx->Jr_pp_mem = NULL;
  mx->Rr_pp     = NULL;
  mx->Rr_pp_mem = NULL;

  /* level 2: row (state) pointers, 0.1..M, go all the way to M
   */
  ESL_ALLOC(mx->Jl_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Ll_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Jr_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Rr_pp,  sizeof(float *) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 2 cells per state, for i = 0 and 1 */
  /* first count the number of valid emitting states, left and right */
  l_nstates_valid = 0;
  r_nstates_valid = 0;
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) l_nstates_valid++;
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) r_nstates_valid++;
  }
  l_nstates_valid++; /* add 1 for the EL state, cm->M */
  r_nstates_valid++; /* add 1 for the EL state, cm->M */

  ESL_ALLOC(mx->Jl_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Ll_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Jr_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Rr_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));

  l_n = 0;
  r_n = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->Jl_pp[v] = mx->Jl_pp_mem + l_n * (allocL);
	  mx->Ll_pp[v] = mx->Ll_pp_mem + l_n * (allocL);
	  l_n++;
	}
	else {
	  mx->Jl_pp[v] = NULL;
	  mx->Ll_pp[v] = NULL;
	}

	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->Jr_pp[v] = mx->Jr_pp_mem + r_n * (allocL);
	  mx->Rr_pp[v] = mx->Rr_pp_mem + r_n * (allocL);
	  r_n++;
	}
	else {
	  mx->Jr_pp[v] = NULL;
	  mx->Rr_pp[v] = NULL;
	}
  }

  /* setup EL row, invalid in Jr */
  mx->Jl_pp[M] = mx->Jl_pp_mem + l_n * (allocL);
  mx->Ll_pp[M] = mx->Ll_pp_mem + l_n * (allocL);
  mx->Rr_pp[M] = mx->Rr_pp_mem + r_n * (allocL);

  mx->Jr_pp[M] = NULL;

  /* finally allocate the sum vector */
  ESL_ALLOC(mx->sum, sizeof(float) * allocL);

  mx->M                = M;
  mx->l_ncells_valid  = 0;
  mx->l_ncells_alloc  = (l_nstates_valid) * (allocL);
  mx->r_ncells_valid  = 0;
  mx->r_ncells_alloc  = (r_nstates_valid) * (allocL);
  mx->L                = allocL-1; /* allocL = 2 */

  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_EMIT_MX)                     +
	 (mx->M+1)    * sizeof(float *)         +  /* mx->Jl_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)         +  /* mx->Ll_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)         +  /* mx->Jr_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)         +  /* mx->Rr_pp[] ptrs */
	 mx->l_ncells_alloc * sizeof(float)     +  /* mx->Jl_pp_mem */
	 mx->l_ncells_alloc * sizeof(float)     +  /* mx->Ll_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)     +  /* mx->Jr_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)     +  /* mx->Rr_pp_mem */
	 (mx->L+1) * sizeof(float));               /* mx->sum */

  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_emit_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_emit_mx_GrowTo()
 * Incept:    EPN, Fri Oct  7 05:42:51 2011
 *
 * Purpose: Assures that a CM_TR_EMIT_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, reallocating memory as necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full EL row for the matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 *            We could save a bit of space here by demanding that we
 *            know the marginal alignment mode when entering this
 *            function and only allocating cells that we will use. For
 *            example, if we know we're in Left marginal mode we don't
 *            use the Rr_pp matrix at all, and so don't need to
 *            allocate any cells for it. However, if we did this, a
 *            subsequent alignment that did use Right marginal mode
 *            would need to reallocate the Rr_pp matrix. Since these
 *            matrices are only 2D (much smaller than many of the 3D
 *            matrices used during alignment) we don't care so much
 *            about space here and so we always allocate Jl_pp, Ll_pp,
 *            Jr_pp and Rr_pp to full size even though we rarely need
 *            all of them.
 *
 *            One wrinkle with this strategy is that it forces us to
 *            allocate space for Ll_pp[cm->M] for local end alignment
 *            in Left marginal mode. These cells will never be used
 *            but are allocated for because the Jl_pp[cm->M] deck is
 *            used, and we only have a single <l_ncells_allocated>
 *            and <l_ncells_valid> count.
 *
 * Args:      cm     - the CM the matrix is for
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_emit_mx_GrowTo(CM_t *cm, CM_TR_EMIT_MX *mx, char *errbuf, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v;
  int64_t l_cur_size = 0;
  int64_t r_cur_size = 0;
  int64_t l_ncells;
  int64_t r_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     l_realloced;   /* did we reallocate mx->Jl_pp_mem and mx->Ll_pp_mem? */
  int     r_realloced;   /* did we reallocate mx->Jr_pp_mem and mx->Rr_pp_mem? */
  int     sum_realloced; /* did we reallocate mx->sum?      */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_tr_emit_mx_SizeNeeded(cm, errbuf, L, &l_ncells, &r_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("Non-banded truncated emit matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("Non-banded truncated emit matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested non-banded truncated emit mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full matrix? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  l_realloced = FALSE;
  r_realloced = FALSE;
  sum_realloced = FALSE;
  if (l_ncells > mx->l_ncells_alloc) {
	  ESL_RALLOC(mx->Jl_pp_mem, p, sizeof(float) * l_ncells);
	  ESL_RALLOC(mx->Ll_pp_mem, p, sizeof(float) * l_ncells);
	  mx->l_ncells_alloc = l_ncells;
	  l_realloced = TRUE;
  }
  if (r_ncells > mx->r_ncells_alloc) {
	  ESL_RALLOC(mx->Jr_pp_mem, p, sizeof(float) * r_ncells);
	  ESL_RALLOC(mx->Rr_pp_mem, p, sizeof(float) * r_ncells);
	  mx->r_ncells_alloc = r_ncells;
	  r_realloced = TRUE;
  }
  if (L > mx->L) {
	ESL_RALLOC(mx->sum, p, sizeof(float) * (L+1));
	sum_realloced = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! l_realloced) {
	Mb_alloc -= (float) (sizeof(float) * l_ncells);           /* Jl_pp */
	Mb_alloc -= (float) (sizeof(float) * l_ncells);           /* Ll_pp */
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc); /* Jl_pp */
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc); /* Ll_pp */
  }
  if(! r_realloced) {
	Mb_alloc -= (float) (sizeof(float) * r_ncells);           /* Jr_pp */
	Mb_alloc -= (float) (sizeof(float) * r_ncells);           /* Rr_pp */
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc); /* Jr_pp */
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc); /* Rr_pp */
  }
  if(! sum_realloced) {
	Mb_alloc -= (float) (sizeof(float) * (L+1));
	Mb_alloc += (float) (sizeof(float) * (mx->L+1));
  }
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->l_ncells_valid = l_ncells;
  mx->r_ncells_valid = r_ncells;

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  l_cur_size = 0;
  r_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->Jl_pp[v] = mx->Jl_pp_mem + l_cur_size;
	  mx->Ll_pp[v] = mx->Ll_pp_mem + l_cur_size;
	  l_cur_size += L+1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->Jr_pp[v] = mx->Jr_pp_mem + r_cur_size;
	  mx->Rr_pp[v] = mx->Rr_pp_mem + r_cur_size;
	  r_cur_size += L+1;
	}
  }
  if(have_el) {
	mx->Jl_pp[mx->M] = mx->Jl_pp_mem + l_cur_size;
	mx->Ll_pp[mx->M] = mx->Ll_pp_mem + l_cur_size;
	mx->Rr_pp[mx->M] = mx->Rr_pp_mem + r_cur_size;
	l_cur_size += L+1;
	r_cur_size += L+1;
  }
  else {
	mx->Jl_pp[mx->M] = NULL;
	mx->Ll_pp[mx->M] = NULL;
	mx->Rr_pp[mx->M] = NULL;
  }
  mx->Jr_pp[mx->M] = NULL;

#if eslDEBUGLEVEL >= 1
  printf("l_ncells %10" PRId64 " %10" PRId64 "\n", l_cur_size, mx->l_ncells_valid);
  printf("r_ncells %10" PRId64 " %10" PRId64 "\n", r_cur_size, mx->r_ncells_valid);
#endif
  assert(l_cur_size == mx->l_ncells_valid);
  assert(r_cur_size == mx->r_ncells_valid);
  ESL_DASSERT1((l_cur_size == mx->l_ncells_valid));
  ESL_DASSERT1((r_cur_size == mx->r_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_emit_mx_Destroy()
 * Synopsis:  Frees a CM_TR_EMIT_MX.
 * Incept:    EPN, Fri Oct  7 05:51:14 2011
 *
 * Purpose:   Frees a <CM_TR_EMIT_MX>.
 *
 * Returns:   (void)
 */
void
cm_tr_emit_mx_Destroy(CM_TR_EMIT_MX *mx)
{
  if (mx == NULL) return;

  if (mx->Jl_pp     != NULL) free(mx->Jl_pp);
  if (mx->Ll_pp     != NULL) free(mx->Ll_pp);
  if (mx->Jr_pp     != NULL) free(mx->Jr_pp);
  if (mx->Rr_pp     != NULL) free(mx->Rr_pp);
  if (mx->Jl_pp_mem != NULL) free(mx->Jl_pp_mem);
  if (mx->Ll_pp_mem != NULL) free(mx->Ll_pp_mem);
  if (mx->Jr_pp_mem != NULL) free(mx->Jr_pp_mem);
  if (mx->Rr_pp_mem != NULL) free(mx->Rr_pp_mem);
  if (mx->sum       != NULL) free(mx->sum);

  free(mx);
  return;
}

/* Function:  cm_tr_emit_mx_Dump()
 * Synopsis:  Dump a truncated emit matrix to a stream, for diagnostics.
 * Incept:    EPN, Fri Oct  7 05:52:13 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_emit_mx_Dump(FILE *ofp, CM_t *cm, CM_TR_EMIT_MX *mx, char mode, int print_mx)
{
  int status;
  int v, i;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "l_ncells_alloc: %" PRId64 "\nl_ncells_valid: %" PRId64 "\n", mx->l_ncells_alloc, mx->l_ncells_valid);
  fprintf(ofp, "r_ncells_alloc: %" PRId64 "\nr_ncells_valid: %" PRId64 "\n", mx->r_ncells_alloc, mx->r_ncells_valid);
  fprintf(ofp, "mode: %d\n", mode);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  if(print_mx) {
	/* l_pp and r_pp matrix data */
	for (v = 0; v < mx->M; v++) {
	  for(i = 0; i <= mx->L; i++) {
	if(mx->Jl_pp[v])           fprintf(ofp, "Jl_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Jl_pp[v][i]), mx->Jl_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	if(mx->Ll_pp[v] && fill_L) fprintf(ofp, "Ll_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Ll_pp[v][i]), mx->Ll_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	if(mx->Jr_pp[v])           fprintf(ofp, "Jr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Jr_pp[v][i]), mx->Jr_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	if(mx->Rr_pp[v] && fill_R) fprintf(ofp, "Rr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Rr_pp[v][i]), mx->Rr_pp[v][i], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	  }
	  fprintf(ofp, "\n");
	}
	/* EL state */
	for(i = 0; i <= mx->L; i++) {
	  if(mx->Jl_pp[cm->M])           fprintf(ofp, "Jl_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Jl_pp[cm->M][i]), mx->Jl_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	  if(mx->Ll_pp[cm->M] && fill_L) fprintf(ofp, "Ll_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Ll_pp[cm->M][i]), mx->Ll_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	  if(mx->Rr_pp[cm->M] && fill_R) fprintf(ofp, "Rr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Rr_pp[cm->M][i]), mx->Rr_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	}
  }
  return eslOK;
}

/* Function:  cm_tr_emit_mx_SizeNeeded()
 * Incept:    EPN, Fri Oct  7 05:53:30 2011
 *
 * Purpose: Given a model and sequence length, determine the number of
 *            cells and total size in Mb required in a CM_TR_EMIT_MX for
 *            the target sequence.
 *
 *            Return number of l_pp, r_pp cells required in
 *            <ret_l_ncells> and <ret_r_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            L            - the length of the current target sequence we're aligning
 *            ret_l_ncells - RETURN: number of matrix cells required
 *            ret_r_ncells - RETURN: number of matrix cells required
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_emit_mx_SizeNeeded(CM_t *cm, char *errbuf, int L, int64_t *ret_l_ncells, int64_t *ret_r_ncells, float *ret_Mb)
{
  int     v;
  int64_t l_ncells;
  int64_t r_ncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  l_ncells = 0;
  r_ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_EMIT_MX) +
	 (cm->M+1) * sizeof(float *) + /* mx->Jl_pp ptrs */
	 (cm->M+1) * sizeof(float *) + /* mx->Ll_pp ptrs */
	 (cm->M+1) * sizeof(float *) + /* mx->Jr_pp ptrs */
	 (cm->M+1) * sizeof(float *)); /* mx->Rr_pp ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  l_ncells += L+1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  r_ncells += L+1;
	}
  }
  if(have_el) {
	l_ncells += L+1; /* space for EL deck */
	r_ncells += L+1; /* space for EL deck */
  }

  Mb_needed += sizeof(float) * (l_ncells + l_ncells + r_ncells + r_ncells + (L+1));
  /* mx->Jl_pp_mem, mx->Ll_pp_mem, mx->Jr_pp_mem, mx->Rr_pp_mem, mx->sum */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_l_ncells != NULL) *ret_l_ncells = l_ncells;
  if(ret_r_ncells != NULL) *ret_r_ncells = r_ncells;
  if(ret_Mb       != NULL) *ret_Mb       = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *  11. CM_HB_EMIT_MX data structure functions,
 *      matrix of float log posterior probabilities of emitted
 *      residues. Used for optimal accuracy alignment and posterior
 *      annotation of alignments. HMM-banded version.
 *****************************************************************/

/* Function:  cm_hb_emit_mx_Create()
 * Incept:    EPN, Thu Oct  6 06:43:57 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_HB_EMIT_MX> for a CM.
 *
 * Args:      cm:      the model
 *
 * Returns:   a pointer to the new <CM_HB_EMIT_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_HB_EMIT_MX *
cm_hb_emit_mx_Create(CM_t *cm)
{
  int            status;
  CM_HB_EMIT_MX *mx = NULL;
  int            v, l_n, r_n;
  int            allocL = 1; /* this corresponds to a sequence of length 1 */
  int            M = cm->M;
  int            l_nstates_valid;  /* num states for which mx->l_pp[v] != NULL */
  int            r_nstates_valid;  /* num states for which mx->r_pp[v] != NULL */

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_HB_EMIT_MX));
  mx->l_pp     = NULL;
  mx->l_pp_mem = NULL;
  mx->r_pp     = NULL;
  mx->r_pp_mem = NULL;

  /* level 2: row (state) pointers, 0.1..M, go all the way to M
   */
  ESL_ALLOC(mx->l_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->r_pp,  sizeof(float *) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 2 cells per state, for i = 0 and 1 */
  /* first count the number of valid emitting states, left and right */
  l_nstates_valid = 0;
  r_nstates_valid = 0;
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) l_nstates_valid++;
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) r_nstates_valid++;
  }
  l_nstates_valid++; /* add 1 for the special left emitting EL state, cm->M */

  ESL_ALLOC(mx->l_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->r_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));

  l_n = 0;
  r_n = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->l_pp[v] = mx->l_pp_mem + l_n * (allocL);
	  l_n++;
	}
	else {
	  mx->l_pp[v] = NULL;
	}

	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->r_pp[v] = mx->r_pp_mem + r_n * (allocL);
	  r_n++;
	}
	else {
	  mx->r_pp[v] = NULL;
	}
  }

  /* EL row */
  mx->l_pp[M] = mx->l_pp_mem + l_n * (allocL);
  mx->r_pp[M] = NULL;

  /* finally allocate the sum vector */
  ESL_ALLOC(mx->sum, sizeof(float) * allocL);

  mx->M               = M;
  mx->l_ncells_valid  = 0;
  mx->l_ncells_alloc  = (l_nstates_valid) * (allocL);
  mx->r_ncells_valid  = 0;
  mx->r_ncells_alloc  = (r_nstates_valid) * (allocL);
  mx->L               = allocL-1; /* allocL = 2 */
  mx->cp9b            = NULL;
  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_HB_EMIT_MX)                   +
	 (mx->M+1)    * sizeof(float *)          +  /* mx->l_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)          +  /* mx->r_pp[] ptrs */
	 mx->l_ncells_alloc * sizeof(float)      +  /* mx->l_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)      +  /* mx->r_pp_mem */
	 (mx->L+1) * sizeof(float));                /* mx->sum */

  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_hb_emit_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_hb_emit_mx_GrowTo()
 * Incept:    EPN, Thu Oct  6 06:51:57 2011
 *
 * Purpose: Assures that a CM_HB_EMIT_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, given bands in <cp9b>, reallocating memory as
 *            necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL row for the matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            cp9b   - HMM bands for current sequence
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the HMM bands for the target sequence we're growing for
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_hb_emit_mx_GrowTo(CM_t *cm, CM_HB_EMIT_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v;
  int64_t l_cur_size = 0;
  int64_t r_cur_size = 0;
  int64_t l_ncells;
  int64_t r_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     l_realloced;   /* did we reallocate mx->l_pp_mem? */
  int     r_realloced;   /* did we reallocate mx->r_pp_mem? */
  int     sum_realloced; /* did we reallocate mx->sum?      */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_hb_emit_mx_SizeNeeded(cm, errbuf, cp9b, L, &l_ncells, &r_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("HMM banded emit matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("HMM banded emit matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded emit mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full matrix? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  l_realloced = FALSE;
  r_realloced = FALSE;
  sum_realloced = FALSE;
  if (l_ncells > mx->l_ncells_alloc) {
	  ESL_RALLOC(mx->l_pp_mem, p, sizeof(float) * l_ncells);
	  mx->l_ncells_alloc = l_ncells;
	  l_realloced = TRUE;
  }
  if (r_ncells > mx->r_ncells_alloc) {
	  ESL_RALLOC(mx->r_pp_mem, p, sizeof(float) * r_ncells);
	  mx->r_ncells_alloc = r_ncells;
	  r_realloced = TRUE;
  }
  if (L > mx->L) {
	ESL_RALLOC(mx->sum, p, sizeof(float) * (L+1));
	sum_realloced = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! l_realloced) {
	Mb_alloc -= (float) (sizeof(float) * l_ncells);
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc);
  }
  if(! r_realloced) {
	Mb_alloc -= (float) (sizeof(float) * r_ncells);
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc);
  }
  if(! sum_realloced) {
	Mb_alloc -= (float) (sizeof(float) * (L+1));
	Mb_alloc += (float) (sizeof(float) * (mx->L+1));
  }
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->l_ncells_valid = l_ncells;
  mx->r_ncells_valid = r_ncells;

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  l_cur_size = 0;
  r_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->l_pp[v] = mx->l_pp_mem + l_cur_size;
	  if(cp9b->imax[v] >= cp9b->imin[v] && cp9b->imax[v] >= 1) {
	l_cur_size += cp9b->imax[v] - cp9b->imin[v] + 1;
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->r_pp[v] = mx->r_pp_mem + r_cur_size;
	  if(cp9b->jmax[v] >= cp9b->jmin[v] && cp9b->jmax[v] >= 1) {
	r_cur_size += cp9b->jmax[v] - cp9b->jmin[v] + 1;
	  }
	}
  }
  if(have_el) { /* EL state is non-banded */
	mx->l_pp[mx->M] = mx->l_pp_mem + l_cur_size;
	l_cur_size += L+1;
  }
  else {
	mx->l_pp[mx->M] = NULL;
  }
  mx->r_pp[mx->M] = NULL;

#if eslDEBUGLEVEL >= 1
  printf("l_ncells %10" PRId64 " %10" PRId64 "\n", l_cur_size, mx->l_ncells_valid);
  printf("r_ncells %10" PRId64 " %10" PRId64 "\n", r_cur_size, mx->r_ncells_valid);
#endif
  assert(l_cur_size == mx->l_ncells_valid);
  assert(r_cur_size == mx->r_ncells_valid);
  ESL_DASSERT1((l_cur_size == mx->l_ncells_valid));
  ESL_DASSERT1((r_cur_size == mx->r_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;
  mx->cp9b    = cp9b;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hb_emit_mx_Destroy()
 * Synopsis:  Frees a CM_HB_EMIT_MX.
 * Incept:    EPN, Thu Oct  6 09:06:58 2011
 *
 * Purpose:   Frees a CM_HB_EMIT_MX.
 *
 * Returns:   (void)
 */
void
cm_hb_emit_mx_Destroy(CM_HB_EMIT_MX *mx)
{
  if (mx == NULL) return;

  if (mx->l_pp     != NULL) free(mx->l_pp);
  if (mx->r_pp     != NULL) free(mx->r_pp);
  if (mx->l_pp_mem != NULL) free(mx->l_pp_mem);
  if (mx->r_pp_mem != NULL) free(mx->r_pp_mem);
  if (mx->sum      != NULL) free(mx->sum);

  /* don't free cp9b, that's just a reference */
  free(mx);
  return;
}

/* Function:  cm_hb_emit_mx_Dump()
 * Synopsis:  Dump a HMM banded emit matrix to a stream, for diagnostics.
 * Incept:    EPN, Thu Oct  6 09:07:35 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_hb_emit_mx_Dump(FILE *ofp, CM_t *cm, CM_HB_EMIT_MX *mx, int print_mx)
{
  int v, i, j, ip_v, jp_v;

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "l_ncells_alloc: %" PRId64 "\nl_ncells_valid: %" PRId64 "\n", mx->l_ncells_alloc, mx->l_ncells_valid);
  fprintf(ofp, "r_ncells_alloc: %" PRId64 "\nr_ncells_valid: %" PRId64 "\n", mx->r_ncells_alloc, mx->r_ncells_valid);

  if(print_mx) {
	/* l_pp and r_pp matrix data */
	for (v = 0; v < mx->M; v++) {
	  if(mx->l_pp[v]) {
	for(i = mx->cp9b->imin[v]; i <= mx->cp9b->imax[v]; i++) {
	  ip_v = i - mx->cp9b->imin[v];
	  fprintf(ofp, "l_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->l_pp[v][ip_v]), mx->l_pp[v][ip_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  if(mx->r_pp[v]) {
	for(j = mx->cp9b->jmin[v]; j <= mx->cp9b->jmax[v]; j++) {
	  jp_v = j - mx->cp9b->jmin[v];
	  fprintf(ofp, "r_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, j, sreEXP2(mx->r_pp[v][jp_v]), mx->r_pp[v][jp_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  fprintf(ofp, "\n");
	}
	/* EL state */
	for(i = 0; i <= mx->L; i++) {
	  if(mx->l_pp[cm->M]) fprintf(ofp, "l_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->l_pp[cm->M][i]), mx->l_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	}
  }
  return eslOK;
}

/* Function:  cm_hb_emit_mx_SizeNeeded()
 * Incept:    EPN, Thu Oct  6 09:11:15 2011
 *
 * Purpose: Given a model, sequence length, and HMM bands object,
 *            determine the number of cells and total size in Mb
 *            required in a CM_HB_EMIT_MX for the target sequence.
 *
 *            Return number of l_pp, r_pp cells required in
 *            <ret_l_ncells> and <ret_r_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            cp9b         - the HMM bands for this sequence
 *            L            - the length of the current target sequence we're aligning
 *            ret_l_ncells - RETURN: number of matrix cells required
 *            ret_r_ncells - RETURN: number of matrix cells required
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_hb_emit_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int L, int64_t *ret_l_ncells, int64_t *ret_r_ncells, float *ret_Mb)
{
  int     v;
  int64_t l_ncells;
  int64_t r_ncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  l_ncells = 0;
  r_ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_HB_EMIT_MX) +
	 (cm->M+1) * sizeof(float *) + /* mx->l_pp ptrs */
	 (cm->M+1) * sizeof(float *)); /* mx->r_pp ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  l_ncells += cp9b->imax[v] - cp9b->imin[v] + 1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  r_ncells += cp9b->jmax[v] - cp9b->jmin[v] + 1;
	}
  }
  if(have_el) l_ncells += L+1; /* space for EL deck */

  Mb_needed += sizeof(float) * (l_ncells + r_ncells + (L+1)); /* mx->l_pp_mem, mx->r_pp_mem, mx->sum */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_l_ncells != NULL) *ret_l_ncells = l_ncells;
  if(ret_r_ncells != NULL) *ret_r_ncells = r_ncells;
  if(ret_Mb       != NULL) *ret_Mb      = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *  12. CM_TR_HB_EMIT_MX data structure functions, matrix of float log
 *      posterior probabilities of emitted residues in truncated
 *      alignments. Used for optimal accuracy alignment and posterior
 *      annotation of alignments. HMM-banded version.
 *****************************************************************/

/* Function:  cm_tr_hb_emit_mx_Create()
 * Incept:    EPN, Fri Oct  7 09:55:24 2011
 *
 * Purpose:   Allocate a reusable, resizeable <CM_TR_HB_EMIT_MX> for a CM.
 *
 * Args:      cm:      the model
 *
 * Returns:   a pointer to the new <CM_TR_HB_EMIT_MX>.
 *
 * Throws:    <NULL> on allocation error.
 */
CM_TR_HB_EMIT_MX *
cm_tr_hb_emit_mx_Create(CM_t *cm)
{
  int            status;
  CM_TR_HB_EMIT_MX *mx = NULL;
  int            v, l_n, r_n;
  int            allocL = 1; /* this corresponds to a sequence of length 1 */
  int            M = cm->M;
  int            l_nstates_valid;  /* num states for which mx->l_pp[v] != NULL */
  int            r_nstates_valid;  /* num states for which mx->r_pp[v] != NULL */

  /* level 1: the structure itself */
  ESL_ALLOC(mx, sizeof(CM_TR_HB_EMIT_MX));
  mx->Jl_pp     = NULL;
  mx->Jl_pp_mem = NULL;
  mx->Ll_pp     = NULL;
  mx->Ll_pp_mem = NULL;
  mx->Jr_pp     = NULL;
  mx->Jr_pp_mem = NULL;
  mx->Rr_pp     = NULL;
  mx->Rr_pp_mem = NULL;

  /* level 2: row (state) pointers, 0.1..M, go all the way to M
   */
  ESL_ALLOC(mx->Jl_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Ll_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Jr_pp,  sizeof(float *) * (M+1));
  ESL_ALLOC(mx->Rr_pp,  sizeof(float *) * (M+1));

  /* level 3: dp cell memory, when creating only allocate 2 cells per state, for i = 0 and 1 */
  /* first count the number of valid emitting states, left and right */
  l_nstates_valid = 0;
  r_nstates_valid = 0;
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) l_nstates_valid++;
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) r_nstates_valid++;
  }
  l_nstates_valid++; /* add 1 for the EL state, cm->M */
  r_nstates_valid++; /* add 1 for the EL state, cm->M */

  ESL_ALLOC(mx->Jl_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Ll_pp_mem,  sizeof(float) * (l_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Jr_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));
  ESL_ALLOC(mx->Rr_pp_mem,  sizeof(float) * (r_nstates_valid) * (allocL));

  l_n = 0;
  r_n = 0;
  for (v = 0; v < M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->Jl_pp[v] = mx->Jl_pp_mem + l_n * (allocL);
	  mx->Ll_pp[v] = mx->Ll_pp_mem + l_n * (allocL);
	  l_n++;
	}
	else {
	  mx->Jl_pp[v] = NULL;
	  mx->Ll_pp[v] = NULL;
	}

	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->Jr_pp[v] = mx->Jr_pp_mem + r_n * (allocL);
	  mx->Rr_pp[v] = mx->Rr_pp_mem + r_n * (allocL);
	  r_n++;
	}
	else {
	  mx->Jr_pp[v] = NULL;
	  mx->Rr_pp[v] = NULL;
	}
  }

  /* allocate EL row, invalid in Jr */
  mx->Jl_pp[M] = mx->Jl_pp_mem + l_n * (allocL);
  mx->Ll_pp[M] = mx->Ll_pp_mem + l_n * (allocL);
  mx->Rr_pp[M] = mx->Ll_pp_mem + l_n * (allocL);
  mx->Jr_pp[M] = NULL;

  /* finally allocate the sum vector */
  ESL_ALLOC(mx->sum, sizeof(float) * allocL);

  mx->M               = M;
  mx->l_ncells_valid  = 0;
  mx->l_ncells_alloc  = (l_nstates_valid) * (allocL);
  mx->r_ncells_valid  = 0;
  mx->r_ncells_alloc  = (r_nstates_valid) * (allocL);
  mx->L               = allocL-1; /* allocL = 2 */
  mx->cp9b            = NULL;
  /* calculate size, these are in order of when they were allocated */
  mx->size_Mb = (float)
	(sizeof(CM_TR_HB_EMIT_MX)                   +
	 (mx->M+1)    * sizeof(float *)          +  /* mx->Jl_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)          +  /* mx->Ll_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)          +  /* mx->Jr_pp[] ptrs */
	 (mx->M+1)    * sizeof(float *)          +  /* mx->Rr_pp[] ptrs */
	 mx->l_ncells_alloc * sizeof(float)      +  /* mx->Jl_pp_mem */
	 mx->l_ncells_alloc * sizeof(float)      +  /* mx->Ll_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)      +  /* mx->Jr_pp_mem */
	 mx->r_ncells_alloc * sizeof(float)      +  /* mx->Rr_pp_mem */
	 (mx->L+1) * sizeof(float));                /* mx->sum */

  mx->size_Mb *= 0.000001; /* convert to Mb */

  return mx;

 ERROR:
  if (mx != NULL) cm_tr_hb_emit_mx_Destroy(mx);
  return NULL;
}

/* Function:  cm_tr_hb_emit_mx_GrowTo()
 * Incept:    EPN, Thu Oct  6 06:51:57 2011
 *
 * Purpose: Assures that a CM_TR_HB_EMIT_MX matrix <mx> is allocated for a
 *            model of exactly <mx->M> states and target sequence of
 *            length L, given bands in <cp9b>, reallocating memory as
 *            necessary.
 *
 *            If local ends are on (cm->flags & CMH_LOCAL_END), allocates
 *            a full non-banded EL row for the matrix.
 *
 *            Checks to make sure desired matrix isn't too big (see throws).
 *
 * Args:      cm     - the CM the matrix is for
 *            cp9b   - HMM bands for current sequence
 *            mx     - the matrix to grow
 *            errbuf - char buffer for reporting errors
 *            cp9b   - the HMM bands for the target sequence we're growing for
 *            L      - the length of the current target sequence we're aligning
 *            size_limit- max number of Mb for DP matrix, if matrix is bigger -> return eslERANGE
 *
 * Returns:   <eslOK> on success, and <mx> may be reallocated upon
 *            return; any data that may have been in <mx> must be
 *            assumed to be invalidated.
 *
 * Throws:    <eslERANGE> if required size to grow to exceeds <size_limit>.
 *            This should be caught and appropriately handled by caller.
 *            <eslEINCOMPAT> on contract violation
 *            <eslEMEM> on memory allocation error.
 */
int
cm_tr_hb_emit_mx_GrowTo(CM_t *cm, CM_TR_HB_EMIT_MX *mx, char *errbuf, CP9Bands_t *cp9b, int L, float size_limit)
{
  int     status;
  void   *p;
  int     v;
  int64_t l_cur_size = 0;
  int64_t r_cur_size = 0;
  int64_t l_ncells;
  int64_t r_ncells;
  float   Mb_needed; /* required size of matrix, given the bands */
  float   Mb_alloc;  /* allocated size of matrix, >= Mb_needed */
  int     have_el;
  int     l_realloced;   /* did we reallocate mx->l_pp_mem? */
  int     r_realloced;   /* did we reallocate mx->r_pp_mem? */
  int     sum_realloced; /* did we reallocate mx->sum?      */

  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  if((status = cm_tr_hb_emit_mx_SizeNeeded(cm, errbuf, cp9b, L, &l_ncells, &r_ncells, &Mb_needed)) != eslOK) return status;
  /*printf("HMM banded truncated emit matrix requested size: %.2f Mb\n", Mb_needed);*/
  ESL_DPRINTF2(("HMM banded truncated emit matrix requested size: %.2f Mb\n", Mb_needed));
  if(Mb_needed > size_limit) ESL_FAIL(eslERANGE, errbuf, "requested HMM banded emit mx of %.2f Mb > %.2f Mb limit.\nUse --mxsize, --maxtau or --tau.", Mb_needed, (float) size_limit);

  /* must we realloc the full matrix? or can we get away
   * with just jiggering the pointers, if total required num cells is
   * less than or equal to what we already have alloc'ed?
   */
  l_realloced = FALSE;
  r_realloced = FALSE;
  sum_realloced = FALSE;
  if (l_ncells > mx->l_ncells_alloc) {
	  ESL_RALLOC(mx->Jl_pp_mem, p, sizeof(float) * l_ncells);
	  ESL_RALLOC(mx->Ll_pp_mem, p, sizeof(float) * l_ncells);
	  mx->l_ncells_alloc = l_ncells;
	  l_realloced = TRUE;
  }
  if (r_ncells > mx->r_ncells_alloc) {
	  ESL_RALLOC(mx->Jr_pp_mem, p, sizeof(float) * r_ncells);
	  ESL_RALLOC(mx->Rr_pp_mem, p, sizeof(float) * r_ncells);
	  mx->r_ncells_alloc = r_ncells;
	  r_realloced = TRUE;
  }
  if (L > mx->L) {
	ESL_RALLOC(mx->sum, p, sizeof(float) * (L+1));
	sum_realloced = TRUE;
  }

  /* Determine the size of our matrix based on the size it needed to be (Mb_needed).
   */
  Mb_alloc = Mb_needed * 1000000; /* convert to bytes */
  if(! l_realloced) {
	Mb_alloc -= (float) (sizeof(float) * l_ncells);           /* Jl_pp */
	Mb_alloc -= (float) (sizeof(float) * l_ncells);           /* Ll_pp */
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc); /* Jl_pp */
	Mb_alloc += (float) (sizeof(float) * mx->l_ncells_alloc); /* Ll_pp */
  }
  if(! r_realloced) {
	Mb_alloc -= (float) (sizeof(float) * r_ncells);           /* Jr_pp */
	Mb_alloc -= (float) (sizeof(float) * r_ncells);           /* Rr_pp */
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc); /* Jr_pp */
	Mb_alloc += (float) (sizeof(float) * mx->r_ncells_alloc); /* Rr_pp */
  }
  if(! sum_realloced) {
	Mb_alloc -= (float) (sizeof(float) * (L+1));
	Mb_alloc += (float) (sizeof(float) * (mx->L+1));
  }
  Mb_alloc *= 0.000001; /* convert to Mb */

  mx->l_ncells_valid = l_ncells;
  mx->r_ncells_valid = r_ncells;

  /* reset the pointers, we keep a tally of cur_size as we go
   */
  l_cur_size = 0;
  r_cur_size = 0;
  for(v = 0; v < mx->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  mx->Jl_pp[v] = mx->Jl_pp_mem + l_cur_size;
	  mx->Ll_pp[v] = mx->Ll_pp_mem + l_cur_size;
	  if(cp9b->imax[v] >= cp9b->imin[v] && cp9b->imax[v] >= 1) {
	l_cur_size += cp9b->imax[v] - cp9b->imin[v] + 1;
	  }
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  mx->Jr_pp[v] = mx->Jr_pp_mem + r_cur_size;
	  mx->Rr_pp[v] = mx->Rr_pp_mem + r_cur_size;
	  if(cp9b->jmax[v] >= cp9b->jmin[v] && cp9b->jmax[v] >= 1) {
	r_cur_size += cp9b->jmax[v] - cp9b->jmin[v] + 1;
	  }
	}
  }
  if(have_el) { /* EL state is non-banded */
	mx->Jl_pp[mx->M] = mx->Jl_pp_mem + l_cur_size;
	mx->Ll_pp[mx->M] = mx->Ll_pp_mem + l_cur_size;
	mx->Rr_pp[mx->M] = mx->Rr_pp_mem + r_cur_size;
	l_cur_size += L+1;
	r_cur_size += L+1;
  }
  else {
	mx->Jl_pp[mx->M] = NULL;
	mx->Ll_pp[mx->M] = NULL;
	mx->Rr_pp[mx->M] = NULL;
  }
  mx->Jr_pp[mx->M] = NULL;

#if eslDEBUGLEVEL >= 1
  printf("l_ncells %10" PRId64 " %10" PRId64 "\n", l_cur_size, mx->l_ncells_valid);
  printf("r_ncells %10" PRId64 " %10" PRId64 "\n", r_cur_size, mx->r_ncells_valid);
#endif
  assert(l_cur_size == mx->l_ncells_valid);
  assert(r_cur_size == mx->r_ncells_valid);
  ESL_DASSERT1((l_cur_size == mx->l_ncells_valid));
  ESL_DASSERT1((r_cur_size == mx->r_ncells_valid));

  /* now update L and size_Mb */
  mx->L       = L;    /* length of current seq we're valid for */
  mx->size_Mb = Mb_alloc;
  mx->cp9b    = cp9b;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tr_hb_emit_mx_Destroy()
 * Synopsis:  Frees a CM_TR_HB_EMIT_MX.
 * Incept:    EPN, Thu Oct  6 09:06:58 2011
 *
 * Purpose:   Frees a CM_TR_HB_EMIT_MX.
 *
 * Returns:   (void)
 */
void
cm_tr_hb_emit_mx_Destroy(CM_TR_HB_EMIT_MX *mx)
{
  if (mx == NULL) return;

  if (mx->Jl_pp     != NULL) free(mx->Jl_pp);
  if (mx->Ll_pp     != NULL) free(mx->Ll_pp);
  if (mx->Jr_pp     != NULL) free(mx->Jr_pp);
  if (mx->Rr_pp     != NULL) free(mx->Rr_pp);
  if (mx->Jl_pp_mem != NULL) free(mx->Jl_pp_mem);
  if (mx->Ll_pp_mem != NULL) free(mx->Ll_pp_mem);
  if (mx->Jr_pp_mem != NULL) free(mx->Jr_pp_mem);
  if (mx->Rr_pp_mem != NULL) free(mx->Rr_pp_mem);
  if (mx->sum       != NULL) free(mx->sum);

  /* don't free cp9b, that's just a reference */
  free(mx);
  return;
}

/* Function:  cm_tr_hb_emit_mx_Dump()
 * Synopsis:  Dump a HMM banded emit matrix to a stream, for diagnostics.
 * Incept:    EPN, Thu Oct  6 09:07:35 2011
 *
 * Purpose:   Dump matrix <mx> to stream <fp> for diagnostics.
 */
int
cm_tr_hb_emit_mx_Dump(FILE *ofp, CM_t *cm, CM_TR_HB_EMIT_MX *mx, char mode, int print_mx)
{
  int status;
  int v, i, j, ip_v, jp_v;
  int fill_L, fill_R, fill_T; /* are the L, R, and T matrices valid? */

  fprintf(ofp, "M: %d\n", mx->M);
  fprintf(ofp, "L: %d\n", mx->L);
  fprintf(ofp, "l_ncells_alloc: %" PRId64 "\nl_ncells_valid: %" PRId64 "\n", mx->l_ncells_alloc, mx->l_ncells_valid);
  fprintf(ofp, "r_ncells_alloc: %" PRId64 "\nr_ncells_valid: %" PRId64 "\n", mx->r_ncells_alloc, mx->r_ncells_valid);
  fprintf(ofp, "mode: %d\n", mode);

  if((status = cm_TrFillFromMode(mode, &fill_L, &fill_R, &fill_T)) != eslOK) return status;

  if(print_mx) {
	/* l_pp and r_pp matrix data */
	for (v = 0; v < mx->M; v++) {
	  if(mx->Jl_pp[v]) {
	for(i = mx->cp9b->imin[v]; i <= mx->cp9b->imax[v]; i++) {
	  ip_v = i - mx->cp9b->imin[v];
	  fprintf(ofp, "Jl_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Jl_pp[v][ip_v]), mx->Jl_pp[v][ip_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  if(mx->Ll_pp[v] && fill_L) {
	for(i = mx->cp9b->imin[v]; i <= mx->cp9b->imax[v]; i++) {
	  ip_v = i - mx->cp9b->imin[v];
	  fprintf(ofp, "Ll_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, i, sreEXP2(mx->Ll_pp[v][ip_v]), mx->Ll_pp[v][ip_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  if(mx->Jr_pp[v]) {
	for(j = mx->cp9b->jmin[v]; j <= mx->cp9b->jmax[v]; j++) {
	  jp_v = j - mx->cp9b->jmin[v];
	  fprintf(ofp, "Jr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, j, sreEXP2(mx->Jr_pp[v][jp_v]), mx->Jr_pp[v][jp_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  if(mx->Rr_pp[v] && fill_R) {
	for(j = mx->cp9b->jmin[v]; j <= mx->cp9b->jmax[v]; j++) {
	  jp_v = j - mx->cp9b->jmin[v];
	  fprintf(ofp, "Rr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", v, j, sreEXP2(mx->Rr_pp[v][jp_v]), mx->Rr_pp[v][jp_v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]));
	}
	  }
	  fprintf(ofp, "\n");
	}

	/* EL state */
	for(i = 0; i <= mx->L; i++) {
	  if(mx->Jl_pp[cm->M])           fprintf(ofp, "Jl_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Jl_pp[cm->M][i]), mx->Jl_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	  if(mx->Ll_pp[cm->M] && fill_L) fprintf(ofp, "Ll_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Ll_pp[cm->M][i]), mx->Ll_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	  if(mx->Rr_pp[cm->M] && fill_R) fprintf(ofp, "Rr_pp[v:%5d][i:%5d] %8.4f (2^%8.4f) (%4s %2s)\n", cm->M, i, sreEXP2(mx->Rr_pp[cm->M][i]), mx->Rr_pp[cm->M][i], "EL", Statetype(cm->sttype[v]));
	}
  }
  return eslOK;
}

/* Function:  cm_tr_hb_emit_mx_SizeNeeded()
 * Incept:    EPN, Thu Oct  6 09:11:15 2011
 *
 * Purpose: Given a model, sequence length, and HMM bands object,
 *            determine the number of cells and total size in Mb
 *            required in a CM_TR_HB_EMIT_MX for the target sequence.
 *
 *            Return number of l_pp, r_pp cells required in
 *            <ret_l_ncells> and <ret_r_ncells> and size of required
 *            matrix in Mb in <ret_Mb>.
 *
 * Args:      cm           - the CM the matrix is for
 *            errbuf       - char buffer for reporting errors
 *            cp9b         - the HMM bands for this sequence
 *            L            - the length of the current target sequence we're aligning
 *            ret_l_ncells - RETURN: number of matrix cells required
 *            ret_r_ncells - RETURN: number of matrix cells required
 *            ret_Mb       - RETURN: required size of matrix in Mb
 *
 * Returns:   <eslOK> on success
 *
 */
int
cm_tr_hb_emit_mx_SizeNeeded(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int L, int64_t *ret_l_ncells, int64_t *ret_r_ncells, float *ret_Mb)
{
  int     v;
  int64_t l_ncells;
  int64_t r_ncells;
  int     have_el;
  float   Mb_needed;
  have_el = (cm->flags & CMH_LOCAL_END) ? TRUE : FALSE;

  l_ncells = 0;
  r_ncells = 0;

  Mb_needed = (float)
	(sizeof(CM_TR_HB_EMIT_MX) +
	 (cm->M+1) * sizeof(float *) + /* mx->Jl_pp ptrs */
	 (cm->M+1) * sizeof(float *) + /* mx->Ll_pp ptrs */
	 (cm->M+1) * sizeof(float *) + /* mx->Jr_pp ptrs */
	 (cm->M+1) * sizeof(float *)); /* mx->Rr_pp ptrs */

  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	  l_ncells += cp9b->imax[v] - cp9b->imin[v] + 1;
	}
	if(cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  r_ncells += cp9b->jmax[v] - cp9b->jmin[v] + 1;
	}
  }
  if(have_el) {
	l_ncells += L+1; /* space for EL deck */
	r_ncells += L+1; /* space for EL deck */
  }

  Mb_needed += sizeof(float) * (l_ncells + l_ncells + r_ncells + r_ncells + (L+1));
  /* mx->Jl_pp_mem, mx->Ll_pp_mem, mx->Jr_pp_mem, mx->Rr_pp_mem, mx->sum */
  Mb_needed *= 0.000001; /* convert to megabytes */

  if(ret_l_ncells != NULL) *ret_l_ncells = l_ncells;
  if(ret_r_ncells != NULL) *ret_r_ncells = r_ncells;
  if(ret_Mb       != NULL) *ret_Mb      = Mb_needed;

  return eslOK;
}

/*****************************************************************
 *  13. CM_SCAN_MX data structure functions,
 *      auxiliary info and matrix of float and/or int scores for
 *      query dependent banded or non-banded CM DP search functions
 *****************************************************************/

/* Function: cm_scan_mx_Create()
 * Date:     EPN, Sun Nov  4 19:56:58 2007
 *
 * Purpose:  Given relevant info, allocate and initialize CM_SCAN_MX.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL upon contract error, *ret_smx is set to NULL.
 *           eslEMEM if out of memory, *ret_smx is set to NULL.
 */
int
cm_scan_mx_Create(CM_t *cm, char *errbuf, int do_float, int do_int, CM_SCAN_MX **ret_smx)
{
  int status;
  CM_SCAN_MX *smx = NULL;
  int v,j,n;

  if((!do_float) && (!do_int)) ESL_FAIL(eslEINVAL, errbuf, "cm_scan_mx_Create(), do_float and do_int both FALSE.");
  if(cm->qdbinfo == NULL || cm->qdbinfo->setby == CM_QDBINFO_SETBY_INIT || cm->qdbinfo->setby == CM_QDBINFO_SETBY_SUBINIT) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_scan_mx_Create(), qdbinfo is invalid");
  }

  ESL_ALLOC(smx, sizeof(CM_SCAN_MX));

  /* copy M and W */
  smx->M = cm->M;
  smx->W = cm->W;

  /* point to the all-important qdbinfo */
  smx->qdbinfo = cm->qdbinfo;

  /* Allocate dnAAA and dxAAA */
  ESL_ALLOC(smx->dnAAA, sizeof(int **) * NSMX_QDB_IDX);
  ESL_ALLOC(smx->dxAAA, sizeof(int **) * NSMX_QDB_IDX);
  for(n = 0; n < NSMX_QDB_IDX; n++) {
	ESL_ALLOC(smx->dnAAA[n], sizeof(int *) * (smx->W+1));
	ESL_ALLOC(smx->dxAAA[n], sizeof(int *) * (smx->W+1));
	for(j = 1; j <= smx->W; j++) {
	  ESL_ALLOC(smx->dnAAA[n][j], sizeof(int) * smx->M);
	  ESL_ALLOC(smx->dxAAA[n][j], sizeof(int) * smx->M);
	}
  }

  /* For each set of bands, precalculate minimum and maximum d for
   * each state and each sequence index (1..j..W).  this is not always
   * just dmin, dmax, (for ex. if j < W).
   */
  smx->dnAAA[SMX_NOQDB][0]      = smx->dxAAA[SMX_NOQDB][0]      = NULL; /* corresponds to j == 0, which is out of bounds */
  smx->dnAAA[SMX_QDB1_TIGHT][0] = smx->dxAAA[SMX_QDB1_TIGHT][0] = NULL; /* corresponds to j == 0, which is out of bounds */
  smx->dnAAA[SMX_QDB2_LOOSE][0] = smx->dxAAA[SMX_QDB2_LOOSE][0] = NULL; /* corresponds to j == 0, which is out of bounds */
  for(j = 1; j <= smx->W; j++) {
	for(v = 0; v < smx->M; v++) {
	  smx->dnAAA[SMX_NOQDB][j][v]      = (cm->sttype[v] == MP_st) ? 2 : 1;
	  smx->dnAAA[SMX_QDB1_TIGHT][j][v] = (cm->sttype[v] == MP_st) ? ESL_MAX(smx->qdbinfo->dmin1[v], 2) : ESL_MAX(smx->qdbinfo->dmin1[v], 1);
	  smx->dnAAA[SMX_QDB2_LOOSE][j][v] = (cm->sttype[v] == MP_st) ? ESL_MAX(smx->qdbinfo->dmin2[v], 2) : ESL_MAX(smx->qdbinfo->dmin2[v], 1);

	  smx->dnAAA[SMX_NOQDB][j][v]      = ESL_MIN(smx->dnAAA[SMX_NOQDB][j][v],      smx->W);
	  smx->dnAAA[SMX_QDB1_TIGHT][j][v] = ESL_MIN(smx->dnAAA[SMX_QDB1_TIGHT][j][v], smx->W);
	  smx->dnAAA[SMX_QDB2_LOOSE][j][v] = ESL_MIN(smx->dnAAA[SMX_QDB2_LOOSE][j][v], smx->W);

	  smx->dxAAA[SMX_NOQDB][j][v]      = j;
	  smx->dxAAA[SMX_QDB1_TIGHT][j][v] = ESL_MIN(j, ESL_MIN(smx->qdbinfo->dmax1[v], smx->W));
	  smx->dxAAA[SMX_QDB2_LOOSE][j][v] = ESL_MIN(j, ESL_MIN(smx->qdbinfo->dmax2[v], smx->W));
	}
  }

  /* allocate bestr and bestsc */
  ESL_ALLOC(smx->bestr,      (sizeof(int)   * (smx->W+1)));
  ESL_ALLOC(smx->bestsc,     (sizeof(float) * (smx->W+1)));

  /* initialize bestr, bestsc (probably not strictly necessary) */
  esl_vec_ISet(smx->bestr,    (smx->W+1), 0);
  esl_vec_FSet(smx->bestsc,   (smx->W+1), IMPOSSIBLE);

  /* Some info about the falpha/ialpha matrix
   * The alpha matrix holds data for all states EXCEPT BEGL_S states
   * The alpha scanning matrix is indexed [j][v][d].
   *    j takes values 0 or 1: only the previous (prv) or current (cur) row
   *    v ranges from 0..M-1 over states in the model.
   *    d ranges from 0..W over subsequence lengths.
   * Note if v is a BEGL_S alpha[j][v] == NULL
   * Note that old convention of sharing E memory is no longer,
   * each E state has it's own deck.
   *
   * alpha_begl matrix holds data for ONLY BEGL_S states
   *    j takes value of 0..W
   *    v ranges from 0..M-1 over states in the model
   *    d ranges from 0..W over subsequence lengths.
   * Note if v is NOT a BEGL_S alpha_begl[j][v] == NULL
   *
   * alpha and alpha_begl are allocated in contiguous blocks
   * of memory in {f,i}alpha_mem and {f,i}alpha_begl_mem
   */

  /* Some info on alpha initialization
   * We initialize on d=0, subsequences of length 0; these are
   * j-independent. Any generating state (P,L,R) is impossible on d=0.
   * E=0 for d=0. B,S,D must be calculated.
   * Also, for MP, d=1 is impossible.
   * Also, for E, all d>0 are impossible.
   *
   * and, for banding: any cell outside our bands is impossible.
   * These inits are never changed in the recursion, so even with the
   * rolling, matrix face reuse strategy, this works.
   *
   * The way we initialize is just to set the entire matrix
   * to -INFTY or IMPOSSIBLE (for ints and floats, respectively),
   * and then reset those cells that should not be -INFTY or
   * IMPOSSIBLE as listed above. This way we don't have to
   * step through the bands, setting cells outside them to IMPOSSIBLE
   * or -INFY;
   */

  smx->falpha          = NULL;
  smx->falpha_begl     = NULL;
  smx->falpha_mem      = NULL;
  smx->falpha_begl_mem = NULL;

  smx->ialpha          = NULL;
  smx->ialpha_begl     = NULL;
  smx->ialpha_mem      = NULL;
  smx->ialpha_begl_mem = NULL;

  smx->ncells_alpha      = 0;
  smx->ncells_alpha_begl = 0;

  if(do_float) {
	if((status = cm_scan_mx_floatize(cm, smx, errbuf)) != eslOK) goto ERROR;
  }
  if(do_int) {
	if((status = cm_scan_mx_integerize(cm, smx, errbuf)) != eslOK) goto ERROR;
  }

  /* tally up size */
  smx->size_Mb  = (float) sizeof(CM_SCAN_MX);
  smx->size_Mb += (float) sizeof(int **)  * NSMX_QDB_IDX;                       /* dnAAA (1st dim) */
  smx->size_Mb += (float) sizeof(int **)  * NSMX_QDB_IDX;                       /* dxAAA (1st dim) */
  smx->size_Mb += (float) sizeof(int  *)  * NSMX_QDB_IDX * (smx->W+1);          /* dnAAA (2nd dim) */
  smx->size_Mb += (float) sizeof(int  *)  * NSMX_QDB_IDX * (smx->W+1);          /* dxAAA (2nd dim) */
  smx->size_Mb += (float) sizeof(int)     * NSMX_QDB_IDX * (smx->W+1) * smx->M; /* dnAAA (3rd dim) */
  smx->size_Mb += (float) sizeof(int)     * NSMX_QDB_IDX * (smx->W+1) * smx->M; /* dnAAA (3rd dim) */
  smx->size_Mb += (float) sizeof(int)     * (smx->W+1);                         /* bestr  */
  smx->size_Mb += (float) sizeof(float)   * (smx->W+1);                         /* bestsc */
  if(do_float) {
	smx->size_Mb += (float) sizeof(float) * smx->ncells_alpha;                  /* falpha      */
	smx->size_Mb += (float) sizeof(float) * smx->ncells_alpha_begl;             /* falpha_begl */
  }
  if(do_int) {
	smx->size_Mb += (float) sizeof(int)   * smx->ncells_alpha;                  /* ialpha      */
	smx->size_Mb += (float) sizeof(int)   * smx->ncells_alpha_begl;             /* ialpha_begl */
  }
  smx->size_Mb *= 0.000001; /* convert to Mb */

  *ret_smx = smx;
  return eslOK;

 ERROR:
  cm_scan_mx_Destroy(cm, smx);
  *ret_smx = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "out of memory (creating scan matrix)");
  return status;
}

/* Function: cm_scan_mx_floatize()
 * Date:     EPN, Wed Nov  7 10:05:55 2007
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if internal consistency check of cell count fails.
 *           eslEMEM if out of memory.
 */
int
cm_scan_mx_floatize(CM_t *cm, CM_SCAN_MX *smx, char *errbuf)
{
  int status;
  int j, v;
  int n_begl;
  int n_non_begl;
  int64_t cur_cell;

  /* allocate alpha
   * we allocate only as many cells as necessary,
   * for falpha,      we only allocate for non-BEGL_S states,
   * for falpha_begl, we only allocate for     BEGL_S states
   *
   * note: deck for the EL state, cm->M is never used for scanners
   */
  n_begl = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  n_non_begl = cm->M - n_begl;

  /* allocate falpha */
  /* j == 0 v == 0 cells, followed by j == 1 v == 0, then j == 0 v == 1 etc.. */
  ESL_ALLOC(smx->falpha,        sizeof(float **) * 2);
  ESL_ALLOC(smx->falpha[0],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, falpha[0][v] will be NULL */
  ESL_ALLOC(smx->falpha[1],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, falpha[0][v] will be NULL */
  /* define ncells_alpha in two statements to avoid potential overflow
   * (this is probably unnec, but is nec for ncells_alpha_begl so stay consistent)
   */
  smx->ncells_alpha  = 2 * n_non_begl;
  smx->ncells_alpha *= (smx->W+1);
  ESL_ALLOC(smx->falpha_mem,    sizeof(float) * smx->ncells_alpha);

  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] != BEGL_S) {
	  smx->falpha[0][v] = smx->falpha_mem + cur_cell;
	  cur_cell += smx->W+1;
	  smx->falpha[1][v] = smx->falpha_mem + cur_cell;
	  cur_cell += smx->W+1;
	}
	else {
	  smx->falpha[0][v] = NULL;
	  smx->falpha[1][v] = NULL;
	}
  }
  if(cur_cell != smx->ncells_alpha) ESL_FAIL(eslEINVAL, errbuf, "problem laying out float scan matrix");

  /* allocate falpha_begl */
  /* j == d, v == 0 cells, followed by j == d+1, v == 0, etc. */
  ESL_ALLOC(smx->falpha_begl, sizeof(float **) * (smx->W+1));
  for (j = 0; j <= smx->W; j++)
	ESL_ALLOC(smx->falpha_begl[j],  sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, falpha_begl[0][v] will be NULL */
  /* define ncells_alpha_begl with three separate statements: */
  smx->ncells_alpha_begl = (smx->W+1);
  smx->ncells_alpha_begl *= n_begl;
  smx->ncells_alpha_begl *= (smx->W+1);
  ESL_ALLOC(smx->falpha_begl_mem,   sizeof(float) * ESL_MAX(1, smx->ncells_alpha_begl));
  /* we used to define ncells_alpha_begl this way:
   *   smx->ncells_alpha_begl = (smx->W+1) * n_begl * (smx->W+1);
   * but that overflows for large models (even though ncells_alpha_begl is an int64_t, I guess
   * the temporary value stored on the RHS overflows?). This was bug i40.
   */

  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	for (j = 0; j <= smx->W; j++) {
	  if (cm->stid[v] == BEGL_S) {
	smx->falpha_begl[j][v] = smx->falpha_begl_mem + cur_cell;
	cur_cell += smx->W+1;
	  }
	  else smx->falpha_begl[j][v] = NULL;
	}
  }
  if(cur_cell != smx->ncells_alpha_begl) ESL_FAIL(eslEINVAL, errbuf, "problem laying out float scan matrix");

  /* set the flag that tells us we've got valid floats */
  smx->floats_valid = TRUE;

  /* Initialize matrix */
  if((status = cm_scan_mx_InitializeFloats(cm, smx, errbuf)) != eslOK) return status;

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "out of memory (creating float scan matrix)");
  return status; /* NOT REACHED */
}

/* Function: cm_scan_mx_integerize()
 * Date:     EPN, Wed Nov  7 10:10:39 2007
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if internal consistency check of cell count fails.
 *           eslEMEM if out of memory.
 */
int
cm_scan_mx_integerize(CM_t *cm, CM_SCAN_MX *smx, char *errbuf)
{
  int status;
  int n_begl;
  int n_non_begl;
  int64_t cur_cell;
  int v, j;

  /* allocate alpha
   * we allocate only as many cells as necessary,
   * for ialpha,      we only allocate for non-BEGL_S states,
   * for ialpha_begl, we only allocate for     BEGL_S states
   *
   * note: deck for the EL state, cm->M is never used for scanners
   */
  n_begl = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  n_non_begl = cm->M - n_begl;

  /* allocate ialpha */
  /* j == 0 v == 0 cells, followed by j == 1 v == 0, then j == 0 v == 1 etc.. */
  ESL_ALLOC(smx->ialpha,        sizeof(int **) * 2);
  ESL_ALLOC(smx->ialpha[0],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, ialpha[0][v] will be NULL */
  ESL_ALLOC(smx->ialpha[1],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, ialpha[0][v] will be NULL */
  /* define ncells_alpha in two statements to avoid potential overflow
   * (this is probably unnec, but is nec for ncells_alpha_begl so stay consistent)
   */
  smx->ncells_alpha  = 2 * n_non_begl;
  smx->ncells_alpha *= (smx->W+1);
  ESL_ALLOC(smx->ialpha_mem,    sizeof(float) * smx->ncells_alpha);

  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] != BEGL_S) {
	  smx->ialpha[0][v] = smx->ialpha_mem + cur_cell;
	  cur_cell += smx->W+1;
	  smx->ialpha[1][v] = smx->ialpha_mem + cur_cell;
	  cur_cell += smx->W+1;
	}
	else {
	  smx->ialpha[0][v] = NULL;
	  smx->ialpha[1][v] = NULL;
	}
  }
  if(cur_cell != smx->ncells_alpha) ESL_FAIL(eslEINVAL, errbuf, "problem laying out int scan matrix");

  /* allocate ialpha_begl */
  /* j == d, v == 0 cells, followed by j == d+1, v == 0, etc. */
  ESL_ALLOC(smx->ialpha_begl, sizeof(int **) * (smx->W+1));
  for (j = 0; j <= smx->W; j++)
	ESL_ALLOC(smx->ialpha_begl[j],  sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, ialpha_begl[0][v] will be NULL */
  /* define ncells_alpha_begl with three separate statements: */
  smx->ncells_alpha_begl = (smx->W+1);
  smx->ncells_alpha_begl *= n_begl;
  smx->ncells_alpha_begl *= (smx->W+1);
  ESL_ALLOC(smx->ialpha_begl_mem,   sizeof(int) * ESL_MAX(1, smx->ncells_alpha_begl)); // avoid 0 malloc
  /* we used to define ncells_alpha_begl this way:
   *   smx->ncells_alpha_begl = (smx->W+1) * n_begl * (smx->W+1);
   * but that overflows for large models (even though ncells_alpha_begl is an int64_t, I guess
   * the temporary value stored on the RHS overflows?). This was bug i40.
   */
  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	for (j = 0; j <= smx->W; j++) {
	  if (cm->stid[v] == BEGL_S) {
	smx->ialpha_begl[j][v] = smx->ialpha_begl_mem + cur_cell;
	cur_cell += smx->W+1;
	  }
	  else smx->ialpha_begl[j][v] = NULL;
	}
  }
  if(cur_cell != smx->ncells_alpha_begl) ESL_FAIL(eslEINVAL, errbuf, "problem laying out int scan matrix");

  /* set the flag that tells us we've got valid ints */
  smx->ints_valid = TRUE;

  /* Initialize matrix */
  if((status = cm_scan_mx_InitializeIntegers(cm, smx, errbuf)) != eslOK) return status;

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "out of memory (creating int scan matrix)");
  return status; /* NOT REACHED */
}

/* Function: cm_scan_mx_InitializeFloats()
 * Date:     EPN, Tue Dec 27 10:41:53 2011
 *
 * Purpose:  Initialize float scores in a CM_SCAN_MX. This
 *           should be done before using the scan matrix for
 *           a new target sequence.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if float matrix is not allocated.
 */
int
cm_scan_mx_InitializeFloats(CM_t *cm, CM_SCAN_MX *smx, char *errbuf)
{
  int v, j, y, w, yoffset;

  if(! smx->floats_valid) ESL_FAIL(eslEINVAL, errbuf, "cm_scan_mx_InitializeFloats(), smx->floats_valid is FALSE");

  /* First, init entire matrix to IMPOSSIBLE */
  esl_vec_FSet(smx->falpha_mem,      smx->ncells_alpha,      IMPOSSIBLE);
  esl_vec_FSet(smx->falpha_begl_mem, smx->ncells_alpha_begl, IMPOSSIBLE);

  /* Now, initialize cells that should not be IMPOSSIBLE in falpha and falpha_begl */
  for(v = cm->M-1; v >= 0; v--) {
	if(cm->stid[v] != BEGL_S) {
	  if (cm->sttype[v] == E_st) {
	smx->falpha[0][v][0] = smx->falpha[1][v][0] = 0.;
	/* rest of E deck is IMPOSSIBLE, it's already set */
	  }
	  else if (cm->sttype[v] == S_st || cm->sttype[v] == D_st) {
	y = cm->cfirst[v];
	smx->falpha[0][v][0] = cm->endsc[v];
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	  smx->falpha[0][v][0] = ESL_MAX(smx->falpha[0][v][0], (smx->falpha[0][y+yoffset][0] + cm->tsc[v][yoffset]));
	smx->falpha[0][v][0] = ESL_MAX(smx->falpha[0][v][0], IMPOSSIBLE);
	  }
	  else if (cm->sttype[v] == B_st) {
	w = cm->cfirst[v]; /* BEGL_S, left child state */
	y = cm->cnum[v];
	smx->falpha[0][v][0] = smx->falpha_begl[0][w][0] + smx->falpha[0][y][0];
	  }
	  smx->falpha[1][v][0] = smx->falpha[0][v][0];
	}
	else { /* v == BEGL_S */
	  y = cm->cfirst[v];
	  smx->falpha_begl[0][v][0] = cm->endsc[v];
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	smx->falpha_begl[0][v][0] = ESL_MAX(smx->falpha_begl[0][v][0], (smx->falpha[0][y+yoffset][0] + cm->tsc[v][yoffset])); /* careful: y is in smx->falpha */
	  smx->falpha_begl[0][v][0] = ESL_MAX(smx->falpha_begl[0][v][0], IMPOSSIBLE);
	  for (j = 1; j <= smx->W; j++)
	smx->falpha_begl[j][v][0] = smx->falpha_begl[0][v][0];
	}
  }

  return eslOK;
}

/* Function: cm_scan_mx_InitializeIntegers()
 * Date:     EPN, Tue Dec 27 10:45:02 2011
 *
 * Purpose:  Initialize integer scores in a CM_SCAN_MX. This
 *           should be done before using the scan matrix for
 *           a new target sequence.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if float matrix is not allocated.
 */
int
cm_scan_mx_InitializeIntegers(CM_t *cm, CM_SCAN_MX *smx, char *errbuf)
{
  int v, j, y, w, yoffset;

  if(! smx->ints_valid) ESL_FAIL(eslEINVAL, errbuf, "cm_scan_mx_InitializeIntegers(), smx->ints_valid is FALSE");

  /* First, init entire matrix to -INFTY */
  esl_vec_ISet(smx->ialpha_mem,      smx->ncells_alpha,      -INFTY);
  esl_vec_ISet(smx->ialpha_begl_mem, smx->ncells_alpha_begl, -INFTY);

  /* Now, initialize cells that should not be -INFTY in ialpha and ialpha_begl */
  for(v = cm->M-1; v >= 0; v--) {
	if(cm->stid[v] != BEGL_S) {
	  if (cm->sttype[v] == E_st) {
	smx->ialpha[0][v][0] = smx->ialpha[1][v][0] = 0.;
	/* rest of E deck is -INFTY, it's already set */
	  }
	  else if (cm->sttype[v] == S_st || cm->sttype[v] == D_st) {
	y = cm->cfirst[v];
	smx->ialpha[0][v][0] = cm->iendsc[v];
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	  smx->ialpha[0][v][0] = ESL_MAX(smx->ialpha[0][v][0], (smx->ialpha[0][y+yoffset][0] + cm->itsc[v][yoffset]));
	smx->ialpha[0][v][0] = ESL_MAX(smx->ialpha[0][v][0], -INFTY);
	  }
	  else if (cm->sttype[v] == B_st) {
	w = cm->cfirst[v]; /* BEGL_S, left child state */
	y = cm->cnum[v];
	smx->ialpha[0][v][0] = smx->ialpha_begl[0][w][0] + smx->ialpha[0][y][0];
	  }
	  smx->ialpha[1][v][0] = smx->ialpha[0][v][0];
	}
	else { /* v == BEGL_S */
	  y = cm->cfirst[v];
	  smx->ialpha_begl[0][v][0] = cm->iendsc[v];
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	smx->ialpha_begl[0][v][0] = ESL_MAX(smx->ialpha_begl[0][v][0], (smx->ialpha[0][y+yoffset][0] + cm->itsc[v][yoffset])); /* careful: y is in alpha */
	  smx->ialpha_begl[0][v][0] = ESL_MAX(smx->ialpha_begl[0][v][0], -INFTY);
	  for (j = 1; j <= smx->W; j++)
	smx->ialpha_begl[j][v][0] = smx->ialpha_begl[0][v][0];
	}
  }

  return eslOK;
}

/* Function: cm_scan_mx_SizeNeeded()
 * Date:     EPN, Tue Dec 13 04:33:42 2011
 *
 * Purpose:  Predict the size needed in Mb to create a
 *           CM_SCAN_MX for <cm>.
 *
 * Returns:  Size needed in Mb.
 */
float
cm_scan_mx_SizeNeeded(CM_t *cm, int do_float, int do_int)
{
  int     n_begl             = 0;
  int     n_non_begl         = 0;
  int64_t ncells_alpha       = 0;
  int64_t ncells_alpha_begl  = 0;
  int     v;
  float   Mb_needed = 0.;

  /* calculate number of cells in alpha and alpha_begl */
  n_begl = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  n_non_begl = cm->M - n_begl;
  /* use several statements to calculate ncells_alpha_*, otherwise we could overflow,
   * (the overflow was part of bug i40).
   */
  ncells_alpha       = 2;
  ncells_alpha      *= n_non_begl;
  ncells_alpha      *= (cm->W+1);
  ncells_alpha_begl  = (cm->W+1);
  ncells_alpha_begl *= n_begl;
  ncells_alpha_begl *= (cm->W+1);

  /* tally up size */
  Mb_needed  = (float) sizeof(CM_SCAN_MX);
  Mb_needed += (float) sizeof(int **)  * NSMX_QDB_IDX;                     /* dnAAA (1st dim) */
  Mb_needed += (float) sizeof(int **)  * NSMX_QDB_IDX;                     /* dxAAA (1st dim) */
  Mb_needed += (float) sizeof(int  *)  * NSMX_QDB_IDX * (cm->W+1);         /* dnAAA (2nd dim) */
  Mb_needed += (float) sizeof(int  *)  * NSMX_QDB_IDX * (cm->W+1);         /* dxAAA (2nd dim) */
  Mb_needed += (float) sizeof(int)     * NSMX_QDB_IDX * (cm->W+1) * cm->M; /* dnAAA (3rd dim) */
  Mb_needed += (float) sizeof(int)     * NSMX_QDB_IDX * (cm->W+1) * cm->M; /* dnAAA (3rd dim) */
  Mb_needed += (float) sizeof(int)     * (cm->W+1);                        /* bestr  */
  Mb_needed += (float) sizeof(float)   * (cm->W+1);                        /* bestsc */
  if(do_float) {
	Mb_needed += (float) sizeof(float) * ncells_alpha;                     /* falpha      */
	Mb_needed += (float) sizeof(float) * ncells_alpha_begl;                /* falpha_begl */
  }
  if(do_int) {
	Mb_needed += (float) sizeof(int)   * ncells_alpha;                     /* ialpha      */
	Mb_needed += (float) sizeof(int)   * ncells_alpha_begl;                /* ialpha_begl */
  }
  Mb_needed *= 0.000001; /* convert to Mb */

  return Mb_needed;
}

/* Function: cm_scan_mx_Destroy()
 * Date:     EPN, Sun Nov  4 20:57:32 2007
 *
 * Purpose:  Free a CM_SCAN_MX object corresponding
 *           to CM <cm>.
 *
 * Returns:  void
 */
void
cm_scan_mx_Destroy(CM_t *cm, CM_SCAN_MX *smx)
{
  int n, j;

  for(n = 0; n < NSMX_QDB_IDX; n++) {
	for(j = 1; j <= smx->W; j++) {
	  free(smx->dnAAA[n][j]);
	  free(smx->dxAAA[n][j]);
	}
	free(smx->dnAAA[n]);
	free(smx->dxAAA[n]);
  }
  free(smx->dnAAA);
  free(smx->dxAAA);
  free(smx->bestr);
  free(smx->bestsc);

  if(smx->floats_valid) cm_scan_mx_freefloats  (cm, smx);
  if(smx->ints_valid)   cm_scan_mx_freeintegers(cm, smx);

  free(smx);
  return;
}

/* Function: cm_scan_mx_freefloats()
 * Date:     EPN, Wed Nov  7 10:03:55 2007
 *
 * Purpose:  Free float data structures in a CM_SCAN_MX object
 *           corresponding to <cm>.
 *
 * Returns:  eslOK on success.
 */
int
cm_scan_mx_freefloats(CM_t *cm, CM_SCAN_MX *smx)
{
  int j;

  if(smx->falpha_mem != NULL) free(smx->falpha_mem);
  if(smx->falpha     != NULL) {
	if(smx->falpha[1]  != NULL) free(smx->falpha[1]);
	if(smx->falpha[0]  != NULL) free(smx->falpha[0]);
	free(smx->falpha);
	smx->falpha = NULL;
  }

  if(smx->falpha_begl_mem != NULL) {
	free(smx->falpha_begl_mem);
  }
  if(smx->falpha_begl != NULL) {
	for (j = 0; j <= smx->W; j++) {
	  if(smx->falpha_begl[j] != NULL) free(smx->falpha_begl[j]);
	}
	free(smx->falpha_begl);
	smx->falpha_begl = NULL;
  }

  smx->floats_valid = FALSE;
  return eslOK;
}

/* Function: cm_scan_mx_freeintegers()
 * Date:     EPN, Wed Nov  7 09:56:01 2007
 *
 * Purpose:  Free int data structures in a CM_SCAN_MX object
 *           corresponding to <cm>.
 *
 * Returns:  eslOK on success, dies immediately on an error.
 */
int
cm_scan_mx_freeintegers(CM_t *cm, CM_SCAN_MX *smx)
{
  int j;

  if(smx->ialpha_mem != NULL) free(smx->ialpha_mem);
  if(smx->ialpha     != NULL) {
	if(smx->ialpha[1]  != NULL) free(smx->ialpha[1]);
	if(smx->ialpha[0]  != NULL) free(smx->ialpha[0]);
	free(smx->ialpha);
	smx->ialpha = NULL;
  }

  if(smx->ialpha_begl_mem != NULL) {
	free(smx->ialpha_begl_mem);
  }
  if(smx->ialpha_begl != NULL) {
	for (j = 0; j <= smx->W; j++) {
	  if(smx->ialpha_begl[j] != NULL) free(smx->ialpha_begl[j]);
	}
	free(smx->ialpha_begl);
	smx->ialpha_begl = NULL;
  }

  smx->ints_valid = FALSE;
  return eslOK;
}

/* Function: cm_scan_mx_Dump()
 * Date:     EPN, Tue Nov  6 05:11:26 2007
 *
 * Purpose:  Dump current alpha matrix (either float or int).
 *
 * Returns:  void, dies upon an error.
 */
void
cm_scan_mx_Dump(FILE *ofp, CM_t *cm, int j, int i0, int qdbidx, int doing_float)
{
  int d, v;
  int jp_g = j-i0+1; /* j is actual index in j, jp_g is offset j relative to start i0 (index in gamma* data structures) */
  int cur = j%2;
  int prv = (j-1)%2;
  int *dnA, *dxA;

  CM_SCAN_MX *smx = cm->smx;
  if(   doing_float  && (! smx->floats_valid)) cm_Fail("cm_scan_mx_Dump(), trying to print float alpha, but floats are not valid");
  if((! doing_float) && (! smx->ints_valid))   cm_Fail("cm_scan_mx_Dump(), trying to print int   alpha, but ints   are not valid");

  int begl_prv = j-1 % (smx->W+1);
  int begl_cur = j   % (smx->W+1);

  fprintf(ofp, "Dumping Alpha: j: %d\n", j);
  if(jp_g >= smx->W) { dnA = smx->dnAAA[qdbidx][smx->W]; dxA = smx->dxAAA[qdbidx][smx->W]; }
  else               { dnA = smx->dnAAA[qdbidx][jp_g];   dxA = smx->dxAAA[qdbidx][jp_g]; }
  if(doing_float) {
	for (v = smx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, smx->falpha_begl[begl_prv][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, smx->falpha[prv][v][d]);
	  }
	  fprintf(ofp, "\n");
	}
	for (v = smx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, smx->falpha_begl[begl_cur][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, smx->falpha[cur][v][d]);
	  }
	  fprintf(ofp, "\n");
	}
  }
  else { /* doing int */
	for (v = smx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, smx->ialpha_begl[begl_prv][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, smx->ialpha[prv][v][d]);
	  }
	  fprintf(ofp, "\n\n");
	}
	for (v = smx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, smx->ialpha_begl[begl_cur][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "A[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, smx->ialpha[cur][v][d]);
	  }
	  fprintf(ofp, "\n\n");
	}
  }
  return;
}

/*****************************************************************
 *  14. CM_TR_SCAN_MX data structure functions,
 *      auxiliary info and matrix of float and/or int scores for
 *      truncated query dependent banded or non-banded CM DP search
 *      functions.
 *****************************************************************/

/* Function: cm_tr_scan_mx_Create()
 * Date:     EPN, Tue Aug 16 04:23:41 2011
 *
 * Purpose:  Given relevant info, allocate and initialize
 *           CM_TR_SCAN_MX object.  Note that unlike a CM_SCAN_MX,
 *           dmin is not used to set minimum values, even if we're
 *           going to use QDBs, because minimum subtree lengths are
 *           illogical with the truncated version of CYK/Inside, but
 *           maximum lengths are not, so <dmax> is considered here.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL upon contract error, *ret_trsmx is set to NULL.
 *           eslEMEM if out of memory, *ret_trsmx is set to NULL.
 */
int
cm_tr_scan_mx_Create(CM_t *cm, char *errbuf, int do_float, int do_int, CM_TR_SCAN_MX **ret_trsmx)
{
  int status;
  CM_TR_SCAN_MX *trsmx = NULL;
  int v,j,n;

  if((!do_float) && (!do_int)) ESL_FAIL(eslEINVAL, errbuf, "cm_tr_scan_mx_Create(), do_float and do_int both FALSE.");
  if(cm->qdbinfo == NULL || cm->qdbinfo->setby == CM_QDBINFO_SETBY_INIT || cm->qdbinfo->setby == CM_QDBINFO_SETBY_SUBINIT) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_tr_scan_mx_Create(), qdbinfo is invalid");
  }

  ESL_ALLOC(trsmx, sizeof(CM_TR_SCAN_MX));

  /* copy W */
  trsmx->W = cm->W;

  /* point to the all-important qdbinfo */
  trsmx->qdbinfo = cm->qdbinfo;

  /* Allocate dnAAA and dxAAA */
  ESL_ALLOC(trsmx->dnAAA, sizeof(int **) * NSMX_QDB_IDX);
  ESL_ALLOC(trsmx->dxAAA, sizeof(int **) * NSMX_QDB_IDX);
  for(n = 0; n < NSMX_QDB_IDX; n++) {
	ESL_ALLOC(trsmx->dnAAA[n], sizeof(int *) * (trsmx->W+1));
	ESL_ALLOC(trsmx->dxAAA[n], sizeof(int *) * (trsmx->W+1));
	for(j = 1; j <= trsmx->W; j++) {
	  ESL_ALLOC(trsmx->dnAAA[n][j], sizeof(int) * cm->M);
	  ESL_ALLOC(trsmx->dxAAA[n][j], sizeof(int) * cm->M);
	}
  }

  /* For each set of bands, precalculate minimum and maximum d for
   * each state and each sequence index (1..j..W).  this is not always
   * just dmin, dmax, (for ex. if j < W).
   */
  trsmx->dnAAA[SMX_NOQDB][0]      = trsmx->dxAAA[SMX_NOQDB][0]      = NULL; /* corresponds to j == 0, which is out of bounds */
  trsmx->dnAAA[SMX_QDB1_TIGHT][0] = trsmx->dxAAA[SMX_QDB1_TIGHT][0] = NULL; /* corresponds to j == 0, which is out of bounds */
  trsmx->dnAAA[SMX_QDB2_LOOSE][0] = trsmx->dxAAA[SMX_QDB2_LOOSE][0] = NULL; /* corresponds to j == 0, which is out of bounds */
  for(j = 1; j <= trsmx->W; j++) {
	for(v = 0; v < cm->M; v++) {
	  /* dnAAA[j][v] is 1 for all states, even MATP, b/c d == 1 is valid for MATP in L,R matrices */
	  trsmx->dnAAA[SMX_NOQDB][j][v]      = 1;
	  trsmx->dnAAA[SMX_QDB1_TIGHT][j][v] = 1;
	  trsmx->dnAAA[SMX_QDB2_LOOSE][j][v] = 1;

	  trsmx->dxAAA[SMX_NOQDB][j][v]      = ESL_MIN(j, trsmx->W);
	  trsmx->dxAAA[SMX_QDB1_TIGHT][j][v] = ESL_MIN(j, ESL_MIN(trsmx->qdbinfo->dmax1[v], trsmx->W));
	  trsmx->dxAAA[SMX_QDB2_LOOSE][j][v] = ESL_MIN(j, ESL_MIN(trsmx->qdbinfo->dmax2[v], trsmx->W));
	}
  }

  /* allocate bestr, bestsc, bestmode */
  ESL_ALLOC(trsmx->bestr,    (sizeof(int)   * (trsmx->W+1)));
  ESL_ALLOC(trsmx->bestsc,   (sizeof(float) * (trsmx->W+1)));
  ESL_ALLOC(trsmx->bestmode, (sizeof(char)  * (trsmx->W+1)));
  /* initialize bestr, bestsc, bestmode (probably not strictly necessary) */
  esl_vec_ISet(trsmx->bestr,    (trsmx->W+1), 0);
  esl_vec_FSet(trsmx->bestsc,   (trsmx->W+1), IMPOSSIBLE);
  for(j = 0; j <= trsmx->W; j++) trsmx->bestmode[j] = TRMODE_UNKNOWN;

  /* Some info about the falpha/ialpha matrix
   * The alpha matrix holds data for all states EXCEPT BEGL_S states
   * The alpha scanning matrix is indexed [j][v][d].
   *    j takes values 0 or 1: only the previous (prv) or current (cur) row
   *    v ranges from 0..M-1 over states in the model.
   *    d ranges from 0..W over subsequence lengths.
   * Note if v is a BEGL_S alpha[j][v] == NULL
   * Note that old convention of sharing E memory is no longer,
   * each E state has it's own deck.
   *
   * alpha_begl matrix holds data for ONLY BEGL_S states
   *    j takes value of 0..W
   *    v ranges from 0..M-1 over states in the model
   *    d ranges from 0..W over subsequence lengths.
   * Note if v is NOT a BEGL_S alpha_begl[j][v] == NULL
   *
   * alpha and alpha_begl are allocated in contiguous blocks
   * of memory in {f,i}alpha_mem and {f,i}alpha_begl_mem
   */

  /* Some info on alpha initialization
   * We initialize on d=0, subsequences of length 0; these are
   * j-independent. Any generating state (P,L,R) is impossible on d=0.
   * E=0 for d=0. B,S,D must be calculated.
   * Also, for MP, d=1 is impossible.
   * Also, for E, all d>0 are impossible.
   *
   * and, for banding: any cell outside our bands is impossible.
   * These inits are never changed in the recursion, so even with the
   * rolling, matrix face reuse strategy, this works.
   *
   * The way we initialize is just to set the entire matrix
   * to -INFTY or IMPOSSIBLE (for ints and floats, respectively),
   * and then reset those cells that should not be -INFTY or
   * IMPOSSIBLE as listed above. This way we don't have to
   * step through the bands, setting cells outside them to IMPOSSIBLE
   * or -INFY;
   */

  trsmx->fJalpha          = trsmx->fLalpha          = trsmx->fRalpha          = trsmx->fTalpha          = NULL;
  trsmx->fJalpha_begl     = trsmx->fLalpha_begl     = trsmx->fRalpha_begl     = NULL;
  trsmx->fJalpha_mem      = trsmx->fLalpha_mem      = trsmx->fRalpha_mem      = trsmx->fTalpha_mem      = NULL;
  trsmx->fJalpha_begl_mem = trsmx->fLalpha_begl_mem = trsmx->fRalpha_begl_mem = NULL;

  trsmx->iJalpha          = trsmx->iLalpha          = trsmx->iRalpha          = trsmx->iTalpha          = NULL;
  trsmx->iJalpha_begl     = trsmx->iLalpha_begl     = trsmx->iRalpha_begl     = NULL;
  trsmx->iJalpha_mem      = trsmx->iLalpha_mem      = trsmx->iRalpha_mem      = trsmx->iTalpha_mem      = NULL;
  trsmx->iJalpha_begl_mem = trsmx->iLalpha_begl_mem = trsmx->iRalpha_begl_mem = NULL;

  trsmx->ncells_alpha      = 0;
  trsmx->ncells_alpha_begl = 0;
  trsmx->ncells_Talpha     = 0;

  if(do_float) {
	if((status = cm_tr_scan_mx_floatize(cm, trsmx, errbuf)) != eslOK) goto ERROR;
  }
  if(do_int) {
	if((status = cm_tr_scan_mx_integerize(cm, trsmx, errbuf)) != eslOK) goto ERROR;
  }

  /* tally up size */
  trsmx->size_Mb  = (float) sizeof(CM_SCAN_MX);
  trsmx->size_Mb += (float) sizeof(int **)  * NSMX_QDB_IDX;                           /* dnAAA (1st dim) */
  trsmx->size_Mb += (float) sizeof(int **)  * NSMX_QDB_IDX;                           /* dxAAA (1st dim) */
  trsmx->size_Mb += (float) sizeof(int  *)  * NSMX_QDB_IDX * (trsmx->W+1);            /* dnAAA (2nd dim) */
  trsmx->size_Mb += (float) sizeof(int  *)  * NSMX_QDB_IDX * (trsmx->W+1);            /* dxAAA (2nd dim) */
  trsmx->size_Mb += (float) sizeof(int)     * NSMX_QDB_IDX * (trsmx->W+1) * trsmx->M; /* dnAAA (3rd dim) */
  trsmx->size_Mb += (float) sizeof(int)     * NSMX_QDB_IDX * (trsmx->W+1) * trsmx->M; /* dnAAA (3rd dim) */
  trsmx->size_Mb += (float) sizeof(int)     * (trsmx->W+1);                           /* bestr  */
  trsmx->size_Mb += (float) sizeof(float)   * (trsmx->W+1);                           /* bestsc */
  if(do_float) {
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha;                    /* fJalpha     */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha;                    /* fLalpha     */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha;                    /* fRalpha     */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_Talpha;                   /* fTalpha     */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha_begl;               /* fJalpha_begl */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha_begl;               /* fLalpha_begl */
	trsmx->size_Mb += (float) sizeof(float) * trsmx->ncells_alpha_begl;               /* fRalpha_begl */
  }
  if(do_int) {
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha;                    /* iJalpha     */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha;                    /* iLalpha     */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha;                    /* iRalpha     */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_Talpha;                   /* iTalpha     */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha_begl;               /* iJalpha_begl */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha_begl;               /* iLalpha_begl */
	trsmx->size_Mb += (float) sizeof(int)   * trsmx->ncells_alpha_begl;               /* iRalpha_begl */
  }
  trsmx->size_Mb *= 0.000001; /* convert to Mb */

  *ret_trsmx = trsmx;
  return eslOK;

 ERROR:
  cm_tr_scan_mx_Destroy(cm, trsmx);
  *ret_trsmx = NULL;
  if(status == eslEMEM) ESL_FAIL(status, errbuf, "out of memory (creating tr scan matrix)");
  return status;
}

/* Function: cm_tr_scan_mx_floatize()
 * Date:     EPN, Tue Aug 16 04:36:29 2011
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if internal consistency check of cell count fails.
 *           eslEMEM if out of memory.
 */
int
cm_tr_scan_mx_floatize(CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf)
{
  int status;
  int j, v;
  int n_begl, n_bif;
  int n_non_begl;
  int64_t cur_cell;

  /* allocate alpha
   * we allocate only as many cells as necessary,
   * for f{J,L,R,T}alpha,      we only allocate for non-BEGL_S states,
   * for f{J,L,R,T}alpha_begl, we only allocate for     BEGL_S states
   * for fTalpha,              we only allocate for     BIF_B  and ROOT_S states
   *
   * note: deck for the EL state, cm->M is never used for scanners
   */
  n_begl = 0;
  n_bif  = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BIF_B)  n_bif++;
  n_non_begl = cm->M - n_begl;

  /* allocate f{J,L,R,T}alpha */
  /* j == 0 v == 0 cells, followed by j == 1 v == 0, then j == 0 v == 1 etc.. */
  ESL_ALLOC(trsmx->fJalpha,        sizeof(float **) * 2);
  ESL_ALLOC(trsmx->fJalpha[0],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fJalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->fJalpha[1],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fJalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->fJalpha_mem,    sizeof(float) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->fLalpha,        sizeof(float **) * 2);
  ESL_ALLOC(trsmx->fLalpha[0],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fLalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->fLalpha[1],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fLalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->fLalpha_mem,    sizeof(float) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->fRalpha,        sizeof(float **) * 2);
  ESL_ALLOC(trsmx->fRalpha[0],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fRalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->fRalpha[1],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fRalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->fRalpha_mem,    sizeof(float) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->fTalpha,        sizeof(float **) * 2);
  ESL_ALLOC(trsmx->fTalpha[0],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BIF_B and v != ROOT_S, fTalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->fTalpha[1],     sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BIF_B and v != ROOT_S, fTalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->fTalpha_mem,    sizeof(float) * 2 * n_non_begl * (trsmx->W+1));

  /* define ncells_alpha in two statements to avoid potential overflow
   * (this is probably unnec, but is nec for ncells_alpha_begl so stay consistent)
   */
  trsmx->ncells_alpha  = 2 * n_non_begl;
  trsmx->ncells_alpha *= (trsmx->W+1);
  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] != BEGL_S) {
	  trsmx->fJalpha[0][v] = trsmx->fJalpha_mem + cur_cell;
	  trsmx->fLalpha[0][v] = trsmx->fLalpha_mem + cur_cell;
	  trsmx->fRalpha[0][v] = trsmx->fRalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	  trsmx->fJalpha[1][v] = trsmx->fJalpha_mem + cur_cell;
	  trsmx->fLalpha[1][v] = trsmx->fLalpha_mem + cur_cell;
	  trsmx->fRalpha[1][v] = trsmx->fRalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	}
	else {
	  trsmx->fJalpha[0][v] = NULL;
	  trsmx->fJalpha[1][v] = NULL;
	  trsmx->fLalpha[0][v] = NULL;
	  trsmx->fLalpha[1][v] = NULL;
	  trsmx->fRalpha[0][v] = NULL;
	  trsmx->fRalpha[1][v] = NULL;
	}
  }
  if(cur_cell != trsmx->ncells_alpha) { status = eslEINVAL; goto ERROR; }

  trsmx->ncells_Talpha = 2 * (n_bif+1) * (trsmx->W+1);
  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] == BIF_B || cm->stid[v] == ROOT_S) {
	  trsmx->fTalpha[0][v] = trsmx->fTalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	  trsmx->fTalpha[1][v] = trsmx->fTalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	}
	else {
	  trsmx->fTalpha[0][v] = NULL;
	  trsmx->fTalpha[1][v] = NULL;
	}
  }
  if(cur_cell != trsmx->ncells_Talpha) ESL_FAIL(eslEINVAL, errbuf, "problem laying out float truncated scan matrix");

  /* allocate falpha_begl */
  /* j == d, v == 0 cells, followed by j == d+1, v == 0, etc. */
  ESL_ALLOC(trsmx->fJalpha_begl, sizeof(float **) * (trsmx->W+1));
  ESL_ALLOC(trsmx->fLalpha_begl, sizeof(float **) * (trsmx->W+1));
  ESL_ALLOC(trsmx->fRalpha_begl, sizeof(float **) * (trsmx->W+1));
  for (j = 0; j <= trsmx->W; j++) {
	ESL_ALLOC(trsmx->fJalpha_begl[j],  sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fJalpha_begl[0][v] will be NULL */
	ESL_ALLOC(trsmx->fLalpha_begl[j],  sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fLalpha_begl[0][v] will be NULL */
	ESL_ALLOC(trsmx->fRalpha_begl[j],  sizeof(float *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fRalpha_begl[0][v] will be NULL */
  }
  /* define ncells_alpha_begl with three separate statements (so we don't overflow, that was bug i40): */
  trsmx->ncells_alpha_begl  = (trsmx->W+1);
  trsmx->ncells_alpha_begl *= n_begl;
  trsmx->ncells_alpha_begl *= (trsmx->W+1);
  ESL_ALLOC(trsmx->fJalpha_begl_mem,   sizeof(float) * ESL_MAX(1, trsmx->ncells_alpha_begl)); // avoid 0 malloc
  ESL_ALLOC(trsmx->fLalpha_begl_mem,   sizeof(float) * ESL_MAX(1, trsmx->ncells_alpha_begl));
  ESL_ALLOC(trsmx->fRalpha_begl_mem,   sizeof(float) * ESL_MAX(1, trsmx->ncells_alpha_begl));

  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	for (j = 0; j <= trsmx->W; j++) {
	  if (cm->stid[v] == BEGL_S) {
	trsmx->fJalpha_begl[j][v] = trsmx->fJalpha_begl_mem + cur_cell;
	trsmx->fLalpha_begl[j][v] = trsmx->fLalpha_begl_mem + cur_cell;
	trsmx->fRalpha_begl[j][v] = trsmx->fRalpha_begl_mem + cur_cell;
	cur_cell += trsmx->W+1;
	  }
	  else {
	trsmx->fJalpha_begl[j][v] = NULL;
	trsmx->fLalpha_begl[j][v] = NULL;
	trsmx->fRalpha_begl[j][v] = NULL;
	  }
	}
  }
  if(cur_cell != trsmx->ncells_alpha_begl) ESL_FAIL(eslEINVAL, errbuf, "problem laying out truncated float scan matrix");

  /* set the flag that tells us we've got valid floats */
  trsmx->floats_valid = TRUE;

  /* Initialize matrix */
  if((status = cm_tr_scan_mx_InitializeFloats(cm, trsmx, errbuf)) != eslOK) return status;

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "out of memory (creating float truncated scan matrix)");
  return status; /* NOT REACHED */
}

/* Function: cm_tr_scan_mx_integerize()
 * Date:     EPN, Wed Aug 24 15:00:32 2011
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if internal consistency check of cell count fails.
 *           eslEMEM if out of memory.
 */
int
cm_tr_scan_mx_integerize(CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf)
{
  int status;
  int j, v;
  int n_begl, n_bif;
  int n_non_begl;
  int64_t cur_cell;

  /* allocate alpha
   * we allocate only as many cells as necessary,
   * for i{J,L,R}alpha,      we only allocate for non-BEGL_S states,
   * for i{J,L,R}alpha_begl, we only allocate for     BEGL_S states
   * for iTalpha,            we only allocate for     BIF_B  and ROOT_S states
   *
   * note: deck for the EL state, cm->M is never used for scanners
   */
  n_begl = 0;
  n_bif  = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BIF_B)  n_bif++;
  n_non_begl = cm->M - n_begl;

  /* allocate f{J,L,R,T}alpha */
  /* j == 0 v == 0 cells, followed by j == 1 v == 0, then j == 0 v == 1 etc.. */
  ESL_ALLOC(trsmx->iJalpha,        sizeof(int **) * 2);
  ESL_ALLOC(trsmx->iJalpha[0],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fJalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->iJalpha[1],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fJalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->iJalpha_mem,    sizeof(int) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->iLalpha,        sizeof(int **) * 2);
  ESL_ALLOC(trsmx->iLalpha[0],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fLalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->iLalpha[1],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fLalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->iLalpha_mem,    sizeof(int) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->iRalpha,        sizeof(int **) * 2);
  ESL_ALLOC(trsmx->iRalpha[0],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fRalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->iRalpha[1],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v == BEGL_S, fRalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->iRalpha_mem,    sizeof(int) * 2 * n_non_begl * (trsmx->W+1));

  ESL_ALLOC(trsmx->iTalpha,        sizeof(int **) * 2);
  ESL_ALLOC(trsmx->iTalpha[0],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BIF_B and v != ROOT_S, fTalpha[0][v] will be NULL */
  ESL_ALLOC(trsmx->iTalpha[1],     sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BIF_B and v != ROOT_S, fTalpha[1][v] will be NULL */
  ESL_ALLOC(trsmx->iTalpha_mem,    sizeof(int) * 2 * n_non_begl * (trsmx->W+1));

  /* define ncells_alpha in two statements to avoid potential overflow
   * (this is probably unnec, but is nec for ncells_alpha_begl so stay consistent)
   */
  trsmx->ncells_alpha  = 2 * n_non_begl;
  trsmx->ncells_alpha *= (trsmx->W+1);
  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] != BEGL_S) {
	  trsmx->iJalpha[0][v] = trsmx->iJalpha_mem + cur_cell;
	  trsmx->iLalpha[0][v] = trsmx->iLalpha_mem + cur_cell;
	  trsmx->iRalpha[0][v] = trsmx->iRalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	  trsmx->iJalpha[1][v] = trsmx->iJalpha_mem + cur_cell;
	  trsmx->iLalpha[1][v] = trsmx->iLalpha_mem + cur_cell;
	  trsmx->iRalpha[1][v] = trsmx->iRalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	}
	else {
	  trsmx->iJalpha[0][v] = NULL;
	  trsmx->iJalpha[1][v] = NULL;
	  trsmx->iLalpha[0][v] = NULL;
	  trsmx->iLalpha[1][v] = NULL;
	  trsmx->iRalpha[0][v] = NULL;
	  trsmx->iRalpha[1][v] = NULL;
	}
  }
  if(cur_cell != trsmx->ncells_alpha) ESL_FAIL(eslEINVAL, errbuf, "problem laying out truncated int scan matrix");

  trsmx->ncells_Talpha = 2 * (n_bif+1) * (trsmx->W+1);
  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	if (cm->stid[v] == BIF_B || cm->stid[v] == ROOT_S) {
	  trsmx->iTalpha[0][v] = trsmx->iTalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	  trsmx->iTalpha[1][v] = trsmx->iTalpha_mem + cur_cell;
	  cur_cell += trsmx->W+1;
	}
	else {
	  trsmx->iTalpha[0][v] = NULL;
	  trsmx->iTalpha[1][v] = NULL;
	}
  }
  if(cur_cell != trsmx->ncells_Talpha) ESL_FAIL(eslEINVAL, errbuf, "problem laying out int truncated scan matrix");

  /* allocate falpha_begl */
  /* j == d, v == 0 cells, followed by j == d+1, v == 0, etc. */
  ESL_ALLOC(trsmx->iJalpha_begl, sizeof(int **) * (trsmx->W+1));
  ESL_ALLOC(trsmx->iLalpha_begl, sizeof(int **) * (trsmx->W+1));
  ESL_ALLOC(trsmx->iRalpha_begl, sizeof(int **) * (trsmx->W+1));
  for (j = 0; j <= trsmx->W; j++) {
	ESL_ALLOC(trsmx->iJalpha_begl[j],  sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fJalpha_begl[0][v] will be NULL */
	ESL_ALLOC(trsmx->iLalpha_begl[j],  sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fLalpha_begl[0][v] will be NULL */
	ESL_ALLOC(trsmx->iRalpha_begl[j],  sizeof(int *) * (cm->M)); /* we still allocate cm->M ptrs, if v != BEGL_S, fRalpha_begl[0][v] will be NULL */
  }
  /* define ncells_alpha_begl with three separate statements (so we don't overflow, that was bug i40): */
  trsmx->ncells_alpha_begl  = (trsmx->W+1);
  trsmx->ncells_alpha_begl *= n_begl;
  trsmx->ncells_alpha_begl *= (trsmx->W+1);
  ESL_ALLOC(trsmx->iJalpha_begl_mem,   sizeof(int) * ESL_MAX(1, trsmx->ncells_alpha_begl));
  ESL_ALLOC(trsmx->iLalpha_begl_mem,   sizeof(int) * ESL_MAX(1, trsmx->ncells_alpha_begl));
  ESL_ALLOC(trsmx->iRalpha_begl_mem,   sizeof(int) * ESL_MAX(1, trsmx->ncells_alpha_begl));

  cur_cell = 0;
  for (v = 0; v < cm->M; v++) {
	for (j = 0; j <= trsmx->W; j++) {
	  if (cm->stid[v] == BEGL_S) {
	trsmx->iJalpha_begl[j][v] = trsmx->iJalpha_begl_mem + cur_cell;
	trsmx->iLalpha_begl[j][v] = trsmx->iLalpha_begl_mem + cur_cell;
	trsmx->iRalpha_begl[j][v] = trsmx->iRalpha_begl_mem + cur_cell;
	cur_cell += trsmx->W+1;
	  }
	  else {
	trsmx->iJalpha_begl[j][v] = NULL;
	trsmx->iLalpha_begl[j][v] = NULL;
	trsmx->iRalpha_begl[j][v] = NULL;
	  }
	}
  }
  if(cur_cell != trsmx->ncells_alpha_begl) ESL_FAIL(eslEINVAL, errbuf, "problem laying out truncated int scan matrix");

  /* set the flag that tells us we've got valid ints */
  trsmx->ints_valid = TRUE;

  /* Initialize matrix */
  if((status = cm_tr_scan_mx_InitializeIntegers(cm, trsmx, errbuf)) != eslOK) return status;

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "out of memory (creating int truncated scan matrix)");
  return status; /* NOT REACHED */
}

/* Function: cm_tr_scan_mx_InitializeFloats()
 * Date:     EPN, Tue Dec 27 11:09:42 2011
 *
 * Purpose:  Initialize float scores in a CM_TR_SCAN_MX. This
 *           should be done before using the scan matrix for
 *           a new target sequence.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if float matrix is not allocated.
 */
int
cm_tr_scan_mx_InitializeFloats(CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf)
{
  int v, j, y, w, yoffset;

  if(! trsmx->floats_valid) ESL_FAIL(eslEINVAL, errbuf, "cm_tr_scan_mx_InitializeFloats(), trsmx->floats_valid is FALSE");

  /* First, init entire matrix to IMPOSSIBLE */
  esl_vec_FSet(trsmx->fJalpha_mem,      trsmx->ncells_alpha,      IMPOSSIBLE);
  esl_vec_FSet(trsmx->fLalpha_mem,      trsmx->ncells_alpha,      IMPOSSIBLE);
  esl_vec_FSet(trsmx->fRalpha_mem,      trsmx->ncells_alpha,      IMPOSSIBLE);
  esl_vec_FSet(trsmx->fTalpha_mem,      trsmx->ncells_Talpha,     IMPOSSIBLE);
  esl_vec_FSet(trsmx->fJalpha_begl_mem, trsmx->ncells_alpha_begl, IMPOSSIBLE);
  esl_vec_FSet(trsmx->fLalpha_begl_mem, trsmx->ncells_alpha_begl, IMPOSSIBLE);
  esl_vec_FSet(trsmx->fRalpha_begl_mem, trsmx->ncells_alpha_begl, IMPOSSIBLE);
  /* Now, initialize cells that should not be IMPOSSIBLE in f{J,L,RT}alpha and f{J,L,R}alpha_begl */
  for(v = cm->M-1; v >= 0; v--) {
	if(cm->stid[v] != BEGL_S) {
	  if (cm->sttype[v] == E_st) {
	trsmx->fJalpha[0][v][0] = trsmx->fJalpha[1][v][0] = 0.;
	trsmx->fLalpha[0][v][0] = trsmx->fLalpha[1][v][0] = 0.;
	trsmx->fRalpha[0][v][0] = trsmx->fRalpha[1][v][0] = 0.;
	/* rest of E deck is IMPOSSIBLE, it's already set */
	  }
	  else if (cm->sttype[v] == S_st || cm->sttype[v] == D_st) {
	y = cm->cfirst[v];
	trsmx->fJalpha[0][v][0] = cm->endsc[v];
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	  trsmx->fJalpha[0][v][0] = ESL_MAX(trsmx->fJalpha[0][v][0], (trsmx->fJalpha[0][y+yoffset][0] + cm->tsc[v][yoffset]));
	trsmx->fJalpha[0][v][0] = ESL_MAX(trsmx->fJalpha[0][v][0], IMPOSSIBLE);
	/* {L,R}alpha[0][v][0] remain IMPOSSIBLE */
	  }
	  else if (cm->sttype[v] == B_st) {
	w = cm->cfirst[v]; /* BEGL_S, left child state */
	y = cm->cnum[v];
	trsmx->fJalpha[0][v][0] = trsmx->fJalpha_begl[0][w][0] + trsmx->fJalpha[0][y][0];
	  }
	  trsmx->fJalpha[1][v][0] = trsmx->fJalpha[0][v][0];
	  /* {L,R,T}alpha[{0,1}][v][0] remain IMPOSSIBLE */
	}
	else { /* v == BEGL_S */
	  y = cm->cfirst[v];
	  trsmx->fJalpha_begl[0][v][0] = cm->endsc[v];
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	trsmx->fJalpha_begl[0][v][0] = ESL_MAX(trsmx->fJalpha_begl[0][v][0], (trsmx->fJalpha[0][y+yoffset][0] + cm->tsc[v][yoffset])); /* careful: y is in trsmx->fJalpha */
	  trsmx->fJalpha_begl[0][v][0] = ESL_MAX(trsmx->fJalpha_begl[0][v][0], IMPOSSIBLE);
	  for (j = 1; j <= trsmx->W; j++)
	trsmx->fJalpha_begl[j][v][0] = trsmx->fJalpha_begl[0][v][0];
	  /* {L,R}alpha_begl[j][v][0] remain IMPOSSIBLE for all j */
	}
  }
  return eslOK;
}

/* Function: cm_tr_scan_mx_InitializeIntegers()
 * Date:     EPN, Tue Dec 27 11:10:35 2011
 *
 * Purpose:  Initialize integer scores in a CM_TR_SCAN_MX. This
 *           should be done before using the scan matrix for
 *           a new target sequence.
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if float matrix is not allocated.
 */
int
cm_tr_scan_mx_InitializeIntegers(CM_t *cm, CM_TR_SCAN_MX *trsmx, char *errbuf)
{
  int v, j, y, w, yoffset;

  if(! trsmx->ints_valid) ESL_FAIL(eslEINVAL, errbuf, "cm_tr_scan_mx_InitializeIntegers(), trsmx->ints_valid is FALSE");

  /* First, init entire matrix to -INFTY */
  esl_vec_ISet(trsmx->iJalpha_mem,      trsmx->ncells_alpha,      -INFTY);
  esl_vec_ISet(trsmx->iLalpha_mem,      trsmx->ncells_alpha,      -INFTY);
  esl_vec_ISet(trsmx->iRalpha_mem,      trsmx->ncells_alpha,      -INFTY);
  esl_vec_ISet(trsmx->iTalpha_mem,      trsmx->ncells_Talpha,     -INFTY);
  esl_vec_ISet(trsmx->iJalpha_begl_mem, trsmx->ncells_alpha_begl, -INFTY);
  esl_vec_ISet(trsmx->iLalpha_begl_mem, trsmx->ncells_alpha_begl, -INFTY);
  esl_vec_ISet(trsmx->iRalpha_begl_mem, trsmx->ncells_alpha_begl, -INFTY);
  /* Now, initialize cells that should not be -INFTY in f{J,L,RT}alpha and f{J,L,R}alpha_begl */
  for(v = cm->M-1; v >= 0; v--) {
	if(cm->stid[v] != BEGL_S) {
	  if (cm->sttype[v] == E_st) {
	trsmx->iJalpha[0][v][0] = trsmx->iJalpha[1][v][0] = 0.;
	trsmx->iLalpha[0][v][0] = trsmx->iLalpha[1][v][0] = 0.;
	trsmx->iRalpha[0][v][0] = trsmx->iRalpha[1][v][0] = 0.;
	/* rest of E deck is -INFTY, it's already set */
	  }
	  else if (cm->sttype[v] == S_st || cm->sttype[v] == D_st) {
	y = cm->cfirst[v];
	trsmx->iJalpha[0][v][0] = cm->endsc[v];
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	  trsmx->iJalpha[0][v][0] = ESL_MAX(trsmx->iJalpha[0][v][0], (trsmx->iJalpha[0][y+yoffset][0] + cm->itsc[v][yoffset]));
	trsmx->iJalpha[0][v][0] = ESL_MAX(trsmx->iJalpha[0][v][0], -INFTY);
	/* {L,R}alpha[0][v][0] remain -INFTY */
	  }
	  else if (cm->sttype[v] == B_st) {
	w = cm->cfirst[v]; /* BEGL_S, left child state */
	y = cm->cnum[v];
	trsmx->iJalpha[0][v][0] = trsmx->iJalpha_begl[0][w][0] + trsmx->iJalpha[0][y][0];
	  }
	  trsmx->iJalpha[1][v][0] = trsmx->iJalpha[0][v][0];
	  /* {L,R,T}alpha[{0,1}][v][0] remain -INFTY */
	}
	else { /* v == BEGL_S */
	  y = cm->cfirst[v];
	  trsmx->iJalpha_begl[0][v][0] = cm->endsc[v];
	  for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	trsmx->iJalpha_begl[0][v][0] = ESL_MAX(trsmx->iJalpha_begl[0][v][0], (trsmx->iJalpha[0][y+yoffset][0] + cm->itsc[v][yoffset])); /* careful: y is in trsmx->iJalpha */
	  trsmx->iJalpha_begl[0][v][0] = ESL_MAX(trsmx->iJalpha_begl[0][v][0], -INFTY);
	  for (j = 1; j <= trsmx->W; j++)
	trsmx->iJalpha_begl[j][v][0] = trsmx->iJalpha_begl[0][v][0];
	  /* {L,R}alpha_begl[j][v][0] remain -INFTY for all j */
	}
  }

  return eslOK;
}

/* Function: cm_tr_scan_mx_SizeNeeded()
 * Date:     EPN, Tue Dec 13 05:01:54 2011
 *
 * Purpose:  Predict the size needed in Mb to create a
 *           CM_TR_SCAN_MX for <cm>.
 *
 * Returns:  Size needed in Mb.
 */
float
cm_tr_scan_mx_SizeNeeded(CM_t *cm, int do_float, int do_int)
{
  int     n_begl             = 0;
  int     n_non_begl         = 0;
  int64_t ncells_alpha       = 0;
  int64_t ncells_alpha_begl  = 0;
  int64_t ncells_Talpha      = 0;
  int     v;
  float   Mb_needed = 0.;

  /* calculate number of cells in alpha and alpha_begl */
  n_begl = 0;
  for (v = 0; v < cm->M; v++) if (cm->stid[v] == BEGL_S) n_begl++;
  n_non_begl = cm->M - n_begl;
  /* use several statements to calculate ncells_alpha_*, otherwise we could overflow,
   * (the overflow was part of bug i40).
   */
  ncells_alpha       = 2;
  ncells_alpha      *= n_non_begl;
  ncells_alpha      *= (cm->W+1);
  ncells_alpha_begl  = (cm->W+1);
  ncells_alpha_begl *= n_begl;
  ncells_alpha_begl *= (cm->W+1);

  /* tally up size */
  Mb_needed  = (float) sizeof(CM_SCAN_MX);
  Mb_needed += (float) sizeof(int **)  * NSMX_QDB_IDX;                      /* dnAAA (1st dim) */
  Mb_needed += (float) sizeof(int **)  * NSMX_QDB_IDX;                      /* dxAAA (1st dim) */
  Mb_needed += (float) sizeof(int  *)  * NSMX_QDB_IDX * (cm->W+1);          /* dnAAA (2nd dim) */
  Mb_needed += (float) sizeof(int  *)  * NSMX_QDB_IDX * (cm->W+1);          /* dxAAA (2nd dim) */
  Mb_needed += (float) sizeof(int)     * NSMX_QDB_IDX * (cm->W+1) * cm->M;  /* dnAAA (3rd dim) */
  Mb_needed += (float) sizeof(int)     * NSMX_QDB_IDX * (cm->W+1) * cm->M;  /* dnAAA (3rd dim) */
  Mb_needed += (float) sizeof(int)     * (cm->W+1);                         /* bestr  */
  Mb_needed += (float) sizeof(float)   * (cm->W+1);                         /* bestsc */
  if(do_float) {
	Mb_needed += (float) sizeof(float) * ncells_alpha;                      /* fJalpha     */
	Mb_needed += (float) sizeof(float) * ncells_alpha;                      /* fLalpha     */
	Mb_needed += (float) sizeof(float) * ncells_alpha;                      /* fRalpha     */
	Mb_needed += (float) sizeof(float) * ncells_Talpha;                     /* fTalpha     */
	Mb_needed += (float) sizeof(float) * ncells_alpha_begl;                 /* fJalpha_begl */
	Mb_needed += (float) sizeof(float) * ncells_alpha_begl;                 /* fLalpha_begl */
	Mb_needed += (float) sizeof(float) * ncells_alpha_begl;                 /* fRalpha_begl */
  }
  if(do_int) {
	Mb_needed += (float) sizeof(int)   * ncells_alpha;                      /* iJalpha     */
	Mb_needed += (float) sizeof(int)   * ncells_alpha;                      /* iLalpha     */
	Mb_needed += (float) sizeof(int)   * ncells_alpha;                      /* iRalpha     */
	Mb_needed += (float) sizeof(int)   * ncells_Talpha;                     /* iTalpha     */
	Mb_needed += (float) sizeof(int)   * ncells_alpha_begl;                 /* iJalpha_begl */
	Mb_needed += (float) sizeof(int)   * ncells_alpha_begl;                 /* iLalpha_begl */
	Mb_needed += (float) sizeof(int)   * ncells_alpha_begl;                 /* iRalpha_begl */
  }
  Mb_needed *= 0.000001; /* convert to Mb */

  return Mb_needed;
}

/* Function: cm_tr_scan_mx_Destroy()
 * Date:     EPN, Wed Aug 17 14:22:45 2011
 *
 * Purpose:  Free a CM_TR_SCAN_MX object corresponding
 *           to CM <cm>.
 *
 * Returns:  void
 */
void
cm_tr_scan_mx_Destroy(CM_t *cm, CM_TR_SCAN_MX *trsmx)
{
  int n, j;

  for(n = 0; n < NSMX_QDB_IDX; n++) {
	for(j = 1; j <= trsmx->W; j++) {
	  free(trsmx->dnAAA[n][j]);
	  free(trsmx->dxAAA[n][j]);
	}
	free(trsmx->dnAAA[n]);
	free(trsmx->dxAAA[n]);
  }
  free(trsmx->dnAAA);
  free(trsmx->dxAAA);
  free(trsmx->bestr);
  free(trsmx->bestsc);
  free(trsmx->bestmode);

  if(trsmx->floats_valid) cm_tr_scan_mx_freefloats  (cm, trsmx);
  if(trsmx->ints_valid)   cm_tr_scan_mx_freeintegers(cm, trsmx);

  free(trsmx);
  return;
}

/* Function: cm_tr_scan_mx_freefloats()
 * Date:     EPN, Wed Aug 17 14:19:21 2011
 *
 * Purpose:  Free float data structures in a CM_TR_SCAN_MX object
 *           corresponding to <cm>.
 *
 * Returns:  eslOK on success
 */
int
cm_tr_scan_mx_freefloats(CM_t *cm, CM_TR_SCAN_MX *trsmx)
{
  int j;

  if(trsmx->fJalpha_mem != NULL) free(trsmx->fJalpha_mem);
  if(trsmx->fJalpha     != NULL) {
	if(trsmx->fJalpha[1]  != NULL) free(trsmx->fJalpha[1]);
	if(trsmx->fJalpha[0]  != NULL) free(trsmx->fJalpha[0]);
	free(trsmx->fJalpha);
	trsmx->fJalpha = NULL;
  }
  if(trsmx->fLalpha_mem != NULL) free(trsmx->fLalpha_mem);
  if(trsmx->fLalpha     != NULL) {
	if(trsmx->fLalpha[1]  != NULL) free(trsmx->fLalpha[1]);
	if(trsmx->fLalpha[0]  != NULL) free(trsmx->fLalpha[0]);
	free(trsmx->fLalpha);
	trsmx->fLalpha = NULL;
  }
  if(trsmx->fRalpha_mem != NULL) free(trsmx->fRalpha_mem);
  if(trsmx->fRalpha     != NULL) {
	if(trsmx->fRalpha[1]  != NULL) free(trsmx->fRalpha[1]);
	if(trsmx->fRalpha[0]  != NULL) free(trsmx->fRalpha[0]);
	free(trsmx->fRalpha);
	trsmx->fRalpha = NULL;
  }
  if(trsmx->fTalpha_mem != NULL) free(trsmx->fTalpha_mem);
  if(trsmx->fTalpha     != NULL) {
	if(trsmx->fTalpha[1]  != NULL) free(trsmx->fTalpha[1]);
	if(trsmx->fTalpha[0]  != NULL) free(trsmx->fTalpha[0]);
	free(trsmx->fTalpha);
	trsmx->fTalpha = NULL;
  }

  if(trsmx->fJalpha_begl_mem != NULL) {
	free(trsmx->fJalpha_begl_mem);
  }
  if(trsmx->fJalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->fJalpha_begl[j] != NULL) free(trsmx->fJalpha_begl[j]);
	}
	free(trsmx->fJalpha_begl);
	trsmx->fJalpha_begl = NULL;
  }
  if(trsmx->fLalpha_begl_mem != NULL) {
	free(trsmx->fLalpha_begl_mem);
  }
  if(trsmx->fLalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->fLalpha_begl[j] != NULL) free(trsmx->fLalpha_begl[j]);
	}
	free(trsmx->fLalpha_begl);
	trsmx->fLalpha_begl = NULL;
  }
  if(trsmx->fRalpha_begl_mem != NULL) {
	free(trsmx->fRalpha_begl_mem);
  }
  if(trsmx->fRalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->fRalpha_begl[j] != NULL) free(trsmx->fRalpha_begl[j]);
	}
	free(trsmx->fRalpha_begl);
	trsmx->fRalpha_begl = NULL;
  }

  trsmx->floats_valid = FALSE;
  return eslOK;
}

/* Function: cm_tr_scan_mx_freeintegers()
 * Date:     EPN, Wed Aug 24 14:56:18 2011
 *
 * Purpose:  Free int data structures in a CM_TR_SCAN_MX object
 *           corresponding to <cm>.
 *
 * Returns:  eslOK on success
 */
int
cm_tr_scan_mx_freeintegers(CM_t *cm, CM_TR_SCAN_MX *trsmx)
{
  int j;

  if(trsmx->iJalpha_mem != NULL) free(trsmx->iJalpha_mem);
  if(trsmx->iJalpha     != NULL) {
	if(trsmx->iJalpha[1]  != NULL) free(trsmx->iJalpha[1]);
	if(trsmx->iJalpha[0]  != NULL) free(trsmx->iJalpha[0]);
	free(trsmx->iJalpha);
	trsmx->iJalpha = NULL;
  }
  if(trsmx->iLalpha_mem != NULL) free(trsmx->iLalpha_mem);
  if(trsmx->iLalpha     != NULL) {
	if(trsmx->iLalpha[1]  != NULL) free(trsmx->iLalpha[1]);
	if(trsmx->iLalpha[0]  != NULL) free(trsmx->iLalpha[0]);
	free(trsmx->iLalpha);
	trsmx->iLalpha = NULL;
  }
  if(trsmx->iRalpha_mem != NULL) free(trsmx->iRalpha_mem);
  if(trsmx->iRalpha     != NULL) {
	if(trsmx->iRalpha[1]  != NULL) free(trsmx->iRalpha[1]);
	if(trsmx->iRalpha[0]  != NULL) free(trsmx->iRalpha[0]);
	free(trsmx->iRalpha);
	trsmx->iRalpha = NULL;
  }
  if(trsmx->iTalpha_mem != NULL) free(trsmx->iTalpha_mem);
  if(trsmx->iTalpha     != NULL) {
	if(trsmx->iTalpha[1]  != NULL) free(trsmx->iTalpha[1]);
	if(trsmx->iTalpha[0]  != NULL) free(trsmx->iTalpha[0]);
	free(trsmx->iTalpha);
	trsmx->iTalpha = NULL;
  }

  if(trsmx->iJalpha_begl_mem != NULL) {
	free(trsmx->iJalpha_begl_mem);
  }
  if(trsmx->iJalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->iJalpha_begl[j] != NULL) free(trsmx->iJalpha_begl[j]);
	}
	free(trsmx->iJalpha_begl);
	trsmx->iJalpha_begl = NULL;
  }
  if(trsmx->iLalpha_begl_mem != NULL) {
	free(trsmx->iLalpha_begl_mem);
  }
  if(trsmx->iLalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->iLalpha_begl[j] != NULL) free(trsmx->iLalpha_begl[j]);
	}
	free(trsmx->iLalpha_begl);
	trsmx->iLalpha_begl = NULL;
  }
  if(trsmx->iRalpha_begl_mem != NULL) {
	free(trsmx->iRalpha_begl_mem);
  }
  if(trsmx->iRalpha_begl != NULL) {
	for (j = 0; j <= trsmx->W; j++) {
	  if(trsmx->iRalpha_begl[j] != NULL) free(trsmx->iRalpha_begl[j]);
	}
	free(trsmx->iRalpha_begl);
	trsmx->iRalpha_begl = NULL;
  }

  trsmx->ints_valid = FALSE;
  return eslOK;
}

/* Function: cm_tr_scan_mx_Dump()
 * Date:     EPN, Thu Aug 18 07:35:20 2011
 *
 * Purpose:  Dump current {J,L,R,T}alpha matrices from a CM_TR_SCAN_MX (either float or int).
 *
 * Returns:  void.
 */
void
cm_tr_scan_mx_Dump(FILE *ofp, CM_t *cm, int j, int i0, int qdbidx, int doing_float)
{
  int d, v;
  int jp_g = j-i0+1; /* j is actual index in j, jp_g is offset j relative to start i0 (index in gamma* data structures) */
  int cur = j%2;
  int prv = (j-1)%2;
  int *dnA, *dxA;

  CM_TR_SCAN_MX *trsmx = cm->trsmx;
  if(   doing_float  && (! trsmx->floats_valid)) cm_Fail("cm_tr_scan_mx_Dump(), trying to print float alpha, but floats are not valid");
  if((! doing_float) && (! trsmx->ints_valid))   cm_Fail("cm_tr_scan_mx_Dump(), trying to print int   alpha, but ints   are not valid");

  int begl_prv = j-1 % (trsmx->W+1);
  int begl_cur = j   % (trsmx->W+1);

  fprintf(ofp, "Dumping {J,L,R,T}Alpha: j: %d\n", j);
  if(jp_g >= trsmx->W) { dnA = trsmx->dnAAA[qdbidx][trsmx->W]; dxA = trsmx->dxAAA[qdbidx][trsmx->W]; }
  else                 { dnA = trsmx->dnAAA[qdbidx][jp_g];     dxA = trsmx->dxAAA[qdbidx][jp_g]; }
  if(doing_float) {
	for (v = trsmx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fJalpha_begl[begl_prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fLalpha_begl[begl_prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fRalpha_begl[begl_prv][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fJalpha[prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fLalpha[prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fRalpha[prv][v][d]);
	  }
	  if(cm->stid[v] == BIF_B) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "TA[j-1:%4d][%4d][%4d]: %10.4f\n", (j-1), v, d, trsmx->fTalpha[prv][v][d]);
	  }
	  fprintf(ofp, "\n");
	}
	for (v = trsmx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fJalpha_begl[begl_cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fLalpha_begl[begl_cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fRalpha_begl[begl_cur][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fJalpha[cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fLalpha[cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fRalpha[cur][v][d]);
	  }
	  if(cm->stid[v] == BIF_B) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "TA[j  :%4d][%4d][%4d]: %10.4f\n", j,     v, d, trsmx->fTalpha[cur][v][d]);
	  }
	  fprintf(ofp, "\n");
	}
  }
  else { /* doing int */
	for (v = trsmx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iJalpha_begl[begl_prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iLalpha_begl[begl_prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iRalpha_begl[begl_prv][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iJalpha[prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iLalpha[prv][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iRalpha[prv][v][d]);
	  }
	  if(cm->stid[v] == BIF_B) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "TA[j-1:%4d][%4d][%4d]: %10d\n", (j-1), v, d, trsmx->iTalpha[prv][v][d]);
	  }
	  fprintf(ofp, "\n\n");
	}
	for (v = trsmx->M-1; v >= 0; v--) {
	  if (cm->stid[v] == BEGL_S) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iJalpha_begl[begl_cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iLalpha_begl[begl_cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iRalpha_begl[begl_cur][v][d]);
	  }
	  else {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "JA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iJalpha[cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "LA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iLalpha[cur][v][d]);
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "RA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iRalpha[cur][v][d]);
	  }
	  if(cm->stid[v] == BIF_B) {
	for(d = dnA[v]; d <= dxA[v]; d++) fprintf(ofp, "TA[j  :%4d][%4d][%4d]: %10d\n", j,     v, d, trsmx->iTalpha[cur][v][d]);
	  }
	  fprintf(ofp, "\n\n");
	}
  }
  return;
}

/*****************************************************************
 *  15. GammaHitMx_t data structure functions,
 *      Semi HMM data structure for optimal resolution of overlapping
 *      hits for CM DP search functions.
 *****************************************************************/

/* Function: CreateGammaHitMx()
 * Date:     EPN, Mon Nov  5 05:22:56 2007
 *
 * Purpose:  Allocate and initialize a gamma semi-HMM for
 *           optimal hit resolution of a CM based scan.
 *
 * Returns:  Newly allocated GammaHitMx_t object:
 */
GammaHitMx_t *
CreateGammaHitMx(int L, int64_t i0, float cutoff)
{
  int status;
  GammaHitMx_t *gamma;
  ESL_ALLOC(gamma, sizeof(GammaHitMx_t));

  gamma->L  = L;
  gamma->i0 = i0;
  gamma->cutoff    = cutoff;
  /* allocate/initialize for CYK/Inside */
  ESL_ALLOC(gamma->mx,       sizeof(float) * (L+1));
  ESL_ALLOC(gamma->gback,    sizeof(int)   * (L+1));
  ESL_ALLOC(gamma->savesc,   sizeof(float) * (L+1));
  ESL_ALLOC(gamma->saver,    sizeof(int)   * (L+1));
  ESL_ALLOC(gamma->savemode, sizeof(int)   * (L+1));

  gamma->mx[0]    = 0;
  gamma->gback[0] = -1;

  return gamma;

 ERROR:
  return NULL;
}

/* Function: FreeGammaHitMx()
 * Date:     EPN, Mon Nov  5 05:32:00 2007
 *
 * Purpose:  Free a gamma semi-HMM.
 *
 * Returns:  void;
 */
void
FreeGammaHitMx(GammaHitMx_t *gamma)
{
  free(gamma->mx);
  free(gamma->gback);
  free(gamma->savesc);
  free(gamma->saver);
  free(gamma->savemode);
  free(gamma);

  return;
}

/* Function: UpdateGammaHitMx()
 * Date:     EPN, Mon Nov  5 05:41:14 2007
 *           EPN, Mon Aug 22 08:54:56 2011 (search_results_t --> CM_TOPHITS)
 *
 * Purpose:  Update a non-greedy gamma semi-HMM for CM hits that end
 *           at gamma-relative position <j>.
 *
 *           Can be called from either standard or truncated scanning
 *           functions. <bestsc[d]>, <bestr[d]>, <bestmode[d]> report
 *           the maximum scoring hit of length d, its root state (0
 *           for glocal, !=0 for local or truncated), and its marginal
 *           mode (if truncated) . They are all allocated for 0..W,
 *           but only dmin..dmax should be considered valid.
 *
 *           If caller is a truncated scanner <bestmode> will be
 *           non-NULL, and include info on the alignment mode of each
 *           hit (<bestmode>). Some hits will be disallowed based
 *           on their alignment mode (e.g. 5' truncated hits must
 *           include residue i0 in their alignment to be allowed,
 *           see cm_tophits.c:cm_hit_AllowTruncation() for more
 *           information).

 *           If bestmode is NULL (caller is non-truncated scanner),
 *           all hits are implictly TRMODE_J mode.
 *
 *           If <bestsc> is NULL (caller is an HMM banded scanner) then
 *           no hit ending at j is possible given the HMM bands, so
 *           position j of the gamma matrix is simply initialized and
 *           then we return. Also if dmin > dmax, no valid d for this
 *           j exists, so we also just initialize and return.
 *
 *           This function should only be called if gamma->i_am_greedy
 *           is FALSE. In this case we store information on the best
 *           score at each position and then traceback later with a
 *           TBackGammaHitMx() call. For greedy gamma matrices, we use
 *           ReportHitsGreedily(), which reports hits immediately.
 *
 * Args:     cm         - the model, used only for its alphabet and null model
 *           errbuf     - for reporting errors
 *           pass_idx   - pipeline pass index we're currently in, dictates which
 *                        types of marginal hits to allow
 *           gamma      - the gamma data structure
 *           j          - end point of hit, in actual sequence coordinate space
 *           dmin       - minimum d to consider
 *           dmax       - maximum d to consider
 *           bestsc     - [0..W]; only [dmin..dmax] valid: best scores for current j, copied from alpha matrix(es) by caller
 *           bestr      - [0..W]; only [dmin..dmax] valid: root state (0 or local entry) corresponding to hit stored in alpha_row
 *           bestmode   - [0..W]; only [dmin..dmax] valid: marginal mode that gives bestsc[d], if NULL, all modes are implictly TRMODE_J
 *           tro       - truncated scanner info, must we enforce i0/j0 be in any valid hit?, NULL if caller is not a truncated scanner
 *           W          - window size, max size of a hit, only used if we're doing a NULL3 correction (act != NULL)
 *           act        - [0..j..W-1][0..a..abc->K-1], alphabet count, count of residue a in dsq from 1..jp where j = jp%(W+1)
 *
 * Returns:  eslOK on success
 * Throws:   eslEMEM on memory allocation error
 */
int
UpdateGammaHitMx(CM_t *cm, char *errbuf, int pass_idx, GammaHitMx_t *gamma, int j, int dmin, int dmax,
		 float *bestsc, int *bestr, char *bestmode, int W, double **act)
{
  int status;          /* easel status */
  int i;               /* position of first residue in hit, in actual sequence coordinates */
  int ip;              /* position of first residue in hit, in gamma/act coordinates */
  int jp;              /* position of final residue in hit, in gamma/act coordinates */
  int d;               /* hit length, d=j-i+1 */
  char mode;           /* marginal alignment mode */
  int   do_report_hit; /* should we add info on this hit to gamma? */
  float hit_sc;        /* score for this hit, possibly null3-corrected */
  float cumulative_sc; /* cumulative score of all hits in gamma, up to j */
  int   j0 = gamma->i0+gamma->L-1;

  /* variables related to NULL3 penalty */
  float *comp = NULL;            /* 0..a..cm->abc-K-1, the composition of residue a within the hit being reported */
  int    a;                      /* counter for alphabet */
  float  null3_correction = 0.;  /* null 3 penalty */

  /* j is in actual sequence coordinates, jp will be in gamma coordinates (offset by gamma->i0) */
  jp = j - gamma->i0 + 1;

  /* initialize */
  gamma->mx[jp]       = gamma->mx[jp-1] + 0;
  gamma->gback[jp]    = -1;
  gamma->savesc[jp]   = IMPOSSIBLE;
  gamma->saver[jp]    = -1;
  gamma->savemode[jp] = -1;

  if(bestsc == NULL || dmin > dmax) return eslOK; /* don't report any hits */

  if(act != NULL) ESL_ALLOC(comp, sizeof(float) * cm->abc->K);
  for (d = ESL_MAX(1, dmin); d <= dmax; d++) { /* don't allow length 0 hits, they cause all sorts of problems */
	i  = j -d+1;
	ip = jp-d+1;
	mode   = (bestmode == NULL) ? TRMODE_J : bestmode[d];
	hit_sc = bestsc[d];
	cumulative_sc = gamma->mx[ip-1] + hit_sc;
	/* printf("CAND hit %3d..%3d: %8.2f\n", i, j, hit_sc); */
	if (cumulative_sc > gamma->mx[jp] && NOT_IMPOSSIBLE(hit_sc)) {
	  do_report_hit = TRUE;

	  if(bestmode != NULL) {
	/* we're in truncated mode, check if we should allow the hit.
	 * this enforces that i0/j0 is included if necessary based on the
	 * marginal alignment mode of the hit
	 */
	do_report_hit = cm_hit_AllowTruncation(cm, pass_idx, i, j, gamma->i0, j0, mode, bestr[d]);
	  }

	  if(do_report_hit && act != NULL) {
	/* do a NULL3 score correction */
	for(a = 0; a < cm->abc->K; a++) {
	  comp[a] = act[jp%(W+1)][a] - act[(ip-1)%(W+1)][a];
	  /*printf("a: %5d jp/W: %5d ip-1/W: %5d jp[a]: %.3f ip-1[a]: %.3f c[a]: %.3f\n", a, jp%(W+1), (ip-1%W), act[(jp%(W+1))][a], act[((ip-1)%(W+1))][a], comp[a]);*/
	}
	esl_vec_FNorm(comp, cm->abc->K);
	ScoreCorrectionNull3(cm->abc, cm->null, comp, d, cm->null3_omega, &null3_correction);
	hit_sc -= null3_correction;
	cumulative_sc -= null3_correction;
	do_report_hit = (cumulative_sc > gamma->mx[jp]) ? TRUE : FALSE;
	/* printf("GOOD hit %3d..%3d: %8.2f  %10.6f  %8.2f\n", i, j, hit_sc+null3_correction, null3_correction, hit_sc); */
	  }

	  if(do_report_hit) {
	/* printf("\t%.3f %.3f\n", hit_sc+null3_correction, hit_sc); */
	gamma->mx[jp]       = cumulative_sc;
	gamma->gback[jp]    = i;
	gamma->savesc[jp]   = hit_sc;
	gamma->saver[jp]    = bestr[d];
	gamma->savemode[jp] = mode;
	  }
	}
  }
  if(comp != NULL) free(comp);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return eslEMEM; /* NEVERREACHED */
}

/* Function: ReportHitsGreedily()
 * Date:     EPN, Fri Nov  4 14:01:10 2011
 *
 * Purpose:  Report hits when using the greedy hit resolution
 *           strategy. For the non-greedy strategy, see
 *           UpdateGammaHitMx().
 *
 *           If caller is a truncated scanner <bestmode> will be
 *           non-NULL, and include info on the alignment mode of each
 *           hit (<bestmode>). Some hits will be disallowed based on
 *           their alignment mode and the pass_idx (e.g. 5' truncated
 *           hits in the PLI_PASS_5P_ONLY_FORCE pass must include
 *           residue i0 in their alignment to be allowed, see
 *           cm_tophits.c:cm_hit_AllowTruncation() for more
 *           information).
 *
 *           If caller is a standard (non-truncated) scanner
 *           <bestmode> will be NULL. All hits will implicitly be of
 *           the TRMODE_J mode and no hits are disallowed.
 *
 * Returns:  eslOK on success
 * Throws:   eslEMEM on memory allocation error
 */
int
ReportHitsGreedily(CM_t *cm, char *errbuf, int pass_idx, int j, int dmin, int dmax, float *bestsc, int *bestr,
		   char *bestmode, int W, double **act, int64_t i0, int64_t j0, float cutoff, CM_TOPHITS *hitlist)
{
  int   status;          /* easel status */
  int   i;               /* first residue in hit, in actual sequence coords */
  int   ip;              /* first residue in hit, in act vector coords */
  int   jp;              /* first residue in hit, in act vector coords */
  int   d;               /* hit length, d=j-i+1 */
  char  mode;            /* marginal alignment mode */
  int   do_report_hit;   /* should we add create a hit for current d? */
  float hit_sc;          /* score for this hit, possibly null3-corrected */
  float max_sc_reported; /* max score of all hits thus far reported */
  CM_HIT *hit = NULL;    /* a hit */

  /* variables related to NULL3 penalty */
  float *comp = NULL;            /* 0..a..cm->abc-K-1, the composition of residue a within the hit being reported */
  int    a;                      /* counter for alphabet */
  float  null3_correction = 0.;  /* null 3 penalty */

  if(bestsc == NULL || dmin > dmax) return eslOK; /* don't report any hits */

  /* In greedy mode, we are resolving overlaps greedily (RSEARCH
   * style). We'll have to remove overlaps after all hits are
   * reported (i.e. many calls to this function with many different
   * j values) but we don't have to report all hits above cutoff for
   * this j. Specifically, at the given j, any hit with a d of d1 is
   * guaranteed to mask any hit of lesser score with a d > d1.  So,
   * we step through all d starting at dmin and going up to dmax,
   * only reporting those that exceed our cutoffs *and* are greater
   * than maximum seen thus far.
   */
  max_sc_reported = IMPOSSIBLE;
  if(act != NULL) ESL_ALLOC(comp, sizeof(float) * cm->abc->K);
  for (d = ESL_MAX(1, dmin); d <= dmax; d++) { /* don't allow length 0 hits, they cause all sorts of problems */
	i  = j-d+1;
	mode = (bestmode == NULL) ? TRMODE_J : bestmode[d];
	hit_sc = bestsc[d];
	if (hit_sc >  max_sc_reported && /* hit of length d is best seen so far */
	hit_sc >= cutoff          && /* hit of length d has sc >= cutoff */
	NOT_IMPOSSIBLE(hit_sc))      /* safety: hit does not have IMPOSSIBLE sc */
	  {
	do_report_hit = TRUE;

	if(bestmode != NULL) {
	  /* we're in truncated mode, check if we should allow the hit.
	   * this enforces that i0/j0 is included if necessary based on the
	   * marginal alignment mode of the hit
	   */
	  do_report_hit = cm_hit_AllowTruncation(cm, pass_idx, i, j, i0, j0, mode, bestr[d]);
	}

	if(do_report_hit && act != NULL) { /* do NULL3 score correction and see if we still want to allow it */
	  ip = i - i0 + 1;
	  jp = j - i0 + 1;
	  for(a = 0; a < cm->abc->K; a++) comp[a] = act[jp%(W+1)][a] - act[(ip-1)%(W+1)][a];
	  esl_vec_FNorm(comp, cm->abc->K);
	  ScoreCorrectionNull3(cm->abc, cm->null, comp, d, cm->null3_omega, &null3_correction);
	  hit_sc -= null3_correction;
	  /* reevaluate do_report_hit: has null3_correction dropped us below our cutoffs? */
	  do_report_hit = (hit_sc > max_sc_reported && hit_sc >= cutoff) ? TRUE : FALSE;
	}

	if(do_report_hit) { /* this may have been set to FALSE if we did a null3 sc correction */
	  /*printf("\t%.3f %.3f i: %d j: %d r: %d mode: %d\n", hit_sc+null3_correction, hit_sc, i, j, bestr[d], mode);*/
	  cm_tophits_CreateNextHit(hitlist, &hit);
	  hit->start   = i;
	  hit->stop    = j;
	  hit->root    = bestr[d];
	  hit->mode    = mode;
	  hit->score   = hit_sc;
	  hit->hmmonly = FALSE;
	  max_sc_reported = hit_sc;
	}
	  }
  }
  if(comp != NULL) free(comp);
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.\n");
  return eslEMEM; /* NEVERREACHED */
}

/* Function: TBackGammaHitMx()
 * Date:     EPN, Mon Nov  5 10:14:30 2007
 *
 * Purpose:  Traceback with a gamma semi-HMM for CM hits.
 *           gamma->iamgreedy should be FALSE.
 *
 * Returns:  void; dies immediately upon an error.
 */
void
TBackGammaHitMx(GammaHitMx_t *gamma, CM_TOPHITS *hitlist, int64_t i0, int64_t j0)
{
  int j, jp_g;
  CM_HIT *hit = NULL;

  if(hitlist == NULL)  cm_Fail("cm_TBackGammaHitMx(), hitlist == NULL");
  /* Recover all hits: an (i,j,sc) triple for each one.
   */
  j = j0;
  while (j >= i0) {
	jp_g = j-i0+1;
	/*printf("TBACK j: %d sc: %.2f\n", j, gamma->savesc[jp_g]);*/
	if (gamma->gback[jp_g] == -1) j--; /* no hit */
	else {              /* a hit, a palpable hit */
	  if(gamma->savesc[jp_g] >= gamma->cutoff) {
	/* report the hit */
	/*ReportHit(gamma->gback[jp_g], j, gamma->saver[jp_g], gamma->savesc[jp_g], results);*/
	cm_tophits_CreateNextHit(hitlist, &hit);
	hit->start   = gamma->gback[jp_g];
	hit->stop    = j;
	hit->root    = gamma->saver[jp_g];
	hit->mode    = gamma->savemode[jp_g];
	hit->score   = gamma->savesc[jp_g];
	hit->hmmonly = FALSE;
	  }
	  j = gamma->gback[jp_g]-1;
	}
  }
  return;
}

/*** End of inlined file: cm_mx.c ***/


/*** Start of inlined file: cm_parsetree.c ***/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>


static float get_femission_score      (CM_t *cm, ESL_DSQ *dsq, int v, int i, int j);
static float get_femission_score_trunc(CM_t *cm, ESL_DSQ *dsq, int v, int i, int j, char mode);
static float sample_helper(ESL_RANDOMNESS *r, float *pA, int *validA, int n, int *ret_choice);

/* Function: CreateParsetree()
 * Incept:   SRE 29 Feb 2000 [Seattle] from cove2.0 code.
 *
 * Purpose:  Creates a parse tree structure.
 *           The first operation on a newly created tree is
 *           generally to add the root:
 *           InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 0, L-1, 0);
 *
 * Return:   ptr to the new tree.
 */
Parsetree_t *
CreateParsetree(int size)
{
  int status;
  Parsetree_t *new;

  ESL_ALLOC(new, sizeof(Parsetree_t));
  new->memblock = 25;		/* allocation block size can be optimized here if you want. */
  new->nalloc   = size;
  ESL_ALLOC(new->emitl, sizeof(int) * new->nalloc);
  ESL_ALLOC(new->emitr, sizeof(int) * new->nalloc);
  ESL_ALLOC(new->state, sizeof(int) * new->nalloc);
  ESL_ALLOC(new->mode,  sizeof(char) * new->nalloc);
  ESL_ALLOC(new->nxtl,  sizeof(int) * new->nalloc);
  ESL_ALLOC(new->nxtr,  sizeof(int) * new->nalloc);
  ESL_ALLOC(new->prv,   sizeof(int) * new->nalloc);
  new->n = 0;
  new->is_std    = TRUE;
  new->trpenalty = 0.;
  new->pass_idx  = PLI_PASS_STD_ANY;
  return new;
 ERROR:
  cm_Fail("ERROR allocated parsetree.\n");
  return NULL; /* never reached */
}

/* Function: GrowParsetree()
 * Incept:   SRE 1 March 2000 [Seattle]
 *
 * Purpose:  Increase the number of available nodes in a parse tree.
 */
void
GrowParsetree(Parsetree_t *tr)
{
  int   status;
  void *tmp;
  tr->nalloc += tr->memblock;
  ESL_RALLOC(tr->emitl, tmp, sizeof(int) * tr->nalloc);
  ESL_RALLOC(tr->emitr, tmp, sizeof(int) * tr->nalloc);
  ESL_RALLOC(tr->state, tmp, sizeof(int) * tr->nalloc);
  ESL_RALLOC(tr->mode,  tmp, sizeof(char) * tr->nalloc);
  ESL_RALLOC(tr->nxtl,  tmp, sizeof(int) * tr->nalloc);
  ESL_RALLOC(tr->nxtr,  tmp, sizeof(int) * tr->nalloc);
  ESL_RALLOC(tr->prv,   tmp, sizeof(int) * tr->nalloc);
  return;

 ERROR:
  cm_Fail("ERROR growing parsetree.\n");
}

/* Function: FreeParsetree()
 * Incept:   SRE 1 March 2000 [Seattle]
 *
 * Purpose:  Destroy a parse tree.
 */
void
FreeParsetree(Parsetree_t *tr)
{
  free(tr->emitl);
  free(tr->emitr);
  free(tr->state);
  free(tr->mode);
  free(tr->nxtl);
  free(tr->nxtr);
  free(tr->prv);
  free(tr);
}

/* Function: SizeofParsetree()
 * Incept:   EPN, Wed Dec  2 17:26:45 2009
 *
 * Purpose:  Return the allocated size of a parsetree in Mb.
 */
float
SizeofParsetree(Parsetree_t *tr)
{
  float Mb;

  Mb = 0.;
  Mb += 3 * sizeof(int); /* n, nalloc, memblock */
  Mb += tr->nalloc * (sizeof(int)) * 6;
  Mb += tr->nalloc * (sizeof(char)) * 1;
  Mb /= 1000000.;
  /* 6 = emitl,emitr,state,nxtl,nxtr,prv */
  /* 1 = mode */
  return Mb;
}

/* Function: InsertTraceNodewithMode()
 * Incept:   SRE 1 March 2000 [Seattle]
 *
 * Purpose:  Insert a new node in a trace tree, attached to node y,
 *           either TRACE_LEFT_CHILD or TRACE_RIGHT_CHILD.
 *
 *           Before:                             After:
 *                 y                                  y
 *               /   \                              /   \
 *              a     b                            n     b
 *                                                / \
 *                                               a   -
 *           The new node has index tr->n.
 *           GrowTrace() if necessary.
 *           The new node n gets connectivity:
 *                  l = a
 *                  r = 1 (a dummy state, e.g. nothing)
 *                prv = y
 *           The old node y gets connectivity :
 *             l or r = n
 *           The downstream node a gets a new parent:
 *                if (a != 1) a's prv = n
 *
 *           Usually we're attaching a node, so a and b are the
 *           terminal dummy state 1, which does not remember its
 *           parents.
 *
 *           For the special case of initializing the root node, use y==-1
 *           and whichway==TRACE_LEFT_CHILD.
 *
 *           <mode> is the alignment mode, either TRMODE_J, TRMODE_L, TRMODE_R, or TRMODE_T.
 *
 * Returns:  index of new node.
 */
int
InsertTraceNodewithMode(Parsetree_t *tr, int y, int whichway, int emitl, int emitr, int state, char mode)
{
  int a;
  int n;

  n = tr->n;
	/* a==-1 unless we're inserting a node into an existing tree, which is rare */
  if (y >= 0)
	a = (whichway == TRACE_LEFT_CHILD ? tr->nxtl[y] : tr->nxtr[y]);
  else
	a = -1;			/* special case of initializing the root. */

  if (tr->n == tr->nalloc) GrowParsetree(tr);
				/* information in new node */
  tr->emitl[n] = emitl;
  tr->emitr[n] = emitr;
  tr->state[n] = state;
  tr->mode[n]  = mode;
				/* connectivity of new node */
  tr->nxtl[n]  = a;
  tr->nxtr[n]  = -1;
  tr->prv[n]   = y;
				/* connectivity of parent   */
  if (y >= 0) {
	if (whichway == TRACE_LEFT_CHILD)  tr->nxtl[y] = n;
	else                               tr->nxtr[y] = n;
  }
				/* connectivity of child,
				   if we're inserting instead of just adding  */
  if (a != -1)  tr->prv[a] = n;
				/* bump counter, return index of new node */
  tr->n++;
  return n;
}

/* Function: InsertTraceNode()
 *
 * Purpose:  Standard, non-mode-aware API
 *           Calls InsertTraceNodewithMode()
 *           with default mode value
 *
 * Returns:  index of new node
 */
int
InsertTraceNode(Parsetree_t *tr, int y, int whichway, int emitl, int emitr, int state)
{
   int n;

   n = InsertTraceNodewithMode(tr, y, whichway, emitl, emitr, state, TRMODE_J);

   return n;
}

/* Function: ParsetreeCount()
 * Date:     SRE, Mon Jul 31 19:19:08 2000 [St. Louis]
 *
 * Purpose:  Count a parsetree into a counts-based CM structure,
 *           in the course of estimating new CM probability parameters.
 *
 * Args:     cm   - CM to collect counts in
 *           tr   - the parse tree to collect from.
 *           dsq  - digitized sequence that we're counting symbols from
 *           wgt  - weight on this sequence (often just 1.0)
 *
 * Returns:  (void)
 */
void
ParsetreeCount(CM_t *cm, Parsetree_t *tr, ESL_DSQ *dsq, float wgt)
{
  int tidx;			/* counter through positions in the parsetree        */
  int v,z;			/* parent, child state index in CM                   */

		/* trivial preorder traverse, since we're already numbered that way */
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	if (v != cm->M && cm->sttype[v] != E_st && cm->sttype[v] != B_st)
	  {
	z = tr->state[tr->nxtl[tidx]];      /* index of child state in CM  */

	if (z == cm->M)
	  cm->end[v] += wgt;
	else if (v == 0 && z - cm->cfirst[v] >= cm->cnum[v])
	  cm->begin[z] += wgt;
	else
	  cm->t[v][z - cm->cfirst[v]] += wgt;

	if (cm->sttype[v] == MP_st)
	  PairCount(cm->abc, cm->e[v], dsq[tr->emitl[tidx]], dsq[tr->emitr[tidx]], wgt);
	else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st)
	  esl_abc_FCount(cm->abc, cm->e[v], dsq[tr->emitl[tidx]], wgt);
	else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)
	  esl_abc_FCount(cm->abc, cm->e[v], dsq[tr->emitr[tidx]], wgt);
	  }
  }
}

/* Function: ParsetreeScore()
 * Date:     SRE, Wed Aug  2 13:54:07 2000 [St. Louis]
 *
 * Purpose:  Calculate the score of a given parse tree for a sequence,
 *           given a CM that's prepared in log-odds form. Also calculate
 *           the contribution of structure to that score, by summing the
 *           difference in MP emissions and the marginalized left and right
 *           scores. Also calculate the primary sequence score, the sum of
 *           all singlet emissions, plus marginalized base pair emissions.
 *           Also determine the first (ret_spos) and last (ret_epos) consensus
 *           columns occupied in the parsetree.
 *
 * Returns:  eslOK on success
 *           eslEINCOMPAT on contract violation.
 */
int
ParsetreeScore(CM_t *cm, CMEmitMap_t *emap, char *errbuf, Parsetree_t *tr, ESL_DSQ *dsq, int do_null2, float *ret_sc, float *ret_struct_sc, float *ret_primary_sc, int *ret_spos, int *ret_epos)
{
  int status;                   /* Easel status code */
  int tidx;			/* counter through positions in the parsetree        */
  int v,y;			/* parent, child state index in CM                   */
  ESL_DSQ symi, symj;		/* symbol indices for emissions, 0..cm->abc->Kp-1    */
  float sc;			/* the log-odds score of the parse tree */
  char mode;
  float struct_sc;              /* contribution of the structure to the score */
  float primary_sc;             /* contribution of primary sequence emissions to the score */
  float lsc, rsc;
  int   nd;
  int   sd;

  /* contract check */
  if(dsq    == NULL)    ESL_FAIL(eslEINCOMPAT, errbuf, "ParsetreeScore(): dsq == NULL.");
  if(ret_sc == NULL)    ESL_FAIL(eslEINCOMPAT, errbuf, "ParsetreeScore(): ret_sc == NULL.");
  if(emap   == NULL && (ret_spos != NULL || ret_epos != NULL)) ESL_FAIL(eslEINCOMPAT, errbuf, "ParsetreeScore(): emap == NULL but ret_spos and ret_epos != NULL.");

  int spos = cm->clen + 1;
  int epos = 0;

		/* trivial preorder traverse, since we're already numbered that way */
  sc = struct_sc = primary_sc = 0.;
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	mode = tr->mode[tidx];
	if (v == cm->M) continue;      	/* special case: v is EL, local alignment end */
	nd = cm->ndidx[v];
	if (cm->sttype[v] != E_st && cm->sttype[v] != B_st) { /* no scores in B,E */

	  /* add in contribution of transition score */
	  if(tr->nxtl[tidx] == -1) {
	sc += 0.; /* we've done a truncated end: no transition score contribution */
	  }
	  else { /* not a truncated end */
	y = tr->state[tr->nxtl[tidx]];      /* index of child state in CM  */
	if(v == 0) {
	  if(! tr->is_std) {
	    sc += tr->trpenalty;
	  }
	  else if(cm->flags & CMH_LOCAL_BEGIN)
	    sc += cm->beginsc[y];
	  else
	    sc += cm->tsc[v][y - cm->cfirst[v]]; /* non-local transition out of ROOT_S */
	}
	else if (y == cm->M) {
	  /* CMH_LOCAL_END is presumably set, else this wouldn't happen */
	  if     (mode == TRMODE_J) sd = StateDelta(cm->sttype[v]);
	  else if(mode == TRMODE_L) sd = StateLeftDelta(cm->sttype[v]);
	  else if(mode == TRMODE_R) sd = StateRightDelta(cm->sttype[v]);
	  sc += cm->endsc[v] + (cm->el_selfsc * (tr->emitr[tidx] - tr->emitl[tidx] + 1 - sd));
	}
	else {
	  /* y - cm->first[v] gives us the offset in the transition vector */
	  sc += cm->tsc[v][y - cm->cfirst[v]];
	}
	  }

	  /* add in contribution of emission score */
	  if (cm->sttype[v] == MP_st) {
	symi = dsq[tr->emitl[tidx]];
	symj = dsq[tr->emitr[tidx]];
	if (mode == TRMODE_J) {
	  if (symi < cm->abc->K && symj < cm->abc->K) {
	    sc += cm->esc[v][(int) (symi*cm->abc->K+symj)];
	    struct_sc += cm->esc[v][(int) (symi*cm->abc->K+symj)];
	  }
	  else {
	    sc += DegeneratePairScore(cm->abc, cm->esc[v], symi, symj);
	    struct_sc += cm->esc[v][(int) (symi*cm->abc->K+symj)];
	  }
	  lsc = cm->lmesc[v][symi];
	  rsc = cm->rmesc[v][symj];
	  struct_sc -= lsc;  /* subtract left  marginalized score */
	  struct_sc -= rsc;  /* subtract right marginalized score */
	  primary_sc += lsc;
	  primary_sc += rsc;
	}
	else if (mode == TRMODE_L)
	  sc += cm->lmesc[v][symi];
	else if (mode == TRMODE_R)
	  sc += cm->rmesc[v][symj];
	if(emap != NULL) {
	  spos = ESL_MIN(spos, emap->lpos[nd]);
	  epos = ESL_MAX(epos, emap->rpos[nd]);
	}
	  }
	  else if ( (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) && ModeEmitsLeft(mode)) {
	symi = dsq[tr->emitl[tidx]];
	if (symi < cm->abc->K) lsc = cm->esc[v][(int) symi];
	else                   lsc = esl_abc_FAvgScore(cm->abc, symi, cm->esc[v]);
	sc += lsc;
	primary_sc += lsc;
	if(emap != NULL && cm->stid[v] == MATL_ML) {
	  spos = ESL_MIN(spos, emap->lpos[nd]);
	  epos = ESL_MAX(epos, emap->lpos[nd]);
	}
	  }
	  else if ( (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) && ModeEmitsRight(mode)) {
	symj = dsq[tr->emitr[tidx]];
	if (symj < cm->abc->K) rsc = cm->esc[v][(int) symj];
	else                   rsc = esl_abc_FAvgScore(cm->abc, symj, cm->esc[v]);
	sc += rsc;
	primary_sc += rsc;
	if(emap != NULL && cm->stid[v] == MATR_MR) {
	  spos = ESL_MIN(spos, emap->rpos[nd]);
	  epos = ESL_MAX(epos, emap->rpos[nd]);
	}
	  }
	}
  }

  if(do_null2) {
	float corr_sc;
	if((status = ParsetreeScoreCorrectionNull2(cm, errbuf, tr, dsq, 0, cm->null2_omega, &corr_sc)) != eslOK) return status;
	sc -= corr_sc;
	primary_sc -= corr_sc;
	/* don't subtract corr_sc from struct_sc, b/c we would have subtracted it from
	 * both the marginalized and non-marginalized MP scores, thus it cancels out for struct_sc
	 */
  }
  if(ret_sc != NULL)         *ret_sc        = sc;
  if(ret_struct_sc != NULL)  *ret_struct_sc = struct_sc;
  if(ret_primary_sc != NULL) *ret_primary_sc = primary_sc;

  if(spos == cm->clen+1) spos = -1;
  if(epos == 0)          epos = -1;

  if(ret_spos != NULL)  *ret_spos = spos;
  if(ret_epos != NULL)  *ret_epos = epos;
  return eslOK;
}

/* Function: PrintParsetree()
 * Date:     SRE, Fri Jul 28 12:47:06 2000 [St. Louis]
 *
 * Purpose:  Debugging: show a tabular representation of a
 *           parsetree structure.
 *
 *           This just shows information in the
 *           parsetree structure itself. ParsetreeDump()
 *           is more detailed, showing sequence information
 *           aligned to the tree. PrintParsetree() is
 *           called by cmbuild.c to print a master guide
 *           tree, which doesn't have an individual
 *           sequence aligned to it.
 *
 * Args:     fp  - output stream (stdout?)
 *           tr  - the tree to show
 *
 * Returns:  void
 */
void
PrintParsetree(FILE *fp, Parsetree_t *tr)
{
  int x;

  fprintf(fp, "%5s %5s %5s %5s %5s %5s %5s %5s\n",
	  " idx ","emitl", "emitr", "state", " nxtl", " nxtr", " prv ", " mode");
  fprintf(fp, "%5s %5s %5s %5s %5s %5s %5s %5s\n",
	  "-----", "-----", "-----", "-----", "-----","-----", "-----", "-----");
  for (x = 0; x < tr->n; x++)
	fprintf(fp, "%5d %5d %5d %5d %5d %5d %5d %5s\n",
	    x, tr->emitl[x], tr->emitr[x], tr->state[x],
	    tr->nxtl[x], tr->nxtr[x], tr->prv[x], MarginalMode(tr->mode[x]));
  fprintf(fp, "%5s %5s %5s %5s %5s %5s %5s %5s\n",
	  "-----", "-----", "-----", "-----","-----","-----", "-----", "-----");

  fprintf(fp, "n      = %d\n", tr->n);
  fprintf(fp, "nalloc = %d\n", tr->nalloc);
  fprintf(fp, "block  = %d\n", tr->memblock);
}

/* Function: ParsetreeDump()
 * Date:     SRE, Fri Aug  4 10:43:20 2000 [St. Louis]
 *
 * Purpose:  Generate a detailed picture of a parsetree data structure,
 *           annotated with relevant information from the sequence
 *           and the model.
 *
 * Args:    fp    - FILE to write output to.
 *          tr    - parsetree to examine.
 *          cm    - model that was aligned to dsq to generate the parsetree
 *          dsq   - digitized sequence that was aligned to cm to generate the parsetree
 *
 * Returns:  (void)
 */
void
ParsetreeDump(FILE *fp, Parsetree_t *tr, CM_t *cm, ESL_DSQ *dsq)
{
  int   x, sd;
  char  syml, symr;
  float tsc;
  float esc;
  int   v,y;
  char  mode;

  /* if we're a truncated alignment first line is special, it shows the truncation penalty only */
  fprintf(fp, "Parsetree dump\n");
  fprintf(fp, "------------------\n");
  fprintf(fp, "is_std              = %s\n",   tr->is_std ? "TRUE (alignment is not truncated)" : "FALSE (parsetree was found by a truncated DP algorithm)");
  fprintf(fp, "pass_idx            = %d\n",   tr->pass_idx);
  fprintf(fp, "trpenalty           = %.3f\n", tr->trpenalty);
  fprintf(fp, "parsetree:\n\n");
  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s %5s\n",
	  " idx ","emitl", "emitr", "state", " mode", " nxtl", " nxtr", " prv ", " tsc ", " esc ");
  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s %5s\n",
	  "-----", "------", "------", "-------", "-----","-----", "-----","-----", "-----", "-----");

  for (x = 0; x < tr->n; x++)
	{
	  v = tr->state[x];
	  mode = tr->mode[x];

	  /* Set syml, symr: one char representation of what we emit, or ' '.
	   * Set esc:        emission score, or 0.
	   * Only P, L, R states have emissions.
	   */
	  syml = symr = ' ';
	  esc = 0.;
	  if (cm->sttype[v] == MP_st) {
	if (mode == TRMODE_J || mode == TRMODE_L) syml = cm->abc->sym[dsq[tr->emitl[x]]];
	if (mode == TRMODE_J || mode == TRMODE_R) symr = cm->abc->sym[dsq[tr->emitr[x]]];
	if      (mode == TRMODE_J) esc = DegeneratePairScore(cm->abc, cm->esc[v], dsq[tr->emitl[x]], dsq[tr->emitr[x]]);
		else if (mode == TRMODE_L) esc = cm->lmesc[v][dsq[tr->emitl[x]]];
		else if (mode == TRMODE_R) esc = cm->rmesc[v][dsq[tr->emitr[x]]];
	  } else if ( (cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) && (mode == TRMODE_J || mode == TRMODE_L) ) {
	syml = cm->abc->sym[dsq[tr->emitl[x]]];
	esc  = esl_abc_FAvgScore(cm->abc, dsq[tr->emitl[x]], cm->esc[v]);
	  } else if ( (cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) && (mode == TRMODE_J || mode == TRMODE_R) ) {
	symr = cm->abc->sym[dsq[tr->emitr[x]]];
	esc  = esl_abc_FAvgScore(cm->abc, dsq[tr->emitr[x]], cm->esc[v]);
	  }

	  /* Set tsc: transition score, or 0.
	   * B, E, and the special EL state (M, local end) have no transitions.
	   */
	  tsc = 0.;
	  if (v != cm->M && cm->sttype[v] != B_st && cm->sttype[v] != E_st && tr->nxtl[x] != -1) {
	y = tr->state[tr->nxtl[x]];
	if(v == 0) {
	  if(! tr->is_std) {
	    tsc = tr->trpenalty;
	  }
	  else if(cm->flags & CMH_LOCAL_BEGIN) {
	    tsc = cm->beginsc[y];
	  }
	  else {
	    tsc = cm->tsc[v][y - cm->cfirst[v]]; /* non-local transition out of ROOT_S */
	  }
	}
	else if (y == cm->M) { /* CMH_LOCAL_END is presumably set, else this wouldn't happen */
	  if     (mode == TRMODE_J) sd = StateDelta(cm->sttype[v]);
	  else if(mode == TRMODE_L) sd = StateLeftDelta(cm->sttype[v]);
	  else if(mode == TRMODE_R) sd = StateRightDelta(cm->sttype[v]);
	  tsc = cm->endsc[v] + (cm->el_selfsc * (tr->emitr[x] - tr->emitl[x] + 1 - sd));
	}
	else {		/* y - cm->first[v] gives us the offset in the transition vector */
	  tsc = cm->tsc[v][y - cm->cfirst[v]];
	}
	  }

	  /* Print the info line for this state
	   */
	  fprintf(fp, "%5d %5d%c %5d%c %5d%-2s %5s %5d %5d %5d %5.2f %5.2f\n",
	      x, tr->emitl[x], syml, tr->emitr[x], symr, tr->state[x],
	      Statetype(cm->sttype[v]), MarginalMode(tr->mode[x]),
	      tr->nxtl[x], tr->nxtr[x], tr->prv[x], tsc, esc);
	}
  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s %5s\n",
	  "-----", "------", "------", "-------", "-----","-----","-----", "-----","-----", "-----");
  fflush(fp);
}

/* Function: ParsetreeCompare()
 * Date:     SRE, Sat Aug 12 22:05:38 2000 [Titusville]
 *
 * Purpose:  Compare two parse trees to each other, for debugging
 *           purposes. If they are not exactly alike, return 0.
 *           Else return 1.
 */
int
ParsetreeCompare(Parsetree_t *t1, Parsetree_t *t2)
{
  int x;

  if (t1->n != t2->n) return 0;
  for (x = 0; x < t1->n; x++)
	{
	  if (t1->emitl[x] != t2->emitl[x]) return 0;
	  if (t1->emitr[x] != t2->emitr[x]) return 0;
	  if (t1->state[x] != t2->state[x]) return 0;
	  if (t1->mode[x]  != t2->mode[x])  return 0;
	  if (t1->nxtl[x]  != t2->nxtl[x])  return 0;
	  if (t1->nxtr[x]  != t2->nxtr[x])  return 0;
	}
  return 1;
}

/* Function: SummarizeMasterTrace()
 * Date:     SRE, Fri Jul 28 13:42:30 2000 [St. Louis]
 *
 * Purpose:  Debugging: count the nodes used in a master trace.
 *           Note that it takes advantage of the overloading of
 *           tr->state; in a master trace, this is a node type
 *           (e.g. MATP_nd), not a state index.
 *
 * Args:     fp - output file (e.g. stdout)
 *           tr - master trace to summarize
 *
 * Returns:  void
 */
void
SummarizeMasterTrace(FILE *fp, Parsetree_t *tr)
{
  int x;
  int count[NODETYPES];

  for (x = 0; x < NODETYPES; x++) count[x] = 0;
  for (x = 0; x < tr->n; x++)     count[tr->state[x]]++;

  fprintf(fp, "Summary report for the master trace:\n");
  fprintf(fp, "------------------------------------\n");
  fprintf(fp, "Total nodes:  %d\n", tr->n);
  fprintf(fp, "Bifurcations: %d\n", count[0]);
  fprintf(fp, "MATP:         %d\n", count[1]);
  fprintf(fp, "MATL:         %d\n", count[2]);
  fprintf(fp, "MATR:         %d\n", count[3]);
  fprintf(fp, "BEGL:         %d\n", count[4]);
  fprintf(fp, "BEGR:         %d\n", count[5]);
  fprintf(fp, "ROOT:         %d\n", count[6]);
  fprintf(fp, "END:          %d\n", count[7]);
}

/* Function: MasterTraceDisplay()
 * Date:     SRE, Mon Aug  7 10:05:16 2000 [St. Louis]
 *
 * Purpose:  prettified display of a master trace, for debugging
 *           and planning purposes. works by recursively calling
 *           mtd_visit_node().
 */
static void
mtd_visit_node(FILE *fp, Parsetree_t *mtr, CM_t *cm, int v, int depth)
{
  int y;
				/* find next start states in "binary tree" */
  for (y = v+1; y < mtr->n; y++)
	if (mtr->state[y] == END_nd || mtr->state[y] == BIF_nd) break;
				/* visit right */
  if (mtr->state[y] == BIF_nd)
	mtd_visit_node(fp, mtr, cm, mtr->nxtr[y], depth+1);
				/* deal with root */
  fprintf(fp, "%*s%d: %d[%d]: %d..%d, %d nt\n", depth*6, "", depth, v, cm->nodemap[v], mtr->emitl[v], mtr->emitr[v], mtr->emitr[v] - mtr->emitl[v] +1);
				/* visit left */
  if (mtr->state[y] == BIF_nd)
	mtd_visit_node(fp, mtr, cm, mtr->nxtl[y], depth+1);
}
void
MasterTraceDisplay(FILE *fp, Parsetree_t *mtr, CM_t *cm)
{
  mtd_visit_node(fp, mtr, cm, 0, 0);
}

/* Function : Parsetrees2Alignment()
 *
 * Purpose:   Creates a MSA from a set of parsetrees and a CM. If
 *            (do_matchonly) the MSA will only include consensus
 *            columns. If (do_full), all consensus columns are
 *            included, regardless of whether they have any residues
 *            in them or not. One reason to do this is so we can
 *            always merge any alignments that were created using the
 *            same CM, because they'll have the same number of
 *            consensus (nongap-RF) columns.
 *
 * Args:     cm           - the CM
 *           errbuf       - for error messages
 *           abc          - alphabet to use to create the return MSA
 *           sq           - sequences, must be digitized (we check for it)
 *           wgt          - weights for seqs (NULL for none)
 *           tr           - array of tracebacks
 *           postcode     - posterior code string (NULL for none)
 *           nseq         - number of sequences
 *           insertfp     - file to print per-seq insert information to (NULL if none)
 *           elfp         - file to print per-seq EL insert information to (NULL if none)
 *           do_full      - TRUE to always include all match columns in alignment
 *           do_matchonly - TRUE to ONLY include match columns
 *           ret_msa      - RETURN: MSA, alloc'ed/created here
 *
 * Returns:  eslOK on success, eslEMEM on memory error, eslEINVALID on contract violation.
 *           Also ret_msa is filled with a new MSA.
 *
 */
int
Parsetrees2Alignment(CM_t *cm, char *errbuf, const ESL_ALPHABET *abc, ESL_SQ **sq, double *wgt,
		     Parsetree_t **tr, char **postcode, int nseq,
		     FILE *insertfp, FILE *elfp, int do_full, int do_matchonly, ESL_MSA **ret_msa)
{
  int          status;          /* easel status flag */
  CMEmitMap_t *emap  = NULL;    /* ptr to cm->emap, for convenience */
  ESL_MSA     *msa   = NULL;    /* multiple sequence alignment */
  int          i;               /* counter over traces */
  int          v, nd;           /* state, node indices */
  char         mode;            /* a marginal alignment mode */
  int          cpos;            /* counter over consensus positions (0)1..clen */
  int         *matuse= NULL;    /* TRUE if we need a cpos in mult alignment */
  int         *iluse = NULL;    /* # of IL insertions after a cpos for 1 trace */
  int         *eluse = NULL;    /* # of EL insertions after a cpos for 1 trace */
  int         *iruse = NULL;    /* # of IR insertions after a cpos for 1 trace */
  int         *maxil = NULL;    /* max # of IL insertions after a cpos */
  int         *maxel = NULL;    /* max # of EL insertions after a cpos */
  int         *maxir = NULL;    /* max # of IR insertions after a cpos */
  int	      *matmap= NULL;    /* apos corresponding to a cpos */
  int         *ilmap = NULL;    /* first apos for an IL following a cpos */
  int         *elmap = NULL;    /* first apos for an EL following a cpos */
  int         *irmap = NULL;    /* first apos for an IR following a cpos */
  int          alen;	        /* length of msa in columns */
  int          apos;	        /* position in an aligned sequence in MSA */
  int          rpos;	        /* position in an unaligned sequence in dsq */
  int         *ifirst = NULL;   /* first uapos (unaligned position) for an insert following a cpos in cur seq */
  int         *elfirst = NULL;  /* first uapos (unaligned position) for an EL following a cpos in cur seq */
  int          tpos;            /* position in a parsetree */
  int          el_len;	        /* length of an EL insertion in residues */
  int          prvnd;	        /* keeps track of previous node for EL */
  int          nins;            /* insert counter used for splitting inserts */
  int          do_post;         /* TRUE if postcode != NULL (we should write at least 1 sequence's posteriors) */
  int          do_cur_post;     /* TRUE if we're writing posteriors for the current sequence inside a loop */
  char        *tmp_aseq = NULL; /* will hold aligned sequence for current sequence */
  char        *tmp_apc  = NULL; /* will hold aligned postcode characters for current sequence */
  /* s_cposA and e_cposA are only alloc'ed and filled if insertfp || elfp != NULL, b/c they're only purpose is to be written to those files */
  int         *s_cposA = NULL;  /* [0..nseq-1] the first consensus position filled by a nongap for seq i */
  int         *e_cposA = NULL;  /* [0..nseq-1] the final consensus position filled by a nongap for seq i */
  int          s_cpos;          /* first consensus position filled by a nongap for current seq */
  int          e_cpos;          /* final consensus position filled by a nongap for current seq */

  /* Contract check. We allow the caller to specify the alphabet they want the
   * resulting MSA in, but it has to make sense (see next few lines). */
  if(cm->abc->type == eslRNA) {
	  if(abc->type != eslRNA && abc->type != eslDNA)
	ESL_XFAIL(eslEINVAL, errbuf, "Parsetrees2Alignment(): cm alphabet is RNA, but requested output alphabet is neither DNA nor RNA.");
  }
  else if(cm->abc->K != abc->K) {
	ESL_XFAIL(eslEINVAL, errbuf, "Parsetrees2Alignment(): cm alphabet size is %d, but requested output alphabet size is %d.", cm->abc->K, abc->K);
  }
  /* cm->cmcons must exist */
  if(cm->cmcons == NULL) ESL_XFAIL(eslEINVAL, errbuf, "Parsetrees2Alignment(): cm-cmcons is NULL");

  do_post = (postcode == NULL) ? FALSE : TRUE;
  emap = cm->emap; /* for convenience */

  ESL_ALLOC(matuse,  sizeof(int)*(emap->clen+1));
  ESL_ALLOC(iluse,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(eluse,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(iruse,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(maxil,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(maxel,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(maxir,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(matmap,  sizeof(int)*(emap->clen+1));
  ESL_ALLOC(ilmap,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(elmap,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(irmap,   sizeof(int)*(emap->clen+1));
  ESL_ALLOC(ifirst,  sizeof(int)*(emap->clen+1));
  ESL_ALLOC(elfirst, sizeof(int)*(emap->clen+1));

  if(insertfp != NULL || elfp != NULL) {
	ESL_ALLOC(s_cposA,  sizeof(int)*nseq);
	ESL_ALLOC(e_cposA,  sizeof(int)*nseq);
	esl_vec_ISet(s_cposA, nseq, 0); /* all nseq values will be overwritten, actually this initialization is unnec */
	esl_vec_ISet(e_cposA, nseq, 0); /* all nseq values will be overwritten, actually this initialization is unnec */
  }

  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if(!do_full || cpos == 0)
	matuse[cpos] = 0;
	  else
	matuse[cpos] = 1;
	  maxil[cpos] = maxel[cpos] = maxir[cpos] = 0;
	  ilmap[cpos] = elmap[cpos] = irmap[cpos] = 0;
	}

  /* Look at all the traces; find maximum length of
   * insert needed at each of the clen+1 possible gap
   * points. (There are three types of insert, IL/EL/IR.)
   * Also find whether we don't need some of the match
   * (consensus) columns.
   */
  for (i = 0; i < nseq; i++) {
	for (cpos = 0; cpos <= emap->clen; cpos++)
	  iluse[cpos] = eluse[cpos] = iruse[cpos] = 0;

	for (tpos = 0; tpos < tr[i]->n; tpos++) {
	  v    = tr[i]->state[tpos];
	  mode = tr[i]->mode[tpos];
	  if (cm->sttype[v] == EL_st) nd = prvnd;
	  else                        nd = cm->ndidx[v];

	  switch (cm->sttype[v]) {
	  case MP_st:
	if(ModeEmitsLeft(mode))  matuse[emap->lpos[nd]] = 1;
	if(ModeEmitsRight(mode)) matuse[emap->rpos[nd]] = 1;
	break;
	  case ML_st:
	if(ModeEmitsLeft(mode))  matuse[emap->lpos[nd]] = 1;
	break;
	  case MR_st:
	if(ModeEmitsRight(mode)) matuse[emap->rpos[nd]] = 1;
	break;
	  case IL_st:
	if(ModeEmitsLeft(mode))  iluse[emap->lpos[nd]]++;
	break;
	  case IR_st:
	/* remember, convention on rpos is that IR precedes this
	 * cpos. Make it after the previous cpos, hence the -1.
	 */
	if(ModeEmitsRight(mode)) iruse[emap->rpos[nd]-1]++;
	break;
	  case EL_st:
	/* mode must be TRMODE_J */
	el_len = tr[i]->emitr[tpos] - tr[i]->emitl[tpos] + 1;
	eluse[emap->epos[nd]] = el_len;
	/* not possible to have >1 EL in same place; could assert this */
	break;
	  }

	  prvnd = nd;
	} /* end looking at trace i */

	for (cpos = 0; cpos <= emap->clen; cpos++)
	  {
	if (iluse[cpos] > maxil[cpos]) maxil[cpos] = iluse[cpos];
	if (eluse[cpos] > maxel[cpos]) maxel[cpos] = eluse[cpos];
	if (iruse[cpos] > maxir[cpos]) maxir[cpos] = iruse[cpos];
	  }
  } /* end calculating lengths used by all traces */

  /* Now we can calculate the total length of the multiple alignment,
   * alen; and the maps ilmap, elmap, and irmap that turn a cpos into
   * an apos in the multiple alignment: e.g. for an IL and EL that
   * follows consensus position cpos, put it at or after apos =
   * ilmap[cpos] in aseq[][].  IR's are filled in backwards (3'->5')
   * and rightflushed.
   *
   * EPN, Mon Oct 22 09:40:15 2012
   * Post-1.1rc1: always put EL insertions *before* (5' of) ILs or
   * IRs. Previous to this modification ELs were 5' or IRs, but 3' of
   * ILs. Since ELs only occur at the end of stem loops, IRs nearly
   * always accounted for inserts at the same position as an EL
   * (because ILs directly before an END_E state are detached to
   * resolve an ambiguity in the CM grammar).  This means the
   * post-1.1rc1 change only affected models with MATP immediately
   * followed by an END_E, where the MATP_IR is is detached and the
   * MATP_IL can emit after the same position as an EL. For those
   * cases, previously ELs were 3' or the ILs, but now ELs are 5' of
   * the ILs. This makes it possible to merge alignments to the same
   * model without parsing their secondary structure because we can
   * assume ELs are always 5' of inserts.
   */
  alen = 0;
  for (cpos = 0; cpos <= emap->clen; cpos++) {
	if (matuse[cpos]) {
	  matmap[cpos] = alen;
	  alen++;
	}
	else matmap[cpos] = -1;

	elmap[cpos] = alen;
	if(! do_matchonly) alen += maxel[cpos];
	ilmap[cpos] = alen;
	if(! do_matchonly) alen += maxil[cpos];
	if(! do_matchonly) alen += maxir[cpos];
	irmap[cpos] = alen-1;
	/* note: if do_matchonly, no inserts are printed, ilmap, elmap, irmap are irrelevant */
  }

  /* We're getting closer.
   * Now we know the size of the MSA, allocate it.
   */
  msa = esl_msa_Create(nseq, -1);
  if(msa == NULL) goto ERROR;
  msa->nseq = nseq;
  msa->alen = alen;
  msa->abc  = NULL;
  if(do_post) {
	ESL_ALLOC(msa->pp, sizeof(char *) * msa->nseq);
  }

  /* we reuse aseq, copying it to the msa after it's completed for each seq */
  ESL_ALLOC(tmp_aseq, sizeof(char) * (msa->alen+1));
  if(do_post) { /* these will be reused for each sequence (the aligned postcode arrays are all the same length) */
	ESL_ALLOC(tmp_apc, sizeof(char) * (msa->alen+1));
  }

  for (i = 0; i < nseq; i++) {
	s_cpos = emap->clen+1; /* an ESL_MIN with any cpos <= clen will replace this */
	e_cpos = 0;            /* an ESL_MAX with any cpos  > 0 will replace this */

	/* Contract check */
	if(sq[i]->dsq == NULL) ESL_XFAIL(eslEINVAL, errbuf, "Error in Parsetrees2Alignment(), sq %d is not digitized.\n", i);
	do_cur_post = FALSE;
	if(do_post) {
	  do_cur_post = (postcode[i] != NULL) ? TRUE : FALSE;
	}

	/* Initialize the aseq with all pads '.' (in insert cols)
	 * and deletes '-' (in match cols).
	 */
	for (apos = 0; apos < alen; apos++) tmp_aseq[apos] = '.';
	if(do_cur_post) {
	  for (apos = 0; apos < alen; apos++) {
	tmp_apc[apos] = '.';
	  }
	}

	for (cpos = 0; cpos <= emap->clen; cpos++) {
	  if (matmap[cpos] != -1) {
	tmp_aseq[matmap[cpos]] = '-';
	  }
	}
	if(do_cur_post) {
	  for (cpos = 0; cpos <= emap->clen; cpos++) {
	if (matmap[cpos] != -1) {
	  tmp_apc[matmap[cpos]] = '.';
	}
	  }
	}
	tmp_aseq[alen] = '\0';
	if(do_cur_post) tmp_apc[alen] = '\0';

	/* Traverse this guy's trace, and place all his
	 * emitted residues and posteriors.
	 */
	for (cpos = 0; cpos <= emap->clen; cpos++) {
	  iluse[cpos] = iruse[cpos] = eluse[cpos] = 0;
	  ifirst[cpos] = elfirst[cpos] = -1;
	}

	for (tpos = 0; tpos < tr[i]->n; tpos++) {
	  v    = tr[i]->state[tpos];
	  mode = tr[i]->mode[tpos];
	  if (cm->sttype[v] == EL_st) nd = prvnd;
	  else                        nd = cm->ndidx[v];

	  switch (cm->sttype[v]) {
	  case MP_st:
	if(ModeEmitsLeft(mode)) {
	  cpos = emap->lpos[nd];
	  apos = matmap[cpos];
	  rpos = tr[i]->emitl[tpos];
	  tmp_aseq[apos] = abc->sym[sq[i]->dsq[rpos]];
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	  s_cpos = ESL_MIN(s_cpos, cpos);
	  e_cpos = ESL_MAX(e_cpos, cpos);
	}

	if(ModeEmitsRight(mode)) {
	  cpos = emap->rpos[nd];
	  apos = matmap[cpos];
	  rpos = tr[i]->emitr[tpos];
	  tmp_aseq[apos] = abc->sym[sq[i]->dsq[rpos]];
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	  s_cpos = ESL_MIN(s_cpos, cpos);
	  e_cpos = ESL_MAX(e_cpos, cpos);
	}
	break;

	  case ML_st:
	if(ModeEmitsLeft(mode)) {
	  cpos = emap->lpos[nd];
	  apos = matmap[cpos];
	  rpos = tr[i]->emitl[tpos];
	  tmp_aseq[apos] = abc->sym[sq[i]->dsq[rpos]];
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	  s_cpos = ESL_MIN(s_cpos, cpos);
	  e_cpos = ESL_MAX(e_cpos, cpos);
	}
	break;

	  case MR_st:
	if(ModeEmitsRight(mode)) {
	  cpos = emap->rpos[nd];
	  apos = matmap[cpos];
	  rpos = tr[i]->emitr[tpos];
	  tmp_aseq[apos] = abc->sym[sq[i]->dsq[rpos]];
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	  s_cpos = ESL_MIN(s_cpos, cpos);
	  e_cpos = ESL_MAX(e_cpos, cpos);
	}
	break;

	  case IL_st:
	if(ModeEmitsLeft(mode)) {
	  cpos = emap->lpos[nd];
	  apos = ilmap[cpos] + iluse[cpos];
	  rpos = tr[i]->emitl[tpos];
	  if(iluse[cpos] == 0) ifirst[cpos] = rpos; /* only update ifirst if this is the first insert for this IL */
	  iluse[cpos]++;
	  if(do_matchonly) break; /* we don't break until this point in case we're writing to insertfp, in which case we need ifirst[] and iluse[] */
	  tmp_aseq[apos] = tolower((int) abc->sym[sq[i]->dsq[rpos]]);
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	}
	break;

	  case EL_st:
	/* we can assert eluse[cpos] always == 0 when we enter,
	 * because we can only have one EL insertion event per
	 * cpos. If we ever decide to regularize (split) insertions,
	 * though, we'll want to calculate eluse in the rpos loop.
	 */
	cpos = emap->epos[nd];
	apos = elmap[cpos];
	eluse[cpos] = tr[i]->emitr[tpos] - tr[i]->emitl[tpos] + 1;
	elfirst[cpos] = tr[i]->emitl[tpos];
	if(do_matchonly) break; /* we don't break until this point in case we're writing to elfp, in which case we need elfirst[] and eluse[] */
	for (rpos = tr[i]->emitl[tpos]; rpos <= tr[i]->emitr[tpos]; rpos++)
	  {
	    tmp_aseq[apos] = tolower((int) abc->sym[sq[i]->dsq[rpos]]);
	    if(do_cur_post) {
	      tmp_apc[apos] = postcode[i][rpos-1];
	    }
	    apos++;
	  }
	break;

	  case IR_st:
	if(ModeEmitsRight(mode)) {
	  cpos = emap->rpos[nd]-1;  /* -1 converts to "following this one" */
	  apos = irmap[cpos] - iruse[cpos];  /* writing backwards, 3'->5' */
	  rpos = tr[i]->emitr[tpos];
	  ifirst[cpos] = rpos; /* by overwriting each time we will end up with min rpos used by this IR */
	  iruse[cpos]++;
	  if(do_matchonly) break; /* we don't break until this point in case we're writing to elfp, in which case we need ifirst[] and iruse[] */
	  tmp_aseq[apos] = tolower((int) abc->sym[sq[i]->dsq[rpos]]);
	  if(do_cur_post) {
	    tmp_apc[apos] = postcode[i][rpos-1];
	  }
	}
	break;

	  case D_st:
	if ((cm->stid[v] == MATP_D || cm->stid[v] == MATL_D) && ModeEmitsLeft(mode)) {
	  cpos = emap->lpos[nd];
	  if (matuse[cpos]) tmp_aseq[matmap[cpos]] = '-';
	}
	if ((cm->stid[v] == MATP_D || cm->stid[v] == MATR_D) && ModeEmitsRight(mode)) {
	  cpos = emap->rpos[nd];
	  if (matuse[cpos]) tmp_aseq[matmap[cpos]] = '-';
	}
	break;

	  } /* end of the switch statement */

	  prvnd = nd;
	  /* we only set s_cposA[i] and e_cposA[i] if we'll output them to an insertfp or elfp */
	  if(insertfp != NULL || elfp != NULL) {
	s_cposA[i] = (s_cpos == (emap->clen+1)) ? -1 : s_cpos;
	e_cposA[i] = (e_cpos == 0)              ? -1 : e_cpos;
	  }
	} /* end traversal over trace i. */

	/* copy tmp_aseq to the msa */
	if((status = esl_strdup(tmp_aseq, msa->alen, &(msa->aseq[i]))) != eslOK) goto ERROR;

	/* add tmp_apc posterior probabilities to msa, if nec */
	if(do_cur_post) {
	  if((status = esl_strdup(tmp_apc, msa->alen, &(msa->pp[i]))) != eslOK) goto ERROR;
	}
	else if (do_post) { msa->pp[i] = NULL; }

	/* rejustify inserts and posteriors (if nec) */
	if(! do_matchonly) {
	  /* IL/EL Insertions are currently flush-left and IR insertions are currently flush-right.
	   * This is pre-1.0 Infernal behavior. If(cm->align_opts & CM_ALIGN_FLUSHINSERTS) we leave them all alone,
	   * otherwise we regularize (split) the internal inserts, we flush the 5' inserts right and the 3'
	   * inserts left (note: pre 1.0 behavior does the opposite, flushes 5' left (assuming they're ROOT_ILs)
	   * and flushes 3' right (assuming they're ROOT_IRs).
	   *
	   * We have to be careful about EL's. We don't want to group IL/IR's and EL's together and then split them
	   * because we need to annotate IL/IR's as '.'s in the consensus structure and EL's as '~'. So we split
	   * each group separately.
	   * post-1.1rc1 release, we now always but EL insertions *before* (5' of) ILs or IRs. This is a change
	   * relative to 1.0->1.1rc1, in which ILs would come 3' of ELs (although this would only very rarely
	   * occur in the case of a MATP followed by an END (that's the only case where an IL and EL can emit
	   * after the same cpos)).
	   */
	  if(! (cm->align_opts & CM_ALIGN_FLUSHINSERTS)) /* default behavior, split insert in half */
	{
	  /* Deal with inserts before first consensus position, ELs, then ILs, then IRs
	   * (new convention post-1.1rc1 see note above, used to be ILs then ELs then IRs)
	   */

	  /* EL's are flush left, we want flush right (I think these are impossible, but just in case...) */
	  rightjustify(abc, msa->aseq[i], maxel[0]);
	  if(do_cur_post) rightjustify(abc, msa->pp[i], maxel[0]);

	  /* IL's are flush left, we want flush right */
	  rightjustify(abc, msa->aseq[i]+maxel[0], maxil[0]);
	  if(do_cur_post) rightjustify(abc, msa->pp[i]+maxel[0], maxil[0]);

	  /* IR's are flush right, we want flush right, do nothing */

	  /* split all internal insertions */
	  for (cpos = 1; cpos < emap->clen; cpos++)
	    {
	      if(maxel[cpos] > 1) /* we're flush LEFT, want to split */
		{
		  apos = matmap[cpos]+1;
		  for (nins = 0; islower((int) (msa->aseq[i][apos])); apos++)
		    nins++;
		  nins /= 2;		/* split the insertion in half */
		  rightjustify(abc, msa->aseq[i]+matmap[cpos]+1+nins, maxel[cpos]-nins);
		  if(do_cur_post) rightjustify(abc, msa->pp[i]+matmap[cpos]+1+nins, maxel[cpos]-nins);
		}

	      if(maxil[cpos] > 1) /* we're flush LEFT, want to split */
		{
		  apos = matmap[cpos]+1 + maxel[cpos];
		  for (nins = 0; islower((int) (msa->aseq[i][apos])); apos++)
		    nins++;
		  nins /= 2;		/* split the insertion in half */
		  rightjustify(abc, msa->aseq[i]+matmap[cpos]+1+maxel[cpos]+nins, maxil[cpos]-nins);
		  if(do_cur_post) rightjustify(abc, msa->pp[i]+matmap[cpos]+1+maxel[cpos]+nins, maxil[cpos]-nins);
		}

	      if(maxir[cpos] > 1) /* we're flush RIGHT, want to split */
		{
		  apos = matmap[cpos+1]-1;
		  for (nins = 0; islower((int) (msa->aseq[i][apos])); apos--)
		    nins++;
		  nins ++; nins /= 2;		/* split the insertion in half (++ makes it same behavior as IL/EL */
		  leftjustify(abc, msa->aseq[i]+matmap[cpos]+1 + maxel[cpos] + maxil[cpos], maxir[cpos]-nins);
		  if(do_cur_post) leftjustify(abc, msa->pp[i]+matmap[cpos]+1 + maxel[cpos] + maxil[cpos], maxir[cpos]-nins);
		}
	    }
	  /* Deal with inserts after final consensus position, IL's then EL's, then IR's
	   * EL's are flush left, we want flush left, do nothing
	   * IL's are flush left, we want flush left, do nothing
	   * IR's are flush right, we want flush left */
	  leftjustify(abc, msa->aseq[i]+matmap[emap->clen]+1 + maxel[emap->clen] + maxil[emap->clen], maxir[emap->clen]);
	  if(do_cur_post) leftjustify(abc, msa->pp[i]+matmap[emap->clen]+1 + maxel[emap->clen] + maxil[emap->clen], maxir[emap->clen]);
	}
	}

	/* output insert and/or EL info to the insertfp and elfp output files, if nec */
	if(insertfp != NULL || elfp != NULL) {
	  if(insertfp != NULL) { fprintf(insertfp, "%s %" PRId64 " %d %d", sq[i]->name, sq[i]->n, s_cposA[i], e_cposA[i]); }
	  if(elfp != NULL)     { fprintf(elfp,     "%s %" PRId64 " %d %d", sq[i]->name, sq[i]->n, s_cposA[i], e_cposA[i]); }
	  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if((insertfp != NULL) && ((iluse[cpos] + iruse[cpos]) > 0)) {
	    fprintf(insertfp, "  %d %d %d", cpos, ifirst[cpos], (iluse[cpos] + iruse[cpos])); /* note cpos+1 puts cpos from 1..clen, ifirst[] is already 1..sq->n */
	    /* Note: only 1 of iluse[cpos] or iruse[cpos] should be != 0 */
	  }
	  if((elfp != NULL) && (eluse[cpos] > 0)) {
	    fprintf(elfp, "  %d %d %d", cpos, elfirst[cpos], eluse[cpos]); /* note cpos+1 puts cpos from 1..clen, ifirst[] is already 1..sq->n */
	  }
	}
	  if(insertfp != NULL) { fprintf(insertfp, "\n"); }
	  if(elfp != NULL)     { fprintf(elfp,     "\n"); }
	}
  } /* end loop over all parsetrees */

  /* Gee, wasn't that easy?
   * Add the rest of the ("optional") information to the MSA.
   */

  /* "author" info */
  ESL_ALLOC(msa->au, sizeof(char) * (strlen(INFERNAL_VERSION)+10));
  sprintf(msa->au, "Infernal %s", INFERNAL_VERSION);

  /* per-seq info */
  for (i = 0; i < nseq; i++) {
	  esl_msa_SetSeqName(msa, i, sq[i]->name, -1);
	  if (sq[i]->acc[0]  != '\0') esl_msa_SetSeqAccession  (msa, i, sq[i]->acc,  -1);
	  if (sq[i]->desc[0] != '\0') esl_msa_SetSeqDescription(msa, i, sq[i]->desc, -1);
	  if (msa->sqlen != NULL) msa->sqlen[i] = sq[i]->n;
	  if (wgt == NULL) msa->wgt[i] = 1.0;
	  else             msa->wgt[i] = wgt[i];
	  /* TODO: individual SS annotations */
  }

  /* Construct the secondary structure consensus line, msa->ss_cons:
   *       IL, IR are annotated as .
   *       EL is annotated as ~
   *       and match columns use the structure code.
   * Also the primary sequence consensus/reference coordinate system line,
   * msa->rf.
   */
  ESL_ALLOC(msa->ss_cons, (sizeof(char) * (alen+1)));
  ESL_ALLOC(msa->rf,      (sizeof(char) * (alen+1)));
  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if (matuse[cpos])
	{ /* CMConsensus is off-by-one right now, 0..clen-1 relative to cpos's 1..clen */

	  /* bug i1, xref STL7 p.12. Before annotating something as a base pair,
	   * make sure the paired column is also present.
	   */
	  if (cm->cmcons->ct[cpos-1] != -1 && matuse[cm->cmcons->ct[cpos-1]+1] == 0) {
	    msa->ss_cons[matmap[cpos]] = '.';
	    msa->rf[matmap[cpos]]      = (cm->flags & CMH_RF) ? cm->rf[cpos] : cm->cmcons->cseq[cpos-1];
	  } else {
	    msa->ss_cons[matmap[cpos]] = cm->cmcons->cstr[cpos-1];
	    msa->rf[matmap[cpos]]      = (cm->flags & CMH_RF) ? cm->rf[cpos] : cm->cmcons->cseq[cpos-1];
	  }
	}
	  if ((maxil[cpos] > 0) && (! do_matchonly))
	for (apos = ilmap[cpos]; apos < ilmap[cpos] + maxil[cpos]; apos++)
	  {
	    msa->ss_cons[apos] = '.';
	    msa->rf[apos] = '.';
	  }
	  if ((maxel[cpos] > 0) && (! do_matchonly))
	for (apos = elmap[cpos]; apos < elmap[cpos] + maxel[cpos]; apos++)
	  {
	    msa->ss_cons[apos] = '~';
	    msa->rf[apos] = '~';
	  }
	  if ((maxir[cpos] > 0) && (! do_matchonly)) /* remember to write backwards */
	for (apos = irmap[cpos]; apos > irmap[cpos] - maxir[cpos]; apos--)
	  {
	    msa->ss_cons[apos] = '.';
	    msa->rf[apos] = '.';
	  }
	}
  msa->ss_cons[alen] = '\0';
  msa->rf[alen] = '\0';
  if (wgt != NULL) msa->flags |= eslMSA_HASWGTS;

  if(tmp_aseq != NULL) free(tmp_aseq);
  if(tmp_apc  != NULL) free(tmp_apc);
  if(s_cposA  != NULL) free(s_cposA);
  if(e_cposA  != NULL) free(e_cposA);
  free(matuse);
  free(iluse);
  free(eluse);
  free(iruse);
  free(maxil);
  free(maxel);
  free(maxir);
  free(matmap);
  free(ilmap);
  free(elmap);
  free(irmap);
  free(ifirst);
  free(elfirst);
  *ret_msa = msa;
  return eslOK;

 ERROR:
  if(tmp_apc != NULL) free(tmp_apc);
  if(matuse!= NULL)  free(matuse);
  if(iluse != NULL)  free(iluse);
  if(eluse != NULL)  free(eluse);
  if(iruse != NULL)  free(iruse);
  if(maxil != NULL)  free(maxil);
  if(maxel != NULL)  free(maxel);
  if(maxir != NULL)  free(maxir);
  if(matmap!= NULL)  free(matmap);
  if(ilmap != NULL)  free(ilmap);
  if(elmap != NULL)  free(elmap);
  if(irmap != NULL)  free(irmap);
  if(msa   != NULL)  esl_msa_Destroy(msa);
  return status;
}

/* Function: ParsetreeScore_Global2Local()
 * Date:     EPN, Wed May 23 09:57:38 2007
 *
 * Purpose:  Given a parsetree of dsq that corresponds to a globally
 *           configured CM, return the highest scoring local parsetree
 *           of dsq or a subsequence of dsq (due to local begins)
 *           that is consistent with it. The hope is that this
 *           score will *be close* to the optimal local parse of dsq so we
 *           can calculate CP9 filter thresholds without the need to
 *           search for the optimal local parse.
 *
 *           All residues 1..L must exist in the local parse emitted
 *           from the same states they were emitted in the global
 *           parse unless (1) the local parse contains a local begin into
 *           state v at parstree node t, where tr->emitl[t] > 1 and/or
 *           tr->emitr[t] < L, (2) residues were emitted from an EL
 *           state because it was higher scoring than the subtree
 *           of the global parse.
 *
 */
float
ParsetreeScore_Global2Local(CM_t *cm, Parsetree_t *tr, ESL_DSQ *dsq, int print_flag)
{
  int   status;
  int tidx;			/* counter through positions in the parsetree        */
  int v,y;			/* parent, child state index in CM                   */
  ESL_DSQ symi, symj;		/* symbol indices for emissions, 0..Kp-1             */
  char mode;
  int    tp;                    /* trace index offset, for v's with > tidx (IL or IR)*/
  float *tr_esc;                /* [0..tr->n-1] score of emissions from each trace node */
  float *tr_tsc;                /* [0..tr->n-1] score of transitions from each trace node */
  int   *v2n_map;               /* [0..cm->M-1], the trace node each state v corresponds to
				 * -1 if none */
  int   *v2n_ct;                /* [0..cm->M-1], # of trace nodes state v corresponds to */
  float *lsc;                   /* [0..tr->n-1], the score of the best local parse *
				 * rooted at v = v2n_map[tidx] for trace node tidx *
				 * -1 if none */
  float max_local_sc;           /* the best local parse score consistent with tr */
  float below_me_sc;            /* score of tr-consistent best local parse under v */
  float tmp_endsc;              /* score of jumping out of v to EL */
  /* Contract check, CM must be LOCALLY configured, (could config to global, but
   * we assume we'll be calling this function serially for many parses and don't
   * want to need to switch CM back and forth from local/global) */
  if((!(cm->flags & CMH_LOCAL_BEGIN)) || (!(cm->flags & CMH_LOCAL_END)))
	cm_Fail("ERROR in ParsetreeScore_Global2Local() CM is not in local mode.\n");
  if(dsq == NULL)
	cm_Fail("ERROR in ParsetreeScore_Global2Local(), dsq is NULL.\n");

  /* Allocate and initialize */
  ESL_ALLOC(v2n_map, sizeof(int)   * cm->M);
  ESL_ALLOC(v2n_ct,  sizeof(int)   * cm->M);
  ESL_ALLOC(lsc,     sizeof(float) * tr->n);
  ESL_ALLOC(tr_esc,  sizeof(float) * tr->n);
  ESL_ALLOC(tr_tsc,  sizeof(float) * tr->n);
  esl_vec_ISet(v2n_map, cm->M, -1);
  esl_vec_ISet(v2n_ct,  cm->M, 0);
  esl_vec_FSet(lsc, tr->n, 0.);
  esl_vec_FSet(tr_tsc, tr->n, 0.);
  esl_vec_FSet(tr_esc, tr->n, 0.);

  /* Determine the score that each trace node contributes to the overall parsetree score */

  for (tidx = 0; tidx < tr->n; tidx++)
	{
	  v = tr->state[tidx];        	/* index of parent state in CM */
	  v2n_map[v] = tidx;
	  v2n_ct[v]++; /* insert states could be visited > once */
	  mode = tr->mode[tidx];
	  if (v == cm->M)
	cm_Fail("ERROR in ParsetreeScore_Global2Local(), EL in parse, but it should be global!\n");
	  if (cm->sttype[v] != E_st && cm->sttype[v] != B_st) /* no scores in B,E */
	{
	  y = tr->state[tr->nxtl[tidx]];      /* index of child state in CM  */

	  if (y == cm->M)
	    cm_Fail("ERROR in ParsetreeScore_Global2Local(), EL in parse, but it should be global!\n");
	  if (v == 0 && y > cm->cnum[0])
	    cm_Fail("ERROR in ParsetreeScore_Global2Local(), we did a local begin in the parse, but it should be global!\n");
	  /* for v == 0, we don't care that transition score has changed from global CM that
	   * was used to generate the parsetree, because the transition from root is not
	   * considered when we look for best local parse below. */

	  /* y - cm->first[v] gives us the offset in the transition vector */
	  tr_tsc[tidx] = cm->tsc[v][y - cm->cfirst[v]];

	  if (cm->sttype[v] == MP_st)
	    {
	      symi = dsq[tr->emitl[tidx]];
	      symj = dsq[tr->emitr[tidx]];
	      if (mode == TRMODE_J)
		{
		  if (symi < cm->abc->K && symj < cm->abc->K)
		    tr_esc[tidx] = cm->esc[v][(int) (symi*cm->abc->K+symj)];
		  else
		    tr_esc[tidx] = DegeneratePairScore(cm->abc, cm->esc[v], symi, symj);
		}
	      else if (mode == TRMODE_L)
		tr_esc[tidx] = cm->lmesc[v][symi];
	      else if (mode == TRMODE_R)
		tr_esc[tidx] = cm->rmesc[v][symj];
	    }
	  else if ( (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) && (mode == TRMODE_J || mode == TRMODE_L) )
	    {
	      symi = dsq[tr->emitl[tidx]];
	      if (symi < cm->abc->K) tr_esc[tidx] = cm->esc[v][(int) symi];
	      else                   tr_esc[tidx] = esl_abc_FAvgScore(cm->abc, symi, cm->esc[v]);
	    }
	  else if ( (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) && (mode == TRMODE_J || mode == TRMODE_L) )
	    {
	      symj = dsq[tr->emitr[tidx]];
	      if (symj < cm->abc->K) tr_esc[tidx] = cm->esc[v][(int) symj];
	      else                   tr_esc[tidx] = esl_abc_FAvgScore(cm->abc, symj, cm->esc[v]);
	    }
	}
	}

  /* Now traverse CM from inside-out, for each v in the parse,
   * keep track of the best local CM score of the parse rooted
   * at v, with the possibility of local ends. Keep track
   * of maximum score considering all possible local begins */
  max_local_sc = IMPOSSIBLE;
  for(v = cm->M-1; v > 0; v--)
	{
	  for(tp = 0; tp < v2n_ct[v]; tp++)
	{
	  tidx = v2n_map[v] - tp;
	  if(print_flag)
	    printf("loop start tidx: %d esc: %f tsc: %f\n", tidx, tr_esc[tidx], tr_tsc[tidx]);

	  if(cm->sttype[v] == B_st)
	    {
	      below_me_sc = lsc[tr->nxtl[tidx]] + lsc[tr->nxtr[tidx]];
	      if(print_flag)
		{
		  printf("B state L %d: %f R %d: %f\n", tr->nxtl[tidx], lsc[tr->nxtl[tidx]], tr->nxtr[tidx], lsc[tr->nxtr[tidx]]);
		}
	    }
	  else if(cm->sttype[v] == E_st)
	    below_me_sc = 0.;
	  else
	    {
	      below_me_sc = lsc[tr->nxtl[tidx]];
	      if(print_flag) printf("non B: below_me_sc %d: %f\n", tr->nxtl[tidx], lsc[tr->nxtl[tidx]]);
	    }
	  /* Check if we could've jumped to an EL instead of traversing the
	   * subparse rooted here at v, would it have been worth it? */
	  tmp_endsc = cm->endsc[v] + /* score of transition to EL */
	    cm->el_selfsc *  /* score of emitting 1 residue */
	    ((tr->emitr[tidx] - StateRightDelta(cm->sttype[v])) -
	     (tr->emitl[tidx] + StateLeftDelta(cm->sttype[v])) + 1); /* number of residues EL must emit */
	  if(below_me_sc < (tmp_endsc - tr_tsc[tidx])) /* careful to consider sc of transition out of v */
	    {
	      below_me_sc = tmp_endsc - tr_tsc[tidx]; /* we'll add tr_tsc[idx] back in next */
	      if(print_flag)
		{
		  printf("\nTOOK LOCAL END!\n");
		  printf("tmp_endsc: %f cm->endsc: %f + %d emits\n", tmp_endsc, cm->endsc[v], ((tr->emitr[tidx] - StateRightDelta(cm->sttype[v])) - (tr->emitl[tidx] + StateLeftDelta(cm->sttype[v])) + 1));
		}
	    }
	  lsc[tidx] = tr_esc[tidx] + tr_tsc[tidx] + below_me_sc; /* note we add in tsc even if local end taken */

	  if(print_flag)
	    {
	      printf("tidx: %d\nv: %d\nlsc[tidx]: %f\nbegin_sc: %f\nmax_local_sc: %f\ntmp_endsc: %f\n\n", tidx, v, lsc[tidx], cm->beginsc[v], max_local_sc, tmp_endsc);
	      printf("tr_esc[tidx]: %f\ntr_tsc[tidx]: %f\nbelow_me_sc: %f\n", tr_esc[tidx], tr_tsc[tidx], below_me_sc);
	    }
	  /* Could we have jumped into this state from ROOT_S? Would it have
	   * been worth it (based on what I've seen so far) */
	  if(print_flag)
	    printf("cur max_local_sc: %f\n\n", max_local_sc);
	  if(max_local_sc < (cm->beginsc[v] + lsc[tidx]))
	    {
	      max_local_sc = cm->beginsc[v] + lsc[tidx];
	      if(print_flag)
		printf("\nNEW max_local_sc: %f\n\n", max_local_sc);
	    }
	}
	}
  free(v2n_map);
  free(v2n_ct);
  free(lsc);
  free(tr_esc);
  free(tr_tsc);
  /*printf("in ParsetreeScore_Global2Local() returning sc: %f\n", max_local_sc);*/
  return max_local_sc;

 ERROR:
  cm_Fail("ERROR in ParsetreeScore_Global2Local()\n");
  return -1.;
}

/* Function: Parsetree2CP9trace()
 * Incept:   EPN, Wed May 30 09:33:01 2007
 *
 * Purpose: Convert a CM parsetree into it's implicit CP9 trace.
 * Returns: eslOK on success
 *
 * Args:
 * CM_t  *cm                - the CM, with valid cp9
 * Parsetree_t *cm_tr       - valid parsetree to convert
 * cp9trace_s *ret_cp9_tr   - the CP9 trace to return, alloc'ed here
 */
int
Parsetree2CP9trace(CM_t *cm, Parsetree_t *tr, CP9trace_t **ret_cp9_tr)
{
  /* Check the contract */
  if(cm->cp9 == NULL || (!(cm->flags & CMH_CP9)))
	cm_Fail("In Parsetree2CP9trace, cm->cp9 is not valid.\n");
  if(cm->cp9map == NULL)
	cm_Fail("In Parsetree2CP9trace, cm->cp9map is NULL.\n");

  int status;                    /* Easel status                            */
  CP9trace_t *cp9_tr;            /* the CP9 trace we're creating            */
  int **ks_ct = NULL;            /* [0..2][0..cp9->M] number of times each state was used
				  * 1st D: 0 = MATCH, 1 = INSERT, 2 = DELETE */
  int  tidx;                     /* counter over parsetree nodes */
  int  v;                        /* CM state index */
  int  k, ks;                    /* HMM nodes and state indices */
  int  i;                        /* generic counter */
  int  cp9_tr_size;              /* number of nodes we'll need for cp9_tr */
  int  lmost_k;                  /* left most HMM node visited in parse (often 1) */
  int  rmost_k;                  /* right most HMM node visited in parse (often M) */
  int  ip;
  int  ins_ct = 0;               /* total number of inserts */
  CP9_t *cp9 = NULL;

  cp9 = cm->cp9;

  lmost_k = cp9->M + 1;
  rmost_k = 0;

  ESL_ALLOC(ks_ct,           sizeof(int *) * 3);
  for(ks = 0; ks < 3; ks++)
	{
	  ESL_ALLOC(ks_ct[ks], sizeof(int) * (cp9->M+1));
	  esl_vec_ISet(ks_ct[ks], cp9->M+1, 0);
	}

  /* Traverse parsetree, keeping track of implied HMM states used by each HMM node. */
  v = tr->state[0];
  if(v != 0) cm_Fail("ERROR in Parsetree2CP9Trace(), first Parsetree node not root.\n");
  /* we leave ks_ct[HMMMATCH][0] as 0 for convenience later, we know it was used. */

  for (tidx = 1; tidx < tr->n; tidx++)
	{
	  v  = tr->state[tidx];        	/* index of parent state in CM */
	  for(i = 0; i < 2; i++) /* each CM state maps to 0, 1 or 2 HMM states */
	{
	  k  = cm->cp9map->cs2hn[v][i];
	  ks = cm->cp9map->cs2hs[v][i];
	  if(k == -1) continue; /* when HMM EL's are implemented, we'll have to have a special
				 * case for them, but for now we visit deletes in between. */
	  ks_ct[ks][k]++;
	  if(ks == HMMINSERT) ins_ct++;
	}
	}
  /* Determine the first (leftmost) node used and last (rightmost) node used,
   * anything else was skipped by a smith-waterman local begin or end. */
  lmost_k = 1;
  rmost_k = cp9->M;
  if(cp9->flags & CPLAN9_LOCAL_BEGIN)
	{
	  while((ks_ct[HMMMATCH][lmost_k] + ks_ct[HMMINSERT][lmost_k] + ks_ct[HMMDELETE][lmost_k]) == 0)
	lmost_k++;
	}
  if(cp9->flags & CPLAN9_LOCAL_END)
	{
	  while((ks_ct[HMMMATCH][rmost_k] + ks_ct[HMMINSERT][rmost_k] + ks_ct[HMMDELETE][rmost_k]) == 0)
	rmost_k--;
	}
  /* Now build the CP9 trace */
  cp9_tr_size = (rmost_k - lmost_k + 1) + ins_ct + 2; /* number of match/deletes we'll visit plus
						       * number of inserts + begin/end */
  CP9AllocTrace(cp9_tr_size, &cp9_tr);  /* allow room for B & E */
  /* start at node 0 with the begin */
  cp9_tr->statetype[0] = CSTB;
  cp9_tr->nodeidx[0]   = 0;
  cp9_tr->pos[0]       = 0;
  tidx = 1;
  i    = 1;
  /* are there inserts from node 0? */
  for(ip = 0; ip < ks_ct[HMMINSERT][0]; ip++)
	{
	  cp9_tr->statetype[tidx] = CSTI;
	  cp9_tr->nodeidx[tidx]   = 0;
	  cp9_tr->pos[tidx]       = i++;
	  tidx++;
	}
  /* now go through nodes 1..M */
  for(k = lmost_k; k <= rmost_k; k++)
	{
	  if(ks_ct[HMMMATCH][k])
	{
	  cp9_tr->statetype[tidx] = CSTM;
	  cp9_tr->nodeidx[tidx]   = k;
	  cp9_tr->pos[tidx]       = i++;
	  tidx++;
	}
	  else if(ks_ct[HMMDELETE][k])
	{
	  cp9_tr->statetype[tidx] = CSTD;
	  cp9_tr->nodeidx[tidx]   = k;
	  cp9_tr->pos[tidx]       = 0;
	  tidx++;
	}
	  else /* skipped due to local end, treat as delete for now */
	{
	  cp9_tr->statetype[tidx] = CSTD;
	  cp9_tr->nodeidx[tidx]   = k;
	  cp9_tr->pos[tidx]       = 0;
	  tidx++;
	}
	  for(ip = 0; ip < ks_ct[HMMINSERT][k]; ip++)
	{
	  cp9_tr->statetype[tidx] = CSTI;
	  cp9_tr->nodeidx[tidx]   = k;
	  cp9_tr->pos[tidx]       = i++;
	  tidx++;
	}
	}
  /* all traces end with E state */
  cp9_tr->statetype[tidx]  = CSTE;
  cp9_tr->nodeidx[tidx]    = 0;
  cp9_tr->pos[tidx]        = 0;
  tidx++;
  cp9_tr->tlen = tidx;

  *ret_cp9_tr = cp9_tr;

  for(ks = 0; ks < 3; ks++)
	if(ks_ct[ks] != NULL) free(ks_ct[ks]);
  if(ks_ct != NULL) free(ks_ct);
  return eslOK;

 ERROR:
  for(ks = 0; ks < 3; ks++)
	if(ks_ct[ks] != NULL) free(ks_ct[ks]);
  if(ks_ct != NULL) free(ks_ct);
  return eslFAIL;
}

/* Function: rightjustify()
 *
 * Purpose:  Given a gap-containing string of length n,
 *           pull all the non-gap characters as far as
 *           possible to the right, leaving gaps on the
 *           left side. Used to rearrange the positions
 *           of insertions in CM generated alignments.
 */
void
rightjustify(const ESL_ALPHABET *abc, char *s, int n)
{
  int npos;
  int opos;

  npos = n-1;
  opos = n-1;
  while (opos >= 0) {
	if (esl_abc_CIsGap(abc, s[opos]))
	  opos--;
	else
	  s[npos--]=s[opos--];
  }
  while (npos >= 0)
	s[npos--] = '.';
}

/* Function: leftjustify()
 *
 * Purpose:  Given a gap-containing string of length n,
 *           pull all the non-gap characters as far as
 *           possible to the left, leaving gaps on the
 *           right side. Used to rearrange the positions
 *           of insertions in CM generated alignments.
 */
void
leftjustify(const ESL_ALPHABET *abc, char *s, int n)
{
  int npos;
  int opos;

  npos = 0;
  opos = 0;
  while (opos < n) {
	if (esl_abc_CIsGap(abc, s[opos]))
	  opos++;
	else
	  s[npos++]=s[opos++];
  }
  while (npos < n)
	s[npos++] = '.';
}

/* Function:  EmitParsetree()
 * Incept:    SRE, Mon Oct 13 22:35:46 2003 [Rams whupping Falcons, Monday Night Football]
 *            Easel'ed: EPN, Fri Aug  3 08:15:12 2007
 *
 * Purpose:   Sample a parsetree and sequence from the joint distribution
 *            Prob(sequence, parsetree | CM).
 *
 *            Be careful screwing with the logic in here. You've got
 *            two tree traversals going simultaneously: a traversal of
 *            the CM, and a traversal of the growing parsetree. It
 *            wasn't obvious how to get it all to work in step
 *            together. Remember, one of your constraints is that the
 *            parsetree is numbered in preorder traversal - so you
 *            must push and defer the right child of a bifurcation,
 *            rather than attaching it immediately.  Another
 *            constraint is that you must set emitr in the parsetree
 *            even for nonemitting states, so you must always push a right
 *            marker along with a parsetree node index tpos, for deferred
 *            assignment of tr->emitr[tpos]. And since you don't
 *            know tpos until you've attached the state, you have to
 *            push the right marker after your deferred attachment of v - not
 *            when v was produced - which is why you have a double
 *            deferral of the right emission or marker: you produce
 *            a V b, push that info onto the pda, pop it back off,
 *            attach V, store a, push b back onto the pda (now storing
 *            the trace position tpos for V), then produce from V.
 *            Yeesh.
 *
 *            Added capacity for local begins/ends. [EPN, Wed May  2 05:59:19 2007]
 *
 * Args:      cm      - covariance model to generate from
 *            errbuf  - for error messages
 *            r       - source of randomness
 *            name    - name for the sequence (ESL_SQ name field is mandatory)
 *            do_digital - TRUE to digitize sq before returning, FALSE not to
 *            ret_tr  - RETURN: generated parse tree. Pass NULL if unwanted.
 *            ret_sq  - RETURN: generated sequence
 *            ret_N   - RETURN: length of generated sequence.
 *
 * Returns:   eslOK on success; eslEMEM on memory error;
 *            eslEINCONCEIVABLE if something inconceivable happens.
 *            tr, sq are allocated here; whichever ones the caller
 *            requests (with non-NULL ret_ pointers) the caller is responsible
 *            for free'ing:
 *               FreeParsetree(tr); esl_sq_Destroy(sq);
 */
int
EmitParsetree(CM_t *cm, char *errbuf, ESL_RANDOMNESS *r, char *name, int do_digital, Parsetree_t **ret_tr, ESL_SQ **ret_sq, int *ret_N)
{
  int status;
  Parsetree_t *tr = NULL;       /* parse tree under construction */
  ESL_STACK *pda = NULL;        /* pushdown automaton for traversing parse tree */
  ESL_STACK *gsq = NULL;        /* growing sequence under construction */
  ESL_SQ    *sq  = NULL;        /* finished sequence, initially normal alphabet form */
  char      *seq;               /* alphabetic sequence to build sq with */
  int N;			/* current emitted sequence length */
  int tparent;			/* parent node index, last attached to parse tree */
  int tpos;			/* child node index, just attached to parse tree */
  int v;			/* index of current state */
  int y,z;			/* indices for next state(s)    */
  int type;			/* PDA_RESIDUE or PDA_STATE */
  int lchar, rchar;		/* index of emitted chars in cm->abc->sym[], or -1 for nothing */
  int whichway;			/* how to attach: TRACE_LEFT_CHILD or TRACE_RIGHT_CHILD */
  int x;			/* tmp variable for sampling MP emission */
  int lpos;                     /* tmp variable for inserting EL trace node */
  float *tmp_tvec = NULL;       /* tmp transition vector to choose from,
				 * for dealing with local end transitions */
  /* Contract check */
  if(cm->flags & CMH_LOCAL_END && (fabs(sreEXP2(cm->el_selfsc) - 1.0) < 0.01))
	ESL_FAIL(eslEINVAL, errbuf, "EL self transition probability %f is too high, would emit long (too long) EL insertions.", sreEXP2(cm->el_selfsc));
  if(cm->abc == NULL)
	ESL_FAIL(eslEINVAL, errbuf, "CM does not have a valid alphabet.");
  if(ret_sq != NULL && name == NULL)
	ESL_FAIL(eslEINVAL, errbuf, "EmitParsetree requires a sequence name for the sequence it's creating.");

  tr  = CreateParsetree(100);
  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  if((gsq = esl_stack_CCreate()) == NULL) goto ERROR;
  N   = 0;
  ESL_ALLOC(tmp_tvec, sizeof(float) * (MAXCONNECT+1)); /* enough room for max possible transitions, plus
							* a local end transition */
  /* Init by pushing root state's info onto pda
   */
  if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit an rchar */
  if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit an lchar either */
  if((status = esl_stack_IPush(pda, TRACE_LEFT_CHILD)) != eslOK) goto ERROR;
  if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* attach this state to parsetree node -1 (init) */
  if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;		/* it's the root state, v=0 */
  if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;

  /* Iterate until the pda is empty...
   */
  while (esl_stack_IPop(pda, &type) != eslEOD)
	{
	  if (type == PDA_RESIDUE)
	{
	  esl_stack_IPop(pda, &tpos);
	  esl_stack_IPop(pda, &rchar);

	  if (rchar != -1) {
	    if((status = esl_stack_CPush(gsq, cm->abc->sym[rchar])) != eslOK) goto ERROR;
	    N++;
	  }
	  tr->emitr[tpos] = N;
	}
	  else if (type == PDA_STATE)
	{
	  esl_stack_IPop(pda, &v);
	  esl_stack_IPop(pda, &tparent);
	  esl_stack_IPop(pda, &whichway);
	  esl_stack_IPop(pda, &lchar);
	  esl_stack_IPop(pda, &rchar);

	  /* Attach state v to the parent parsetree node that generated it,
	   * which is tparent. Set emitl now; emitr gets deferred and set later.
		   * The insertion function returns tpos, the index of the node in the
		   * parse tree that we just created.
	   */
	  tpos = InsertTraceNode(tr, tparent, whichway, N+1, -1, v);

	  /* If v emitted left: add that symbol to the growing seq.
	   */
	  if (lchar != -1)
	    {
	      if((status = esl_stack_CPush(gsq, cm->abc->sym[lchar])) != eslOK) goto ERROR;
	      N++;
	    }

	  /* Push right emission info for state v onto the pda, now
		   * that we know tpos for where v is in the parsetree. We have
		   * to do this even if rchar is -1, to be sure that we will set the emitr
		   * bound properly even for nonemitting states in the parsetree.
	   */
	  if((status = esl_stack_IPush(pda, rchar)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, tpos)) != eslOK) goto ERROR;
	  if((status = esl_stack_IPush(pda, PDA_RESIDUE)) != eslOK) goto ERROR;

	  /* Decide what state we're going to next.
		   * B is special case of a bifurcation to two S states.
	   */
	  if (cm->sttype[v] == B_st)
	    {
	      y = cm->cfirst[v];	/* left child  */
	      z = cm->cnum[v];	        /* right child */

	      /* Push the right start state's info
	       */
	      if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit right */
	      if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit left */
	      if((status = esl_stack_IPush(pda, TRACE_RIGHT_CHILD)) != eslOK) goto ERROR; /* attach as right child of the B */
	      if((status = esl_stack_IPush(pda, tpos)) != eslOK) goto ERROR;		/* attach it to B, which is tpos in parsetree*/
	      if((status = esl_stack_IPush(pda, z)) != eslOK) goto ERROR;		/* state z */
	      if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;

	      /* Push the left start state's info
	       */
	      if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit right */
	      if((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR;		/* doesn't emit left */
	      if((status = esl_stack_IPush(pda, TRACE_LEFT_CHILD)) != eslOK) goto ERROR; /* attach as left child of the B */
	      if((status = esl_stack_IPush(pda, tpos)) != eslOK) goto ERROR;		/* attach it to B, which is tpos in parsetree*/
	      if((status = esl_stack_IPush(pda, y)) != eslOK) goto ERROR;		/* state z */
	      if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	    }
	  else
	    {
	      if(v == 0 && cm->flags & CMH_LOCAL_BEGIN)	{ /* ROOT_S with local begins, special */
		if(cm->flags & CM_EMIT_NO_LOCAL_BEGINS) { /* even though local begins are on, we don't allow them during emission */
		  if(cm->root_trans == NULL) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "EmitParsetree(), cm->flags CM_EMIT_NO_LOCAL_BEGINS and CM_EMIT_GLOBAL flags raised, but cm->root_trans is NULL.");
		  y = cm->cfirst[v] + esl_rnd_FChoose(r, cm->root_trans, cm->cnum[0]); /* choose next state, y, from 0's children using initial transitions (those from global model, read from CM file) */
		}
		else {
		  y = esl_rnd_FChoose(r, cm->begin, cm->M); /* choose next state, y */
		}
	      }
	      else if(cm->flags & CMH_LOCAL_END) /* special case, we could transit to EL, if CM_EMIT_NO_LOCAL_ENDS flag is down */
		{
		  if(cm->flags & CM_EMIT_NO_LOCAL_ENDS) { /* even though local ends are on, we dont allow them during emission */
		    /* create temporary vector for choosing transition */
		    esl_vec_FSet(tmp_tvec, (MAXCONNECT+1), 0.);
		    esl_vec_FCopy(cm->t[v], cm->cnum[v], tmp_tvec);
		    esl_vec_FNorm(tmp_tvec, cm->cnum[v]);
		    y = cm->cfirst[v] + esl_rnd_FChoose(r, tmp_tvec, cm->cnum[v]); /* choose next state, y, but don't include a local end as a possibility */
		  }
		  else { /* we may choose a child of v, or a local end */
		    esl_vec_FSet(tmp_tvec, (MAXCONNECT+1), 0.);
		    esl_vec_FCopy(cm->t[v], cm->cnum[v], tmp_tvec);
		    tmp_tvec[cm->cnum[v]] = cm->end[v];
		    y = esl_rnd_FChoose(r, tmp_tvec, (cm->cnum[v]+1)); /* choose next state, y's offset */
		    if(y == cm->cnum[v]) y = cm->M; /* local end */
		    else y += cm->cfirst[v];
		  }
		}
	      else
		y = cm->cfirst[v] + esl_rnd_FChoose(r, cm->t[v], cm->cnum[v]); /* choose next state, y */

	      switch (cm->sttype[y]) {
	      case MP_st:
		x     = esl_rnd_FChoose(r, cm->e[y], cm->abc->K*cm->abc->K);
		lchar = x / cm->abc->K;
		rchar = x % cm->abc->K;
		break;
	      case ML_st:
	      case IL_st:
		lchar = esl_rnd_FChoose(r, cm->e[y], cm->abc->K);
		rchar = -1;
		break;
	      case MR_st:
	      case IR_st:
		lchar = -1;
		rchar = esl_rnd_FChoose(r, cm->e[y], cm->abc->K);
		break;
	      case EL_st: /* EL emits on transition, here we don't emit */
		lchar = -1;
		rchar = -1;
		break;
	      default:
		lchar = -1;
		rchar = -1;
	      }
	      if (cm->sttype[y] == E_st)
		{
		  /*InsertTraceNode(tr, tpos, TRACE_LEFT_CHILD, -1, -1, y);*/
		  InsertTraceNode(tr, tpos, TRACE_LEFT_CHILD, N+1, N, y);
		}
	      else if(cm->sttype[y] == EL_st) /* y == cm->M */
		{
		  lpos = N+1; /* remember lpos, we need it after we emit from EL */
		  /* Now choose number of residues emitted from EL, could be 0.
		   * We do this here b/c convention for EL is to have a single trace node,
		   * even if multiple residues are emitted. */
		  esl_vec_FSet(tmp_tvec, (MAXCONNECT+1), 0.);
		  tmp_tvec[0] = sreEXP2(cm->el_selfsc); /* EL self probability */
		  tmp_tvec[1] = 1. - tmp_tvec[0];       /* probability of going to implicit END */
		  y = esl_rnd_FChoose(r, tmp_tvec, 2); /* choose next state, either EL or implicit END */
		  while(y == 0) /* we've self-transitioned, emit 1 res from NULL distro */
		    {
		      lchar = esl_rnd_FChoose(r, cm->null, cm->abc->K);
		      if((status = esl_stack_CPush(gsq, cm->abc->sym[lchar])) != eslOK) goto ERROR;
		      N++;
		      y = esl_rnd_FChoose(r, tmp_tvec, 2); /* choose next state, either EL or implicit END */
		    }
		  InsertTraceNode(tr, tpos, TRACE_LEFT_CHILD, lpos, N, cm->M); /* careful to reset y to cm->M */
		}
	      else
		{
		  if((status = esl_stack_IPush(pda, rchar)) != eslOK) goto ERROR;		/* does it emit right? */
		  if((status = esl_stack_IPush(pda, lchar)) != eslOK) goto ERROR;		/* does it emit left? */
		  if((status = esl_stack_IPush(pda, TRACE_LEFT_CHILD)) != eslOK) goto ERROR; /* non-B's: attach as left child by conv */
		  if((status = esl_stack_IPush(pda, tpos)) != eslOK) goto ERROR;		/* attach it to v, which is tpos in parsetree*/
		  if((status = esl_stack_IPush(pda, y)) != eslOK) goto ERROR;		/* next state we're going to */
		  if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
		}
	    } /* end of PDA_STATE logic */
	} /* end of else (which we enter if v not a B state) */
	} /* end of main "while esl_stack_IPop()" loop */

  if((seq = esl_stack_Convert2String(gsq)) == NULL) goto ERROR; /* this destroys gsq char stack */
  if(name != NULL) sq  = esl_sq_CreateFrom(name, seq, NULL, NULL, NULL);
  else             sq  = esl_sq_CreateFrom("seq", seq, NULL, NULL, NULL);
  if(sq == NULL) goto ERROR;
  free(seq); /* we made a copy of this when creating sq */
  /* name can only be NULL if ret_sq == NULL, so we're throwing it away anyway */

  /* digitize if nec */
  if(do_digital)
	if((status = esl_sq_Digitize(cm->abc, sq)) != eslOK) goto ERROR;
  /*ParsetreeDump(stdout, tr, cm, dsq);*/

  esl_stack_Destroy(pda);

  free(tmp_tvec);
  if (ret_tr  != NULL) *ret_tr  = tr;  else FreeParsetree(tr);
  if (ret_sq  != NULL) *ret_sq  = sq;  else esl_sq_Destroy(sq);
  if (ret_N   != NULL) *ret_N   = N;
  return eslOK;

 ERROR:
  if(tr  != NULL) FreeParsetree(tr);
  if(gsq != NULL) esl_stack_Destroy(gsq);
  if(pda != NULL) esl_stack_Destroy(pda);
  if(sq  != NULL) esl_sq_Destroy(sq);
  if(tmp_tvec != NULL) free(tmp_tvec);
  return status;
}

/* Function: ParsetreeScoreCorrectionNull2()
 * based on     TraceScoreCorrection() from HMMER:
 * EPN 08.24.06 Janelia
 *
 * Purpose:  Calculate a correction (in log_2 odds) to be
 *           applied to a sequence, using a second null model,
 *           based on a traceback. All emissions are corrected;
 *           The null model is constructed /post hoc/ as the
 *           average over all the emission distributions used by the trace.
 *
 *           <omega> is the prior probability of the null3 model.
 *           The log of this value is the penalty for the null3
 *           correction. If <omega> is 1./65536., which it is
 *           by default (1/2^16), we apply a 16 bit penalty.
 *
 * Return:   ret_sc: the log_2-odds score correction.
 *           eslEINCOMPAT on contract violation
 */
int
ParsetreeScoreCorrectionNull2(CM_t *cm, char *errbuf, Parsetree_t *tr, ESL_DSQ *dsq, int start, float omega, float *ret_sc)
{
  int status;
  float *p;		/* null2 model distribution */
  float *sc;	        /* null2 model scores       */
  int   a,b;            /* residue index counters */
  int   v;              /* state index counter */
  int   i, j;           /* seq posn counter */
  int   tidx;
  float score;
  float struct_score;   /* structure contribution to the score */

  if(ret_sc == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "ParsetreeScoreCorrectionNull2() ret_sc is NULL.");

  /* Rarely, the alignment was totally impossible, and tr is NULL.
   */
  if (tr == NULL) return 0.0;

  /* Set up model: average over the emission distributions of
   * all M, I states that appear in the trace. Ad hoc? Sure, you betcha.
   */
  /* trivial preorder traverse, since we're already numbered that way */
  ESL_ALLOC(p, sizeof(float) * cm->abc->K);
  esl_vec_FSet(p, cm->abc->K, 0.0);
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	if(cm->sttype[v] == MP_st) {
	  /* we treat this as two match states. */
	  for(a = 0; a < cm->abc->K; a++) {
	/* first add contribution to null2 for left half. */
	for(b = (a * cm->abc->K); b < ((a+1) * cm->abc->K); b++) p[a] += cm->e[v][b];
	/* now add contribution for right half. */
	for(b = a; b < (cm->abc->K * cm->abc->K); b += cm->abc->K) p[a] += cm->e[v][b];
	  }
	}
	else if(cm->sttype[v] == ML_st || cm->sttype[v] == IL_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	  esl_vec_FAdd(p, cm->e[v], cm->abc->K);
	}
  }
  esl_vec_FNorm(p, cm->abc->K);

  ESL_ALLOC(sc,  sizeof(float) * (cm->abc->Kp));
  /* calculate null2 scores of each possible emission, first the base alphabet */
  for (a = 0; a < cm->abc->K; a++) sc[a] = sreLOG2(p[a] / cm->null[a]);
  /* the ambiguities */
  for (a = cm->abc->K+1; a < cm->abc->Kp-1; a++) sc[a] = esl_abc_FAvgScore(cm->abc, a, sc);

  /* Score all the state emissions that appear in the trace.
   */
  score = struct_score = 0;
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	i = tr->emitl[tidx];
	j = tr->emitr[tidx];
	if (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) score += sc[dsq[i+start-1]];
	if (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) score += sc[dsq[j+start-1]];
  }
   /* Apply an ad hoc log(omega) fudge factor penalty;
	* interpreted as a prior, saying that the third null model is
	* <omega> as likely as the standard null model.
	* <omega> is by default 1/(2^16), so this is by default a
	* 16 bit penalty.
	*/
  score += sreLOG2(omega);

  /* Return the correction to the bit score. */
  ESL_DPRINTF1(("ParsetreeScoreCorrectionNull2 return sc: %f\n", LogSum2(0., score)));
  free(sc);
  free(p);
  score = LogSum2(0., score);
  *ret_sc = score;
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "ParsetreeScoreCorrectionNull2(): memory allocation error.");
  return status; /* NEVERREACHED*/
}

/* Function: ParsetreeScoreCorrectionNull3()
 * Incept:   EPN, Sat May  3 15:38:24 2008
 *
 * Purpose:  Calculate a correction (in log_2 odds) to be
 *           applied to a sequence, using a third null model, the
 *           composition of the target sequence.
 *           All emissions are corrected;
 *           The null model is constructed /post hoc/ as the
 *           distribution of the target sequence; if the target
 *           sequence is 40% A, 5% C, 5% G, 40% U, then the null
 *           model is (0.4, 0.05, 0.05, 0.4).
 *
 *           NOTE: (start) is offset in dsq such that tr->emitl[0] corresponds
 *           to the residue in dsq[1];
 *
 *           <omega> is the prior probability of the null3 model.
 *           The log of this value is the penalty for the null3
 *           correction. If <omega> is 1./65536., which it is
 *           by default (1/2^16), we apply a 16 bit penalty.
 *
 * Return:   ret_sc: the log_2-odds score correction.
 *           eslEINCOMPAT on contract violation
 */
int
ParsetreeScoreCorrectionNull3(CM_t *cm, char *errbuf, Parsetree_t *tr, ESL_DSQ *dsq, int start, float omega, float *ret_sc)
{
  int status;
  float *p;		/* null3 model distribution */
  float *sc;	        /* null3 model scores       */
  int   a;              /* residue index counters */
  int   v;              /* state index counter */
  int   i, j;           /* seq posn counter */
  int   tidx;
  float score;
  float struct_score;   /* structure contribution to the score */

  if(ret_sc == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "ParsetreeScoreCorrectionNull3() ret_sc is NULL.");
  /* Rarely, the alignment was totally impossible, and tr is NULL.
   */
  if (tr == NULL) return 0.0;

  /* get composition of full subseq in parse from tr->emitl[0]..tr->emitr[0],
   * starting at dsq+start-1 b/c coords in tr->emit* are offset relative to dsq by start
   * such that tr->emitl[0] always equals 1.
   * Note: we're INcluding any EL emissions here in ACGU composition calculation but then
   * EXcluding them when we correct the score below (not sure if this is right),
   * in a way we're always assuming scores of ELs are 0.0, meaning there's no difference
   * between the probability they're emitted by the model and any possible NULL model.
   */
  get_alphabet_comp(cm->abc, dsq+start-1, tr->emitl[0], tr->emitr[0], &p);
  ESL_ALLOC(sc,  sizeof(float) * (cm->abc->Kp));
  /* calculate null3 scores of each possible emission, first the base alphabet */
  for (a = 0; a < cm->abc->K; a++) {
	sc[a] = sreLOG2(p[a] / cm->null[a]);
	/*printf("p[%d]: %.3f sc %.3f\n", a, p[a], sc[a]);*/
  }
  /* the ambiguities */
  for (a = cm->abc->K+1; a < cm->abc->Kp-1; a++) sc[a] = esl_abc_FAvgScore(cm->abc, a, sc);

  /* Score all the state emissions that appear in the trace.
   */
  score = struct_score = 0.;
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	i = tr->emitl[tidx];
	j = tr->emitr[tidx];
	if (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) score += sc[dsq[i+start-1]];
	if (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) score += sc[dsq[j+start-1]];
  }
   /* Apply an ad hoc log(omega) fudge factor penalty;
	* interpreted as a prior, saying that the third null model is
	* <omega> as likely as the standard null model.
	* <omega> is by default 1/(2^16), so this is by default a
	* 16 bit penalty.
	*/
  score += sreLOG2(omega);

  /* Return the correction to the bit score. */
  /*printf("ParsetreeScoreCorrectionNull3 return sc: %f\n", LogSum2(0., score));*/
  ESL_DPRINTF1(("ParsetreeScoreCorrectionNull3 return sc: %f\n", LogSum2(0., score)));
  free(sc);
  free(p);
  score = LogSum2(0., score);
  *ret_sc = score;
  return eslOK;

 ERROR:
   ESL_FAIL(status, errbuf, "ParsetreeScoreCorrectionNull3(): memory allocation error.");
   return status; /* NEVERREACHED*/
}

/* Function: ScoreCorrectionNull3()
 * Incept:   EPN, Sat May 10 17:58:03 2008
 *
 * Purpose:  Calculate a correction (in log_2 odds) to be
 *           applied to a sequence, using a third null model, the
 *           composition of the target sequence.
 *           All emissions are corrected;
 *           The null model is constructed /post hoc/ as the
 *           distribution of the target sequence; if the target
 *           sequence is 40% A, 5% C, 5% G, 40% U, then the null
 *           model is (0.4, 0.05, 0.05, 0.4).
 *
 *           Note: no trace or parsetree is needed. The bit score correction
 *           can be derived solely by the nucleotide composition of the hit and
 *           it's length.
 *
 *           <omega> is the prior probability of the null3 model.
 *           The log of this value is the penalty for the null3
 *           correction. If <omega> is 1./65536., which it is
 *           by default (1/2^16), we apply a 16 bit penalty.
 *
 * Args:     abc  - alphabet for hit (only used to get alphabet size, which is size of <comp>)
 *           null0- the first null model used when building the CM, usually cm->null or cm->cp9->null
 *           comp - [0..a..abc->K-1] frequency of residue a in the hit we're correcting the score for,
 *                  passed in b/c we can efficiently compute this during scanning DP funcs instead of
 *                  calcing it each time per hit which is wasteful for many, possibly overlapping hits
 *                  which is the case during model calibration with cmcalibrate.
 *           len  - length of the hit
 *           ret_sc- RETURN: the correction to the score, caller subtracts this from hit score to get
 *                   corrected score.
 *
 * Return:   void, ret_sc: the log_2-odds score correction.
 */
void
ScoreCorrectionNull3(const ESL_ALPHABET *abc, float *null0, float *comp, int len, float omega, float *ret_sc)
{
  int   a;              /* residue index counters */
  float score = 0.;

  /*printf("\n");
	esl_vec_FDump(stdout, comp, abc->K, NULL);*/

  for (a = 0; a < abc->K; a++) score += sreLOG2(comp[a] / null0[a]) * comp[a] * len;

   /* Apply an ad hoc log(omega) fudge factor penalty;
	* interpreted as a prior, saying that the third null model is
	* <omega> as likely as the standard null model.
	* <omega> is by default 1/(2^16), so this is by default a
	* 16 bit penalty.
	*/
  score += sreLOG2(omega);

  /* Return the correction to the bit score. */

  /* Return the correction to the bit score. */
  /*printf("ScoreCorrectionNull3 return sc: %.3f\n", LogSum2(0., score));*/
  ESL_DPRINTF3(("ScoreCorrectionNull3 return sc: %f\n", LogSum2(0., score)));
  score = LogSum2(0., score);
  *ret_sc = score;
  return;
}

/* Function: ScoreCorrectionNull3CompUnknown()
 * Incept:   EPN, Thu May 22 13:16:04 2008
 *
 * Purpose:  Calculate a correction (in log_2 odds) to be
 *           applied to a sequence, using a third null model, the
 *           composition of the target sequence.
 *           All emissions are corrected;
 *           The null model is constructed /post hoc/ as the
 *           distribution of the target sequence; if the target
 *           sequence is 40% A, 5% C, 5% G, 40% U, then the null
 *           model is (0.4, 0.05, 0.05, 0.4).
 *
 *           Same as ScoreCorrectionNull3() except that no <comp> vector is needed,
 *           the composition is determined within this function.
 *
 *           <omega> is the prior probability of the null3 model.
 *           The log of this value is the penalty for the null3
 *           correction. If <omega> is 1./65536., which it is
 *           by default (1/2^16), we apply a 16 bit penalty.
 *
 * Args:     abc  - alphabet for hit (only used to get alphabet size, which is size of <comp>)
 *           null0- the first null model used when building the CM, usually cm->null or cm->cp9->null
 *           dsq  - the sequence the hit resides in
 *           start- start position of hit in dsq
 *           end  - end   position of hit in dsq
 *           ret_sc- RETURN: the correction to the score, caller subtracts this from hit score to get
 *                   corrected score.
 * Return:   void, ret_sc: the log_2-odds score correction.
 */
void
ScoreCorrectionNull3CompUnknown(const ESL_ALPHABET *abc, float *null0, ESL_DSQ *dsq, int start, int stop, float omega, float *ret_sc)
{
  float score = 0.;
  float *comp;		/* null3 model distribution */

  get_alphabet_comp(abc, dsq, start, stop, &comp);
  ScoreCorrectionNull3(abc, null0, comp, (stop-start+1), omega, &score);
  free(comp);
  *ret_sc = score;
  return;
}

/* Function: ParsetreeCountMPEmissions()
 * Date:     EPN, Thu May 22 14:11:28 2008
 *
 * Purpose:  Given a parsetree, return the number of residues emitted by MP states.
 *
 * Returns:  Number of residues emitted by MP states in <tr>.
 */
int
ParsetreeCountMPEmissions(CM_t *cm, Parsetree_t *tr)
{
  int tidx;
  int nres_by_mp = 0;

  for (tidx = 0; tidx < tr->n; tidx++) {
	if(cm->sttype[tr->state[tidx]] == MP_st) nres_by_mp += 2;
  }
  return nres_by_mp;
}

/* Function: Alignment2Parsetrees()
 * EPN, Fri Jul 11 09:49:50 2008
 *
 * Purpose:  Given a MSA <msa>, a CM <cm> and a guidetree <mtr> for <cm>,
 *           Determine the implicit parsetrees of the sequences in the
 *           MSA to the CM. Return the parsetrees in <ret_tr> if non-NULL,
 *           sequence objects in <ret_sq> if non-null.
 *
 *           Dealign the MSA seqs in <ret_sq> and convert from aligned to
 *           unaligned coordinates in <ret_tr>.
 *
 * Args:     msa          - MSA we want to infer parsetrees from
 *           cm           - CM we're aligning to
 *           mtr          - master parsetree, guide tree for CM
 *           errbuf       - easel error message
 *           ret_sq       - Return: dealigned msa seqs in digital form
 *           ret_tr       - Return: parsetree for seqs in dealigned coords
 *
 * Returns:  eslOK on success, eslEINCOMPAT on contract violation, eslEMEM on memory error
 *           <ret_tr>, <ret_sq>, see 'Purpose'.
 */
int
Alignment2Parsetrees(ESL_MSA *msa, CM_t *cm, Parsetree_t *mtr, char *errbuf, ESL_SQ ***ret_sq, Parsetree_t ***ret_tr)
{
  int           status;
  int           i;	        /* counter over aseqs       */
  int           apos;           /*   aligned position index */
  int           uapos;          /* unaligned position index */
  int           x;              /* counter of parsetree nodes */
  int          *map     = NULL; /* for current seq, [0..msa->alen] map from aligned posns to unaligned (non-gap) posns */
  int          *used_el = NULL; /* [0..msa->alen] used_el[apos] is TRUE if position apos is modeled by EL state, FALSE if not */
  char         *uaseq   = NULL; /* current seq, dealigned from the MSA */
  char         *aseq    = NULL; /* current seq, aligned text */
  Parsetree_t **tr      = NULL; /* [0..msa->nseq-1] new parsetrees, one per seq in msa */
  ESL_SQ      **sq      = NULL; /* [0..msa->nseq-1] new ESL_SQ objects, one per seq in msa */

  /* Contract check */
  if(msa == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "Alignment2Parsetrees() msa is NULL.\n");
  if(! (msa->flags & eslMSA_DIGITAL))  ESL_FAIL(eslEINCOMPAT, errbuf, "Alignment2Parsetrees() msa is not digitized.\n");
  if(ret_tr == NULL && ret_sq == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "Alignment2Parsetrees() ret_sq and ret_tr both NULL.");

  if(ret_tr != NULL) ESL_ALLOC(tr, (sizeof(Parsetree_t *) * msa->nseq));
  if(ret_sq != NULL) ESL_ALLOC(sq, (sizeof(ESL_SQ *)      * msa->nseq));
  ESL_ALLOC(aseq,    sizeof(char) * (msa->alen+1));
  ESL_ALLOC(map,     sizeof(int)  * (msa->alen+1));
  ESL_ALLOC(used_el, sizeof(int)  * (msa->alen+1));
  map[0] = -1; /* invalid */
  used_el[0] = FALSE; /* invalid */
  if(msa->rf != NULL) {
	for(apos = 0; apos < msa->alen; apos++) {
	  used_el[apos+1] = (msa->rf[apos] == '~') ? TRUE : FALSE;
	}
  }
  else {
	/* no msa->rf, impossible to tell if any columns are EL, assume none are */
	esl_vec_ISet(used_el, msa->alen+1, FALSE);
  }

  for (i = 0; i < msa->nseq; i++) {
	uapos = 1;
	/* map aligned to dealigned coords (digitized coords, 1..alen) for this seq
	 * map is needed b/c we want the parsetree in dealigned coords so we can
	 * call Parsetrees2Alignment with it, but mtr is in aligned coords, and
	 * Transmogrify works in aligned coords, so after calling Transmogrify
	 * we have to convert tr->emitl and tr->emitr to dealigned coords using map.
	 */
	for(apos = 1; apos <= msa->alen; apos++)
	  map[apos] = esl_abc_XIsGap(msa->abc, msa->ax[i][apos]) ? -1 : uapos++;
	/* get text seq, we need digitized AND text seqs for Transmogrify */
	esl_abc_Textize(msa->abc, msa->ax[i], msa->alen, aseq);
	esl_strdup(aseq, -1, &uaseq);
	/* dealign seq */
	esl_strdealign(uaseq, uaseq, "-_.~", NULL);
	/* Transmogrify the aligned seq to get a parsetree */
   if(ret_tr != NULL) {
	 if((status = Transmogrify(cm, errbuf, mtr, msa->ax[i], used_el, msa->alen, &(tr[i]))) != eslOK) return status;
	  /*ParsetreeDump(stdout, tr[i], cm, msa->ax[i]);*/
	  /* tr[i] is in alignment coords, convert it to unaligned coords, */
	  for(x = 0; x < tr[i]->n; x++) {
	/*printf("i: %d x: %d emitl %d emitr %d\n", i, x, tr[i]->emitl[x], tr[i]->emitr[x]);*/
	if(tr[i]->emitl[x] != -1) {
	  /*printf("\tmapl: %d\n", map[i][tr[i]->emitl[x]]);*/
	  tr[i]->emitl[x] = map[tr[i]->emitl[x]];
	}
	if(tr[i]->emitr[x] != -1) {
	  /*printf("\tmapr: %d\n", map[i][tr[i]->emitr[x]]);*/
	  tr[i]->emitr[x] = map[tr[i]->emitr[x]];
	}
	  }
	}
	if(ret_sq != NULL) {
	  sq[i] = esl_sq_CreateFrom(msa->sqname[i], uaseq, NULL, NULL, NULL);
	  esl_sq_Digitize(cm->abc, sq[i]);
	}
	free(uaseq); /* this gets reallocated and filled per seq in esl_strdup() call above */
  }
  free(aseq);
  free(map);
  free(used_el);

  /* tr and sq are only allocated if ret_tr and ret_sq were non-null */
  if(ret_tr != NULL) *ret_tr = tr;
  if(ret_sq != NULL) *ret_sq = sq;

  return eslOK;

 ERROR:
  if(map     != NULL) free(map);
  if(used_el != NULL) free(used_el);
  if(uaseq   != NULL) free(uaseq);
  if(aseq    != NULL) free(aseq);
  return status;
}

/* Function: ParsetreeMode()
 * Incept:   EPN, Thu Nov 10 11:31:04 2011
 *
 * Purpose:  Return the alignment mode of a parsetree.
 */
char
ParsetreeMode(Parsetree_t *tr)
{
  return tr->mode[0];
}

/* Function: ParsetreeToCMBounds()
 * Incept:   EPN, Wed Jan  4 05:34:32 2012
 *
 * Purpose:  Determine the CM consensus position (cpos) boundaries
 *           spanned in a parsetree. Return two sets of boundaries:
 *
 *           <cfrom_span>..<cto_span>: first..final cpos spanned by
 *           any state in parsetree (regardless of truncation mode).
 *
 *           <cfrom_emit>..<cto_emit>: first..final cpos spanned by
 *           any state in parsetree in relevant truncation mode
 *           (J or L for MATP&MATL, J or R for MATP&MATR)
 *
 *           <first_emit>..<final_emit>: first..final cpos that
 *           emits a residue (doesn't use a delete state or
 *           silent off-mode state).
 *
 * Args:     cm             - the covariance model
 *           tr             - the parsetree
 *           have_i0        - TRUE if first res of source sequence is emitted in tr
 *           have_j0        - TRUE if final res of source sequence is emitted in tr
 *           errbuf         - for error messages
 *           ret_cfrom_span - RETURN: cfrom_span, explained in Purpose.
 *           ret_cto_span   - RETURN: cto_span,   explained in Purpose.
 *           ret_cfrom_emit - RETURN: cfrom_emit, explained in Purpose.
 *           ret_cto_span   - RETURN: cto_emit,   explained in Purpose.
 *           ret_first_emit - RETURN: first_emit, explained in Purpose.
 *           ret_final_emit - RETURN: final_emit, explained in Purpose.
 *
 *
 * Returns:  eslOK on success.
 *           eslEINVAL if cm->emap is NULL.
 */
int
ParsetreeToCMBounds(CM_t *cm, Parsetree_t *tr, int have_i0, int have_j0, char *errbuf, int *ret_cfrom_span, int *ret_cto_span, int *ret_cfrom_emit, int *ret_cto_emit, int *ret_first_emit, int *ret_final_emit)
{
  int  ti;         /* counter over parsetree nodes */
  int  v, nd;      /* state, node index */
  int  prv_v;      /* previous state */
  int  sdl, sdr;   /* state left delta, state right delta for current state */
  int  insert_sd;  /* number of insert residues emitted for current state */
  char mode;       /* truncation mode */
  int  is_left;    /* does current node/state emit left? */
  int  is_right;   /* does current node/state emit right? */
  int  cfrom_span; /* first position spanned by any state of the full parsetree: we guess at this if we're truncated */
  int  cto_span;   /* first position spanned by any state of the full parsetree: we guess at this if we're truncated */
  int  cfrom_emit; /* first model position spanned by any state in parsetree in relevant mode
		    * (J or L for MATP&MATL, J or R for MATP&MATR) */
  int  cto_emit;   /* final model position spanned by any state in parsetree in relevant mode
		    * (J or L for MATP&MATL, J or R for MATP&MATR) */
  int  first_emit; /* first model consensus position that emits a residue */
  int  final_emit; /* final model consensus position that emits a residue */
  int  lpos, rpos; /* boundaries of a consensus subtree */

  /* if parsetree/alignment is in J mode (not L, R, or T) then
   * cfrom_span == cfrom_emit and cto_span == cto_emit
   *
   * if first/final consensus positions used are not
   * gaps (aligned to delete states) then
   * cfrom_emit == first_emit and cto_emit == final_emit
   */

  if(cm->emap == NULL) ESL_FAIL(eslEINVAL, errbuf, "ParsetreeToCMBounds(), cm->emap is NULL");

  cfrom_span = cfrom_emit = first_emit = cm->clen+1;
  cto_span   = cto_emit   = final_emit = 0;

  for (ti = 0; ti < tr->n; ti++) {
	v    = tr->state[ti];
	mode = tr->mode[ti];
	sdl  = StateLeftDelta(cm->sttype[v]);
	sdr  = StateRightDelta(cm->sttype[v]);
	if(v != cm->M) {
	  nd  = cm->ndidx[v];
	  lpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
	  rpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;

	  if     (cm->sttype[v]  == IL_st)   { is_left = TRUE;  is_right = FALSE; insert_sd = 1; }
	  else if(cm->sttype[v]  == IR_st)   { is_left = FALSE; is_right = TRUE;  insert_sd = 1; }
	  else if(cm->ndtype[nd] == MATP_nd) { is_left = TRUE;  is_right = TRUE;  insert_sd = 0; }
	  else if(cm->ndtype[nd] == MATL_nd) { is_left = TRUE;  is_right = FALSE; insert_sd = 0; }
	  else if(cm->ndtype[nd] == MATR_nd) { is_left = FALSE; is_right = TRUE;  insert_sd = 0; }
	  else                               { is_left = FALSE; is_right = FALSE; insert_sd = 0; }
	}
	else { /* v == cm->M, special case, use previous state and treat as left and right and possibly insert (see below) */
	  prv_v     = tr->state[ti-1];
	  mode      = tr->mode[ti-1];
	  sdl       = 0; /* this prevents EL from affecting first/final_emit */
	  sdr       = 0; /* this prevents EL from affecting first/final_emit */
	  is_left   = TRUE;
	  is_right  = TRUE;
	  nd        = cm->ndidx[prv_v];
	  /* tricky case: if previous node was not a LEFT emitter, the EL will emit at lpos, not after it */
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) {
	insert_sd = 1;
	  }
	  else {
	insert_sd = 0;
	  }
	  /* importantly, lpos and rpos remain as they were for the previous state/nd */
	}

	if(is_left) {
	  if(ModeEmitsLeft(mode)) {
	cfrom_emit = ESL_MIN(cfrom_emit, lpos + insert_sd); /* '+ insert_sd' for cfrom b/c we insert after match/delete */
	cto_emit   = ESL_MAX(cto_emit,   lpos);
	if(sdl > 0 && cm->sttype[v] != IL_st) { /* inserts don't impact first_emit/final_emit */
	  first_emit = ESL_MIN(first_emit, lpos);
	  final_emit = ESL_MAX(final_emit, lpos);
	}
	  }
	}
	if(is_right) {
	  if(ModeEmitsRight(mode)) {
	cfrom_emit = ESL_MIN(cfrom_emit, rpos + insert_sd); /* '+ insert_sd' for cfrom b/c we insert after match/delete */
	cto_emit   = ESL_MAX(cto_emit,   rpos);
	if(sdr > 0 && cm->sttype[v] != IR_st) { /* inserts don't impact first_emit/final_emit */
	  first_emit = ESL_MIN(first_emit, rpos);
	  final_emit = ESL_MAX(final_emit, rpos);
	}
	  }
	}
  }

  /* Final step, define cfrom_span/cto_span. These will be the
   * lpos/rpos of the node the parsetree is rooted at if the hit is
   * not truncated. If it is truncated we define these as guesses at
   * the the first and final positions spanned by the full parsetree,
   * i.e. the parsetree of the full sequence if it were not
   * truncated. (We can't possibly know what these are, so we guess.)
   * We use these guesses to display number of truncated positions 5'
   * and/or 3' in the CM_ALIDISPLAY.
   */
  if(ret_cfrom_span != NULL || ret_cto_span != NULL) {
	nd = cm->ndidx[tr->state[1]];
	cfrom_span = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
	cto_span   = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;
	/* aligned fragment is from g..h (1<=g<=h<=clen) in consensus positions,
	 * nd is currently the lowest node in the model tree that spans g..h.
	 */
	if(tr->pass_idx == PLI_PASS_5P_ONLY_FORCE && have_i0) {
	  /* a 5' truncation only */
	  rpos = cto_span;
	  /* find highest nd in the tree whose subtree ends at exactly cto_span
	   * we'll guess that our full hit would be rooted at that node if it wasn't truncated.
	   */
	  while(rpos == cto_span && nd > 0) {
	nd--;
	rpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;
	  }
	  cfrom_span = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
	}
	if(tr->pass_idx == PLI_PASS_3P_ONLY_FORCE && have_j0) {
	  /* a 3' truncation only */
	  lpos = cfrom_span;
	  /* find highest nd in the tree whose subtree begins at exactly cfrom_span
	   * we'll guess that our full hit would be rooted at that node if it wasn't truncated.
	   */
	  while(lpos == cfrom_span && nd > 0) {
	nd--;
	lpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
	  }
	  cto_span   = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;
	}
	if(tr->pass_idx == PLI_PASS_5P_AND_3P_FORCE && have_i0 && have_j0) {
	  /* 5' and 3' truncation and we have the first and final residue aligned */
	  /* we guess it was a full hit */
	  cfrom_span = 1;
	  cto_span   = cm->clen;
	}
	if(tr->pass_idx == PLI_PASS_5P_AND_3P_ANY) {
	  /* we've allowed truncated hits anywhere, not sure what to do here... */
	  /* we guess it was a full hit */
	  cfrom_span = 1;
	  cto_span   = cm->clen;
	}
	if(tr->pass_idx == PLI_PASS_STD_ANY) {
	  /* sanity check */
	  if(cfrom_emit != cfrom_span) ESL_FAIL(eslFAIL, errbuf, "ParsetreeToCMBounds(), std pipeline pass, cfrom_emit != cfrom_span (bug)");
	  if(cto_emit   != cto_span)   ESL_FAIL(eslFAIL, errbuf, "ParsetreeToCMBounds(), std pipeline pass, cto_emit != cto_span (bug)");
	}
  }

  if(ret_cfrom_span != NULL) *ret_cfrom_span = cfrom_span;
  if(ret_cto_span   != NULL) *ret_cto_span   = cto_span;
  if(ret_cfrom_emit != NULL) *ret_cfrom_emit = cfrom_emit;
  if(ret_cto_emit   != NULL) *ret_cto_emit   = cto_emit;
  if(ret_first_emit != NULL) *ret_first_emit = first_emit;
  if(ret_final_emit != NULL) *ret_final_emit = final_emit;

  return eslOK;
}

/* Function: cm_StochasticParsetree()
 * Incept:   EPN, Thu Nov 15 16:45:32 2007
 *           EPN, Wed Jan 11 10:52:11 2012 [Updated]
 *
 * Purpose: Sample a parsetree from a non-banded float Inside
 *          matrix. The Inside matrix must have been already filled by
 *          cm_InsideAlign().  Renamed from SampleFromInside() [EPN,
 *          Wed Sep 14 06:17:11 2011].
 *
 * Args:     cm       - the model
 *           errbuf   - char buffer for reporting errors
 *           dsq      - digitized sequence
 *           L        - length of dsq
 *           mx       - pre-calculated Inside matrix (floats)
 *           r        - source of randomness
 *           ret_tr   - RETURN: sampled parsetree
 *           ret_sc   - RETURN: score of sampled parsetree
 *
 * Returns:  <eslOK> on success.
 * Throws:   <eslEMEM> if we run out of memory.
 */

int
cm_StochasticParsetree(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, CM_MX *mx, ESL_RANDOMNESS *r, Parsetree_t **ret_tr, float *ret_sc)
{
  int          status;             /* easel status code */
  int          v, y, z, b;         /* state indices */
  int          yoffset;            /* transition offset in a states transition vector */
  int          i, j;               /* sequence position indices */
  int          d;                  /* j - i + 1; the current subseq length */
  int          k;                  /* right subseq fragment length for bifurcs */
  int          bifparent;          /* for connecting bifurcs */
  Parsetree_t *tr;                 /* trace we're building */
  ESL_STACK   *pda       = NULL;   /* the stack */
  int          vec_size;           /* size of pA, validA */
  int          cur_vec_size;       /* number of elements we're currently using in pA, validA */
  float       *pA        = NULL;   /* prob vector of  possible paths to take, used for various state types */
  int         *validA    = NULL;   /* is pA a valid choice? (or was it supposed to be IMPOSSIBLE) */
  int          el_is_possible;     /* TRUE if we can jump to EL from current state (and we're in local mode) FALSE if not */
  float        fsc = 0.;           /* score of the parsetree we're sampling */
  int          choice;             /* index represeting sampled choice */
  int          sd, sdr;            /* state delta, state right delta */

  /* the DP matrix, filled by prior call to cm_InsideAlign() */
  float ***alpha  = mx->dp; /* pointer to the alpha DP matrix */

  /* allocate and initialize probability vectors */
  vec_size  = ESL_MAX(L+1, ESL_MAX(cm->M, MAXCONNECT+1));
  /* multipurpose vectors, we need up to L+1 elements for bifs, M elements for root, MAXCONNECT+1 for other states */
  ESL_ALLOC(pA,       sizeof(float) * vec_size);
  ESL_ALLOC(validA,   sizeof(int)   * vec_size);
  esl_vec_FSet(pA,       vec_size, IMPOSSIBLE);
  esl_vec_ISet(validA,   vec_size, FALSE);

  /* Create a parse tree structure and initialize it by adding the root state, with appropriate mode */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0); /* init: attach the root S */

  /* Stochastically traceback through the TrInside matrix
   * this section of code is adapted from cm_dpsmall.c:insideT().
   */
  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;

  v = 0;
  j = d = L;
  i = 1;
  fsc = 0.;
  while (1) {
	if (cm->sttype[v] == B_st) {
	  y = cm->cfirst[v];
	  z = cm->cnum[v];

	  cur_vec_size = d+1;
	  esl_vec_FSet(pA,     cur_vec_size, IMPOSSIBLE); /* only valid k's will be reset to a non-IMPOSSIBLE score, d+1 and d+2 store special cases in L and R mode, remain invalid for J and T mode */

	  /* Set pA[] as (float-ized) log odds scores for each valid right fragment length, k,
	   * and choose a k.
	   */
	  for(k = 0; k <= d; k++) {
	pA[k] = alpha[y][j-k][d-k] + alpha[z][j][k];
	  }
	  /* sample k */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (B_st) is 0.");
	  k = choice;

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(pda, j))       != eslOK) goto ERROR; /* remember the end j    */
	  if((status = esl_stack_IPush(pda, k))       != eslOK) goto ERROR; /* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR; /* remember the trace index of the parent B state */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
	  /* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	}
	else {
	  if((v > 0) || (! (cm->flags & CMH_LOCAL_BEGIN))) { /* not a ROOT_S or local begins are off */
	/* add in emission score (or 0.0 if we're a non-emitter) */
	fsc += get_femission_score(cm, dsq, v, i, j);
	sd  = StateDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);

	/* set pA[] as (float-ized) log odds scores for each child we can transit to,
	 * plus a local end (if possible), and choose a transition.
	 */
	cur_vec_size = cm->cnum[v];
	el_is_possible = FALSE;
	if((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  el_is_possible = TRUE;
	  cur_vec_size++;
	}
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  pA[yoffset] = cm->tsc[v][yoffset] + alpha[y][j-sdr][d-sd];
	}
	if(el_is_possible) {
	  pA[cur_vec_size-1] = cm->endsc[v] + alpha[cm->M][j][d];
	}
	/* sample yoffset */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (non B_st) is 0.");
	yoffset = choice;
	if(yoffset < cm->cnum[v]) {
	  fsc += cm->tsc[v][yoffset];
	}
	else {
	  yoffset = USED_EL; /* we chose EL */
	  fsc += cm->endsc[v] + (cm->el_selfsc * (d - sd)); /* transition to EL plus score of all EL emissions */
	}
	  }
	  else { /* v == 0 && (cm->flags && CMH_LOCAL_BEGIN) ( local begins are on ) */
	cur_vec_size = cm->M; /* pretend all states are possible to begin into, but they're not as some will remain IMPOSSIBLE */
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(y = 0; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    pA[y] = cm->beginsc[y] + alpha[y][j][d];
	  }
	}
	/* sample b */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid local begins is 0.");
	b = choice;
	fsc += cm->beginsc[b];
	yoffset = USED_LOCAL_BEGIN;
	  }

	  /* adjust i and j appropriately based on state type */
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    ESL_FAIL(eslEINCONCEIVABLE, errbuf, "'Inconceivable!'\n'You keep using that word...'");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL) {
	/* a local alignment end */
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	v = cm->M; /* now we're in EL */
	  }
	  else if (yoffset == USED_LOCAL_BEGIN) {
	/* local begin; can only happen once, from root */
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	v = b;
	  }
	  else {
	y = cm->cfirst[v] + yoffset;
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	v = y;
	  }
	  /* ParsetreeDump(stdout, tr, cm, dsq);*/
	}
  }
  if(pda       != NULL) esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);

#if eslDEBUGLEVEL >= 2
  ParsetreeDump(stdout, tr, cm, dsq);
  float sc;
  ParsetreeScore(cm, cm->emap, errbuf, tr, dsq, FALSE, &sc, NULL, NULL, NULL, NULL);
  printf("parsetree score: %.4f\n", sc);
  printf("fsc:             %.4f\n", fsc);
#endif

  if(ret_tr   != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_sc   != NULL) *ret_sc   = fsc;

  ESL_DPRINTF1(("cm_StochasticParsetree() return sc: %f\n", fsc));
  return eslOK;

 ERROR:
  if(pda     != NULL) esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  if(pA      != NULL) free(pA);
  if(validA  != NULL) free(validA);

  if(tr       != NULL) FreeParsetree(tr);

  if(ret_tr   != NULL) *ret_tr   = NULL;
  if(ret_sc   != NULL) *ret_sc   = 0.;

  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_StochasticParsetreeHB()
 * Incept:   EPN, Fri Sep  7 11:02:15 2007
 *           EPN, Wed Jan 11 16:21:59 2012 [updated]
 *
 * Purpose: Sample a parsetree from a HMM banded float
 *          Inside matrix. The Inside matrix must have been already
 *          filled by cm_InsideAlignHB(). Analogous
 *          to cm_StochasticParsetree(), but uses HMM bands.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - digitized sequence
 *           L           - length of dsq
 *           mx          - pre-calculated Inside matrix
 *           r           - source of randomness
 *           ret_tr      - RETURN: sampled parsetree
 *           ret_sc      - RETURN: score of sampled parsetree
 *
 * Returns:  <eslOK> on success.
 * Throws:   <eslEMEM> if we run out of memory.
 */
int
cm_StochasticParsetreeHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, CM_HB_MX *mx, ESL_RANDOMNESS *r, Parsetree_t **ret_tr, float *ret_sc)
{
  int          status;             /* easel status code */
  int          v, y, z, b;         /* state indices */
  int          yoffset;            /* transition offset in a states transition vector */
  int          i, j;               /* sequence position indices */
  int          d;                  /* j - i + 1; the current subseq length */
  int          k;                  /* right subseq fragment length for bifurcs */
  int          bifparent;          /* for connecting bifurcs */
  Parsetree_t *tr;                 /* trace we're building */
  ESL_STACK   *pda       = NULL;   /* the stack */
  int          vec_size;           /* size of pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  int          cur_vec_size;       /* number of elements we're currently using in pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  float       *pA        = NULL;   /* prob vector of  possible paths to take, used for various state types */
  int         *validA    = NULL;   /* is pA a valid choice? (or was it supposed to be IMPOSSIBLE) */
  int          el_is_possible;     /* TRUE if we can jump to EL from current state (and we're in local mode) FALSE if not */
  float        fsc = 0.;           /* score of the parsetree we're sampling */
  int          choice;             /* index represeting sampled choice */
  int          sd, sdl, sdr;       /* state delta, state left delta, state right delta */

  /* variables used in HMM banded version but no nonbanded version */
  int      jp_v, dp_v;    /* j - jmin[v], d - hdmin[v][jp_v] */
  int      jp_y, dp_y ;   /* j - jmin[y], d - hdmin[y][jp_y] */
  int      jp_z, kp_z;    /* j - jmin[z], d - hdmin[z][jp_z] */
  int      jp_y_sdr;      /* j - jmin[y] - vms_sdr */
  int      dp_y_sd;       /* hdmin[y][jp_y_vms_sdr] - vms_sd */
  int      jp_0;          /* j offset in ROOT_S's (v==0) j band */
  int      Lp_0;          /* L offset in ROOT_S's (v==0) d band */
  int      kmin, kmax;    /* min/max k */

  /* the DP matrix */
  float ***alpha  = mx->dp; /* pointer to the alpha DP matrix */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* allocate and initialize probability vectors */
  vec_size  = ESL_MAX(L+3, ESL_MAX(cm->M, MAXCONNECT+1));
  /* multipurpose vectors, we need up to L+3 elements for bifs, M elements for root, 3*MAXCONNECT+1 for other states */
  ESL_ALLOC(pA,       sizeof(float) * vec_size);
  ESL_ALLOC(validA,   sizeof(int)   * vec_size);
  esl_vec_FSet(pA,       vec_size, IMPOSSIBLE);
  esl_vec_ISet(validA,   vec_size, FALSE);

  /* ensure a full alignment to ROOT_S (v==0) is possible */
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)               ESL_FAIL(eslEINVAL, errbuf, "cm_StochasticParsetreeHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_StochasticParsetreeHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* Create a parse tree structure and initialize it by adding the root state, with appropriate mode */
  tr = CreateParsetree(100);
  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0); /* init: attach the root S */

  /* Stochastically traceback through the TrInside matrix
   * this section of code is adapted from cm_dpsmall.c:insideT().
   */
  pda = esl_stack_ICreate();
  if(pda == NULL) goto ERROR;

  v = 0;
  j = d = L;
  i = 1;
  jp_v = j - jmin[v];
  dp_v = d - hdmin[v][jp_v];
  fsc = 0.;
  while (1) {
	if (cm->sttype[v] == B_st) {
	  y = cm->cfirst[v];
	  z = cm->cnum[v];
	  jp_z = j-jmin[z];
	  k = kp_z + hdmin[z][jp_z];  /* k = offset len of right fragment */

	  /* Determine valid k values. This is complex, and
	   * uncommented. It was taken from
	   * cm_dpalign.c:cm_CYKInsideAlignHB(), the B_st case. The code
	   * there is commented somewhat extensively. I'm pretty sure this
	   * is the most efficient (or at least close to it) way to find
	   * the valid cells in the DP matrix we're looking for.
	   */
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];
	  if(j < jmin[v] || j > jmax[v])               ESL_FAIL(eslFAIL, errbuf, "cm_StochasticParsetreeHB() B_st v: %d j: %d outside band jmin: %d jmax: %d\n", v, j, jmin[v], jmax[v]);
	  if(d < hdmin[v][jp_v] || d > hdmax[v][jp_v]) ESL_FAIL(eslFAIL, errbuf, "cm_StochasticParsetreeHB() B_st v: %d j: %d d: %d outside band dmin: %d dmax: %d\n", v, j, d, hdmin[v][jp_v], hdmax[v][jp_v]);
	  kmin = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
	  kmax = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];

	  cur_vec_size = d+1;
	  esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE); /* only valid k's will be reset to a non-IMPOSSIBLE score */

	  /* Set pA[] as (float-ized) log odds scores for each valid right fragment length, k,
	   * and choose a k.
	   */
	  for(k = kmin; k <= kmax; k++) {
	if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	  kp_z       = k-hdmin[z][jp_z];
	  dp_y       = d-hdmin[y][jp_y-k];
	  pA[k]      = alpha[y][jp_y-k][dp_y-k] + alpha[z][jp_z][kp_z];
	}
	  }
	  /* sample k */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (B_st) is 0.");
	  k = choice;

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(pda, j))       != eslOK) goto ERROR; /* remember the end j    */
	  if((status = esl_stack_IPush(pda, k))       != eslOK) goto ERROR; /* remember the subseq length k */
	  if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR; /* remember the trace index of the parent B state */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	  v = y;
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(pda, &d);
	  esl_stack_IPop(pda, &j);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
	  /* attach the S to the right */
	  InsertTraceNode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y);
	  v = y;
	}
	else {
	  if((v > 0) || (! (cm->flags & CMH_LOCAL_BEGIN))) { /* not a ROOT_S or local begins are off */
	/* add in emission score (or 0.0 if we're a non-emitter) */
	fsc += get_femission_score(cm, dsq, v, i, j);
	sd  = StateDelta(cm->sttype[v]);
	sdl = StateLeftDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);

	/* set pA[] as (float-ized) log odds scores for each child we can transit to,
	 * plus a local end (if possible), and choose a transition */
	cur_vec_size = cm->cnum[v];
	el_is_possible = FALSE;
	if((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	  el_is_possible = TRUE;
	  cur_vec_size++;
	}
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  if((j-sdr) >= jmin[y] && (j-sdr) <= jmax[y]) { /* j-sdr is valid in y */
	    jp_y_sdr = j - jmin[y] - sdr;
	    if((d-sd) >= hdmin[y][jp_y_sdr] && (d-sd) <= hdmax[y][jp_y_sdr]) {
	      dp_y_sd = d - hdmin[y][jp_y_sdr] - sd;
	      pA[yoffset] = cm->tsc[v][yoffset] + alpha[y][jp_y_sdr][dp_y_sd];
	    }
	  }
	}
	if(el_is_possible) {
	  pA[cur_vec_size-1] = cm->endsc[v] + alpha[cm->M][j][d]; /* remember EL deck is non-banded */
	}
	/* sample yoffset */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (non-B_st) is 0.");
	yoffset = choice;
	if(yoffset < cm->cnum[v]) {
	  fsc += cm->tsc[v][yoffset];
	}
	else {
	  yoffset = USED_EL; /* we chose EL */
	  fsc += cm->endsc[v] + (cm->el_selfsc * (d - sd)); /* transition to EL plus score of all EL emissions */
	}
	  }
	  else { /* v == 0 && (cm->flags && CMH_LOCAL_BEGIN) ( local begins are on ) */
	cur_vec_size = cm->M; /* pretend all states are possible to begin into, but they're not as some will remain IMPOSSIBLE */
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(y = 0; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	    if(j >= jmin[y] && j <= jmax[y]) { /* j is valid in y */
	      jp_y = j - jmin[y];
	      if(d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]) {
		dp_y = d - hdmin[y][jp_y];
		pA[y] = cm->beginsc[y] + alpha[y][jp_y][dp_y];
	      }
	    }
	  }
	}
	/* sample b */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid local begins is 0.");
	b = choice;
	fsc += cm->beginsc[b];
	yoffset = USED_LOCAL_BEGIN;
	  }

	  /* adjust i and j appropriately based on state type */
	  switch (cm->sttype[v]) {
	  case D_st:            break;
	  case MP_st: i++; j--; break;
	  case ML_st: i++;      break;
	  case MR_st:      j--; break;
	  case IL_st: i++;      break;
	  case IR_st:      j--; break;
	  case S_st:            break;
	  default:    ESL_FAIL(eslEINCONCEIVABLE, errbuf, "'Inconceivable!'\n'You keep using that word...'");
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL) {
	/* a local alignment end */
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M);
	v = cm->M; /* now we're in EL */
	  }
	  else if (yoffset == USED_LOCAL_BEGIN) {
	/* local begin; can only happen once, from root */
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b);
	v = b;
	  }
	  else {
	y = cm->cfirst[v] + yoffset;
	InsertTraceNode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y);
	v = y;
	  }
	  /* ParsetreeDump(stdout, tr, cm, dsq); */
	}
  }
  if(pda       != NULL) esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);

#if eslDEBUGLEVEL >= 2
  ParsetreeDump(stdout, tr, cm, dsq);
  float sc;
  ParsetreeScore(cm, cm->emap, errbuf, tr, dsq, FALSE, &sc, NULL, NULL, NULL, NULL);
  printf("parsetree score: %f\n", sc);
  printf("fsc:             %.4f\n", fsc);
#endif

  if(ret_tr   != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_sc   != NULL) *ret_sc   = fsc;

  ESL_DPRINTF1(("cm_StochasticParsetreeHB() return sc: %f\n", fsc));
  return eslOK;

 ERROR:
  if(pda       != NULL) esl_stack_Destroy(pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);

  if(tr        != NULL) FreeParsetree(tr);

  if(ret_tr   != NULL) *ret_tr   = NULL;
  if(ret_sc   != NULL) *ret_sc   = 0.;

  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_TrStochasticParsetree()
 * Incept:   EPN, Mon Jan  9 08:58:34 2012
 *
 * Purpose: Sample a parsetree from a non-banded truncated float Inside
 *          matrix. The Inside matrix must have been already filled by
 *          cm_TrInsideAlign(). Based on cm_StochasticParsetree().
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - digitized sequence
 *           L           - length of dsq
 *           preset_mode - pre-determined alignment mode, TRMODE_UNKNOWN to allow any
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - pre-calculated Inside matrix (floats)
 *           r           - source of randomness
 *           ret_tr      - RETURN: sampled parsetree
 *           ret_mode    - RETURN: mode of sampled parsetree
 *           ret_sc      - RETURN: score of sampled parsetree
 *
 * Returns:  <eslOK> on success.
 * Throws:   <eslEMEM> if we run out of memory.
 */
int
cm_TrStochasticParsetree(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, char preset_mode, int pass_idx,
			 CM_TR_MX *mx, ESL_RANDOMNESS *r, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc)
{
  int          status;             /* easel status code */
  int          v, y, z, b;         /* state indices */
  int          yoffset;            /* transition offset in a states transition vector */
  int          p;                  /* counter for pA */
  int          i, j;               /* sequence position indices */
  int          d;                  /* j - i + 1; the current subseq length */
  int          k;                  /* right subseq fragment length for bifurcs */
  int          bifparent;          /* for connecting bifurcs */
  Parsetree_t *tr;                 /* trace we're building */
  ESL_STACK   *i_pda     = NULL;   /* the stack, integers */
  ESL_STACK   *c_pda     = NULL;   /* the stack, characters */
  int          vec_size;           /* size of pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  int          cur_vec_size;       /* number of elements we're currently using in pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  float       *pA        = NULL;   /* prob vector of  possible paths to take, used for various state types */
  int         *validA    = NULL;   /* is pA a valid choice? (or was it supposed to be IMPOSSIBLE) */
  char        *y_modeA   = NULL;   /* y_mode[x] is alignment mode for state y corresponding to pA[x] */
  char        *z_modeA   = NULL;   /* z_mode[x] is alignment mode for state z corresponding to pA[x] */
  int         *kA        = NULL;   /* kA[x] is k index corresponding to pA[x], for bifurcs */
  int         *yoffsetA  = NULL;   /* yoffsetA[x] is yoffset index corresponding to yoffsetA[x] */
  int          Jel_is_possible;    /* TRUE if we can jump to EL from current state in J mode (with local ends on), FALSE if not */
  int          Lel_is_possible;    /* TRUE if we can jump to EL from current state in L mode (with local ends on), FALSE if not */
  int          Rel_is_possible;    /* TRUE if we can jump to EL from current state in R mode (with local ends on), FALSE if not */
  float        fsc = 0.;           /* score of the parsetree we're sampling */
  int          choice;             /* index represeting sampled choice */

  /* other variables used in truncated version, but not standard version (not in cm_CYKInsideAlign()) */
  char     parsetree_mode;            /* truncation mode of sampled parseetree */
  char     v_mode, y_mode, z_mode, b_mode; /* truncation mode for states v, y, z, b */
  int      Jntrans, Rntrans, Lntrans; /* number of transitions for current state, each mode */
  float   *JpA = NULL;                /* prob vector for possible transitions to take, J mode */
  float   *LpA = NULL;                /* prob vector for possible transitions to take, L mode */
  float   *RpA = NULL;                /* prob vector for possible transitions to take, R mode */
  int      vms_sd, vms_sdl, vms_sdr;  /* mode-specific state delta, state left delta, state right delta */
  int      do_J, do_L, do_R, do_T;    /* allow transitions to J, L, R modes from current state? */
  int      filled_L, filled_R, filled_T;       /* will we ever use L, R, and T matrices? (determined from <preset_mode>) */
  int      allow_S_trunc_end;         /* set to true to allow d==0 BEGL_S and BEGR_S truncated ends */
  int      pty_idx;                   /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;                 /* truncation penalty, differs based on pass_idx and if we're local or global */

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* allocate and initialize probability vectors */
  vec_size  = ESL_MAX(L+3, ESL_MAX(cm->M, 3*MAXCONNECT+1));
  /* multipurpose vectors, we need up to L+3 elements for bifs, M elements for root, 3*MAXCONNECT+1 for other states */
  ESL_ALLOC(pA,       sizeof(float) * vec_size);
  ESL_ALLOC(validA,   sizeof(int)   * vec_size);
  ESL_ALLOC(y_modeA,  sizeof(char)  * vec_size);
  ESL_ALLOC(z_modeA,  sizeof(char)  * vec_size);
  ESL_ALLOC(kA,       sizeof(int)   * vec_size);
  ESL_ALLOC(yoffsetA, sizeof(int)   * vec_size);
  esl_vec_FSet(pA,       vec_size, IMPOSSIBLE);
  esl_vec_ISet(validA,   vec_size, FALSE);
  esl_vec_ISet(kA,       vec_size, 0);
  esl_vec_ISet(yoffsetA, vec_size, 0);
  for(p = 0; p < vec_size; p++) y_modeA[p] = TRMODE_UNKNOWN;
  for(p = 0; p < vec_size; p++) z_modeA[p] = TRMODE_UNKNOWN;

  /* per-mode vectors */
  ESL_ALLOC(JpA,     sizeof(float) * (MAXCONNECT+1));
  ESL_ALLOC(LpA,     sizeof(float) * (MAXCONNECT+1));
  ESL_ALLOC(RpA,     sizeof(float) * (MAXCONNECT+1));
  esl_vec_FSet(JpA,      MAXCONNECT+1, 0.);
  esl_vec_FSet(LpA,      MAXCONNECT+1, 0.);
  esl_vec_FSet(RpA,      MAXCONNECT+1, 0.);

  /* Determine which matrices we might use, based on <preset_mode>, if TRMODE_UNKNOWN, filled_L, filled_R, filled_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &filled_L, &filled_R, &filled_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetree(), bogus mode: %d", preset_mode);
  /* Determine truncation penalty index, from <pass_idx> */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrStochasticParsetree(), unexpected pass idx: %d", pass_idx);

  /* Truncated specific step: sample alignment marginal mode if <preset_mode> == TRMODE_UNKNOWN */
  if(preset_mode == TRMODE_UNKNOWN) {
	cur_vec_size = 4;
	pA[0] = Jalpha[0][L][L]; validA[0] = TRUE;
	pA[1] = Lalpha[0][L][L]; validA[1] = TRUE;
	pA[2] = Ralpha[0][L][L]; validA[2] = TRUE;
	pA[3] = Talpha[0][L][L]; validA[3] = TRUE;
	/* sample mode */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetree() no valid alignment modes.");
	if     (choice == 0) parsetree_mode = TRMODE_J;
	else if(choice == 1) parsetree_mode = TRMODE_L;
	else if(choice == 2) parsetree_mode = TRMODE_R;
	else if(choice == 3) parsetree_mode = TRMODE_T;
	/*printf("cm_TrStochasticParsetree() sampled %s (%g %g %g %g)\n", MarginalMode(parsetree_mode), pA[0], pA[1], pA[2], pA[3]);*/
  }
  else { /* preset_mode != TRMODE_UNKNOWN, enforce sampled parsetree mode is preset_mode */
	parsetree_mode = preset_mode;
  }

  /* Create a parse tree structure and initialize it by adding the root state, with appropriate mode */
  tr = CreateParsetree(100);
  tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
  tr->pass_idx = pass_idx;
  InsertTraceNodewithMode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0, parsetree_mode); /* init: attach the root S */

  /* Stochastically traceback through the TrInside matrix
   * this section of code is adapted from cm_dpsmall.c:insideT().
   */
  i_pda = esl_stack_ICreate();
  c_pda = esl_stack_CCreate();
  if(i_pda == NULL) goto ERROR;
  if(c_pda == NULL) goto ERROR;

  v = 0;
  j = d = L;
  i = 1;
  v_mode = parsetree_mode;
  fsc = 0.;
  while (1) {
	/* check for super special case in truncated alignment sampling: */
	if(d == 0 && v_mode == TRMODE_UNKNOWN && (cm->stid[v] == BEGL_S || cm->stid[v] == BEGR_S)) {
	  /* If d==0, v_mode is TRMODE_UNKNOWN, v is BEGL_S or BEGR_S
	   * we've used a special case for a B_st (see that section for
	   * details), we've emitted the full sequence under either the
	   * BEGL_S or the BEGR_S and now we're on the other side (v is
	   * the sister BEGR_S or BEGL_S) that emits nothing (hence d==0),
	   * we do a truncated end and exit.
	   */
	  allow_S_trunc_end = TRUE; /* this sets yoffset to USED_TRUNC_END in the final 'else' of the code block below */
	}
	else {
	  allow_S_trunc_end = FALSE;
	}

	if (cm->sttype[v] == B_st) {
	  y = cm->cfirst[v];
	  z = cm->cnum[v];

	  cur_vec_size = d+3;
	  esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE); /* only valid k's will be reset to a non-IMPOSSIBLE score, d+1 and d+2 store special cases in L and R mode, remain invalid for J and T mode */
	  esl_vec_ISet(kA, cur_vec_size, -1);         /* only valid k's will be reset to a non -1 value */
	  for(p = 0; p < cur_vec_size; p++) y_modeA[p] = TRMODE_UNKNOWN;
	  for(p = 0; p < cur_vec_size; p++) z_modeA[p] = TRMODE_UNKNOWN;

	  /* Set pA[] as (float-ized) log odds scores for each valid right fragment length, k, and choose a k.
	   * We handle each mode separately (note I checked the filled_* values are TRUE, in most cases they must be,
	   * but we check anyway, if there's something wrong we'll catch it when we check if any validA[] values
	   * have been set to TRUE below).
	   */
	  if(v_mode == TRMODE_J) {
	/* v is J, y and z must be J mode also */
	for(k = 0; k <= d; k++) {
	  pA[k] = Jalpha[y][j-k][d-k] + Jalpha[z][j][k];
	  kA[k] = k;
	  y_modeA[k] = TRMODE_J;
	  z_modeA[k] = TRMODE_J;
	}
	/* no additional special cases in J mode */
	  }
	  else if(v_mode == TRMODE_L && filled_L) {
	/* v is L, y will be J or L, z will be L */
	for(k = 0; k <= d; k++) {
	  pA[k] = Jalpha[y][j-k][d-k] + Lalpha[z][j][k];
	  kA[k] = k;
	  y_modeA[k] = TRMODE_J;
	  z_modeA[k] = TRMODE_L;
	}
	/* allow for the two special L cases, if they're valid */
	pA[d+1]      = Jalpha[y][j][d]; /* entire sequence is on left in J mode, k is 0 */
	kA[d+1]      = 0;
	y_modeA[d+1] = TRMODE_J;
	z_modeA[d+1] = TRMODE_UNKNOWN;

	pA[d+2]      = Lalpha[y][j][d]; /* entire sequence is on left in J mode, k is 0 */
	kA[d+2]      = 0;
	y_modeA[d+2] = TRMODE_L;
	z_modeA[d+2] = TRMODE_UNKNOWN;
	  }
	  else if(v_mode == TRMODE_R && filled_R) {
	/* v is R, y will be R, z will be J or R */
	for(k = 0; k <= d; k++) {
	  pA[k] = Ralpha[y][j-k][d-k] + Jalpha[z][j][k];
	  kA[k] = k;
	  y_modeA[k] = TRMODE_R;
	  z_modeA[k] = TRMODE_J;
	}
	/* allow for the two special R cases, if they're valid */
	pA[d+1]      = Jalpha[z][j][d]; /* entire sequence is on right in J mode, k is d */
	kA[d+1]      = d;
	y_modeA[d+1] = TRMODE_UNKNOWN;
	z_modeA[d+1] = TRMODE_J;

	pA[d+2]      = Ralpha[z][j][d]; /* entire sequence is on right in J mode, k is d */
	kA[d+2]      = d;
	y_modeA[d+2] = TRMODE_UNKNOWN;
	z_modeA[d+2] = TRMODE_R;
	  }
	  else if(v_mode == TRMODE_T && filled_R && filled_L) {
	/* v is T, y will be R, z will be L */
	for(k = 1; k < d; k++) {
	  pA[k] = Ralpha[y][j-k][d-k] + Lalpha[z][j][k];
	  kA[k]      = k;
	  y_modeA[k] = TRMODE_R;
	  z_modeA[k] = TRMODE_L;
	}
	  }
	  /* sample k */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (B_st) is 0.");
	  y_mode = y_modeA[choice];
	  z_mode = z_modeA[choice];
	  k      = kA[choice];
	  /* kA[choice] will usually be choice, unless its a special case
	   * and v_mode is L or R mode.
	   */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(i_pda, j))       != eslOK) goto ERROR; /* remember the end j    */
	  if((status = esl_stack_IPush(i_pda, k))       != eslOK) goto ERROR; /* remember the subseq length k */
	  if((status = esl_stack_IPush(i_pda, tr->n-1)) != eslOK) goto ERROR; /* remember the trace index of the parent B state */
	  if((status = esl_stack_CPush(c_pda, z_mode))  != eslOK) goto ERROR; /* remember the mode of the right fragment */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, y_mode);
	  v = y;
	  v_mode = y_mode;
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(i_pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(i_pda, &d);
	  esl_stack_IPop(i_pda, &j);
	  esl_stack_CPop(c_pda, &y_mode);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
	  /* attach the S to the right */
	  InsertTraceNodewithMode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y, y_mode);
	  v = y;
	  v_mode = y_mode;
	}
	else {
	  /* v != B_st && v != E_st && v != EL_st */
	  if (v == 0) { /* ROOT_S, we choose a truncated begin state, irregardless of whether we're in local or global mode */
	/* determine which modes we can transition to, we're an S state, so only same-mode transitions are possible */
	do_J = (v_mode == TRMODE_J) ? TRUE : FALSE;
	do_L = (v_mode == TRMODE_L) ? TRUE : FALSE;
	do_R = (v_mode == TRMODE_R) ? TRUE : FALSE;
	do_T = (v_mode == TRMODE_T) ? TRUE : FALSE;
	/* note: exactly 1 of do_J, do_L, do_R, do_T will be TRUE */

	cur_vec_size = cm->M; /* pretend all states are possible to begin into, but they're not as some will remain IMPOSSIBLE */
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(y = 0; y < cm->M; y++) {
	  trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][y] : cm->trp->g_ptyAA[pty_idx][y];
	  if(NOT_IMPOSSIBLE(trpenalty)) {
	    if(do_J)               pA[y] = trpenalty + Jalpha[y][j][d];
	    if(filled_L && do_L)   pA[y] = trpenalty + Lalpha[y][j][d];
	    if(filled_R && do_R)   pA[y] = trpenalty + Ralpha[y][j][d];
	    if(filled_T && do_T && cm->sttype[y] == B_st) {
	      pA[y] = trpenalty + Talpha[y][j][d];
	    }
	  }
	}
	/* sample b */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid local begins is 0.");
	b = choice;
	b_mode = v_mode; /* can't change mode out of a S_st */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][b] : cm->trp->g_ptyAA[pty_idx][b];
	fsc += trpenalty;
	yoffset = USED_TRUNC_BEGIN;

	/* set the truncation penalty parameter of the parsetree */
	tr->trpenalty = trpenalty;
	  }
	  else { /* standard case: v != 0 && v != E_st && v != EL_st && v != B_st */
	/* add in emission score (or 0.0 if we're a non-emitter) */
	fsc += get_femission_score_trunc(cm, dsq, v, i, j, v_mode); /* this is okay even if allow_S_trunc_end is TRUE (b/c then we're a silent S_st and add 0.0) */
	/* check for special cases:
	 * special case 1: allow_S_trunc_end == TRUE (set above if d==0, v_mode is TRMODE_UNKNOWN, v is BEGL_S or BEGR_S)
	 * special case 2: d==1, v_mode is TRMODE_L, v emits left
	 * special case 3: d==1, v_mode is TRMODE_R, v emits right
	 * In all 3 cases, we use a truncated end and don't transition anywhere.
	 * See comments above where allow_S_trunc_end is set for details on first
	 * case.
	 * Second and third cases allow truncated alignments to end at any point
	 * in the parsetree (as long as full sequence is emitted).
	 */
	if(allow_S_trunc_end) { /* this was set above if d==0, stid = BEGL_S or BEGR_S and v_mode == TRMODE_UNKNOWN */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_UNKNOWN; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else if(d == 1 && v_mode == TRMODE_L && StateLeftDelta(cm->sttype[v]) == 1) { /* special case 1 */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_L; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else if(d == 1 && v_mode == TRMODE_R && StateRightDelta(cm->sttype[v]) == 1) { /* special case 2 */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_R; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else { /* usual case, determine where we transition and go there */
	  /* determine mode-specific state delta values, and which modes we can transition to */
	  if(v_mode == TRMODE_J) {
	    vms_sd  = StateDelta(cm->sttype[v]);
	    vms_sdl = StateLeftDelta(cm->sttype[v]);
	    vms_sdr = StateRightDelta(cm->sttype[v]);
	    do_J    = TRUE;
	    do_L    = FALSE;
	    do_R    = FALSE;
	  }
	  else if(v_mode == TRMODE_L) {
	    vms_sd  = StateLeftDelta(cm->sttype[v]);
	    vms_sdl = StateLeftDelta(cm->sttype[v]);
	    vms_sdr = 0;
	    do_J    = (StateRightDelta(cm->sttype[v]) == 1) ? TRUE : FALSE; /* can transition from L to J mode only if a right emitter */
	    do_L    = TRUE;
	    do_R    = FALSE;
	  }
	  else if(v_mode == TRMODE_R) {
	    vms_sd  = StateRightDelta(cm->sttype[v]);
	    vms_sdl = 0;
	    vms_sdr = StateRightDelta(cm->sttype[v]);
	    do_J    = (StateLeftDelta(cm->sttype[v]) == 1) ? TRUE : FALSE; /* can transition from R to J mode only if a left emitter */
	    do_L    = FALSE;
	    do_R    = TRUE;
	  }

	  /* fill JpA, LpA and RpA with log odds scores for each child we can transit to,
	   * add a local end in any mode (if possible) */
	  Jntrans = (do_J) ? cm->cnum[v] : 0;
	  Lntrans = (do_L) ? cm->cnum[v] : 0;
	  Rntrans = (do_R) ? cm->cnum[v] : 0;
	  Jel_is_possible = FALSE;
	  Lel_is_possible = FALSE;
	  Rel_is_possible = FALSE;
	  if((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	    if(do_J) { Jel_is_possible = TRUE; Jntrans++; }
	    if(do_L) { Lel_is_possible = TRUE; Lntrans++; }
	    if(do_R) { Rel_is_possible = TRUE; Rntrans++; }
	  }
	  /* init JpA, LpA, RpA */
	  esl_vec_FSet(JpA, MAXCONNECT+1, IMPOSSIBLE);
	  esl_vec_FSet(LpA, MAXCONNECT+1, IMPOSSIBLE);
	  esl_vec_FSet(RpA, MAXCONNECT+1, IMPOSSIBLE);
	  /* fill JpA, LpA, RpA separately */
	  for(yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if(do_J)             JpA[yoffset] = cm->tsc[v][yoffset] + Jalpha[y][j-vms_sdr][d-vms_sd];
	    if(filled_L && do_L) LpA[yoffset] = cm->tsc[v][yoffset] + Lalpha[y][j-vms_sdr][d-vms_sd];
	    if(filled_R && do_R) RpA[yoffset] = cm->tsc[v][yoffset] + Ralpha[y][j-vms_sdr][d-vms_sd];
	  }
	  if(Jel_is_possible) JpA[Jntrans-1] = cm->endsc[v] + Jalpha[cm->M][j][d]; /* remember EL deck is non-banded */
	  if(Lel_is_possible) LpA[Lntrans-1] = cm->endsc[v] + Lalpha[cm->M][j][d]; /* remember EL deck is non-banded */
	  if(Rel_is_possible) RpA[Rntrans-1] = cm->endsc[v] + Ralpha[cm->M][j][d]; /* remember EL deck is non-banded */

	  /* create one big vector of all possibilities, and for convenience keep track of mode and mode-specific index (q) of each */
	  cur_vec_size = Jntrans + Lntrans + Rntrans;
	  esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	  p = 0;
	  for(yoffset = 0; yoffset < Jntrans; yoffset++) { pA[p] = JpA[yoffset]; y_modeA[p] = TRMODE_J; yoffsetA[p] = yoffset; p++; }
	  for(yoffset = 0; yoffset < Lntrans; yoffset++) { pA[p] = LpA[yoffset]; y_modeA[p] = TRMODE_L; yoffsetA[p] = yoffset; p++; }
	  for(yoffset = 0; yoffset < Rntrans; yoffset++) { pA[p] = RpA[yoffset]; y_modeA[p] = TRMODE_R; yoffsetA[p] = yoffset; p++; }

	  /* sample yoffset */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of valid transitions (non B_st) is 0.");
	  y_mode  = y_modeA[choice];
	  yoffset = yoffsetA[choice];
	  if((y_mode == TRMODE_J && Jel_is_possible && yoffset == (Jntrans-1)) ||
	     (y_mode == TRMODE_L && Lel_is_possible && yoffset == (Lntrans-1)) ||
	     (y_mode == TRMODE_R && Rel_is_possible && yoffset == (Rntrans-1))) {
	    yoffset = USED_EL; /* we chose EL */
	    fsc += cm->endsc[v] + (cm->el_selfsc * (d - StateDelta(cm->sttype[v]))); /* transition to EL plus score of all EL emissions */
	  }
	  else {
	    fsc += cm->tsc[v][yoffset];
	  }
	}
	  }

	  /* adjust i and j appropriately based on state type and mode */
	  switch (cm->sttype[v]) {
	  case  D_st:
	  case  S_st:
	break;
	  case MP_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  case ML_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	break;
	  case MR_st:
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  case IL_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	break;
	  case IR_st:
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  default: ESL_FAIL(eslEINVAL, errbuf, "bogus state type %d \n", cm->sttype[v]);
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL || yoffset == USED_TRUNC_END) {
	/* a local alignment end  or a truncation end */
	if(yoffset == USED_EL) {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M, y_mode);
	}
	v = cm->M; /* now we're in EL (if USED_TRUNC_END, we act like we are) */
	v_mode = y_mode;
	  }
	  else if (yoffset == USED_TRUNC_BEGIN) {
	/* truncated begin; can only happen once, from root */
	InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b, b_mode);
	v = b;
	v_mode = b_mode;
	  }
	  else {
	y = cm->cfirst[v] + yoffset;
	InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, y_mode);
	v = y;
	v_mode = y_mode;
	  }
	  /* ParsetreeDump(stdout, tr, cm, dsq); */
	}
  }
  if(i_pda     != NULL) esl_stack_Destroy(i_pda);  /* it should be empty; we could check; naaah. */
  if(c_pda     != NULL) esl_stack_Destroy(c_pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);
  if(y_modeA   != NULL) free(y_modeA);
  if(z_modeA   != NULL) free(z_modeA);
  if(kA        != NULL) free(kA);
  if(yoffsetA  != NULL) free(yoffsetA);
  if(JpA       != NULL) free(JpA);
  if(LpA       != NULL) free(LpA);
  if(RpA       != NULL) free(RpA);

#if eslDEBUGLEVEL >= 2
  ParsetreeDump(stdout, tr, cm, dsq);
  float sc;
  ParsetreeScore(cm, cm->emap, errbuf, tr, dsq, FALSE, &sc, NULL, NULL, NULL, NULL);
  printf("parsetree score: %.4f\n", sc);
  printf("fsc:             %.4f\n", fsc);
#endif

  if(ret_tr   != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_mode != NULL) *ret_mode = parsetree_mode;
  if(ret_sc   != NULL) *ret_sc   = fsc;

  ESL_DPRINTF1(("cm_TrStochasticParsetree() return sc: %f\n", fsc));
  return eslOK;

 ERROR:
  if(i_pda     != NULL) esl_stack_Destroy(i_pda);  /* it should be empty; we could check; naaah. */
  if(c_pda     != NULL) esl_stack_Destroy(c_pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);
  if(y_modeA   != NULL) free(y_modeA);
  if(z_modeA   != NULL) free(z_modeA);
  if(kA        != NULL) free(kA);
  if(yoffsetA  != NULL) free(yoffsetA);
  if(JpA       != NULL) free(JpA);
  if(LpA       != NULL) free(LpA);
  if(RpA       != NULL) free(RpA);

  if(tr        != NULL) FreeParsetree(tr);

  if(ret_tr   != NULL) *ret_tr   = NULL;
  if(ret_mode != NULL) *ret_mode = TRMODE_UNKNOWN;
  if(ret_sc   != NULL) *ret_sc   = 0.;

  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_TrStochasticParsetreeHB()
 * Incept:   EPN, Tue Jan 10 05:56:55 2012
 *
 * Purpose: Sample a parsetree from a HMM banded truncated float
 *          Inside matrix. The Inside matrix must have been already
 *          filled by cm_TrInsideAlignHB(). Based on
 *          cm_StochasticParsetreeHB(), analogous to
 *          cm_TrStochasticParsetree() but uses HMM bands.
 *
 * Args:     cm          - the model
 *           errbuf      - char buffer for reporting errors
 *           dsq         - digitized sequence
 *           L           - length of dsq
 *           preset_mode - pre-determined alignment mode, TRMODE_UNKNOWN to allow any
 *           pass_idx    - pipeline pass index, indicates what truncation penalty to use
 *           mx          - pre-calculated Inside matrix (floats)
 *           r           - source of randomness
 *           ret_tr      - RETURN: sampled parsetree
 *           ret_mode    - RETURN: mode of sampled parsetree
 *           ret_sc      - RETURN: score of sampled parsetree
 *
 * Returns:  <eslOK> on success.
 * Throws:   <eslEMEM> if we run out of memory.
 */
int
cm_TrStochasticParsetreeHB(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int L, char preset_mode, int pass_idx,
			   CM_TR_HB_MX *mx, ESL_RANDOMNESS *r, Parsetree_t **ret_tr, char *ret_mode, float *ret_sc)
{
  int          status;             /* easel status code */
  int          v, y, z, b;         /* state indices */
  int          yoffset;            /* transition offset in a states transition vector */
  int          p;                  /* counter for pA */
  int          i, j;               /* sequence position indices */
  int          d;                  /* j - i + 1; the current subseq length */
  int          k;                  /* right subseq fragment length for bifurcs */
  int          bifparent;          /* for connecting bifurcs */
  Parsetree_t *tr;                 /* trace we're building */
  ESL_STACK   *i_pda     = NULL;   /* the stack, integers */
  ESL_STACK   *c_pda     = NULL;   /* the stack, characters */
  int          vec_size;           /* size of pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  int          cur_vec_size;       /* number of elements we're currently using in pA, validA, y_modeA, z_modeA, kA, yoffsetA */
  float       *pA        = NULL;   /* prob vector of  possible paths to take, used for various state types */
  int         *validA    = NULL;   /* is pA a valid choice? (or was it supposed to be IMPOSSIBLE) */
  char        *y_modeA   = NULL;   /* y_mode[x] is alignment mode for state y corresponding to pA[x] */
  char        *z_modeA   = NULL;   /* z_mode[x] is alignment mode for state z corresponding to pA[x] */
  int         *kA        = NULL;   /* kA[x] is k index corresponding to pA[x], for bifurcs */
  int         *yoffsetA  = NULL;   /* yoffsetA[x] is yoffset index corresponding to yoffsetA[x] */
  int          Jel_is_possible;    /* TRUE if we can jump to EL from current state in J mode (with local ends on), FALSE if not */
  int          Lel_is_possible;    /* TRUE if we can jump to EL from current state in L mode (with local ends on), FALSE if not */
  int          Rel_is_possible;    /* TRUE if we can jump to EL from current state in R mode (with local ends on), FALSE if not */
  float        fsc = 0.;           /* score of the parsetree we're sampling */
  int          choice;             /* index represeting sampled choice */

  /* other variables used in truncated version, but not standard version (not in cm_StochasticParsetree() */
  char     parsetree_mode;            /* truncation mode of sampled parseetree */
  char     v_mode, y_mode, z_mode, b_mode; /* truncation mode for states v, y, z, b */
  int      Jntrans, Rntrans, Lntrans; /* number of transitions for current state, each mode */
  float   *JpA = NULL;                /* prob vector for possible transitions to take, J mode */
  float   *LpA = NULL;                /* prob vector for possible transitions to take, L mode */
  float   *RpA = NULL;                /* prob vector for possible transitions to take, R mode */
  int      vms_sd, vms_sdl, vms_sdr;  /* mode-specific state delta, state left delta, state right delta */
  int      do_J, do_L, do_R, do_T;    /* allow transitions to J, L, R modes from current state? */
  int      filled_L, filled_R, filled_T; /* will we ever use L, R, and T matrices? (determined from <preset_mode>) */
  int      allow_S_trunc_end;         /* set to true to allow d==0 BEGL_S and BEGR_S truncated ends, even if outside bands */
  int      pty_idx;                   /* index for truncation penalty, determined by pass_idx */
  float    trpenalty;                 /* truncation penalty, differs based on pass_idx and if we're local or global */

  /* variables used in HMM banded version but no nonbanded version */
  int      jp_v, dp_v;    /* j - jmin[v], d - hdmin[v][jp_v] */
  int      jp_y, dp_y ;   /* j - jmin[y], d - hdmin[y][jp_y] */
  int      jp_z, kp_z;    /* j - jmin[z], d - hdmin[z][jp_z] */
  int      dp_z;          /* d - hdmin[z][jp_z] */
  int      jp_y_vms_sdr;  /* j - jmin[y] - vms_sdr */
  int      dp_y_vms_sd;   /* hdmin[y][jp_y_vms_sdr] - vms_sd */
  int      jp_0;          /* L offset in ROOT_S's (v==0) j band */
  int      Lp_0;          /* L offset in ROOT_S's (v==0) d band */
  int      kmin, kmax;    /* min/max k */
  int      kn, kx;        /* min/max k in T mode */

  /* the DP matrix */
  float ***Jalpha  = mx->Jdp; /* pointer to the Jalpha DP matrix */
  float ***Lalpha  = mx->Ldp; /* pointer to the Lalpha DP matrix */
  float ***Ralpha  = mx->Rdp; /* pointer to the Ralpha DP matrix */
  float ***Talpha  = mx->Tdp; /* pointer to the Talpha DP matrix */

  /* ptrs to cp9b info, for convenience */
  CP9Bands_t *cp9b = cm->cp9b;
  int     *jmin  = cp9b->jmin;
  int     *jmax  = cp9b->jmax;
  int    **hdmin = cp9b->hdmin;
  int    **hdmax = cp9b->hdmax;

  /* allocate and initialize probability vectors */
  vec_size  = ESL_MAX(L+3, ESL_MAX(cm->M, 3*MAXCONNECT+1));
  /* multipurpose vectors, we need up to L+3 elements for bifs, M elements for root, 3*MAXCONNECT+1 for other states */
  ESL_ALLOC(pA,       sizeof(float) * vec_size);
  ESL_ALLOC(validA,   sizeof(int)   * vec_size);
  ESL_ALLOC(y_modeA,  sizeof(char)  * vec_size);
  ESL_ALLOC(z_modeA,  sizeof(char)  * vec_size);
  ESL_ALLOC(kA,       sizeof(int)   * vec_size);
  ESL_ALLOC(yoffsetA, sizeof(int)   * vec_size);
  esl_vec_FSet(pA,       vec_size, IMPOSSIBLE);
  esl_vec_ISet(validA,   vec_size, FALSE);
  esl_vec_ISet(kA,       vec_size, 0);
  esl_vec_ISet(yoffsetA, vec_size, 0);
  for(p = 0; p < vec_size; p++) y_modeA[p] = TRMODE_UNKNOWN;
  for(p = 0; p < vec_size; p++) z_modeA[p] = TRMODE_UNKNOWN;

  /* per-mode vectors */
  ESL_ALLOC(JpA,     sizeof(float) * (MAXCONNECT+1));
  ESL_ALLOC(LpA,     sizeof(float) * (MAXCONNECT+1));
  ESL_ALLOC(RpA,     sizeof(float) * (MAXCONNECT+1));
  esl_vec_FSet(JpA,      MAXCONNECT+1, 0.);
  esl_vec_FSet(LpA,      MAXCONNECT+1, 0.);
  esl_vec_FSet(RpA,      MAXCONNECT+1, 0.);

  /* Determine which matrices we might use, based on <preset_mode>, if TRMODE_UNKNOWN, filled_L, filled_R, filled_T will all be set as TRUE */
  if((status = cm_TrFillFromMode(preset_mode, &filled_L, &filled_R, &filled_T)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetreeHB(), bogus mode: %d", preset_mode);
  /* Determine truncation penalty index, from <pass_idx> */
  if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_TrStochasticParsetreeHB(), unexpected pass idx: %d", pass_idx);

  /* ensure a full alignment to ROOT_S (v==0) is possible */
  if (preset_mode == TRMODE_J && (! cp9b->Jvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB()(): preset_mode is J mode, but cp9b->Jvalid[v] is FALSE");
  if (preset_mode == TRMODE_L && (! cp9b->Lvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB()(): preset_mode is L mode, but cp9b->Lvalid[v] is FALSE");
  if (preset_mode == TRMODE_R && (! cp9b->Rvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB()(): preset_mode is R mode, but cp9b->Rvalid[v] is FALSE");
  if (preset_mode == TRMODE_T && (! cp9b->Tvalid[0])) ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB()(): preset_mode is T mode, but cp9b->Tvalid[v] is FALSE");
  if (preset_mode == TRMODE_UNKNOWN && (! (cp9b->Jvalid[0] || cp9b->Lvalid[0] || cp9b->Rvalid[0] || cp9b->Tvalid[0]))) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB()(): no marginal mode is allowed for state 0");
  }
  if (cp9b->jmin[0] > L || cp9b->jmax[0] < L)               ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB(): L (%d) is outside ROOT_S's j band (%d..%d)\n", L, cp9b->jmin[0], cp9b->jmax[0]);
  jp_0 = L - jmin[0];
  if (cp9b->hdmin[0][jp_0] > L || cp9b->hdmax[0][jp_0] < L) ESL_FAIL(eslEINVAL, errbuf, "cm_TrStochasticParsetreeHB(): L (%d) is outside ROOT_S's d band (%d..%d)\n", L, cp9b->hdmin[0][jp_0], cp9b->hdmax[0][jp_0]);
  Lp_0 = L - hdmin[0][jp_0];

  /* Truncated specific step: sample alignment marginal mode if <preset_mode> == TRMODE_UNKNOWN */
  if(preset_mode == TRMODE_UNKNOWN) {
	cur_vec_size = 4;
	if(cp9b->Jvalid[0]) pA[0] = Jalpha[0][jp_0][Lp_0];
	if(cp9b->Lvalid[0]) pA[1] = Lalpha[0][jp_0][Lp_0];
	if(cp9b->Rvalid[0]) pA[2] = Ralpha[0][jp_0][Lp_0];
	if(cp9b->Tvalid[0]) pA[3] = Talpha[0][jp_0][Lp_0];
	/* sample mode */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetreeHB() no valid alignment modes.");
	if     (choice == 0) parsetree_mode = TRMODE_J;
	else if(choice == 1) parsetree_mode = TRMODE_L;
	else if(choice == 2) parsetree_mode = TRMODE_R;
	else if(choice == 3) parsetree_mode = TRMODE_T;
	/*printf("cm_TrStochasticParsetreeHB() sampled %s (%g %g %g %g)\n", MarginalMode(parsetree_mode), pA[0], pA[1], pA[2], pA[3]);*/
  }
  else { /* preset_mode != TRMODE_UNKNOWN, enforce sampled parsetree mode is preset_mode */
	parsetree_mode = preset_mode;
  }

  /* Create a parse tree structure and initialize it by adding the root state, with appropriate mode */
  tr = CreateParsetree(100);
  tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
  tr->pass_idx = pass_idx;
  InsertTraceNodewithMode(tr, -1, TRACE_LEFT_CHILD, 1, L, 0, parsetree_mode); /* init: attach the root S */

  /* Stochastically traceback through the TrInside matrix
   * this section of code is adapted from cm_dpsmall.c:insideT().
   */
  i_pda = esl_stack_ICreate();
  c_pda = esl_stack_CCreate();
  if(i_pda == NULL) goto ERROR;
  if(c_pda == NULL) goto ERROR;

  v = 0;
  j = d = L;
  i = 1;
  v_mode = parsetree_mode;
  jp_v = j - jmin[v];
  dp_v = d - hdmin[v][jp_v];
  fsc = 0.;
  while (1) {
	/* check for super special case in truncated alignment sampling: */
	if(d == 0 && v_mode == TRMODE_UNKNOWN && (cm->stid[v] == BEGL_S || cm->stid[v] == BEGR_S)) {
	  /* If d==0, v_mode is TRMODE_UNKNOWN, v is BEGL_S or BEGR_S
	   * we've used a special case for a B_st (see that section for
	   * details), we've emitted the full sequence under either the
	   * BEGL_S or the BEGR_S and now we're on the other side (v is
	   * the sister BEGR_S or BEGL_S) that emits nothing (hence d==0),
	   * we do a truncated end and exit. We may be outside our bands
	   * on v and/or j, but we allow that for this special case.
	   */
	  allow_S_trunc_end = TRUE; /* this sets yoffset to USED_TRUNC_END in the final 'else' of the code block below */
	}
	else if(cm->sttype[v] != EL_st) {
	  /* update all-important jp_v and dp_v (j and d band-offset indices) */
	  jp_v = j - jmin[v];
	  dp_v = d - hdmin[v][jp_v];
	  allow_S_trunc_end = FALSE;
	  /* check for errors */
	  if(j > jmax[v])        ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), j: %d > jmax[%d] (%d)\n", j, v, jmax[v]);
	  if(j < jmin[v])        ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), j: %d < jmin[%d] (%d)\n", j, v, jmin[v]);
	  if(d > hdmax[v][jp_v]) ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), d: %d > hdmax[%d] (%d)\n", d, v, hdmax[v][jp_v]);
	  if(d < hdmin[v][jp_v]) ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), d: %d < hdmin[%d] (%d)\n", d, v, hdmin[v][jp_v]);
	  if(v_mode == TRMODE_J && (! cp9b->Jvalid[v]))  ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), mode is TRMODE_J for v: %d but cp9b->Jvalid[v] is FALSE", v);
	  if(v_mode == TRMODE_L && (! cp9b->Lvalid[v]))  ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), mode is TRMODE_L for v: %d but cp9b->Lvalid[v] is FALSE", v);
	  if(v_mode == TRMODE_R && (! cp9b->Rvalid[v]))  ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), mode is TRMODE_R for v: %d but cp9b->Rvalid[v] is FALSE", v);
	  if(v_mode == TRMODE_T && (! cp9b->Tvalid[v]))  ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB(), mode is TRMODE_T for v: %d but cp9b->Tvalid[v] is FALSE", v);
	}

	if (cm->sttype[v] == B_st) {
	  y = cm->cfirst[v];
	  z = cm->cnum[v];
	  jp_z = j-jmin[z];
	  k = kp_z + hdmin[z][jp_z];  /* k = offset len of right fragment */

	  /* Determine valid k values, this is mode-independent. This is
	   * complex, and uncommented. It was taken from
	   * cm_dpalign.c:cm_CYKInsideAlignHB(), the B_st case. The code
	   * there is commented somewhat extensively. I'm pretty sure this
	   * is the most efficient (or at least close to it) way to find
	   * the valid cells in the DP matrix we're looking for.
	   */
	  jp_v = j - jmin[v];
	  jp_y = j - jmin[y];
	  jp_z = j - jmin[z];
	  if(j < jmin[v] || j > jmax[v])               ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB() B_st v: %d j: %d outside band jmin: %d jmax: %d\n", v, j, jmin[v], jmax[v]);
	  if(d < hdmin[v][jp_v] || d > hdmax[v][jp_v]) ESL_FAIL(eslFAIL, errbuf, "cm_TrStochasticParsetreeHB() B_st v: %d j: %d d: %d outside band dmin: %d dmax: %d\n", v, j, d, hdmin[v][jp_v], hdmax[v][jp_v]);
	  kmin = ((j-jmax[y]) > (hdmin[z][jp_z])) ? (j-jmax[y]) : hdmin[z][jp_z];
	  kmax = ( jp_y       < (hdmax[z][jp_z])) ?  jp_y       : hdmax[z][jp_z];

	  cur_vec_size = d+3;
	  esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE); /* only valid k's will be reset to a non-IMPOSSIBLE score, d+1 and d+2 store special cases in L and R mode, remain invalid for J and T mode */
	  esl_vec_ISet(kA, cur_vec_size, -1);         /* only valid k's will be reset to a non -1 value */
	  for(p = 0; p < cur_vec_size; p++) y_modeA[p] = TRMODE_UNKNOWN;
	  for(p = 0; p < cur_vec_size; p++) z_modeA[p] = TRMODE_UNKNOWN;

	  /* set pA[] as (float-ized) log odds scores for each valid right fragment length, k, and choose a k */
	  /* handle each mode separately */
	  if(v_mode == TRMODE_J) {
	/* v is J, y and z must be J mode also */
	if(cp9b->Jvalid[y] && cp9b->Jvalid[z]) {
	  for(k = kmin; k <= kmax; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      kp_z       = k-hdmin[z][jp_z];
	      dp_y       = d-hdmin[y][jp_y-k];
	      pA[k]      = Jalpha[y][jp_y-k][dp_y-k] + Jalpha[z][jp_z][kp_z];
	      kA[k]      = k;
	      y_modeA[k] = TRMODE_J;
	      z_modeA[k] = TRMODE_J;
	    }
	  }
	}
	/* no additional special cases in J mode */
	  }
	  else if(v_mode == TRMODE_L) {
	/* v is L, y will be J or L, z will be L */
	if(filled_L && cp9b->Jvalid[y] && cp9b->Lvalid[z]) {
	  for(k = kmin; k <= kmax; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      kp_z       = k-hdmin[z][jp_z];
	      dp_y       = d-hdmin[y][jp_y-k];
	      pA[k]      = Jalpha[y][jp_y-k][dp_y-k] + Lalpha[z][jp_z][kp_z];
	      kA[k]      = k;
	      y_modeA[k] = TRMODE_J;
	      z_modeA[k] = TRMODE_L;
	    }
	  }
	}
	/* allow for the two special L cases, if they're valid */
	if(j >= jmin[y] && j <= jmax[y]) { /* j is valid in y */
	  jp_y = j-jmin[y];
	  if(d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]) { /* d is valid in j, y */
	    dp_y = d - hdmin[y][jp_y];
	    if(cp9b->Jvalid[y]) {
	      pA[d+1]      = Jalpha[y][jp_y][dp_y]; /* entire sequence is on left in J mode, k is 0 */
	      kA[d+1]      = 0;
	      y_modeA[d+1] = TRMODE_J;
	      z_modeA[d+1] = TRMODE_UNKNOWN;
	    }
	    if(filled_L && cp9b->Lvalid[y]) {
	      pA[d+2]      = Lalpha[y][jp_y][dp_y]; /* entire sequence is on left in L mode, k is 0 */
	      kA[d+2]      = 0;
	      y_modeA[d+2] = TRMODE_L;
	      z_modeA[d+2] = TRMODE_UNKNOWN;
	    }
	  }
	}
	  }
	  else if(v_mode == TRMODE_R) {
	/* v is R, y will be R, z will be J or R */
	if(filled_R && cp9b->Rvalid[y] && cp9b->Jvalid[z]) {
	  for(k = kmin; k <= kmax; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      kp_z       = k-hdmin[z][jp_z];
	      dp_y       = d-hdmin[y][jp_y-k];
	      pA[k]      = Ralpha[y][jp_y-k][dp_y-k] + Jalpha[z][jp_z][kp_z];
	      kA[k]      = k;
	      y_modeA[k] = TRMODE_R;
	      z_modeA[k] = TRMODE_J;
	    }
	  }
	}
	/* allow for the two special R cases, if they're valid */
	if(j >= jmin[z] && j <= jmax[z]) {
	  jp_z = j-jmin[z];
	  if(d >= hdmin[z][jp_z] && d <= hdmax[z][jp_z]) {
	    dp_z = d - hdmin[z][jp_z];
	    if(cp9b->Jvalid[z]) {
	      pA[d+1]      = Jalpha[z][jp_z][dp_z]; /* entire sequence is on right in J mode, k is d */
	      kA[d+1]      = d;
	      y_modeA[d+1] = TRMODE_UNKNOWN;
	      z_modeA[d+1] = TRMODE_J;
	    }
	    if(filled_R && cp9b->Rvalid[z]) {
	      pA[d+2]      = Ralpha[z][jp_z][dp_z]; /* entire sequence is on right in J mode, k is d */
	      kA[d+2]      = d;
	      y_modeA[d+2] = TRMODE_UNKNOWN;
	      z_modeA[d+2] = TRMODE_R;
	    }
	  }
	}
	  }
	  else if(v_mode == TRMODE_T) {
	/* v is T, y will be R, z will be L */
	if(filled_R && filled_L && cp9b->Rvalid[y] && cp9b->Lvalid[z]) {
	  kn = ESL_MAX(kmin, 1);
	  kx = ESL_MIN(kmax, d);
	  for(k = kn; k <= kx; k++) {
	    if((k >= d - hdmax[y][jp_y-k]) && k <= d - hdmin[y][jp_y-k]) {
	      kp_z       = k-hdmin[z][jp_z];
	      dp_y       = d-hdmin[y][jp_y-k];
	      pA[k]      = Ralpha[y][jp_y-k][dp_y-k] + Lalpha[z][jp_z][kp_z];
	      kA[k]      = k;
	      y_modeA[k] = TRMODE_R;
	      z_modeA[k] = TRMODE_L;
	    }
	  }
	}
	  }

	  /* sample k */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetreeHB() number of transitions (B_st) is 0.");
	  y_mode = y_modeA[choice];
	  z_mode = z_modeA[choice];
	  k      = kA[choice];
	  /* kA[choice] will usually be choice, unless its a special case
	   * and v_mode is L or R mode.
	   */

	  /* Store info about the right fragment that we'll retrieve later:
	   */
	  if((status = esl_stack_IPush(i_pda, j))       != eslOK) goto ERROR; /* remember the end j    */
	  if((status = esl_stack_IPush(i_pda, k))       != eslOK) goto ERROR; /* remember the subseq length k */
	  if((status = esl_stack_IPush(i_pda, tr->n-1)) != eslOK) goto ERROR; /* remember the trace index of the parent B state */
	  if((status = esl_stack_CPush(c_pda, z_mode))  != eslOK) goto ERROR; /* remember the mode of the right fragment */

	  /* Deal with attaching left start state.
	   */
	  j = j-k;
	  d = d-k;
	  i = j-d+1;
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, y_mode);
	  v = y;
	  v_mode = y_mode;
	}
	else if (cm->sttype[v] == E_st || cm->sttype[v] == EL_st) {
	  /* We don't trace back from an E or EL. Instead, we're done with the
	   * left branch of the tree, and we try to swing over to the right
	   * branch by popping a right start off the stack and attaching
	   * it. If the stack is empty, then we're done with the
	   * traceback altogether. This is the only way to break the
	   * while (1) loop.
	   */
	  if (esl_stack_IPop(i_pda, &bifparent) == eslEOD) break;
	  esl_stack_IPop(i_pda, &d);
	  esl_stack_IPop(i_pda, &j);
	  esl_stack_CPop(c_pda, &y_mode);
	  v = tr->state[bifparent];	/* recover state index of B */
	  y = cm->cnum[v];		/* find state index of right S */
	  i = j-d+1;
	  /* attach the S to the right */
	  InsertTraceNodewithMode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, y, y_mode);
	  v = y;
	  v_mode = y_mode;
	}
	else {
	  /* v != B_st && v != E_st && v != EL_st */
	  if (v == 0) { /* ROOT_S, we choose a truncated begin state, irregardless of whether we're in local or global mode */
	/* determine which modes we can transition to, we're an S state, so only same-mode transitions are possible */
	do_J = (v_mode == TRMODE_J) ? TRUE : FALSE;
	do_L = (v_mode == TRMODE_L) ? TRUE : FALSE;
	do_R = (v_mode == TRMODE_R) ? TRUE : FALSE;
	do_T = (v_mode == TRMODE_T) ? TRUE : FALSE;
	/* note: exactly 1 of do_J, do_L, do_R, do_T will be TRUE */

	cur_vec_size = cm->M; /* pretend all states are possible to begin into, but they're not as some will remain IMPOSSIBLE */
	esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	for(y = 0; y < cm->M; y++) {
	  if(j >= jmin[y] && j <= jmax[y]) { /* j is valid in y */
	    jp_y = j - jmin[y];
	    if(d >= hdmin[y][jp_y] && d <= hdmax[y][jp_y]) {
	      dp_y = d - hdmin[y][jp_y];
	      trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][y] : cm->trp->g_ptyAA[pty_idx][y];
	      if(NOT_IMPOSSIBLE(trpenalty)) {
		if(            do_J && cp9b->Jvalid[y])   pA[y] = trpenalty + Jalpha[y][jp_y][dp_y];
		if(filled_L && do_L && cp9b->Lvalid[y])   pA[y] = trpenalty + Lalpha[y][jp_y][dp_y];
		if(filled_R && do_R && cp9b->Rvalid[y])   pA[y] = trpenalty + Ralpha[y][jp_y][dp_y];
		if(filled_T && do_T && cp9b->Tvalid[y] && cm->sttype[y] == B_st) {
		  pA[y] = trpenalty + Talpha[y][jp_y][dp_y];
		}
	      }
	    }
	  }
	}
	/* sample b */
	if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_StochasticParsetree() number of local begins is 0.");
	b = choice;
	b_mode = v_mode; /* can't change mode out of a S_st */
	trpenalty = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][b] : cm->trp->g_ptyAA[pty_idx][b];
	fsc += trpenalty;
	yoffset = USED_TRUNC_BEGIN;
	/* set the truncation penalty parameter of the parsetree */
	tr->trpenalty = trpenalty;
	  }
	  else { /* standard case: v != 0 && v != E_st && v != EL_st && v != B_st */
	/* add in emission score (or 0.0 if we're a non-emitter) */
	fsc += get_femission_score_trunc(cm, dsq, v, i, j, v_mode); /* this is okay even if allow_S_trunc_end is TRUE (b/c then we're a silent S_st and add 0.0) */
	/* check for special cases:
	 * special case 1: allow_S_trunc_end == TRUE (set above if d==0, v_mode is TRMODE_UNKNOWN, v is BEGL_S or BEGR_S)
	 * special case 2: d==1, v_mode is TRMODE_L, v emits left
	 * special case 3: d==1, v_mode is TRMODE_R, v emits right
	 * In all 3 cases, we use a truncated end and don't transition anywhere.
	 * See comments above where allow_S_trunc_end is set for details on first
	 * case.
	 * Second and third cases allow truncated alignments to end at any point
	 * in the parsetree (as long as full sequence is emitted).
	 */
	if(allow_S_trunc_end) { /* this was set above if d==0, stid = BEGL_S or BEGR_S and v_mode == TRMODE_UNKNOWN */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_UNKNOWN; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else if(d == 1 && v_mode == TRMODE_L && StateLeftDelta(cm->sttype[v]) == 1) { /* special case 1 */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_L; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else if(d == 1 && v_mode == TRMODE_R && StateRightDelta(cm->sttype[v]) == 1) { /* special case 2 */
	  yoffset = USED_TRUNC_END;
	  y_mode  = TRMODE_R; /* necessary only b/c we check mode below to distinguish USED_TRUNC_END from USED_EL */
	}
	else { /* usual case, determine where we transition and go there */
	  /* determine mode-specific state delta values, and which modes we can transition to */
	  if(v_mode == TRMODE_J) {
	    vms_sd  = StateDelta(cm->sttype[v]);
	    vms_sdl = StateLeftDelta(cm->sttype[v]);
	    vms_sdr = StateRightDelta(cm->sttype[v]);
	    do_J    = TRUE;
	    do_L    = FALSE;
	    do_R    = FALSE;
	  }
	  else if(v_mode == TRMODE_L) {
	    vms_sd  = StateLeftDelta(cm->sttype[v]);
	    vms_sdl = StateLeftDelta(cm->sttype[v]);
	    vms_sdr = 0;
	    do_J    = (StateRightDelta(cm->sttype[v]) == 1) ? TRUE : FALSE; /* can transition from L to J mode only a right emitter */
	    do_L    = TRUE;
	    do_R    = FALSE;
	  }
	  else if(v_mode == TRMODE_R) {
	    vms_sd  = StateRightDelta(cm->sttype[v]);
	    vms_sdl = 0;
	    vms_sdr = StateRightDelta(cm->sttype[v]);
	    do_J    = (StateLeftDelta(cm->sttype[v]) == 1) ? TRUE : FALSE; /* can transition from R to J mode only a leftt emitter */
	    do_L    = FALSE;
	    do_R    = TRUE;
	  }

	  /* fill JpA, LpA and RpA with log odds scores for each child we can transit to,
	   * add a local end in J mode (if possible) */
	  Jntrans = (do_J) ? cm->cnum[v] : 0;
	  Lntrans = (do_L) ? cm->cnum[v] : 0;
	  Rntrans = (do_R) ? cm->cnum[v] : 0;
	  Jel_is_possible = FALSE;
	  Lel_is_possible = FALSE;
	  Rel_is_possible = FALSE;
	  if((cm->flags & CMH_LOCAL_END) && NOT_IMPOSSIBLE(cm->endsc[v])) {
	    if(do_J && cp9b->Jvalid[cm->M]) { Jel_is_possible = TRUE; Jntrans++; }
	    if(do_L && cp9b->Lvalid[cm->M]) { Lel_is_possible = TRUE; Lntrans++; }
	    if(do_R && cp9b->Rvalid[cm->M]) { Rel_is_possible = TRUE; Rntrans++; }
	  }
	  /* init JpA, LpA, RpA */
	  esl_vec_FSet(JpA, MAXCONNECT+1, IMPOSSIBLE);
	  esl_vec_FSet(LpA, MAXCONNECT+1, IMPOSSIBLE);
	  esl_vec_FSet(RpA, MAXCONNECT+1, IMPOSSIBLE);
	  /* fill JpA, LpA, RpA separately */
	  for(yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	    y = cm->cfirst[v] + yoffset;
	    if((j-vms_sdr) >= jmin[y] && (j-vms_sdr) <= jmax[y]) { /* j-vms_sdr is valid in y */
	      jp_y_vms_sdr = j - jmin[y] - vms_sdr;
	      if((d-vms_sd) >= hdmin[y][jp_y_vms_sdr] && (d-vms_sd) <= hdmax[y][jp_y_vms_sdr]) {
		dp_y_vms_sd = d - hdmin[y][jp_y_vms_sdr] - vms_sd;
		if(            do_J && cp9b->Jvalid[y]) JpA[yoffset] = cm->tsc[v][yoffset] + Jalpha[y][jp_y_vms_sdr][dp_y_vms_sd];
		if(filled_L && do_L && cp9b->Lvalid[y]) LpA[yoffset] = cm->tsc[v][yoffset] + Lalpha[y][jp_y_vms_sdr][dp_y_vms_sd];
		if(filled_R && do_R && cp9b->Rvalid[y]) RpA[yoffset] = cm->tsc[v][yoffset] + Ralpha[y][jp_y_vms_sdr][dp_y_vms_sd];
	      }
	    }
	  }
	  if(Jel_is_possible) JpA[Jntrans-1] = cm->endsc[v] + Jalpha[cm->M][j][d]; /* remember EL deck is non-banded */
	  if(Lel_is_possible) LpA[Lntrans-1] = cm->endsc[v] + Lalpha[cm->M][j][d]; /* remember EL deck is non-banded */
	  if(Rel_is_possible) RpA[Rntrans-1] = cm->endsc[v] + Ralpha[cm->M][j][d]; /* remember EL deck is non-banded */

	  /* create one big vector of all possibilities, and for convenience keep track of mode and mode-specific index (q) of each */
	  cur_vec_size = Jntrans + Lntrans + Rntrans;
	  esl_vec_FSet(pA, cur_vec_size, IMPOSSIBLE);
	  p = 0;
	  for(yoffset = 0; yoffset < Jntrans; yoffset++) { pA[p] = JpA[yoffset]; y_modeA[p] = TRMODE_J; yoffsetA[p] = yoffset; p++; }
	  for(yoffset = 0; yoffset < Lntrans; yoffset++) { pA[p] = LpA[yoffset]; y_modeA[p] = TRMODE_L; yoffsetA[p] = yoffset; p++; }
	  for(yoffset = 0; yoffset < Rntrans; yoffset++) { pA[p] = RpA[yoffset]; y_modeA[p] = TRMODE_R; yoffsetA[p] = yoffset; p++; }

	  /* sample yoffset */
	  if((status = sample_helper(r, pA, validA, cur_vec_size, &choice)) != eslOK) ESL_FAIL(status, errbuf, "cm_TrStochasticParsetreeHB() number of transitions (non-B_st) is 0.");
	  y_mode  = y_modeA[choice];
	  yoffset = yoffsetA[choice];
	  if((y_mode == TRMODE_J && Jel_is_possible && yoffset == (Jntrans-1)) ||
	     (y_mode == TRMODE_L && Lel_is_possible && yoffset == (Lntrans-1)) ||
	     (y_mode == TRMODE_R && Rel_is_possible && yoffset == (Rntrans-1))) {
	    yoffset = USED_EL; /* we chose EL */
	    fsc += cm->endsc[v] + (cm->el_selfsc * (d - StateDelta(cm->sttype[v]))); /* transition to EL plus score of all EL emissions */
	  }
	  else {
	    fsc += cm->tsc[v][yoffset];
	  }
	}
	  }

	  /* adjust i and j appropriately based on state type and mode */
	  switch (cm->sttype[v]) {
	  case  D_st:
	  case  S_st:
	break;
	  case MP_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  case ML_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	break;
	  case MR_st:
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  case IL_st:
	if ( v_mode == TRMODE_J )          i++;
	if ( v_mode == TRMODE_L && d > 0 ) i++;
	break;
	  case IR_st:
	if ( v_mode == TRMODE_J )          j--;
	if ( v_mode == TRMODE_R && d > 0 ) j--;
	break;
	  default: ESL_FAIL(eslEINVAL, errbuf, "bogus state type %d \n", cm->sttype[v]);
	  }
	  d = j-i+1;

	  if (yoffset == USED_EL || yoffset == USED_TRUNC_END) {
	/* a local alignment end  or a truncation end */
	if(yoffset == USED_EL) {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M, y_mode);
	}
	v = cm->M; /* now we're in EL (if USED_TRUNC_END, we act like we are) */
	v_mode = y_mode;
	  }
	  else if (yoffset == USED_TRUNC_BEGIN) {
	/* truncated begin; can only happen once, from root */
	InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, b, b_mode);
	v = b;
	v_mode = b_mode;
	  }
	  else {
	y = cm->cfirst[v] + yoffset;
	InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, y, y_mode);
	v = y;
	v_mode = y_mode;
	  }
	  /* ParsetreeDump(stdout, tr, cm, dsq); */
	}
  }
  if(i_pda     != NULL) esl_stack_Destroy(i_pda);  /* it should be empty; we could check; naaah. */
  if(c_pda     != NULL) esl_stack_Destroy(c_pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);
  if(y_modeA   != NULL) free(y_modeA);
  if(z_modeA   != NULL) free(z_modeA);
  if(kA        != NULL) free(kA);
  if(yoffsetA  != NULL) free(yoffsetA);
  if(JpA       != NULL) free(JpA);
  if(LpA       != NULL) free(LpA);
  if(RpA       != NULL) free(RpA);

#if eslDEBUGLEVEL >= 2
  ParsetreeDump(stdout, tr, cm, dsq);
  float sc;
  ParsetreeScore(cm, cm->emap, errbuf, tr, dsq, FALSE, &sc, NULL, NULL, NULL, NULL);
  printf("parsetree score: %f\n", sc);
  printf("fsc:             %.4f\n", fsc);
#endif

  if(ret_tr   != NULL) *ret_tr   = tr; else FreeParsetree(tr);
  if(ret_mode != NULL) *ret_mode = parsetree_mode;
  if(ret_sc   != NULL) *ret_sc   = fsc;

  ESL_DPRINTF1(("cm_TrStochasticParsetreeHB() return sc: %f\n", fsc));
  return eslOK;

 ERROR:
  if(i_pda     != NULL) esl_stack_Destroy(i_pda);  /* it should be empty; we could check; naaah. */
  if(c_pda     != NULL) esl_stack_Destroy(c_pda);  /* it should be empty; we could check; naaah. */
  if(pA        != NULL) free(pA);
  if(validA    != NULL) free(validA);
  if(y_modeA   != NULL) free(y_modeA);
  if(z_modeA   != NULL) free(z_modeA);
  if(kA        != NULL) free(kA);
  if(yoffsetA  != NULL) free(yoffsetA);
  if(JpA       != NULL) free(JpA);
  if(LpA       != NULL) free(LpA);
  if(RpA       != NULL) free(RpA);

  if(tr        != NULL) FreeParsetree(tr);

  if(ret_tr   != NULL) *ret_tr   = NULL;
  if(ret_mode != NULL) *ret_mode = TRMODE_UNKNOWN;
  if(ret_sc   != NULL) *ret_sc   = 0.;

  ESL_FAIL(status, errbuf, "out of memory");
  return status; /* NEVER REACHED */
}

/* Function: cm_parsetree_Doctor()
 * Incept:   EPN, Mon Apr 23 12:48:32 2012
 *           SRE, Thu May 21 08:45:46 2009 [p7_trace_Doctor()]
 *
 * Purpose:  CMs with zero basepairs are parameterized similarly to
 *           Plan 7 HMMs, so we can use the ML p7 HMM with fast HMM
 *           algorithms and approximate the CM as closely as
 *           possible. This means we need to disallow MATL_D->MATL_IL
 *           and MATL_IL->MATL_D transitions, as explained below in
 *           the notes from p7_trace_Doctor() from hmmer.
 *
 *           We should only enter this function if our CM has zero
 *           basepairs, in which case we'll only have three types of
 *           nodes in the CM: MATL nodes, 1 ROOT node and 1 END node.
 *           The only types of D->I transitions we'll have will be
 *           MATL_D->MATL_IL. We can have three types of I->D
 *           transitions, MATL_IL->MATL_D or ROOT_IL->MATL_D or
 *           ROOT_IR->MATL_D. We only remove the first type
 *           (MATL_IL->MATL_D). Normally, later on in the build
 *           process we'll zero out any transitions involving ROOT_IL
 *           and ROOT_IR states in cm_zero_flanking_insert_counts().
 *
 *           HMMER's p7_trace_Doctor() notes:
 *           Plan 7 disallows D->I and I->D "chatter" transitions.
 *           However, these transitions will be implied by many
 *           alignments. trace_doctor() arbitrarily collapses I->D or
 *           D->I into a single M position in the trace.
 *
 *           trace_doctor does not examine any scores when it does
 *           this. In ambiguous situations (D->I->D) the symbol
 *           will be pulled arbitrarily to the left, regardless
 *           of whether that's the best column to put it in or not.
 *
 * Args:     tr      - trace to doctor
 *           opt_ndi - optRETURN: number of DI transitions doctored
 *           opt_nid - optRETURN: number of ID transitions doctored
 *
 * Return:   <eslOK> on success, and the parsetree <tr> is modified.
 *
 * Throws:   <eslEINVAL> if parsetree has any states other than
 *           ROOT_S, ROOT_IL, ROOT_IR, END_E, MATL_ML, MATL_IL, MATL_D;
 *           errbuf filled.
 */
int
cm_parsetree_Doctor(CM_t *cm, char *errbuf, Parsetree_t *tr, int *opt_ndi, int *opt_nid)
{
  int opos;			/* position in old parsetree           */
  int npos;			/* position in new parsetree (<= opos) */
  int first_matl = 0;           /* position in old parsetree of first MATL_* state */
  int x;                        /* position ctr in parsetree */
  int ndi, nid;			/* number of DI, ID transitions doctored */

  /* first, validate the parsetree, should be ROOT_S->[ROOT_IL]_n->[ROOT_IR]_n->[MATL_{M,I,D}]_n->END_E */
  if(cm->stid[tr->state[0]] != ROOT_S) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_parsetree_Doctor() parsetree doesn't begin with a ROOT_S state\n");
  }
  if(cm->stid[tr->state[tr->n-1]] != END_E) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_parsetree_Doctor() parsetree doesn't end with an END_E state\n");
  }
  /* find first not ROOT_IL/ROOT_IR */
  x = 1;
  while(cm->stid[tr->state[x]] == ROOT_IL || cm->stid[tr->state[x]] == ROOT_IR) x++;
  if(cm->stid[tr->state[x]] != MATL_ML && cm->stid[tr->state[x]] != MATL_IL && cm->stid[tr->state[x]] != MATL_D) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_parsetree_Doctor() unexpected first non-ROOT node state in parsetree %s at position %d\n", CMStateid(cm->stid[tr->state[x]]), x);
  }
  first_matl = x;
  /* verify all states after first not ROOT_IL/ROOT_IR are MATL states until END_E */
  for(x = first_matl; x < tr->n-1; x++) {
	if((cm->stid[tr->state[x]] != MATL_ML) &&
	   (cm->stid[tr->state[x]] != MATL_IL) &&
	   (cm->stid[tr->state[x]] != MATL_D)) {
	  ESL_FAIL(eslEINVAL, errbuf, "cm_parsetree_Doctor() unexpected state id %s at position %d\n", CMStateid(cm->stid[tr->state[x]]), x);
	}
  }
  /* also validate that the mode is always TRMODE_J */
  for(x = 0; x < tr->n; x++) {
	if(tr->mode[x] != TRMODE_J) ESL_FAIL(eslEINVAL, errbuf, "cm_parsetree_Doctor() unexpected non TRMODE_J mode");
  }

  /* overwrite the trace from left to right */
  ndi  = nid  = 0;
  opos = npos = 0;
  while (opos < tr->n) {
	/* first set data that is predetermined since we know we're all MATL nodes:
	 * mode:  always TRMODE_J (we already checked)
	 * nxtl:  always points to next position (unless END_E, which we'll fix at end)
	 * nxtr:  always -1
	 * prv:   always npos-1
	 * emitr: always == tr->emitr[opos] (only right emitters we'll have are ROOT_IRs)
	 * at next parsetree node.
	 */
	tr->mode[npos]  = TRMODE_J;
	tr->nxtl[npos]  = npos+1;
	tr->nxtr[npos]  = -1;
	tr->prv[npos]   = npos-1;  /* even correct for npos == 0 */
	tr->emitr[npos] = tr->emitr[opos]; /* this never changes */

	/* fix implied D->I transitions; D transforms to M, I pulled in */
	if (cm->stid[tr->state[opos]] == MATL_D && cm->stid[tr->state[opos+1]] == MATL_IL) {
	  tr->state[npos] = tr->state[opos] - 1; /* MATL_D --> MATL_ML */
	  tr->emitl[npos] = tr->emitl[opos+1];   /* insert char moves back */
	  opos += 2;
	  npos += 1;
	  ndi++;
	} /* fix implied I->D transitions; D transforms to M, I is pushed in */
	else if (cm->stid[tr->state[opos]] == MATL_IL && cm->stid[tr->state[opos+1]] == MATL_D) {
	  tr->state[npos] = tr->state[opos+1] - 1; /* MATL_D --> MATL_ML */
	  tr->emitl[npos] = tr->emitl[opos];       /* insert char moves back */
	  opos += 2;
	  npos += 1;
	  nid++;
	} /* else, we just copy state and emitl */
	else {
	  tr->state[npos] = tr->state[opos];
	  tr->emitl[npos] = tr->emitl[opos];
	  opos++;
	  npos++;
	}
  }
  tr->n = npos;
  /* fix nxtl and emitr for final node */
  tr->emitr[tr->n-1] = -1;
  tr->nxtl[tr->n-1]  = -1;

  /* we don't have to worry about changing anything else
   * (i.e. is_std, nalloc, memblock, pass_idx, trpenalty)
   */

  if (opt_ndi != NULL) *opt_ndi = ndi;
  if (opt_nid != NULL) *opt_nid = nid;
  return eslOK;
}

/* Function: get_femission_score()
 * Incept:   EPN, Thu Nov 15 16:48:56 2007
 *
 * Purpose:  Given a CM, dsq, state index and coordinates return the float emission
 *           score.
 *
 * Args:     cm       - the model
 *           dsq      - digitized sequence
 *           v        - state index
 *           i        - dsq index for first position of subseq for subtree at v
 *           j        - dsq index for last position of subseq for subtree at v
 *
 * Return:   float emission score, 0 if state is non-emitter.
 */
float
get_femission_score(CM_t *cm, ESL_DSQ *dsq, int v, int i, int j)
{
  if     (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) return cm->oesc[v][dsq[i]];
  else if(cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) return cm->oesc[v][dsq[j]];
  else if(cm->sttype[v] == MP_st)                           return cm->oesc[v][dsq[i]*cm->abc->Kp+dsq[j]];
  else return 0.;
}

/* Function: get_femission_score_trunc()
 * Incept:   EPN, Mon Jan  9 09:19:38 2012
 *
 * Purpose:  Given a CM, dsq, state index, alignment mode and
 *           coordinates return the float emission score.
 *
 * Args:     cm       - the model
 *           dsq      - digitized sequence
 *           v        - state index
 *           i        - dsq index for first position of subseq for subtree at v
 *           j        - dsq index for last position of subseq for subtree at v
 *           mode     - marginal mode
 *
 * Return:   float emission score, 0 if state is non-emitter.
 */
float
get_femission_score_trunc(CM_t *cm, ESL_DSQ *dsq, int v, int i, int j, char mode)
{
  switch(cm->sttype[v]) {
  case ML_st:
  case IL_st:
	if(ModeEmitsLeft(mode)) return cm->oesc[v][dsq[i]];
	else                    return 0.;
	break;
  case MR_st:
  case IR_st:
	if(ModeEmitsRight(mode)) return cm->oesc[v][dsq[j]];
	else                     return 0.;
	break;
  case MP_st:
	if     (ModeEmitsLeft(mode) && ModeEmitsRight(mode)) return cm->oesc[v][dsq[i]*cm->abc->Kp+dsq[j]];
	else if(ModeEmitsLeft(mode))                         return cm->lmesc[v][dsq[i]];
	else if(ModeEmitsRight(mode))                        return cm->rmesc[v][dsq[j]];
	break;
  default:
	return 0.;
  }
  return 0.; /* never reached */
}

/* Function: sample_helper()
 * Incept:   EPN, Sat Jan 14 17:17:52 2012
 *
 * Purpose:  Given a non-normalized log_2 probability vector, convert it
 *           to probabilities, normalize it and make a choice. Return
 *           the choice in <*ret_choice>.
 *
 * Args:     r          - source of randomness
 *           pA         - [0..i..n-1] non-normalized, log_2 prob vector
 *           validA     - [0..i..n-1] pre'alloced vector for storing validity of i
 *           n          - size of pA, validA
 *           ret_choice - RETURN: chosen i from pA, 0..n-1, pA[i] is ! IMPOSSIBLE
 *
 * Return:   eslOK on success.
 *           eslEINVAL if all n elements of pA are IMPOSSIBLE
 */
float
sample_helper(ESL_RANDOMNESS *r, float *pA, int *validA, int n, int *ret_choice)
{
  int   i;
  int   seen_valid;
  float maxsc;

  /* determine which elements in pA are valid by checking if they're IMPOSSIBLE */
  esl_vec_ISet(validA, n, FALSE);
  for(i = 0; i < n; i++) { if(NOT_IMPOSSIBLE(pA[i])) validA[i] = TRUE; }
  /* make sure we have at least one valid choice */
  seen_valid = FALSE;
  for(i = 0; i < n; i++) { if(validA[i] == TRUE) { seen_valid = TRUE; break; } }
  if(! seen_valid) return eslEINVAL;

  /* normalize and make the choice
   * note: pA likely has log-odds scores, but we can treat them as log
   * probs,because the log probability of the null model is the same
   * for each, so essentially we've divided each score by the same
   * constant, so the *relative* proportion of the log odds scores is
   * the same as the relative proportion of the log probabilities (seq
   * | model)
   */
  maxsc = esl_vec_FMax     (pA, n);
  esl_vec_FIncrement       (pA, n, (-1. * maxsc));
  esl_vec_FScale           (pA, n, log(2.));
  esl_vec_FLogNorm         (pA, n);
  do { i = esl_rnd_FChoose (r, pA, n); } while(validA[i] == FALSE);

  *ret_choice = i;
  return eslOK;
}

/*** End of inlined file: cm_parsetree.c ***/


/*** Start of inlined file: cm_pipeline.c ***/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


static int  pli_p7_filter          (CM_PIPELINE *pli, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, P7_SCOREDATA *msvdata, const ESL_SQ *sq, int64_t **ret_ws, int64_t **ret_we, float **ret_wb, int *ret_nwin);
static int  pli_p7_env_def         (CM_PIPELINE *pli, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, const ESL_SQ *sq, int64_t *ws, int64_t *we, int nwin, P7_HMM **opt_hmm, P7_PROFILE **opt_gm,
				    P7_PROFILE **opt_Rgm, P7_PROFILE **opt_Lgm, P7_PROFILE **opt_Tgm, int64_t **ret_es, int64_t **ret_ee, float **ret_eb, int *ret_nenv);
static int  pli_cyk_env_filter     (CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, int64_t *p7es, int64_t *p7ee, int np7env, CM_t **opt_cm, int64_t **ret_es, int64_t **ret_ee, int *ret_nenv);
static int  pli_cyk_seq_filter     (CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, CM_t **opt_cm, int64_t **ret_ws, int64_t **ret_we, int *ret_nwin);
static int  pli_final_stage        (CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, int64_t *es, int64_t *ee, int nenv, CM_TOPHITS *hitlist, CM_t **opt_cm);
static int  pli_final_stage_hmmonly(CM_PIPELINE *pli, off_t cm_offset, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, const ESL_SQ *sq, int64_t *ws, int64_t *we, int nwin, CM_TOPHITS *hitlist, CM_t **opt_cm);
static int  pli_dispatch_cm_search (CM_PIPELINE *pli, CM_t *cm, ESL_DSQ *dsq, int64_t start, int64_t stop, CM_TOPHITS *hitlist, float cutoff, float env_cutoff, int qdbidx, float *ret_sc, int64_t *opt_envi, int64_t *opt_envj);
static int  pli_align_hit          (CM_PIPELINE *pli, CM_t *cm, const ESL_SQ *sq, CM_HIT *hit);
static int  pli_scan_mode_read_cm  (CM_PIPELINE *pli, off_t cm_offset, float *p7_evparam, int p7_max_length, CM_t **ret_cm);

static int   pli_pass_statistics        (FILE *ofp, CM_PIPELINE *pli, int pass_idx);
static int   pli_hmmonly_pass_statistics(FILE *ofp, CM_PIPELINE *pli);
static int   pli_sum_statistics         (CM_PIPELINE *pli);
static void  pli_copy_subseq            (const ESL_SQ *src_sq, ESL_SQ *dest_sq, int64_t i, int64_t L);
static char *pli_describe_pass          (int pass_idx);
static char *pli_describe_hits_for_pass (int pass_idx);
static float pli_mxsize_limit_from_W    (int W);

/*****************************************************************
 * 1. The CM_PIPELINE object: allocation, initialization, destruction.
 *****************************************************************/

/* Function:  cm_pipeline_Create()
 * Synopsis:  Create a new accelerated comparison pipeline.
 * Incept:    EPN, Fri Sep 24 16:14:39 2010
 *            SRE, Fri Dec  5 10:11:31 2008 [Janelia] (p7_pipeline_Create())
 *
 * Purpose:   Given an application configuration structure <go>
 *            containing certain standardized options (described
 *            below), some initial guesses at the model size <M_hint>
 *            and sequence length <L_hint> that will be processed,
 *            and a <mode> that can be either <cm_SCAN_MODELS> or
 *            <cm_SEARCH_SEQS> depending on whether we're searching one sequence
 *            against a model database (cmscan mode) or one model
 *            against a sequence database (cmsearch mode); create new
 *            pipeline object.
 *
 *            In search mode, we would generally know the length of
 *            our query profile exactly, and would pass <cm->clen> as <M_hint>;
 *            in scan mode, we generally know the length of our query
 *            sequence exactly, and would pass <sq->n> as <L_hint>.
 *            Targets will come in various sizes as we read them,
 *            and the pipeline will resize any necessary objects as
 *            needed, so the other (unknown) length is only an
 *            initial allocation.
 *
 *            <Z> is passed as the database size, in residues, if
 *            known. If unknown, 0 should be passed as <Z>.
 *
 *            The configuration <go> must include settings for the
 *            following options:
 *
 *            || option      ||            description                     || usually  ||
 *            | -g           |  configure CM for glocal alignment           |   FALSE   |
 *            | -Z           |  database size in Mb                         |    NULL   |
 *            | --acc        |  prefer accessions over names in output      |   FALSE   |
 *            | --noali      |  don't output alignments (smaller output)    |   FALSE   |
 *            | --verbose    |  verbose output mode                         |   FALSE   |
 *            | -E           |  report hits <= this E-value threshold       |    10.0   |
 *            | -T           |  report hits >= this bit score threshold     |    NULL   |
 *            | --incE       |  include hits <= this E-value threshold      |    0.01   |
 *            | --incT       |  include hits >= this bit score threshold    |    NULL   |
 *            | --cut_ga     |  model-specific thresholding using GA        |   FALSE   |
 *            | --cut_nc     |  model-specific thresholding using NC        |   FALSE   |
 *            | --cut_tc     |  model-specific thresholding using TC        |   FALSE   |
 *            | --notrunc    |  turn off truncated hit detection            |   FALSE   |
 *            | --anytrunc   |  allow full + trunc hits anywhere in the seq |   FALSE   |
 *            | --onlytrunc  |  allow only trunc hits anywhere in the seq   |   FALSE   |
 *            | --max        |  turn all heuristic filters off              |   FALSE   |
 *            | --nohmm      |  turn all HMM filters off                    |   FALSE   |
 *            | --mid        |  turn off MSV and Viterbi filters            |   FALSE   |
 *            | --default    |  default dbsize-dependent filtering strategy |    TRUE   |
 *            | --rfam       |  set filters to strict Rfam settings         |   FALSE   |
 *            | --FZ <x>     |  set filter thr as if dbsize were <x> Mb     |    NULL   |
 *            | --Fmid <x>   |  with --mid, set fwd filter thresholds to <x>|    NULL   |
 *            | --nonull3    |  turn off NULL3 correction                   |   FALSE   |
 *            | --mxsize <x> |  set max allowed HMM banded DP mx size to <x>|    128 Mb |
 *            | --cyk        |  set final search stage as CYK, not Inside   |   FALSE   |
 *            | --acyk       |  align hits with CYK, not optimal accuracy   |   FALSE   |
 *            | --wcx <x>    |  set cm->W as <x> * cm->clen                 |   FALSE   |
 *            | --toponly    |  only search top strand                      |   FALSE   |
 *            | --bottomonly |  only search bottom strand                   |   FALSE   |
 * *** all opts below this line are 'developer' options, only visible in cmsearch/cmscan via --devhelp
 *            | --noF1       |  turn off MSV filter stage                   |   FALSE   |
 *            | --noF2       |  turn off Viterbi filter stage               |   FALSE   |
 *            | --noF3       |  turn off HMM local forward stage            |   FALSE   |
 *            | --noF4       |  turn off HMM glocal forward stage           |   FALSE   |
 *            | --noF6       |  turn off CYK filter stage                   |   FALSE   |
 *            | --doF1b      |  turn on  MSV composition bias filter        |   FALSE   |
 *            | --noF2b      |  turn off Viterbi composition bias filter    |   FALSE   |
 *            | --noF3b      |  turn off local forward bias filter          |   FALSE   |
 *            | --noF4b      |  turn off glocal forward bias filter         |   FALSE   |
 *            | --doF5b      |  turn on  per-envelope bias filter           |   TRUE    |
 * *** options for defining filter thresholds, usually NULL bc set in DB-size dependent manner
 *            | --F1         |  Stage 1  (MSV)         P value threshold    |    NULL   |
 *            | --F1b        |  Stage 1b (MSV bias)    P value threshold    |    NULL   |
 *            | --F2         |  Stage 2  (Vit)         P value threshold    |    NULL   |
 *            | --F2b        |  Stage 2b (Vit bias)    P value threshold    |    NULL   |
 *            | --F3         |  Stage 3  (lFwd)        P value threshold    |    NULL   |
 *            | --F3b        |  Stage 3b (lFwd bias)   P value threshold    |    NULL   |
 *            | --F4         |  Stage 4  (gFwd)        P value threshold    |    NULL   |
 *            | --F4b        |  Stage 4b (gFwd bias)   P value threshold    |    NULL   |
 *            | --F5         |  Stage 5  (envdef)      P value threshold    |    NULL   |
 *            | --F5b        |  Stage 5b (envdef bias) P value threshold    |    NULL   |
 *            | --F6         |  Stage 6  (CYK)         P value threshold    |    NULL   |
 *            | --rt1        |  P7_DOMAINDEF rt1 parameter                  |    0.25   |
 *            | --rt2        |  P7_DOMAINDEF rt2 parameter                  |    0.10   |
 *            | --rt3        |  P7_DOMAINDEF rt3 parameter                  |    0.20   |
 *            | --ns         |  number of domain/envelope tracebacks        |     200   |
 *            | --ftau       |  HMM band tail loss prob for CYK filter      |    1e-4   |
 *            | --fsums      |  use sums to get CYK filter HMM bands        |   FALSE   |
 *            | --fqdb       |  use QDBs not HMM bands in CYK filter        |   FALSE   |
 *            | --fbeta      |  beta for QDBs in CYK filter                 |    1e-7   |
 *            | --fnonbanded |  run CYK filter without bands                |   FALSE   |
 *            | --nocykenv   |  do not redefine envelopes using CYK         |   FALSE   |
 *            | --cykenvx    |  P-value multiplier for CYK envelope redefn  |    NULL   |
 *            | --tau        |  HMM band tail loss prob for final round     |    5e-6   |
 *            | --qdb        |  use QDBs not HMM bands in final round       |   FALSE   |
 *            | --sums       |  use sums to get final round HMM bands       |   FALSE   |
 *            | --beta       |  beta for QDBs in final round                |   1e-15   |
 *            | --nonbanded  |  run CYK filter without bands                |   FALSE   |
 *            | --timeF1     |  abort after F1b stage, for timing expts     |   FALSE   |
 *            | --timeF2     |  abort after F2b stage, for timing expts     |   FALSE   |
 *            | --timeF3     |  abort after F3b stage, for timing expts     |   FALSE   |
 *            | --timeF4     |  abort after F4b stage, for timing expts     |   FALSE   |
 *            | --timeF5     |  abort after F5b stage, for timing expts     |   FALSE   |
 *            | --timeF6     |  abort after F6  stage, for timing expts     |   FALSE   |
 *            | --trmF3      |  terminate after F3 stage, output windows    |   FALSE   |
 *            | --nogreedy   |  use optimal CM hit resolution, not greedy   |   FALSE   |
 *            | --cp9noel    |  turn off EL state in CP9 HMM                |   FALSE   |
 *            | --cp9gloc    |  configure CP9 HMM in glocal mode            |   FALSE   |
 *            | --null2      |  turn on null2 biased composition model      |   FALSE   |
 *            | --maxtau     |  max tau during band tightening              |    0.01   |
 *            | --seed       |  RNG seed (0=use arbitrary seed)             |     181   |
 *
 * Returns:   ptr to new <cm_PIPELINE> object on success. Caller frees this
 *            with <cm_pipeline_Destroy()>.
 *
 * Throws:    <NULL> on allocation failure.
 */
CM_PIPELINE *
cm_pipeline_Create(ESL_GETOPTS *go, ESL_ALPHABET *abc, int clen_hint, int L_hint, int64_t Z, enum cm_zsetby_e Z_setby, enum cm_pipemodes_e mode)
{
  CM_PIPELINE *pli  = NULL;
  int          seed = esl_opt_GetInteger(go, "--seed");
  int          status;
  double       Z_Mb; /* database size in Mb */
  int          pass_idx; /* counter over passes */

  ESL_ALLOC(pli, sizeof(CM_PIPELINE));

  /* allocate matrices */
  if ((pli->fwd  = p7_omx_Create(clen_hint, L_hint, L_hint)) == NULL) goto ERROR;
  if ((pli->bck  = p7_omx_Create(clen_hint, L_hint, L_hint)) == NULL) goto ERROR;
  if ((pli->oxf  = p7_omx_Create(clen_hint, 0,      L_hint)) == NULL) goto ERROR;
  if ((pli->oxb  = p7_omx_Create(clen_hint, 0,      L_hint)) == NULL) goto ERROR;
  if ((pli->gfwd = p7_gmx_Create(clen_hint, L_hint))         == NULL) goto ERROR;
  if ((pli->gbck = p7_gmx_Create(clen_hint, L_hint))         == NULL) goto ERROR;
  if ((pli->gxf  = p7_gmx_Create(clen_hint, L_hint))         == NULL) goto ERROR;
  if ((pli->gxb  = p7_gmx_Create(clen_hint, L_hint))         == NULL) goto ERROR;

  /* Initializations */
  pli->mode         = mode;
  pli->abc          = abc;
  pli->errbuf[0]    = '\0';
  pli->maxW         = 0;    /* model-dependent, invalid until cm_pli_NewModel() is called */
  pli->cmW          = 0;    /* model-dependent, invalid until cm_pli_NewModel() is called */
  pli->clen         = 0;    /* model-dependent, invalid until cm_pli_NewModel() is called */
  pli->cur_cm_idx   = -1;   /* model-dependent, invalid until cm_pli_NewModel() is called */
  pli->cur_clan_idx = -1;   /* model-dependent, invalid until cm_pli_NewModel() is called */
  pli->cur_seq_idx  = -1;   /* sequence-dependent, invalid until cm_pli_NewSeq() is called */
  pli->cur_pass_idx = -1;   /* pipeline-pass-dependent, updated in cm_Pipeline() */
  pli->cmfp         = NULL; /* set by caller only if we're a scan pipeline (i.e. set in cmscan) */

  /* Accounting, as we collect results */
  pli->nseqs           = 0;
  pli->nmodels         = 0;
  pli->nnodes          = 0;
  pli->nmodels_hmmonly = 0;
  pli->nnodes_hmmonly  = 0;
  for(pass_idx = 0; pass_idx < NPLI_PASSES; pass_idx++) {
	cm_pli_ZeroAccounting(&(pli->acct[pass_idx]));
  }

  /* Normally, we reinitialize the RNG to the original seed every time we're
   * about to collect a stochastic trace ensemble. This eliminates run-to-run
   * variability. As a special case, if seed==0, we choose an arbitrary one-time
   * seed: time() sets the seed, and we turn off the reinitialization.
   */
  pli->r                  =  esl_randomness_CreateFast(seed);
  pli->do_reseeding       = (seed == 0) ? FALSE : TRUE;
  pli->ddef               = p7_domaindef_Create(pli->r);
  pli->ddef->do_reseeding = pli->do_reseeding;

  /* Miscellaneous parameters */
  if(esl_opt_IsOn(go, "--mxsize")) {
	pli->mxsize_limit = esl_opt_GetReal(go, "--mxsize");
	pli->mxsize_set   = TRUE;
  }
  else {
	pli->mxsize_limit = 0.;
	pli->mxsize_set   = FALSE;
  }
  pli->do_top          = esl_opt_GetBoolean(go, "--bottomonly") ? FALSE : TRUE;
  pli->do_bot          = esl_opt_GetBoolean(go, "--toponly")    ? FALSE : TRUE;
  pli->be_verbose      = esl_opt_GetBoolean(go, "--verbose")    ? TRUE  : FALSE;
  pli->show_accessions = esl_opt_GetBoolean(go, "--acc")        ? TRUE  : FALSE;
  pli->show_alignments = esl_opt_GetBoolean(go, "--noali")      ? FALSE : TRUE;
  pli->maxtau          = esl_opt_GetReal   (go, "--maxtau");
  pli->do_wcx          = esl_opt_IsUsed    (go, "--wcx")        ? TRUE  : FALSE;
  pli->wcx             = esl_opt_IsUsed    (go, "--wcx")        ? esl_opt_GetReal(go, "--wcx") : 0.;
  pli->do_one_cmpass   = esl_opt_GetBoolean(go, "--onepass")    ? TRUE  : FALSE;
  pli->do_time_F1      = esl_opt_GetBoolean(go, "--timeF1")     ? TRUE  : FALSE;
  pli->do_time_F2      = esl_opt_GetBoolean(go, "--timeF2")     ? TRUE  : FALSE;
  pli->do_time_F3      = esl_opt_GetBoolean(go, "--timeF3")     ? TRUE  : FALSE;
  pli->do_time_F4      = esl_opt_GetBoolean(go, "--timeF4")     ? TRUE  : FALSE;
  pli->do_time_F5      = esl_opt_GetBoolean(go, "--timeF5")     ? TRUE  : FALSE;
  pli->do_time_F6      = esl_opt_GetBoolean(go, "--timeF6")     ? TRUE  : FALSE;
  pli->do_trm_F3       = esl_opt_GetBoolean(go, "--trmF3")      ? TRUE  : FALSE;

  /* hard-coded miscellaneous parameters that were command-line
   * settable in past testing, and could be in future testing.
   */
  pli->smult           = 2.0;
  pli->wmult           = 1.0;
  pli->mlmult          = 0.1;
  pli->cmult           = 1.25;
  /* NOTE: pli->cmult is tied to the minimum allowable value for --wcx
   * in cmsearch.c and cmscan.c (they're both 1.25). If you change
   * one, change both.
   */

  /* Configure reporting thresholds */
  pli->by_E            = TRUE;
  pli->E               = esl_opt_GetReal(go, "-E");
  pli->T               = 0.0;
  pli->use_bit_cutoffs = FALSE;
  if (esl_opt_IsOn(go, "-T")) {
	pli->T    = esl_opt_GetReal(go, "-T");
	pli->by_E = FALSE;
  }

  /* Configure inclusion thresholds */
  pli->inc_by_E           = TRUE;
  pli->incE               = esl_opt_GetReal(go, "--incE");
  pli->incT               = 0.0;
  if (esl_opt_IsOn(go, "--incT")) {
	pli->incT     = esl_opt_GetReal(go, "--incT");
	pli->inc_by_E = FALSE;
  }

  /* Configure for one of the model-specific thresholding options */
  if (esl_opt_GetBoolean(go, "--cut_ga")) {
	pli->T        = 0.0;
	pli->by_E     = FALSE;
	pli->incT     = 0.0;
	pli->inc_by_E = FALSE;
	pli->use_bit_cutoffs = CMH_GA;
  }
  if (esl_opt_GetBoolean(go, "--cut_nc")) {
	pli->T        = 0.0;
	pli->by_E     = FALSE;
	pli->incT     = 0.0;
	pli->inc_by_E = FALSE;
	pli->use_bit_cutoffs = CMH_NC;
  }
  if (esl_opt_GetBoolean(go, "--cut_tc")) {
	pli->T        = 0.0;
	pli->by_E     = FALSE;
	pli->incT     = 0.0;
	pli->inc_by_E = FALSE;
	pli->use_bit_cutoffs = CMH_TC;
  }

  /* Configure envelope definition parameters */
  pli->rt1            = esl_opt_GetReal(go, "--rt1");
  pli->rt2            = esl_opt_GetReal(go, "--rt2");
  pli->rt3            = esl_opt_GetReal(go, "--rt3");
  pli->ns             = esl_opt_GetInteger(go, "--ns");
  pli->ddef->rt1      = pli->rt1;
  pli->ddef->rt2      = pli->rt2;
  pli->ddef->rt3      = pli->rt3;
  pli->ddef->nsamples = pli->ns;

  /* configure truncation hit allowance parameters */
  if(esl_opt_GetBoolean(go, "--anytrunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = TRUE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--onlytrunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = TRUE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--onlytrunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = TRUE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--notrunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--5trunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = TRUE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--3trunc")) {
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = TRUE;
  }
  else { /* default */
	pli->do_trunc_ends    = TRUE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }

  /* Set Z, the search space size. This is used for E-value
   * calculations and for setting filter thresholds by default
   * (i.e. if none of --max, --nohmm, --mid, --rfam are used) which is
   * why we do this here, before setting filter thresholds.  The
   * database size was passed in, if -Z <x> enabled, we overwrite the
   * passed in value with <x>.
   */
  if (esl_opt_IsOn(go, "-Z")) {
	  pli->Z_setby = CM_ZSETBY_OPTION;
	  pli->Z       = (int64_t) (esl_opt_GetReal(go, "-Z") * 1000000.);
  }
  else {
	pli->Z       = Z;       /* Z is an input variable to this function */
	pli->Z_setby = Z_setby; /* so is Z_setby */
  }

  /********************************************************************************/
  /* Configure acceleration pipeline by setting filter on/off parameters
   * and filter thresholds. (Note: we set HMM only filter parameters later
   * independently of these.)
   *
   * Two steps:
   * 1. Set filter parameters based on which of the five filtering strategies
   *    we're using.
   * 2. Overwrite any filter parameters set on the command-line.
   *
   * The five exclusive filtering strategies:
   * 1. --max:     turn off all filters
   * 2. --nohmm:   turn off all HMM filters
   * 3. --mid:     turn off MSV/Viterbi HMM filters
   * 4. default:   use all filters with DB-size dependent thresholds
   * 5. --rfam:    use all filters with strict thresholds (as if DB was size of RFAMSEQ)
   *
   * strategy       F1?*  F2/F2b?  F3/F3b?  F4/F4b?    F5?**      F6?
   * --------    -------  -------  -------  -------  -------  -------
   * --max           off      off      off      off      off      off
   * --nohmm         off      off      off      off      off       on
   * --mid           off      off       on       on       on       on
   * default          on       on       on       on       on       on
   * --rfam           on       on       on       on       on       on
   *
   *   * By default, F1b is always off.
   *  ** By default, F5b is always off.
   *
   * First set defaults, then make nec changes if --max, --nohmm, --mid, --rfam
   */
  pli->do_max            = FALSE;
  pli->do_nohmm          = FALSE;
  pli->do_mid            = FALSE;
  pli->do_rfam           = FALSE;
  pli->do_hmmonly_cur    = FALSE;
  pli->do_hmmonly_always = FALSE;
  pli->do_hmmonly_never  = FALSE;
  pli->do_msv            = TRUE;
  pli->do_msvbias        = FALSE;
  pli->do_vit            = TRUE;
  pli->do_vitbias        = TRUE;
  pli->do_fwd            = TRUE;
  pli->do_fwdbias        = TRUE;
  pli->do_gfwd           = TRUE;
  pli->do_gfwdbias       = TRUE;
  pli->do_edef           = TRUE;
  pli->do_edefbias       = FALSE;
  pli->do_fcyk           = TRUE;

  if(esl_opt_GetBoolean(go, "--max")) {
	pli->do_max = TRUE;
	pli->do_msv     = pli->do_vit     = pli->do_fwd     = pli->do_gfwd     = pli->do_edef     = pli->do_fcyk    = FALSE;
	pli->do_msvbias = pli->do_vitbias = pli->do_fwdbias = pli->do_gfwdbias = pli->do_edefbias = pli->do_fcykenv = FALSE;
	pli->F1  = pli->F2  = pli->F3  = pli->F4  = pli->F5  = pli->F6 = 1.0;
	pli->F1b = pli->F2b = pli->F3b = pli->F4b = pli->F5b = pli->F6 = 1.0;
	/* D&C truncated alignment is not robust, so we don't allow it */
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--nohmm")) {
	pli->do_nohmm  = TRUE;
	pli->do_msv     = pli->do_vit     = pli->do_fwd     = pli->do_gfwd     = pli->do_edef     = FALSE;
	pli->do_msvbias = pli->do_vitbias = pli->do_fwdbias = pli->do_gfwdbias = pli->do_edefbias = FALSE;
	pli->F1  = pli->F2  = pli->F3  = pli->F4  = pli->F5  = 1.0;
	pli->F1b = pli->F2b = pli->F3b = pli->F4b = pli->F5b = 1.0;
	pli->F6  = 0.0001; /* default F6, we'll change this below if --F6 was used */
	/* D&C truncated alignment is not robust, so we don't allow it */
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else if(esl_opt_GetBoolean(go, "--mid")) {
	pli->do_mid  = TRUE;
	pli->do_msv     = pli->do_vit     = FALSE;
	pli->do_msvbias = pli->do_vitbias = FALSE;
	pli->F1  = pli->F2  = 1.0;
	pli->F1b = pli->F2b = 1.0;
	pli->F3  = pli->F3b = pli->F4 = pli->F4b = pli->F5 = pli->F5b = esl_opt_GetReal(go, "--Fmid");
	pli->F6  = 0.0001; /* default F6, we'll change this below if --F6 was used */
  }
  else if(esl_opt_GetBoolean(go, "--rfam")) {
	pli->do_rfam = TRUE;
	pli->F1 = 0.06;
	pli->F2 = pli->F2b = 0.02;
	pli->F3 = pli->F3b = 0.0002;
	pli->F4 = pli->F4b = 0.0002;
	pli->F5 = pli->F5b = 0.0002;
	pli->F6 = 0.0001;
	/* these are the same as the defaults for a 20 Gb database or larger */
  }
  else {
	/* None of --max, --nohmm, --mid, --rfam, --hmmonly enabled, use
	 * default strategy, set filter thresholds dependent on Z, which
	 * was set above. These default thresholds are hard-coded and were
	 * determined by a systematic search over possible filter
	 * threshold combinations.  xref:
	 * ~nawrockie/notebook/11_0513_inf_dcmsearch_thresholds/00LOG
	 */
	Z_Mb = esl_opt_IsOn(go, "--FZ") ? esl_opt_GetReal(go, "--FZ") : pli->Z / 1000000.;
	/* None of --max, --nohmm, --mid, --rfam enabled, use default
	 * strategy, set filter thresholds dependent on Z, which was set
	 * above. These default thresholds are hard-coded and were determined
	 * by a systematic search over possible filter threshold combinations.
	 * xref: ~nawrockie/notebook/12_0319_inf_finalize_filter_thresholds/00LOG
	 */
	Z_Mb = esl_opt_IsUsed(go, "--FZ") ? esl_opt_GetReal(go, "--FZ") : pli->Z / 1000000.;

	/* turn off MSV bias filter and env def bias filter */
	pli->do_msvbias = pli->do_edefbias = FALSE;
	pli->F1b = pli->F5b = 1.0; /* these are irrelevant */

	/* set all other thresholds to db size defaults */
	if(Z_Mb >= (20000. - eslSMALLX1)) { /* Z >= 20 Gb */
	  pli->F1 = 0.06;
	  pli->F2 = pli->F2b = 0.02;
	  pli->F3 = pli->F3b = 0.0002;
	  pli->F4 = pli->F4b = 0.0002;
	  pli->F5 = pli->F5b = 0.0002;
	  pli->F6 = 0.0001;
	}
	else if(Z_Mb >= (2000. - eslSMALLX1)) { /* 20 Gb > Z >= 2 Gb */
	  pli->F1 = 0.15;
	  pli->F2 = pli->F2b = 0.15;
	  pli->F3 = pli->F3b = 0.0002;
	  pli->F4 = pli->F4b = 0.0002;
	  pli->F5 = pli->F5b = 0.0002;
	  pli->F6 = 0.0001;
	}
	else if(Z_Mb >= (200. - eslSMALLX1)) { /* 2 Gb > Z >= 200 Mb */
	  pli->F1 = 0.15;
	  pli->F2 = pli->F2b = 0.15;
	  pli->F3 = pli->F3b = 0.0008;
	  pli->F4 = pli->F4b = 0.0008;
	  pli->F5 = pli->F5b = 0.0008;
	  pli->F6 = 0.0001;
	}
	else if(Z_Mb >= (20. - eslSMALLX1)) { /* 200 Mb  > Z >= 20 Mb */
	  pli->F1 = pli->F1b = 0.35;
	  pli->F2 = pli->F2b = 0.15;
	  pli->F3 = pli->F3b = 0.003;
	  pli->F4 = pli->F4b = 0.003;
	  pli->F5 = pli->F5b = 0.003;
	  pli->F6 = 0.0001;
	}
	else if(Z_Mb >= (2. - eslSMALLX1)) { /* 20 Mb  > Z >= 2 Mb */
	  pli->F1 = 0.35;
	  pli->do_vit = pli->do_vitbias = FALSE;
	  pli->F2 = pli->F2b = 1.00; /* these are irrelevant */
	  pli->F3 = pli->F3b = 0.005;
	  pli->F4 = pli->F4b = 0.005;
	  pli->F5 = pli->F5b = 0.005;
	  pli->F6 = 0.0001;
	}
	else { /* 2 Mb  > Z */
	  pli->F1 = 0.35;
	  pli->do_vit = pli->do_vitbias = FALSE;
	  pli->F2 = pli->F2b = 1.00; /* these are irrelevant */
	  pli->F3 = pli->F3b = 0.02;
	  pli->F4 = pli->F4b = 0.02;
	  pli->F5 = pli->F5b = 0.02;
	  pli->F6 = 0.0001;
	}
  } /* end of 'else' entered if none of --max, --nohmm, --mid, --rfam used */

  /* Filter on/off parameters and thresholds are now completely set
   * based on filtering strategy. Final step is to overwrite any that
   * the user set on the command-line. (Only expert users should be
   * doing this.)
   *
   * We have to be careful here to not turn on filters that our
   * strategy disallows. The definition of ESL_GETOPTS <go> should
   * enforce that incompatible options cause a failure (and thus will
   * never exist in <go>), but we do a second check here for some
   * combinations.
   */
  if((! pli->do_max) && (! pli->do_nohmm) && (! pli->do_mid)) {
	if(esl_opt_IsOn(go, "--F1"))  { pli->do_msv      = TRUE; pli->F1  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F1"));  }
	if(esl_opt_IsOn(go, "--F1b")) { pli->do_msvbias  = TRUE; pli->F1b = ESL_MIN(1.0, esl_opt_GetReal(go, "--F1b")); }
	if(esl_opt_IsOn(go, "--F2"))  { pli->do_vit      = TRUE; pli->F2  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F2"));  }
	if(esl_opt_IsOn(go, "--F2b")) { pli->do_vitbias  = TRUE; pli->F2b = ESL_MIN(1.0, esl_opt_GetReal(go, "--F2b")); }
  }
  if((! pli->do_max) && (! pli->do_nohmm)) {
	if(esl_opt_IsOn(go, "--F3"))  { pli->do_fwd        = TRUE; pli->F3  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F3"));  }
	if(esl_opt_IsOn(go, "--F3b")) { pli->do_fwdbias    = TRUE; pli->F3b = ESL_MIN(1.0, esl_opt_GetReal(go, "--F3b")); }
	if(esl_opt_IsOn(go, "--F4"))  { pli->do_gfwd       = TRUE; pli->F4  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F4"));  }
	if(esl_opt_IsOn(go, "--F4b")) { pli->do_gfwdbias   = TRUE; pli->F4b = ESL_MIN(1.0, esl_opt_GetReal(go, "--F4b")); }
	if(esl_opt_IsOn(go, "--F5"))  { pli->do_edef       = TRUE; pli->F5  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F5"));  }
	if(esl_opt_IsOn(go, "--F5b")) { pli->do_edefbias   = TRUE; pli->F5b = ESL_MIN(1.0, esl_opt_GetReal(go, "--F5b")); }
  }
  if(! pli->do_max) {
	if(esl_opt_IsOn(go, "--F6"))  { pli->do_fcyk     = TRUE; pli->F6  = ESL_MIN(1.0, esl_opt_GetReal(go, "--F6"));  }
  }

  if(esl_opt_GetBoolean(go, "--noF1"))     pli->do_msv  = FALSE;
  if(esl_opt_GetBoolean(go, "--noF2"))     pli->do_vit  = FALSE;
  if(esl_opt_GetBoolean(go, "--noF3"))     pli->do_fwd  = FALSE;
  if(esl_opt_GetBoolean(go, "--noF4"))     pli->do_gfwd = FALSE;
  if(esl_opt_GetBoolean(go, "--noF6"))     pli->do_fcyk = FALSE;

  if((! pli->do_max) && (! pli->do_nohmm) && (! pli->do_mid)) {
	if(esl_opt_GetBoolean(go, "--doF1b"))    pli->do_msvbias    = TRUE;
  }
  if(esl_opt_GetBoolean(go, "--noF2b"))    pli->do_vitbias  = FALSE;
  if(esl_opt_GetBoolean(go, "--noF3b"))    pli->do_fwdbias  = FALSE;
  if(esl_opt_GetBoolean(go, "--noF4b"))    pli->do_gfwdbias = FALSE;
  if(esl_opt_GetBoolean(go, "--doF5b"))    pli->do_edefbias = TRUE;

  /* set HMM only thresholds and filter stage on/off parameters, these
   * will only be relevant in HMM only mode (for all models if
   * pli->do_hmmonly_always, or all models with 0 basepairs if
   * (!pli->no_hmmonly)).
   *
   * First set defaults, then change them if nec.
   */
  pli->do_hmmonly_always = (esl_opt_GetBoolean(go, "--hmmonly"))   ? TRUE : FALSE;
  pli->do_hmmonly_never  = (esl_opt_GetBoolean(go, "--nohmmonly") ||
			    esl_opt_GetBoolean(go, "--max")       ||
			    esl_opt_GetBoolean(go, "--nohmm")) ? TRUE : FALSE;
  /* pli->do_hmmonly_cur is set in cm_pli_NewModel(), stays FALSE until then */
  pli->do_max_hmmonly    = FALSE;
  pli->do_bias_hmmonly   = TRUE;
  pli->do_null2_hmmonly  = TRUE;
  pli->F1_hmmonly = ESL_MIN(1.0, esl_opt_GetReal(go, "--hmmF1"));
  pli->F2_hmmonly = ESL_MIN(1.0, esl_opt_GetReal(go, "--hmmF2"));
  pli->F3_hmmonly = ESL_MIN(1.0, esl_opt_GetReal(go, "--hmmF3"));
  if(esl_opt_GetBoolean(go, "--hmmmax")) {
	pli->do_max_hmmonly  = TRUE;
	pli->do_bias_hmmonly = FALSE;
	pli->F1_hmmonly = 0.3;
	pli->F2_hmmonly = 1.0;
	pli->F3_hmmonly = 1.0;
  }
  if(esl_opt_GetBoolean(go, "--hmmnonull2")) pli->do_null2_hmmonly = FALSE;
  if(esl_opt_GetBoolean(go, "--hmmnobias"))  pli->do_bias_hmmonly  = FALSE;

  /* Finished setting filter stage on/off parameters and thresholds */
  /********************************************************************************/

  /********************************************************************************/
  /* Configure options for the CM stages */
  pli->do_null2   = esl_opt_GetBoolean(go, "--null2")   ? TRUE  : FALSE;
  pli->do_null3   = esl_opt_GetBoolean(go, "--nonull3") ? FALSE : TRUE;

  pli->fcyk_cm_search_opts  = 0;
  pli->final_cm_search_opts = 0;
  pli->fcyk_beta  = esl_opt_GetReal(go, "--fbeta");
  pli->fcyk_tau   = esl_opt_GetReal(go, "--ftau");
  pli->do_fcykenv = esl_opt_GetBoolean(go, "--nocykenv") ? FALSE : TRUE;
  /* important to set F6env after F6 is set to final value */
  pli->F6env       = ESL_MIN(1.0, pli->F6 * (float) esl_opt_GetInteger(go, "--cykenvx"));

  pli->final_beta = esl_opt_GetReal(go, "--beta");
  pli->final_tau  = esl_opt_GetReal(go, "--tau");

  /* There are 3 options for banding in CYK filter and final round.
   * Choice of the 3 varies depending on if pli->do_max, pli->do_nohmm
   * or neither.
   *
   * if(do_max) {
   *   filter CYK is off.
   *   final round: --qdb: use QDBs, else non-banded
   * }
   * else if(do_nohmm) {
   *   filter CYK : --fnonbanded: no bands, else use QDBs
   *   final round: --nonbanded:  no bands, else use QDBs
   * }
   * else {  normal case
   *   filter CYK : --fnonbanded: no bands, --fqdb: use QDBs, else use HMM bands
   *   final round: --nonbanded:  no bands, --qdb:  use QDBs, else use HMM bands
   * }
   *
   * In all cases, if QDBs used for filter CYK beta is from --fbeta
   * <x>, final beta is from --beta <x>.
   *
   * In all cases, if HMM bands used for filter CYK tau is from --ftau
   * <x>, final tau is from --tau <x>.
   */

  /* CYK filter settings, only set these if do_fcyk
   */
  if(pli->do_fcyk) {
	if(pli->do_nohmm) {
	  /* special case: default behavior for fcyk is to do QDB, HMM banded is not allowed.
	   */
	  if(esl_opt_GetBoolean(go, "--fnonbanded"))       pli->fcyk_cm_search_opts  |= CM_SEARCH_NONBANDED;
	  else                                             pli->fcyk_cm_search_opts  |= CM_SEARCH_QDB;
	}
	else {
	  if     (esl_opt_GetBoolean(go, "--fnonbanded"))  pli->fcyk_cm_search_opts  |= CM_SEARCH_NONBANDED;
	  else if(esl_opt_GetBoolean(go, "--fqdb"))        pli->fcyk_cm_search_opts  |= CM_SEARCH_QDB;
	  else                                             pli->fcyk_cm_search_opts  |= CM_SEARCH_HBANDED;
	}
	if(  esl_opt_GetBoolean(go, "--fsums"))            pli->fcyk_cm_search_opts  |= CM_SEARCH_SUMS;
	if(! esl_opt_GetBoolean(go, "--nonull3"))          pli->fcyk_cm_search_opts  |= CM_SEARCH_NULL3;
  }

  /* set up final round parameters, always set these (we always do the final CM round) */
  if(! esl_opt_GetBoolean(go, "--cyk"))                pli->final_cm_search_opts |= CM_SEARCH_INSIDE;
  if     (pli->do_max)   { /* special case, default behavior in final round is to do non-banded, HMM banded is not allowed */
	if(esl_opt_GetBoolean(go, "--qdb"))                pli->final_cm_search_opts |= CM_SEARCH_QDB;
	else                                               pli->final_cm_search_opts |= CM_SEARCH_NONBANDED;
  }
  else if(pli->do_nohmm) { /* special case, default behavior in final round is to do QDB, HMM banded is not allowed */
	if(esl_opt_GetBoolean(go, "--nonbanded"))          pli->final_cm_search_opts |= CM_SEARCH_NONBANDED;
	else                                               pli->final_cm_search_opts |= CM_SEARCH_QDB;
  }
  else { /* normal case, default is HMM banded */
	if     (esl_opt_GetBoolean(go, "--nonbanded"))     pli->final_cm_search_opts |= CM_SEARCH_NONBANDED;
	else if(esl_opt_GetBoolean(go, "--qdb"))           pli->final_cm_search_opts |= CM_SEARCH_QDB;
	else                                               pli->final_cm_search_opts |= CM_SEARCH_HBANDED;
  }
  if(esl_opt_GetBoolean(go, "--sums"))                 pli->final_cm_search_opts |= CM_SEARCH_SUMS;
  if(esl_opt_GetBoolean(go, "--nogreedy"))             pli->final_cm_search_opts |= CM_SEARCH_CMNOTGREEDY;

  /* Determine cm->config_opts and cm->align_opts we'll use to
   * configure CMs after reading within a SCAN pipeline. Search
   * options will change for the CYK filter and final stage, so
   * these are stored in fcyk_cm_search_opts and final_cm_search_opts
   * determined above.
  */
  pli->cm_config_opts = 0;
  pli->cm_align_opts = 0;
  /* should we configure CM/CP9 into local mode? */
  if(! esl_opt_GetBoolean(go, "-g")) {
	pli->cm_config_opts |= CM_CONFIG_LOCAL;
	if(! esl_opt_GetBoolean(go, "--cp9gloc")) {
	  pli->cm_config_opts |= CM_CONFIG_HMMLOCAL;
	  if(! esl_opt_GetBoolean(go, "--cp9noel")) {
	pli->cm_config_opts |= CM_CONFIG_HMMEL;
	  }
	}
  }
  /* should we setup for truncated alignments? */
  if(pli->do_trunc_ends || pli->do_trunc_any || pli->do_trunc_only || pli->do_trunc_5p_ends || pli->do_trunc_3p_ends) pli->cm_config_opts |= CM_CONFIG_TRUNC;

  /* will we be requiring a CM_SCAN_MX? a CM_TR_SCAN_MX? */
  if(pli->do_max   ||                    /* max mode, no filters */
	 pli->do_nohmm ||                    /* nohmm mode, no HMM filters */
	 esl_opt_GetBoolean(go, "--fqdb") || /* user specified to use --fqdb, do it */
	 esl_opt_GetBoolean(go, "--qdb")) {  /* user specified to use --qdb,  do it */
	pli->cm_config_opts |= CM_CONFIG_SCANMX;
	if(pli->do_trunc_ends || pli->do_trunc_any || pli->do_trunc_only || pli->do_trunc_5p_ends || pli->do_trunc_3p_ends) pli->cm_config_opts |= CM_CONFIG_TRSCANMX;
  }
  /* will we be requiring non-banded alignment matrices? */
  if(pli->do_max ||                     /* max mode, no filters, hit alignment will be nonbanded */
	 pli->do_nohmm ||                   /* nohmm mode, no HMM filters, hit alignment will be nonbanded */
	 esl_opt_GetBoolean(go, "--qdb")) { /* using QDBs in final Inside stage, only safe way to go is nonbanded alignment */
	pli->cm_align_opts |= CM_ALIGN_SMALL;
	pli->cm_align_opts |= CM_ALIGN_CYK;
	if(pli->do_max) pli->cm_align_opts |= CM_ALIGN_NONBANDED;
	else            pli->cm_align_opts |= CM_ALIGN_QDB;       /* --nohmm, --qdb */
	/* D&C truncated alignment is not robust, so we don't allow it */
	pli->do_trunc_ends    = FALSE;
	pli->do_trunc_any     = FALSE;
	pli->do_trunc_only    = FALSE;
	pli->do_trunc_5p_ends = FALSE;
	pli->do_trunc_3p_ends = FALSE;
  }
  else {
	pli->cm_align_opts |= CM_ALIGN_HBANDED;
	pli->cm_align_opts |= CM_ALIGN_POST;
	if(esl_opt_GetBoolean(go, "--acyk")) pli->cm_align_opts |= CM_ALIGN_CYK;
	else                                 pli->cm_align_opts |= CM_ALIGN_OPTACC;
  }

  /* Determine statistics modes for CM stages */
  pli->do_glocal_cm_always    = (esl_opt_GetBoolean(go, "-g")) ? TRUE : FALSE;
  pli->do_glocal_cm_cur       = pli->do_glocal_cm_always       ? TRUE : FALSE;
  pli->do_glocal_cm_sometimes = (esl_opt_IsOn(go, "--glist"))  ? TRUE : FALSE;

  pli->fcyk_cm_exp_mode       = pli->do_glocal_cm_always ? EXP_CM_GC : EXP_CM_LC;
  if(pli->final_cm_search_opts & CM_SEARCH_INSIDE) {
	pli->final_cm_exp_mode  = pli->do_glocal_cm_always ? EXP_CM_GI : EXP_CM_LI;
  }
  else {
	pli->final_cm_exp_mode = pli->do_glocal_cm_always ? EXP_CM_GC : EXP_CM_LC;
  }
  /* finished setting up parameters for CM stages */
  /********************************************************************************/

  return pli;

 ERROR:
  cm_pipeline_Destroy(pli, NULL);
  return NULL;
}

/* Function:  cm_pipeline_Reuse()
 * Synopsis:  Reuse a pipeline for next target.
 * Incept:    EPN, Fri Sep 24 16:28:55 2010
 *            SRE, Fri Dec  5 10:31:36 2008 [Janelia] (p7_pipeline_Reuse())
 *
 * Purpose:   Reuse <pli> for next target sequence (search mode)
 *            or model (scan mode).
 *
 *            May eventually need to distinguish from reusing pipeline
 *            for next query, but we're not really focused on multiquery
 *            use of hmmscan/hmmsearch/phmmer for the moment.
 */
int
cm_pipeline_Reuse(CM_PIPELINE *pli)
{
  p7_omx_Reuse(pli->oxf);
  p7_omx_Reuse(pli->oxb);
  p7_omx_Reuse(pli->fwd);
  p7_omx_Reuse(pli->bck);
  p7_domaindef_Reuse(pli->ddef);
  /* TO DO, write scanmatrixreuse */
  return eslOK;
}

/* Function:  cm_pipeline_Destroy()
 * Synopsis:  Free a <CM_PIPELINE> object.
 * Incept:    EPN, Fri Sep 24 16:29:34 2010
 *            SRE, Fri Dec  5 10:30:23 2008 [Janelia] (p7_pipeline_Destroy())
 *
 * Purpose:   Free a <CM_PIPELINE> object. Requires a cm (sigh) to free the scan matrix.
 */
void
cm_pipeline_Destroy(CM_PIPELINE *pli, CM_t *cm)
{
  if (pli == NULL) return;

  p7_omx_Destroy(pli->oxf);
  p7_omx_Destroy(pli->oxb);
  p7_omx_Destroy(pli->fwd);
  p7_omx_Destroy(pli->bck);
  p7_gmx_Destroy(pli->gfwd);
  p7_gmx_Destroy(pli->gbck);
  p7_gmx_Destroy(pli->gxf);
  p7_gmx_Destroy(pli->gxb);
  esl_randomness_Destroy(pli->r);
  p7_domaindef_Destroy(pli->ddef);
  free(pli);
}
/*---------------- end, CM_PIPELINE object ----------------------*/

/*****************************************************************
 * 2. Pipeline API.
 *****************************************************************/

/* Function:  cm_pli_TargetReportable
 * Synopsis:  Returns TRUE if target score meets reporting threshold.
 * Incept:    EPN, Fri Sep 24 16:34:37 2010
 *            SRE, Tue Dec  9 08:57:26 2008 [Janelia] (p7_pli_TargetReportable())
 *
 * Purpose:   Returns <TRUE> if the bit score <score> and/or
 *            E-value <Eval> meets per-target reporting thresholds
 *            for the processing pipeline.
 */
int
cm_pli_TargetReportable(CM_PIPELINE *pli, float score, double Eval)
{
  if      (  pli->by_E && Eval  <= pli->E) return TRUE;
  else if (! pli->by_E && score >= pli->T) return TRUE;
  return FALSE;
}

/* Function:  cm_pli_TargetIncludable()
 * Synopsis:  Returns TRUE if target score meets inclusion threshold.
 * Incept:    EPN, Fri Sep 24 16:32:43 2010
 *            SRE, Fri Jan 16 11:18:08 2009 [Janelia] (p7_pli_TargetIncludable())
 */
int
cm_pli_TargetIncludable(CM_PIPELINE *pli, float score, double Eval)
{
  if      (  pli->by_E && Eval  <= pli->incE) return TRUE;
  else if (! pli->by_E && score >= pli->incT) return TRUE;

  return FALSE;
}

/* Function:  cm_pli_NewModel()
 * Synopsis:  Prepare pipeline for a new CM/HMM
 * Incept:    EPN, Fri Sep 24 16:35:35 2010
 *            SRE, Fri Dec  5 10:35:37 2008 [Janelia] (p7_pli_NewModel())
 *
 * Purpose:   Caller has a new model.
 *            Prepare the pipeline <pli> to receive this model as either
 *            a query or a target.
 *
 *            The information of the model we may receive varies, as
 *            indicated by <modmode> and <pli->mode>. This is enforced
 *            by a contract check upon entrance, failure causes immediate
 *            return of eslEINCOMPAT.
 *
 *      case  <pli->mode>     <modmode>         <cm>      <om> and <bg>
 *      ----  --------------  ---------------   --------  -------------
 *         1  CM_SEARCH_SEQS  CM_NEWMODEL_CM    non-null  non-null
 *         2  CM_SCAN_SEQS    CM_NEWMODEL_MSV   NULL      non-null
 *         3  CM_SCAN_SEQS    CM_NEWMODEL_CM    non-null  NULL
 *
 *            <cm_clen>, <cm_W> and <cm_nbp> are always valid, but are only
 *            necessary for case 2.
 *
 *            Note that if we're in SEARCH mode, <modmode> will
 *            always be CM_NEWMODEL_CM. In SCAN mode, we may only
 *            call this function once with <modmode> == CM_NEWMODEL_MSV
 *            (case 2 above, this happens if no hit from the query
 *            sequence survives to the CM stage). Also, if we
 *            are in SCAN mode with modmode==CM_NEWMODEL_CM we must
 *            have entered this function previously for the same
 *            'model' with modmode==CM_NEWMODEL_MSV.
 *
 *            The pipeline may alter the null model in <bg> in a
 *            model-specific way (if we're using composition bias
 *            filter HMMs in the pipeline).
 *
 *            The value of <cm_W> passed in will not be changed. Upon
 *            exit >pli->cmW> will == <cm_W>. That is, we don't
 *            potentially set it based on the wcx mechanism within
 *            this function, the caller must have already done that if
 *            it should be done. (The wcx mechanism allows the user to
 *            specify W as a multiple (<x>) of the consensus length of
 *            the model via the --wcx option, controlled with
 *            pli->use_wcx and pli->wcx.)
 *
 *            If pli->do_hmmonly_cur and pli->by_E, we have to set
 *            pli->T as the bit score corresponding to an E-value
 *            of pli->E. This requires <p7_evparam> and <p7_max_length>.
 *            (If we're in SEARCH mode, <p7_max_length> will likely
 *            be equal to om->max_length, but in SCAN mode om may
 *            be NULL).
 *
 *            <cur_clan_idx> indicates the index of the clan for the
 *            model and will be transferred to any hits (CM_HIT) found
 *            with this model. It can be -1 if the model either does
 *            not belong to a clan or if we are not keeping track of
 *            clans (which is the usual case: clans are only used for
 *            certain options in cmscan).
 *
 *            <glocal_kh> is irrelevant (and can be NULL) unless
 *            we're in case 2 and pli->do_glocal_cm_sometimes is
 *            TRUE. If so, we update pli parameters relevant to
 *            the CM model configuration (local/global) depending
 *            on whether om->name is in <glocal_kh> (if it is,
 *            we set configuration to global, else we set it
 *            to local). This allows us to use glocal mode for
 *            only those models who are keys in glocal_kh (the
 *            cmscan --glist option) which was implemented between
 *            v1.1rc1 and v1.1rc2 solely to handle the fact that
 *            some Rfam bit score thresholds correspond to glocal
 *            mode and others to local (i.e. it's a brutal hack).
 *
 * Returns:   <eslOK> on success.
 *
 *            <eslEINCOMPAT> in contract is not met.
 *
 *            <eslEINVAL> if pipeline expects to be able to use a
 *            model's bit score thresholds, but this model does not
 *            have the appropriate ones set.
 */
int
cm_pli_NewModel(CM_PIPELINE *pli, int modmode, CM_t *cm, int cm_clen, int cm_W, int cm_nbp, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, int p7_max_length, int64_t cur_cm_idx, int cur_clan_idx, ESL_KEYHASH *glocal_kh)
{
  int status = eslOK;
  float T;

  /* check contract */
  if(pli->mode == CM_SEARCH_SEQS) { /* case 1 */
	if(modmode != CM_NEWMODEL_CM)
	if(cm == NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SEARCH mode and CM is NULL");
	if(cm->clen != cm_clen)                    ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->clen != cm_clen");
	if(cm->W    != cm_W)                       ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->W != cm_W");
	if(CMCountNodetype(cm, MATP_nd) != cm_nbp) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->clen != cm_clen");
	if(om == NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SEARCH mode and om is NULL");
	if(bg == NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SEARCH mode and bg is NULL");
  }
  else if(pli->mode == CM_SCAN_MODELS) {
	if(modmode == CM_NEWMODEL_MSV) { /* case 2 */
	  if(cm != NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/MSV mode, and CM is non-NULL");
	  if(om == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/MSV mode, and om is NULL");
	  if(bg == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/MSV mode, and bg is NULL");
	}
	else if(modmode == CM_NEWMODEL_CM) { /* case 3 */
	  if(cm == NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/CM mode, and CM is NULL");
	  if(cm->clen != cm_clen)                    ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->clen != cm_clen");
	  if(cm->W    != cm_W)                       ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->W != cm_W");
	  if(CMCountNodetype(cm, MATP_nd) != cm_nbp) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, cm->clen != cm_clen");
	  if(om != NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/CM mode, and om is non-NULL");
	  if(bg != NULL)                             ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, SCAN/CM mode, and bg is non-NULL");
	}
  }

  pli->cur_cm_idx   = cur_cm_idx;
  pli->cur_clan_idx = cur_clan_idx;

  /* Two sets (A and B) of value updates:
   * case 1: we do both sets
   * case 2: we do set A only
   * case 3: we do set B only
   */
  if(pli->mode == CM_SEARCH_SEQS || modmode == CM_NEWMODEL_MSV) {
	/* set A updates: case 1 and 2 do these */

	/* set model configuration local/global if we're in SCAN mode and do_glocal_cm_sometimes is TRUE*/
	if(modmode == CM_NEWMODEL_MSV && pli->do_glocal_cm_sometimes) {
	  if(glocal_kh == NULL)        ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, do_glocal_cm_sometimes is TRUE but glocal_kh is NULL");
	  if(pli->do_glocal_cm_always) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "cm_pli_NewModel(), contract violated, do_glocal_cm_sometimes and do_glocal_cm_always both TRUE");
	  status = esl_keyhash_Lookup(glocal_kh, om->name, -1, NULL);
	  if(status == eslOK) { /* om->name is in glocal_kh, use glocal CM stages for this model */
	pli->do_glocal_cm_cur  = TRUE;
	pli->fcyk_cm_exp_mode  = EXP_CM_GC;
	pli->final_cm_exp_mode = (pli->final_cm_search_opts & CM_SEARCH_INSIDE) ? EXP_CM_GI : EXP_CM_GC;
	pli->cm_config_opts &= ~CM_CONFIG_LOCAL;
	pli->cm_config_opts &= ~CM_CONFIG_HMMLOCAL;
	pli->cm_config_opts &= ~CM_CONFIG_HMMEL;
	  }
	  else if (status == eslENOTFOUND) { /* om->name is not in glocal_kh, use local CM stages for this model */
	pli->do_glocal_cm_cur  = FALSE;
	pli->fcyk_cm_exp_mode  = EXP_CM_LC;
	pli->final_cm_exp_mode = (pli->final_cm_search_opts & CM_SEARCH_INSIDE) ? EXP_CM_LI : EXP_CM_LC;
	pli->cm_config_opts |= CM_CONFIG_LOCAL;
	pli->cm_config_opts |= CM_CONFIG_HMMLOCAL;
	pli->cm_config_opts |= CM_CONFIG_HMMEL;
	  }
	  else { ESL_FAIL(status, pli->errbuf, "cm_pli_NewModel(), unexpected error looking up model %s\n", om->name); }
	}

	/* determine if we should use the special HMM only pipeline for this model,
	 * if pli->do_hmmonly_never    == TRUE: we won't,
	 * if pli->do_glocal_cm_cur    == TRUE: we won't,
	 * if pli->do_hmmonly_always   == TRUE: we will,
	 * else we will only if model has 0 base pairs.
	 */

	if     (pli->do_hmmonly_never  || pli->do_glocal_cm_cur) pli->do_hmmonly_cur = FALSE;
	else if(pli->do_hmmonly_always || cm_nbp == 0)           pli->do_hmmonly_cur = TRUE;
	else                                                     pli->do_hmmonly_cur = FALSE;

	if(pli->do_hmmonly_cur) {
	  pli->nmodels_hmmonly++;
	  pli->nnodes_hmmonly += cm_clen;
	}
	else {
	  pli->nmodels++;
	  pli->nnodes += cm_clen;
	}

	if (pli->do_msvbias || pli->do_vitbias || pli->do_fwdbias || pli->do_gfwdbias || pli->do_edefbias) {
	  p7_bg_SetFilter(bg, om->M, om->compo);
	}
	/* copy some values for the model */
	pli->cmW  = cm_W;
	pli->clen = cm_clen;

	/* determine pli->maxW, this will be one more than the number of
	 * residues that must overlap between adjacent windows on a single
	 * sequence, this is MAX of cm->W and pli->cmult * cm->clen.
	 * wmult is hardcoded as 1.0 and cmult as 1.25 in
	 * cm_pipeline_Create(). (cmult is purposefully equal to the
	 * minimum value for <x> from --wcx so that <x> is always obeyed.)
	 */
	pli->maxW = ESL_MAX(pli->wmult * cm_W, pli->cmult * cm_clen);
  }
  if(pli->mode == CM_SEARCH_SEQS || modmode == CM_NEWMODEL_CM) {
	/* set B updates: case 1 and 3 do these (they require a valid CM) */

	/* Update the current effective database size so it pertains to
	 * the new model. Also, If we're using an E-value threshold
	 * determine the bit score for this model that pertains to that
	 * E-value.  We have to do this differently if we're in HMM-only
	 * mode or not. If we're in HMM-only mode we probably don't even
	 * have CM E-value parameters.
	 */
	if(pli->do_hmmonly_cur) {
	  if(pli->by_E) {
	pli->T = cm_p7_E2Score(pli->E, pli->Z, p7_max_length, p7_evparam[CM_p7_LFTAU], p7_evparam[CM_p7_LFLAMBDA]);
	  }
	}
	else { /* ! do_hmmonly_cur */
	  if((status = UpdateExpsForDBSize(cm, pli->errbuf, pli->Z)) != eslOK) return status;
	  if(pli->by_E) {
	if((status = E2ScoreGivenExpInfo(cm->expA[pli->final_cm_exp_mode], pli->errbuf, pli->E, &T)) != eslOK) ESL_FAIL(status, pli->errbuf, "problem determining min score for E-value %6g for model %s\n", pli->E, cm->name);
	pli->T = (double) T;
	  }
	}

	/* if we're using Rfam GA, NC, or TC cutoffs, update them for this model */
	if (pli->use_bit_cutoffs) {
	  if((status = cm_pli_NewModelThresholds(pli, cm)) != eslOK) return status;
	}
  }
  return eslOK;
}

/* Function:  cm_pli_NewModelThresholds()
 * Synopsis:  Set reporting and inclusion bit score thresholds on a new model.
 * Incept:    EPN, Wed Jun 15 14:40:46 2011
 *            SRE, Sat Oct 17 12:07:43 2009 [Janelia] (p7_pli_NewModelThresholds()
 *
 * Purpose:   Set the bit score thresholds on a new model, if we're
 *            either using Rfam GA, TC, or NC cutoffs for reporting or
 *            inclusion, and/or if we already know the total
 *            database size.
 *
 *            In a "search" pipeline, this only needs to be done once
 *            per query model, so <cm_pli_NewModelThresholds()> gets
 *            called by <cm_pli_NewModel()>.
 *
 *            In a "scan" pipeline, this needs to be called for each
 *            target model.
 *
 * Returns:   <eslOK> on success.
 *
 *            <eslEINVAL> if pipeline expects to be able to use a
 *            model's bit score thresholds, but this model does not
 *            have the appropriate ones set.
 *
 * Xref:      Written to fix bug #h60 (p7_pli_NewModelThreshold())
 */
int
cm_pli_NewModelThresholds(CM_PIPELINE *pli, CM_t *cm)
{

  if (pli->use_bit_cutoffs) {
	if(pli->use_bit_cutoffs == CMH_GA) {
	  if (! (cm->flags & CMH_GA)) ESL_FAIL(eslEINVAL, pli->errbuf, "GA bit threshold unavailable for model %s\n", cm->name);
	  pli->T = pli->incT = cm->ga;
	}
	else if(pli->use_bit_cutoffs == CMH_TC) {
	  if (! (cm->flags & CMH_TC)) ESL_FAIL(eslEINVAL, pli->errbuf, "TC bit threshold unavailable for model %s\n", cm->name);
	  pli->T = pli->incT = cm->tc;
	}
	else if(pli->use_bit_cutoffs == CMH_NC) {
	  if (! (cm->flags & CMH_NC)) ESL_FAIL(eslEINVAL, pli->errbuf, "NC bit threshold unavailable for model %s\n", cm->name);
	  pli->T = pli->incT = cm->nc;
	}
  }
  return eslOK;
}

/* Function:  cm_pli_NewSeq()
 * Synopsis:  Prepare pipeline for a new sequence (target or query)
 * Incept:    EPN, Fri Sep 24 16:39:52 2010
 *            SRE, Fri Dec  5 10:57:15 2008 [Janelia] (p7_pli_NewSeq())
 *
 * Purpose:   Caller has a new sequence <sq>. Prepare the pipeline <pli>
 *            to receive this model as either a query or a target.
 *
 *            This function differs from the analog in the P7 HMMER3
 *            pipeline in that we don't update the <nres> residue
 *            count here. In a CM pipeline, we keep pass-specific
 *            counts of residues, and those counts are updated in
 *            cm_Pipeline(). Also, we don't update pli->Z, which must
 *            be set at beginning of a search, in the P7 pipeline
 *            Z is updated as sequences are read, by default.
 *
 * Returns:   <eslOK> on success.
 */
 int
 cm_pli_NewSeq(CM_PIPELINE *pli, const ESL_SQ *sq, int64_t cur_seq_idx)
{
  /* Update cur_seq_idx, which is a unique identifier for the sequence, so
   * we can reliably remove overlaps. This index is copied to all the
   * hit objects for all hits found by the pipeline when searching this sequence. */
  pli->cur_seq_idx = cur_seq_idx;

  return eslOK;
}

/* Function:  cm_pipeline_Merge()
 * Synopsis:  Merge pipeline statistics from <p2> with those in <p1>.
 * Incept:    EPN, Fri Sep 24 16:41:17 2010
 *
 * Purpose:   Merge statistics from <p2> with those in <p1>. The
 *            merged statistics will be saved in <p1>.
 *
 * Returns:   <eslOK> on success.
 *
 *            <eslEINVAL> if pipeline expects to be able to use a
 *            model's bit score thresholds, but this model does not
 *            have the appropriate ones set.
 */
int
cm_pipeline_Merge(CM_PIPELINE *p1, CM_PIPELINE *p2)
{
  /* if we are searching a sequence database, we need to keep track of the
   * number of sequences and residues processed.
   */
  int p; /* counter over pipeline passes */

  if (p1->mode == CM_SEARCH_SEQS)
	{
	  p1->nseqs   += p2->nseqs;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].npli_top += p2->acct[p].npli_top;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].npli_bot += p2->acct[p].npli_bot;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].nres_top += p2->acct[p].nres_top;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].nres_bot += p2->acct[p].nres_bot;
	}
  else
	{ /* SCAN mode */
	  p1->nmodels         += p2->nmodels;
	  p1->nnodes          += p2->nnodes;
	  p1->nmodels_hmmonly += p2->nmodels_hmmonly;
	  p1->nnodes_hmmonly  += p2->nnodes_hmmonly;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].nres_top += p2->acct[p].nres_top;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].nres_bot += p2->acct[p].nres_bot;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].npli_top += p2->acct[p].npli_top;
	  for(p = 0; p < NPLI_PASSES; p++) p1->acct[p].npli_bot += p2->acct[p].npli_bot;
	  /* If target CM file was small, it's possible that <p1->nseqs>
	   * is 0 and <p2->nseqs> is not, or vice versa. This happens if
	   * we had so few CMs in our database that not all threads got to
	   * actually do a search. To properly handle this case, we take
	   * the max instead of adding.
	   */
	  p1->nseqs = ESL_MAX(p1->nseqs, p2->nseqs);
	}

  for(p = 0; p < NPLI_PASSES; p++) {
	p1->acct[p].n_past_msv  += p2->acct[p].n_past_msv;
	p1->acct[p].n_past_vit  += p2->acct[p].n_past_vit;
	p1->acct[p].n_past_fwd  += p2->acct[p].n_past_fwd;
	p1->acct[p].n_past_gfwd += p2->acct[p].n_past_gfwd;
	p1->acct[p].n_past_edef += p2->acct[p].n_past_edef;
	p1->acct[p].n_past_cyk  += p2->acct[p].n_past_cyk;
	p1->acct[p].n_past_ins  += p2->acct[p].n_past_ins;
	p1->acct[p].n_output    += p2->acct[p].n_output;

	p1->acct[p].n_past_msvbias  += p2->acct[p].n_past_msvbias;
	p1->acct[p].n_past_vitbias  += p2->acct[p].n_past_vitbias;
	p1->acct[p].n_past_fwdbias  += p2->acct[p].n_past_fwdbias;
	p1->acct[p].n_past_gfwdbias += p2->acct[p].n_past_gfwdbias;
	p1->acct[p].n_past_edefbias += p2->acct[p].n_past_edefbias;

	p1->acct[p].pos_past_msv  += p2->acct[p].pos_past_msv;
	p1->acct[p].pos_past_vit  += p2->acct[p].pos_past_vit;
	p1->acct[p].pos_past_fwd  += p2->acct[p].pos_past_fwd;
	p1->acct[p].pos_past_gfwd += p2->acct[p].pos_past_gfwd;
	p1->acct[p].pos_past_edef += p2->acct[p].pos_past_edef;
	p1->acct[p].pos_past_cyk  += p2->acct[p].pos_past_cyk;
	p1->acct[p].pos_past_ins  += p2->acct[p].pos_past_ins;
	p1->acct[p].pos_output    += p2->acct[p].pos_output;

	p1->acct[p].pos_past_msvbias += p2->acct[p].pos_past_msvbias;
	p1->acct[p].pos_past_vitbias += p2->acct[p].pos_past_vitbias;
	p1->acct[p].pos_past_fwdbias += p2->acct[p].pos_past_fwdbias;
	p1->acct[p].pos_past_gfwdbias+= p2->acct[p].pos_past_gfwdbias;
	p1->acct[p].pos_past_edefbias += p2->acct[p].pos_past_edefbias;

	p1->acct[p].n_overflow_fcyk  += p2->acct[p].n_overflow_fcyk;
	p1->acct[p].n_overflow_final += p2->acct[p].n_overflow_final;
	p1->acct[p].n_aln_hb         += p2->acct[p].n_aln_hb;
	p1->acct[p].n_aln_dccyk      += p2->acct[p].n_aln_dccyk;
  }

  return eslOK;
}

/* Function:  cm_Pipeline()
 * Synopsis:  The accelerated seq/CM comparison pipeline.
 * Incept:    EPN, Fri Sep 24 16:42:21 2010
 *            TJW, Fri Feb 26 10:17:53 2018 [Janelia] (p7_Pipeline_Longtargets())
 *
 * Purpose:   Run the accelerated pipeline to compare p7 HMM <om> and
 *            covariance model <opt_cm> against sequence <sq>. This
 *            function calls other functions specific to each stage of
 *            the pipeline: pli_p7_filter(), pli_p7_env_def(),
 *            pli_cyk_env_filter(), pli_cyk_seq_filter(),
 *            pli_final_stage().
 *
 * Returns:   <eslOK> on success. If a significant hit is obtained,
 *            its information is added to the growing <hitlist>.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 *            <eslERANGE> on numerical overflow errors in the
 *            optimized vector implementations; particularly in
 *            posterior decoding. I don't believe this is possible for
 *            multihit local models, but I'm set up to catch it
 *            anyway. We may emit a warning to the user, but cleanly
 *            skip the problematic sequence and continue.
 *
 * Throws:    <eslEMEM> on allocation failure.
 *
 * Xref:      J4/25.
 */
int
cm_Pipeline(CM_PIPELINE *pli, off_t cm_offset, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, P7_SCOREDATA *msvdata, ESL_SQ *sq, CM_TOPHITS *hitlist, int in_rc, P7_HMM **opt_hmm, P7_PROFILE **opt_gm, P7_PROFILE **opt_Rgm, P7_PROFILE **opt_Lgm, P7_PROFILE **opt_Tgm, CM_t **opt_cm)
{
  int             status;
  int             nwin = 0;       /* number of windows surviving MSV & Vit & lFwd, filled by pli_p7_filter() */
  int64_t        *ws = NULL;      /* [0..i..nwin-1] window start positions, filled by pli_p7_filter() */
  int64_t        *we = NULL;      /* [0..i..nwin-1] window end   positions, filled by pli_p7_filter() */
  float          *wb = NULL;      /* [0..i..nwin-1] window bit scores, filled by pli_p7_filter, relevant only if pli->do_trm_F3 is TRUE */
  int            *np7envA =NULL;  /* [0..p..NPLI_PASSES] number of envelopes surviving MSV & Vit & lFwd & gFwd & EnvDef, filled by pli_p7_env_def() */
  int64_t        **p7esAA = NULL; /* [0..p..NPLI_PASSES][0..i..np7env-1] window start positions, filled by pli_p7_env_def() */
  int64_t        **p7eeAA = NULL; /* [0..p..NPLI_PASSES][0..i..np7env-1] window end   positions, filled by pli_p7_env_def() */
  float          **p7ebAA = NULL; /* [0..p..NPLI_PASSES][0..i..np7env-1] window bit score, filled by pli_p7_env_def() */
  int             nenv = 0;       /* number of envelopes surviving CYK filter, filled by pli_cyk_env_filter() or pli_cyk_seq_filter() */
  int64_t        *es  = NULL;     /* [0..i..nenv-1] envelope start positions, filled by pli_cyk_env_filter() or pli_cyk_seq_filter() */
  int64_t        *ee  = NULL;     /* [0..i..nenv-1] envelope end   positions, filled by pli_cyk_env_filter() or pli_cyk_seq_filter() */
  int             i;              /* counter over envelopes */
  CM_HIT         *hit = NULL;     /* ptr to the current hit output data, only used if pli->do_trmF3 */

  /* variables necessary for re-searching sequence ends */
  ESL_SQ   *sq2search = NULL;  /* a pointer to the sequence to search on current pass */
  ESL_SQ   *term5sq   = NULL;  /* a copy of the 5'-most pli->maxW residues from sq */
  ESL_SQ   *term3sq   = NULL;  /* a copy of the 3'-most pli->maxW residues from sq */
  int       p;                 /* counter over passes */
  int       nwin_pass_std_any = -1;  /* number of windows that survived pass 1 (PLI_PASS_STD_ANY), -1 indicates we didn't run PLI_PASS_STD_ANY */
  int       do_pass_std_any;         /* should we do pass 2 (PLI_PASS_STD_ANY)          search the full sequence with CM pipeline? */
  int       do_pass_5p_only_force;   /* should we do pass 2 (PLI_PASS_5P_ONLY_FORCE)?   re-search the 5'-most pli->maxW residues */
  int       do_pass_3p_only_force;   /* should we do pass 3 (PLI_PASS_3P_ONLY_FORCE)?   re-search the 3'-most pli->maxW residues */
  int       do_pass_5p_and_3p_force; /* should we do pass 4 (PLI_PASS_5P_AND_3P_FORCE)? re-search the full sequence allowing 5' and 3' truncated hits? */
  int       do_pass_5p_and_3p_any;   /* should we do pass 5 (PLI_PASS_5P_AND_3P_ANY)?   re-search the full sequence allowing for all truncated hits? */
  int       do_pass_hmm_only_any;    /* should we do pass 6 (PLI_PASS_HMM_ONLY_ANY)     search the full sequence with HMM only pipeline? */
  int       have5term;         /* TRUE if sq contains the 5'-most pli->maxW residues of its source sequence */
  int       have3term;         /* TRUE if sq contains the 3'-most pli->maxW residues of its source sequence */
  int       h;                 /* counter over hits */
  int       prv_ntophits;      /* number of hits */
  int64_t   start_offset;      /* offset to add to start/stop coordinates of hits found in pass 3, in which we re-search the 3' terminus */
  int       winning_pass = -1; /* best scoring pass in HMM stage, only used if pli->do_one_cmpass */
  float     winning_sc   = 0.; /* score of best scoring pass in HMM stage, only used if pli->do_one_cmpass */

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */

  if ((! pli->do_edef) && pli->do_one_cmpass) {
	ESL_FAIL(eslEINVAL, pli->errbuf, "cm_Pipeline() entered with do_edef as FALSE but do_onepass as TRUE, coding bug.");
  }

  /* Determine if we have the 5' and/or 3' termini. We can do this
   * because sq->L should always be valid. (Caller should enforce
   * this, but it takes some effort if caller is potentially reading
   * subsequences of large sequences. For example, cmsearch does an
   * initial readthrough of the entire target database file storing
   * the sequence lengths prior to doing any cm_Pipeline() calls (or
   * it uses sequence length info in an SSI index).
   */
  if(sq->start <= sq->end) { /* not in reverse complement (or 1 residue sequence, in revcomp) */
	have5term = (sq->start == 1)     ? TRUE : FALSE;
	have3term = (sq->end   == sq->L) ? TRUE : FALSE;
  }
  else { /* in reverse complement */
	have5term = (sq->start == sq->L) ? TRUE : FALSE;
	have3term = (sq->end   == 1)     ? TRUE : FALSE;
  }

#if eslDEBUGLEVEL >= 3
  /*printf("\nPIPELINE ENTRANCE %s  %s  %" PRId64 " residues (pli->maxW: %d om->max_length: %d cm->W: %d)\n", sq->name, sq->desc, sq->n, pli->maxW, om->max_length, (*opt_cm)->W);*/
  printf("\nPIPELINE ENTRANCE %-15s %15s  (n: %6" PRId64 " start: %6" PRId64 " end: %6" PRId64 " C: %6" PRId64 " W: %6" PRId64 " L: %6" PRId64 " have5term: %d have3term: %d)\n",
	 sq->name, om->name, sq->n, sq->start, sq->end, sq->C, sq->W, sq->L, have5term, have3term);
#endif

  /* allocate *p7* variables, if nec */
  if(pli->do_edef) {
	ESL_ALLOC(np7envA, sizeof(int)     * NPLI_PASSES);
	ESL_ALLOC(p7esAA,  sizeof(int *)   * NPLI_PASSES);
	ESL_ALLOC(p7eeAA,  sizeof(int *)   * NPLI_PASSES);
	ESL_ALLOC(p7ebAA,  sizeof(float *) * NPLI_PASSES);
	for(p = 0; p < NPLI_PASSES; p++) {
	  np7envA[p] = 0;
	  p7esAA[p] = NULL;
	  p7eeAA[p] = NULL;
	  p7ebAA[p] = NULL;
	}
  }

  /* determine which passes we'll need to do for this sequence. The
   * 'do_' variables indicated which type of truncations are allowed
   * in each pass; e.g. do_pass_5p_only_force: only 5' truncations are
   * allowed in that pass - we do this pass if <do_trunc_ends> is TRUE
   * and have5term is TRUE.
   */
  if(pli->do_hmmonly_cur) { /* HMM only mode, only PLI_PASS_HMM_ONLY_ANY is performed */
	do_pass_hmm_only_any = TRUE;
	do_pass_std_any = do_pass_5p_only_force = do_pass_3p_only_force = do_pass_5p_and_3p_force = do_pass_5p_and_3p_any = FALSE;
  }
  else if(pli->do_trunc_ends) { /* we allow truncated hits only at 5' or 3' end (default) */
	do_pass_std_any         = TRUE;
	do_pass_5p_only_force   = have5term ? TRUE : FALSE;
	do_pass_3p_only_force   = have3term ? TRUE : FALSE;
	do_pass_5p_and_3p_force = (have5term && have3term && sq->n <= pli->maxW) ? TRUE : FALSE;
	do_pass_5p_and_3p_any   = do_pass_hmm_only_any = FALSE;
  }
  else if(pli->do_trunc_5p_ends) { /* we allow truncated hits only at 5' end */
	do_pass_std_any        = TRUE;
	do_pass_5p_only_force  = have5term ? TRUE : FALSE;
	do_pass_3p_only_force  = do_pass_5p_and_3p_force = do_pass_5p_and_3p_any = do_pass_hmm_only_any = FALSE;
  }
  else if(pli->do_trunc_3p_ends) { /* we allow truncated hits only at 3' end */
	do_pass_std_any        = TRUE;
	do_pass_3p_only_force  = have3term ? TRUE : FALSE;
	do_pass_5p_only_force  = do_pass_5p_and_3p_force = do_pass_5p_and_3p_any = do_pass_hmm_only_any = FALSE;
  }
  else if(pli->do_trunc_any) { /* we allow any truncated hit, in a special pass PLI_PASS_5P_AND_3P_ANY */
	do_pass_std_any       = TRUE;
	do_pass_5p_and_3p_any = TRUE;
	do_pass_5p_only_force = do_pass_3p_only_force = do_pass_5p_and_3p_force = do_pass_hmm_only_any = FALSE;
  }
  else if(pli->do_trunc_only) { /* we allow any truncated hit, in a special pass PLI_PASS_5P_AND_3P_ANY */
	do_pass_5p_and_3p_any = TRUE;
	do_pass_std_any = do_pass_5p_only_force = do_pass_3p_only_force = do_pass_5p_and_3p_force = do_pass_hmm_only_any = FALSE;
  }
  else { /* we're not allowing any truncated hits */
	do_pass_std_any       = TRUE;
	do_pass_5p_only_force = do_pass_3p_only_force = do_pass_5p_and_3p_force = do_pass_5p_and_3p_any = do_pass_hmm_only_any = FALSE;
  }

#if eslDEBUGLEVEL >= 1
  printf("in cm_Pipeline() %s\n", sq->name);
  printf("do_pass_std_any:         %d\n", do_pass_std_any);
  printf("do_pass_5p_only_force:   %d\n", do_pass_5p_only_force);
  printf("do_pass_3p_only_force:   %d\n", do_pass_3p_only_force);
  printf("do_pass_5p_and_3p_force: %d\n", do_pass_5p_and_3p_force);
  printf("do_pass_5p_and_3p_any:   %d\n", do_pass_5p_and_3p_any);
  printf("do_pass_hmm_only_any:    %d\n", do_pass_hmm_only_any);
#endif

  /* First loop over each pipeline pass:
   * A. Update pipeline accounting numbers
   * B. Complete all HMM-based calculations (we'll do CM calculations in second loop over passes)
   */
  for(p = PLI_PASS_STD_ANY; p < NPLI_PASSES; p++) { /* p will go from 1..6 */
	if(p == PLI_PASS_STD_ANY         && (! do_pass_std_any))         continue;
	if(p == PLI_PASS_5P_ONLY_FORCE   && (! do_pass_5p_only_force))   continue;
	if(p == PLI_PASS_3P_ONLY_FORCE   && (! do_pass_3p_only_force))   continue;
	if(p == PLI_PASS_5P_AND_3P_FORCE && (! do_pass_5p_and_3p_force)) continue;
	if(p == PLI_PASS_5P_AND_3P_ANY   && (! do_pass_5p_and_3p_any))   continue;
	if(p == PLI_PASS_HMM_ONLY_ANY    && (! do_pass_hmm_only_any))    continue;

	/* A. Update pipeline accounting numbers
	 * Update npli_{top,bot} run and nres_{top,bot} searched for this
	 * pass. It's important to do this precisely here, in between the
	 * 'continue's above, but prior to the one below that 'continue's
	 * only because we know no windows pass local Fwd (F3).
	 */
	if(in_rc) pli->acct[p].npli_bot++;
	else      pli->acct[p].npli_top++;
	if(p == PLI_PASS_STD_ANY || p == PLI_PASS_5P_AND_3P_ANY || p == PLI_PASS_HMM_ONLY_ANY) {
	  if(in_rc) pli->acct[p].nres_bot += sq->n;
	  else      pli->acct[p].nres_top += sq->n;
	}
	else {
	  if(in_rc) pli->acct[p].nres_bot += ESL_MIN(pli->maxW, sq->n);
	  else      pli->acct[p].nres_top += ESL_MIN(pli->maxW, sq->n);
	}

	/* if we know there's no windows that pass local Fwd (F3), our terminal (or full) seqs won't have any either, continue */
	if(p != PLI_PASS_STD_ANY && p != PLI_PASS_HMM_ONLY_ANY && nwin_pass_std_any == 0 && (! pli->do_max)) continue;

	/* set sq2search and remember start_offset */
	start_offset = 0;
	if(p == PLI_PASS_STD_ANY || p == PLI_PASS_5P_AND_3P_FORCE || p == PLI_PASS_5P_AND_3P_ANY || p == PLI_PASS_HMM_ONLY_ANY || sq->n <= pli->maxW) {
	  sq2search = sq;
	}
	else if(p == PLI_PASS_5P_ONLY_FORCE) { /* research first (5') pli->maxW residues */
	  term5sq = esl_sq_CreateDigital(bg->abc);
	  pli_copy_subseq(sq, term5sq, 1, pli->maxW);
	  sq2search = term5sq;
	}
	else if(p == PLI_PASS_3P_ONLY_FORCE) { /* research first (5') pli->maxW residues */
	  term3sq = esl_sq_CreateDigital(bg->abc);
	  pli_copy_subseq(sq, term3sq, sq->n - pli->maxW + 1, pli->maxW);
	  sq2search = term3sq;
	  start_offset = sq->n - pli->maxW;
	}
	pli->cur_pass_idx = p; /* pipeline stages will use this to modify pass-specific behavior as necessary */

	/* Execute the pipeline, either HMM only mode (relatively simple), or normal CM mode (more complex) */
	if(p == PLI_PASS_HMM_ONLY_ANY) {
	  /********************************************************************************************************/
	  /* Execute the HMM-only filter pipeline:
	   * A. pli_p7_filter():           MSV, Viterbi, local Forward filters
	   * B. pli_final_stage_hmmonly(): use H3 local domain definition to define HMM hits
	   ********************************************************************************************************/
#if eslDEBUGLEVEL >= 3
	  printf("\nHMM ONLY PIPELINE calling p7_filter() %s  %" PRId64 " residues (pass: %d)\n", sq2search->name, sq2search->n, p);
#endif
	  if((status = pli_p7_filter(pli, om, bg, p7_evparam, msvdata, sq2search, &ws, &we, &wb, &nwin)) != eslOK) return status;
	  if(pli->do_time_F1 || pli->do_time_F2 || pli->do_time_F3) return status;
	  prv_ntophits = hitlist->N;
	  if((status = pli_final_stage_hmmonly(pli, cm_offset, om, bg, p7_evparam, sq2search, ws, we, nwin, hitlist, opt_cm)) != eslOK) return status;
	}
	else { /* normal case, p != PLI_PASS_HMM_ONLY_ANY */
	  /* Use HMM to define envelopes, if nec.
	   * If we skip this step (if pli->do_edef == FALSE)
	   * we will do it with the CM in the second loop over passes below.
	   */
	  if(pli->do_edef) {
	/* Defining envelopes with p7 HMM:
	 * A. pli_p7_filter():   SSV, Viterbi, local Forward filters
	 * B. pli_p7_env_def():  glocal Forward, and glocal (usually) HMM envelope definition, then
	 */
#if eslDEBUGLEVEL >= 3
	printf("\nPIPELINE calling p7_filter() %s  %" PRId64 " residues (pass: %d)\n", sq2search->name, sq2search->n, p);
#endif
	if((status = pli_p7_filter(pli, om, bg, p7_evparam, msvdata, sq2search, &ws, &we, &wb, &nwin)) != eslOK) return status;
	if(p == PLI_PASS_STD_ANY) nwin_pass_std_any = nwin;
	if(pli->do_time_F1 || pli->do_time_F2 || pli->do_time_F3) return status;

		if(pli->do_trm_F3) { /* terminate after F3, and convert surviving windows to hits */
		  for(h = 0; h < nwin; h++) {
			/* create a hit from each window to be output at end of run, we do this (as opposed to
			 * just outputting info on windows *here*) so that we can use our machinery for removing
			 * overlaps later before we output.
			 */
			cm_tophits_CreateNextHit(hitlist, &hit);
			hit->start    = ws[h];
			hit->stop     = we[h];
			hit->root     = -1; /* irrelevant in HMM only hit */
			hit->mode     = TRMODE_J; /* irrelevant */
			hit->score    = wb[h];

			hit->cm_idx   = pli->cur_cm_idx;
			hit->clan_idx = pli->cur_clan_idx;
			hit->seq_idx  = pli->cur_seq_idx;
			hit->pass_idx = pli->cur_pass_idx;
			hit->pvalue   = 0.; /* irrelevant */
			hit->srcL     = sq->L; /* this may be -1, in which case it will be updated by caller (cmsearch or cmscan) when full length is known */

			hit->hmmonly    = TRUE;
			hit->glocal     = FALSE; /* all HMM hits are local */
			hit->bias       = 0.; /* irrelevant */
			hit->evalue     = 0.; /* irrelevant */
			hit->has_evalue = FALSE;
			hit->ad         = NULL;

			if (pli->mode == CM_SEARCH_SEQS) {
			  if (                       (status  = esl_strdup(sq->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			  if (sq->acc[0]  != '\0' && (status  = esl_strdup(sq->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			  /* special for do_trm_F3: description gets overwritten as query name */
			  if ((status  = esl_strdup(om->name, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			}
			else { /* SCAN mode */
			  if ((status  = esl_strdup(om->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			  if ((status  = esl_strdup(om->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			  /* special for do_trm_F3: description gets overwritten as query name */
			  if ((status  = esl_strdup(sq->name, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
			}
		  }
		}
		else {
#if eslDEBUGLEVEL >= 3
		  printf("\nPIPELINE calling p7_env_def() %s  %" PRId64 " residues (pass: %d)\n", sq2search->name, sq2search->n, p);
#endif
		  if((status = pli_p7_env_def(pli, om, bg, p7_evparam, sq2search, ws, we, nwin, opt_hmm, opt_gm, opt_Rgm, opt_Lgm, opt_Tgm, &(p7esAA[p]), &(p7eeAA[p]), &(p7ebAA[p]), &(np7envA[p]))) != eslOK) return status;
		}
	  } /* end of if(pli->do_edef) */
	} /* end of 'else' entered if p != PLI_PASS_HMM_ONLY_ANY */
	if(ws    != NULL) { free(ws);    ws   = NULL; }
	if(we    != NULL) { free(we);    we   = NULL; }
	if(wb    != NULL) { free(wb);    wb   = NULL; }
	nwin = 0;
  } /* end of 'for(p = PLI_PASS_STD_ANY; p <= PLI_NPASSES; p++)', first loop over pipeline passes */

  if(pli->do_one_cmpass) {
	winning_pass = -1;
	/* if following criteria are met, only perform CM stages below with best scoring pass:
	 * C1. all passes have 0 or 1 envelopes
	 * C2. all envelopes encompass the full sequence
	 */
	for(p = PLI_PASS_STD_ANY; p < NPLI_PASSES; p++) {
	  if(np7envA[p] == 1) {
		if(p7esAA[p][0] == 1 && p7eeAA[p][0] == sq->L) {
		  if(winning_pass == -1 || p7ebAA[p][0] > winning_sc) {
			winning_pass = p;
			winning_sc   = p7ebAA[p][0];
		  }
		}
		else {
		  p = NPLI_PASSES + 1; /* serves as a flag that we violated our criteria (C2 in this case) */
		}
	  }
	  else if(np7envA[p] > 1) {
		p = NPLI_PASSES + 1; /* serves as a flag that we violated our criteria (C1 in this case) */
	  }
	}
  }

  /* Second loop over each pipeline pass:
   * Complete all CM-based calculations.
   */
  for(p = PLI_PASS_STD_ANY; p < NPLI_PASSES; p++) { /* p will go from 1..6 */
	if(pli->do_trm_F3)                                               continue;
	if(winning_pass != -1            && p != winning_pass)           continue;
	if(p == PLI_PASS_STD_ANY         && (! do_pass_std_any))         continue;
	if(p == PLI_PASS_5P_ONLY_FORCE   && (! do_pass_5p_only_force))   continue;
	if(p == PLI_PASS_3P_ONLY_FORCE   && (! do_pass_3p_only_force))   continue;
	if(p == PLI_PASS_5P_AND_3P_FORCE && (! do_pass_5p_and_3p_force)) continue;
	if(p == PLI_PASS_5P_AND_3P_ANY   && (! do_pass_5p_and_3p_any))   continue;
	if(p == PLI_PASS_HMM_ONLY_ANY)                                   continue; /* we already handled this pass completely in the first loop over passes above */

	/* if we know there's no windows that pass local Fwd (F3), our terminal (or full) seqs won't have any either, continue */
	if(p != PLI_PASS_STD_ANY && p != PLI_PASS_HMM_ONLY_ANY && nwin_pass_std_any == 0 && (! pli->do_max)) continue;

	/* set sq2search and remember start_offset as we did above in first loop over passes, but we don't have to create term5sq and term3sq again */
	start_offset = 0;
	if(p == PLI_PASS_STD_ANY || p == PLI_PASS_5P_AND_3P_FORCE || p == PLI_PASS_5P_AND_3P_ANY || p == PLI_PASS_HMM_ONLY_ANY || sq->n <= pli->maxW) {
	  sq2search = sq;
	}
	else if(p == PLI_PASS_5P_ONLY_FORCE) { /* research first (5') pli->maxW residues */
	  sq2search = term5sq;
	}
	else if(p == PLI_PASS_3P_ONLY_FORCE) { /* research first (5') pli->maxW residues */
	  sq2search = term3sq;
	  start_offset = sq->n - pli->maxW;
	}
	pli->cur_pass_idx = p; /* pipeline stages will use this to modify pass-specific behavior as necessary */

	/* 3 ways to determine the envelopes to pass to the Final CM stage:
	 * 1. Banded CYK on the envelopes defined by the p7 HMM in the pipeline pass above (if pli->do_edef == TRUE)
	 * 2. Using CYK to define envelopes on full sequences                              (if pli->do_edef == FALSE && pli->fcyk = TRUE)
	 * 3. Each full seq is an envelope to be examined by the Final stage  (no filters,  if pli->do_edef == FALSE && pli->fcyk = FALSE)
	 */

	/* 1. Banded CYK on the envelopes defined by the p7 HMM in the pipeline pass above (if pli->do_edef == TRUE) */
	if(pli->do_edef) {
	  if(pli->do_fcyk) {
	  #if eslDEBUGLEVEL >= 3
		printf("\nPIPELINE calling pli_cyk_env_filter() %s  %" PRId64 " residues (pass: %d)\n", sq2search->name, sq2search->n, p);
	  #endif
		if((status = pli_cyk_env_filter(pli, cm_offset, sq2search, p7esAA[p], p7eeAA[p], np7envA[p], opt_cm, &es, &ee, &nenv)) != eslOK) return status;
		if(pli->do_time_F4 || pli->do_time_F5) return status;
	  }
	  else { /* defined envelopes with HMM, but CYK filter is off: act as if all p7-defined envelopes survived CYK */
		ESL_ALLOC(es, sizeof(int64_t) * ESL_MAX(1, np7envA[p])); // avoid 0 malloc
		ESL_ALLOC(ee, sizeof(int64_t) * ESL_MAX(1, np7envA[p]));
		for(i = 0; i < np7envA[p]; i++) { es[i] = p7esAA[p][i]; ee[i] = p7eeAA[p][i]; }
		nenv = np7envA[p];
	  }
	}
	/* 2. Using CYK to define envelopes on full sequences (if pli->do_edef == FALSE && pli->fcyk = TRUE) */
	else if((! pli->do_edef) && pli->do_fcyk) {
	  /* Defining envelopes with CYK */
#if eslDEBUGLEVEL >= 3
	  printf("\nPIPELINE calling pli_cyk_seq_filter() %s  %" PRId64 " residues (pass: %d)\n", sq2search->name, sq2search->n, p);
#endif
	  if((status = pli_cyk_seq_filter(pli, cm_offset, sq2search, opt_cm, &es, &ee, &nenv)) != eslOK) return status;
	}
	/* 3. Each full seq is an envelope to be examined by the Final stage  (no filters,  if pli->do_edef == FALSE && pli->fcyk = FALSE) */
	else {
	  ESL_ALLOC(es, sizeof(int64_t) * 1);
	  ESL_ALLOC(ee, sizeof(int64_t) * 1);
	  nenv = 1; es[0] = 1; ee[0] = sq2search->n;
	}
	if(pli->do_time_F6) return status;

	/* Filters are finished. Final stage of pipeline (always run).
	 */
#if eslDEBUGLEVEL >= 3
	printf("\nPIPELINE calling FinalStage() %s  %" PRId64 " residues model: %s (pass: %d) nhits: %" PRId64 "\n", sq2search->name, sq2search->n, om->name, p, hitlist->N);
#endif
	prv_ntophits = hitlist->N;
	if((status = pli_final_stage(pli, cm_offset, sq2search, es, ee, nenv, hitlist, opt_cm)) != eslOK) return status;
#if eslDEBUGLEVEL >= 3
	printf("\nPIPELINE back from FinalStage() %s  %" PRId64 " residues model: %s (pass: %d) nhits: %" PRId64 "\n", sq2search->name, sq2search->n, om->name, p, hitlist->N);
#endif

	/* if we're researching a 3' terminus, adjust the start/stop
	 * positions so they are relative to the actual 5' start
	 */
	if(hitlist->N > prv_ntophits) {
	  if(start_offset != 0) { /* this will only be non-zero if we're in pass PLI_PASS_3P_ONLY_FORCE */
		for(h = prv_ntophits; h < hitlist->N; h++) {
		  hitlist->unsrt[h].start += start_offset;
		  hitlist->unsrt[h].stop  += start_offset;
		  if(hitlist->unsrt[h].ad != NULL) {
			hitlist->unsrt[h].ad->sqfrom += start_offset;
			hitlist->unsrt[h].ad->sqto   += start_offset;
		  }
		}
	  }
	}
	if(es != NULL) { free(es); es   = NULL; }
	if(ee != NULL) { free(ee); ee   = NULL; }
	nenv = 0;
  } /* end of 'for(p = PLI_PASS_STD_ANY; p <= PLI_NPASSES; p++)', second loop over pipeline passes */

  if(np7envA != NULL) free(np7envA);
  for(p = 0; p < NPLI_PASSES; p++) {
	if(p7esAA && p7esAA[p]) free(p7esAA[p]);
	if(p7eeAA && p7eeAA[p]) free(p7eeAA[p]);
	if(p7ebAA && p7ebAA[p]) free(p7ebAA[p]);
  }
  if(p7esAA) free(p7esAA);
  if(p7eeAA) free(p7eeAA);
  if(p7ebAA) free(p7ebAA);

  if(term5sq != NULL) esl_sq_Destroy(term5sq);
  if(term3sq != NULL) esl_sq_Destroy(term3sq);

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, pli->errbuf, "out of memory");
}

/* Function:  cm_pli_Statistics()
 * Synopsis:  Final stats output for all passes of a pipeline.
 * Incept:    EPN, Thu Feb 16 15:19:35 2012
 *
 * Purpose:   Print a standardized report of the internal statistics of
 *            a finished processing pipeline <pli> to stream <ofp>.
 *            If pli->be_verbose, print statistics for each pass,
 *            else only print statistics for the standard pass.
 *
 *            Actual work is done by repeated calls to
 *            pli_pass_statistics().
 *
 * Returns:   <eslOK> on success.
 */
int
cm_pli_Statistics(FILE *ofp, CM_PIPELINE *pli, ESL_STOPWATCH *w)
{
  if(pli->nmodels > 0 && pli->be_verbose) { /* print stats out for each stage */
	if(! pli->do_trunc_only) {
	  pli_pass_statistics(ofp, pli, PLI_PASS_STD_ANY); fprintf(ofp, "\n");
	}
	if(pli->do_trunc_ends) {
	  pli_pass_statistics(ofp, pli, PLI_PASS_5P_ONLY_FORCE);   fprintf(ofp, "\n");
	  pli_pass_statistics(ofp, pli, PLI_PASS_3P_ONLY_FORCE);   fprintf(ofp, "\n");
	  pli_pass_statistics(ofp, pli, PLI_PASS_5P_AND_3P_FORCE); fprintf(ofp, "\n");
	}
	else if(pli->do_trunc_5p_ends) {
	  pli_pass_statistics(ofp, pli, PLI_PASS_5P_ONLY_FORCE);   fprintf(ofp, "\n");
	}
	else if(pli->do_trunc_3p_ends) {
	  pli_pass_statistics(ofp, pli, PLI_PASS_3P_ONLY_FORCE); fprintf(ofp, "\n");
	}
	else if(pli->do_trunc_any || pli->do_trunc_only) {
	  pli_pass_statistics(ofp, pli, PLI_PASS_5P_AND_3P_ANY); fprintf(ofp, "\n");
	}
  }
  if(pli->nmodels_hmmonly > 0) { /* HMM only pipeline used for at least one model */
	pli_hmmonly_pass_statistics(ofp, pli); fprintf(ofp, "\n");
  }
  if(pli->nmodels > 0) { /* CM pipeline was used for at least one model */
	pli_sum_statistics(pli);
	pli_pass_statistics(ofp, pli, PLI_PASS_CM_SUMMED); fprintf(ofp, "\n");
  }
  if(pli->nmodels > 0 && pli->nmodels_hmmonly > 0) {
	fprintf(ofp, "Total CM and HMM hits reported:                    %15d\n\n",
	    (int) (pli->acct[PLI_PASS_CM_SUMMED].n_output) +
	    (int) (pli->acct[PLI_PASS_HMM_ONLY_ANY].n_output));
  }
  if(w != NULL) esl_stopwatch_Display(ofp, w, "# CPU time: ");

  return eslOK;
}

/* Function:  pli_pass_statistics()
 * Synopsis:  Final stats output for one pass of a pipeline.
 * Incept:    EPN, Fri Sep 24 16:48:06 2010
 *            SRE, Tue Dec  9 10:19:45 2008 [Janelia] (p7_pli_Statistics())
 *
 * Purpose:   Print a standardized report of the internal statistics of
 *            a finished processing pipeline <pli> to stream <ofp>.
 *
 * Returns:   <eslOK> on success.
 */
int
pli_pass_statistics(FILE *ofp, CM_PIPELINE *pli, int pass_idx)
{
  int64_t nwin_fcyk  = 0;      /* number of windows CYK filter evaluated */
  int64_t nwin_final = 0;      /* number of windows final stage evaluated */
  int64_t n_output_trunc;      /* number of truncated hits */
  int64_t pos_output_trunc;    /* number of residues in truncated hits */
  int64_t nres_searched = 0;   /* number of residues searched in this stage */
  int64_t nres_researched = 0; /* number of residues re-searched for truncated hits */

  CM_PLI_ACCT *pli_acct = &(pli->acct[pass_idx]);

  /* first, determine number of residues searched, and num res re-searched for truncated hits */
  nres_searched = pli_acct->nres_top + pli_acct->nres_bot;
  switch(pass_idx) {
  case PLI_PASS_CM_SUMMED:
	nres_researched = (pli_acct->nres_top + pli->acct->nres_bot) - (pli->acct[PLI_PASS_STD_ANY].nres_top + pli->acct[PLI_PASS_STD_ANY].nres_bot);
	break;
  case PLI_PASS_STD_ANY:
	nres_researched = 0;
	break;
  case PLI_PASS_5P_ONLY_FORCE:
  case PLI_PASS_3P_ONLY_FORCE:
  case PLI_PASS_5P_AND_3P_FORCE:
  case PLI_PASS_5P_AND_3P_ANY:
	nres_researched = pli_acct->nres_top + pli_acct->nres_bot;
	break;
  default:
	nres_researched = 0;
	break;
  }

  if(pli->be_verbose) {
	fprintf(ofp, "Internal CM pipeline statistics summary: %s\n", pli_describe_pass(pass_idx));
  }
  else {
	fprintf(ofp, "Internal CM pipeline statistics summary:\n");
  }
  fprintf(ofp, "----------------------------------------\n");
  if (pli->mode == CM_SEARCH_SEQS) {
	fprintf(ofp,   "Query model(s):                                    %15" PRId64 "  (%" PRId64 " consensus positions)\n",
	    pli->nmodels, pli->nnodes);
	if(pass_idx == PLI_PASS_STD_ANY || pass_idx == PLI_PASS_CM_SUMMED) {
	  fprintf(ofp,   "Target sequences:                                  %15" PRId64 "  (%" PRId64 " residues searched)\n",
	      pli->nseqs, nres_searched - nres_researched);
	}
	if(pass_idx != PLI_PASS_STD_ANY) {
	  if(pass_idx == PLI_PASS_5P_AND_3P_FORCE) {
	  /* special case, not all sequences get searched by this pass,
	   * since only seqs < maxW are searched in this pass (so no
	   * sequence is chopped up into overlapping windows) npli
	   * is equal to number of sequences searched (npli_top or
	   * npli_bot).
	   */
	fprintf(ofp,   "Target sequences re-searched for truncated hits:   %15" PRId64 "  (%" PRId64 " residues re-searched)\n",
		(pli->do_trunc_ends) ? ESL_MAX(pli_acct->npli_top, pli_acct->npli_bot) : 0,
		nres_researched);
	  }
	  else {
		if(pli->do_trunc_only) {
		  fprintf(ofp,   "Target sequences searched for truncated hits:      %15" PRId64 "  (%" PRId64 " residues searched)\n",
				  pli->nseqs, nres_researched);
		}
		else {
		  fprintf(ofp,   "Target sequences re-searched for truncated hits:   %15" PRId64 "  (%" PRId64 " residues re-searched)\n",
				  (pli->do_trunc_ends || pli->do_trunc_any || pli->do_trunc_5p_ends || pli->do_trunc_3p_ends) ? pli->nseqs : 0,
				  nres_researched);
		}
	  }
	}
  } else { /* SCAN mode */
	if(pass_idx == PLI_PASS_STD_ANY || pass_idx == PLI_PASS_CM_SUMMED) {
	  fprintf(ofp,   "Query sequence(s):                                 %15" PRId64 "  (%d residues searched)\n",
	      pli->nseqs, (int) ((nres_searched - nres_researched) / pli->nmodels));
	}
	if(pass_idx != PLI_PASS_STD_ANY) {
	  if(pass_idx == PLI_PASS_5P_AND_3P_FORCE) {
	  /* special case, not all sequences get searched by this pass,
	   * since only seqs < maxW are searched in this pass, if
	   * npli_top or npli_bot is greater than 0, then we searched
	   * pli->nseqs (which is always 1) with at least 1 model
	   * (we could also use pli->nres_researched > 0 as an
	   * indication of whether we searched with any models or not).
	   */
	fprintf(ofp,   "Query sequences re-searched for truncated hits:    %15" PRId64 "  (%.1f residues re-searched, avg per model)\n",
		(pli_acct->npli_top > 0 || pli_acct->npli_bot > 0) ? pli->nseqs : 0,
		(pli_acct->npli_top > 0 || pli_acct->npli_bot > 0) ? (float) nres_researched / (float) (ESL_MAX(pli_acct->npli_top, pli_acct->npli_bot)) : 0.);
	  }
	  else {
	fprintf(ofp,   "Query sequences re-searched for truncated hits:    %15" PRId64 "  (%.1f residues re-searched, avg per model)\n",
		(pli->do_trunc_ends || pli->do_trunc_any || pli->do_trunc_only || pli->do_trunc_5p_ends || pli->do_trunc_3p_ends) ? pli->nseqs : 0,
		(float) nres_researched / (float) pli->nmodels);
	  }
	}
	if(pass_idx == PLI_PASS_5P_AND_3P_FORCE) {
	  /* special case, only print number of models with which
	   * we actually searched. It won't necessarily be all models
	   * because only models for which the sequence is < maxW will
	   * be used. And don't print number of nodes - we don't
	   * keep track of that for this stage.
	   */
	  fprintf(ofp,   "Target model(s):                                   %15" PRId64 "\n",
	      ESL_MAX(pli_acct->npli_top, pli_acct->npli_bot));
	}
	else {
	  fprintf(ofp,   "Target model(s):                                   %15" PRId64 "  (%" PRId64 " consensus positions)\n",
	      pli->nmodels, pli->nnodes);
	}
  }

  if(pli->do_msv) {
	fprintf(ofp, "Windows   passing  local HMM SSV           filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_msv,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_msv / nres_searched,
	    pli->F1);
	nwin_fcyk = nwin_final = pli_acct->n_past_msv;
  }
  else {
	fprintf(ofp, "Windows   passing  local HMM SSV           filter: %15s  (off)\n", "");
  }

  if(pli->do_msvbias) {
	fprintf(ofp, "Windows   passing  local HMM MSV      bias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_msvbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_msvbias / nres_searched,
	    pli->F1b);
	nwin_fcyk = nwin_final = pli_acct->n_past_msvbias;
  }
  /* msv bias is off by default, so don't output anything if it's off */

  if(pli->do_vit) {
	fprintf(ofp, "Windows   passing  local HMM Viterbi       filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_vit,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_vit / nres_searched,
	    pli->F2);
	nwin_fcyk = nwin_final = pli_acct->n_past_vit;
  }
  else {
	fprintf(ofp, "Windows   passing  local HMM Viterbi       filter: %15s  (off)\n", "");
  }

  if(pli->do_vitbias) {
	fprintf(ofp, "Windows   passing  local HMM Viterbi  bias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_vitbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_vitbias / nres_searched,
	    pli->F2b);
	nwin_fcyk = nwin_final = pli_acct->n_past_vitbias;
  }
  else {
	fprintf(ofp, "Windows   passing  local HMM Viterbi  bias filter: %15s  (off)\n", "");
  }

  if(pli->do_fwd) {
	fprintf(ofp, "Windows   passing  local HMM Forward       filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_fwd,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_fwd / nres_searched,
	    pli->F3);
	nwin_fcyk = nwin_final = pli_acct->n_past_fwd;
  }
  else {
	fprintf(ofp, "Windows   passing  local HMM Forward       filter: %15s  (off)\n", "");
  }

  if(pli->do_fwdbias) {
	fprintf(ofp, "Windows   passing  local HMM Forward  bias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_fwdbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_fwdbias / nres_searched,
	    pli->F3b);
	nwin_fcyk = nwin_final = pli_acct->n_past_fwdbias;
  }
  else {
	fprintf(ofp, "Windows   passing  local HMM Forward  bias filter: %15s  (off)\n", "");
  }

  if(pli->do_gfwd) {
	fprintf(ofp, "Windows   passing glocal HMM Forward       filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_gfwd,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_gfwd / nres_searched,
	    pli->F4);
	nwin_fcyk = nwin_final = pli_acct->n_past_gfwd;
  }
  else {
	fprintf(ofp, "Windows   passing glocal HMM Forward       filter: %15s  (off)\n", "");
  }
  if(pli->do_gfwdbias) {
	fprintf(ofp, "Windows   passing glocal HMM Forward  bias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_gfwdbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_gfwdbias / nres_searched,
	    pli->F4b);
	nwin_fcyk = nwin_final = pli_acct->n_past_gfwdbias;
  }
  else {
	fprintf(ofp, "Windows   passing glocal HMM Forward  bias filter: %15s  (off)\n", "");
  }

  if(pli->do_edef) {
	fprintf(ofp, "Envelopes passing glocal HMM envelope defn filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_edef,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_edef / nres_searched,
	    pli->F5);
	nwin_fcyk = nwin_final = pli_acct->n_past_edef;
  }
  else {
	fprintf(ofp, "Envelopes passing glocal HMM envelope defn filter: %15s  (off)\n", "");
  }

  if(pli->do_edefbias) {
	fprintf(ofp, "Envelopes passing glocal HMM envelope bias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    pli_acct->n_past_edefbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_edefbias / nres_searched,
	    pli->F5b);
	nwin_fcyk = nwin_final = pli_acct->n_past_edefbias;
  }
  /* edef bias is off by default, so don't output anything if it's off */

  if(pli->do_fcyk) {
	fprintf(ofp, "Envelopes passing %6s CM  CYK           filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    (pli->do_glocal_cm_always || pli->do_glocal_cm_sometimes) ? ((pli->do_glocal_cm_always) ? "glocal" : "") : "local",
	    pli_acct->n_past_cyk,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_cyk / nres_searched,
	    pli->F6);
	nwin_final = pli_acct->n_past_cyk;
  }
  else {
	fprintf(ofp, "Envelopes passing %6s CM  CYK           filter: %15s  (off)\n",
	    (pli->do_glocal_cm_always || pli->do_glocal_cm_sometimes) ? ((pli->do_glocal_cm_always) ? "glocal" : "") : "local",
	    "");
  }

  if(pass_idx == PLI_PASS_CM_SUMMED) {
	if(pli->do_trunc_ends) {
	  n_output_trunc   = pli->acct[PLI_PASS_5P_ONLY_FORCE].n_output   + pli->acct[PLI_PASS_3P_ONLY_FORCE].n_output   + pli->acct[PLI_PASS_5P_AND_3P_FORCE].n_output;
	  pos_output_trunc = pli->acct[PLI_PASS_5P_ONLY_FORCE].pos_output + pli->acct[PLI_PASS_3P_ONLY_FORCE].pos_output + pli->acct[PLI_PASS_5P_AND_3P_FORCE].pos_output;
	}
	else if(pli->do_trunc_5p_ends) {
	  n_output_trunc   = pli->acct[PLI_PASS_5P_ONLY_FORCE].n_output;
	  pos_output_trunc = pli->acct[PLI_PASS_5P_ONLY_FORCE].pos_output;
	}
	else if(pli->do_trunc_3p_ends) {
	  n_output_trunc   = pli->acct[PLI_PASS_3P_ONLY_FORCE].n_output;
	  pos_output_trunc = pli->acct[PLI_PASS_3P_ONLY_FORCE].pos_output;
	}
	else if(pli->do_trunc_any || pli->do_trunc_only) {
	  n_output_trunc   = pli->acct[PLI_PASS_5P_AND_3P_ANY].n_output;
	  pos_output_trunc = pli->acct[PLI_PASS_5P_AND_3P_ANY].pos_output;
	}
	else { /* no truncated hits were allowed */
	  n_output_trunc   = 0;
	  pos_output_trunc = 0;
	}
	fprintf(ofp, "Total CM hits reported:                            %15d  (%.4g); includes %d truncated hit(s)\n",
	    (int) pli_acct->n_output,
	    (nres_searched == 0) ? 0.0 : (double) (pli_acct->pos_output + pos_output_trunc) / nres_searched,
	    (int) n_output_trunc);
  }
  else {
	fprintf(ofp, "Total %37s        %15d  (%.4g)\n",
	    (pli->be_verbose) ? pli_describe_hits_for_pass(pass_idx) : "",
	    (int) pli_acct->n_output,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_output / nres_searched);
  }

  if(pli->be_verbose) {
	 fprintf(ofp, "\n");
	 if(nwin_fcyk > 0) {
	   fprintf(ofp, "%-6s filter stage scan matrix overflows:         %15" PRId64 "  (%.4g)\n",
	       "CYK",
	       pli_acct->n_overflow_fcyk,
	       (double) pli_acct->n_overflow_fcyk / (double) nwin_fcyk);
	 }
	 else {
	   fprintf(ofp, "%-6s filter stage scan matrix overflows:         %15d  (%.4g)\n",
	       "CYK",
	       0, 0.);
	 }
	 if(nwin_final > 0) {
	   fprintf(ofp, "%-6s final  stage scan matrix overflows:         %15" PRId64 "  (%.4g)\n",
	       (pli->final_cm_search_opts & CM_SEARCH_INSIDE) ? "Inside" : "CYK",
	       pli_acct->n_overflow_final,
	       (double) pli_acct->n_overflow_final / (double) nwin_final);
	 }
	 else {
	   fprintf(ofp, "%-6s final  stage scan matrix overflows:         %15d  (%.4g)\n",
	       (pli->final_cm_search_opts & CM_SEARCH_INSIDE) ? "Inside" : "CYK",
	       0, 0.);
	 }
  }

  return eslOK;
}

/* Function:  pli_hmmonly_pass_statistics()
 * Synopsis:  Final stats output for HMM only pass of a pipeline.
 * Incept:    EPN, Fri Sep 24 16:48:06 2010
 *            SRE, Tue Dec  9 10:19:45 2008 [Janelia] (p7_pli_Statistics())
 *
 * Purpose:   Print a standardized report of the internal statistics of
 *            a finished processing pipeline <pli> for HMM only passes
 *            to stream <ofp>.
 *
 * Returns:   <eslOK> on success.
 */
int
pli_hmmonly_pass_statistics(FILE *ofp, CM_PIPELINE *pli)
{
  CM_PLI_ACCT *pli_acct = &(pli->acct[PLI_PASS_HMM_ONLY_ANY]);
  int match_cm_spacing = (pli->nmodels > 0) ? TRUE : FALSE;
  int64_t nres_searched = pli_acct->nres_top + pli_acct->nres_bot;

  if(pli->do_hmmonly_always) {
	fprintf(ofp, "Internal HMM-only pipeline statistics summary: (--hmmonly used)\n");
	fprintf(ofp, "---------------------------------------------------------------\n");
  }
  else {
	fprintf(ofp, "Internal HMM-only pipeline statistics summary: (run for model(s) with zero basepairs)\n");
	fprintf(ofp, "--------------------------------------------------------------------------------------\n");
  }

  if (pli->mode == CM_SEARCH_SEQS) {
	fprintf(ofp,   "Query model(s):                            %s%15" PRId64 "  (%" PRId64 " consensus positions)\n",
	    match_cm_spacing ? "       "  : "",
	    pli->nmodels_hmmonly, pli->nnodes_hmmonly);
	fprintf(ofp,   "Target sequences:                          %s%15" PRId64 "  (%" PRId64 " residues searched)\n",
	    match_cm_spacing ? "        "  : "",
	    pli->nseqs, nres_searched);
  } else { /* SCAN MODE */
	fprintf(ofp,   "Query sequence(s):                         %s%15" PRId64 "  (%d residues searched)\n",
	    match_cm_spacing ? "        "  : "",
	    pli->nseqs,   (int) (nres_searched / pli->nmodels_hmmonly));
	fprintf(ofp,   "Target model(s):                           %s%15" PRId64 "  (%" PRId64 " consensus positions)\n",
	    match_cm_spacing ? "        "  : "",
	    pli->nmodels_hmmonly, pli->nnodes_hmmonly);
  }

  fprintf(ofp, "Windows %spassing %slocal HMM SSV      %sfilter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	  match_cm_spacing ? "  "     : "",
	  match_cm_spacing ? " "      : "",
	  match_cm_spacing ? "     "  : "",
	  pli_acct->n_past_msv,
	  (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_msv / nres_searched,
	  pli->F1_hmmonly);

  if(pli->do_bias_hmmonly) {
	fprintf(ofp, "Windows %spassing %slocal HMM MSV %sbias filter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    match_cm_spacing ? "  "      : "",
	    match_cm_spacing ? " "       : "",
	    match_cm_spacing ? "     "   : "",
	    pli_acct->n_past_msvbias,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_msvbias / nres_searched,
	    pli->F1_hmmonly);
  }
  else { /* msv bias is off by default, so don't output anything if it's off */
	fprintf(ofp, "Windows %spassing %slocal HMM MSV %sbias filter: %15s  (off)\n",
	    match_cm_spacing ? "  "      : "",
	    match_cm_spacing ? " "       : "",
	    match_cm_spacing ? "     "   : "",
	    "");
  }

  if(! pli->do_max_hmmonly) {
	fprintf(ofp, "Windows %spassing %slocal HMM Viterbi  %sfilter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    match_cm_spacing ? "  "     : "",
	    match_cm_spacing ? " "      : "",
	    match_cm_spacing ? "     "  : "",
	    pli_acct->n_past_vit,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_vit / nres_searched,
	    pli->F2_hmmonly);
  }
  else {
	fprintf(ofp, "Windows %spassing %slocal HMM Viterbi  %sfilter: %15s  (off)\n",
	    match_cm_spacing ? "  "     : "",
	    match_cm_spacing ? " "      : "",
	    match_cm_spacing ? "     "  : "",
	    "");
  }

  if(! pli->do_max_hmmonly) {
	fprintf(ofp, "Windows %spassing %slocal HMM Forward  %sfilter: %15" PRId64 "  (%.4g); expected (%.4g)\n",
	    match_cm_spacing ? "  "     : "",
	    match_cm_spacing ? " "      : "",
	    match_cm_spacing ? "     "  : "",
	    pli_acct->n_past_fwd,
	    (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_past_fwd / nres_searched,
	    pli->F3_hmmonly);
  }
  else {
	fprintf(ofp, "Windows %spassing %slocal HMM Forward  %sfilter: %15s  (off)\n",
	    match_cm_spacing ? "  "     : "",
	    match_cm_spacing ? " "      : "",
	    match_cm_spacing ? "     "  : "",
	    "");
  }

  fprintf(ofp, "Total HMM hits reported:                   %s%15d  (%.4g)\n",
	  match_cm_spacing ? "        "  : "",
	  (int) pli_acct->n_output,
	  (nres_searched == 0) ? 0.0 : (double) pli_acct->pos_output / nres_searched);

  return eslOK;
}

/* Function:  pli_sum_statistics()
 * Synopsis:  Sum up pipeline statistics for all CM passes of a pipeline.
 * Incept:    EPN, Thu Feb 23 11:00:39 2012
 *
 * Purpose:   Sum stats for all relevant passes in a pipeline
 *            and store them in pli->acct[PLI_PASS_CM_SUMMED].
 *
 * Returns:   <eslOK> on success.
 */
int
pli_sum_statistics(CM_PIPELINE *pli)
{
  int p; /* counter over passes */

  /* first zero out pli->acct[PLI_PASS_CM_SUMMED] */
  cm_pli_ZeroAccounting(&(pli->acct[PLI_PASS_CM_SUMMED]));

  /* now tally up counts for all passes we performed, we use
   * pli->acct[p].nres_top > 0 or pli->acct[p].nres_bot as indicator
   * pass was performed for at least one model.
   */
  for(p = 1; p < NPLI_PASSES; p++) {
	if(p == PLI_PASS_HMM_ONLY_ANY) continue; /* skip HMM only stage */
	if(pli->acct[p].nres_top > 0 || pli->acct[p].nres_bot > 0) {
	  pli->acct[PLI_PASS_CM_SUMMED].npli_top          += pli->acct[p].npli_top;
	  pli->acct[PLI_PASS_CM_SUMMED].npli_bot          += pli->acct[p].npli_bot;
	  pli->acct[PLI_PASS_CM_SUMMED].nres_top          += pli->acct[p].nres_top;
	  pli->acct[PLI_PASS_CM_SUMMED].nres_bot          += pli->acct[p].nres_bot;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_msv        += pli->acct[p].n_past_msv;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_vit        += pli->acct[p].n_past_vit;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_fwd        += pli->acct[p].n_past_fwd;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_gfwd       += pli->acct[p].n_past_gfwd;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_edef       += pli->acct[p].n_past_edef;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_cyk        += pli->acct[p].n_past_cyk;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_ins        += pli->acct[p].n_past_ins;
	  pli->acct[PLI_PASS_CM_SUMMED].n_output          += pli->acct[p].n_output;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_msvbias    += pli->acct[p].n_past_msvbias;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_vitbias    += pli->acct[p].n_past_vitbias;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_fwdbias    += pli->acct[p].n_past_fwdbias;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_gfwdbias   += pli->acct[p].n_past_gfwdbias;
	  pli->acct[PLI_PASS_CM_SUMMED].n_past_edefbias   += pli->acct[p].n_past_edefbias;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_msv      += pli->acct[p].pos_past_msv;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_vit      += pli->acct[p].pos_past_vit;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_fwd      += pli->acct[p].pos_past_fwd;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_gfwd     += pli->acct[p].pos_past_gfwd;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_edef     += pli->acct[p].pos_past_edef;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_cyk      += pli->acct[p].pos_past_cyk;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_ins      += pli->acct[p].pos_past_ins;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_output        += pli->acct[p].pos_output;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_msvbias  += pli->acct[p].pos_past_msvbias;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_vitbias  += pli->acct[p].pos_past_vitbias;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_fwdbias  += pli->acct[p].pos_past_fwdbias;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_gfwdbias += pli->acct[p].pos_past_gfwdbias;
	  pli->acct[PLI_PASS_CM_SUMMED].pos_past_edefbias += pli->acct[p].pos_past_edefbias;

	  pli->acct[PLI_PASS_CM_SUMMED].n_overflow_fcyk   += pli->acct[p].n_overflow_fcyk;
	  pli->acct[PLI_PASS_CM_SUMMED].n_overflow_final  += pli->acct[p].n_overflow_final;
	  pli->acct[PLI_PASS_CM_SUMMED].n_aln_hb          += pli->acct[p].n_aln_hb;
	  pli->acct[PLI_PASS_CM_SUMMED].n_aln_dccyk       += pli->acct[p].n_aln_dccyk;
	}
  }
  return eslOK;
}

/* Function:  cm_pli_ZeroAccounting()
 * Synopsis:  Zero a set of pipeline accounting statistics.
 * Incept:    EPN, Mon Nov 28 18:40:00 2011
 *
 * Returns:   <eslOK> on success.
 */
int
cm_pli_ZeroAccounting(CM_PLI_ACCT *pli_acct)
{
  pli_acct->npli_top          = 0;
  pli_acct->npli_bot          = 0;
  pli_acct->nres_top          = 0;
  pli_acct->nres_bot          = 0;
  pli_acct->n_past_msv        = 0;
  pli_acct->n_past_vit        = 0;
  pli_acct->n_past_fwd        = 0;
  pli_acct->n_past_gfwd       = 0;
  pli_acct->n_past_edef       = 0;
  pli_acct->n_past_cyk        = 0;
  pli_acct->n_past_ins        = 0;
  pli_acct->n_output          = 0;
  pli_acct->n_past_msvbias    = 0;
  pli_acct->n_past_vitbias    = 0;
  pli_acct->n_past_fwdbias    = 0;
  pli_acct->n_past_gfwdbias   = 0;
  pli_acct->n_past_edefbias   = 0;
  pli_acct->pos_past_msv      = 0;
  pli_acct->pos_past_vit      = 0;
  pli_acct->pos_past_fwd      = 0;
  pli_acct->pos_past_gfwd     = 0;
  pli_acct->pos_past_edef     = 0;
  pli_acct->pos_past_cyk      = 0;
  pli_acct->pos_past_ins      = 0;
  pli_acct->pos_output        = 0;
  pli_acct->pos_past_msvbias  = 0;
  pli_acct->pos_past_vitbias  = 0;
  pli_acct->pos_past_fwdbias  = 0;
  pli_acct->pos_past_gfwdbias = 0;
  pli_acct->pos_past_edefbias = 0;

  pli_acct->n_overflow_fcyk   = 0;
  pli_acct->n_overflow_final  = 0;
  pli_acct->n_aln_hb          = 0;
  pli_acct->n_aln_dccyk       = 0;

  return eslOK;
}

/* Function:  cm_pli_PassEnforcesFirstRes()
 * Date:      EPN, Thu Feb 16 07:42:59 2012
 *
 * Purpose:   Return TRUE if the pipeline pass indicated by
 *            <pass_idx> forces the inclusion of i0 (first
 *            residue in the sequence) in any valid
 *            parsetree/alignment. Else returns FALSE.
 *
 * Args:      pass_idx - a pipeline pass index:
 *                       PLI_PASS_CM_SUMMED | PLI_PASS_STD_ANY | PLI_PASS_5P_ONLY_FORCE |
 *                       PLI_PASS_3P_ONLY_FORCE | PLI_PASS_5P_AND_3P_FORCE | PLI_PASS_HMM_ONLY_ANY
 *
 * Returns:   TRUE if i0 inclusion is forced, FALSE if not
 */
int
cm_pli_PassEnforcesFirstRes(int pass_idx)
{
  switch (pass_idx) {
  case PLI_PASS_STD_ANY:         return FALSE; break;
  case PLI_PASS_5P_ONLY_FORCE:   return TRUE;  break;
  case PLI_PASS_3P_ONLY_FORCE:   return FALSE; break;
  case PLI_PASS_5P_AND_3P_FORCE: return TRUE;  break;
  case PLI_PASS_5P_AND_3P_ANY:   return FALSE; break;
  case PLI_PASS_HMM_ONLY_ANY:    return FALSE; break;
  default:                       return FALSE; break;
  }
  return FALSE;
}

/* Function:  cm_pli_PassEnforcesFinalRes()
 * Date:      EPN, Thu Feb 16 07:46:10 2012
 *
 * Purpose:   Return TRUE if the pipeline pass indicated by
 *            <pass_idx> forces the inclusion of j0 (final
 *            residue in the sequence) in any valid
 *            parsetree/alignment. Else returns FALSE.
 *
 * Args:      pass_idx - a pipeline pass index
 *                       PLI_PASS_CM_SUMMED | PLI_PASS_STD_ANY | PLI_PASS_5P_ONLY_FORCE |
 *                       PLI_PASS_3P_ONLY_FORCE | PLI_PASS_5P_AND_3P_FORCE | PLI_PASS_HMM_ONLY_ANY
 *
 * Returns:   TRUE if j0 inclusion is forced, FALSE if not
 */
int
cm_pli_PassEnforcesFinalRes(int pass_idx)
{
  switch (pass_idx) {
  case PLI_PASS_STD_ANY:         return FALSE; break;
  case PLI_PASS_5P_ONLY_FORCE:   return FALSE; break;
  case PLI_PASS_3P_ONLY_FORCE:   return TRUE;  break;
  case PLI_PASS_5P_AND_3P_FORCE: return TRUE;  break;
  case PLI_PASS_5P_AND_3P_ANY:   return FALSE; break;
  case PLI_PASS_HMM_ONLY_ANY:    return FALSE; break;
  default:                       return FALSE; break;
  }
  return FALSE;
}

/* Function:  cm_pli_PassAllowsTruncation()
 * Date:      EPN, Wed Mar 14 13:53:30 2012
 *
 * Purpose:   Return TRUE if the pipeline pass indicated by <pass_idx>
 *            allows some type of truncated alignment, else return
 *            FALSE.  In other words, if we can safely call a standard
 *            (non-truncated) DP alignment/search function for this
 *            pass then return FALSE, else return TRUE.
 *
 * Args:      pass_idx - a pipeline pass index
 *                       PLI_PASS_CM_SUMMED | PLI_PASS_STD_ANY | PLI_PASS_5P_ONLY_FORCE |
 *                       PLI_PASS_3P_ONLY_FORCE | PLI_PASS_5P_AND_3P_FORCE | PLI_PASS_HMM_ONLY_ANY
 *
 * Returns:   TRUE if j0 inclusion is forced, FALSE if not
 */
int
cm_pli_PassAllowsTruncation(int pass_idx)
{
  switch (pass_idx) {
  case PLI_PASS_STD_ANY:         return FALSE; break;
  case PLI_PASS_5P_ONLY_FORCE:   return TRUE;  break;
  case PLI_PASS_3P_ONLY_FORCE:   return TRUE;  break;
  case PLI_PASS_5P_AND_3P_FORCE: return TRUE;  break;
  case PLI_PASS_5P_AND_3P_ANY:   return TRUE;  break;
  case PLI_PASS_HMM_ONLY_ANY:    return FALSE; break;
  default:                       return FALSE; break;
  }
  return FALSE;
}

/* Function:  cm_pli_AdjustNresForOverlaps()
 * Incept:    EPN, Wed Nov 19 09:20:17 2014
 *
 * Purpose:  Update <nres_top> or <nres_bot> values in a CM_PIPELINE
 *           <pli> to account for overlapping windows from previous pipeline
 *           passes. Only certain passes are affected, all others can
 *           never search overlaps. If <in_rc> is TRUE we adjust <nres_bot>,
 *           else we adjust <nres_top>.
 *
 * Returns: void.
 */
void
cm_pli_AdjustNresForOverlaps(CM_PIPELINE *pli, int64_t noverlap, int in_rc)
{
  if(in_rc) {
	if(! pli->do_hmmonly_cur)                   pli->acct[PLI_PASS_STD_ANY].nres_bot       -= noverlap;
	else                                        pli->acct[PLI_PASS_HMM_ONLY_ANY].nres_bot  -= noverlap;
	if(pli->do_trunc_any || pli->do_trunc_only) pli->acct[PLI_PASS_5P_AND_3P_ANY].nres_bot -= noverlap;
  }
  else {
	if(! pli->do_hmmonly_cur)                   pli->acct[PLI_PASS_STD_ANY].nres_top       -= noverlap;
	else                                        pli->acct[PLI_PASS_HMM_ONLY_ANY].nres_top  -= noverlap;
	if(pli->do_trunc_any || pli->do_trunc_only) pli->acct[PLI_PASS_5P_AND_3P_ANY].nres_top -= noverlap;
  }
  return;
}

/*------------------- end, pipeline API -------------------------*/

/*****************************************************************
 * 3. Non-API filter stage search and other functions
 *****************************************************************/

/* Function:  pli_p7_filter()
 * Synopsis:  The accelerated p7 comparison pipeline: MSV through Forward filter.
 * Incept:    EPN, Wed Nov 24 13:07:02 2010
 *            TJW, Fri Feb 26 10:17:53 2018 [Janelia] (p7_Pipeline_Longtargets())
 *
 * Purpose:   Run the accelerated pipeline to compare profile <om>
 *            against sequence <sq>. Some combination of the MSV,
 *            Viterbi and Forward algorithms are used, based on
*             option flags set in <pli>.
 *
 *            In a normal pipeline run, this function call is the
 *            first search function used and should be followed by a
 *            call to pli_p7_env_def().
 *
 * Returns:   <eslOK> on success. For the <ret_nwin> windows that
 *            survive all filters, the start and end positions of the
 *            windows are stored and returned in <ret_ws> and
 *            <ret_we> respectively.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 *            <eslERANGE> on numerical overflow errors in the
 *            optimized vector implementations; particularly in
 *            posterior decoding. I don't believe this is possible for
 *            multihit local models, but I'm set up to catch it
 *            anyway. We may emit a warning to the user, but cleanly
 *            skip the problematic sequence and continue.
 *
 * Throws:    <eslEMEM> on allocation failure.
 *
 * Xref:      J4/25.
 */
int
pli_p7_filter(CM_PIPELINE *pli, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, P7_SCOREDATA *msvdata, const ESL_SQ *sq, int64_t **ret_ws, int64_t **ret_we, float **ret_wb, int *ret_nwin)
{
  int               status;
  float             mfsc, vfsc, fwdsc; /* filter scores          */
  float             filtersc;          /* HMM null filter score  */
  int               have_filtersc;     /* TRUE if filtersc has been calc'ed for current window */
  float             nullsc;            /* null model score */
  float             wsc;               /* the corrected bit score for a window */
  double            P;                 /* P-value of a hit */
  int               i, i2;             /* counters */
  int               wlen;              /* length of current window */
  void             *p;                 /* for ESL_RALLOC */
  int              *useme = NULL;      /* used when merging overlapping windows */
  int               overlap;           /* number of overlapping positions b/t 2 adjacent windows */
  int             **survAA = NULL;     /* [0..s..Np7_SURV-1][0..i..nwin-1] TRUE if window i survived stage s */
  int               nalloc;            /* currently allocated size for ws, we */
  int64_t          *ws = NULL;         /* [0..nwin-1] window start positions */
  int64_t          *we = NULL;         /* [0..nwin-1] window end   positions */
  double           *wp = NULL;         /* [0..nwin-1] window P-value   of furthest-reached filter alg, not valid until Vit (invalid for F1, F1b) */
  float            *wb = NULL;         /* [0..nwin-1] window bit score of furthest-reached filter alg, not valid until Vit (invalid for F1, F1b) */
  int               nwin;              /* number of windows */
  int64_t          *new_ws = NULL;     /* used when copying/modifying ws */
  int64_t          *new_we = NULL;     /* used when copying/modifying we */
  float            *new_wb = NULL;     /* used when copying/modifying wb */
  int               nsurv_fwd;         /* number of windows that survive fwd filter */
  ESL_DSQ          *subdsq;            /* a ptr to the first position of a window */
  int               have_rest;         /* do we have the full <om> read in? */
  P7_HMM_WINDOWLIST wlist;             /* list of windows, structure taken by p7_MSVFilter_longtarget() */
  int               save_max_length = om->max_length;

  /* filter thresholds and on/off parameters, these will normally be set to
   * CM pipeline values unless pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY,
   * in which case they're set to HMM only pipeline values.
   */
  int    cur_do_msv     = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? TRUE                    : pli->do_msv;
  int    cur_do_msvbias = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? pli->do_bias_hmmonly    : pli->do_msvbias;
  int    cur_do_vit     = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? (! pli->do_max_hmmonly) : pli->do_vit;
  int    cur_do_vitbias = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? FALSE                   : pli->do_vitbias;
  int    cur_do_fwd     = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? (! pli->do_max_hmmonly) : pli->do_fwd;
  int    cur_do_fwdbias = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? FALSE                   : pli->do_fwdbias;
  double cur_F1         = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? pli->F1_hmmonly         : pli->F1;
  double cur_F1b        = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? pli->F1_hmmonly         : pli->F1b;
  double cur_F2         = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? pli->F2_hmmonly         : pli->F2;
  double cur_F2b        = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? 1.0                     : pli->F2b;
  double cur_F3         = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? pli->F3_hmmonly         : pli->F3;
  double cur_F3b        = (pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY) ? 1.0                     : pli->F3b;

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */
  p7_omx_GrowTo(pli->oxf, om->M, 0, sq->n);    /* expand the one-row omx if needed */
  have_rest = (om->mode == p7_NO_MODE) ? FALSE : TRUE; /* we use om->mode as a flag to tell us whether we already have read the full <om> from disk or not */

  /* Set false target length. This is a conservative estimate of the length of window that'll
   * soon be passed on to later phases of the pipeline;  used to recover some bits of the score
   * that we would miss if we left length parameters set to the full target length */

  /* Set MSV length as pli->maxW/
   * Note: this differs from nhmmer, which uses om->max_length
   */
  p7_oprofile_ReconfigMSVLength(om, pli->maxW);
  om->max_length = pli->maxW;

  #if eslDEBUGLEVEL >= 3
  printf("\nPIPELINE pli_p7_filter() %s  %" PRId64 " residues\n", sq->name, sq->n);
  #endif

  /* initializations */
  nsurv_fwd = 0;
  nwin = 0;

  /***************************************************/
  /* Filter 1: SSV, long target-variant, with p7 HMM */
  if(cur_do_msv) {
	p7_hmmwindow_init(&wlist);
	status = p7_SSVFilter_longtarget(sq->dsq, sq->n, om, pli->oxf, msvdata, bg, cur_F1, &wlist);

	if(wlist.count > 0) {
	  /* In scan mode, if at least one window passes the MSV filter, read the rest of the profile */
	  if (pli->mode == CM_SCAN_MODELS && (! have_rest)) {
	if (pli->cmfp) p7_oprofile_ReadRest(pli->cmfp->hfp, om);
	/* Note: we don't call cm_pli_NewModelThresholds() yet (as p7_pipeline()
	 * does at this point), because we don't yet have the CM */
	have_rest = TRUE;
	  }
	  if(msvdata->prefix_lengths == NULL && msvdata->suffix_lengths == NULL) {
	p7_hmm_ScoreDataComputeRest(om, msvdata);
	/* only call *ComputeRest() if we haven't already (we may have
	 * already in a previous pipeline pass).
	 */
	  }
	  p7_pli_ExtendAndMergeWindows(om, msvdata, &wlist, 0.0);
	}
	ESL_ALLOC(ws, sizeof(int64_t) * ESL_MAX(1, wlist.count));  // avoid 0 malloc
	ESL_ALLOC(we, sizeof(int64_t) * ESL_MAX(1, wlist.count));
	nwin = wlist.count;
	for(i = 0; i < nwin; i++) {
	  ws[i] =         wlist.windows[i].n;
	  we[i] = ws[i] + wlist.windows[i].length - 1;
	}
	/* split up windows > (2 * pli->cmW) into length 2W, with W-1
	 * overlapping residues.
	 */
	nalloc = nwin + 100;
	ESL_ALLOC(new_ws, sizeof(int64_t) * nalloc);
	ESL_ALLOC(new_we, sizeof(int64_t) * nalloc);
	for (i = 0, i2 = 0; i < nwin; i++, i2++) {
	  wlen = we[i] - ws[i] + 1;
	  if((i2+1) == nalloc) {
	nalloc += 100;
	ESL_RALLOC(new_ws, p, sizeof(int64_t) * nalloc);
	ESL_RALLOC(new_we, p, sizeof(int64_t) * nalloc);
	  }
	  if(wlen > (2 * pli->cmW)) {
	/* split this window */
	new_ws[i2]   = ws[i];
	new_we[i2]   = ESL_MIN((new_ws[i2] + (2 * pli->cmW) - 1), we[i]);
	while(new_we[i2] < we[i]) {
	  i2++;
	  if((i2+1) == nalloc) {
	    nalloc += 100;
	    ESL_RALLOC(new_ws, p, sizeof(int64_t) * nalloc);
	    ESL_RALLOC(new_we, p, sizeof(int64_t) * nalloc);
	  }
	  new_ws[i2]   = ESL_MIN(new_ws[i2-1] + pli->cmW, we[i]);
	  new_we[i2]   = ESL_MIN(new_we[i2-1] + pli->cmW, we[i]);
	}
	  }
	  else { /* do not split this window */
	new_ws[i2] = ws[i];
	new_we[i2] = we[i];
	  }
	}
	free(wlist.windows);
	free(ws);
	free(we);
	ws = new_ws;
	we = new_we;
	nwin = i2;
  }
  else { /* do_msv is FALSE */
	nwin = 1; /* first window */
	if(sq->n > (2 * pli->maxW)) {
	  nwin += (int) (sq->n - (2 * pli->maxW)) / ((2 * pli->maxW) - (pli->maxW - 1));
	  /*            (L     -  first window)/(number of unique residues per window) */
	  if(((sq->n - (2 * pli->maxW)) % ((2 * pli->maxW) - (pli->maxW - 1))) > 0) {
	nwin++; /* if the (int) cast in previous line removed any fraction of a window, we add it back here */
	  }
	}
	ESL_ALLOC(ws,     sizeof(int64_t) * nwin);
	ESL_ALLOC(we,     sizeof(int64_t) * nwin);
	for(i = 0; i < nwin; i++) {
	  ws[i] = 1 + (i * (pli->maxW + 1));
	  we[i] = ESL_MIN((ws[i] + (2*pli->maxW) - 1), sq->n);
	  /*printf("window %5d/%5d  %10" PRId64 "..%10" PRId64 " (L=%10" PRId64 ")\n", i+1, nwin, ws[i], we[i], sq->n);*/
	}
  }
  pli->acct[pli->cur_pass_idx].n_past_msv += nwin;

  /*********************************************/
  /* allocate and initialize survAA, which will keep track of number of windows surviving each stage */
  ESL_ALLOC(survAA, sizeof(int *) * Np7_SURV);
  for (i = 0; i < Np7_SURV; i++) {
	ESL_ALLOC(survAA[i], sizeof(int) * ESL_MAX(1, nwin)); // avoid 0 mallocs
	esl_vec_ISet(survAA[i], nwin, FALSE);
  }

  ESL_ALLOC(wp, sizeof(double) * ESL_MAX(1, nwin));  // avoid 0 mallocs
  ESL_ALLOC(wb, sizeof(float)  * ESL_MAX(1, nwin));
  for (i = 0; i < nwin; i++) { wp[i] = 1.0;    }
  for (i = 0; i < nwin; i++) { wb[i] = -999.0; }

  for (i = 0; i < nwin; i++) {
	subdsq = sq->dsq + ws[i] - 1;
	have_filtersc = FALSE;
	wlen = we[i] - ws[i] + 1;

	p7_bg_SetLength(bg, wlen);
	p7_bg_NullOne  (bg, subdsq, wlen, &nullsc);

#if eslDEBUGLEVEL >= 3
	if(cur_do_msv) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived SSV       ? bits ? P\n", i, ws[i], we[i]);
#endif
	survAA[p7_SURV_F1][i] = TRUE;

	if (cur_do_msv && cur_do_msvbias) {
	  /******************************************************************************/
	  /* Filter 1B: Bias filter with p7 HMM
	   * Have to run msv again, to get the full score for the window.
	   * (using the standard "per-sequence" msv filter this time).
	   */
	  p7_oprofile_ReconfigMSVLength(om, wlen);
	  p7_MSVFilter(subdsq, wlen, om, pli->oxf, &mfsc);
	  p7_bg_FilterScore(bg, subdsq, wlen, &filtersc);
	  have_filtersc = TRUE;

	  wsc = (mfsc - filtersc) / eslCONST_LOG2;
	  P   = esl_gumbel_surv(wsc,  p7_evparam[CM_p7_LMMU],  p7_evparam[CM_p7_LMLAMBDA]);
	  wp[i] = P;

	  if (P > cur_F1b) continue;

	  /******************************************************************************/
	}

	pli->acct[pli->cur_pass_idx].n_past_msvbias++;
	survAA[p7_SURV_F1b][i] = TRUE;

#if eslDEBUGLEVEL >= 3
	if(cur_do_msv && cur_do_msvbias) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived MSV-Bias  ? bits  P ?\n", i, ws[i], we[i]);
#endif
	if(pli->do_time_F1) return eslOK;

	/* In scan mode, we may get to this point and not yet have read the rest of
	 * the profile if the msvfilter is off, if so read the rest of the profile.
	 */
	if (pli->mode == CM_SCAN_MODELS && (! have_rest)) {
	  if (pli->cmfp) p7_oprofile_ReadRest(pli->cmfp->hfp, om);
	  /* Note: we don't call cm_pli_NewModelThresholds() yet (as p7_pipeline()
	   * does at this point), because we don't yet have the CM */
	  have_rest = TRUE;
	}
	if(cur_do_msv && cur_do_msvbias) { /* we already called p7_oprofile_ReconfigMSVLength() above */
	  p7_oprofile_ReconfigRestLength(om, wlen);
	}
	else { /* we did not call p7_oprofile_ReconfigMSVLength() above */
	  p7_oprofile_ReconfigLength(om, wlen);
	}

	if (cur_do_vit) {
	  /******************************************************************************/
	  /* Filter 2: Viterbi with p7 HMM */
	  /* Second level filter: ViterbiFilter(), multihit with <om> */
	  p7_ViterbiFilter(subdsq, wlen, om, pli->oxf, &vfsc);
	  wsc   = (vfsc - nullsc) / eslCONST_LOG2;
	  P     = esl_gumbel_surv(wsc,  p7_evparam[CM_p7_LVMU],  p7_evparam[CM_p7_LVLAMBDA]);
	  wp[i] = P;
	  wb[i] = wsc;
	  if (P > cur_F2) continue;
	}
	pli->acct[pli->cur_pass_idx].n_past_vit++;
	survAA[p7_SURV_F2][i] = TRUE;

#if eslDEBUGLEVEL >= 3
	if (cur_do_vit) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived Vit       %6.2f bits  P %g\n", i, ws[i], we[i], wb[i], wp[i]);
#endif

	/********************************************/
	if (cur_do_vit && cur_do_vitbias) {
	  if(! have_filtersc) {
	p7_bg_FilterScore(bg, subdsq, wlen, &filtersc);
	  }
	  have_filtersc = TRUE;
	  wsc = (vfsc - filtersc) / eslCONST_LOG2;
	  P = esl_gumbel_surv(wsc,  p7_evparam[CM_p7_LVMU],  p7_evparam[CM_p7_LVLAMBDA]);
	  wp[i] = P;
	  wb[i] = wsc;
	  if (P > cur_F2b) continue;
	  /******************************************************************************/
	}
	pli->acct[pli->cur_pass_idx].n_past_vitbias++;
	survAA[p7_SURV_F2b][i] = TRUE;

#if eslDEBUGLEVEL >= 3
	if (cur_do_vit && cur_do_vitbias) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived Vit-Bias  %6.2f bits  P %g\n", i, ws[i], we[i], wb[i], wp[i]);
#endif
	if(pli->do_time_F2) continue;
	/********************************************/

	if(cur_do_fwd) {
	  /******************************************************************************/
	  /* Filter 3: Forward with p7 HMM */
	  /* Parse it with Forward and obtain its real Forward score. */
	  p7_ForwardParser(subdsq, wlen, om, pli->oxf, &fwdsc);
	  wsc = (fwdsc - nullsc) / eslCONST_LOG2;
	  P = esl_exp_surv(wsc,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	  wp[i] = P;
	  wb[i] = wsc;
	  if (P > cur_F3) continue;
	}
	/******************************************************************************/
	pli->acct[pli->cur_pass_idx].n_past_fwd++;
	survAA[p7_SURV_F3][i] = TRUE;

#if eslDEBUGLEVEL >= 3
	if(cur_do_fwd) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived Fwd       %6.2f bits  P %g\n", i, ws[i], we[i], wb[i], wp[i]);
#endif

	if (cur_do_fwd && cur_do_fwdbias) {
	  if (! have_filtersc) {
	p7_bg_FilterScore(bg, subdsq, wlen,     &filtersc);
	  }
	  have_filtersc = TRUE;
	  wsc = (fwdsc - filtersc) / eslCONST_LOG2;
	  P = esl_exp_surv(wsc,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	  wp[i] = P;
	  wb[i] = wsc;
	  if (P > cur_F3b) continue;
	  /******************************************************************************/
	}
	pli->acct[pli->cur_pass_idx].n_past_fwdbias++;
	nsurv_fwd++;
	survAA[p7_SURV_F3b][i] = TRUE;

#if eslDEBUGLEVEL >= 3
	if(cur_do_fwd && cur_do_fwdbias) printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived Fwd-Bias  %6.2f bits  P %g\n", i, ws[i], we[i], wb[i], wp[i]);
#endif
  }

  /* Go back through all windows, and tally up total number of
   * residues that survived each stage, without double-counting
   * overlapping residues. Based on the way the windows were split, we
   * know that any overlapping residues must occur in adjacent windows
   * and we exploit that here.
   */
  for(i = 0; i < nwin; i++) {
	wlen = we[i] - ws[i] + 1;

	if(survAA[p7_SURV_F1][i])  pli->acct[pli->cur_pass_idx].pos_past_msv     += wlen;
	if(survAA[p7_SURV_F1b][i]) pli->acct[pli->cur_pass_idx].pos_past_msvbias += wlen;
	if(survAA[p7_SURV_F2][i])  pli->acct[pli->cur_pass_idx].pos_past_vit     += wlen;
	if(survAA[p7_SURV_F2b][i]) pli->acct[pli->cur_pass_idx].pos_past_vitbias += wlen;
	if(survAA[p7_SURV_F3][i])  pli->acct[pli->cur_pass_idx].pos_past_fwd     += wlen;
	if(survAA[p7_SURV_F3b][i]) pli->acct[pli->cur_pass_idx].pos_past_fwdbias += wlen;

	/* now subtract residues we've double counted */
	if(i > 0) {
	  overlap = we[i-1] - ws[i] + 1;
	  if(overlap > 0) {
	if(survAA[p7_SURV_F1][i]  && survAA[p7_SURV_F1][i-1])  pli->acct[pli->cur_pass_idx].pos_past_msv     -= overlap;
	if(survAA[p7_SURV_F1b][i] && survAA[p7_SURV_F1b][i-1]) pli->acct[pli->cur_pass_idx].pos_past_msvbias -= overlap;
	if(survAA[p7_SURV_F2][i]  && survAA[p7_SURV_F2][i-1])  pli->acct[pli->cur_pass_idx].pos_past_vit     -= overlap;
	if(survAA[p7_SURV_F2b][i] && survAA[p7_SURV_F2b][i-1]) pli->acct[pli->cur_pass_idx].pos_past_vitbias -= overlap;
	if(survAA[p7_SURV_F3][i]  && survAA[p7_SURV_F3][i-1])  pli->acct[pli->cur_pass_idx].pos_past_fwd     -= overlap;
	if(survAA[p7_SURV_F3b][i] && survAA[p7_SURV_F3b][i-1]) pli->acct[pli->cur_pass_idx].pos_past_fwdbias -= overlap;
	  }
	}
  }

  /* Finally, create list of just those that survived fwd, and merge any overlapping windows together */
  if(nsurv_fwd > 0) {
	ESL_ALLOC(new_ws, sizeof(int64_t) * nsurv_fwd);
	ESL_ALLOC(new_we, sizeof(int64_t) * nsurv_fwd);
	ESL_ALLOC(new_wb, sizeof(float) * nsurv_fwd);
	for (i = 0, i2 = 0; i < nwin; i++) {
	  if(survAA[p7_SURV_F3b][i]) {
	new_ws[i2] = ws[i];
	new_we[i2] = we[i];
		new_wb[i2] = wb[i];
	i2++;
	  }
	}
	/* we could have overlapping windows, merge those that do overlap */
	ESL_ALLOC(useme, sizeof(int) * nsurv_fwd);
	esl_vec_ISet(useme, nsurv_fwd, FALSE);
	i2 = 0;
	for(i = 0, i2 = 0; i < nsurv_fwd; i++) {
	  useme[i] = TRUE;
	  i2 = i+1;
	  while((i2 < nsurv_fwd) && ((new_we[i]+1) >= (new_ws[i2]))) {
	useme[i2] = FALSE;
	new_we[i] = new_we[i2]; /* merged i with i2, rewrite end for i */
		new_wb[i] = ESL_MAX(new_wb[i], new_wb[i2]); /* keep higher score */
	i2++;
	  }
	  i = i2-1;
	}
	i2 = 0;
	for(i = 0; i < nsurv_fwd; i++) {
	  if(useme[i]) {
	new_ws[i2] = new_ws[i];
	new_we[i2] = new_we[i];
		new_wb[i2] = new_wb[i];
	i2++;
	  }
	}
	nsurv_fwd = i2;
	free(useme);
	free(ws); ws = NULL;
	free(we); we = NULL;
	free(wp); wp = NULL;
	free(wb); wb = NULL;
	ws = new_ws;
	we = new_we;
	wb = new_wb;
  } /* end of 'if(nsurv_fwd > 0)' */
  else {
	if(ws != NULL) free(ws); ws = NULL;
	if(we != NULL) free(we); we = NULL;
	if(wp != NULL) free(wp); wp = NULL;
	if(wb != NULL) free(wb); wb = NULL;
  }

  if(survAA != NULL) {
	for (i = 0; i < Np7_SURV; i++) free(survAA[i]);
	free(survAA);
  }

  om->max_length = save_max_length;

  *ret_ws   = ws;
  *ret_we   = we;
  *ret_wb   = wb;
  *ret_nwin = nsurv_fwd;

  return eslOK;

 ERROR:
  ESL_EXCEPTION(eslEMEM, "Error allocating memory for hit list in pipeline\n");

}

/* Function:  pli_p7_env_def()
 * Synopsis:  Envelope definition of hits surviving Forward, prior to passing to CYK.
 * Incept:    EPN, Wed Nov 24 13:18:54 2010
 *
 * Purpose:   For each window x, from <ws[x]>..<we[x]>, determine
 *            the envelope boundaries for any hits within it using
 *            a p7 profile.
 *
 *            In the SCAN pipeline we may enter this function with
 *            *opt_gm == NULL because we haven't yet read it from the
 *            HMM file. In that case, read it and return it in
 *            <*opt_gm>.  Otherwise, <*opt_gm> is valid upon entering.
 *
 *            If the P-value of any detected envelopes is sufficiently
 *            high (above pli->F5), we skip them (i.e. envelope defn
 *            acts as a filter too). Further, in glocal mode
 *            (<do_glocal>==TRUE) we skip any window for which the
 *            glocal Forward P-value is too high (above pli->F4).
 *
 *            In a normal pipeline run, this function call should be
 *            just after a call to pli_p7_filter() and just
 *            before a call to pli_cyk_env_filter().
 *
 *            If pli->cur_pass_idx == PLI_PASS_HMM_ONLY_ANY,
 *            <opt_esc> and <opt_ead> will be non-NULL and will be
 *            filled with HMM hit scores and P7_ALIDISPLAYS
 *            respectively, else they'll be NULL.

 * Returns:   <eslOK on success. For all <ret_nenv> envelopes not
 *            filtered out, return their envelope boundaries in
 *            <ret_es> and <ret_ee>.
 *
 * Throws:    <eslEMEM> on allocation failure.
 *            <eslENOTFOUND> if we need but don't have an HMM file to read
 *            <eslESYS> on failure of system call when reading HMM
 */
int
pli_p7_env_def(CM_PIPELINE *pli, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, const ESL_SQ *sq, int64_t *ws, int64_t *we, int nwin,
	       P7_HMM **opt_hmm, P7_PROFILE **opt_gm, P7_PROFILE **opt_Rgm, P7_PROFILE **opt_Lgm, P7_PROFILE **opt_Tgm, int64_t **ret_es, int64_t **ret_ee, float **ret_eb, int *ret_nenv)
{
  int              status;
  double           P;                 /* P-value of a hit */
  int              d, i;              /* counters */
  void            *p;                 /* for ESL_RALLOC */
  int              env_len;           /* envelope length */
  float            env_sc;            /* envelope bit score, and null1 score */
  float            sc_for_pvalue;     /* score for window, used for calc'ing P value */
  float            env_edefbias;      /* null2 correction for envelope */
  float            env_sc_for_pvalue; /* corrected score for envelope, used for calc'ing P value */
  int64_t          wlen;              /* window length of current window */
  int64_t         *es  = NULL;        /* [0..nenv-1] envelope start positions */
  int64_t         *ee  = NULL;        /* [0..nenv-1] envelope end   positions */
  float           *eb  = NULL;        /* [0..nenv-1] envelope end   positions */
  int              nenv;              /* number of surviving envelopes */
  int              nenv_alloc;        /* current size of es, ee */
  ESL_DSQ         *subdsq;            /* a ptr to the first position of a window */
  ESL_SQ          *seq = NULL;        /* a copy of a window */
  float            nullsc, filtersc, fwdsc, bcksc;
  P7_PROFILE      *gm  = NULL;        /* a ptr to *opt_gm, for convenience */
  int              do_local_envdef;   /* TRUE if we define envelopes with p7 in local mode, FALSE for glocal */

  /* variables related to forcing first and/or final residue within truncated hits */
  P7_PROFILE      *Rgm = NULL;        /* a ptr to *Ropt_gm, for convenience */
  P7_PROFILE      *Lgm = NULL;        /* a ptr to *Lopt_gm, for convenience */
  P7_PROFILE      *Tgm = NULL;        /* a ptr to *Topt_gm, for convenience */
  float            safe_lfwdsc;       /* a score <= local Forward score, determined via a correction to a Forward score with Rgm or Lgm */
  int              use_gm, use_Rgm, use_Lgm, use_Tgm; /* only one of these can be TRUE, should we use the standard profile for non
						       * truncated hits or the specially configured T, R, or L profiles because
						       * we're defining envelopes for hits possibly truncated 5', 3' or both 5' and 3'?
						       */
  float            Rgm_correction;    /* nat score correction for windows and envelopes defined with Rgm */
  float            Lgm_correction;    /* nat score correction for windows and envelopes defined with Lgm */

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */
  if (nwin == 0) {
	*ret_es = NULL;
	*ret_ee = NULL;
	*ret_eb = NULL;
	*ret_nenv = 0;
	return eslOK;    /* if there's no windows to search in, return */
  }

  /* Will we use local envelope definition? Only if we're in the
   * special pipeline pass where we allow any truncated hits (only
   * possibly true if pli->do_trunc_any or pli->do_trunc_only is TRUE).
   */
  do_local_envdef = (pli->cur_pass_idx == PLI_PASS_5P_AND_3P_ANY) ? TRUE : FALSE;

  nenv_alloc = nwin;
  ESL_ALLOC(es, sizeof(int64_t) * ESL_MAX(1, nenv_alloc)); // avoid 0 malloc
  ESL_ALLOC(ee, sizeof(int64_t) * ESL_MAX(1, nenv_alloc));
  ESL_ALLOC(eb, sizeof(float)   * ESL_MAX(1, nenv_alloc));
  nenv = 0;
  seq = esl_sq_CreateDigital(sq->abc);

#if eslDEBUGLEVEL >= 3
  printf("\nPIPELINE p7EnvelopeDef() %s  %" PRId64 " residues\n", sq->name, sq->n);
#endif

  /* determine which generic model we'll need to use based on which pass we're in */
  use_gm = use_Tgm = use_Rgm = use_Lgm = FALSE; /* one of these is set to TRUE below if nec */
  if(! do_local_envdef) {
	switch(pli->cur_pass_idx) {
	case PLI_PASS_STD_ANY:          use_gm = TRUE; break;
	case PLI_PASS_5P_ONLY_FORCE:   use_Rgm = TRUE; break;
	case PLI_PASS_3P_ONLY_FORCE:   use_Lgm = TRUE; break;
	case PLI_PASS_5P_AND_3P_FORCE: use_Tgm = TRUE; break;
	default: ESL_FAIL(eslEINVAL, pli->errbuf, "pli_p7_env_def() invalid pass index");
	}
  }

  /* If we're in SCAN mode and we don't yet have the generic model we
   * need, read the HMM and create it.
   */
  if (pli->mode == CM_SCAN_MODELS &&
	  ((use_gm  == TRUE && (*opt_gm)  == NULL) ||
	   (use_Rgm == TRUE && (*opt_Rgm) == NULL) ||
	   (use_Lgm == TRUE && (*opt_Lgm) == NULL) ||
	   (use_Tgm == TRUE && (*opt_Tgm) == NULL))) {
	if((*opt_hmm) == NULL) {
	  /* read the HMM from the file */
	  if (pli->cmfp      == NULL) ESL_FAIL(eslENOTFOUND, pli->errbuf, "No file available to read HMM from in pli_p7_env_def()");
	  if (pli->cmfp->hfp == NULL) ESL_FAIL(eslENOTFOUND, pli->errbuf, "No file available to read HMM from in pli_p7_env_def()");
	  if((status = cm_p7_hmmfile_Read(pli->cmfp, pli->abc, om->offs[p7_MOFFSET], opt_hmm)) != eslOK) ESL_FAIL(status, pli->errbuf, "%s", pli->cmfp->errbuf);
	}

	if((*opt_gm) == NULL) { /* we need gm to create Lgm, Rgm or Tgm */
	  *opt_gm = p7_profile_Create((*opt_hmm)->M, pli->abc);
	  p7_ProfileConfig(*opt_hmm, bg, *opt_gm, 100, p7_GLOCAL);
	}
	if(use_Rgm && (*opt_Rgm == NULL)) {
	  *opt_Rgm = p7_profile_Clone(*opt_gm);
	  p7_ProfileConfig5PrimeTrunc(*opt_Rgm, 100);
	}
	if(use_Lgm && (*opt_Lgm == NULL)) {
	  *opt_Lgm = p7_profile_Clone(*opt_gm);
	  p7_ProfileConfig3PrimeTrunc(*opt_hmm, *opt_Lgm, 100);
	}
	if(use_Tgm && (*opt_Tgm == NULL)) {
	  *opt_Tgm = p7_profile_Clone(*opt_gm);
	  p7_ProfileConfig(*opt_hmm, bg, *opt_Tgm, 100, p7_LOCAL);
	  p7_ProfileConfig5PrimeAnd3PrimeTrunc(*opt_Tgm, 100);
	}
  }
  gm  = *opt_gm;
  Rgm = *opt_Rgm;
  Lgm = *opt_Lgm;
  Tgm = *opt_Tgm;

  for (i = 0; i < nwin; i++) {
#if eslDEBUGLEVEL >= 3
	printf("p7 envdef win: %4d of %4d [%6" PRId64 "..%6" PRId64 "] pass: %" PRId64 "\n", i, nwin, ws[i], we[i], pli->cur_pass_idx);
#endif
	/* if we require first or final residue, and don't have it, then
	 * this window doesn't survive.
	 */
	if(cm_pli_PassEnforcesFirstRes(pli->cur_pass_idx) && ws[i] != 1)     continue;
	if(cm_pli_PassEnforcesFinalRes(pli->cur_pass_idx) && we[i] != sq->n) continue;

	wlen   = we[i]   - ws[i] + 1;
	subdsq = sq->dsq + ws[i] - 1;

	/* set up seq object for domaindef function */
	esl_sq_GrowTo(seq, wlen);
	memcpy((void*)(seq->dsq), subdsq, (wlen+1) * sizeof(uint8_t));
	seq->dsq[0] = seq->dsq[wlen+1] = eslDSQ_SENTINEL;
	seq->n = wlen;

	p7_bg_SetLength(bg, wlen);
	p7_bg_NullOne(bg, seq->dsq, wlen, &nullsc);

	if(do_local_envdef) {
	  /* Local envelope defn: we can use optimized matrices and,
	   * consequently, p7_domaindef_ByPosteriorHeuristics().
	   */
	  p7_oprofile_ReconfigLength(om, wlen);
	  p7_ForwardParser(seq->dsq, wlen, om, pli->oxf, NULL);
	  p7_omx_GrowTo(pli->oxb, om->M, 0, wlen);
	  p7_BackwardParser(seq->dsq, wlen, om, pli->oxf, pli->oxb, NULL);
	  status = p7_domaindef_ByPosteriorHeuristics (seq, NULL, om, pli->oxf, pli->oxb, pli->fwd, pli->bck, pli->ddef, bg, /*long_target=*/FALSE,
						   /*bg_tmp=*/NULL, /*scores_arr=*/NULL, /*fwd_emissions_arr=*/NULL);
	}
	else {
	  /* We're defining envelopes in glocal mode, so we need to fill
	   * generic fwd/bck matrices and pass them to
	   * p7_domaindef_GlocalByPosteriorHeuristics(), but we have to do
	   * this differently depending on which pass we're in
	   * (i.e. which type of *gm we're using).
	   */
	  if(use_Tgm) {
	/* no length reconfiguration necessary */
	p7_gmx_GrowTo(pli->gxf, Tgm->M, wlen);
	p7_GForward (seq->dsq, wlen, Tgm, pli->gxf, &fwdsc);
	/*printf("Tfwdsc: %.4f\n", fwdsc);*/
	/* We use local Fwd statistics to determine statistical
	 * significance of this score, it has already had basically a
	 * 1/log(M*(M+1)) penalty for equiprobable local begins and
	 * ends */
	sc_for_pvalue = (fwdsc - nullsc) / eslCONST_LOG2;
	P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	  }
	  else if(use_Rgm) {
	p7_ReconfigLength5PrimeTrunc(Rgm, wlen);
	p7_gmx_GrowTo(pli->gxf, Rgm->M, wlen);
	p7_GForward (seq->dsq, wlen, Rgm, pli->gxf, &fwdsc);
	/*printf("Rfwdsc: %.4f\n", fwdsc);*/
	/* We use local Fwd statistics to determine significance of
	 * the score. GForward penalized 0. for ends and log(1/Rgm->M)
	 * for begins into any state. No further correction is
	 * required because GForward already properly accounted for
	 * equiprobable begins and fixed ends out of node M.
	 */
	Rgm_correction = 0.;
	safe_lfwdsc = fwdsc + Rgm_correction;
	sc_for_pvalue = (safe_lfwdsc - nullsc) / eslCONST_LOG2;
	P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	  }
	  else if(use_Lgm) {
	p7_ReconfigLength3PrimeTrunc(Lgm, wlen);
	p7_gmx_GrowTo(pli->gxf, Lgm->M, wlen);
	p7_GForward (seq->dsq, wlen, Lgm, pli->gxf, &fwdsc);
	/*printf("Lfwdsc: %.4f\n", fwdsc);*/
	/* We use local Fwd statistics to determine significance of
	 * the score, but we need to correct for lack of equiprobable
	 * begins and ends in fwdsc. We correct for fact that local
	 * begins should be equiprobable.
	 */
	Lgm_correction = log(1./Lgm->M);
	safe_lfwdsc = fwdsc + Lgm_correction;
	sc_for_pvalue = (safe_lfwdsc - nullsc) / eslCONST_LOG2;
	P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	  }
	  else if(use_gm) { /* normal case, not looking for truncated hits */
	p7_ReconfigLength(gm, wlen);
	p7_gmx_GrowTo(pli->gxf, gm->M, wlen);
	p7_GForward (seq->dsq, wlen, gm, pli->gxf, &fwdsc);
	/*printf(" fwdsc: %.4f\n", fwdsc);*/
	sc_for_pvalue = (fwdsc - nullsc) / eslCONST_LOG2;
	P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_GFMU],  p7_evparam[CM_p7_GFLAMBDA]);
	  }

#if eslDEBUGLEVEL >= 3
	  if(P > pli->F4) {
	printf("KILLED   window %5d [%10" PRId64 "..%10" PRId64 "]          gFwd      %6.2f bits  P %g\n", i, ws[i], we[i], sc_for_pvalue, P);
	  }
#endif
	  /* Does this score exceed our glocal forward filter threshold? If not, move on to next seq */
	  if(P > pli->F4) continue;

	  pli->acct[pli->cur_pass_idx].n_past_gfwd++;
	  pli->acct[pli->cur_pass_idx].pos_past_gfwd += wlen;

#if eslDEBUGLEVEL >= 3
	  printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived gFwd      %6.2f bits  P %g\n", i, ws[i], we[i], sc_for_pvalue, P);
#endif

	  if(pli->do_gfwdbias) {
	/* calculate bias filter score for entire window */
	p7_bg_FilterScore(bg, seq->dsq, wlen, &filtersc);
	/* Once again, score and P-value determination depends on which
	 * *gm we're using (see F4 code block above for comments).
	 */
	if(use_Tgm) {
	  sc_for_pvalue = (fwdsc - filtersc) / eslCONST_LOG2;
	  P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	}
	else if(use_Rgm || use_Lgm) {
	  sc_for_pvalue = (safe_lfwdsc - nullsc) / eslCONST_LOG2;
	  P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_LFTAU],  p7_evparam[CM_p7_LFLAMBDA]);
	}
	else if(use_gm) { /* normal case */
	  sc_for_pvalue = (fwdsc - filtersc) / eslCONST_LOG2;
	  P = esl_exp_surv (sc_for_pvalue,  p7_evparam[CM_p7_GFMU],  p7_evparam[CM_p7_GFLAMBDA]);
	}
	if(P > pli->F4b) continue;
#if eslDEBUGLEVEL >= 3
	printf("SURVIVOR window %5d [%10" PRId64 "..%10" PRId64 "] survived gFwdBias  %6.2f bits  P %g\n", i, ws[i], we[i], sc_for_pvalue, P);
#endif
	pli->acct[pli->cur_pass_idx].n_past_gfwdbias++;
	pli->acct[pli->cur_pass_idx].pos_past_gfwdbias += wlen;
	  }
	  if(pli->do_time_F4) continue;
	  //if(pli->cur_pass_idx != PLI_PASS_STD_ANY) continue;
	  //if(pli->cur_pass_idx != PLI_PASS_5P_ONLY_FORCE) continue;
	  //if(pli->cur_pass_idx != PLI_PASS_3P_ONLY_FORCE) continue;
	  //if(pli->cur_pass_idx != PLI_PASS_5P_AND_3P_FORCE) continue;
	  //if(1) continue;

	  /* this block needs to match up with if..else if...else if...else block calling p7_GForward above */
	  if(use_Tgm) {
	/* no length reconfiguration necessary */
	p7_gmx_GrowTo(pli->gxb, Tgm->M, wlen);
	p7_GBackward(seq->dsq, wlen, Tgm, pli->gxb, &bcksc);
	if((status = p7_domaindef_GlocalByPosteriorHeuristics(seq, Tgm, pli->gxf, pli->gxb, pli->gfwd, pli->gbck, pli->ddef, pli->do_null2)) != eslOK) ESL_FAIL(status, pli->errbuf, "unexpected failure during glocal envelope defn");
	/*printf("Tbcksc: %.4f\n", bcksc);*/
	  }
	  else if(use_Rgm) {
	p7_gmx_GrowTo(pli->gxb, Rgm->M, wlen);
	p7_GBackward(seq->dsq, wlen, Rgm, pli->gxb, &bcksc);
	if((status = p7_domaindef_GlocalByPosteriorHeuristics(seq, Rgm, pli->gxf, pli->gxb, pli->gfwd, pli->gbck, pli->ddef, pli->do_null2)) != eslOK) ESL_FAIL(status, pli->errbuf, "unexpected failure during glocal envelope defn");;
	/*printf("Rbcksc: %.4f\n", bcksc);*/
	  }
	  else if(use_Lgm) {
	p7_gmx_GrowTo(pli->gxb, Lgm->M, wlen);
	p7_GBackward(seq->dsq, wlen, Lgm, pli->gxb, &bcksc);
	if((status = p7_domaindef_GlocalByPosteriorHeuristics(seq, Lgm, pli->gxf, pli->gxb, pli->gfwd, pli->gbck, pli->ddef, pli->do_null2)) != eslOK) ESL_FAIL(status, pli->errbuf, "unexpected failure during glocal envelope defn");
	/*printf("Lbcksc: %.4f\n", bcksc);*/
	  }
	  else { /* normal case, not looking for truncated hits */
	p7_gmx_GrowTo(pli->gxb, gm->M, wlen);
	p7_GBackward(seq->dsq, wlen, gm, pli->gxb, &bcksc);
	if((status = p7_domaindef_GlocalByPosteriorHeuristics(seq, gm, pli->gxf, pli->gxb, pli->gfwd, pli->gbck, pli->ddef, pli->do_null2)) != eslOK) ESL_FAIL(status, pli->errbuf, "unexpected failure during glocal envelope defn");
	/*printf(" bcksc: %.4f\n", bcksc);*/
	  }
	} /* end of 'else' entered if (! do_local_envdef) */

	if (status != eslOK) ESL_FAIL(status, pli->errbuf, "envelope definition workflow failure"); /* eslERANGE can happen */
	if (pli->ddef->nregions   == 0)  continue; /* score passed threshold but there's no discrete domains here       */
	if (pli->ddef->nenvelopes == 0)  continue; /* rarer: region was found, stochastic clustered, no envelopes found */

	/* For each domain found in the p7_domaindef_*() function, determine if it passes our criteria */
	for(d = 0; d < pli->ddef->ndom; d++) {

	  if(do_local_envdef) { /* we called p7_domaindef_ByPosteriorHeuristics() above, which fills pli->ddef->dcl[d].ad, but we don't need it */
	p7_alidisplay_Destroy(pli->ddef->dcl[d].ad);
	pli->ddef->dcl[d].ad = NULL;
	  }

	  env_len = pli->ddef->dcl[d].jenv - pli->ddef->dcl[d].ienv +1;
	  env_sc  = pli->ddef->dcl[d].envsc;

	  /* Make a correction to the score
	   * from hmmsearch's p7_pipeline():
	   * here is the p7_pipeline code, verbatim:
	   *  Ld = hit->dcl[d].jenv - hit->dcl[d].ienv + 1;
	   *  hit->dcl[d].bitscore = hit->dcl[d].envsc + (sq->n-Ld) * log((float) sq->n / (float) (sq->n+3));
	   *  hit->dcl[d].dombias  = (pli->do_null2 ? p7_FLogsum(0.0, log(bg->omega) + hit->dcl[d].domcorrection) : 0.0);
	   *  hit->dcl[d].bitscore = (hit->dcl[d].bitscore - (nullsc + hit->dcl[d].dombias)) / eslCONST_LOG2;
	   *  hit->dcl[d].pvalue   = esl_exp_surv (hit->dcl[d].bitscore,  om->evparam[p7_FTAU], om->evparam[p7_FLAMBDA]);
	   *
	   *  and here is the same code, simplified with our different names for the variables, etc
	   * (we don't use hit->dcl the way p7_pipeline does after this):  */
	  env_sc            = env_sc + (wlen - env_len) * log((float) wlen / (float) (wlen+3)); /* NATS, for the moment... */
	  env_edefbias      = pli->do_null2 ? p7_FLogsum(0.0, log(bg->omega) + pli->ddef->dcl[d].domcorrection) : 0.0; /* NATS, and will stay so */
	  env_sc_for_pvalue = (env_sc - (nullsc + env_edefbias)) / eslCONST_LOG2; /* now BITS, as it should be */

	  if(use_Rgm) env_sc_for_pvalue += Rgm_correction / eslCONST_LOG2; /* glocal env def penalized 0. for ends and log(1/Lgm->M) for begins into any state */
	  if(use_Lgm) env_sc_for_pvalue += Lgm_correction / eslCONST_LOG2; /* glocal env def penalized 0. for ends and 0. for begins into M1 */

	  if(do_local_envdef || use_Tgm || use_Rgm || use_Lgm) P = esl_exp_surv (env_sc_for_pvalue,  p7_evparam[CM_p7_LFTAU], p7_evparam[CM_p7_LFLAMBDA]);
	  else                                                 P = esl_exp_surv (env_sc_for_pvalue,  p7_evparam[CM_p7_GFMU],  p7_evparam[CM_p7_GFLAMBDA]);
	  /***************************************************/

	  /* check if we can skip this envelope based on its P-value */
	  if(P > pli->F5) {
	if(pli->ddef->dcl[d].ad) p7_alidisplay_Destroy(pli->ddef->dcl[d].ad);
	continue;
	  }

#if eslDEBUGLEVEL >= 3
	  printf("SURVIVOR envelope     [%10" PRId64 "..%10" PRId64 "] survived F5       %6.2f bits  P %g\n", pli->ddef->dcl[d].ienv + ws[i] - 1, pli->ddef->dcl[d].jenv + ws[i] - 1, env_sc_for_pvalue, P);
#endif
	  pli->acct[pli->cur_pass_idx].n_past_edef++;
	  pli->acct[pli->cur_pass_idx].pos_past_edef += env_len;

	  /* if we're doing a bias filter on envelopes - check if we skip envelope due to that */
	  if(pli->do_edefbias) {
	/* calculate bias filter score for entire window
	 * may want to test alternative strategies in the future.
	 */
	p7_bg_FilterScore(bg, seq->dsq, wlen, &filtersc);
	env_sc_for_pvalue = (env_sc - filtersc) / eslCONST_LOG2;

	if(use_Rgm) env_sc_for_pvalue += Rgm_correction / eslCONST_LOG2; /* glocal env def penalized 0. for ends and log(1/Lgm->M) for begins into any state */
	if(use_Lgm) env_sc_for_pvalue += Lgm_correction / eslCONST_LOG2; /* glocal env def penalized 0. for ends and 0. for begins into M1 */

	if(do_local_envdef || use_Tgm || use_Rgm || use_Lgm) P = esl_exp_surv (env_sc_for_pvalue,  p7_evparam[CM_p7_LFTAU], p7_evparam[CM_p7_LFLAMBDA]);
	else                                                 P = esl_exp_surv (env_sc_for_pvalue,  p7_evparam[CM_p7_GFMU],  p7_evparam[CM_p7_GFLAMBDA]);
	if(P > pli->F5b) {
	  if(pli->ddef->dcl[d].ad) p7_alidisplay_Destroy(pli->ddef->dcl[d].ad);
	  continue;
	}
	  }
#if eslDEBUGLEVEL >= 3
	  printf("SURVIVOR envelope     [%10" PRId64 "..%10" PRId64 "] survived F5-bias  %6.2f bits  P %g\n", pli->ddef->dcl[d].ienv + ws[i] - 1, pli->ddef->dcl[d].jenv + ws[i] - 1, env_sc_for_pvalue, P);
#endif
	  pli->acct[pli->cur_pass_idx].n_past_edefbias++;
	  pli->acct[pli->cur_pass_idx].pos_past_edefbias += env_len;

	  if(pli->do_time_F5) { continue; }

	  /* if we get here, the envelope has survived, add it to the growing list */
	  if((nenv+1) == nenv_alloc) {
	nenv_alloc *= 2;
	ESL_RALLOC(es, p, sizeof(int64_t) * nenv_alloc);
	ESL_RALLOC(ee, p, sizeof(int64_t) * nenv_alloc);
		ESL_RALLOC(eb, p, sizeof(float)   * nenv_alloc);
	  }
	  /* Define envelope to search with CM */
	  es[nenv] = pli->ddef->dcl[d].ienv + ws[i] - 1;
	  ee[nenv] = pli->ddef->dcl[d].jenv + ws[i] - 1;
	  eb[nenv] = env_sc_for_pvalue;
	  nenv++;
	}

	pli->ddef->ndom = 0; /* reset for next use */
  }

  /* clean up, set return variables, and return */
  if(seq != NULL) esl_sq_Destroy(seq);

  *ret_es   = es;
  *ret_ee   = ee;
  *ret_eb   = eb;
  *ret_nenv = nenv;

  return eslOK;

 ERROR:
  ESL_EXCEPTION(eslEMEM, "Error: out of memory");
}

/* Function:  pli_cyk_env_filter()
 * Synopsis:  Given envelopes defined by an HMM, use CYK as a filter.
 * Incept:    EPN, Thu Mar  1 12:03:09 2012
 *
 * Purpose:   For each envelope x, from <es[x]>..<ee[x]>, run
 *            CYK to see if any hits above threshold exist, if so
 *            the hit will survive the filter.
 *
 *            In a normal pipeline run, this function call should be
 *            just after a call to pli_p7_env_def().
 *
 *            This function is similar to pli_cyk_seq_filter(), but
 *            differs in that it takes as input envelope boundaries
 *            defined by an HMM as input, while cyk_seq_filter() takes
 *            as input full length sequences that have not been
 *            analyzed with an HMM.
 *
 *            If pli->mode is CM_SCAN_MODELS, it's possible that we
 *            haven't yet read our CM from the file. This is true when
 *            (*opt_cm == NULL). If so, we read the CM from the file
 *            after positioning it to position <cm_offset> and
 *            configure the CM after setting cm->config_opts to
 *            <pli->cm_config_opts>.
 *
 * Returns:   <eslOK> on success. If a significant hit is obtained,
 *            its information is added to the growing <hitlist>.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
pli_cyk_env_filter(CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, int64_t *p7es, int64_t *p7ee, int np7env, CM_t **opt_cm,
		    int64_t **ret_es, int64_t **ret_ee, int *ret_nenv)
{
  int              status;
  float            sc;                     /* bit score */
  double           P;                      /* P-value of a hit */
  int              i, si;                  /* counters */
  double           save_tau;               /* CM's tau upon entering function */
  int64_t          cyk_envi, cyk_envj;     /* cyk_envi..cyk_envj is new envelope as defined by CYK hits */
  float            cyk_env_cutoff;         /* bit score cutoff for envelope redefinition */
  CM_t            *cm = NULL;              /* ptr to *opt_cm, for convenience only */
  int              qdbidx;                 /* scan matrix qdb idx, defined differently for filter and final round */

  int             *i_surv = NULL;          /* [0..i..np7env-1], TRUE if hit i survived CYK filter, FALSE if not */
  int64_t          nenv = 0;               /* number of hits that survived CYK filter */
  int64_t         *es = NULL;              /* [0..si..nenv-1] start posn of surviving envelope si */
  int64_t         *ee = NULL;              /* [0..si..nenv-1] end   posn of surviving envelope si */

  if (sq->n == 0)  return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */
  if (np7env == 0) return eslOK;    /* if there's no envelopes to search in, return */

  ESL_ALLOC(i_surv, sizeof(int) * np7env);
  esl_vec_ISet(i_surv, np7env, FALSE);

  /* if we're in SCAN mode, and we don't yet have a CM, read it and configure it */
  if (pli->mode == CM_SCAN_MODELS && (*opt_cm == NULL)) {
	if((status = pli_scan_mode_read_cm(pli, cm_offset,
				       NULL, 0, /* p7_evparam, p7_max_length: irrelevant because pli->do_hmmonly_cur is FALSE */
				       opt_cm)) != eslOK) return status;
  }
  else { /* *opt_cm should be valid */
	if(opt_cm == NULL || *opt_cm == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "Entered pli_final_stage() with invalid CM");
  }
  cm = *opt_cm;
  save_tau = cm->tau;

  /* Determine bit score cutoff for CYK envelope redefinition, any
   * residue that exists in a CYK hit that reaches this threshold will
   * be included in the redefined envelope, any that doesn't will not
   * be.
   */
  cyk_env_cutoff = cm->expA[pli->fcyk_cm_exp_mode]->mu_extrap + (log(pli->F6env) / (-1 * cm->expA[pli->fcyk_cm_exp_mode]->lambda));

#if eslDEBUGLEVEL >= 3
  printf("\nPIPELINE EnvCYKFilter() %s  %" PRId64 " residues\n", sq->name, sq->n);
#endif

  for (i = 0; i < np7env; i++) {
#if eslDEBUGLEVEL >= 3
	printf("\nSURVIVOR Envelope %5d [%10ld..%10ld] being passed to EnvCYKFilter   pass: %" PRId64 "\n", i, p7es[i], p7ee[i], pli->cur_pass_idx);
#endif
	cm->search_opts  = pli->fcyk_cm_search_opts;
	cm->tau          = pli->fcyk_tau;
	qdbidx           = (cm->search_opts & CM_SEARCH_NONBANDED) ? SMX_NOQDB : SMX_QDB1_TIGHT;
	status = pli_dispatch_cm_search(pli, cm, sq->dsq, p7es[i], p7ee[i], NULL, 0., cyk_env_cutoff, qdbidx, &sc,
				    (pli->do_fcykenv) ? &cyk_envi : NULL,
				    (pli->do_fcykenv) ? &cyk_envj : NULL);

	if(status == eslERANGE) {
	  pli->acct[pli->cur_pass_idx].n_overflow_fcyk++;
	  continue; /* skip envelopes that would require too big of a HMM banded matrix */
	}
	else if(status != eslOK) return status;

	P = esl_exp_surv(sc, cm->expA[pli->fcyk_cm_exp_mode]->mu_extrap, cm->expA[pli->fcyk_cm_exp_mode]->lambda);

	if (P > pli->F6) continue;

	i_surv[i] = TRUE;
	nenv++;
	/* update envelope boundaries, if nec */
	if(pli->do_fcykenv && (cyk_envi != -1 && cyk_envj != -1)) {
	  p7es[i] = cyk_envi;
	  p7ee[i] = cyk_envj;
	}

#if eslDEBUGLEVEL >= 3
	printf("SURVIVOR envelope     [%10" PRId64 "..%10" PRId64 "] survived EnvCYKFilter       %6.2f bits  P %g\n", p7es[i], p7ee[i], sc, P);
#endif
  }
  /* create list of surviving envelopes */
  if(nenv > 0) {
	ESL_ALLOC(es, sizeof(int64_t) * nenv);
	ESL_ALLOC(ee, sizeof(int64_t) * nenv);
	si = 0;
	for(i = 0; i < np7env; i++) {
	  if(i_surv[i]) {
	es[si] = p7es[i];
	ee[si] = p7ee[i];
	pli->acct[pli->cur_pass_idx].n_past_cyk++;
	pli->acct[pli->cur_pass_idx].pos_past_cyk += ee[si] - es[si] + 1;
	si++;
	  }
	}
  }
  cm->tau = save_tau;
  if(i_surv != NULL) free(i_surv);
  *ret_es   = es;
  *ret_ee   = ee;
  *ret_nenv = nenv;

  return eslOK;

 ERROR:
  cm->tau = save_tau;
  if(i_surv != NULL) free(i_surv);
  if(es     != NULL) free(es);
  if(ee     != NULL) free(ee);
  *ret_es   = NULL;
  *ret_ee   = NULL;
  *ret_nenv = 0;
  ESL_FAIL(status, pli->errbuf, "out of memory");
}

/* Function:  pli_cyk_seq_filter()
 * Synopsis:  Given a sequence, use CYK as a filter and to define
 *            surviving windows.
 *
 * Incept:    EPN, Thu Mar  1 12:03:09 2012
 *
 * Purpose:   Run scanning CYK to see if any hits in <dsq> above
 *            threshold exist. Then append adjacent residues to
 *            all such hits, merge those that overlap, and return
 *            information on the number of resulting windows and
 *            the locations of those windows in <ret_nwin>, <ret_ws>
 *            and <ret_we>.
 *
 *            This function is only called in a pipeline run if
 *            HMMs were not used to define envelopes, so when used
 *            it is the first stage of the pipeline.
 *
 *            This function is similar to pli_cyk_env_filter(), but
 *            differs in that it takes as input a single full length
 *            sequences, while EnvCYKFilter takes as input envelopes
 *            defined by an HMM filter.
 *
 *            If pli->mode is CM_SCAN_MODELS, it's possible that we
 *            haven't yet read our CM from the file. This is true when
 *            (*opt_cm == NULL). If so, we read the CM from the file
 *            after positioning it to position <cm_offset> and
 *            configure the CM after setting cm->config_opts to
 *            <pli->cm_config_opts>.
 *
 * Returns:   <eslOK> on success. If a significant hit is obtained,
 *            its information is added to the growing <hitlist>.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
pli_cyk_seq_filter(CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, CM_t **opt_cm, int64_t **ret_ws, int64_t **ret_we, int *ret_nwin)
{
  int              status;
  float            sc;                     /* bit score */
  double           save_tau;               /* CM's tau upon entering function */
  float            cutoff;                 /* CYK bit score cutoff, anything above this survives */
  CM_t            *cm = NULL;              /* ptr to *opt_cm, for convenience only */
  int              qdbidx;                 /* scan matrix qdb idx, defined differently for filter and final round */
  CM_TOPHITS      *sq_hitlist = NULL;      /* hits found in sq, local to this function */
  int              do_merge;               /* TRUE to merge overlapping windows at end of function */
  int              h;                      /* counter over hits */

  int64_t          nwin = 0;               /* number of windows that survived CYK filter */
  int64_t         *ws = NULL;              /* [0..i..nwin-1] start posn of surviving window i */
  int64_t         *we = NULL;              /* [0..i..nwin-1] end   posn of surviving window i */
  int              alloc_size = 1000;      /* chunk size for allocating ws, we */
  int              nwin_alloc = 0;         /* current size of ws, we */
  int64_t          iwin, jwin;             /* start, stop positions of a window */
  int64_t          next_iwin;              /* start position of next window */

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */

  if(pli->fcyk_cm_search_opts & CM_SEARCH_HBANDED) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "pli_cyk_seq_filter() trying to use HMM bands");

  /* if we're in SCAN mode, and we don't yet have a CM, read it and configure it */
  if (pli->mode == CM_SCAN_MODELS && (*opt_cm == NULL)) {
	if((status = pli_scan_mode_read_cm(pli, cm_offset,
				       NULL, 0, /* p7_evparam, p7_max_length: irrelevant because pli->do_hmmonly_cur is FALSE */
				       opt_cm)) != eslOK) return status;
  }
  else { /* *opt_cm should be valid */
	if(opt_cm == NULL || *opt_cm == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "Entered pli_final_stage() with invalid CM");
  }
  cm = *opt_cm;

  cm->search_opts = pli->fcyk_cm_search_opts;
  save_tau        = cm->tau;
  cm->tau         = pli->fcyk_tau;
  qdbidx          = (cm->search_opts & CM_SEARCH_NONBANDED) ? SMX_NOQDB : SMX_QDB1_TIGHT;
  cutoff          = cm->expA[pli->fcyk_cm_exp_mode]->mu_extrap + (log(pli->F6) / (-1 * cm->expA[pli->fcyk_cm_exp_mode]->lambda));
  sq_hitlist      = cm_tophits_Create();
  status = pli_dispatch_cm_search(pli, cm, sq->dsq, 1, sq->n, sq_hitlist, cutoff, 0., qdbidx, &sc, NULL, NULL);
  if(status == eslERANGE) ESL_FAIL(status, pli->errbuf, "pli_cyk_seq_filter(), internal error, trying to use a HMM banded matrix");
  else if(status != eslOK) return status;

  /* To be safe, we only trust that start..stop of our filter-passing
   * hit is within the real hit, so we add (W-1) to start point i and
   * subtract (W-1) from j, and treat this region j-(W-1)..i+(W-1) as
   * having survived the filter.  And (unless we're using HMM bands in
   * the final stage) we merge overlapping hits following this
   * addition of residues.
   */

  do_merge = (pli->final_cm_search_opts & CM_SEARCH_HBANDED) ? FALSE : TRUE;
  if(do_merge) {
	/* sort hits by position, so we can merge them after padding out */
	cm_tophits_SortByPosition(sq_hitlist);
	/* any hits in sq_hitlist will be sorted by increasing end point j */
	/* cm_tophits_Dump(stdout, sq_hitlist); */
  }

  for(h = 0; h < sq_hitlist->N; h++) {
	if(sq_hitlist->hit[h]->stop < sq_hitlist->hit[h]->start) ESL_FAIL(eslEINVAL, pli->errbuf, "pli_cyk_seq_filter() internal error: hit is in revcomp");

	iwin = ESL_MAX(1,     sq_hitlist->hit[h]->stop  - (cm->W-1));
	jwin = ESL_MIN(sq->n, sq_hitlist->hit[h]->start + (cm->W-1));

#if eslDEBUGLEVEL >= 3
	double P = esl_exp_surv(sq_hitlist->hit[h]->score, cm->expA[pli->fcyk_cm_exp_mode]->mu_extrap, cm->expA[pli->fcyk_cm_exp_mode]->lambda);
	printf("SURVIVOR window       [%10" PRId64 "..%10" PRId64 "] survived SeqCYKFilter   %6.2f bits  P %g\n", iwin, jwin, sq_hitlist->hit[h]->score, P);
#endif

	if(do_merge) {
	  if((h+1) < sq_hitlist->N) {
	next_iwin = ((h+1) < sq_hitlist->N) ? ESL_MAX(1, sq_hitlist->hit[h+1]->stop - (cm->W-1)) : sq->n+1;
	while(next_iwin <= jwin) { /* merge hit h and h+1 */
	  h++;
	  jwin = ESL_MIN(sq->n, sq_hitlist->hit[h]->start + (cm->W-1));
	  /* printf("\t merging with hit %" PRId64 "..%" PRId64 "\n", next_iwin, jwin); */
	  next_iwin = ((h+1) < sq_hitlist->N) ? ESL_MAX(1, sq_hitlist->hit[h+1]->stop - (cm->W-1)) : sq->n+1;
	  /* if (h == tophits->N-1) (last hit) next_i will be set as sq->n+1, breaking the while() */
	}
	  }
	}

	if(nwin == nwin_alloc) {
	  nwin_alloc += alloc_size;
	  ESL_REALLOC(ws, sizeof(int64_t) * nwin_alloc);
	  ESL_REALLOC(we, sizeof(int64_t) * nwin_alloc);
	}
	ws[nwin] = iwin;
	we[nwin] = jwin;
	nwin++;

	pli->acct[pli->cur_pass_idx].n_past_cyk++;
	pli->acct[pli->cur_pass_idx].pos_past_cyk += jwin-iwin+1;
  }
  cm->tau = save_tau;

  if(sq_hitlist != NULL) cm_tophits_Destroy(sq_hitlist);
  *ret_ws   = ws;
  *ret_we   = we;
  *ret_nwin = nwin;

  return eslOK;

 ERROR:
  if(sq_hitlist != NULL) cm_tophits_Destroy(sq_hitlist);
  cm->tau = save_tau;
  *ret_ws   = NULL;
  *ret_we   = NULL;
  *ret_nwin = 0;
  ESL_FAIL(status, pli->errbuf, "out of memory");
}

/* Function:  pli_final_stage()
 * Synopsis:  Final stage of pipeline: Inside or CYK.
 * Incept:    EPN, Sun Nov 28 13:47:31 2010
 *
 * Purpose:   For each envelope x, from <es[x]>..<ee[x]>, run
 *            Inside or CYK for final hit definition.
 *
 *            In a normal pipeline run, this function call should be
 *            just after a call to pli_cyk_env_filter().
 *
 *            If pli->mode is CM_SCAN_MODELS, it's possible that we
 *            haven't yet read our CM from the file. This is true when
 *            (*opt_cm == NULL). If so, we read the CM from the file
 *            after positioning it to position <cm_offset> and
 *            configure the CM after setting cm->config_opts to
 *            <pli->cm_config_opts>.
 *
 * Returns:   <eslOK> on success. If a significant hit is obtained,
 *            its information is added to the growing <hitlist>.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
pli_final_stage(CM_PIPELINE *pli, off_t cm_offset, const ESL_SQ *sq, int64_t *es, int64_t *ee, int nenv, CM_TOPHITS *hitlist, CM_t **opt_cm)
{
  int              status;
  CM_HIT          *hit = NULL;        /* ptr to the current hit output data   */
  float            sc;                /* bit score */
  int              i, h;              /* counters */
  int              nhit;              /* number of hits reported */
  double           save_tau;          /* CM's tau upon entering function */
  CM_t            *cm = NULL;         /* ptr to *opt_cm, for convenience only */
  CP9Bands_t      *scan_cp9b = NULL;  /* a copy of the HMM bands derived in the final CM search stage, if its HMM banded */
  int              qdbidx;            /* scan matrix qdb idx, defined differently for filter and final round */

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */
  if (nenv == 0)  return eslOK;    /* if there's no envelopes to search in, return */

  /* if we're in SCAN mode, and we don't yet have a CM, read it and configure it */
  if (pli->mode == CM_SCAN_MODELS && (*opt_cm == NULL)) {
	if((status = pli_scan_mode_read_cm(pli, cm_offset,
				       NULL, 0, /* p7_evparam, p7_max_length: irrelevant because pli->do_hmmonly_cur is FALSE */
				       opt_cm)) != eslOK) return status;
  }
  else { /* *opt_cm should be valid */
	if(opt_cm == NULL || *opt_cm == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "Entered pli_final_stage() with invalid CM");
  }
  cm = *opt_cm;
  save_tau = cm->tau;

  for (i = 0; i < nenv; i++) {
#if eslDEBUGLEVEL >= 3
	printf("\nSURVIVOR Envelope %5d [%10ld..%10ld] being passed to Final stage   pass: %" PRId64 "\n", i, es[i], ee[i], pli->cur_pass_idx);
#endif
	nhit             = hitlist->N;
	cm->search_opts  = pli->final_cm_search_opts;
	cm->tau          = pli->final_tau;
	qdbidx           = (cm->search_opts & CM_SEARCH_NONBANDED) ? SMX_NOQDB : SMX_QDB2_LOOSE;
	status = pli_dispatch_cm_search(pli, cm, sq->dsq, es[i], ee[i], hitlist, pli->T, 0., qdbidx, &sc, NULL, NULL);
	if(status == eslERANGE) {
	  pli->acct[pli->cur_pass_idx].n_overflow_final++;
	  continue; /* skip envelopes that would require too big a HMM banded matrix */
	}
	else if(status != eslOK) return status;

	/* if we used HMM bands during the final search stage, save a copy
	 * of them, we'll use it to align any hits above threshold below.
	 */
	if(cm->search_opts & CM_SEARCH_HBANDED) {
	  scan_cp9b = cp9_CloneBands(cm->cp9b, pli->errbuf);
	  if(scan_cp9b == NULL) return eslEMEM;
#if eslDEBUGLEVEL >= 1
	  if((status = cp9_ValidateBands(cm, pli->errbuf, cm->cp9b, es[i], ee[i], cm_pli_PassAllowsTruncation(pli->cur_pass_idx))) != eslOK) return status;
	  ESL_DPRINTF1(("original bands validated.\n"));
	  if((status = cp9_ValidateBands(cm, pli->errbuf, scan_cp9b, es[i], ee[i], cm_pli_PassAllowsTruncation(pli->cur_pass_idx))) != eslOK) return status;
	  ESL_DPRINTF1(("cloned bands validated.\n"));
#endif
	}
	else {
	  scan_cp9b = NULL;
	}

	/* add info to each hit DP scanning functions didn't have access to, and align the hits if nec */
	for (h = nhit; h < hitlist->N; h++) {
	  hit = &(hitlist->unsrt[h]);
	  hit->cm_idx   = pli->cur_cm_idx;
	  hit->clan_idx = pli->cur_clan_idx;
	  hit->seq_idx  = pli->cur_seq_idx;
	  hit->pass_idx = pli->cur_pass_idx;
	  hit->pvalue   = esl_exp_surv(hit->score, cm->expA[pli->final_cm_exp_mode]->mu_extrap, cm->expA[pli->final_cm_exp_mode]->lambda);
	  hit->srcL     = sq->L; /* this may be -1, in which case it will be updated by caller (cmsearch or cmscan) when full length is known */
	  hit->glocal   = (pli->final_cm_exp_mode == EXP_CM_GI || pli->final_cm_exp_mode == EXP_CM_GC) ? TRUE : FALSE;

	  /* initialize remaining values we don't know yet */
	  hit->evalue     = 0.;
	  hit->has_evalue = FALSE;
	  hit->ad         = NULL;

	  if (pli->mode == CM_SEARCH_SEQS) {
	if (                       (status  = esl_strdup(sq->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	if (sq->acc[0]  != '\0' && (status  = esl_strdup(sq->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
		if (sq->desc[0] != '\0' && (status  = esl_strdup(sq->desc, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  }
	  else {
	if ((status  = esl_strdup(cm->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	if ((status  = esl_strdup(cm->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
		if ((status  = esl_strdup(cm->desc, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  }
#if eslDEBUGLEVEL >= 3
	  printf("SURVIVOR envelope     [%10ld..%10ld] survived Inside    %6.2f bits  P %g\n", hit->start, hit->stop, hit->score, hit->pvalue);
#endif
	  /* Get an alignment of the hit.
	   */
	  /* check if we need to overwrite cm->cp9b with scan_cp9b
	   * because alignment of previous hit modified them in previous
	   * call to pli_align_hit().
	   */
	  if(h > nhit && scan_cp9b != NULL) {
	if(cm->cp9b != NULL) FreeCP9Bands(cm->cp9b);
	cm->cp9b = cp9_CloneBands(scan_cp9b, pli->errbuf);
	if(cm->cp9b == NULL) return status;
	  }
	  /*cm_hit_Dump(stdout, hit);*/

	  /* Before we create the hit alignment, we do a sanity check. If
	   * we used HMM bands in the final search stage, the hit
	   * alignment pli_align_hit() is about to do is expected to use
	   * those bands (they're in cm->cp9b). This should be true based
	   * on how the cm_pipeline_Create() function created the pipeline
	   * object. But since that's a complicated function thanks to the
	   * litany of command-line options that affect it, we do a check
	   * here to make sure.
	   */
	  if(scan_cp9b != NULL && (! (pli->cm_align_opts & CM_ALIGN_HBANDED))) {
	ESL_FAIL(eslEINVAL, pli->errbuf, "used HMM bands for Inside search stage, but won't for hit alignment, this shouldn't happen");
	  }
	  if(scan_cp9b == NULL && (pli->cm_align_opts & CM_ALIGN_HBANDED)) {
	ESL_FAIL(eslEINVAL, pli->errbuf, "did not use HMM bands for Inside search stage, but will for hit alignment, this shouldn't happen");
	  }
	  if((status = pli_align_hit(pli, cm, sq, hit)) != eslOK) return status;

	  /* Finally, if we're using model-specific bit score thresholds,
	   * determine if the significance of the hit (is it reported
	   * and/or included?)  Adapted from Sean's comments at an
	   * analogous point in p7_pipeline():
	   *
	   * If we're using model-specific bit score thresholds (GA | TC | NC)
	   * and we're in a cmscan pipeline (mode = CM_SCAN_MODELS), then we
	   * *must* apply those reporting or inclusion thresholds now, because
	   * this model is about to go away; we won't have its thresholds
	   * after all targets have been processed.
	   *
	   * If we're using E-value thresholds and we don't know the
	   * search space size (Z_setby == CM_ZSETBY_NTARGETS), we
	   * *cannot* apply those thresholds now, and we *must* wait
	   * until all targets have been processed (see cm_tophits_Threshold()).
	   *
	   * For any other thresholding, it doesn't matter whether we do
	   * it here (model-specifically) or at the end (in
	   * cm_tophits_Threshold()).
	   *
	   * What we actually do, then, is to set the flags if we're using
	   * model-specific score thresholds (regardless of whether we're
	   * in a scan or a search pipeline); otherwise we leave it to
	   * cm_tophits_Threshold(). cm_tophits_Threshold() is always
	   * responsible for *counting* the reported, included sequences.
	   *
	   * [xref J5/92]
	   */

	  if (pli->use_bit_cutoffs) {
	if (cm_pli_TargetReportable(pli, hit->score, hit->evalue)) { /* evalue is invalid, but irrelevant if pli->use_bit_cutoffs */
	  hit->flags |= CM_HIT_IS_REPORTED;
	  if (cm_pli_TargetIncludable(pli, hit->score, hit->evalue)) /* ditto */
	    hit->flags |= CM_HIT_IS_INCLUDED;
	}
	  }
	} /* end of 'for(h = nhit'... */
	if(scan_cp9b != NULL) {
	  FreeCP9Bands(scan_cp9b);
	  scan_cp9b = NULL;
	}
  } /* end of for each envelope loop */
  cm->tau = save_tau;
  /* free the scan matrices if we just allocated them */
  if(scan_cp9b != NULL) FreeCP9Bands(scan_cp9b);

  return eslOK;
}

/* Function:  pli_final_stage_hmmonly()
 * Synopsis:  Final stage of HMM only pipeline.
 * Incept:    EPN, Sun Nov 28 13:47:31 2010
 *
 * Purpose:   Each envelope x <es[x]>..<ee[x]> is a potential
 *            HMM hit with score <esc[x]> and P7_ALIDISPLAY <ead[x]>.
 *            Check if we should include it, and if so create a
 *            CM_HIT for it, and convert the P7_ALIDISPLAY to
 *            a CM_ALIDISPLAY.
 *
 *            This function is only called if we're doing a special
 *            HMM only version of the pipeline (i.e. pli->do_hmmonly
 *            is TRUE).
 *
 * Returns:   <eslOK> on success. If a significant hit is obtained,
 *            its information is added to the growing <hitlist>.
 *
 *            <eslEINVAL> if (in a scan pipeline) we're supposed to
 *            set GA/TC/NC bit score thresholds but the model doesn't
 *            have any.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
pli_final_stage_hmmonly(CM_PIPELINE *pli, off_t cm_offset, P7_OPROFILE *om, P7_BG *bg, float *p7_evparam, const ESL_SQ *sq, int64_t *ws, int64_t *we, int nwin, CM_TOPHITS *hitlist, CM_t **opt_cm)
{
  int              status;
  int              i, d;              /* counter over windows, domains */
  CM_HIT          *hit = NULL;        /* ptr to the current hit output data   */
  CM_t            *cm = NULL;         /* ptr to *opt_cm, for convenience only */
  ESL_DSQ         *subdsq;            /* a ptr to the first position of a window */
  ESL_SQ          *seq = NULL;        /* a copy of a window */
  int64_t          wlen;              /* window length of current window */
  int              env_len;           /* envelope length */
  float            nullsc;            /* null model score */
  float            avgpp;             /* average PP of emitted residues in a P7_ALIDISPLAY */

  /* variables necessary only for bit score correction if
   * pli->cur_pass_idx = PLI_PASS_HMM_ONLY_ANY that is analogous to
   * one nhmmer performs, (search for 'nhmmer score adjustment' in
   * comments below). I've named this variables identically to
   * analogous ones in p7_pipeline.c::postMSV_LongTarget() (as of
   * r3976).
   */
  int   ali_len;
  float bitscore;
  int   loc_window_length;
  int   window_len;
  float nullsc2;
  float dom_bias;
  float dom_score;

  if (sq->n == 0) return eslOK;    /* silently skip length 0 seqs; they'd cause us all sorts of weird problems */
  if (nwin == 0)  return eslOK;    /* if there's no windows, return */
  seq = esl_sq_CreateDigital(sq->abc);

  /* if we're in SCAN mode, and we don't yet have a CM, read it and configure it */
  if (pli->mode == CM_SCAN_MODELS && (*opt_cm == NULL)) {
	if((status = pli_scan_mode_read_cm(pli, cm_offset, p7_evparam, om->max_length, opt_cm)) != eslOK) return status;
  }
  else { /* *opt_cm should be valid */
	if(opt_cm == NULL || *opt_cm == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "Entered pli_final_stage() with invalid CM");
  }
  cm = *opt_cm;

 /* calculate nullsc2, this mimics nhmmer from
   * p7_pipeline:postMSV_LongTarget(), as of r3976.
   */
  loc_window_length = om->max_length;
  nullsc2           =  (float)loc_window_length * log((float)loc_window_length/(loc_window_length+1)) + log(1./(loc_window_length+1));

  for (i = 0; i < nwin; i++) {
#if eslDEBUGLEVEL >= 3
	printf("p7 final stage win: %4d of %4d [%6" PRId64 "..%6" PRId64 "] pass: %" PRId64 "\n", i, nwin, ws[i], we[i], pli->cur_pass_idx);
#endif

	wlen   = we[i]   - ws[i] + 1;
	subdsq = sq->dsq + ws[i] - 1;
	/* set up seq object for domaindef function */
	esl_sq_GrowTo(seq, wlen);
	memcpy((void*)(seq->dsq), subdsq, (wlen+1) * sizeof(uint8_t));
	seq->dsq[0] = seq->dsq[wlen+1] = eslDSQ_SENTINEL;
	seq->n = wlen;

	p7_bg_SetLength(bg, wlen);
	p7_bg_NullOne(bg, seq->dsq, wlen, &nullsc);

	/* Local envelope defn: we can use optimized matrices and,
	 * consequently, p7_domaindef_ByPosteriorHeuristics().
	 */
	p7_oprofile_ReconfigLength(om, wlen);
	p7_ForwardParser(seq->dsq, wlen, om, pli->oxf, NULL);
	p7_omx_GrowTo(pli->oxb, om->M, 0, wlen);
	p7_BackwardParser(seq->dsq, wlen, om, pli->oxf, pli->oxb, NULL);
	status = p7_domaindef_ByPosteriorHeuristics (seq, /*nt_seq=*/NULL, om, pli->oxf, pli->oxb, pli->fwd, pli->bck, pli->ddef, bg,  /*long_target=*/FALSE,
						 /*bg_tmp=*/NULL, /*scores_arr=*/NULL, /*fwd_emissions_arr=*/NULL);

	if (status != eslOK) ESL_FAIL(status, pli->errbuf, "envelope definition workflow failure"); /* eslERANGE can happen */
	if (pli->ddef->nregions   == 0)  continue; /* score passed threshold but there's no discrete domains here       */
	if (pli->ddef->nenvelopes == 0)  continue; /* rarer: region was found, stochastic clustered, no envelopes found */

	/* For each domain found in the p7_domaindef_*() function, determine if it passes our criteria */
	for(d = 0; d < pli->ddef->ndom; d++) {
	  /* make nhmmer score adjustment from p7_pipeline.c::postMSV_LongTarget() as of SVN r3976
	   * comments from relevant part of that function are below:
	   *
	   * note: the initial bitscore of a hit depends on the window_len of the
	   * current window. Here, the score is modified (reduced) by treating
	   * all passing windows as though they came from windows of length
	   * om->max_length. For details, see
	   * ~wheelert/notebook/2012/0130_bits_v_evalues/00NOTES (Feb 1)
	   *
	   * adjust the score of a hit to account for the full length model - the characters outside the envelope but in the window
	   * end of p7_pipeline.c comments
	   *
	   * I define variables with identical names to
	   * p7_pipeline.c::postMSV_LongTarget() to make it obvious that
	   * I'm doing exactly the same thing.
	   */
	  env_len = pli->ddef->dcl[d].jenv - pli->ddef->dcl[d].ienv + 1;
	  ali_len = pli->ddef->dcl[d].jali - pli->ddef->dcl[d].iali + 1;
	  bitscore = pli->ddef->dcl[d].envsc;
	  window_len = wlen;
	  /* For these modifications, see notes, ~/notebook/2010/0716_hmmer_score_v_eval_bug/, end of Thu Jul 22 13:36:49 EDT 2010 */
	  bitscore -= 2 * log(2. / (window_len+2))          +   (env_len-ali_len)            * log((float)window_len / (window_len+2));
	  bitscore += 2 * log(2. / (loc_window_length+2));
	  /* the ESL_MAX test handles the extremely rare case that the env_len is actually larger than om->max_length */
	  bitscore +=  (ESL_MAX(loc_window_length, env_len) - ali_len) * log((float)loc_window_length / (float) (loc_window_length+2));

	  dom_bias   = pli->do_null2_hmmonly ? p7_FLogsum(0.0, log(bg->omega) + pli->ddef->dcl[d].domcorrection) : 0.0;
	  dom_score  = (bitscore - (nullsc2 + dom_bias))  / eslCONST_LOG2;

	  if(dom_score >= pli->T) {
	cm_tophits_CreateNextHit(hitlist, &hit);
	/* We define hit start/stop based on P7_ALIDISPLAY
	 * sqfrom/sqto instead of envelope boundaries, to be consistent
	 * with non-hmmonly pipeline runs, CM hit start/stop always
	 * matches CM_ALIDISPLAY sqfrom/sqto.
	 */
	pli->ddef->dcl[d].ad->sqfrom += ws[i] - 1;
	pli->ddef->dcl[d].ad->sqto   += ws[i] - 1;
	hit->start    = pli->ddef->dcl[d].ad->sqfrom;
	hit->stop     = pli->ddef->dcl[d].ad->sqto;
	hit->root     = -1; /* irrelevant in HMM only hit */
	hit->mode     = TRMODE_J;
	hit->score    = dom_score;

	hit->cm_idx   = pli->cur_cm_idx;
	hit->clan_idx = pli->cur_clan_idx;
	hit->seq_idx  = pli->cur_seq_idx;
	hit->pass_idx = pli->cur_pass_idx;
	hit->pvalue   = esl_exp_surv (hit->score,  p7_evparam[CM_p7_LFTAU], p7_evparam[CM_p7_LFLAMBDA]);
	hit->srcL     = sq->L; /* this may be -1, in which case it will be updated by caller (cmsearch or cmscan) when full length is known */

	hit->hmmonly  = TRUE;
	hit->glocal   = FALSE; /* all HMM hits are local (currently) */
	hit->bias     = dom_bias;
	hit->evalue   = 0.; /* we'll redefine this later */

	/* create a CM_ALIDISPLAY from the P7_ALIDISPLAY */
	avgpp = pli->ddef->dcl[d].oasc / (1.0 + fabs((float) (pli->ddef->dcl[d].jenv - pli->ddef->dcl[d].ienv)));
	if((status = cm_alidisplay_CreateFromP7(cm, pli->errbuf, sq, hit->start, hit->score, avgpp, pli->ddef->dcl[d].ad, &(hit->ad))) != eslOK) return status;
	/* Free the P7_ALIDISPLAY */
	p7_alidisplay_Destroy(pli->ddef->dcl[d].ad);
	pli->ddef->dcl[d].ad = NULL;

#if eslDEBUGLEVEL >= 3
	printf("SURVIVOR envelope     [%10ld..%10ld] survived Final HMM ONLY stage    %6.2f bits  P %g\n", hit->start, hit->stop, hit->score, hit->pvalue);
#endif

	if (pli->mode == CM_SEARCH_SEQS) {
	  if (                       (status  = esl_strdup(sq->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  if (sq->acc[0]  != '\0' && (status  = esl_strdup(sq->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  if (sq->desc[0] != '\0' && (status  = esl_strdup(sq->desc, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	}
	else {
	  if ((status  = esl_strdup(cm->name, -1, &(hit->name)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  if ((status  = esl_strdup(cm->acc,  -1, &(hit->acc)))   != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	  if ((status  = esl_strdup(cm->desc, -1, &(hit->desc)))  != eslOK) ESL_FAIL(eslEMEM, pli->errbuf, "allocation failure");
	}
	/* Finally, if we're using model-specific bit score thresholds,
	 * determine if the significance of the hit (is it reported
	 * and/or included?)  Adapted from Sean's comments at an
	 * analogous point in p7_pipeline():
	 *
	 * If we're using model-specific bit score thresholds (GA | TC | NC)
	 * and we're in a cmscan pipeline (mode = CM_SCAN_MODELS), then we
	 * *must* apply those reporting or inclusion thresholds now, because
	 * this model is about to go away; we won't have its thresholds
	 * after all targets have been processed.
	 *
	 * If we're using E-value thresholds and we don't know the
	 * search space size (Z_setby == CM_ZSETBY_NTARGETS), we
	 * *cannot* apply those thresholds now, and we *must* wait
	 * until all targets have been processed (see cm_tophits_Threshold()).
	 *
	 * For any other thresholding, it doesn't matter whether we do
	 * it here (model-specifically) or at the end (in
	 * cm_tophits_Threshold()).
	 *
	 * What we actually do, then, is to set the flags if we're using
	 * model-specific score thresholds (regardless of whether we're
	 * in a scan or a search pipeline); otherwise we leave it to
	 * cm_tophits_Threshold(). cm_tophits_Threshold() is always
	 * responsible for *counting* the reported, included sequences.
	 *
	 * [xref J5/92]
	 */
	if (pli->use_bit_cutoffs) {
	  if (cm_pli_TargetReportable(pli, hit->score, hit->evalue)) { /* evalue is invalid, but irrelevant if pli->use_bit_cutoffs */
	    hit->flags |= CM_HIT_IS_REPORTED;
	    if (cm_pli_TargetIncludable(pli, hit->score, hit->evalue)) /* ditto */
	      hit->flags |= CM_HIT_IS_INCLUDED;
	  }
	}
	  }
	} /* end of for(d = 0; d < pli->ddef->ndom; d++) */
	pli->ddef->ndom = 0; /* reset for next use */
  } /* end of 'for(i = 0; i < win'... */

  /* clean up, set return variables, and return */
  if(seq != NULL) esl_sq_Destroy(seq);

  return eslOK;
}

/* Function:  pli_dispatch_cm_search()
 * Synopsis:  Search a sequence from <start> to <end> with a CM.
 * Incept:    EPN, Thu Mar  1 10:29:53 2012
 *
 * Purpose:   Use a CM scanning DP algorithm to scan <dsq> from
 *            <start> to <stop>. The specific algorithm to use
 *            is specified by cm->search_opts and pli->cur_pass_idx.
 *
 * Args:      pli         - the pipeline
 *            cm          - the CM
 *            dsq         - sequence to search
 *            start       - first position of dsq to search
 *            stop        - final position of dsq to search
 *            hitlist     - CM_TOPHITS to add to, can be NULL
 *            cutoff      - min bit score to report to hitlist,
 *                          irrelevant if hitlist is NULL
 *            env_cutoff  - min bit score for env redefn,
 *                          irrelevant if opt_envi, opt_envj are NULL
 *            qdbidx      - index
 *            ret_sc      - RETURN: score returned by scanner
 *            opt_envi    - OPT RETURN: redefined envelope start (can be NULL)
 *            opt_envj    - OPT RETURN: redefined envelope stop  (can be NULL)
 *
 * Returns: eslOK on success.
 *          eslERANGE if we wanted to do HMM banded, but couldn't.
 */
int pli_dispatch_cm_search(CM_PIPELINE *pli, CM_t *cm, ESL_DSQ *dsq, int64_t start, int64_t stop, CM_TOPHITS *hitlist, float cutoff,
			   float env_cutoff, int qdbidx, float *ret_sc, int64_t *opt_envi, int64_t *opt_envj)
{
  int status;
  int do_trunc            = cm_pli_PassAllowsTruncation(pli->cur_pass_idx);
  int do_inside           = (cm->search_opts & CM_SEARCH_INSIDE) ? TRUE : FALSE;
  int do_hbanded          = (cm->search_opts & CM_SEARCH_HBANDED) ? TRUE : FALSE;
  int do_qdb_or_nonbanded = (do_hbanded) ? FALSE : TRUE;
  double save_tau         = cm->tau;
  float  save_thresh1     = (cm->cp9b == NULL) ? -1. : cm->cp9b->thresh1;
  float  save_thresh2     = (cm->cp9b == NULL) ? -1. : cm->cp9b->thresh2;
  float  hbmx_Mb = 0.;     /* approximate size in Mb for HMM banded matrix for this sequence */
  float  sc;               /* score returned from DP scanner */
  float  mxsize_limit     = (pli->mxsize_set) ? pli->mxsize_limit : pli_mxsize_limit_from_W(cm->W);

  /* printf("in pli_dispatch_cm_search(): do_trunc: %d do_inside: %d cutoff: %.1f env_cutoff: %.1f do_hbanded: %d hitlist?: %d opt_envi/j?: %d start: %" PRId64 " stop: %" PRId64 "\n",
	 do_trunc, do_inside, cutoff, env_cutoff, do_hbanded, (hitlist == NULL) ? 0 : 1, (opt_envi == NULL && opt_envj == NULL) ? 0 : 1, start, stop); */

  if(do_hbanded) {
	status = cp9_IterateSeq2Bands(cm, pli->errbuf, dsq, start, stop, pli->cur_pass_idx, mxsize_limit,
				  TRUE, FALSE, FALSE, /* yes we're doing search, no we won't sample from mx, no we don't need posteriors (yet) */
				  pli->maxtau, &hbmx_Mb);
	if(status == eslERANGE) {
	  /* HMM banded matrix exceeded mxsize_limit with tau of
	   * pli->maxtau. We kill this potential hit. The memory limit
	   * is acting as a filter. This is the only filter that is
	   * used differently for different sized models. The bigger
	   * a model, the more likely it is to have a hit killed here.
	   */
	  goto ERROR; /* we'll return eslERANGE, and caller will increment pli->n_overflow_* */
	}
	else if(status != eslOK) {
	  printf("pli_dispatch_cm_search(), error: %s\n", pli->errbuf); goto ERROR;
	}
	else if(status == eslOK) {
	  /* bands imply a matrix or size mxsize_limit or smaller with tau == cm->tau <= pli->maxtau */
	  if(do_trunc) { /* HMM banded, truncated */
	if(do_inside) {
	  status = FTrInsideScanHB(cm, pli->errbuf, cm->trhb_mx, mxsize_limit, pli->cur_pass_idx, dsq, start, stop,
				   cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, &sc);
	}
	else {
	  status = TrCYKScanHB(cm, pli->errbuf, cm->trhb_mx, mxsize_limit, pli->cur_pass_idx, dsq, start, stop,
			       cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, &sc);
	}
	  }
	  else { /* HMM banded, not truncated */
	if(do_inside) {
	  status = FastFInsideScanHB(cm, pli->errbuf, cm->hb_mx, mxsize_limit, dsq, start, stop,
				     cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, &sc);
	}
	else {
	  status = FastCYKScanHB(cm, pli->errbuf, cm->hb_mx, mxsize_limit, dsq, start, stop,
				 cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, &sc);
	}
	  }
	}
  }
  else if(do_qdb_or_nonbanded) {
	if(do_trunc) {
	  if(cm->trsmx == NULL) ESL_XFAIL(eslEINVAL, pli->errbuf, "pli_dispatch_cm_search(), need truncated scan mx but don't have one");
	  if(do_inside) { /* not HMM banded, truncated */
	status = RefITrInsideScan(cm, pli->errbuf, cm->trsmx, qdbidx, pli->cur_pass_idx, dsq, start, stop,
				  cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, NULL, &sc);
	  }
	  else {
	status = RefTrCYKScan(cm, pli->errbuf, cm->trsmx, qdbidx, pli->cur_pass_idx, dsq, start, stop,
			      cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, NULL, &sc);
	  }
	}
	else { /* not HMM banded, not truncated */
	  if(cm->smx == NULL) ESL_XFAIL(eslEINVAL, pli->errbuf, "pli_dispatch_cm_search(), need standard scan mx but don't have one");
	  if(do_inside) {
	status = FastIInsideScan(cm, pli->errbuf, cm->smx, qdbidx, dsq, start, stop,
				 cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, &sc);
	  }
	  else {
	status = FastCYKScan(cm, pli->errbuf, cm->smx, qdbidx, dsq, start, stop,
			     cutoff, hitlist, pli->do_null3, env_cutoff, opt_envi, opt_envj, NULL, &sc);
	  }
	}
	if(status != eslOK) { printf("pli_dispatch_cm_search(), error: %s\n", pli->errbuf); goto ERROR; }
  }

  /* revert to original parameters */
  cm->tau = save_tau;
  if(cm->cp9b != NULL) {
	cm->cp9b->thresh1 = save_thresh1;
	cm->cp9b->thresh2 = save_thresh2;
  }

  *ret_sc = sc;

  return eslOK;

 ERROR:
  cm->tau = save_tau;
  /* don't forget to thresh1 and thresh2 revert to their original values (not doing this was bug i42) */
  if(cm->cp9b != NULL) {
	cm->cp9b->thresh1 = save_thresh1;
	cm->cp9b->thresh2 = save_thresh2;
  }
  *ret_sc      = IMPOSSIBLE;
  if(opt_envi    != NULL) *opt_envi = start;
  if(opt_envj    != NULL) *opt_envi = stop;
  return eslERANGE;
}

/* Function:  pli_align_hit()
 * Synopsis:  Align a hit that survives all stages of the pipeline to a CM.
 * Incept:    EPN, Mon Aug  8 10:46:21 2011
 *
 * Purpose:   For a given hit <hit> in sequence <sq> spanning
 *            <hit->start> to <hit->stop>, align it to a CM and create a
 *            CM_ALIDISPLAY object and store it in <hit->ad>.
 *
 *            The algorithm used is dictated by pli->cm_align_opts.
 *            There's one important special case, if we want HMM
 *            banded optimal accuracy alignment with posteriors (which
 *            is TRUE in the default pipeline) and it will require too
 *            much memory, we failover to HMM banded CYK (NOT small
 *            D&C CYK as that would take a long long time for a big
 *            alignment). HMM banded CYK should never exceed our limit
 *            because we must have used HMM banded Inside in the final
 *            search stage (using the same bands we'll use here, those
 *            in cm->cp9b).
 *
 * Returns: eslOK on success, alidisplay in hit->ad.
 *          ! eslOK on an error, pli->errbuf is filled, hit->ad is NULL.
 */
int
pli_align_hit(CM_PIPELINE *pli, CM_t *cm, const ESL_SQ *sq, CM_HIT *hit)
{
  int            status;           /* Easel status code */
  CM_ALNDATA    *adata  = NULL;    /* alignment data */
  ESL_SQ        *sq2aln = NULL;    /* copy of the hit, req'd by DispatchSqAlignment() */
  ESL_STOPWATCH *watch  = NULL;    /* stopwatch for timing alignment step */
  float          null3_correction; /* null 3 bit score penalty, for CYK score */
  float          mxsize_limit = (pli->mxsize_set) ? pli->mxsize_limit : pli_mxsize_limit_from_W(cm->W);

  if(cm->cmcons == NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "pli_align_hit() cm->cmcons is NULL");

  if((watch = esl_stopwatch_Create()) == NULL) ESL_XFAIL(eslEMEM, pli->errbuf, "out of memory");
  esl_stopwatch_Start(watch);

  /* make new sq object, b/c DispatchSqAlignment() requires one */
  if((sq2aln = esl_sq_CreateDigitalFrom(cm->abc, "seq", sq->dsq + hit->start - 1, hit->stop - hit->start + 1, NULL, NULL, NULL)) == NULL) goto ERROR;

  cm->align_opts = pli->cm_align_opts;
  if(pli->cur_pass_idx != PLI_PASS_STD_ANY) cm->align_opts |= CM_ALIGN_TRUNC;

  /* do HMM banded aln, if nec */
  if(cm->align_opts & CM_ALIGN_HBANDED) { /* align with HMM bands */
	/* we have existing CP9 HMM bands from the final search stage, in
	 * cm->cp9b (caller should have verified this). Shift them by a
	 * fixed offset, this guarantees our alignment will be the same
	 * hit our search found. (After this cm->cp9b bands would fail a
	 * cp9_ValidateBands() check..., but don't worry about
	 * that... they'll work for our purposes here.
	 */
	cp9_ShiftCMBands(cm, hit->start, hit->stop, (cm->align_opts & CM_ALIGN_TRUNC) ? TRUE : FALSE);

	/* sanity check */
	if(! (cm->align_opts & CM_ALIGN_POST)) ESL_XFAIL(eslEINVAL, pli->errbuf, "pli_align_hit() using HMM bands but CM_ALIGN_POST is down");

	/* compute the HMM banded alignment */
	status = DispatchSqAlignment(cm, pli->errbuf, sq2aln, -1, mxsize_limit, hit->mode, pli->cur_pass_idx,
				 TRUE, /* TRUE: cp9b bands are valid, don't recalc them */
				 NULL, NULL, NULL, &adata);
	if(status != eslOK && status != eslERANGE) {
	  goto ERROR;
	}
	else if(status == eslERANGE) {
	  /* matrix was too big, alignment not computed, failover to HMM banded CYK with no posteriors */
	  cm->align_opts &= ~CM_ALIGN_OPTACC;
	  cm->align_opts &= ~CM_ALIGN_POST;
	  cm->align_opts |= CM_ALIGN_CYK;
	  /* Note that we double max matrix size in next call to be safe,
	   * this should be overkill because we know that our Inside
	   * search stage using the same bands was able to use a matrix
	   * less than mxsize_limit. If we can't do it now in twice
	   * that, something has gone horribly wrong. (Note that the
	   * required matrix size will be bigger than for an Inside scan,
	   * because of the required shadow matrix, but that's roughly 25%
	   * the size of the DP matrix, so the total size required for
	   * alignment should never exceed twice what the Inside scan
	   * required.)
	   */
	  status = DispatchSqAlignment(cm, pli->errbuf, sq2aln, -1, 2*mxsize_limit, hit->mode, pli->cur_pass_idx,
				   TRUE, /* TRUE: cp9b bands are valid, don't recalc them */
				   NULL, NULL, NULL, &adata);
	  if (status == eslERANGE) ESL_XFAIL(eslEINVAL, pli->errbuf, "pli_align_hit() alignment HB retry mx too big, this shouldn't happen");
	  else if(status != eslOK) goto ERROR;
	}
	pli->acct[pli->cur_pass_idx].n_aln_hb++;
	esl_stopwatch_Stop(watch); /* we started it above before we calc'ed the CP9 bands */
  }
  else { /* do non-HMM-banded alignment (! (cm->align_opts & CM_ALIGN_HBANDED)) */
	esl_stopwatch_Start(watch);
	if((status = DispatchSqAlignment(cm, pli->errbuf, sq2aln, -1, mxsize_limit, hit->mode, pli->cur_pass_idx,
				     FALSE, NULL, NULL, NULL, &adata)) != eslOK) goto ERROR;
	pli->acct[pli->cur_pass_idx].n_aln_dccyk++;
	esl_stopwatch_Stop(watch);
  }
  /* ParsetreeDump(stdout, tr, cm, sq2aln->dsq); */

  /* add null3 correction to sc if nec */
  if(pli->do_null3) {
	ScoreCorrectionNull3CompUnknown(cm->abc, cm->null, sq2aln->dsq, 1, sq2aln->L, cm->null3_omega, &null3_correction);
	adata->sc  -= null3_correction;
	hit->bias   = null3_correction;
  }

  /* create the CM_ALIDISPLAY object */
  if((status = cm_alidisplay_Create(cm, pli->errbuf, adata, sq, hit->start,
				    (cm->align_opts & CM_ALIGN_HBANDED) ? cm->cp9b->tau : -1., /* what was tau, if we used HMM bands */
				    watch->elapsed, &(hit->ad))) != eslOK) goto ERROR;

  /* clean up and return */
  cm->align_opts = pli->cm_align_opts; /* restore these */
  if(adata  != NULL) cm_alndata_Destroy(adata, FALSE); /* FALSE: don't free adata->sqp (sq2aln) */
  if(sq2aln != NULL) esl_sq_Destroy(sq2aln);
  if(watch  != NULL) esl_stopwatch_Destroy(watch);

  return eslOK;

 ERROR:
  cm->align_opts = pli->cm_align_opts; /* restore these */
  if(adata  != NULL) cm_alndata_Destroy(adata, FALSE); /* FALSE: don't free adata->sqp (sq2aln) */
  if(sq2aln != NULL) esl_sq_Destroy(sq2aln);
  if(watch  != NULL) esl_stopwatch_Destroy(watch);
  hit->ad = NULL;
  return status;
}

/* Function:  pli_scan_mode_read_cm()
 * Synopsis:  Read a CM from the CM file, mid-pipeline.
 * Incept:    EPN, Thu Mar  1 15:00:27 2012
 *
 * Purpose:   When in scan mode, we don't read the CM until we know
 *            we're going to need it, i.e. at least one envelope has
 *            survived all HMM filters (or HMM filters are turned
 *            off). Here, we read the CM from the file, configure it
 *            and return it in <ret_cm>. We also update the pipeline
 *            regarding the CM we just read.
 *
 *            <p7_evparam> will be NULL and <p7_max_length> will be 0
 *            (bot are irrelevant) unless pli->do_hmmonly_cur is TRUE.
 *
 * Returns:   <eslOK> on success. <ret_cm> contains the CM.
 *
 * Throws:    <eslEMEM> on allocation failure
 *            <eslEINCOMPAT> on contract violation.
 *            In both case, *ret_cm set to NULL, pli->errbuf filled.
 */
int
pli_scan_mode_read_cm(CM_PIPELINE *pli, off_t cm_offset, float *p7_evparam, int p7_max_length, CM_t **ret_cm)
{
  int status;
  CM_t *cm = NULL;
  int  check_fcyk_beta;  /* TRUE if we just read a CM and we need to check if its beta1 == pli->fcyk_beta */
  int  check_final_beta; /* TRUE if we just read a CM and we need to check if its beta2 == pli->final_beta */
  int   W_from_cmdline;     /* -1 (W not set on cmdline) unless pli->use_wcx is TRUE, which means --wcx was enabled */

  if (pli->mode != CM_SCAN_MODELS) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "pli_scan_mode_read_cm(), pipeline isn't in SCAN mode");
  if (*ret_cm != NULL) ESL_FAIL(eslEINCOMPAT, pli->errbuf, "pli_scan_mode_read_cm(), *ret_cm != NULL");

#ifdef HMMER_THREADS
  /* lock the mutex to prevent other threads from reading the file at the same time */
  if (pli->cmfp->syncRead) {
	if (pthread_mutex_lock (&pli->cmfp->readMutex) != 0) ESL_FAIL(eslESYS, pli->errbuf, "mutex lock failed");
  }
#endif
  cm_file_Position(pli->cmfp, cm_offset);
  if((status = cm_file_Read(pli->cmfp, FALSE, &(pli->abc), &cm)) != eslOK) ESL_FAIL(status, pli->errbuf, "%s", pli->cmfp->errbuf);
#ifdef HMMER_THREADS
  if (pli->cmfp->syncRead) {
	if (pthread_mutex_unlock (&pli->cmfp->readMutex) != 0) ESL_EXCEPTION(eslESYS, "mutex unlock failed");
  }
#endif

  /* from here on, this function is very similar to
   * cmsearch.c:configure_cm()
   */

  cm->config_opts = pli->cm_config_opts;
  cm->align_opts  = pli->cm_align_opts;
  /* check if we need to recalculate QDBs prior to building the scan matrix in cm_Configure()
   * (we couldn't do this until we read the CM file to find out what cm->qdbinfo->beta1/beta2 were
   */
  check_fcyk_beta  = (pli->fcyk_cm_search_opts  & CM_SEARCH_QDB) ? TRUE : FALSE;
  check_final_beta = (pli->final_cm_search_opts & CM_SEARCH_QDB) ? TRUE : FALSE;
  if((status = CheckCMQDBInfo(cm->qdbinfo, pli->fcyk_beta, check_fcyk_beta, pli->final_beta, check_final_beta)) == eslFAIL) {
	cm->config_opts   |= CM_CONFIG_QDB;
	cm->qdbinfo->beta1 = pli->fcyk_beta;
	cm->qdbinfo->beta2 = pli->final_beta;
  }
  /* else we don't have to change cm->qdbinfo->beta1/beta2 */

  W_from_cmdline = pli->do_wcx ? (int) (cm->clen * pli->wcx) : -1; /* -1: use W from CM file */
  if((status = cm_Configure(cm, pli->errbuf, W_from_cmdline)) != eslOK) goto ERROR;
  /* update the pipeline about the model */
  if((status = cm_pli_NewModel(pli, CM_NEWMODEL_CM, cm, cm->clen, cm->W, CMCountNodetype(cm, MATP_nd),
			       NULL, NULL, p7_evparam, p7_max_length, pli->cur_cm_idx, pli->cur_clan_idx, NULL)) /* NULL: om, bg, glocal_kh */
	 != eslOK) goto ERROR;

  *ret_cm = cm;
  return eslOK;

 ERROR:
  if(cm != NULL) FreeCM(cm);
  *ret_cm = NULL;
  return status;
}

/* Function:  pli_copy_subseq()
 * Incept:    EPN, Tue Aug  9 11:13:02 2011
 *
 * Purpose: Copy a subsequence of an existing sequence <src_sq>
 *           starting at position <i>, of length <L> to another
 *           sequence object <dest_sq>. Copy only residues from
 *           <i>..<i>+<L>-1. <dest_sq> must be pre-allocated.
 *
 * Returns: eslOK on success.
 */
void
pli_copy_subseq(const ESL_SQ *src_sq, ESL_SQ *dest_sq, int64_t i, int64_t L)
{
  /*Printf("entering pli_copy_subseq i: %" PRId64 " j: %" PRId64 " L: %" PRId64 " start-end: %" PRId64 "... %" PRId64 "\n",
	i, i+L-1, L, src_sq->start, src_sq->end);
	fflush(stdout);*/

  esl_sq_Reuse(dest_sq);
  esl_sq_GrowTo(dest_sq, L);
  memcpy((void*)(dest_sq->dsq+1), src_sq->dsq+i, L * sizeof(ESL_DSQ));
  dest_sq->dsq[0] = dest_sq->dsq[L+1] = eslDSQ_SENTINEL;
  dest_sq->n      = L;
  dest_sq->L      = src_sq->L;

  if(src_sq->start <= src_sq->end) {
	ESL_DASSERT1((L <= (src_sq->end - src_sq->start + 1)));
	/*assert(L <= (src_sq->end - src_sq->start + 1));*/
	dest_sq->start = src_sq->start  + i - 1;
	dest_sq->end   = dest_sq->start + L - 1;
  }
  else {
	ESL_DASSERT1((L <= (src_sq->start - src_sq->end + 1)));
	/*assert(L <= (src_sq->start - src_sq->end + 1));*/
	dest_sq->start = src_sq->end    + L - 1;
	dest_sq->end   = dest_sq->start - L + 1;
  }
  /*printf("leaving copy_subseq dest_sq->start..end: %" PRId64 " %" PRId64 " n: %" PRId64 "\n",
	dest_sq->start, dest_sq->end, dest_sq->n);*/

  esl_sq_SetName     (dest_sq, src_sq->name);
  esl_sq_SetAccession(dest_sq, src_sq->acc);
  esl_sq_SetDesc     (dest_sq, src_sq->desc);

  return;
}

/* Function:  pli_describe_pass()
 * Date:      EPN, Tue Nov 29 04:39:38 2011
 *
 * Purpose:   Translate internal flags for pipeline pass index
 *            into human-readable strings, for clearer output.
 *
 * Args:      pass_idx - a pipeline pass index
 *                       PLI_PASS_CM_SUMMED | PLI_PASS_STD_ANY | PLI_PASS_5P_ONLY_FORCE |
 *                       PLI_PASS_3P_ONLY_FORCE | PLI_PASS_5P_AND_3P_FORCE | PLI_PASS_HMM_ONLY_ANY
 *
 * Returns:   the appropriate string
 */
char *
pli_describe_pass(int pass_idx)
{
  switch (pass_idx) {
  case PLI_PASS_CM_SUMMED:       return "(standard and truncated passes)"; break;
  case PLI_PASS_STD_ANY:         return "(full sequences)";                break;
  case PLI_PASS_5P_ONLY_FORCE:   return "(5' terminal sequence regions)";  break;
  case PLI_PASS_3P_ONLY_FORCE:   return "(3' terminal sequence regions)";  break;
  case PLI_PASS_5P_AND_3P_FORCE: return "(full sequences short enough to contain a 5' and 3' truncated hit)"; break;
  case PLI_PASS_5P_AND_3P_ANY:   return "(full sequences, allowing truncated hits)"; break;
  case PLI_PASS_HMM_ONLY_ANY:    return "(HMM only mode: full sequences, allowing truncated hits)"; break;
  default: cm_Fail("bogus pipeline pass index %d\n", pass_idx); break;
  }
  return "";
}

/* Function:  pli_describe_hits_for_pass()
 * Date:      EPN, Thu Apr 19 05:50:54 2012
 *
 * Purpose:   Translate internal flags for pipeline pass index
 *            into human-readable strings describe types of hits
 *            found in that pass, for clearer output.
 *
 * Args:      pass_idx - a pipeline pass index
 *                       PLI_PASS_CM_SUMMED | PLI_PASS_STD_ANY | PLI_PASS_5P_ONLY_FORCE |
 *                       PLI_PASS_3P_ONLY_FORCE | PLI_PASS_5P_AND_3P_FORCE | PLI_PASS_HMM_ONLY_ANY
 *
 * Returns:   the appropriate string
 */
char *
pli_describe_hits_for_pass(int pass_idx)
{
  switch (pass_idx) {
  case PLI_PASS_CM_SUMMED:       return "CM hits reported:";                     break;
  case PLI_PASS_STD_ANY:         return "non-truncated CM hits reported:";       break;
  case PLI_PASS_5P_ONLY_FORCE:   return "5' truncated CM hits reported:";        break;
  case PLI_PASS_3P_ONLY_FORCE:   return "3' truncated CM hits reported:";        break;
  case PLI_PASS_5P_AND_3P_FORCE: return "5' and 3' truncated CM hits reported:"; break;
  case PLI_PASS_5P_AND_3P_ANY:   return "CM hits reported:";                     break;
  case PLI_PASS_HMM_ONLY_ANY:    return "HMM hits reported:";                    break;
  default: cm_Fail("bogus pipeline pass index %d\n", pass_idx); break;
  }
  return "";
}

/* Function:  pli_mxsize_limit_from_W()
 * Date:      EPN, Fri May 30 15:28:04 2014
 *
 * Purpose:   Determine the HMM banded matrix size limit dependent on
 *            W. This is used separately for each model in the pipeline
 *            unless the user set --mxsize in 'cmsearch' or 'cmscan'.
 *
 * Args:      W: cm->W, the window length for the current CM
 *
 * Returns:   the maximum matrix size for the given W.
 */
float
pli_mxsize_limit_from_W(int W)
{
  float mxsize;

  mxsize  = (float) W - (float) DEFAULT_HB_MXSIZE_MIN_W;
  mxsize /= (float) DEFAULT_HB_MXSIZE_MAX_W  - (float) DEFAULT_HB_MXSIZE_MIN_W;
  mxsize *= (float) DEFAULT_HB_MXSIZE_MAX_MB - (float) DEFAULT_HB_MXSIZE_MIN_MB;
  mxsize += (float) DEFAULT_HB_MXSIZE_MIN_MB;

  /* at this point, mxsize is probably less than the minimum allowed (DEFAULT_HB_MXSIZE_MIN_MB)
   * (depending on what that's set to). It may even be a negative number! So it's important
   * to enforce the minimum and maximum here.
   */
  mxsize = ESL_MIN(mxsize, DEFAULT_HB_MXSIZE_MAX_MB);
  mxsize = ESL_MAX(mxsize, DEFAULT_HB_MXSIZE_MIN_MB);

  /*printf("in mxsize_limit_from_W(): W: %d returning %.3f\n", W, mxsize);*/
  return mxsize;
}

#if 0
/* EPN, Fri Mar 2 13:46:18 2012
 * This function was developed when I was experimenting with using
 * multiple HMM filters, which was later scrapped. It's left here for
 * reference.
 */

/* Function:  merge_windows_from_two_lists()
 * Synopsis:  Merge two sorted lists of windows into one, collapsing overlapping windows together.
 * Incept:    EPN, Mon Nov 29 14:47:40 2010
 *
 * Purpose:   Given two lists of windows, merge them into one list
 *            by collapsing any overlapping windows into a single window.
 *
 *            Each window in list 1 is defined as:
 *            <ws1[i]>..we1[i] for i=0..<nwin1-1>
 *
 *            Each window in list 2 is defined as:
 *            <ws2[i]>..we2[i] for i=0..<nwin2-1>
 *
 *            The windows within each list must be sorted in
 *            increasing order and be non-overlapping, i.e. the
 *            following must hold:
 *
 *            ws1[i] <  ws1[j] for all i < j.
 *            ws1[i] <= we1[i] for all i.
 *
 *            ws2[i] <  ws2[j] for all i < j.
 *            ws2[i] <= we2[i] for all i.
 *
 *            Note, we check that these conditions hold at the
 *            beginning of the function, and return eslEINVAL if not.
 *
 *            A new list is created and returned, as <mws>,
 *            <mwe>, and <nmwin>, start, end positions and
 *            number of windows respectively.
 *
 *            The lowest P-value of any of the merged windows is also
 *            kept, and returned in <ret_mwp>, <ret_mwp[i]> is the
 *            lowest P-value of any of the P-values from <wp1>/<wp2>
 *            for windows that were merged together to create
 *            <mws>..<mwe>. If the P-value was from a window in list 1
 *            (<wp1>), <ret_mwl[i]> is set as 1, if it is from a
 *            window from list 2 (<wp2>), <ret_mwl[i]> is set as 2.
 *
 * Returns:   New merged list in <ret_mws>, <ret_mwe>, <ret_mwp>,
 *            <ret_mwl>, <ret_nmwin>, storing start position, end
 *            position, P-value and list origin of each of the
 *            <ret_nmwin> windows in the merged list.
 */
int
merge_windows_from_two_lists(int64_t *ws1, int64_t *we1, double *wp1, int *wl1, int nwin1, int64_t *ws2, int64_t *we2, double *wp2, int *wl2, int nwin2, int64_t **ret_mws, int64_t **ret_mwe, double **ret_mwp, int **ret_mwl, int *ret_nmwin)
{
  int status;
  int64_t *mws = NULL;
  int64_t *mwe = NULL;
  double  *mwp = NULL;
  int     *mwl = NULL;
  int nmwin;
  int mi, i1, i2;
  int nalloc;

  /* check that our required conditions hold */
  for(i1 = 0; i1 < nwin1-1; i1++) if(ws1[i1] >= ws1[i1+1]) return eslEINVAL;
  for(i2 = 0; i2 < nwin2-1; i2++) if(ws2[i2] >= ws2[i2+1]) return eslEINVAL;
  for(i1 = 0; i1 < nwin1; i1++) if(ws1[i1] > we1[i1]) return eslEINVAL;
  for(i2 = 0; i2 < nwin2; i2++) if(ws2[i2] > we2[i2]) return eslEINVAL;

  nalloc = nwin1 + nwin2; /* we'll never exceed this */
  ESL_ALLOC(mws, sizeof(int64_t) * ESL_MAX(1, nalloc)); // avoid 0 malloc
  ESL_ALLOC(mwe, sizeof(int64_t) * ESL_MAX(1, nalloc));
  ESL_ALLOC(mwp, sizeof(double)  * ESL_MAX(1, nalloc));
  ESL_ALLOC(mwl, sizeof(int)     * ESL_MAX(1, nalloc));

  i1 = 0;
  i2 = 0;
  mi = 0;
  while(i1 < nwin1 || i2 < nwin2) {
	if((i1 < nwin1) && ((i2 == nwin2) || (ws1[i1] < ws2[i2]))) {
	  /**************************************************
	   * case 1: our next hit, in order is from list 1 *
	   **************************************************/
	  /* initialize merged hit as copy of hit from list 1 */
	  mws[mi] = ws1[i1]; /* our merged window begins at ws1[i1], this won't change */
	  mwp[mi] = wp1[i1]; /* for now, our best P-value is wp1[i1] */
	  mwl[mi] = wl1[i1]; /* for now, our best P-value comes from list 1 */
	  mwe[mi] = we1[i1]; /* for now, our merged window ends at we1[i1] */
	  /* merge with all overlapping windows in list 2 */
	  while((i2 < nwin2) && (mwe[mi] >= ws2[i2])) { /* check all windows in list 2 that overlap with our current list 1 window */
	mwe[mi] = ESL_MAX(mwe[mi], we2[i2]); /* our merged window now ends at larger of mwe[me] and we2[i2] */
	if(wp2[i2] < mwp[mi]) {
	  mwp[mi] = wp2[i2];  /* our best P-value now is wp2[i2] */
	  mwl[mi] = wl2[i2];  /* our best P-value now comes from list 2 */
	}
	i2++;
	  }
	  i1++;
	  /* finally, if we merged any windows from list 2, our window is possibly larger,
	   * so we merge with all now-overlapping windows in list 1 */
	  while((i1 < nwin1) && (mwe[mi] >= ws1[i1])) {
	mwe[mi] = ESL_MAX(mwe[mi], we1[i1]); /* our merged window now ends at larger of mwe[me] and we2[i2] */
	if(wp1[i1] < mwp[mi]) {
	  mwp[mi] = wp1[i1];  /* our best P-value now is wp1[i1] */
	  mwl[mi] = wl1[i1];  /* our best P-value now comes from list 1 */
	}
	i1++;
	  }
	  mi++;
	}
	else {
	  /****************************************************************************************************************
	   * case 2: our next hit, in order is from list 2, same code as case 1, with list 1 and list 2 variables inverted *
	   ****************************************************************************************************************/
	  /* initialize merged hit as copy of hit from list 2 */
	  mws[mi] = ws2[i2]; /* our merged window begins at ws1[i2], this won't change */
	  mwp[mi] = wp2[i2]; /* for now, our best P-value is wp2[i2] */
	  mwl[mi] = wl2[i2]; /* for now, our best P-value comes from list 2 */
	  mwe[mi] = we2[i2]; /* for now, our merged window ends at we2[i2] */
	  /* merge with all overlapping windows in list 1 */
	  while((i1 < nwin1) && (mwe[mi] >= ws1[i1])) { /* check all windows in list 1 that overlap with our current list 2 window */
	mwe[mi] = ESL_MAX(mwe[mi], we1[i1]); /* our merged window now ends at larger of mwe[me] and we1[i1] */
	if(wp1[i1] < mwp[mi]) {
	  mwp[mi] = wp1[i1];  /* our best P-value now is wp1[i1] */
	  mwl[mi] = wl1[i1];  /* our best P-value now comes from list 1 */
	}
	i1++;
	  }
	  i2++;
	  /* finally, if we merged any windows from list 1, our window is possibly larger,
	   * so we merge with all now-overlapping windows in list 2 */
	  while((i2 < nwin2) && (mwe[mi] >= ws2[i2])) { /* check all windows in list 2 that overlap with our current list 1 window */
	mwe[mi] = ESL_MAX(mwe[mi], we2[i2]); /* our merged window now ends at larger of mwe[me] and we2[i2] */
	if(wp2[i2] < mwp[mi]) {
	  mwp[mi] = wp2[i2];  /* our best P-value now is wp2[i2] */
	  mwl[mi] = wl2[i2];  /* our best P-value now comes from list 2 */
	}
	i2++;
	  }
	  mi++;
	}
  }
  nmwin = mi;

  /*
  for(i1 = 0; i1 < nwin1; i1++) printf("list1 win %5d  %10" PRId64 "..%10" PRId64 " P: %10g\n", i1, ws1[i1], we1[i1], wp1[i1]);
  printf("\n");
  for(i2 = 0; i2 < nwin2; i2++) printf("list2 win %5d  %10" PRId64 "..%10" PRId64 " P: %10g\n", i2, ws2[i2], we2[i2], wp2[i2]);
  printf("\n");
  for(mi = 0; mi < nmwin; mi++) printf("mlist win %5d  %10" PRId64 "..%10" PRId64 " P: %10g  %d\n", mi, mws[mi], mwe[mi], mwp[mi], mwl[mi]);
  printf("\n");
  */

  *ret_mws = mws;
  *ret_mwe = mwe;
  *ret_mwp = mwp;
  *ret_mwl = mwl;
  *ret_nmwin = nmwin;

  return eslOK;

 ERROR:
  return status;
}
#endif

/*****************************************************************
 * 3. Example 1: "search mode" in a sequence db
 *****************************************************************/
/*****************************************************************
 * 4. Example 2: "scan mode" in an HMM db
 *****************************************************************/
/*****************************************************************
 * Infernal - inference of RNA secondary structure alignments
 * Version 1.1.2; July 2016
 * Copyright (C) 2016 Howard Hughes Medical Institute.
 * Other copyrights also apply. See the COPYRIGHT file for a full list.
 *
 * Infernal is distributed under the terms of the GNU General Public License
 * (GPLv3). See the LICENSE file for details.
 *****************************************************************/

/*** End of inlined file: cm_pipeline.c ***/


/*** Start of inlined file: cm_qdband.c ***/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>



static char *qdbinfo_setby_to_string(int setby);

/* Function:  CalculateQueryDependentBands()
 * Incept:    EPN, Sat Dec 10 16:23:53 2011
 *
 * Purpose:   A wrapper for BandCalculationEngine() (see that function
 *            for more information). BCE() requires a guess at a maximum
 *            length Z hat may or may not satisfy our criteria for
 *            truncation error, so if it fails we continue to call it
 *            with larger Z until it passes.
 *
 * Returns:   eslOK on success.
 *            eslEINVAL if qdbinfo->beta1 is < qdbinfo->beta2 (beta1 should always be higher (tighter bands))
 *            eslEMEM if we're out of memory
 *            eslEINCONCEIVABLE if (Z = cm->clen * 1000) is still not big enough
 */
int
CalculateQueryDependentBands(CM_t *cm, char *errbuf, CM_QDBINFO *qdbinfo, double beta_W, int *ret_W,
			     double **ret_gamma0_loc, double **ret_gamma0_glb, int *ret_Z)
{
  int status;
  int Z;

  if(qdbinfo != NULL && ((qdbinfo->beta2 - qdbinfo->beta1) > 1E-20)) ESL_FAIL(eslEINVAL, errbuf, "Calculating QDBs, qdbinfo->beta1 < qdbinfo->beta2");

  Z = cm->clen * 4;
  while((status = BandCalculationEngine(cm, Z, qdbinfo, beta_W, ret_W, NULL, ret_gamma0_loc, ret_gamma0_glb)) != eslOK) {
	if(status == eslEMEM)     ESL_FAIL(status, errbuf, "Calculating QDBs, out of memory");
	if(status != eslERANGE)   ESL_FAIL(status, errbuf, "Calculating QDBs, unexpected error");
	Z *= 2;
	if(Z > (cm->clen * 1000)) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "Calculating QDBs, Z got insanely large (> 1000*clen)");
  }

  if(ret_Z != NULL) *ret_Z = Z;
  return eslOK;
}

/* Function:  BandCalculationEngine()
 * Incept:    SRE, Sat Oct 11 14:17:40 2003 [St. Louis]
 *
 * Purpose:   Given a CM and a maximum length Z;
 *            calculate probability densities gamma_v(n), probability
 *            of a parse subtree rooted at state v emitting a sequence
 *            of length n.
 *
 *            Then use these to return up to two sets of bounds
 *            dmin1[v]..dmax1[v] and dmin2[v]..dmax2[v] which
 *            include a probability mass of >= 1-2(beta1) and
 *            >= 1-2(beta2) respectively. Each truncated tail
 *            (left and right) contains <= beta1 and <= beta2
 *            * probability mass.
 *
 *            dmin1, dmax2, dmin2, dmax2, beta1, beta2 are all
 *            part of the passed in <qdbinfo> data structure.
 *            If <qdbinfo> is NULL, don't calculate these bands.
 *
 *            Let L_v(n) be the cumulative probability distribution,
 *            P(length <= n), for state v:
 *                L_v(n) = \sum_{i=0}^{n}  \gamma_v(i)
 *
 *            For each state v, find dmin such that the probability
 *            of missing a hit is <= \beta on the low side:
 *                dmin = max_dmin L_v(dmin-1) <= \beta
 *
 *            On the high side, let H_v(n) be 1-L_v(n): e.g.
 *            P(length > n) for state v. But it is important not
 *            to calculate this as 1-L_v(n); because of numerical
 *            roundoff issues, it must be done as:
 *                H_v(n) = \sum_{i=n+1}{\infty} \gamma_v(i)
 *
 *            Then for each state v, find a dmax such that the
 *            probability of missing a hit is <= \beta on the high
 *            side:
 *               dmax = min_dmax  H_v(dmax) <= \beta
 *
 *            Note on truncation error:
 *            Of course we can't calculate the sum to \infty; we have
 *            to truncate somewhere. Truncation error must be negligible,
 *            else our choice of bands will depend on the choice of Z.
 *            See BandTruncationNegligible() for the test.
 *
 *            Note on model configuration:
 *            We always calculate QDBs with local ends off and local
 *            begins on. This makes the QDBs safe to use for local or
 *            global search: putting local begins on only affects the
 *            ROOT_S state 0, which must be able to transit to any
 *            state for which a legal local begin is possible. A
 *            scanner function (e.g. cm_dpsearch.c:FastCYKScan()) can
 *            restrict dmin[0] and dmax[0] in global mode as a small
 *            optimization.
 *
 *            However, we don't want to modify the model configuration
 *            since local begins on and local ends off is a strange
 *            combination. So we make copies of <cm->t> and calculate
 *            new versions of <cm->begin> and <cm->trbegin> vectors
 *            just to use to calculate bands. This way we don't have
 *            to reconfigure the model twice: once upon entering the
 *            function and then back to its original state upon exit.
 *            This would be relatively quick, our main motivation is
 *            that we want to limit the possible paths through the
 *            different configuration functions as much as possible
 *            to limit the chance that some of those paths would
 *            screw something up.
 *
 * Args:      cm             - model to build the bands for
 *            Z              - maximum subsequence length Z
 *            qdbinfo        - data structure with two sets of preallocated
 *                             dmin/dmax arrays and two beta values, if
 *                             NULL we don't care about d bounds.
 *            beta_W         - tail probability mass used to set ret_W,
 *                             the maximum size of a hit to be allowed
 *            ret_W          - RETURN: dmax[0] set with tail loss prob == beta_W
 *            ret_gamma      - RETURN: gamma[v][n], [0..M-1][0..Z], is the prob
 *                             density Prob(length=n | parse subtree rooted at v).
 *                             If NULL: uses a memory-efficient O(Z lnM)
 *                             algorithm instead
 *            ret_gamma0_loc - RETURN: [0..Z] probability of hit lengths (rooted at ROOT_S) in local mode
 *            ret_gamma0_glb - RETURN: [0..Z] probability of hit lengths (rooted at ROOT_S) in global mode
 *
 * Returns:   eslOK on success.
 *            eslERANGE if Z was too small; caller needs to increase Z and call the engine again.
 *            eslEINVAL if qdbinfo->beta1 is < qdbinfo->beta2 (beta1 should always be higher (tighter bands))
 *            eslEMEM if we're out of memory
 *
 *            The dependency on a sensible Z a priori is an annoyance;
 *            it may be possible to write an algorithm that calculates
 *            Z on the fly, but I don't see it.
 *
 * Xref:      STL7 p.127 - rearranged calculations of previous BandBounds()
 *                         imp., for better numerical precision
 *            STL7 p.128 - justification of truncation error calculations.
 *            STL7 p.130 - tests/evaluations.
 */
int
BandCalculationEngine(CM_t *cm, int Z, CM_QDBINFO *qdbinfo, double beta_W,
		      int *ret_W, double ***ret_gamma, double **ret_gamma0_loc, double **ret_gamma0_glb)
{
  int      status;		/* return status. */
  double **gamma;               /* P(length = n) for each state v            */
  int      v;			/* counter over states, 0..M-1               */
  int      y;			/* counter over connected states             */
  int      n;			/* counter over lengths, 0..Z */
  int      dv;			/* Delta for state v */
  int      leftn;		/* length of left subsequence under a bifurc */
  double   pdf; 		/* P(<=n) or P(>=n) for this state v         */
  int     *touch;               /* touch[y] = # higher states depending on y */
  ESL_STACK *beamstack;         /* pool of beams we can reuse  */
  double  *tmp;                 /* for freeing beamstack only */
  int      yoffset;             /* counter over children */
  double  *gamma0_loc = NULL;   /* length distribution of  local hits (gamma[0]) */
  double  *gamma0_glb = NULL;   /* length distribution of global hits (gamma[0] if we were in global mode) */
  double   max_beta;            /* max of beta_W, qdbinfo->beta1 and qdbinfo->beta2 */
  int      dmin2_set = FALSE;   /* qdbinfo->dmin2 has been set for this state, used when setting bands */
  int      dmax2_set = FALSE;   /* qdbinfo->dmax2 has been set for this state, used when setting bands */
  int      W;                   /* dmax[0] when using beta_W, returned as *ret_W */

  /* copies of CM parameters */
  float  **t_copy       = NULL;  /* copy of cm->t[0..v..M-1][0..MAXCONNECT-1], transition probs */
  float   *begin_copy   = NULL;  /* cm->begin[0..v..M-1], standard local begin probabilities  */

  if(qdbinfo != NULL && ((qdbinfo->beta2 - qdbinfo->beta1) > 1E-20)) return eslEINVAL;
  max_beta = beta_W;
  if(qdbinfo != NULL) max_beta = ESL_MAX(max_beta, ESL_MAX(qdbinfo->beta1, qdbinfo->beta2));

  /* Make copies of cm->t, cm->begin and cm->trbegin, so we can
   * modify the copies without changing the originals.
   */
  ESL_ALLOC(t_copy,    cm->M * sizeof(float *));
  ESL_ALLOC(t_copy[0], cm->M * MAXCONNECT * sizeof(float));
  for (v = 0; v < cm->M; v++) {
	t_copy[v] = t_copy[0] + v * MAXCONNECT;
  }
  ESL_ALLOC(begin_copy,   sizeof(float) * cm->M);
  esl_vec_FCopy(cm->t[0],  cm->M * MAXCONNECT, t_copy[0]);
  esl_vec_FCopy(cm->begin, cm->M, begin_copy);

  /* Now modify our copies to reflect a CM with local begins on but local ends off */
  /* first negate local ends */
  if(cm->flags & CMH_LOCAL_END) {
	for (v = 0; v < cm->M; v++) {
	  if(NOTZERO(cm->end[v])) {
	esl_vec_FNorm(t_copy[v], cm->cnum[v]);
	  }
	}
  }
  cm_CalculateLocalBeginProbs(cm, cm->pbegin, t_copy, begin_copy);

  /* gamma[v][n] is Prob(state v generates subseq of length n)
   */
  ESL_ALLOC(gamma, sizeof(double *) * cm->M);
  for (v = 0; v < cm->M; v++) gamma[v] = NULL;

  /* beamstack is a trick for reusing memory: a pushdown stack of
   * "beams" (gamma[v] rows) we can reuse.
   */
  beamstack = esl_stack_PCreate();

  /* The second component of memory saving is the "touch" array.
   * touch[y] is the number of states above state [y] that will
   * depend on y but haven't been calculated yet. When we're done
   * calculating a new state v, we decrement touch[y] for all
   * y \in C_v. Any time touch[y] reaches 0, we put that beam
   * back into the pool for reuse.
   */
  ESL_ALLOC(touch, sizeof(int) * cm->M);
  for (v = 0; v < cm->M; v++) touch[v] = cm->pnum[v];

  /* Allocate and initialize the shared end beam and the special
   * ROOT_S beam which we need to keep around the entire time.
   */
  ESL_ALLOC(gamma[0],       (sizeof(double) * (Z+1)));
  ESL_ALLOC(gamma[cm->M-1], (sizeof(double) * (Z+1)));
  esl_vec_DSet(gamma[0],       Z+1, 0.);
  esl_vec_DSet(gamma[cm->M-1], Z+1, 0.);
  gamma[cm->M-1][0] = 1.0;

  for (v = cm->M-1; v >= 0; v--) {
	if (cm->sttype[v] == E_st) {
	  gamma[v] = gamma[cm->M-1];
	  if(qdbinfo != NULL) {
	qdbinfo->dmin1[v] = qdbinfo->dmax1[v] = 0;
	qdbinfo->dmin2[v] = qdbinfo->dmax2[v] = 0;
	  }
	  continue;
	}

	if(v != 0) {
	  if (esl_stack_PPop(beamstack, (void **) &gamma[v]) == eslEOD) {
	ESL_ALLOC(gamma[v], sizeof(double) * (Z+1));
	  }
	  esl_vec_DSet(gamma[v], Z+1, 0.);
	}
	/* Recursively calculate prob density P(length=n) for this state v.
	 * (The heart of the algorithm is right here.)
	 */
	if(cm->sttype[v] == B_st) { /* a bifurcation state: */
	  pdf = 0.;
	  for (n = 0; n <= Z; n++) {
	for (leftn = 0; leftn <= n; leftn++) {
	  gamma[v][n] += gamma[cm->cfirst[v]][leftn]*gamma[cm->cnum[v]][n-leftn];
	}
	pdf += gamma[v][n];
	  }
	}
	else if (v != 0) {
	  /* not a B_st, not the ROOT_S state (only way out of ROOT_S is via a local begin) */
	  pdf = 0.;
	  dv = StateDelta(cm->sttype[v]);
	  for (n = dv; n <= Z; n++) {
	for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++) {
	  y = cm->cfirst[v] + yoffset;
	  gamma[v][n] += t_copy[v][yoffset] * gamma[y][n-dv];
	}
	pdf += gamma[v][n];
	  }
	}
	/* update gamma[0] by considering local begins from ROOT_S into v */
	if(begin_copy[v] > 0.) { /* standard local begin transition into v is possible */
	  for (n = 0; n <= Z; n++) {
	gamma[0][n] += begin_copy[v] * gamma[v][n];
	/* Note: we only consider possible standard local
	 * begins, not truncated local begins. This could be
	 * considered 'wrong', but it is consistent with earlier
	 * versions of Infernal that didn't allow truncated
	 * begins. If we did consider truncated local begins we
	 * may have slightly looser bands that were more
	 * relevant for truncated scans. However, standard
	 * scans dominate truncated scans, so this approach
	 * is reasonable.
	 */
	  }
	}

	/* Make sure we've captured "enough" of the distribution (e.g.,
	 * we have captured the right tail; our truncation error is
	 * negligible).
	 *   Of our 3 criteria, we apply two to every state:
	 *     1. we're on the right side of the density (pdf is > 0.5
	 *        would be enough, but we use .999)
	 *     2. gamma_v(Z) < p * DBL_EPSILON
	 *        Must be true if \sum_{i=Z+1...\infty} g(i) < p*DBL_EPSILON,
	 *        which is really what we're trying to prove
	 */
	if(v == 0) pdf = esl_vec_DSum(gamma[0], Z+1);
	if (pdf <= 0.999 || gamma[v][Z] > max_beta * DBL_EPSILON)
	  {
	/* fail; truncation error is unacceptable;
	 * caller is supposed to increase Z and rerun.
	 */
	status = eslERANGE;
	goto ERROR;
	  }

	/* Renormalize this beam. (Should we really be doing this?) */
	if (pdf > 1.0) esl_vec_DNorm(gamma[v], Z+1);

	if(qdbinfo != NULL) {
	  /* Determine our left bounds, dmin1 and dmin2, use knowledge that beta2 < beta1*/
	  pdf = 0.;
	  dmin2_set = FALSE;
	  for (n = 0; n <= Z; n++) {
	pdf += gamma[v][n];
	if ((! dmin2_set) && pdf > qdbinfo->beta2) { qdbinfo->dmin2[v] = n; dmin2_set = TRUE; }
	if ((  dmin2_set) && pdf > qdbinfo->beta1) { qdbinfo->dmin1[v] = n; break; }
	  }
	  /* And our right bounds, dmax1 and dmax2 */
	  pdf = 0.;
	  dmax2_set = FALSE;
	  for (n = Z; n >= 0; n--) {
	pdf += gamma[v][n];
	if ((! dmax2_set) && pdf > qdbinfo->beta2) { qdbinfo->dmax2[v] = n; dmax2_set = TRUE; }
	if ((  dmax2_set) && pdf > qdbinfo->beta1) { qdbinfo->dmax1[v] = n; break; }
	  }
	}
	if(v == 0) { /* calculate right bound, to set as ret_W (will be max size of a hit) */
	  pdf = 0.;
	  for (n = Z; n >= 0; n--) {
	pdf += gamma[0][n];
	if (pdf > beta_W) { W = n; break; }
	  }
	}
	/* Reuse memory where possible, using the "touch" trick:
	 *   look at all children y \in C_v.
	 *   decrement touch[y]
	 *   if touch[y] reaches 0, no higher state v depends on this
	 *     state's numbers; release the memory.
	 *   we're reusing the end state for every E, so don't free it
	 *   'til we're done.
	 * But if ret_gamma != NULL, don't do this - the
	 * caller wants the whole gamma matrix back.
	 */
	if (ret_gamma == NULL) {
	  if (cm->sttype[v] == B_st)
	{  /* connected children of a B st are handled specially, remember */
	  y = cm->cfirst[v];
	  if((status = esl_stack_PPush(beamstack, gamma[y])) != eslOK) goto ERROR;
	  gamma[y] = NULL;
	  y = cm->cnum[v];
	  if((status = esl_stack_PPush(beamstack, gamma[y])) != eslOK) goto ERROR;
	  gamma[y] = NULL;
	}
	  else
	{
	  for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
	    {
	      touch[y]--;
	      if (touch[y] == 0 && cm->sttype[y] != E_st) {
		if((status = esl_stack_PPush(beamstack, gamma[y])) != eslOK) goto ERROR;
		gamma[y] = NULL;
	      }
	    }
	}
	}
  } /*end loop up through all states v*/

  /* Get length distributions of local hits and global hits */
  if(ret_gamma0_loc != NULL) {
	ESL_ALLOC(gamma0_loc, sizeof(double) * (Z+1));
	/* local mode is easy, gamma[0] already contains the length distribution */
	esl_vec_DCopy(gamma[0],   Z+1, gamma0_loc);
	esl_vec_DNorm(gamma0_loc, Z+1);
  }
  if(ret_gamma0_glb != NULL) {
	ESL_ALLOC(gamma0_glb, sizeof(double) * (Z+1));
	/* global: we need to do some more calculations first */
	/* reset global-mode transition probabilities */
	if(cm->root_trans != NULL) {
	  for (v = 0; v < cm->cnum[0]; v++) t_copy[0][v] = cm->root_trans[v];
	} /* else t_copy[0] includes appropriate global transition probs */
	/* recalculate what gamma[0] would be if local begins were off */
	esl_vec_DSet(gamma0_glb, Z+1, 0.);
	for (n = 0; n <= Z; n++) {
	  for (yoffset = 0; yoffset < cm->cnum[0]; yoffset++) {
	y = cm->cfirst[0] + yoffset;
	gamma0_glb[n] += t_copy[0][yoffset] * gamma[y][n];
	  }
	}
	esl_vec_DNorm(gamma0_glb, Z+1);
  }

  if ((! BandTruncationNegligible(gamma[0], W, Z, NULL)) ||
	  (qdbinfo != NULL && (! BandTruncationNegligible(gamma[0], qdbinfo->dmax1[0], Z, NULL))) ||
	  (qdbinfo != NULL && (! BandTruncationNegligible(gamma[0], qdbinfo->dmax2[0], Z, NULL))))
	{
	  status = eslERANGE;
	  goto ERROR;
	}

  if(qdbinfo != NULL) qdbinfo->setby = CM_QDBINFO_SETBY_BANDCALC;

  /*if(qdbinfo != NULL) DumpCMQDBInfo(stdout, cm, qdbinfo);*/

  if (ret_W          != NULL) *ret_W          = W;
  if (ret_gamma      != NULL) *ret_gamma      = gamma;      else FreeBandDensities(cm, gamma);
  if (ret_gamma0_loc != NULL) *ret_gamma0_loc = gamma0_loc; else if(gamma0_loc != NULL) free(gamma0_loc);
  if (ret_gamma0_glb != NULL) *ret_gamma0_glb = gamma0_glb; else if(gamma0_glb != NULL) free(gamma0_glb);
  status = eslOK;

 ERROR:
  if(status != eslOK) {
	if (ret_W          != NULL) *ret_W          = 0;
	if (ret_gamma      != NULL) *ret_gamma      = NULL;
	if (ret_gamma0_loc != NULL) *ret_gamma0_loc = NULL;
	if (ret_gamma0_glb != NULL) *ret_gamma0_glb = NULL;
	if (gamma      != NULL) FreeBandDensities(cm, gamma);
	if (gamma0_loc != NULL) free(gamma0_loc);
	if (gamma0_glb != NULL) free(gamma0_glb);
  }

  /* Free the reused stack of beams.
   */
  if(t_copy != NULL) {
	if(t_copy[0] != NULL) free(t_copy[0]);
	free(t_copy);
  }
  if(begin_copy   != NULL) free(begin_copy);

  free(touch);
  while (esl_stack_PPop(beamstack, (void **) &tmp) != eslEOD) free(tmp);
  esl_stack_Destroy(beamstack);

  return status;
}

/* Function:  BandTruncationNegligible()
 * Incept:    SRE, Sun Oct 19 10:43:21 2003 [St. Louis]
 *
 * Purpose:   Verifies that for this choice of Z, the truncation error,
 *                 D = \sum_{n=Z+1}{\infty} \gamma_v(n),
 *            will not affect our calculation of the right bound, b (dmax),
 *            based on the probability mass we can observe,
 *                 C = \sum_{n=b+1}{Z} \gamma_v(n).
 *
 *            Specifically, we want D such that C + D = C; that is,
 *                 D < C * DBL_EPSILON.
 *
 *            We assume that the tail of \gamma is decreasing
 *            geometrically. This lets us predict the tail is
 *                  \gamma_v(n) = \gamma_v(Z+1) \beta^{n-Z-1}
 *
 *            and from the sum of an infinite geometric series, combined
 *            with \gamma_v(Z+1) = \beta \gamma_v(Z), we obtain:
 *                            \gamma_v(Z) \beta
 *                    D'  =     -----------------
 *                                1 - \beta
 *
 *            How well D' approximates the true truncated tail mass D
 *            depends on how valid the assumption of geometrically
 *            decreasing tails is. For a single insert state, one
 *            obtains a geometrically decreasing tail.  For a mixture
 *            of geometric distributions, if one fits the low side,
 *            one overestimates the rate of convergence to 0, and so
 *            underestimates D; D' <= D. But if anything, we want D' >= D;
 *            an upper bound on D lets us prove D < C * epsilon.
 *            Puzzlingly, this does not seem to be a problem. For
 *            a variety of models and states, D' is indeed an
 *            overestimate of D; empirically, the tail density converges to zero
 *            supergeometrically, which I can't explain.
 *
 *            Using ret_beta to verify:
 *
 *               D' = (beta / (1.-beta)) * density[Z];
 *               D  = \sum_{n=b+1}{\infty} density[Z];
 *               D' >= D.
 *
 *               test for an even stronger criterion:
 *               let estimated density g(n) = gamma[Z] * \beta^(n-Z);
 *               g(n) >= gamma[n] for all n > Z.
 *
 *            In the testsuite, "check_bandtruncation" empirically verifies
 *            D' > D.
 *
 * Args:      density    - one density \gamma_v() calculated by BandCalculationEngine();
 *                         usually the root (if Z is big enough for the root, it's
 *                         big enough for every state).
 *            b          - the left bound dmax[v]
 *            Z          - the maximum length; gamma_v[] runs [0..Z]
 *            ret_beta   - RETURN (optional): the geometric decay constant \beta,
 *                         obtained by simple linear fit to log gamma().
 *
 *
 * Returns:   1 if truncation error is negligible (D' < C * DBL_EPSILON)
 *            0 if truncation error is not negigible, and caller will
 *              have to worry about increasing Z.
 *
 * Xref: STL7 p.128.
 */
int
BandTruncationNegligible(double *density, int b, int Z, double *ret_beta)
{
  double logbeta;
  double beta;		/* geometric decay parameter                  */
  double C;		/* area under density from b+1..Z inclusive   */
  double D;		/* area under unseen density from Z+1..\infty */
  int    i;

  /* Sum up how much probability mass we do see,
   * in the truncated tail from b+1..Z.
   */
  C = 0.;
  for (i = b+1; i <= Z; i++) C += density[i];

  /* If density is falling off as a geometric, log(beta) is
   * the slope of log(p). Estimate slope quickly and crudely, by a
   * simple 2-point fit at our boundaries b+1 and Z.
   */
  logbeta = (log(density[Z]) - log(density[b+1])) / (Z - b - 1);
  beta = exp(logbeta);

  /* We can now guess at the missing probability mass from Z+1...\infty,
   * because a finite geometric series converges to 1/(1+\beta).
   */
  D = (beta / (1.-beta)) * density[Z];

  if (ret_beta != NULL) *ret_beta = beta;

  if (D < C * DBL_EPSILON) return 1;
  else                     return 0;
}

/* Function:  BandMonteCarlo()
 * Incept:    SRE, Fri Oct 17 08:01:42 2003 [St. Louis]
 *
 * Purpose:   Calculate the gamma_v densities by Monte Carlo simulation,
 *            by sampling parsetrees from the CM. gamma[v][i] is the
 *            observed number of subsequences of length i rooted at v
 *            in the sample. These counts are left unnormalized; different
 *            states are reached with different probabilities, and the
 *            caller may want to test the Monte Carlo observed counts
 *            against predicted counts (see bandcyk-montecarlo-test in
 *            the testsuite).
 *
 * Args:      cm         - the model to sample from
 *            nsample    - number of Monte Carlo sampled parsetrees
 *            Z          - maximum subsequence length in densities
 *            ret_gamma  - RETURN: gamma[v][n], [0..M-1][0..Z] as
 *                         unnormalized observed counts.
 *
 * Returns:   1 on success.
 *            0 on failure: one or more samples had a length too great to be
 *              captured by Z.
 *
 *            Caller frees the returned gamma with FreeBandDensities().
 *
 * Note:     Dies (cm_Fail()) from memory allocation error, without
 *           cleanup.
 */
int
BandMonteCarlo(CM_t *cm, int nsample, int Z, double ***ret_gamma)
{
  Parsetree_t  *tr;             /* sampled parsetree */
  double      **gamma;          /* RETURN: the densities */
  int           i;		/* counter over samples */
  int           seqlen;		/* length of sampled sequence */
  int           tidx;		/* index on parsetree */
  int           v;		/* state used at a parsetree node */
  int           n;		/* subseq length at a parsetree node */
  int           status;		/* return status. */
  char         *name;           /* name for the seq we've emitted */
  ESL_RANDOMNESS  *r = NULL;    /* source of randomness */
  int           namelen;        /* max int size for name */
  char errbuf[eslERRBUFSIZE];

  /* Create and seed RNG */
  if ((r = esl_randomness_CreateTimeseeded()) == NULL)
	cm_Fail("Failed to create random number generator: probably out of memory");

  /* Allocate gamma, completely; and initialize to zeros.
   * For consistency w/ BandCalculationEngine(), allocate a single
   * shared end deck at M-1, and point other ends at it - even
   * though P(n=0) = 1.0 by definition at the E's and we don't
   * really need to calculate it. Then we can use FreeBandDensities()
   * for gamma matrices alloc'ed in either function.
   */
  ESL_ALLOC(gamma, (sizeof(double *) * cm->M));
  ESL_ALLOC(gamma[cm->M-1], (sizeof(double) * (Z+1)));
  esl_vec_DSet(gamma[cm->M-1], Z+1, 0.0);
  for (v = 0; v < cm->M-1; v++)
	{
	  if (cm->sttype[v] != E_st)
	{
	  ESL_ALLOC(gamma[v], sizeof(double) * (Z+1));
	  esl_vec_DSet(gamma[v], Z+1, 0.0);
	}
	  else
	gamma[v] = gamma[cm->M-1];
	}

  namelen = 3 + IntMaxDigits() + 1;  /* IntMaxDigits() returns number of digits in INT_MAX */

  /* Count Monte Carlo samples of subsequence lengths for
   * all nodes of sampled parsetrees.
   */
  status = 1;
  for (i = 0; i < nsample; i++)  {
	ESL_ALLOC(name, sizeof(char) * namelen);
	sprintf(name, "seq%d", i+1);
	if(EmitParsetree(cm, errbuf, r, NULL, FALSE, &tr, NULL, &seqlen) != eslOK) cm_Fail(errbuf);
	free(name);
	if (seqlen > Z) {
	  FreeParsetree(tr);
	  status = 0;		/* set status to FAILED */
	  continue;
	}

	/* The parsetree, though it's a tree, is stored as an
	 * array - so traversing it in preorder is trivial. It's
	 * already arranged in preorder.
	 */
	for (tidx = 0; tidx < tr->n; tidx++)
	  {
	v = tr->state[tidx];
	n = (cm->sttype[v] == E_st) ? 0 : tr->emitr[tidx] - tr->emitl[tidx] + 1;
	gamma[v][n] += 1.;
	  }
	FreeParsetree(tr);
  }

  /* Return gamma, the observed counts (unnormalized densities).
   */
  *ret_gamma = gamma;
  esl_randomness_Destroy(r);
  ESL_DPRINTF1(("Returning %d from BandMonteCarlo() (1 is passed, 0 failed)\n", status));
  return status;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return eslFAIL; /* never reached */
}

/* Function:  FreeBandDensities()
 * Incept:    SRE, Thu Oct 16 08:30:47 2003 [St. Louis]
 *
 * Purpose:   Free a gamma[] array that was returned by BandCalculationEngine().
 *            Best to handle this with a special function because of the reuse
 *            of the END rows - only cm->M-1 is actually allocated, and other
 *            ENDs just point at that one. Too easy to double free() if we
 *            leave this tricky business to the caller.
 *
 * Args:      cm    - the model we build the band densities, gamma[], for.
 *            gamma - the band densities. Doesn't matter if this is a full
 *                    or partial (ret_gamma in BandCalculationEngine() was
 *                    non-NULL or NULL.)
 *
 * Returns:   (void)
 *
 * Xref:      STL7 p130.
 */
void
FreeBandDensities(CM_t *cm, double **gamma)
{
  int v;
  for (v = 0; v < cm->M; v++)
	if (cm->sttype[v] != E_st && gamma[v] != NULL)
	  { free(gamma[v]); gamma[v] = NULL; }
  free(gamma[cm->M-1]);		/* free the end state */
  free(gamma);
}

/* A couple of quick hacks. ...
 * Print an XMGRACE xy file for a specified v, showing the
 * cumulative distribution. Needed this for the R01 renewal.
 * SRE, Wed Feb 19 08:35:32 2003
 */
void
PrintBandGraph(FILE *fp, double **gamma, int *min, int *max, int v, int Z)
{
  int n;

  for (n = 0; n <= Z; n++)
	fprintf(fp, "%d %.6f\n", n, gamma[v][n]);
  fprintf(fp, "&\n");
  fprintf(fp, "%d  0\n",   min[v]);
  fprintf(fp, "%d  1.0\n", min[v]);
  fprintf(fp, "&\n");
  fprintf(fp, "%d  0\n",   max[v]);
  fprintf(fp, "%d  1.0\n", max[v]);
  fprintf(fp, "&\n");
}
/* ... and, estimate the total savings in DP cells filled.
 */
void
PrintDPCellsSaved(CM_t *cm, int *min, int *max, int W)
{
  int v;
  int after, before;

  before = after = 0;
  for (v = 0; v < cm->M; v++)
	{
	  if (cm->sttype[v] != E_st) {
	after  += max[v] - min[v] + 1;
	before += W;
	  }
	}
  printf("Before:  something like %d\n", before);
  printf("After:   something like %d\n", after);
  printf("Speedup: maybe %.2f fold\n", (float) before / (float) after);
}

/* EPN 07.22.05
 * ExpandBands()
 * Function: ExpandBands
 *
 * Purpose:  Called when the sequence we are about to align
 *           using bands is either shorter in length than
 *           the dmin on the root state, or longer in length
 *           than the dmax on the root state.
 *
 *           This function expands the bands on ALL states
 *           v=1..cm->M-1 in the following manner :
 *
 *           case 1 : target len < dmin[0]
 *                    subtract (dmin[0]-target len) from
 *                    dmin of all states, and ensure
 *                    dmin[v]>=0 for all v.
 *                    Further :
 *                    if cm->sttype[v] == MP_st ensure dmin[v]>=2;
 *                    if cm->sttype[v] == IL_st || ML_st ensure dmin[v]>=1;
 *                    if cm->sttype[v] == IR_st || MR_st ensure dmin[v]>=1;
 *
 *           case 2 : target len > dmax[0]
 *                    add (target len-dmax[0] to dmax
 *                    of all states.
 *
 *           Prior to handling such situtations with this
 *           hack, the program would choke and die.  This
 *           hacky approach is used as a simple, inefficient
 *           not well thought out, but effective way to
 *           solve this problem.
 *
 * Args:    cm       - the CM
 *          tlen     - length of target sequence about to be aligned
 *          dmin     - minimum d bound for each state v; [0..v..M-1]
 *                     may be modified in this function
 *          dmax     - maximum d bound for each state v; [0..v..M-1]
 *                     may be modified in this function
 *
 * Returns: (void)
 */

void
ExpandBands(CM_t *cm, int tlen, int *dmin, int *dmax)
{
  int v;
  int diff;
  int root_min;
  int root_max;
  int M = cm->M;
  root_min = dmin[0];
  root_max = dmax[0];

  if(tlen < root_min)
	{
	  diff = root_min - tlen;
	  for(v=0; v<M; v++)
	{
	  dmin[v] -= diff;
	  if((cm->sttype[v] == MP_st) && (dmin[v] < 2))
	    dmin[v] = 2;
	  else if(((cm->sttype[v] == IL_st) || (cm->sttype[v] == ML_st))
		  && (dmin[v] < 1))
	    dmin[v] = 1;
	  else if(((cm->sttype[v] == IR_st) || (cm->sttype[v] == MR_st))
		  && (dmin[v] < 1))
	    dmin[v] = 1;
	  else if(dmin[v] < 0)
	    dmin[v] = 0;
	}
	}
  else if(tlen > root_max)
	{
	  diff = tlen - root_min;
	  for(v=0; v<M; v++)
	{
	  dmax[v] += diff;
	}
	}
}

/* EPN 08.15.05
 * qdb_trace_info_dump()
 * Function: qdb_trace_info_dump
 *
 * Purpose:  Called when the user has enabled the --banddump
 *           options.  This function determines how close the
 *           trace was to the bands at each state in the trace,
 *           and prints out that information in differing levels
 *           of verbosity depending on an input parameter
 *           (bdump_level).
 *
 * Args:    tr       - the parsetree (trace)
 *          dmin     - minimum d bound for each state v; [0..v..M-1]
 *                     may be modified in this function
 *          dmax     - maximum d bound for each state v; [0..v..M-1]
 *                     may be modified in this function
 *          bdump_level - level of verbosity
 * Returns: (void)
 */

void
qdb_trace_info_dump(CM_t *cm, Parsetree_t *tr, int *dmin, int *dmax, int bdump_level)
{
  int    status;
  char **sttypes;
  char **nodetypes;
  int v, i, j, d, tpos;
  int mindiff;            /* d - dmin[v] */
  int maxdiff;            /* dmax[v] - d */

  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  for (tpos = 0; tpos < tr->n; tpos++)
	{
	  v  = tr->state[tpos];
	  i = tr->emitl[tpos];
	  j = tr->emitr[tpos];
	  d = j-i+1;

	  if(cm->sttype[v] != EL_st)
	{
	  mindiff = d-dmin[v];
	  maxdiff = dmax[v]-d;
	  if(bdump_level > 1 || ((mindiff < 0) || (maxdiff < 0)))
	    printf("%-4s %-3s v: %4d | d: %4d | dmin: %4d | dmax: %4d | %3d | %3d |\n", nodetypes[(int) cm->ndtype[(int) cm->ndidx[v]]], sttypes[(int) cm->sttype[v]], v, d, dmin[v], dmax[v], mindiff, maxdiff);
	}
	  else
	{
	  if(bdump_level > 1)
	    printf("%-8s v: %4d | d: %4d |\n", sttypes[(int) cm->sttype[v]], v, d);
	}
	}
  free(sttypes);
  free(nodetypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function: CreateCMQDBInfo()
 * Date:     EPN, Sat Dec 10 06:24:53 2011
 *
 * Purpose:  Allocate and initialize a CM_QDBINFO object
 *           given <M> the number of states in the CM
 *           we'll use the QDBs for.
 *
 * Returns:  Newly allocated CM_QDBINFO object. NULL if out
 *           of memory.
 */
CM_QDBINFO *
CreateCMQDBInfo(int M, int clen)
{
  int status;
  CM_QDBINFO *qdbinfo = NULL;
  ESL_ALLOC(qdbinfo, sizeof(CM_QDBINFO));

  qdbinfo->M = M;

  qdbinfo->beta1 = DEFAULT_BETA_QDB1;
  ESL_ALLOC(qdbinfo->dmin1, sizeof(int) * M);
  ESL_ALLOC(qdbinfo->dmax1, sizeof(int) * M);
  esl_vec_ISet(qdbinfo->dmin1, M, 0);
  esl_vec_ISet(qdbinfo->dmax1, M, clen*2);

  qdbinfo->beta2 = DEFAULT_BETA_QDB2;
  ESL_ALLOC(qdbinfo->dmin2, sizeof(int) * M);
  ESL_ALLOC(qdbinfo->dmax2, sizeof(int) * M);
  esl_vec_ISet(qdbinfo->dmin2, M, 0);
  esl_vec_ISet(qdbinfo->dmax2, M, clen*2);

  qdbinfo->setby = CM_QDBINFO_SETBY_INIT;

  return qdbinfo;

 ERROR:
  if(qdbinfo != NULL) FreeCMQDBInfo(qdbinfo);
  return NULL;
}

/* Function: SizeofCMQDBInfo()
 * Date:     EPN, Wed Jan 18 05:01:42 2012
 *
 * Purpose:  Determine and return the size of
 *           a CM_QDBINFO object in Mb.
 *
 * Returns:  Size of the CM_QDBINFO object in Mb.
 */
float
SizeofCMQDBInfo(CM_QDBINFO *qdbinfo)
{
  float bytes;

  if(qdbinfo == NULL) return 0.;

  bytes = sizeof(CM_QDBINFO);
  bytes += sizeof(int) * qdbinfo->M; /* dmin1 */
  bytes += sizeof(int) * qdbinfo->M; /* dmax1 */
  bytes += sizeof(int) * qdbinfo->M; /* dmin2 */
  bytes += sizeof(int) * qdbinfo->M; /* dmax2 */

  bytes *= 0.000001; /* convert to Mb */

  return bytes;
}

/* Function: FreeCMQDBInfo()
 * Date:     EPN, Sat Dec 10 06:31:12 2011
 *
 * Purpose:  Free a CM_QDBINFO object.
 *
 * Returns:  void
 */
void
FreeCMQDBInfo(CM_QDBINFO *qdbinfo)
{
  if(qdbinfo == NULL) return;

  if(qdbinfo->dmin1 != NULL) free(qdbinfo->dmin1);
  if(qdbinfo->dmax1 != NULL) free(qdbinfo->dmax1);
  if(qdbinfo->dmin2 != NULL) free(qdbinfo->dmin2);
  if(qdbinfo->dmax2 != NULL) free(qdbinfo->dmax2);

  free(qdbinfo);
  return;
}

/* Function:  CopyCMQDBInfo()
 * Synopsis:  Copy a CM_QDBINFO object.
 * Date:      EPN, Sat Dec 10 06:55:17 2011
 *
 * Purpose:   Copies qdbinfo <src> to qdbinfo <dst>, where <dst>
 *            has already been allocated to be of sufficient size.
 *
 * Returns:   <eslOK> on success.
 * Throws:    <eslEINVAL> if <dst> is too small
 *            to fit <src>, errbuf is filled.
 */
int
CopyCMQDBInfo(const CM_QDBINFO *src, CM_QDBINFO *dst, char *errbuf)
{
  if (src->M != dst->M) ESL_FAIL(eslEINVAL, errbuf, "destination qdbinfo not equal to size of source qdbinfo");

  dst->beta1 = src->beta1;
  esl_vec_ICopy(src->dmin1, src->M, dst->dmin1);
  esl_vec_ICopy(src->dmax1, src->M, dst->dmax1);

  dst->beta2 = src->beta2;
  esl_vec_ICopy(src->dmin2, src->M, dst->dmin2);
  esl_vec_ICopy(src->dmax2, src->M, dst->dmax2);

  dst->setby = src->setby;

  return eslOK;
}

/* Function:  qdbinfo_setby_to_string()
 * Date:      EPN, Tue Dec 13 09:55:42 2011
 */
char *
qdbinfo_setby_to_string(int setby)
{
  switch (setby) {
  case CM_QDBINFO_SETBY_INIT:     return "CM_QDBINFO_SETBY_INIT";
  case CM_QDBINFO_SETBY_CMFILE:   return "CM_QDBINFO_SETBY_CMFILE";
  case CM_QDBINFO_SETBY_BANDCALC: return "CM_QDBINFO_SETBY_BANDCALC";
  case CM_QDBINFO_SETBY_SUBINIT:  return "CM_QDBINFO_SETBY_SUBINIT";
  default: cm_Fail("bogus CM_QDBINFO_SETBY type: %d\n", setby);
  }
  return ""; /* NEVERREACHED */
}

/* Function:  DumpCMQDBInfo()
 * Synopsis:  Print contents of a CM_QDBINFO object to <fp>.
 * Date:      EPN, Tue Dec 13 09:52:05 2011
 *
 * Returns:   void.
 */
void
DumpCMQDBInfo(FILE *fp, CM_t *cm, CM_QDBINFO *qdbinfo)
{
  int v;

  fprintf(fp, "CM_QDBINFO dump\n");
  fprintf(fp, "------------------\n");
  fprintf(fp, "# M:        %d\n", qdbinfo->M);
  fprintf(fp, "# setby:    %s\n", qdbinfo_setby_to_string(qdbinfo->setby));
  fprintf(fp, "# beta1:    %g\n", qdbinfo->beta1);
  fprintf(fp, "# beta2:    %g\n", qdbinfo->beta2);
  fprintf(fp, "# %8s  %8s  %6s  %6s    %5s  %5s  %5s  %5s    %5s  %5s\n", "stidx(v)", "ndidx",    "ndtype", "sttype", "dmin2","dmin1", "dmax1", "dmax2", "bwd1",  "bwd2");
  fprintf(fp, "# %8s  %8s  %6s  %6s    %5s  %5s  %5s  %5s    %5s  %5s\n", "--------", "--------", "------", "------", "-----", "----", "-----", "-----", "------","-----");
  for(v = 0; v < cm->M; v++) {
	fprintf(fp, "  %8d  %8d  %-6s  %-6s    %5d  %5d  %5d  %5d    %5d  %5d\n", v, cm->ndidx[v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]),
	    qdbinfo->dmin2[v], qdbinfo->dmin1[v], qdbinfo->dmax1[v], qdbinfo->dmax2[v],
	    qdbinfo->dmax1[v] - qdbinfo->dmin1[v] + 1, qdbinfo->dmax2[v] - qdbinfo->dmin2[v] + 1);
  }
  fprintf(fp, "//\n");
  return;
}

/* Function:  CheckCMQDBInfo()
 * Synopsis:  Check if QDBs in CM_QDBINFO need to be recalculated.
 * Date:      EPN, Tue Dec 13 13:39:06 2011
 *
 * Purpose:   Check if beta values in a CM_QDBINFO object are equal to
 *            passed in beta values. If <do_check1>, we check if
 *            cm->qdbinfo->beta1 == <beta1> and if <do_check2>, we
 *            check if cm->qdbinfo->beta2 == <beta2>. We return eslOK
 *            if neither check fails and eslFAIL if one or both
 *            does. As a special case if cm->qdbinfo->setby ==
 *            CM_QDBINFO_SETBY_INIT then we always return eslFAIL
 *            because it means the QDBs in cm->qdbinfo are in their
 *            initialized state and haven't yet been calculated.
 *
 * Returns:   eslOK   if we don't need to recalculate the QDBs in cm->qdbinfo
 *            eslFAIL if we do    need to recalculate the QDBs in cm->qdbinfo
 */
int
CheckCMQDBInfo(CM_QDBINFO *qdbinfo, double beta1, int do_check1, double beta2, int do_check2)
{
  if(qdbinfo->setby == CM_QDBINFO_SETBY_INIT)    return eslFAIL;
  if(qdbinfo->setby == CM_QDBINFO_SETBY_SUBINIT) return eslFAIL;

  if(do_check1) {
	if(fabs(qdbinfo->beta1 - beta1) > 1E-20) return eslFAIL;
  }
  if(do_check2) {
	if(fabs(qdbinfo->beta2 - beta2) > 1E-20) return eslFAIL;
  }

  return eslOK;
}

/*** End of inlined file: cm_qdband.c ***/


/*** Start of inlined file: cm_submodel.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


static void  map_orig2sub_cm(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int print_flag);
static int   map_orig2sub_cm_helper(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int orig_v, int sub_v);
static int   cm2sub_cm_check_id_next_node(CM_t *orig_cm, CM_t *sub_cm, int orig_nd, int sub_nd,
					  CMSubMap_t *submap, CP9Map_t *orig_cp9map, CP9Map_t *sub_cp9map,
					  int print_flag);
static void  cm2sub_cm_emit_probs(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, int v_s, int v_o1, int v_o2,
				  CMSubMap_t *submap);
static void  cm2sub_cm_trans_probs(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_s,
				   CMSubMap_t *submap);
static void  cm2sub_cm_trans_probs_S(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_start,
				     CMSubMap_t *submap);
static void  cm2sub_cm_trans_probs_B_E(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_end,
				       CMSubMap_t *submap, int print_flag);
static void  cm2sub_cm_add_single_trans(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int orig_v, int orig_y,
					int sub_v, int yoffset, double *orig_psi, char ***tmap);
static float cm2sub_cm_sum_subpaths(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int start, int end,
				    int init_sub_start, char ***tmap, double *orig_psi);
static int   cm_trans_check(CM_t *cm, int a, int b);
static void  cm2sub_cm_subtract_root_subpaths(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap,
					      CMSubMap_t *submap, int print_flag);
static void  cm2sub_cm_find_impossible_misc_cases(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CMSubInfo_t *subinfo,
						  CP9Map_t *orig_cp9map, CP9Map_t *sub_cp9map, int print_flag);
static void  cm2sub_cm_find_impossible_matr_cases(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CMSubInfo_t *subinfo,
						  CP9Map_t *orig_cp9map, CP9Map_t *sub_cp9map, int print_flag);

/**************************************************************************
 * EPN 10.25.06
 * Function: AllocSubMap()
 *
 * Purpose:  Determine maps between a template CM and a sub CM, which probably
 *           has less structure (less MATP nodes) than the template. Do this
 *           a bit indirectly, first get maps from each CM to a CP9 HMM,
 *           then use these maps to map the CMs to each other.
 *           See infernal.h for more info on the submap data structure.
 *
 * Args
 * CM_t *sub_cm        - the sub CM
 * CM_t *orig_cm       - the original template CM
 * int sstruct         - the first (leftmost)  consensus posn we're keeping structure for
 * int estruct         - the last  (rightmost) consensus posn we're keeping structure for
 */

CMSubMap_t *
AllocSubMap(CM_t *sub_cm, CM_t *orig_cm, int sstruct, int estruct)
{
  CMSubMap_t  *submap;
  int v;
  int status;

  ESL_ALLOC(submap, sizeof(struct submap_s));

  submap->sub_M  = sub_cm->M;
  submap->orig_M = orig_cm->M;
  /* Determine clen of the orig_cm */
  submap->orig_clen = 0;
  for(v = 0; v <= orig_cm->M; v++)
	{
	  if(orig_cm->stid[v] ==  MATP_MP)
	submap->orig_clen += 2;
	  else if(orig_cm->stid[v] == MATL_ML || orig_cm->stid[v] == MATR_MR)
	submap->orig_clen++;
	}
  submap->sstruct = sstruct;
  submap->estruct = estruct;
  submap->sub_clen = (submap->estruct-submap->sstruct+1);
  submap->spos     = submap->sstruct;
  submap->epos     = submap->estruct;

  /* Allocate and initialize arrays */
  ESL_ALLOC(submap->s2o_id,   sizeof(int) *   (sub_cm->M+1));
  ESL_ALLOC(submap->s2o_smap, sizeof(int *) * (sub_cm->M+1));
  for(v = 0; v <= sub_cm->M; v++)
	{
	  submap->s2o_id[v]      = FALSE;
	  ESL_ALLOC(submap->s2o_smap[v], sizeof(int) * 2);
	  submap->s2o_smap[v][0] = -1;
	  submap->s2o_smap[v][1] = -1;
	}

  ESL_ALLOC(submap->o2s_smap, sizeof(int *) * (orig_cm->M+1));
  for(v = 0; v <= orig_cm->M; v++)
	{
	  ESL_ALLOC(submap->o2s_smap[v], sizeof(int) * 2);
	  submap->o2s_smap[v][0] = -1;
	  submap->o2s_smap[v][1] = -1;
	}
  return submap;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function: FreeSubMap()
 * Returns: (void)
 */

void
FreeSubMap(CMSubMap_t *submap)
{
  int v;
  for(v = 0; v <= submap->sub_M; v++)
	free(submap->s2o_smap[v]);
  free(submap->s2o_smap);
  for(v = 0; v <= submap->orig_M; v++)
	free(submap->o2s_smap[v]);
  free(submap->o2s_smap);
  free(submap->s2o_id);
  free(submap);
}

/**************************************************************************
 * EPN 10.26.06
 * Function: AllocSubInfo()
 *
 * Purpose:  Store information about a sub CM that is useful for testing
 *           if it constructed correctly.
 *
 * Args:
 * int clen;           - consensus length of the sub_cm
 * Returns: CMSubInfo_t
 */

CMSubInfo_t *
AllocSubInfo(int clen)
{
  int status;
  CMSubInfo_t  *subinfo;
  int i;
  int ncases;

  ESL_ALLOC(subinfo, sizeof(struct subinfo_s));
  /* Allocate and initialize arrays */
  ESL_ALLOC(subinfo->imp_cc, sizeof(int) * (clen + 2));
  for(i = 0; i <= clen+1; i++)
	subinfo->imp_cc[i] = FALSE;

  /* 6 possible cases for predicting we get HMM distros wrong */
  ncases = 6;
  ESL_ALLOC(subinfo->apredict_ct, sizeof(int) * (ncases+1));
  ESL_ALLOC(subinfo->spredict_ct, sizeof(int) * (ncases+1));
  ESL_ALLOC(subinfo->awrong_ct,   sizeof(int) * (ncases+1));
  ESL_ALLOC(subinfo->swrong_ct,   sizeof(int) * (ncases+1));
  for(i = 0; i <= ncases; i++)
	{
	  subinfo->apredict_ct[i] = 0;
	  subinfo->spredict_ct[i] = 0;
	  subinfo->awrong_ct[i]   = 0;
	  subinfo->swrong_ct[i]   = 0;
	}
  return subinfo;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function: FreeSubInfo()
 * Returns:  void
 */

void
FreeSubInfo(CMSubInfo_t *subinfo)
{
  free(subinfo->imp_cc);
  free(subinfo->apredict_ct);
  free(subinfo->spredict_ct);
  free(subinfo->awrong_ct);
  free(subinfo->swrong_ct);
  free(subinfo);
}

/**************************************************************************
 * EPN 09.22.06
 * Function: map_orig2sub_cm()
 *
 * Purpose:  Determine maps between a template CM and a sub CM, which probably
 *           has less structure (less MATP nodes) than the template. Do this
 *           a bit indirectly, first get maps from each CM to a CP9 HMM,
 *           then use these maps to map the CMs to each other.
 * Args:
 * CM_t *orig_cm       - the original template CM
 * CM_t *sub_cm        - the sub CM
 * CMSubMap_t *submap  - the sub CM map
 * int print_flag      - TRUE to print out useful debugging info
 * Returns: (void)
 */
void
map_orig2sub_cm(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int print_flag)
{
  int status;
  int k_s;  /* HMM node counter */
  int v_o;
  int v_s;
  int v; /* state index in CM */
  int n_o;
  int n_s;
  char **nodetypes;
  char **sttypes;
  int sub_k;
  int orig_k;
  int sub_nd;
  int orig_nd;
  int x, y;
  CP9Map_t *orig_cp9map;
  CP9Map_t *sub_cp9map;

  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  /* sanity check */
  if(sub_cm->M > orig_cm->M)
	cm_Fail("ERROR: sub_cm has more states than orig_cm in map_orig2sub_cm()\n");

  /* We want maps from the orig_cm to a CP9 HMM and from the
   * sub_cm to a CP9 HMM, but we don't need the actual HMMs, just
   * the maps. */
  /* Allocate and initialize the cp9maps */
  orig_cp9map = AllocCP9Map(orig_cm);
  sub_cp9map  = AllocCP9Map(sub_cm);
  /* Map the CM states to CP9 states and nodes, and vice versa */
  CP9_map_cm2hmm(orig_cm, orig_cp9map, print_flag);
  CP9_map_cm2hmm(sub_cm,  sub_cp9map,  print_flag);

  /* Step through the consensus columns, filling in maps */
  /* ROOT is special: */
  v_s = 0; /* ROOT_S */
  v_o = 0; /* ROOT_S */
  map_orig2sub_cm_helper(orig_cm, sub_cm, submap, v_o, v_s);

  /* ROOT_IL inserts before orig cc submap->spos */
  k_s = 1; /* insert */
  for(x = 0; x <= 1; x++)
	for(y = 0; y <= 1; y++)
	  map_orig2sub_cm_helper(orig_cm, sub_cm, submap,
			     orig_cp9map->hns2cs[submap->spos-1][k_s][x],
			     sub_cp9map->hns2cs[0][k_s][y]);

  /* ROOT_IR inserts after orig cc submap->epos */
  k_s = 1; /* insert */
  for(x = 0; x <= 1; x++)
	for(y = 0; y <= 1; y++)
	  map_orig2sub_cm_helper(orig_cm, sub_cm, submap,
			     orig_cp9map->hns2cs[submap->epos][k_s][x],
			     sub_cp9map->hns2cs[submap->epos-submap->spos+1][k_s][y]);

  for(sub_k = 1; sub_k <= sub_cp9map->hmm_M; sub_k++)
	{
	  orig_k = sub_k + submap->spos - 1;
	  sub_nd  = sub_cp9map->pos2nd[sub_k];
	  orig_nd = orig_cp9map->pos2nd[orig_k];

	  /* Check for an easy case to save time in the future: when
	   * the orig_cm and sub_cm nodes that map to this column are
	   * of the same type, and also the orig_cm and sub_cm nodes
	   * that map to the next column are also of the same type.
	   * We check for this in cm2sub_cm_check_id_next_node() if TRUE,
	   * then submap->s2o_id[sub_v] is set to TRUE for all states
	   * in this node. Later this will save time by just copying
	   * transition and emission parameters from the orig_cm for
	   * these states.
	   */
	  cm2sub_cm_check_id_next_node(orig_cm, sub_cm, orig_nd, sub_nd, submap, orig_cp9map,
				   sub_cp9map, print_flag);
	  for(k_s = 0; k_s < 3; k_s++) /* k_s = 0 (match), k_s = 1 (insert),
				      k_s = 2 (delete) */
	for(x = 0; x <= 1; x++)
	  for(y = 0; y <= 1; y++)
	    map_orig2sub_cm_helper(orig_cm, sub_cm, submap,
				   orig_cp9map->hns2cs[orig_k][k_s][x],
				   sub_cp9map->hns2cs[sub_k][k_s][y]);
	}
  /* NOTE: We ignore mapping B states, E states and S states (except ROOT_S). We'll handle these guys
   * specially when we fill in transition probabilities. The reason we don't map them is that
   * I think its impossible to do it robustly. I saw cases with SSU where there were BIF nodes in the
   * sub_cm for which I couldn't figure out which BIF nodes (and correspondingly BEGL and BEGR nodes)
   * in the orig_cm they should map to. Regardless, even if there is a pretty, nice way I'm abandoning
   * an attempt to find it for a crude way - we will handle the transitions involving these guys
   * specially, without a need for a mapping between CMs.
   */

  /* If we're in debugging mode and print_flag == TRUE, we print and check the map */
  if(print_flag)
	{
	  /* First print submap->s2o_id */
	  for(v = 0; v <= sub_cm->M; v++)
	if(submap->s2o_id[v] == TRUE)
	  printf("submap->s2o_id[%d] TRUE\n", v);
	else
	  printf("submap->s2o_id[%d] FALSE\n", v);

	  printf("\n\n\nMAP\n\n\n");
	  for(v_s = 0; v_s < sub_cm->M; v_s++)
	{
	  n_s = sub_cm->ndidx[v_s];
	  v_o = submap->s2o_smap[v_s][0];
	  if(sub_cm->sttype[v_s] == E_st)
	    printf("sub v:%4d   END\n", v_s);
	  if(sub_cm->sttype[v_s] == S_st)
	    printf("sub v:%4d   START\n", v_s);
	  if(sub_cm->sttype[v_s] == B_st)
	    printf("sub v:%4d   BIF_B\n", v_s);
	  if((sub_cm->sttype[v_s] != B_st &&
	      sub_cm->sttype[v_s] != S_st) &&
	     sub_cm->sttype[v_s] != E_st)
	    {
	      if(v_o == -1 && sub_cm->sttype[(v_s+1)] == E_st) /* v_s is a dead insert */
		continue;
	      if(v_o == -1 && sub_cm->sttype[v_s] != E_st)
		cm_Fail("ERROR sub_cm state: %d type: %s node type: %s doesn't map to any state in orig_cm\n", v_s, sttypes[(int) sub_cm->sttype[v_s]], nodetypes[(int) sub_cm->ndtype[n_s]]);

	      n_o = orig_cm->ndidx[v_o];
	      if(print_flag) printf("sub v:%4d(%4d) %6s%6s | orig v:%4d(%4d) %6s%6s\n", v_s, n_s, nodetypes[(int) sub_cm->ndtype[n_s]], sttypes[(int) sub_cm->sttype[v_s]], v_o, n_o, nodetypes[(int) orig_cm->ndtype[n_o]], sttypes[(int) orig_cm->sttype[v_o]]);
	      /* check to make sure submap->o2s_smap is consistent */
	      if(submap->o2s_smap[v_o][0] != v_s && submap->o2s_smap[v_o][1] != v_s)
		cm_Fail("ERROR inconsistency; neither o2s_smap[%d][0] and [1] is %d\n", v_o, v_s);

	      v_o = submap->s2o_smap[v_s][1];
	      if(v_o != -1)
		{
		  n_o = orig_cm->ndidx[v_o];
		  if(print_flag) printf("                              | orig v:%4d(%4d) %6s%6s\n", v_o, n_o, nodetypes[(int) orig_cm->ndtype[n_o]], sttypes[(int) orig_cm->sttype[v_o]]);
		  /* check to make sure o2s_smap is consistent */
		  if(submap->o2s_smap[v_o][0] != v_s && submap->o2s_smap[v_o][1] != v_s)
		    {
		      cm_Fail("ERROR inconsistency; neither o2s_smap[%d][0] and [1] is %d\n", v_o, v_s);
		    }
		}
	    }
	}
	}

  /* Clean up and return */
  FreeCP9Map(orig_cp9map);
  FreeCP9Map(sub_cp9map);
  free(sttypes);
  free(nodetypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 08.30.06
 * map_orig2sub_cm_helper()
 *
 * helper function for map_orig2sub_cm(),
 *
 * Purpose:  Fill in specific part of the map, given orig_v (orig_cm state),
 *           sub_v (sub_cm state)
 * Args:
 * CM_t *orig_cm
 * CM_t *sub_cm
 * CMSubMap_t *submap
 * int   orig_v;
 * int   sub_v;
 * Returns: 1 if a new mapping was made, 0 if not
 */
static int
map_orig2sub_cm_helper(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int orig_v, int sub_v)
{
  int sub_nd;
  int orig_nd;

  /*printf("\nin helper: orig_v: %d sub_v: %d\n", orig_v, sub_v);*/

  if(orig_v == -1 || sub_v == -1)
	return 0;

  /* check to see if we already have this mapping */
  if(submap->o2s_smap[orig_v][0] == sub_v || submap->o2s_smap[orig_v][1] == sub_v)
	return 0;

  orig_nd = orig_cm->ndidx[orig_v];
  sub_nd  =  sub_cm->ndidx[sub_v];

  if(sub_cm->sttype[sub_v] == IL_st || sub_cm->sttype[sub_v] == IR_st)
	{
	  /* Make sure that neither orig_v nor sub_v is a detached insert state,
	   * if either is, we return b/c it's irrelevant, and we don't store that info in the maps */
	  if(orig_cm->sttype[(orig_v+1)] == E_st || sub_cm->sttype[(sub_v+1)] == E_st)
	return 0;
	}
  /* 09.14.06  I think that some of the code that checks for cases where we wnat to avoid mapping is unnecessary!,
   * but I'm not sure what...*/

  /* Check for a case we want to avoid mapping. We exploit the fact that we know a MATP_nd in a sub_cm MUST be mapped
   * to a corresponding MATP_nd in the original template CM: */
  if(sub_cm->ndtype[sub_nd] == MATP_nd)
	if(orig_cm->ndtype[orig_nd] == MATP_nd && sub_cm->sttype[sub_v] != orig_cm->sttype[orig_v])
	  return 0;

  /* Fill in submap->o2s_smap */
  if(submap->o2s_smap[orig_v][0] == -1)
	{
	  if (submap->o2s_smap[orig_v][1] != -1)
	cm_Fail("ERROR in map_orig2sub_cm_helper, submap->o2s_smap[%d][0] is -1 but submap->o2s_smap[%d][1] is not, this shouldn't happen.\n", orig_v, orig_v);
	  else
	submap->o2s_smap[orig_v][0] = sub_v;
	}
  else if (submap->o2s_smap[orig_v][1] != -1)
	{
	  if(submap->o2s_smap[orig_v][0] == sub_v || submap->o2s_smap[orig_v][1] == sub_v)
	/* abort!, we already have this mapping */
	return 0;
	  else
	cm_Fail("ERROR in map_orig2sub_cm_helper, submap->o2s_smap[%d][0] is not -1 and submap->o2s_smap[%d][1] is not -1, this shouldn't happen.\n", orig_v, orig_v);
	}
  else /* submap->o2s_smap[orig_v][0] != -1 && submap->o2s_smap[orig_v][1] == -1 */
	{
	  if(submap->o2s_smap[orig_v][0] == sub_v || submap->o2s_smap[orig_v][1] == sub_v)
	/* abort!, we already have this mapping */
	return 0;
	  submap->o2s_smap[orig_v][1] = sub_v;
	}

  /* now fill in submap->s2o_smap */
  if(submap->s2o_smap[sub_v][0] == -1)
	if (submap->s2o_smap[sub_v][1] != -1)
	  cm_Fail("ERROR in map_sub2orig_cm_helper, submap->s2o_smap[%d][0] is -1 but submap->s2o_smap[%d][1] is not, this shouldn't happen.\n", sub_v, sub_v);
	else
	  submap->s2o_smap[sub_v][0] = orig_v;
  else if (submap->s2o_smap[sub_v][1] != -1)
	cm_Fail("ERROR in map_sub2orig_cm_helper, submap->s2o_smap[%d][0] is not -1 and submap->s2o_smap[%d][1] is not -1, this shouldn't happen.\n", sub_v, sub_v);
  else /* submap->s2o_smap[sub_v][0] != -1 && submap->s2o_smap[sub_v][1] == -1 */
	submap->s2o_smap[sub_v][1] = orig_v;
  return 1;
}

/****************************************************************************
 * Function:  build_sub_cm()
 * EPN 08.28.06
 *
 * Purpose:   Given a template CM (orig_cm) built from an MSA of consensus columns
 *            1..M, build a new, "sub CM" (sub_cm), that only models well-nested base pairs
 *            that occur (have both left and right halves) between consensus columns
 *            [sstruct..estruct]. The sub_cm will only model the consensus
 *            columns between [sstruct..estruct].
 *
 *            We attempt to construct the sub CM such that:
 *
 *            1. All 'mapped' states in the orig_cm and sub_cm have identical
 *               'psi' values, i.e. the expected number of times entered in a single parse
 *               is identical.
 *
 *            2. Alignments sampled from it should 'follow the same probability distributions'
 *               as alignments sampled from the template CM and then truncated,
 *               removing columns outside [sstruct..estruct] Specifically, 'follow
 *               the same probability distributions' means if we built a ML HMM (Weinberg
 *               style) from the resulting infinite alignments, we would have identical
 *               HMMs for the sub-CM alignments and for the truncated template CMs. It turns
 *               out this is impossible for certain situations
 *               that cause differences in the topology of the orig_cm and sub_cm. These
 *               situations, so-called 'impossible cases', cause the distributions out of a
 *               single ML HMM node to be different between the orig_cm, but are relatively
 *               rare (a rough, rough estimate is 1% of ML HMM nodes are affected).  We can
 *               predict when all of these situations will occur, but sometimes when we
 *               predict a ML HMM node will be off in this way, it is in fact identical
 *               between the sub_cm and orig_cm for reasons I can't quite grasp.
 *
 *            This function builds a sub_cm and then potentially performs up to 3 checks
 *            to see if 1 and 2 above are satisfied (it only checks if 2 holds for
 *            non-impossible cases, and that we can accurately predict the impossible
 *            cases). The 3 potential checks are:
 *
 *            A. Calculate the expected number of times that each state in the orig_cm
 *               and sub_cm is entered (psi[v] = exp # times state v is entered), and
 *               make sure these values are within 'threshold' of each other for all
 *               states that map between the orig_cm and sub_cm. This is performed
 *               by the 'check_orig_psi_vs_sub_psi' function, which is called within
 *               this function if either the 'do_acheck' and/or 'do_scheck' parameters
 *               passed in are TRUE.
 *
 *            B. Analytically (not by sampling) building 2 ML HMMs, one from the orig_cm
 *               and one from the sub_cm, predicting the impossible cases and testing t
 *               o make sure all the corresponding parameters for non-impossible cases
 *               are within 'threshold' of each other. This is done within the
 *               check_sub_cm() function which is called from this function if the
 *               'do_acheck' parameter passed in is set to TRUE.
 *
 *            C. Build a CP9 ML HMM analytically from the sub_cm. Sample a deep MSA
 *               from the orig_cm and potentially truncate outside [sstruct..estruct]. Use
 *               counts from the MSA to build a ML HMM for the orig_cm. Then perform
 *               chi-squared tests to see if the counts in the orig_cm's HMM could
 *               have been generated by the distributions in the sub_cm's HMM. This
 *               check is performed if the 'do_scheck' parameter passed in is set
 *               to TRUE.
 *
 * Args:      orig_cm      - the original model, which we're going to (potentially)
 *                           remove some structure from
 *            errbuf       - for error messages
 *            ret_sub_cm   - the new sub_cm built from orig_cm with some structure removed.
 *            sstruct      - the first position (consensus column) we want to model
 *            estruct      - the last position we will model
 *            print_flag   - TRUE to print debugging statements
 *
 * Returns:   eslOK on success
 *            eslEINCONCEIVABLE if something inconceivable happens
 *            eslEINCOMPAT on contract violation
 *            eslEMEM on memory error
 */
int
build_sub_cm(CM_t *orig_cm, char *errbuf, CM_t **ret_cm, int sstruct, int estruct, CMSubMap_t **ret_submap, int print_flag)
{
  int              status;
  CM_t            *sub_cm;      /* new covariance model, a submodel of the template */
  CMConsensus_t   *con;         /* growing consensus info for orig_cm               */
  Parsetree_t     *mtr;         /* master structure tree from the alignment         */
  char            *sub_cstr;    /* consensus substructure display string            */
  int             *sub_ct;	/* 0..con->clen-1 base pair partners array          */
  int              cpos;        /* position counter within orig_cm                  */
  int              sub_cpos;    /* position counter within sub_cm                   */
  char          ***tmap;        /* hard-coded transition map, for convenience       */
  double          *orig_psi;    /* expected num times each state visited in orig_cm */
  int              v_s;         /* state counter for sub_cm                         */
  int              n_s;         /* node  counter for sub_cm                         */
  FILE            *ofp;         /* an open output file                              */
  int              spos;        /* first consensus (match) column of the orig_cm to
				 * model with the sub_cm */
  int              epos;        /* last consensus (match) column of the orig_cm to
				 * model with the sub_cm */
  CMSubMap_t *submap;

  /* check to make sure that we can actually build a sub CM of this model */
  if((orig_cm->flags & CMH_LOCAL_BEGIN) || (orig_cm->flags & CMH_LOCAL_END)) ESL_FAIL(eslEINCOMPAT, errbuf, "build_sub_cm() trying to build a sub CM of a CM already in local mode, not yet supported.\n");
  if(orig_cm->flags & CM_IS_SUB) ESL_FAIL(eslEINCOMPAT, errbuf, "build_sub_cm(), trying to build a sub CM of a CM that is itself a sub CM.");

  /* Much of the code for building and checking sub CMs relies on the fact that every insert
   * state in the sub CM maps exactly 1 insert state in the original CM. This is fine if we
   * have removed ambiguities by detaching all original CM insert states that are 1 state
   * before an END_E state. This was probably done when the CM was built, but we redo it here
   * in case it was not.
   */
  cm_find_and_detach_dual_inserts(orig_cm,
				  FALSE, /* DON'T check that these states have 0 counts (they may not due to priors) */
				  TRUE); /* DO detach END_E-1 insert states, making them unreachable */

  /* Get the consensus sequence and consensus structure information from the original CM */
  if((con = CreateCMConsensus(orig_cm, orig_cm->abc)) == NULL) ESL_FAIL(eslFAIL, errbuf, "build_sub_cm(), unable to create cm consensus data");
  if(print_flag)
	{
	  printf("con->cseq    : %s\n", con->cseq);
	  printf("con->cstr    : %s\n", con->cstr);
	  printf("clen         : %d\n", con->clen);
	}

  spos = sstruct;
  epos = estruct;

  /* Fill a new ct array for the sub_cm. The sub_cm will only model the consensus columns
   * between spos and epos, and only the structure between spos
   * and epos. First copy the template (original) CMs ct array but only for the
   * appropriate consensus columns that lie in between both structure and model boundarIes
   * Next, eliminate any structure that lies outside the structure boundaries.
   */

  ESL_ALLOC(sub_ct,  sizeof(int) * (epos - spos + 1));
  /* First just copy ct array for model boundaries from con->ct */
  for (cpos = (spos-1); cpos < epos; cpos++)
	{
	  sub_cpos = cpos - (spos-1);
	  if(con->ct[cpos] != -1 &&
	 (con->ct[cpos] <  (spos-1) ||
	  con->ct[cpos] >=  epos))
	sub_ct[sub_cpos] = -1;
	  else
	sub_ct[sub_cpos] = con->ct[cpos];
	}
  /* Second remove structure outside structural boundaries */
  for (cpos = (spos-1); cpos < epos; cpos++)
	{
	  sub_cpos = cpos - (spos-1);
	  if ((cpos+1) < sstruct || (cpos+1) > estruct) /* cpos goes 1..clen, but ct is indexed
						     * 0..clen-1.*/
	{
	  /* CreateCMConsensus() uses -1 in ct[] to indicate single
	   * stranded (different convention than WUSS2ct()). */
	  if (sub_ct[sub_cpos] != -1)
	    sub_ct[sub_ct[sub_cpos]] = -1;
	  sub_ct[sub_cpos] = -1;
	}
	}

  /* Construct the new structure ss_cons based on the template CM ct array.
   * We could do this similar to how display.c::CreateCMConsensus()
   * does it to get the fully formatted WUSS ([{<>}]) string but
   * lazily we just do <> bps here.
   */
  ESL_ALLOC(sub_cstr, sizeof(char) * (epos - spos + 2));
  for (cpos = (spos-1); cpos < epos; cpos++)
	{
	  sub_cpos = cpos - (spos-1);
	  if(sub_ct[sub_cpos] == -1)         sub_cstr[sub_cpos] = '.';
	  else if (sub_ct[sub_cpos]  > cpos) sub_cstr[sub_cpos] = '<';
	  else if (sub_ct[sub_cpos]  < cpos) sub_cstr[sub_cpos] = '>';
	  else cm_Fail("ERROR: weird error in build_sub_cm()\n");
	}
  sub_cstr[(epos-spos+1)] = '\0';

  /* Build the new sub_cm given the new consensus structure. But don't
   * parameterize it yet.
   */
  if((status = ConsensusModelmaker(orig_cm->abc, errbuf, sub_cstr, (epos-spos+1), TRUE, &sub_cm, &mtr)) != eslOK) return status;
  /* TRUE in ConsensusModelmaker() call says 'yes, we're building a sub CM, allow invalid CMs in cm_from_guide() (see comments in that function for details)*/

  /* Set creation time */
  if ((status = cm_SetCtime(sub_cm)) != eslOK)  ESL_FAIL(status, errbuf, "Failed to record timestamp");

  /* Rebalance the CM for optimization of D&C */
  CM_t *new;
  if((status = CMRebalance(sub_cm, errbuf, &new)) != eslOK) return status;
  FreeCM(sub_cm);
  sub_cm = new;

  submap = AllocSubMap(sub_cm, orig_cm, sstruct, estruct);
  if(print_flag)
	{
	  printf("\n\norig struct: %s\n", con->cstr);
	  printf("\n\nnew struct : %s\n", sub_cstr);
	}

  /* Map states from orig_cm to sub_cm and vice versa. */
  map_orig2sub_cm(orig_cm, sub_cm, submap, print_flag);

  /* Fill orig_psi, which we need to determine the sub_cm parameters. */
  orig_psi = cm_ExpectedStateOccupancy(orig_cm);
  /* we need a transition map too */
  tmap = cm_CreateTransitionMap();

  CMZero(sub_cm);
  CMSetNullModel(sub_cm, orig_cm->null);
  sub_cm->el_selfsc = orig_cm->el_selfsc;
  sub_cm->beta_W    = orig_cm->beta_W;
  sub_cm->tau       = orig_cm->tau;

  /* copy the options from the template CM, but turn off the CM_ALIGN_SUB and
   * CM_CONFIG_SUB options and turn on the CM_IS_SUB flag */
  sub_cm->config_opts      = orig_cm->config_opts;
  sub_cm->align_opts       = orig_cm->align_opts;
  sub_cm->search_opts      = orig_cm->search_opts;
  sub_cm->flags            = 0;
  if(sub_cm->config_opts & CM_CONFIG_SUB) sub_cm->config_opts &= ~CM_CONFIG_SUB;
  if(sub_cm->align_opts  & CM_ALIGN_SUB)  sub_cm->align_opts  &= ~CM_ALIGN_SUB;
  sub_cm->flags |= CM_IS_SUB;

  /* Fill in emission probabilities */
  for(v_s = 0; v_s < sub_cm->M; v_s++)
	{
	  if(sub_cm->sttype[(v_s+1)] == E_st) /* detached insert */
	esl_vec_FNorm(sub_cm->e[v_s], orig_cm->abc->K);   /* equiprobable, but irrelevant, this state will never be reached */
	  else if(sub_cm->sttype[v_s] != S_st &&
	      sub_cm->sttype[v_s] != D_st &&
	      sub_cm->sttype[v_s] != B_st &&
	      sub_cm->sttype[v_s] != E_st)
	cm2sub_cm_emit_probs(orig_cm, sub_cm, orig_psi, v_s, submap->s2o_smap[v_s][0], submap->s2o_smap[v_s][1], submap);
	}
  /* Fill in transition virtual counts.
   * First handle non-B,S,E states, we'll deal with B,S,Es later.
   * The reason we have to wait is that we can't (I don't think at least)
   * unambiguously map the sub_cm B, S, or E states to orig_cm states.
   */
  for(v_s = 0; v_s < sub_cm->M; v_s++)
	{
	  if(sub_cm->sttype[(v_s+1)] == E_st) /* detached insert */
	esl_vec_FNorm(sub_cm->t[v_s], sub_cm->cnum[v_s]);   /* equiprobable, but irrelevant, this state will never be reached */
	  else if(v_s == 0 ||
	      (sub_cm->sttype[v_s] != S_st &&
	       sub_cm->sttype[v_s] != B_st &&
	       sub_cm->sttype[v_s] != E_st))
	cm2sub_cm_trans_probs(orig_cm, sub_cm, orig_psi, tmap, v_s, submap);
	}

  /* Address problem 090806 (in the 00LOG of ~/notebook/6_0725_inf_sub_cm/), by
   * retraversing the structure and subtracting out subpaths that have been counted twice
   * for a special situation involving the two inserts of ROOT and MATP states
   */
  for(n_s = 0; n_s < sub_cm->nodes; n_s++)
	{
	  if(sub_cm->ndtype[n_s] == MATP_nd && (sub_cm->sttype[(sub_cm->nodemap[n_s] + 5)+1] != E_st))
	{

	  if((submap->s2o_smap[sub_cm->nodemap[n_s] + 4][1] != -1) ||
	     (submap->s2o_smap[sub_cm->nodemap[n_s] + 5][1] != -1))
	    ESL_FAIL(eslEINCONCEIVABLE, errbuf, "build_sub_cm(), MATP_IL or MATP_IR node: %d map to 2 cm states\n", n_s);
	  if(submap->s2o_smap[sub_cm->nodemap[n_s] + 4][0] != (submap->s2o_smap[sub_cm->nodemap[n_s] + 5][0] - 1))
	    ESL_FAIL(eslEINCONCEIVABLE, errbuf, "build_sub_cm(), MATP_IL or MATP_IR node: %d don't map to adjacent orig_cm states\n", n_s);
	}
	  if(sub_cm->ndtype[n_s] == ROOT_nd && sub_cm->ndtype[n_s+1] != BIF_nd) /* ROOT->BIFs are handled special
									     * (see next loop) */
	cm2sub_cm_subtract_root_subpaths(orig_cm, sub_cm, orig_psi, tmap, submap, print_flag);
	}

  /* Go back through and fill in the transitions into E and B states and out of S states */
  for(v_s = 0; v_s < sub_cm->M; v_s++)
	{
	  if(sub_cm->sttype[v_s] == S_st)
	cm2sub_cm_trans_probs_S(orig_cm, sub_cm, orig_psi, tmap, v_s, submap);

	  if(sub_cm->sttype[v_s] == E_st || sub_cm->sttype[v_s] == B_st)
	cm2sub_cm_trans_probs_B_E(orig_cm, sub_cm, orig_psi, tmap, v_s, submap, print_flag);
	  /* convention is to leave transitions out of BIF_B as 0.0, all the code knows they're obligate */
	}

  /* Remove sub_cm ambiguities by finding and detaching sub CM insert states
   * that are 1 state before END_E states by setting transitions into
   * such states as 0.0.
   */
  cm_find_and_detach_dual_inserts(sub_cm,
				  FALSE, /* DON'T check that these states have 0 counts (they won't due to priors) */
				  TRUE); /* DO detach END_E-1 insert states */

  /*debug_sub_cm_check_all_trans(orig_cm, sub_cm, submap);*/

  /* reset sub_cm->qdbinfo->setby, we don't want to have to calculate QDBs for the sub CM unless we have to */
  if(sub_cm->qdbinfo->setby == CM_QDBINFO_SETBY_INIT) sub_cm->qdbinfo->setby = CM_QDBINFO_SETBY_SUBINIT;
  if(sub_cm->W == 0) {
	sub_cm->W = orig_cm->W;
	sub_cm->W_setby = CM_W_SETBY_SUBCOPY;
  }

  /* Finally renormalize the CM */
  CMRenormalize(sub_cm);
  /* DO NOT LOGODDSIFY YET, we'll do this when we call ConfigCM() for this CM,
   * the logsoddsification step takes a significant amount of time.
   * CMLogoddsify(sub_cm);
   */

  if(print_flag)
	{
	  ofp = fopen("sub.cm", "w");
	  if(print_flag)  printf("%-40s ... ", "Saving model to file"); fflush(stdout);
	  if(print_flag)  cm_file_WriteASCII(ofp, -1, sub_cm);
	  if(print_flag)  printf("done.\n");
	}

  if(print_flag)
	{
	  printf("\nDEBUG PRINT OF ORIG_CM PARAMETERS:\n");
	  debug_print_cm_params(stdout, orig_cm);
	  printf("\nDEBUG PRINT OF SUB_CM PARAMETERS:\n");
	  debug_print_cm_params(stdout, sub_cm);
	}

  /* Cleanup and exit. */
  cm_FreeTransitionMap(tmap);
  free(sub_cstr);
  free(sub_ct);
  FreeCMConsensus(con);
  FreeParsetree(mtr);
  free(orig_psi);

  *ret_cm = sub_cm;
  *ret_submap = submap;

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "build_sub_cm() memory allocation error.");
  return FALSE; /* never reached */
}

/**************************************************************
 * Function: CP9NodeForPosn()
 * EPN 07.25.06 Benasque, Spain
 *
 * Purpose:  Determine the node of the CP9 HMM that is most likely to
 *           have emitted (from either its Match or Insert state)
 *           a given posn in the target sequence.
 *
 * Args:     hmm       - the CM plan 9 HMM
 *           i0        - first posn of target subseq with info in posterior matrix
 *           j0        - last posn of target subseq with info in posterior matrix
 *           x         - posn of target subsequence we're interested in
 *           L         - last position of target sequence
 *           post      - the posterior matrix for the hmm
 *           ret_node  - RETURN: index of node with highest probability of emitting x
 *           ret_type  - RETURN: type of state in ret_node with highest probability
 *           pmass     - probability mass to require on left of start or right of end
 *           is_start  - TRUE if we're doing left of start,
 *           print_flag- TRUE to print out info on most likely node
 *
 * Returns:  eslOK on success;
 *           eslEINVAL on contract violation.
 */
void
CP9NodeForPosn(CP9_t *hmm, int i0, int j0, int x, CP9_MX *post,
	       int *ret_node, int *ret_type, float pmass, int is_start,
	       int print_flag)
{
  /* post->mmx[i][k]: posterior probability that posn i was emitted from node k's
	 match state */
  int  max_k;    /* node index with highest posterior probability of emitting posn x */
  int  max_type; /* type of state in max_k node with max probability '0' for match,
		    '1' for insert */
  int  max_sc;   /* score (log probability) from post matrix for max_k node max_type state type */
  int  k;        /* counter over nodes */

  if(!is_start) pmass = 1. - pmass; /* we move left to right */

  /*printf("in CP9NodeForPosn is_start: %d pmass: %f\n", is_start, pmass);*/
  if(x > j0 || x < i0)
	/*ESL_XFAIL(eslEINVAL, "ERROR in CP9NodeForPosn(), asking for position x: %d outside subseq bounds i0: %d j0: %d\n", x, i0, j0);*/
	cm_Fail("ERROR in CP9NodeForPosn(), asking for position x: %d outside subseq bounds i0: %d j0: %d\n", x, i0, j0);

  if(post->mmx[x][0] > post->imx[x][0])
	{
	  max_sc     = post->mmx[x][0];
	  max_type   = 0; /* match */
	}
  else
	{
	  max_sc     = post->imx[x][0];
	  max_type   = 1; /* insert */
	}
  max_k    = 0;
  /* move left to right through HMM nodes */
  for(k = 1; k <= hmm->M; k++)
	{
	  if(post->mmx[x][k] > max_sc)
	{
	  max_k  = k;
	  max_sc = post->mmx[x][k];
	  max_type = 0; /* match */
	}
	  if(post->imx[x][k] > max_sc)
	{
	  max_k  = k;
	  max_sc = post->imx[x][k];
	  max_type = 1; /* insert */
	}
	}

  if(print_flag)
	{
	  if(max_type == 0)
	printf("MATCH | mx->mmx[%3d][%3d]: %9d | %8f\n", x, max_k, post->mmx[x][max_k], Score2Prob(post->mmx[x][max_k], 1.));
	  else
	printf("INSERT | mx->imx[%3d][%3d]: %9d | %8f\n", x, max_k, post->imx[x][max_k], Score2Prob(post->imx[x][max_k], 1.));
	}
  *ret_node = max_k;
  *ret_type = max_type;
  return;
}

/**********************************************************
 * Function:  StripWUSSGivenCC()
 * EPN 09.07.05
 *
 * Purpose:   Strips a secondary structure string in WUSS notation
 *            of base pair information for specific match (consensus) columns.
 *            namely those before the first match column given by first_match,
 *            and after the last match column, given by last_match
 *            The msa->ss_cons secondary structure string is modified.
 *
 *            Characters <([{  are converted to :   (left base of base pairs)
 *            Characters >)]}  are converted to :   (right base of base pairs)
 *            Characters _-,   are converted to :   (unpaired bases)
 *            Characters  .:~  are untouched
 *            Pseudoknot characters are converted to : as well.
 *
 * Args:      msa         - the multiple sequence alignment
 *            gapthresh   - the gap threshold for calling a match column
 *            first_match - first match column to keep structure for
 *            last_match  - last match column to keep structure for
 * Returns:   (void)
 */
void
StripWUSSGivenCC(ESL_MSA *msa, float gapthresh, int first_match, int last_match)
{
  int status;
  int *matassign;	/* 0..alen-1 array; 0=insert col, 1=match col */
  int gaps;
  int apos;
  int idx;
  int cc;
  int *ct;		/* 0..alen-1 base pair partners array         */

  /* Contract check */
  if(msa->flags & eslMSA_DIGITAL)
	cm_Fail("ERROR in StripWUSSGivenCC, MSA is digitized.\n");

  /* 1. Determine match/insert assignments
   *    matassign is 1..alen. Values are 1 if a match column, 0 if insert column.
   */
  ESL_ALLOC(matassign, sizeof(int) * (msa->alen+1));
  matassign[0] = 0; /* no 0th column in MSA */
  for (apos = 0; apos < msa->alen; apos++)
	{
	  for (gaps = 0, idx = 0; idx < msa->nseq; idx++)
	if (esl_abc_CIsGap(msa->abc, msa->aseq[idx][apos])) gaps++;
	  matassign[apos+1] = ((double) gaps / (double) msa->nseq > gapthresh) ? 0 : 1;
	}

  /* 2. Determine a "ct" array, base-pairing partners for each position.
   *    Disallow/ignore pseudoknots. (That's what the FALSE flag does.)
   *    ct[] values give the index of a base pairing partner, or 0 for unpaired positions.
   *    Even though msa->ss_cons is in the 0..alen-1 coord system of msa, ct[]
   *    comes back in the 1..alen coord system of dsq.
   */
  ESL_ALLOC(ct, (msa->alen+1) * sizeof(int));
  if (esl_wuss2ct(msa->ss_cons, msa->alen, ct) != eslOK)
	cm_Fail("Consensus structure string is inconsistent");

  /* 3. Make sure the consensus structure "ct" is consistent with the match assignments.
   *    Wipe out all structure in insert columns; including the base-paired
   *    partner of insert-assigned columns.
   *    Also, remove structure outside of the consensus columns that
   *    map to the HMM nodes first_match and last_match.
   */
  cc = 0;
  for (apos = 1; apos <= msa->alen; apos++)
	{
	  if (! matassign[apos])
	{
	  if (ct[apos] != 0)  ct[ct[apos]] = 0;
	  ct[apos] = 0;
	}
	  else /* matassign[apos] == 1 */
	{
	  cc++;
	  if(cc < first_match || cc > last_match)
	    {
	      if (ct[apos] != 0)  ct[ct[apos]] = 0;
	      ct[apos] = 0;
	    }
	}
	}

  /* Next construct the new msa->ss_cons based on the ct array.
   * We should do this similar to display.c::CreateCMConsensus()
   * does it to get the fully formatted WUSS ([{<>}]) string but
   * lazily we just do <> bps here.
   */
  for (apos = 1; apos <= msa->alen; apos++)
	{
	  if      (ct[apos] == 0   ) msa->ss_cons[apos-1] = '.';
	  else if (ct[apos]  > apos) msa->ss_cons[apos-1] = '<';
	  else if (ct[apos]  < apos) msa->ss_cons[apos-1] = '>';
	  else cm_Fail("ERROR: weird error in StripWUSSGivenCC\n");
	}

  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 08.31.06
 * cm2sub_cm_emit_probs()
 *
 * Purpose:  For a specific sub CM state v_s, determine the
 *           emission probabilities using the emission probs
 *           of state(s) (up to 2) in the original CM that
 *           map to it. We weight the contribution of each
 *           state to the emission probability by it's psi
 *           value in orig_cm (psi[v] is expected number of
 *           times state v is entered in a parse).
 *
 * Args:
 * CM_t *orig_cm     - the original, template CM
 * CM_t *sub_cm      - the sub CM
 * double *orig_psi  - orig_psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * int v_s           - the sub_cm state we're filling emissions for
 * int v_o1          - orig_cm state v_s maps to
 * int v_o2          - orig_cm state v_s maps to (-1 if v_s maps to only 1 state)
 * Returns: void
 */
static void
cm2sub_cm_emit_probs(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, int v_s, int v_o1, int v_o2,
		     CMSubMap_t *submap)
{
  int is_left;
  int i, j;

  /*printf("\nin cm2sub_cm_emit_probs v_s: %d, v_o1: %d, v_o2: %d\n", v_s, v_o1, v_o2);*/

  if(v_o1 == -1)
	{
	  cm_Fail("ERROR in cm2sub_cm_emit_probs, sub_cm state %d maps to 0 states in orig_cm (spos: %d epos: %d)\n", v_s, submap->spos, submap->epos);
	}

  if(sub_cm->sttype[v_s] == MP_st)
	{
	  for(i = 0; i < (orig_cm->abc->K*orig_cm->abc->K); i++)
	sub_cm->e[v_s][i] = orig_cm->e[v_o1][i];
	  return;
	}

  if(submap->s2o_id[v_s] == TRUE)
	{
	  /* must be a singlet emitter */
	  for(i = 0; i < orig_cm->abc->K; i++)
	sub_cm->e[v_s][i] = orig_cm->e[v_o1][i];
	  /* No FNorm's necessary (assuming the orig_cm is normalized), since we're
	   * building a new CM for each sequence in --sub mode, we skip it for speed.
	   */
	  return;
	}

  /* If we get here, v_s is a singlet emitter. */

  /* There are two cases when two states can map to v_s.
   * Case 1: one of them is an MP_st,
   * Case 2: one is an IL_st and one is an IR_st (ambiguity in CM architecture)
   * These are the only cases where we need to weight emission probs by orig_psi values,
   * and subsequently only cases we need to call FNorm() for */
  if(orig_cm->sttype[v_o1] == MP_st)
	{
	  if(orig_cm->sttype[v_o2] == ML_st)
	is_left = TRUE;
	  else if(orig_cm->sttype[v_o2] == MR_st)
	is_left = FALSE;
	  else
	cm_Fail("ERROR v_s: %d maps to a MP_st and another non-ML and non-MR state\n");

	  for(i = 0; i < orig_cm->abc->K; i++)
	if(is_left)
	  for(j = (i*orig_cm->abc->K); j < ((i+1)*orig_cm->abc->K); j++)
	    sub_cm->e[v_s][i] += orig_psi[v_o1] * orig_cm->e[v_o1][j];
	else
	  for(j = i; j < (orig_cm->abc->K*orig_cm->abc->K); j+=orig_cm->abc->K)
	    sub_cm->e[v_s][i] += orig_psi[v_o1] * orig_cm->e[v_o1][j];
	  if(orig_cm->sttype[v_o2] == MP_st)
	cm_Fail("ERROR sub_cm state: %d maps to two MATP_MP states\n", v_s);

	  /*v_o2 must be ML or MR, which can all be handled identically */
	  for(i = 0; i < orig_cm->abc->K; i++)
	sub_cm->e[v_s][i] += orig_psi[v_o2] * orig_cm->e[v_o2][i];
	  esl_vec_FNorm(sub_cm->e[v_s], orig_cm->abc->K);
	  return;
	}
  else if(v_o2 != -1)
	cm_Fail("ERROR sub_cm state: %d maps to two states (%d and %d), but neither is a MATP_MP\n", v_s, v_o1, v_o2);

  /* If we get here, v_s maps to a single singlet emitter in orig_cm, v_o1 */
  for(i = 0; i < orig_cm->abc->K; i++)
	sub_cm->e[v_s][i] = orig_cm->e[v_o1][i];

  return;
}

/**************************************************************************
 * EPN 08.31.06
 * cm2sub_cm_trans_probs()
 *
 * Purpose:  For a specific sub CM state v_s, determine the
 *           transition probabilities going out of v_s,
 *           using the psi values for the original template
 *           CM (orig_cm) (psi[v] is expected number of
 *           times state v is entered in a parse).
 *           We fill the sub_cm->t[v_s] with 'virtual
 *           counts', then we'll normalize to probabilities
 *           later (outside this function).
 *
 *           This is based on cp9_modelmaker.c::cm2hmm_trans_probs_cp9()
 *           which was based on formulas/ideas in Zasha Weinberg's
 *           thesis (p.123).
 *
 * Args:
 * CM_t *orig_cm     - the original, template CM
 * CM_t *sub_cm      - the sub CM
 * double *orig_psi  - orig_psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap      - the hard-coded transition map
 * int v_s           - the sub_cm state we're filling transitions for
 * submap            - the map from the sub CM to the template CM
 * Returns: void
 */
static void
cm2sub_cm_trans_probs(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_s, CMSubMap_t *submap)
{
  int v_o;
  int yoffset;
  int y_s;

  /*printf("in cm2sub_cm_trans_probs: v_s: %d\n", v_s);*/

  if(submap->s2o_id[v_s] == TRUE) /* v_s is identical to submap->s2o_smap[v_s][0] */
	{
	  v_o = submap->s2o_smap[v_s][0];
	  for(yoffset = 0; yoffset < sub_cm->cnum[v_s]; yoffset++)
	{
	  /* we can just copy the transitions */
	  sub_cm->t[v_s][yoffset] = orig_psi[v_o] * orig_cm->t[v_o][yoffset];
	}
	  return;
	}

  /* start with the first orig_cm state that maps to v_s */
  v_o = submap->s2o_smap[v_s][0];
  /*printf("\tv_o: %d\n", v_o);*/
  if(v_o == -1)
	{
	  if(sub_cm->sttype[v_s] != S_st &&
	 sub_cm->sttype[v_s] != E_st &&
	 sub_cm->sttype[v_s] != B_st)
	/* special cases, S_st, E_st, B_st */
	cm_Fail("ERROR, sub_cm state v_s: %d maps to no state in sub_cm, but it's not a B, E or S state\n", v_s);
	}
  else
	{
	  if(sub_cm->sttype[v_s] == S_st ||
	 sub_cm->sttype[v_s] == E_st ||
	 sub_cm->sttype[v_s] == B_st)
	if(v_s != 0)
	  cm_Fail("ERROR, sub_cm state v_s: %d is S, E or B but maps to a orig_cm state: v_o:%d\n", v_o);

	  for(yoffset = 0; yoffset < sub_cm->cnum[v_s]; yoffset++)
	{
	  y_s = sub_cm->cfirst[v_s] + yoffset;
	  if(sub_cm->sttype[(y_s+1)] != E_st) /* if y_s+1 is an E, y_s is a detached insert state, we want
					       * it to be impossible to reach this guy, leave counts as 0.0 */
	    {
	      cm2sub_cm_add_single_trans(orig_cm, sub_cm, submap, v_o, submap->s2o_smap[y_s][0], v_s, yoffset, orig_psi, tmap);
	      cm2sub_cm_add_single_trans(orig_cm, sub_cm, submap, v_o, submap->s2o_smap[y_s][1], v_s, yoffset, orig_psi, tmap);
	    }
	}
	}

  /* move on to the second orig_cm state that maps to v_s */
  v_o = submap->s2o_smap[v_s][1];
  if(v_o != -1)
	{
	  for(yoffset = 0; yoffset < sub_cm->cnum[v_s]; yoffset++)
	{
	  y_s = sub_cm->cfirst[v_s] + yoffset;
	  if(sub_cm->sttype[(y_s+1)] != E_st) /* if y_s+1 is an E, y_s is a detached insert state, we want
					       * it to be impossible to reach this guy, leave counts as 0.0 */
	    {
	      cm2sub_cm_add_single_trans(orig_cm, sub_cm, submap, v_o, submap->s2o_smap[y_s][0], v_s, yoffset, orig_psi, tmap);
	      cm2sub_cm_add_single_trans(orig_cm, sub_cm, submap, v_o, submap->s2o_smap[y_s][1], v_s, yoffset, orig_psi, tmap);
	    }
	}
	}
  return;
}

/**************************************************************************
 * EPN 09.15.06
 * cm2sub_cm_trans_probs_S()
 *
 * Purpose:  For a specific sub CM S state v_start, fill in virtual counts
 *           for transitions out of v_s. We do this in its own seperate function
 *           because we can't robustly map S states in a sub_cm to S states
 *           in an orig CM (if its possible - I can't figure out how to do it).
 *
 * Args:
 * CM_t *orig_cm     - the original, template CM
 * CM_t *sub_cm      - the sub CM
 * double *orig_psi  - orig_psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap      - the hard-coded transition map
 * int v_start       - the sub_cm start state we're filling virtual counts of transitions into
 * submap            - the map from the sub CM to the template CM
 * Returns: void
 */
static void
cm2sub_cm_trans_probs_S(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_start, CMSubMap_t *submap)
{
  int yoffset;
  int y_s;

  int sub_nd;

  int v_s_insert;
  int v_o_insert;

  float sum;
  float il_psi;
  float temp_psi;
  float temp_psi_sum;
  float diff;

  int orig_il1, orig_il2, orig_ir1, orig_ir2;

  /*printf("in cm2sub_cm_trans_probs_S: v_start: %d\n", v_start);*/

  sub_nd     = sub_cm->ndidx[v_start];

  if(sub_cm->ndtype[sub_nd] == BEGL_nd)
	{
	  /* This is the easy case, we have transitions into each of the states in the split-set
	   * of the next node. The only way to reach each of these states is from the BEGL
	   * so we just weight each by the psi values for the matching orig_cm states.
	   */
	  if(sub_cm->ndtype[sub_nd + 1] == BIF_nd)
	sub_cm->t[v_start][0] = 1.0; /* BEGL_S -> BIF_B */
	  else
	for(yoffset = 0; yoffset < sub_cm->cnum[v_start]; yoffset++)
	  {
	    y_s = sub_cm->cfirst[v_start] + yoffset;
	    /*printf("updating sub_cm->t[%d][%d]\n", v_start, yoffset);*/
	    sub_cm->t[v_start][yoffset] = orig_psi[submap->s2o_smap[y_s][0]];
	    if(submap->s2o_smap[y_s][1] != -1)
	      sub_cm->t[v_start][yoffset] += orig_psi[submap->s2o_smap[y_s][1]];
	  }
	}

  else if(sub_cm->ndtype[sub_nd] == BEGR_nd)
	{
	  /* More complicated than the BEGL case b/c we need to handle the
	   * BEGR_S -> BEGR_IL transition as well as BEGR_S -> next node
	   * split set transitions.
	   * We know the BEGR_IL -> BEGR_IL self transition though because
	   * we were able to map BEGR_IL to 1 or 2 orig_cm states.
	   */

	  v_s_insert = v_start + 1;
	  if(sub_cm->ndtype[sub_nd + 1] == BIF_nd)
	{
	  /*printf("!!!SPECIAL CASE BEGR -> BIF! v_ct\n");*/

	  v_o_insert = submap->s2o_smap[v_s_insert][0];
	  if(submap->s2o_smap[v_s_insert][1] == -1)
	    {
	      diff = sub_cm->t[v_s_insert][0] - (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]);
	      if(diff >= 0. && diff > 0.0001)
		cm_Fail("ERROR, code for calc'ing BEGR_IL -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	      if(diff <= 0. && diff < -0.0001)
		cm_Fail("ERROR, code for calc'ing BEGR_IL -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	    }

	  /* BEGR_IL -> BEGR_IL will be the sum over possibly two orig_cm states v_o_insert that
	   * map to sub_cm state BEGR_IL of:
	   *    orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0],
	   * so BEGR_IL -> BIF_B is calc'ed as follows */
	  sub_cm->t[v_s_insert][1] = orig_psi[v_o_insert] * (1. - orig_cm->t[v_o_insert][0]);
	  if(submap->s2o_smap[v_s_insert][1] != -1)
	    {
	      /* we have to factor in the other state as well. */
	      cm_Fail("ERROR, BEGR_IL: %d maps to 2 orig_cm states, was hoping this was impossible - need to implement.\n", v_s_insert);
	      v_o_insert = submap->s2o_smap[v_s_insert][1];
	      sub_cm->t[v_s_insert][1] += orig_psi[v_o_insert] * (1. - orig_cm->t[v_o_insert][0]);
	    }
	  /* Now we normalize the transitions out of BEGR_IL, so we can calculate BEGR_S -> BEGR_IL */
	  esl_vec_FNorm(sub_cm->t[v_s_insert], sub_cm->cnum[v_s_insert]);
	  il_psi   = orig_psi[submap->s2o_smap[v_s_insert][0]];
	  if(submap->s2o_smap[v_s_insert][1] != -1)
	    {
	      cm_Fail("ERROR, BEGR_IL: %d maps to 2 orig_cm states, was hoping this was impossible - need to implement.\n", v_s_insert);
	      il_psi+= orig_psi[submap->s2o_smap[v_s_insert][1]];
	    }
	  sub_cm->t[v_start][0] = (1. - sub_cm->t[v_s_insert][0]) * il_psi; /* set BEGR_S -> BEGR_IL */
	  sub_cm->t[v_start][1] = 1. - sub_cm->t[v_start][0]; /* set BEGR_S -> BIF_B */
	}

	  else
	{ /* next node is not a BIF node */
	  /* First, normalize the probabilities out of the BEGR_IL, so
	   * we can calculate what BEGR_S -> BEGR_IL should be (we need
	   * to know BEGR_IL -> BEGR_IL probability and orig_psi of
	   * the states that map to BEGR_IL to do this).
	   */
	  sum = 0.;
	  esl_vec_FNorm(sub_cm->t[v_s_insert], sub_cm->cnum[v_s_insert]);
	  il_psi   = orig_psi[submap->s2o_smap[v_s_insert][0]];
	  if(submap->s2o_smap[v_s_insert][1] != -1)
	    {
	      cm_Fail("ERROR, BEGR_IL: %d maps to 2 orig_cm states, was hoping this was impossible - need to implement.\n", v_s_insert);
	      il_psi += orig_psi[submap->s2o_smap[v_s_insert][1]];
	    }
	  sub_cm->t[v_start][0] = (1. - sub_cm->t[v_s_insert][0]) * il_psi; /* set BEGR_S -> BEGR_IL */
	  sum = sub_cm->t[v_start][0];

	  for(yoffset = 1; yoffset < sub_cm->cnum[v_start]; yoffset++) /* note we start at yoffset = 1
									* BEGR_S -> first state of next
									* node's split set. */
	    {
	      y_s = sub_cm->cfirst[v_start] + yoffset;
	      temp_psi   = orig_psi[submap->s2o_smap[y_s][0]];
	      if(submap->s2o_smap[y_s][1] != -1)
		temp_psi += orig_psi[submap->s2o_smap[y_s][1]];

	      sub_cm->t[v_start][yoffset] = temp_psi - il_psi * sub_cm->t[v_s_insert][yoffset];
	      sum += sub_cm->t[v_start][yoffset];
	    }
	  /*printf("BEGR->NON BIF  SUM: %f\n", sum);*/
	  if(sum < 1.0 && ((1.0 - sum) > 0.001))
	    cm_Fail("ERROR calculating transitions out of BEGR_S incorrectly\n");
	  if(sum > 1.0 && ((sum - 1.0) > 0.001))
	    cm_Fail("ERROR calculating transitions out of BEGR_S incorrectly\n");
	}
	}
  else if(sub_cm->ndtype[sub_nd] == ROOT_nd)
	{
	  /*printf("in cm2sub_cm_trans_probs_S(), ROOT_nd\n");*/
	  /* the only case we have to worry about is if the next node is BIF node,
	   * otherwise the transitions out of ROOT_S have already been set.
	   */
	  if(sub_cm->ndtype[sub_nd + 1] == BIF_nd)
	{
	  /*printf("!!!SPECIAL CASE ROOT -> BIF!\n");*/
	  /* Before we do anything we have to check to see if we need to subtract
	   * any subpaths from ROOT_S -> ROOT_IR that have been double counted:
	   */
	  /* if orig_ir < orig_il, we've counted paths from
	   * ir -> il correctly for ROOT_IL -> ROOT_IR and
	   *        incorrectly for ROOT_S  -> ROOT_IR
	   */

	  orig_il1 = submap->s2o_smap[1][0];
	  orig_il2 = submap->s2o_smap[1][1];

	  orig_ir1 = submap->s2o_smap[2][0];
	  orig_ir2 = submap->s2o_smap[2][1];

	  if(orig_ir1 < orig_il1)
	    {
	      sub_cm->t[0][1] -= orig_psi[orig_ir1] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir1, orig_il1, 0, tmap, orig_psi);
	    }
	  if(orig_ir2 != -1 && orig_ir2 < orig_il1)
	    {
	      sub_cm->t[0][1] -= orig_psi[orig_ir2] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir2, orig_il1, 0, tmap, orig_psi);
	    }
	  if(orig_il2 != -1 && orig_ir1 < orig_il2)
	    {
	      sub_cm->t[0][1] -= orig_psi[orig_ir1] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir1, orig_il2, 0, tmap, orig_psi);
	    }
	  if((orig_ir2 != -1 && orig_il2 != -1) && (orig_ir2 < orig_il2))
	    {
	      sub_cm->t[0][1] -= orig_psi[orig_ir2] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir2, orig_il2, 0, tmap, orig_psi);
	    }

	  /* Next, set transition from ROOT_S -> BIF_B, we know that
	   * ROOT_S -> ROOT_IL and ROOT_S -> ROOT_IR were set using
	   * orig_cm subpaths originating at ROOT_S, so we know that
	   * the virtual counts out of ROOT_S should NOT be scaled, in
	   * other words, they can be treated as probabilities and should
	   * sum to 1.0.
	   */
	  sub_cm->t[0][2] = 1.0 - (sub_cm->t[0][0] + sub_cm->t[0][1]); /* set ROOT_S->BIF_B */

	  v_s_insert = v_start + 1; /* ROOT_IL */
	  v_o_insert = submap->s2o_smap[v_s_insert][0];
	  if(submap->s2o_smap[v_s_insert][1] == -1)
	    {
	      diff = sub_cm->t[v_s_insert][0] - (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]);
	      if(diff >= 0. && diff >= 0.0001)
		cm_Fail("ERROR, code for calc'ing ROOT_IL -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	      if(diff <= 0. && diff <= -0.0001)
		cm_Fail("ERROR, code for calc'ing ROOT_IL -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	    }
	  /* We want to figure out what the virtual counts for the traansition ROOT_IL -> BIF_B should
	   * be, but this depends on how we filled the virtual counts for the other two
	   * transitions (-> ROOT_IL and -> ROOT_IR) out of ROOT_IL, so we SHOULD revisit
	   * their calculation. Here, I'm attempting a trick that SHOULD work: figuring out
	   * what the self_insert probability IL->IL should be based on the self insert probabilities
	   * of the up to 2 orig_cm states that sub_cm ROOT_IL maps to, then using that scaling
	   * factor (the actual probability / the virtual counts currently in sub_cm->t[ROOT_IL][0])
	   * to scale both ROOT_IL->ROOT_IL and ROOT_IL->ROOT_IR, then we can just set ROOT_IL->BIF
	   * as 1.0 - (ROOT_IL->ROOT_IL + ROOT_IL->ROOT_IR).
	   */

	  temp_psi_sum = orig_psi[v_o_insert];

	  if(submap->s2o_smap[v_s_insert][1] != -1)
	    {
	      v_o_insert    = submap->s2o_smap[v_s_insert][1];
	      temp_psi_sum += orig_psi[v_o_insert];
	    }
	  sub_cm->t[v_s_insert][0] /= temp_psi_sum; /* ROOT_IL -> ROOT_IL */
	  sub_cm->t[v_s_insert][1] /= temp_psi_sum; /* ROOT_IL -> ROOT_IR */
	  sub_cm->t[v_s_insert][2]  = 1. - (sub_cm->t[v_s_insert][0] + sub_cm->t[v_s_insert][1]);
	  /* ROOT_IL -> BIF_B */

	  /* move on to calc'ing ROOT_IR -> BIF */
	  v_s_insert = v_start + 2; /* ROOT_IR */
	  v_o_insert = submap->s2o_smap[v_s_insert][0];
	  if(submap->s2o_smap[v_s_insert][1] == -1)
	    {
	      diff = sub_cm->t[v_s_insert][0] - (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]);
	      if(diff >= 0. && diff > 0.0001)
		cm_Fail("ERROR, code for calc'ing ROOT_IR -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	      if(diff <= 0. && diff < -0.0001)
		cm_Fail("ERROR, code for calc'ing ROOT_IR -> BIF_B is wrong, sub_cm->t[v_s_insert:%d][0] should be %f (based on your understanding) but its really %f\n", v_s_insert, (orig_psi[v_o_insert] * orig_cm->t[v_o_insert][0]), (sub_cm->t[v_s_insert][0]));
	    }
	  /* We can calculate what the ROOT_IR -> ROOT_IR probability should be, and then
	   * just take 1.0 minus that probability to set ROOT_IR -> BIF.
	   */
	  temp_psi_sum = orig_psi[v_o_insert];

	  if(submap->s2o_smap[v_s_insert][1] != -1)
	    {
	      v_o_insert    = submap->s2o_smap[v_s_insert][1];
	      temp_psi_sum += orig_psi[v_o_insert];
	    }
	  sub_cm->t[v_s_insert][0] /= temp_psi_sum; /* ROOT_IR -> ROOT_IR */
	  sub_cm->t[v_s_insert][1]  = 1. - (sub_cm->t[v_s_insert][0]);
	  /* ROOT_IR -> BIF_B */
	}
	  else
	{
	  /* ROOT -> non-BIF node, we have already handled this, so we return. */
	}
	}
  /*printf("leaving cm2sub_cm_trans_probs_S\n\n");*/
  return;
}

/**************************************************************************
 * EPN 09.21.06
 * cm2sub_cm_trans_probs_B_E()
 *
 * Purpose:  For a specific sub CM B or E state v_be fill in virtual counts
 *           for transitions into v_be. We do this in its own seperate function,
 *           because we can't robustly map E states in a sub_cm to E states
 *           in an orig CM (if its possible - I can't figure out how to do it).
 *
 * Args:
 * CM_t *orig_cm     - the original, template CM
 * CM_t *sub_cm      - the sub CM
 * double *orig_psi  - orig_psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap      - the hard-coded transition map
 * int v_be         - the sub_cm END state we're filling virtual counts of transitions into
 * submap            - the map from the sub CM to the template CM
 * print_flag        - TRUE to print useful debugging info
 * Returns: void
 */
static void
cm2sub_cm_trans_probs_B_E(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap, int v_be, CMSubMap_t *submap,
			  int print_flag)
{
  int orig_v;
  int sub_v;

  int sub_nd;
  int psub_nd;
  int sub_i;
  int bif_end_yoffset;
  int orig_v1, orig_v2, orig_i;
  float contribution;
  int orig_il, orig_ir, sub_il, sub_ir;
  int into_end_flag;

  if(print_flag) printf("in cm2sub_cm_trans_probs_B_E: sub_v: %d\n", v_be);

  sub_nd =  sub_cm->ndidx[v_be];
  psub_nd = sub_nd - 1;

  into_end_flag = FALSE;
  if(sub_cm->sttype[v_be] == E_st)
	into_end_flag = TRUE;
  /* We're moving from into an END, so the END_E - 1 state is a detached insert,
   * and we have to handle this in a special way */

  switch (sub_cm->ndtype[psub_nd]) {
  case MATP_nd:
	if(print_flag) printf("prev node type MATP\n");
	/* psub_nd is a MATP: each state in psub_nd transits to
	 * exactly 3 states, the MATP_IL, MATP_IR and the BIF or END state v_be, for which
	 * we are trying to fill virtual transition counts into.
	 *
	 * The case for MATP_nd's is actually simpler than for other nodes because we
	 * can exploit the fact that if a MATP node exists in the sub_cm it necessarily
	 * must map to a MATP node in the original CM (we're not adding or changing any
	 * base pairs, just deleting some possibly), so every sub MATP state must correspond
	 * to exactly 1 original MATP state.
	 */

	bif_end_yoffset = 2; /* cm->t[][2] goes to BIF_B or END_E */
	sub_il = sub_cm->nodemap[psub_nd] + 4;
	sub_ir = sub_cm->nodemap[psub_nd] + 5;

	orig_il = submap->s2o_smap[sub_il][0];
	orig_ir = submap->s2o_smap[sub_ir][0];
	if(into_end_flag && orig_ir != -1)
	  cm_Fail("ERROR in cm2sub_cm_trans_probs_B_E(), into_end_flag is TRUE but MATP_IR maps to a orig_cm state.\n");
	if(orig_ir == -1 && !into_end_flag)
	  cm_Fail("ERROR in cm2sub_cm_trans_probs_B_E(), into_end_flag is FALSE but MATP_IR doesn't map to a orig_cm state.\n");

	for(sub_v = sub_cm->nodemap[psub_nd]; sub_v < sub_il; sub_v++)
	  {
	orig_v = submap->s2o_smap[sub_v][0]; /* submap->s2o_smap[sub_v][1] will nec. be -1 in a MATP */
	sub_cm->t[sub_v][bif_end_yoffset] = orig_psi[orig_v] -
	  (sub_cm->t[sub_v][0] + sub_cm->t[sub_v][1]); /* if into_end_flag is TRUE, sub_cm->t[sub_v][1] is 0. */
	  }
	/* now do MATP_IL and MATP_IR */
	sub_cm->t[sub_il][bif_end_yoffset] = orig_psi[orig_il] -
	  (sub_cm->t[sub_il][0] + sub_cm->t[sub_il][1]);

	bif_end_yoffset = 1;
	if(into_end_flag)
	  sub_cm->t[sub_ir][bif_end_yoffset] = 1.0;
	else
	  sub_cm->t[sub_ir][bif_end_yoffset] = orig_psi[orig_ir] - sub_cm->t[sub_ir][0];
	break;

  case MATL_nd:
  case MATR_nd:
	if(print_flag) printf("prev node type MATL or MATR\n");
	/* psub_nd is a MATL or MATR and we know each state in psub_nd transits to
	 * exactly 2 states, the insert state of psub_nd and the BIF or END state v_be, which
	 * we are trying to fill in transitions to.
	 */
	bif_end_yoffset = 1; /* cm->t[][1] goes to BIF_B or END_E */
	sub_i = sub_cm->nodemap[psub_nd] + 2; /* sub_i is MATL_IL or MATR_IR */
	orig_i = submap->s2o_smap[sub_i][0];
	if(into_end_flag && orig_i != -1)
	  cm_Fail("ERROR in cm2sub_cm_trans_probs_B_E(), into_end_flag is TRUE but MAT*_I* maps to a orig_cm state.\n");

	for(sub_v = sub_cm->nodemap[psub_nd]; sub_v < sub_i; sub_v++)
	  {
	orig_v1 = submap->s2o_smap[sub_v][0];
	orig_v2 = submap->s2o_smap[sub_v][1];
	if(into_end_flag)
	  sub_cm->t[sub_v][bif_end_yoffset] = 1.0;
	else
	  {
	    if(orig_v1 < orig_i)
	      {
		contribution = cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap,
						      orig_v1, orig_i, sub_v, tmap, orig_psi);
		sub_cm->t[sub_v][bif_end_yoffset] = orig_psi[orig_v1] * (1. - contribution);
		if(print_flag) printf("curr v1 < i1 sub_cm->t[sub_v:%d][1] now: %f (added: psi:%f * 1-cont: %f (%f))\n", sub_v, sub_cm->t[sub_v][1], orig_psi[orig_v1], (1.-contribution), (orig_psi[orig_v1] * (1. - contribution)));
	      }
	    else
	      {
		contribution = orig_psi[orig_i] * cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap,
									 orig_i, orig_v1, sub_v, tmap, orig_psi);
		sub_cm->t[sub_v][bif_end_yoffset] = orig_psi[orig_v1] * (1. - (contribution / orig_psi[orig_v1]));
		if(print_flag) printf("curr i1 < v1 sub_cm->t[sub_v:%d][1] now: %f (added: psi:%f * 1-cont: %f (%f))\n", sub_v, sub_cm->t[sub_v][1], orig_psi[orig_v1], (1.-contribution), (orig_psi[orig_v1] * (1. - contribution)));
	      }
	    if(orig_v2 != -1)
	      {
		if(orig_v2 < orig_i)
		  {
		    contribution = cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap,
							  orig_v2, orig_i, sub_v, tmap, orig_psi);
		    sub_cm->t[sub_v][bif_end_yoffset] += orig_psi[orig_v2] * (1. - contribution);
		    if(print_flag) printf("curr v2 < i1 sub_cm->t[sub_v:%d][1] now: %f (added: psi:%f * 1-cont: %f (%f))\n", sub_v, sub_cm->t[sub_v][1], orig_psi[orig_v2], (1.-contribution), (orig_psi[orig_v2] * (1. - contribution)));
		  }
		else
		  {
		    contribution = orig_psi[orig_i] * cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap,
									     orig_i, orig_v2, sub_v, tmap, orig_psi);
		    sub_cm->t[sub_v][bif_end_yoffset] += orig_psi[orig_v2] * (1. - (contribution / orig_psi[orig_v2]));
		    if(print_flag) printf("curr i1 < v2 sub_cm->t[sub_v:%d][1] now: %f (added: psi:%f * 1-cont: %f (%f))\n", sub_v, sub_cm->t[sub_v][1], orig_psi[orig_v2], (1.-contribution), (orig_psi[orig_v2] * (1. - contribution)));
		  }
	      }
	  }
	  }
	/* now set the sub_i -> B or E transition prob */
	if(into_end_flag) /* The transition probability out of the MAT{L,R}_I{L,R} is irrelevant,
		       * because the state is detached. */
	  sub_cm->t[sub_i][1] = 1.;
	else
	  sub_cm->t[sub_i][1] = orig_psi[orig_i] *
	(1. - cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap,
				     orig_i, orig_i, sub_i,tmap, orig_psi));
	break;

  case ROOT_nd:
  case BEGL_nd:
  case BEGR_nd:
	{ /* we handle these cases in cm2sub_cm_trans_probs_S() */ }
	break;

  default:
	cm_Fail("ERROR bogus node type transiting to END or BIF\n");
	break;
  }

  if(print_flag) printf("Returning from cm2sub_cm_trans_probs_B_E\n");
  return;
}

/**************************************************************************
 * EPN 08.31.06
 * Function: cm2sub_cm_add_single_trans()
 *
 * Purpose:  Add a virtual counts contribution to a single CM transition.
 *
 * See related functions for explanation of parameters.
 * Returns: (void)
 */
static void
cm2sub_cm_add_single_trans(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int orig_v, int orig_y,
			   int sub_v, int yoffset, double *orig_psi, char ***tmap)
{
  int start;
  /* check if we've got real CM state ids */
  if(orig_v == -1 || orig_y == -1)
	return;
  start = orig_v;
  if(orig_y < start)
	start = orig_y;
  sub_cm->t[sub_v][yoffset] += orig_psi[start] *
	cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_v, orig_y, sub_v, tmap, orig_psi);
  return;
}

/**************************************************************************
 * EPN 08.31.06
 * Function: cm2sub_cm_sum_subpaths()
 *
 * Purpose:  Calculate probability of getting from one state (start) to
 *           another (end) in a CM, taking special considerations involving
 *           insert states.
 *
 *           This function is similar to CP9_cm2wrhmm::cm_sum_subpaths_cp9()
 *           but was written for mapping transitions in a template CM (orig_cm)
 *           to those in a sub CM built from that template. The sub_cm conversion
 *           process is more complex and this function requires more functionality
 *           than the *_cp9() version.
 *
 *           When getting a transition probability for the sub_cm state 'v' in node
 *           'n', we ignore the contribution of subpaths that correspond to other
 *           transitions out of states in 'n'.
 *           For example, we don't want to include the probability of an
 *           IL (nd 'n') -> MATL_ML (nd 'n'+1) sub parse when calculating
 *           the transition probability for MATL_ML (nd 'n') -> MATL_ML (nd 'n'+1)
 *           because the IL (nd 'n') -> MATL_ML (nd 'n'+1) exists and should
 *           contain that probability mass. This is an easy example to skip,
 *           there are several other instances where it's more complex to
 *           ignore subpaths involving inserts like this.
 *
 *           Importantly, this function does not correctly calculate the transition
 *           virtual counts for only the states in the ROOT_nd. This is because
 *           the ROOT_nd has 2 insert states, which makes it much more complex to
 *           properly ignore subparses involving both these inserts. The
 *           cm2sub_cm_subtract_root_subpaths() function corrects the counts for
 *           the ROOT states. MATP_nd's also have 2 insert states but when constructing
 *           sub_cm's the only  MATP_nd's that exist have an exact mapping MATP_nd in
 *           the orig_cm, which makes them easier to handle.
 *
 *           In some cases, this function calls itself to determine the probabilities
 *           of subparses that it should ignore. It is for these cases that it's
 *           necessary to have the init_sub_start parameter passed in, which is
 *           the sub_cm state the initial call (non-recursive call) of this function
 *           was calculating transitions out of.
 *
 * Args:
 * CM_t   *orig_cm        - the original, template CM
 * CM_t   *sub_cm         - the sub CM
 * int     orig_v         - orig_cm state that maps to sub_v (1 of potentially 2)
 * int     orig_y         - orig_cm state that maps to sub_y (1 of potentially 2)
 * int     sub_v          - sub_cm state; we're calc'ing transitions out of sub_v
 * int     sub_y          - sub_cm state; we're calc'ing transitions into sub_y
 * int     init_sub_start - the sub_cm state the initial (non-recursive call) had as sub_v.
 * double *orig_psi       - for orig_cm: orig_psi[v] is the expected number of times state v
 *                          is entered in a CM parse
 *
 * Returns: FLOAT, the summed probability of all subpaths through the CM
 *          starting at "start" and ending at "end" that don't pass through
 *          orig_cm inserts that map to sub_cm insert states in the same node as init_sub_start.
 */
static float
cm2sub_cm_sum_subpaths(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, int orig_v, int orig_y,
		       int init_sub_start, char ***tmap, double *orig_psi)
{
  int     status;
  int     v,x,y;           /* state indices in the orig_cm                             */
  int     start, end;      /* min(orig_v, orig_y) and max(orig_v, orig_y) respectively */
  float   to_return;       /* the probability mass we're returning                     */
  char    tmap_val;        /* a value in the hard-coded tmap                           */
  int     is_insert;       /* TRUE if v is insert, FALSE if not                        */
  float   insert_to_start; /* prob mass going into start that we must ignore (see code)*/
  float   end_to_insert;   /* prob mass going out of end that we must ignore (see code)*/
  int     skip_flag;       /* TRUE to skip state v's contribution (see code)           */
  int     init_sub_nd;     /* sub_cm node containing init_sub_start                    */
  int     sub_insert1;     /* a sub_cm insert state in sub_cm node init_sub_nd, or -1  */
  int     sub_insert2;     /* a sub_cm insert state in sub_cm node init_sub_nd, or -1  */
  int     orig_insert1;    /* the orig_cm state that map to sub_insert1, or -1         */
  int     orig_insert2;    /* the orig_cm state that map to sub_insert2, or -1         */
  float   self_loop_factor;/* for dealing with self-insert loops                       */
  int     sub_start1;      /* a sub_cm state that maps to orig_cm's 'start'            */
  int     sub_start2;      /* a sub_cm state that maps to orig_cm's 'start' or -1      */
  int     sub_end1;        /* a sub_cm state that maps to orig_cm's 'end'              */
  int     sub_end2;        /* a sub_cm state that maps to orig_cm's 'end' or -1        */
  double *sub_psi;         /* sub_psi[v] is the expected number of times state v is    *
			    * entered given we started at state "start",  and we       *
			    * didn't go through orig_insert1 or orig_insert2           */

  if(orig_v == -1 || orig_y == -1)
	return 0.;

  start = orig_v;
  end   = orig_y;
  if(start > end)
	{ start = orig_y; end = orig_v; }
  if(start == end)
	return orig_cm->t[start][0]; /* return self-insert probability */

  /*printf("\nin cm2sub_cm_sum_subpaths2: start: %d | end: %d\n", start, end);*/

  ESL_ALLOC(sub_psi, sizeof(double) * (end - start + 1));
  sub_psi[0] = 1.; /* Initialize sub_psi[0]. We have to start in "start" */

  /* First we store some useful information for later in the function,
   * we do this and use descriptive variable names to make the code
   * later easier to follow. */

  /* Determine the 1 or 2 sub_cm states that map to
   * the orig_cm state start and end, and store these
   * in sub_start{1,2} and sub_end{1,2} respectively. */
  sub_start1 = submap->o2s_smap[start][0];
  sub_start2 = submap->o2s_smap[start][1];
  sub_end1   = submap->o2s_smap[end  ][0];
  sub_end2   = submap->o2s_smap[end  ][1];

  /* Determine the 0, 1, or 2 sub_cm insert states in the same
   * node as init_sub_start, store these in sub_insert1 and
   * sub_insert2.
   */
  init_sub_nd = sub_cm->ndidx[init_sub_start];
  orig_insert1 = orig_insert2 = sub_insert1 = sub_insert2 = -1;
  if(sub_cm->ndtype[init_sub_nd] == MATP_nd)
	{
	  sub_insert1 = sub_cm->nodemap[init_sub_nd] + 4; /* MATP_IL */
	  sub_insert2 = sub_cm->nodemap[init_sub_nd] + 5; /* MATP_IR */
	}
  else if(sub_cm->ndtype[init_sub_nd] == ROOT_nd)
	{
	  sub_insert1 = 1; /* ROOT_IL */
	  sub_insert2 = 2; /* ROOT_IR */
	}
  else if(sub_cm->ndtype[init_sub_nd] == MATL_nd ||
	  sub_cm->ndtype[init_sub_nd] == MATR_nd ||
	  sub_cm->ndtype[init_sub_nd] == BEGR_nd)
	sub_insert1 = sub_cm->cfirst[init_sub_start]; /* MAT{L,R}_I{L,R} or BEGR_IL */

  /* Set orig_insert{1,2} as the orig_cm states that map to sub_insert{1,2}. */
  if(sub_insert1 != -1) orig_insert1 = submap->s2o_smap[sub_insert1][0];
  if(sub_insert2 != -1) orig_insert2 = submap->s2o_smap[sub_insert2][0];

  /* Step through states between start and end, keeping track of prob mass. */
  for (v = (start+1); v <= end; v++)
	{
	  sub_psi[v-start] = 0.; /* initialize */
	  is_insert = FALSE;
	  if(orig_cm->sttype[v] == IL_st || orig_cm->sttype[v] == IR_st)
	is_insert = TRUE;
	  if(orig_cm->sttype[v] == S_st)
	{
	  /* Previous state is either a BIF_B or a END_E, and there's no transitions
	   * FROM previous state to this state, so we handle this in a special way.*/
	  sub_psi[v-start] = sub_psi[(v-1)-start];
	}
	  /* Determine if we should skip the contribution of state v because
	   * it will be correctly counted in a subsequent call of this function
	   * for a different sub_cm transition. We want to do this if:
	   *    (1) v is not end
	   *    (2) v is an orig_cm insert state (orig_insert{1,2}) that maps
	   *        to a sub_cm insert state (sub_insert{1,2}) in the same node
	   *        as init_sub_start.
	   *    (3) sub_insert{1,2} is equal to or downstream of init_sub_start
	   *    (4) a sub_cm transition exists between the sub_insert{1,2} and
	   *        a sub_cm state that maps to orig_cm start (sub_start{1,2})
	   *        or end (sub_end{1,2}).
	   */
	  skip_flag = FALSE;
	  if (v != end && v == orig_insert1 && sub_insert1 >= init_sub_start)
	{
	  if(cm_trans_check(sub_cm, sub_insert1, sub_end1  ) ||
	     cm_trans_check(sub_cm, sub_insert1, sub_end2  ) ||
	     cm_trans_check(sub_cm, sub_insert1, sub_start1) ||
	     cm_trans_check(sub_cm, sub_insert1, sub_start2))
	    skip_flag = TRUE;
	}
	  else if (v != end && v == orig_insert2 && sub_insert2 >= init_sub_start)
	{
	  if(cm_trans_check(sub_cm, sub_insert2, sub_end1  ) ||
	     cm_trans_check(sub_cm, sub_insert2, sub_end2  ) ||
	     cm_trans_check(sub_cm, sub_insert2, sub_start1) ||
	     cm_trans_check(sub_cm, sub_insert2, sub_start2))
	    skip_flag = TRUE;
	}
	  if(!skip_flag)
	{
	  for (y = orig_cm->pnum[v]-1; y >= is_insert; y--)
	    {
	      x = orig_cm->plast[v] - y;
	      /* x is a parent of v, we're adding contribution of a transition from x to v. */
	      tmap_val = tmap[(int) orig_cm->stid[x]][(int) orig_cm->ndtype[orig_cm->ndidx[v]+is_insert]][(int) orig_cm->stid[v]];
	      /* assert(tmap_val != -1); */
	      if((x - start) < 0) sub_psi[v-start] += 0.;
	      else sub_psi[v-start] += sub_psi[x-start] * orig_cm->t[x][(int) tmap_val];
	    }
	  if(v != end && is_insert) /* if v is end, we don't include the self loop contribution */
	    sub_psi[v-start] += sub_psi[v-start] *
	      (orig_cm->t[v][0] / (1-orig_cm->t[v][0])); /* else we include the self loop contribution */
	}
	}
  to_return = sub_psi[end-start];

  /* If start and end are both not inserts, we need to ignore some of the
   * probability mass that comes INTO 'start' and goes OUT OF 'end'.
   * Specifically we need to ignore the probability mass that
   * is accounted for by transitions either TO OR FROM the sub_cm insert
   * states in the same sub_cm node as init_sub_start (sub_insert{1,2}).
   * This code block is related to the block with the (for(v = start+1..) block
   * above involving the 'skip_flag' which skips states accounted for by
   * the sub_cm insert states sub_insert{1,2} between start..end, this
   * block handles the case where the orig_cm insert states that map
   * to sub_insert{1,2}, namely orig_insert{1,2}, fall outside start..end.
   */
  insert_to_start = 0.;
  end_to_insert = 0.;

  if((orig_cm->sttype[start] != IL_st && orig_cm->sttype[start] != IR_st) &&
	 (orig_cm->sttype[end]   != IL_st && orig_cm->sttype[end]   != IR_st))
	{
	  if(orig_insert1 != -1 && orig_insert1 < start)
	{
	  if(orig_cm->sttype[start] == IL_st || orig_cm->sttype[start] == IR_st)
	    self_loop_factor = (1. + (orig_cm->t[start][0] / (1. - orig_cm->t[start][0])));
	  else
	    self_loop_factor = 1.0;
	  insert_to_start += self_loop_factor * orig_psi[orig_insert1] *
	    cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_insert1, start, init_sub_start, tmap, orig_psi);
	}
	  if(orig_insert1 != -1 && orig_insert1 > end)
	end_to_insert += cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, end, orig_insert1, init_sub_start, tmap, orig_psi);

	  if(orig_insert2 != -1 && orig_insert2 < start)
	{
	  self_loop_factor = 1.0;
	  if(orig_cm->sttype[start] == IL_st ||
	     orig_cm->sttype[start] == IR_st)
	    self_loop_factor = (1. + (orig_cm->t[start][0] / (1. - orig_cm->t[start][0])));
	  insert_to_start += self_loop_factor * orig_psi[orig_insert2] * cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_insert2, start, init_sub_start, tmap, orig_psi);
	}
	  if(orig_insert2 != -1 && orig_insert2 > end)
	end_to_insert += cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, end, orig_insert2, init_sub_start, tmap, orig_psi);

	  /*printf("\t\tinsert_to_start: %f sub_psi[0]: %f\n", insert_to_start, sub_psi[0]);
	printf("\t\tend_to_insert: %f sub_psi[end-start]: %f\n", end_to_insert, sub_psi[(end-start)]);*/
	}
  to_return *= (1. - (insert_to_start / orig_psi[start]));
  to_return *= (1. - end_to_insert);
  /*printf("***returning from cm2sub_cm_sum_subpaths (s: %d | e: %d): %f\n", start, end, to_return);*/

  free(sub_psi);
  return (float) to_return;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/**************************************************************************
 * EPN 09.01.06
 * debug_print_cm_params()
 *
 * Purpose:  Print out emission and transition probabilities and scores
 *           for a CM.
 *
 * Args:
 * fp        stdout often
 * CM_t *cm
 * Returns: (void)
 */
void
debug_print_cm_params(FILE *fp, CM_t *cm)
{
  int status;
  int v, i;
  int yoffset;

  char **nodetypes;
  char **sttypes;

  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  fprintf(fp, "cm->nodes: %d\n", cm->nodes);
  fprintf(fp, "cm->M:     %d\n", cm->M);
  for(v = 0; v < cm->M; v++)
	{
	  fprintf(fp, "v:%4d:%4d %4s %2s\n", v, cm->ndidx[v], nodetypes[(int) cm->ndtype[cm->ndidx[v]]], sttypes[(int) cm->sttype[v]]);
	  if(cm->nodemap[cm->ndidx[v]] == v)
	fprintf(fp, "beg: %0.6f (%.6f %10d)| end %0.6f (%.6f %10d)\n",
		cm->begin[v], cm->beginsc[v], cm->ibeginsc[v],
		cm->end[v], cm->endsc[v], cm->iendsc[v]);
	  if(cm->sttype[v] == MP_st)
	{
	  fprintf(fp, "\tE: ");
	  for(i = 0; i < cm->abc->K*cm->abc->K; i++)
	    fprintf(fp, "%0.6f (%.6f %6d) ", cm->e[v][i], cm->esc[v][i], cm->iesc[v][i]);
	  fprintf(fp, "\n");
	}
	  else if(cm->sttype[v] == ML_st ||
	      cm->sttype[v] == MR_st ||
	      cm->sttype[v] == IL_st ||
	      cm->sttype[v] == IR_st)
	{
	  fprintf(fp, "\tE: ");
	  for(i = 0; i < cm->abc->K; i++)
	    fprintf(fp, "%0.6f (%0.6f %10d) ", cm->e[v][i], cm->esc[v][i], cm->iesc[v][i]);
	  fprintf(fp, "\n");
	}
	  if(cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	{
	  fprintf(fp, "\tT: ");
	  for(yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
	    fprintf(fp, "%0.6f (%0.6f %10d) ", cm->t[v][yoffset], cm->tsc[v][yoffset], cm->itsc[v][yoffset]);
	  fprintf(fp, "\n");
	}
	  else if(cm->sttype[v] == B_st)
	{
	  fprintf(fp, "\tL: %d | R: %d\n", cm->cfirst[v], cm->cnum[v]);
	}
	  else if(cm->sttype[v] == E_st)
	fprintf(fp, "\n\n");
	}
  fprintf(fp, "\n\n");
  free(nodetypes);
  free(sttypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 09.01.06
 * Function: check_sub_cm_by_sampling()
 *
 * Purpose:  Given a CM and a sub CM that is supposed to mirror
 *           the CM as closely as possible between two given consensus
 *           columns (spos and epos), check that the sub_cm was correctly
 *           constructed.
 *
 *           The current approach is to build a CM Plan 9 HMM from the
 *           sub CM, then sample from the CM and see if the samples
 *           were likely drawn from the CM Plan 9 distributions.
 *           This is done inside CP9_cm2wrhmm::CP9_check_by_sampling().
 *
 * Args:
 * orig_cm     - the original, template CM
 * sub_cm      - the sub CM built from the orig_cm
 * errbuf      - for error messages
 * r           - source of randomness
 * submap      - map from orig_cm to sub_cm and vice versa
 * subinfo     - sub cm information
 * chi_thresh  - rejection threshold for chi-squared tests
 * nsamples    - number of samples to use to build the ML HMM
 * print_flag  - TRUE to print useful info for debugging
 *
 * Returns: eslOK   if CM and sub CM are "close enough" (see code)
 *          eslFAIL otherwise, errbuf is filled
 */
int
check_sub_cm_by_sampling(CM_t *orig_cm, CM_t *sub_cm, char *errbuf, ESL_RANDOMNESS *r, CMSubMap_t *submap, CMSubInfo_t *subinfo,
			 float chi_thresh, int nsamples, int print_flag)
{
  int       status;
  CP9_t    *orig_hmm;    /* constructed CP9 HMM from the original cm */
  CP9_t    *sub_hmm;     /* constructed CP9 HMM from the sub_cm */
  CP9Map_t *orig_cp9map; /* maps the orig_cm to the orig_hmm and vice versa */
  CP9Map_t *sub_cp9map;  /* maps the sub_cm to the sub_hmm and vice versa */

  /* Build two CP9 HMMs, one for the orig_cm and one for the sub_cm */
  if((status = build_cp9_hmm(orig_cm, errbuf, FALSE, 0.0001, print_flag, &orig_hmm, &orig_cp9map)) != eslOK) return status;
  if((status = build_cp9_hmm(sub_cm,  errbuf, FALSE, 0.0001, print_flag, &sub_hmm,  &sub_cp9map)) != eslOK) return status;
  CP9Logoddsify(orig_hmm);
  CP9Logoddsify(sub_hmm);

  /* Look for 'impossible' cases where we know the sub_cm
   * construction procedure fails, in that the distribution of transitions out of CP9 nodes
   * built from the sub_cm will be the same distros out of corresponding CP9 nodes built from
   * the full CM. */
  cm2sub_cm_find_impossible_misc_cases(orig_cm, sub_cm, submap, subinfo, orig_cp9map, sub_cp9map, print_flag);
  cm2sub_cm_find_impossible_matr_cases(orig_cm, sub_cm, submap, subinfo, orig_cp9map, sub_cp9map, print_flag);

  if((status = CP9_check_by_sampling(orig_cm, sub_hmm, errbuf, r, subinfo, submap->spos, submap->epos, chi_thresh, nsamples, print_flag)) != eslOK) return status;
  if(print_flag) printf("CM Plan 9 built from sub_cm passed sampling check; sub_cm was built correctly.\n");

  FreeCPlan9(orig_hmm);
  FreeCPlan9(sub_hmm);
  FreeCP9Map(orig_cp9map);
  FreeCP9Map(sub_cp9map);
  return eslOK;
}

/**************************************************************************
 * EPN 09.07.06
 * check_orig_psi_vs_sub_psi()
 *
 * Purpose:  Check that the psi values for an original, template CM and
 *           a sub CM are withing a given leeway threshold, given maps
 *           from the states of the original to the sub and vice versa.
 *
 * Args:
 * orig_cm    - the original, template CM
 * sub_cm     - the sub CM
 * errbuf     - for error messages
 * submap     - the map data structure for the sub CM
 * threshold  - the threshold that mapping (potentially summed) psi
 *              values are allowed to be different by, without throwing an error.
 * print_flag  - TRUE to print out the values, FALSE not to
 *
 * Returns: eslOK   if CM and sub CM are "close enough" (see code)
 *          eslFAIL otherwise, errbuf is filled
 */
int
check_orig_psi_vs_sub_psi(CM_t *orig_cm, CM_t *sub_cm, char *errbuf,CMSubMap_t *submap, double threshold,
			  int print_flag)
{
  int v_s; /* sub_cm state index*/
  int v_o; /* orig_cm state index*/
  double temp_psi;
  int violation;
  int v_ct; /* Number of violations */
  int detached_insert;
  int is_insert;
  int root_v_ct;
  float diff;
  double     *orig_psi;    /* expected num times each state visited in orig_cm */
  double     *sub_psi;     /* expected num times each state visited in sub_cm  */

  /* Fill orig_psi and sub_psi parameters. */
  if((orig_psi = cm_ExpectedStateOccupancy(orig_cm)) == NULL) ESL_FAIL(eslFAIL, errbuf, "check_orig_psi_vs_sub_cm(), unable to calculate expected state occupancy for orig_cm()");
  if((sub_psi  = cm_ExpectedStateOccupancy(sub_cm))  == NULL) ESL_FAIL(eslFAIL, errbuf, "check_orig_psi_vs_sub_cm(), unable to calculate expected state occupancy for sub_cm()");

  if(print_flag)
	{
	  printf("Printing psi in check_orig_psi_vs_sub_psi():\n");
	  for(v_o = 0; v_o < orig_cm->M; v_o++)
	printf("orig_psi[%4d]: %.6f\n", v_o, orig_psi[v_o]);

	}

  v_ct = 0;
  root_v_ct = 0;
  if(print_flag == TRUE) printf("\n");
  for(v_s = 0; v_s < sub_cm->M; v_s++)
	{
	  detached_insert         = FALSE;
	  if(sub_cm->sttype[v_s] == IL_st || sub_cm->sttype[v_s] == IR_st)
	is_insert = TRUE;
	  else
	is_insert = FALSE;

	  if(print_flag) printf("\tv_s: %4d (%.6f) ", v_s, sub_psi[v_s]);
	  v_o = submap->s2o_smap[v_s][0];
	  if(sub_cm->sttype[v_s+1] == E_st) detached_insert = TRUE;
	  if(v_o != -1)
	{
	  if(print_flag) printf("v_o1: %4d (%.6f) ", v_o, orig_psi[v_o]);
	  temp_psi = orig_psi[v_o];
	  v_o = submap->s2o_smap[v_s][1];
	  if(v_o != -1)
	    {
	      if(is_insert) /* this insert state maps to 2 orig_cm inserts */
		ESL_FAIL(eslFAIL, errbuf, "check_orig_psi_vs_sub_psi(), sub insert state maps to 2 orig_cm inserts.");
	      temp_psi += orig_psi[v_o];
	      if(print_flag)
		printf("v_o2: %4d (%.6f)\n", v_o, orig_psi[v_o]);
	    }
	  else
	    if(print_flag) printf("\n");

	  violation = FALSE;
	  if(detached_insert)
	    temp_psi = 0.0;

	  /* 10.20.06 Found an exceedingly rare case (2 cases in all possible sub CM
	   * models of RMARK) where psi test fails with diff < 0.00002 but > 0.00001
	   * (our default). Both cases involve insert self loops with p > 0.9,
	   * the reason (I'm pretty sure) these guys fail is because when the
	   * contribution of the self insertion loop is included in fill_psi, even
	   * if the self-insert probs for a sub_cm and orig_cm state are equal, if
	   * the psi values for that state BEFORE the contribution of the self insert
	   * is added are > 0.0000001 or so, the self insert contributions amplifies
	   * that difference above our 0.00001 threshold. This only happens if the
	   * self insert probs are really high and explains the rareness of this case.
	   * The approach to fixing it is to subtract out the self loop contribution
	   * prior to checking if we exceed our threshold.
	   */
	  if(is_insert && !detached_insert)
	    {
	      diff = (sub_psi[v_s] - (sub_psi[v_s] * sub_cm->t[v_s][0])) -
		(temp_psi - (temp_psi * orig_cm->t[submap->s2o_smap[v_s][0]][0]));
	    }
	  else
	    diff = sub_psi[v_s] - temp_psi;
	  if((diff > threshold) || ((-1. * diff) > threshold))
	    {
	      violation = TRUE;
	      v_ct++;
	      if((sub_cm->ndidx[v_s] == 0) || (sub_cm->ndidx[v_s] == 1))
		{
		  root_v_ct++;
		}
	    }
	  if(violation)
	    printf("sub: %.6f | orig: %.6f | diff: %.6f VIOLATION\n\n", sub_psi[v_s], temp_psi, (sub_psi[v_s]-temp_psi));
	  else if(detached_insert && print_flag)
	    printf("sub: %.6f | orig: %.6f | diff: %.6f (DEAD INSERT)\n\n", sub_psi[v_s], temp_psi, (sub_psi[v_s]-temp_psi));
	  else if(print_flag)
	    printf("sub: %.6f | orig: %.6f | diff: %.6f\n\n", sub_psi[v_s], temp_psi, (sub_psi[v_s]-temp_psi));
	}
	  else
	{
	  if(!detached_insert &&
	     sub_cm->sttype[v_s] != E_st &&
	     sub_cm->sttype[v_s] != B_st &&
	     sub_cm->sttype[v_s] != S_st &&
	     sub_cm->sttype[v_s] != EL_st)
	    ESL_FAIL(eslFAIL, errbuf, "check_orig_psi_vs_sub_psi() state v_s:%d maps to nothing and its not E,B,S,EL\n", v_s);
	  if(print_flag) printf("E B S or EL\n");
	}
	}

  if(v_ct > 0) ESL_FAIL(eslFAIL, errbuf, "check_orig_psi_vs_sub_psi(): check failed");
  else
	if(print_flag) printf("v_ct is 0 with thresh: %f!\n", threshold);
  if(root_v_ct > 0)
	printf("ROOT v_ct is %d with thresh: %f!\n", root_v_ct, threshold);

  /* Cleanup and exit. */
  free(orig_psi);
  free(sub_psi);

  return eslOK;
}

/**************************************************************************
 * EPN 09.11.06
 * cm_trans_check()
 *
 * Return TRUE if there's a transition in the CM from state a to state b.
 *
 * Args:
 * CM_t  cm,
 * int   a;
 * int   b;
 * Returns: TRUE if b is a child of a (a->b exists)
 *          FALSE otherwise
 */
int
cm_trans_check(CM_t *cm, int a, int b)
{
  /*printf("\t**in cm_trans_check a: %d | b: %d\n", a, b);*/

  if((a == -1 || b == -1) || (a > b))
	return FALSE;

  if((b - cm->cfirst[a]) < cm->cnum[a])
	{ /*printf("returning TRUE") ;*/ return TRUE; }

  return FALSE;

}

/**************************************************************************
 * EPN 09.21.06
 * Function: cm2sub_cm_subtract_root_subpaths()
 *
 * Purpose:  When building a sub CM (sub_cm) from an original, template
 *           CM (orig_cm), there's special considerations that must be
 *           taken involving sub_cm nodes with 2 insert states where there
 *           isn't an exactly identical node in the original CM. The only
 *           node that potentially meets this criteria is the ROOT_nd because
 *           all MATP nodes in sub_cm must necessarily also exist in the
 *           orig_cm.
 *
 *           The problem is that we have overcounted certain subpaths when
 *           transitioning out of the sub_cm ROOT_S and ROOT_IL states.
 *
 *           For each sub_cm ROOT_IL state, there are up to 2 orig_cm inserts
 *           that map to it (orig_il1 and orig_il2), and analagously for sub_cm
 *           ROOT_IR (orig_ir1 and orig_ir2). Then there are up to 2 sub_cm states
 *           that map to each of the split set states in sub_cm node 1 (orig_ss1
 *           and orig_ss2). The subpaths that we have overcounted is dependent
 *           on the relationship between orig_il*, orig_ir*, and orig_ss*.
 *           There are six cases of this relationship:
 *
 *             cases 1A, 1B, 1C apply when il < ir.
 *             case 1A: il < ir < ss (this is correctly handled by cm2sub_cm_sum_subpaths())
 *             case 1B: il < ss < ir
 *             case 1C: ss < il < ir
 *
 *             cases 2A, 2B, 2C apply when ir < il.
 *             case 2A: ir < il < ss
 *             case 2B: ir < ss < il
 *             case 2C: ss < ir < il
 *
 *           These cases are not explicitly checked for in the code but were
 *           useful for determining the correct strategy to use here, and
 *           are mentioned in comments throughout the code.
 *
 *           This function calls a helper function for each pair of orig_il* and
 *           orig_ir* (up to 4 possible pairs), which actually subtracts
 *           the path based on the relationships of orig_il*, orig_ir* and
 *           orig_ss*.
 *
 *           Importantly, though there are potentially many orig_ss* states
 *           (up to 2 that map to each sub_cm node 1 split set state),
 *           they all must be close enough in state indices that we'll
 *           never have a case where for a specific il* and ir* we get more
 *           than 1 of the 6 possible cases for all orig_ss*. This is
 *           because either the orig_ss are in a sub_cm MATP node - in
 *           which case they MUST map to exactly 1 state each in the orig_cm
 *           (to the corresponding MATP node) and are contiguous state indices,
 *           or they are a MATL or MATR which either map to a corresponding
 *           MATL, MATR (in which case they're contiguous) or each sub_cm
 *           split state maps to exactly 2 states in the same orig_cm MATP
 *           node, (for example MATL_ML might map to MATP_MP and MATP_ML)
 *           which are all in the same node and thus have no insert states
 *           with a state index between the indices of the 2 states they
 *           map to (ouch).
 *
 *
 * Args:
 * CM_t *orig_cm     - the original, template CM
 * CM_t *sub_cm      - the sub CM
 * double *orig_psi  - for orig_cm: orig_psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap      - the hard-coded transition map
 * CMSubMap_t *submap- the map from the sub CM to the template CM
 * int print_flag    - TRUE to print useful debugging info
 *
 * Returns: VOID
 */
static void
cm2sub_cm_subtract_root_subpaths(CM_t *orig_cm, CM_t *sub_cm, double *orig_psi, char ***tmap,
				 CMSubMap_t *submap, int print_flag)

{
  int sub_root_s;
  int sub_il;
  int sub_ir;
  int yoffset;
  int sub_y;
  int orig_y;
  int orig_il;
  int orig_ir;
  int orig_ss;
  int orig_ss1;
  int orig_ss2;

  sub_root_s = 0; /* sub_cm ROOT_S index */
  sub_il = 1; /* sub ROOT_IL index */
  sub_ir = 2; /* sub ROOT_IR index */
  orig_il = submap->s2o_smap[sub_il][0];
  orig_ir = submap->s2o_smap[sub_ir][0];

  if(print_flag) printf("\n\nin cm2sum_cm_subtract_root_subpaths_helper: orig_il: %d orig_ir: %d\n", orig_il, orig_ir);

  for(yoffset = 0; yoffset < sub_cm->cnum[0]; yoffset++)
	if(print_flag) printf("Before t[0][%d] = %f\n", yoffset, sub_cm->t[0][yoffset]);

  orig_ss = submap->s2o_smap[3][0]; /* orig_ss is the 1 (of possibly 2) orig_cm states that map to the first
				     * state in sub_cm node 1 (sub_cm state 3)
				     */
  /* Check to make sure that all the split states meet our guarantee (not necessary) */
  for(yoffset = 2; yoffset < sub_cm->cnum[0]; yoffset++) /* note we start at yoffset = 2
							  * ROOT_S -> first state of next
							  * node's split set. */
	{
	  sub_y = yoffset + sub_cm->cfirst[0];
	  orig_y = submap->s2o_smap[sub_y][0];
	  if((orig_il > orig_ss && orig_il < orig_y) ||
	 (orig_il < orig_ss && orig_il > orig_y) ||
	 (orig_ir > orig_ss && orig_ir < orig_y) ||
	 (orig_ir < orig_ss && orig_ir > orig_y))
	cm_Fail("ERROR in cm2sub_cm_subtract_root_subpaths_helper() split set state guarantee violated!\n");
	}

  /* Check for which of the 6 cases we have (not actually necessary) */
  if((orig_il < orig_ir) && (orig_ir < orig_ss))
	if(print_flag) printf("ROOT NODE case 1A\n");
  if((orig_il < orig_ss) && (orig_ss < orig_ir))
	if(print_flag) printf("ROOT NODE case 1B\n");
  if((orig_ss < orig_il) && (orig_il < orig_ir))
	if(print_flag) printf("ROOT NODE case 1C\n");

  if((orig_ir < orig_il) && (orig_il < orig_ss))
	if(print_flag) printf("ROOT NODE case 2A\n");
  if((orig_ir < orig_ss) && (orig_ss < orig_il))
	if(print_flag) printf("ROOT NODE case 2B\n");
  if((orig_ss < orig_ir) && (orig_ir < orig_il))
	if(print_flag) printf("ROOT NODE case 2C\n");

  /* First adjust counts out of sub_cm ROOT_S */

  /* if orig_ir < orig_il, we've counted paths from
   * ir -> il correctly for ROOT_IL -> ROOT_IR and
   *        incorrectly for ROOT_S  -> ROOT_IR
   */
  if(orig_ir < orig_il)
	{
	  if(print_flag) printf("0 sub from S->IR, IR -> IL\n"); /* cases 2A, 2B, 2C */
	  sub_cm->t[sub_root_s][1] -= orig_psi[orig_ir] *
	cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir, orig_il, 0, tmap, orig_psi);
	}

  /* All the remaining paths to be subtracted involve the split set state of
   * node 1. */
  for(yoffset = 0; yoffset < sub_cm->cnum[0]; yoffset++)
	{
	  sub_y = sub_cm->cfirst[0] + yoffset;
	  orig_ss1 = submap->s2o_smap[sub_y][0];
	  orig_ss2 = submap->s2o_smap[sub_y][1];
	  if(sub_cm->ndidx[sub_y] != 0)
	{
	  /* Adjust counts out of ROOT_IL if necessary */

	  /* if orig_ir < orig_ss < orig_il, we've counted paths from
	   * ir -> ss -> il correctly for ROOT_IL -> ROOT_IR and
	   *              incorrectly for ROOT_IL -> ROOT_SS
	   */
	  if(orig_ir < orig_ss && orig_ss < orig_il) /* case 2B only */
	    {
	      if(print_flag) printf("3 (2b) sub from IL, IR -> SS -> IL\n");

	      /* subtract paths from orig_ir -> orig_ss1 -> orig_il */
	      sub_cm->t[sub_il][yoffset] -= orig_psi[orig_ir] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir, orig_ss1,
				       sub_il, tmap, orig_psi) *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss1, orig_il,
				       sub_il, tmap, orig_psi);
	      if(orig_ss2 != -1)
		/* subtract paths from orig_ir -> orig_ss2 -> orig_il */
		sub_cm->t[1][yoffset] -= orig_psi[orig_ir] *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir, orig_ss2,
					 sub_il, tmap, orig_psi) *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss2, orig_il,
					 sub_il, tmap, orig_psi);

	    }

	  /* if orig_ss < orig_il < orig_ir, we've counted paths from
	   * ss -> il -> ir correctly for ROOT_IR -> ROOT_SS and
	   *              incorrectly for ROOT_IL -> ROOT_SS
	   */
	  if(orig_ss < orig_il && orig_il < orig_ir) /* case 1C only */
	    {
	      if(print_flag) printf("4 (1c) sub from IL, SS -> IL -> IR\n");

	      /* subtract paths from orig_ss1 -> orig_il (add self insert) -> orig_ir */
	      sub_cm->t[sub_il][yoffset] -= orig_psi[orig_ss1] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss1, orig_il,
				       sub_il, tmap, orig_psi) *
		(1. + (orig_cm->t[orig_il][0] / (1 - orig_cm->t[orig_il][0]))) *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ir,
				       sub_il, tmap, orig_psi);

	      if(orig_ss2 != -1)
		/* subtract paths from orig_ss2 -> orig_il (add self insert) -> orig_ir */
		sub_cm->t[sub_il][yoffset] -= orig_psi[orig_ss2] *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss2, orig_il,
					 sub_il, tmap, orig_psi) *
		  (1. + (orig_cm->t[orig_il][0] / (1 - orig_cm->t[orig_il][0]))) *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ir,
					 sub_il, tmap, orig_psi);
	    }

	  /* if orig_ir < orig_il < orig_ss, we've counted paths from
	   * ir -> il -> ss correctly for ROOT_IR -> ROOT_SS and
	   *              incorrectly for ROOT_IL -> ROOT_SS
	   */
	  if(orig_ir < orig_il && orig_il < orig_ss) /* case 2A only */
	    {
	      if(print_flag) printf("5 (2a) sub from IL, IR -> IL -> SS\n");

	      /* subtract paths from orig_ir -> orig_il (add self insert) -> orig_ss1 */
	      sub_cm->t[sub_il][yoffset] -= orig_psi[orig_ir] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir, orig_il,
				       sub_il, tmap, orig_psi) *
		(1. + (orig_cm->t[orig_il][0] / (1 - orig_cm->t[orig_il][0]))) *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ss1,
				       sub_il, tmap, orig_psi);

	      if(orig_ss2 != -1)
		/* subtract paths from orig_ir -> orig_il (add self insert) -> orig_ss2 */
		sub_cm->t[sub_il][yoffset] -= orig_psi[orig_ir] *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ir, orig_il,
					 sub_il, tmap, orig_psi) *
		  (1. + (orig_cm->t[orig_il][0] / (1 - orig_cm->t[orig_il][0]))) *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ss2,
					 sub_il, tmap, orig_psi);

	    }

	  /* if orig_il < orig_ss < orig_ir, we've counted paths from
	   * il -> ss -> ir correctly for ROOT_IL -> ROOT_IR and
	   *              incorrectly for ROOT_IL -> ROOT_SS
	   */
	  if(orig_il < orig_ss && orig_ss < orig_ir) /* case 1B only */
	    {
	      if(print_flag) printf("6 (1b) sub from IL, IL -> SS -> IR\n");
	      if(print_flag) printf("1B before sub 1: sub_cm->t[sub_il:%d][yoffset:%d]: %f\n", sub_il, yoffset, sub_cm->t[sub_il][yoffset]);
	      /* subtract paths from orig_il -> orig_ss1 -> orig_ir */
	      sub_cm->t[sub_il][yoffset] -= orig_psi[orig_il] *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ss1,
				       sub_il, tmap, orig_psi) *
		cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss1, orig_ir,
				       sub_il, tmap, orig_psi);

	      if(print_flag) printf("1B before sub 2: sub_cm->t[sub_il:%d][yoffset:%d]: %f\n", sub_il, yoffset, sub_cm->t[sub_il][yoffset]);
	      if(orig_ss2 != -1)
		/* subtract paths from orig_il -> orig_ss2 -> orig_ir */
		sub_cm->t[sub_il][yoffset] -= orig_psi[orig_il] *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_il, orig_ss2,
					 sub_il, tmap, orig_psi) *
		  cm2sub_cm_sum_subpaths(orig_cm, sub_cm, submap, orig_ss2, orig_ir,
					 sub_il, tmap, orig_psi);
	      if(print_flag) printf("1B after sub 2: sub_cm->t[sub_il:%d][yoffset:%d]: %f\n", sub_il, yoffset, sub_cm->t[sub_il][yoffset]);

	    }
	}
	}
  for(yoffset = 0; yoffset < sub_cm->cnum[0]; yoffset++)
	if(print_flag) printf("After t[0][%d] = %f\n", yoffset, sub_cm->t[0][yoffset]);

  return;
}

/**************************************************************************
 * EPN 09.11.06
 * cm2sub_cm_check_id_next_node()
 *
 * It's known that sub_nd and orig_nd are identical nodes, in that they
 * are of the same type and model the same column of the seed alignment.
 * In this function, we check if the next node of the sub_cm and orig_nd
 * have the same relationship and if so, we update information in
 * the submap->s2o_id array, setting the sub_cm states of this node to
 * TRUE.
 *
 * Returns: void
 *
 * Args:
 * CM_t  orig_cm
 * CM_t  sub_cm
 * int   orig_nd
 * int   sub_nd
 * CMSubMap_t *submap
 * int   sub_start
 */

static int
cm2sub_cm_check_id_next_node(CM_t *orig_cm, CM_t *sub_cm, int orig_nd, int sub_nd,
			     CMSubMap_t *submap, CP9Map_t *orig_cp9map,
			     CP9Map_t *sub_cp9map, int print_flag)
{
  int v_s;
  int left_check, right_check;
  left_check = FALSE;
  right_check = FALSE;

  if((orig_nd+1) > (orig_cm->nodes-1))
	return FALSE;
  if((sub_nd+1)  > (sub_cm->nodes-1))
	return FALSE;
  if(orig_cm->ndtype[orig_nd] != sub_cm->ndtype[sub_nd])
	return FALSE;
  if(orig_cm->ndtype[orig_nd+1] != sub_cm->ndtype[sub_nd+1])
	return FALSE;

  if(orig_cp9map->nd2lpos[orig_nd+1] == -1 && sub_cp9map->nd2lpos[sub_nd+1] == -1)
	left_check = TRUE;
  if(orig_cp9map->nd2lpos[orig_nd+1] == (sub_cp9map->nd2lpos[sub_nd+1] + submap->spos -1))
	left_check = TRUE;
  if(orig_cp9map->nd2rpos[orig_nd+1] == -1 && sub_cp9map->nd2rpos[sub_nd+1] == -1)
	right_check = TRUE;
  if(orig_cp9map->nd2rpos[orig_nd+1] == (sub_cp9map->nd2rpos[sub_nd+1] + submap->spos -1))
	right_check = TRUE;

  if(left_check && right_check)
	{
	  v_s = sub_cm->nodemap[sub_nd];
	  while(sub_cm->ndidx[v_s] == sub_nd)
	{
	  if(print_flag) printf("setting submap->s2o_id[v_s:%d] to TRUE\n", v_s);
	  if(sub_cm->sttype[v_s+1] != E_st) submap->s2o_id[v_s] = TRUE; /* if v+1 is an E_st, it's a detached insert don't set s2o_id[v] to TRUE */
	  v_s++;
	}
	  return TRUE;
	}
  return FALSE;
}

/**************************************************************************
 * EPN 10.05.06
 * cm2sub_cm_find_impossible_misc_cases
 *
 * For certain situations, the conversion of an orig_cm to a sub_cm loses
 * some information that makes it impossible for a CP9 trained from the sub_cm
 * to exactly match a CP9 trained from the orig_cm for the corresponding
 * columns. One case where it is impossible involves start states as follows:
 *
 * if for any k k=spos..epos-1
 * X >= 0 start states exists in the orig_cm in a node between:
 *          orig_cp9map->pos2nd[k] -> orig_cp9map->pos2nd[k+1]
 * AND Y >= 1 start states exist in the sub_cm in a node between:
 *          sub_cp9map->pos2nd[k-spos+1] -> sub_cp9map->pos2nd[k-spos+1+1]
 * where X != Y
 *
 * AND further one or both of the two nodes in the sub_cm (sub_cp9map->pos2nd[k-spos+1]
 * OR sub_cp9map->pos2nd[k-spos+1+1] must be a MATP.
 *
 * This is because for the sub_cm paths that would go from CP9 node k to k+1
 * were forced to go through a start state where as for the orig_cm there
 * was not a requirement to go through a start. Therefore when the
 * sub_cm was constructed it lost some information about the original
 * transitions.
 *
 * Also, a special situation of this case occurs with transitions out of
 * CP9 node k=spos-1 to k=spos, and out of CP9 node k=epos to k=epos+1.
 * The sub_cm node that models columns spos-1 and epos-1 is the ROOT node,
 * which only really models inserts in those columns. It turns out that
 * the transition distributions will nearly always be screwy out of these
 * two nodes, except in the case when the sub_cm ROOT_IL and ROOT_IR map
 * to an IL and IR state respectivley in the original *within the same
 * orig_cm node*. In which case the transitions out of node 0 will be
 * identical to those out of node spos-1 in the orig_cm.
 * There are a few other rare cases where the transitions will be
 * identical, but an exhaustive understanding of them eludes me.
 * (see ~nawrockie/notebook/6_0725_inf_sub_cm/00LOG for more).
 *
 * Returns: void
 *
 * Args:
 * CM_t  orig_cm
 * CM_t  sub_cm
 * int *orig_cp9map->pos2nd
 * int *sub_cp9map->pos2nd
 * int *imp_cc
 * int spos;
 * int epos;
 */

static void
cm2sub_cm_find_impossible_misc_cases(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CMSubInfo_t *subinfo,
				     CP9Map_t *orig_cp9map, CP9Map_t *sub_cp9map, int print_flag)

{
  int status;
  int k;
  int sub_starts;
  int orig_starts;
  int orig_nd1;
  int orig_nd2;
  int sub_nd1;
  int sub_nd2;
  int temp;
  int nd;
  int orig_special_matps;
  int sub_special_matl;
  int sub_both_matps;
  CMEmitMap_t *orig_emap;         /* consensus emit map for the original, template CM */
  CMEmitMap_t *sub_emap;          /* consensus emit map for the sub CM */

  int orig_il1;
  int orig_il2;
  int orig_ir1;
  int orig_ir2;

  char **nodetypes;
  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  if(print_flag) printf("in cm2sub_find_impossible_misc_cases()\n");

  orig_emap = CreateEmitMap(orig_cm);
  sub_emap = CreateEmitMap(sub_cm);

  /* We know that the sub CM node 0 and node submap->sub_clen are nearly always going to
   * get the transition distributions wrong (see comments above in the function
   * explanation). There are a couple of cases they should get right
   * (see ~nawrockie/notebook/6_0725_inf_sub_cm/00LOG for details), we
   * check for these here:
   */
  subinfo->imp_cc[0] = 1;
  subinfo->imp_cc[submap->sub_clen] = 1;

  /* check if the orig_cm states that model sub_cm ROOT_IL and ROOT_IR are
   * from the same node. */
  orig_il1 = submap->s2o_smap[1][0]; /* 1st of up to 2 states that maps to sub_cm's ROOT_IL */
  orig_il2 = submap->s2o_smap[1][1]; /* 2nd state that maps to sub_cm's ROOT_IL or -1 if only 1 maps*/
  orig_ir1 = submap->s2o_smap[2][0]; /* 1st of up to 2 states that maps to sub_cm's ROOT_IR */
  orig_ir2 = submap->s2o_smap[2][1]; /* 2nd state that maps to sub_cm's ROOT_IR or -1 if only 1 maps*/

  /* We ASSUME that ambiguities have been removed, i.e. if two insert states map to either ROOT_IL
   * or ROOT_IR, one of them has been detached. We exploit this knowledge.
   */
  if(orig_il2 != -1)
	{
	  if(orig_cm->sttype[orig_il1+1] == E_st)
	orig_il1 = orig_il2; /* orig_il1 was detached */
	  else if(orig_cm->sttype[orig_il2+1] == E_st)
	{
	  /* do nothing */
	}
	  else
	cm_Fail("ERROR, can't determine which state was detached\n");
	}
  if(orig_ir2 != -1)
	{
	  if(orig_cm->sttype[orig_ir1+1] == E_st)
	orig_ir1 = orig_ir2; /* orig_ir1 was detached */
	  else if(orig_cm->sttype[orig_ir2+1] == E_st)
	{
	  /* do nothing */
	}
	  else
	cm_Fail("ERROR, can't determine which state was detached\n");
	}

  /* Now orig_il1 and orig_ir1 map to the ONLY insert states that map to sub_cm
   * ROOT_IL and ROOT_IR respectively. */
  if(orig_cm->ndidx[orig_il1] == orig_cm->ndidx[orig_ir1])
	{
	  /* we can get the distro out of 0 right in this case */
	  subinfo->imp_cc[0] = FALSE;
	  if(submap->spos == submap->sstruct && submap->epos == submap->estruct)
	subinfo->imp_cc[submap->sub_clen] = FALSE;
	}

  for(k = 1; k < submap->sub_clen; k++)
	{
	  if(print_flag) printf("k: %d\n", k);
	  if((k+submap->spos-1) == 0)
	orig_nd1 = 0;
	  else
	orig_nd1 = orig_cp9map->pos2nd[k+submap->spos-1];
	  orig_nd2 = orig_cp9map->pos2nd[k+submap->spos-1+1];

	  orig_special_matps = FALSE;
	  if((orig_cm->ndtype[orig_nd1] == MATP_nd &&
	  orig_cm->ndtype[orig_nd2] == MATP_nd) &&
	 (orig_cp9map->nd2rpos[orig_nd1] == (k+submap->spos-1) &&
	  orig_cp9map->nd2lpos[orig_nd2]  == (k+submap->spos)))
	{
	  if((orig_cp9map->nd2lpos[orig_nd1] < submap->spos) ||
	     (orig_cp9map->nd2rpos[orig_nd2] > submap->epos))
	    {
	      /* This is a special case */
	      orig_special_matps = TRUE;
	    }
	}

	  if(orig_nd2 < orig_nd1)
	{
	  temp = orig_nd1;
	  orig_nd1 = orig_nd2;
	  orig_nd2 = temp;
	}
	  orig_starts = 0;

	  if(print_flag) printf("orig_nd1: %d | orig_nd2: %d\n", orig_nd1, orig_nd2);
	  for(nd = orig_nd1; nd <= orig_nd2; nd++)
	{
	  if(print_flag) printf("orig_cm->ndtype[%d]: %s L: %4d R: %4d (submap->spos: %4d) (submap->epos: %4d)\n", nd, nodetypes[(int) orig_cm->ndtype[nd]], orig_emap->lpos[nd], orig_emap->rpos[nd], submap->spos, submap->epos);
	  if(orig_cm->ndtype[nd] == BEGL_nd ||
	     orig_cm->ndtype[nd] == BEGR_nd)
	    { orig_starts++; }
	}
	  sub_nd1 = sub_cp9map->pos2nd[k];
	  sub_nd2 = sub_cp9map->pos2nd[k+1];

	  sub_special_matl = FALSE;
	  if(sub_cm->ndtype[sub_nd1] == MATL_nd)
	sub_special_matl = TRUE;

	  if(sub_nd2 < sub_nd1)
	{
	  temp = sub_nd1;
	  sub_nd1 = sub_nd2;
	  sub_nd2 = temp;
	}

	  sub_both_matps = FALSE;
	  if((sub_cm->ndtype[sub_nd1] == MATP_nd && sub_cm->ndtype[sub_nd2] == MATP_nd) &&
	 (!(sub_cp9map->nd2lpos[sub_nd1] < sub_cp9map->nd2lpos[sub_nd2] && sub_cp9map->nd2rpos[sub_nd1] > sub_cp9map->nd2rpos[sub_nd2])))
	sub_both_matps = TRUE;

	  sub_starts = 0;
	  if(print_flag) printf("sub_nd1: %d | sub_nd2: %d\n", sub_nd1, sub_nd2);
	  for(nd = sub_nd1; nd <= sub_nd2; nd++)
	{
	  if(print_flag) printf("sub_cm->ndtype[%d]: %s L: %4d R: %4d (submap->spos: %4d) (submap->epos: %4d)\n", nd, nodetypes[(int) sub_cm->ndtype[nd]], (sub_emap->lpos[nd]+submap->spos-1), (sub_emap->rpos[nd]+submap->spos-1), submap->spos, submap->epos);
	  if(sub_cm->ndtype[nd] == BEGL_nd || sub_cm->ndtype[nd] == BEGR_nd)
	    {
	      sub_starts++;
	      if(sub_cm->ndtype[sub_nd1] != MATP_nd && sub_cm->ndtype[sub_nd2] != MATP_nd)
		cm_Fail("ERROR in cm2sub_cm_find_impossible_misc_cases() found impossible case not involving any MATP in the sub_cm, k: %d submap->epos-submap->spos+1: %d\n", k, submap->sub_clen);
	      if(orig_cm->ndtype[orig_nd1] != MATP_nd && orig_cm->ndtype[orig_nd2] != MATP_nd)
		cm_Fail("ERROR in cm2sub_cm_find_impossible_misc_cases() found impossible case not involving any MATP in the orig_cm\n, k: %d | submap->epos-submap->spos+1: %d", k, submap->sub_clen);
	    }
	}

	  if(print_flag) printf("sub_starts: %d | orig_starts: %d\n", sub_starts, orig_starts);

	  if(sub_starts > 0 && orig_starts == 0)
	subinfo->imp_cc[k] = 3;
	  else if((sub_starts > 0 && sub_starts > orig_starts) &&
	      sub_both_matps == TRUE)
	subinfo->imp_cc[k] = 4;
	  else if(sub_starts > 0 && orig_special_matps && sub_special_matl)
	subinfo->imp_cc[k] = 5;
	  else if(sub_starts == 0 && orig_starts > 0 && orig_special_matps && sub_special_matl)
	subinfo->imp_cc[k] = 6;

	}
  FreeEmitMap(orig_emap);
  FreeEmitMap(sub_emap);
  free(nodetypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 10.18.06
 * cm2sub_cm_find_impossible_matr_cases
 *
 * For certain situations, the conversion of an orig_cm to a sub_cm loses
 * some information that makes it impossible for a CP9 trained from the sub_cm
 * to exactly match a CP9 trained from the orig_cm for the corresponding
 * columns. One case where it is impossible involves MATR nodes as follows:
 *
 * if for any k k=spos..epos-1:
 * orig_cp9map->pos2nd[k] + 1  = orig_cp9map->pos2nd[k+1] AND  (NOT TRUE!)
 * sub_cp9map->pos2nd[k] + 1 != sub_cp9map->pos2nd[k+1] AND
 * orig_cp9map->pos2nd[k]     == sub_cp9map->pos2nd[k]   == MATL AND
 * orig_cp9map->pos2nd[k+1]   == sub_cp9map->pos2nd[k+1] == MATP AND
 * all nodes between sub_cp9map->pos2nd[k] .. cc_node_map[k+1] are BIF, BEG*, or MATR nodes AND
 * the orig_cm nodes that the stretch of MATR nodes map to are all MATP nodes
 *     for which the other half of the nodes map to positions outside the sub_cm.
 *
 * Here we explicitly check for these situations and set imp_cc[k] = TRUE for
 * any k that satisfy all the criteria.
 * Returns: void
 *
 * Args:
 * CM_t  orig_cm
 * CM_t  sub_cm
 * int *orig_cp9map->pos2nd
 * int *sub_cp9map->pos2nd
 * int *imp_cc
 * int spos;
 * int epos;
 */

static void
cm2sub_cm_find_impossible_matr_cases(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CMSubInfo_t *subinfo,
				     CP9Map_t *orig_cp9map, CP9Map_t *sub_cp9map, int print_flag)
{
  int status;
  int sub_k;
  int orig_k;
  int orig_nd;
  int sub_nd;
  int next_sub_nd;
  int next_orig_nd;
  int sub_nd1;
  int sub_nd2;
  int orig_nd1;
  int orig_nd2;
  int tmp_k;
  int tmp_sub_nd;
  int tmp_orig_nd;
  int correct_node_types_flag;
  int orig_matr_stretch_flag;
  int sub_matr_stretch_flag;

  char **nodetypes;
  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  for(sub_k = 1; sub_k < submap->sub_clen; sub_k++)
	{
	  orig_k = sub_k + submap->spos - 1;
	  if(print_flag) printf("CASE 2 k: %d\n", sub_k);
	  /* Strategy: we check each of our criteria independently */

	  /* Find out what the node that models the next column is */
	  sub_nd = sub_cp9map->pos2nd[sub_k];
	  next_sub_nd = sub_cp9map->pos2nd[sub_k+1];
	  orig_nd = orig_cp9map->pos2nd[orig_k];
	  next_orig_nd = orig_cp9map->pos2nd[orig_k+1];
	  if(sub_nd < next_sub_nd)
	{
	  sub_nd1 = sub_nd;
	  sub_nd2 = next_sub_nd;
	}
	  else
	{
	  sub_nd1 = next_sub_nd;
	  sub_nd2 = sub_nd;
	}
	  if(orig_nd < next_orig_nd)
	{
	  orig_nd1 = orig_nd;
	  orig_nd2 = next_orig_nd;
	}
	  else
	{
	  orig_nd1 = next_orig_nd;
	  orig_nd2 = orig_nd;
	}

	  if(print_flag) printf("CASE 2 k: %d  sub_nd: %d  next_sub_nd: %d\n", sub_k, sub_nd, next_sub_nd);
	  if(print_flag) printf("CASE 2 k: %d orig_nd: %d next_orig_nd: %d\n", sub_k, orig_nd, next_orig_nd);

	  /* Make sure that next_sub_nd is and sub_nd are not consecutive */
	  if(sub_nd1 != sub_nd2-1)
	{
	  /* Check if min(sub_nd, next_sub_nd) and min(orig_nd, next_orig_nd) are both MATLs and
	     if max(sub_nd, next_sub_nd) and max(orig_nd, next_orig_nd) are both MATPs */
	  if((orig_cm->ndtype[orig_nd1] == MATL_nd && sub_cm->ndtype[sub_nd1] == MATL_nd) &&
	     (orig_cm->ndtype[orig_nd2] == MATP_nd && sub_cm->ndtype[sub_nd2] == MATP_nd))
	    correct_node_types_flag = TRUE;
	  else
	    correct_node_types_flag = FALSE;
	  if(print_flag) printf("CASE 2 k: %d correct_node_types_flag: %d\n", sub_k, correct_node_types_flag);

	  if(correct_node_types_flag == TRUE)
	    {
	      /* Determine if the next_orig_nd is the next left emitting
	       * node of the orig_cm after orig_nd */
	      orig_matr_stretch_flag = TRUE;
	      for(tmp_orig_nd = orig_nd1+1; tmp_orig_nd < orig_nd2; tmp_orig_nd++)
		{
		  if(orig_cm->ndtype[tmp_orig_nd] != MATR_nd)
		    {
		      orig_matr_stretch_flag = FALSE;
		      break;
		    }
		}
	      if(print_flag) printf("CASE 2 k: %d orig_matr_stretch_flag: %d\n", sub_k, orig_matr_stretch_flag);
	      if(orig_matr_stretch_flag == TRUE)
		{
		  /* Check if all the sub_cm nodes between sub_nd and
		   * next_sub_nd are MATRs. */
		  sub_matr_stretch_flag = TRUE;
		  for(tmp_sub_nd = sub_nd1+1; tmp_sub_nd < sub_nd2; tmp_sub_nd++)
		    if(sub_cm->ndtype[tmp_sub_nd] != MATR_nd)
		      {
			sub_matr_stretch_flag = FALSE;
			break;
		      }
		  if(print_flag) printf("CASE 2 k: %d sub_matr_stretch_flag: %d\n", sub_k, sub_matr_stretch_flag);
		  if(sub_matr_stretch_flag == TRUE)
		    {
		      /* This should be a MATR impossible case,
		       * Check all the criteria we *think* are always true in this situation,
		       * cm_Fail if what we think is wrong.
		       *
		       * The orig_cm nodes that map to the same consensus columns
		       * as the MATR nodes in the sub_cm must either be:

		       * as the MATR nodes in the sub_cm must either be:
		       *
		       * 1 orig_cm MATPs or MATRs for which the RIGHT half maps to the same column
		       *   modelled by the corresponding sub_cm MATR, and in the case of the
		       *   MATPs the LEFT half maps to consensus columns before spos.
		       * 2 orig_cm nodes that map to the same consensus columns
		       *   as the MATR nodes in the sub_cm are ALL either orig_cm MATPs
		       *   or MATLs for which the LEFT half maps to the same
		       *   column modelled by the corresponding sub_cm MATR, and in the
		       *   case of the MATPs, the RIGHT half maps to consensus columns
		       *   after epos.
		       *
		       * Usually the entire set of orig_cm nodes that map to the sub_cm
		       * MATRs are either one or the other type, but I've seen rare cases
		       * where there's a stretch of one type, and then a stretch of the
		       * other.
		       */
		      tmp_sub_nd = sub_cp9map->pos2nd[sub_k] + 1;
		      tmp_k       = sub_cp9map->nd2rpos[tmp_sub_nd] + submap->spos - 1;
		      tmp_orig_nd = orig_cp9map->pos2nd[tmp_k];

		      for(tmp_sub_nd = sub_nd1+1; tmp_sub_nd < sub_nd2; tmp_sub_nd++)
			{
			  tmp_k       = sub_cp9map->nd2rpos[tmp_sub_nd] + submap->spos - 1;
			  tmp_orig_nd = orig_cp9map->pos2nd[tmp_k];

			  if(print_flag) printf("10.18.06: %s %3d %3d | %s %3d %3d (xcc: %3d)\n", nodetypes[(int) sub_cm->ndtype[tmp_sub_nd]], tmp_sub_nd, (sub_cp9map->nd2rpos[tmp_sub_nd]+submap->spos-1), nodetypes[(int) orig_cm->ndtype[tmp_orig_nd]], orig_cp9map->nd2lpos[tmp_orig_nd], orig_cp9map->nd2rpos[tmp_orig_nd], tmp_k);
			  if(orig_cp9map->nd2rpos[tmp_orig_nd] == (sub_cp9map->nd2rpos[tmp_sub_nd]+submap->spos-1)) /* Case 1 above */
			    {
			      if(orig_cm->ndtype[tmp_orig_nd] != MATP_nd && orig_cm->ndtype[tmp_orig_nd] != MATR_nd)
				cm_Fail("ERROR 2 in cm2sub_cm_find_impossible_matr_cases() found impossible MATR case that can't be classified as case 1 or case 2, k: %d | submap->spos: %d submap->epos: %d", sub_k, submap->spos, submap->epos);
			      if(orig_cm->ndtype[tmp_orig_nd] == MATP_nd && orig_cp9map->nd2lpos[tmp_orig_nd] >= submap->spos)
				cm_Fail("ERROR 3 in cm2sub_cm_find_impossible_matr_cases() found impossible MATR case that can't be classified as case 1 or case 2, k: %d | submap->spos: %d submap->epos: %d", sub_k, submap->spos, submap->epos);
			    }
			  else if(orig_cp9map->nd2lpos[tmp_orig_nd] == (sub_cp9map->nd2rpos[tmp_sub_nd]+submap->spos-1)) /* Case 2 above */
			    {
			      if(orig_cm->ndtype[tmp_orig_nd] != MATP_nd && orig_cm->ndtype[tmp_orig_nd] != MATL_nd)
				cm_Fail("ERROR 4 in cm2sub_cm_find_impossible_matr_cases() found impossible MATR case that can't be classified as case 1 or case 2, k: %d | submap->spos: %d submap->epos: %d", sub_k, submap->spos, submap->epos);
			      if(orig_cm->ndtype[tmp_orig_nd] == MATP_nd && orig_cp9map->nd2rpos[tmp_orig_nd] <= submap->epos)
				cm_Fail("ERROR 5 in cm2sub_cm_find_impossible_matr_cases() found impossible MATR case that can't be classified as case 1 or case 2, k: %d | submap->spos: %d submap->epos: %d | orig_cp9map->nd2rpos[%d]: %d", sub_k, submap->spos, submap->epos, tmp_orig_nd, orig_cp9map->nd2rpos[tmp_orig_nd]);
			    }
			}
		      /* if we get here, we've satisfied all of our criteria */
		      subinfo->imp_cc[sub_k] = 2;
		    }
		}
	    }
	}
	}
  free(nodetypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 10.16.06
 * Function: check_sub_cm()
 *
 * Purpose:  Given a CM and a sub CM that is supposed to mirror
 *           the CM as closely as possible between two given consensus
 *           columns (spos and epos), check that the sub_cm was correctly
 *           constructed.
 *
 *	     1. Build a CP9 HMM (cp9_1) from the sub_cm.
 *	     2. Build a CP9 HMM (cp9_2) from the full cm.
 *	     3. Reconfig cp9_2 so start node is spos and end node is epos.
 *	     4. Check corresponding parameters of cp9_1 and cp9_2 to make
 *	        sure they're within pthresh, allowing nodes we predict
 *              to be wrong, as stored in subinfo->imp_cc[] to be wrong,
 *              but keeping statistics on these cases.
 *
 * Args:
 * orig_cm     - the original, template CM
 * sub_cm      - the sub CM built from the orig_cm
 * errbuf      - for error messages
 * submap      - map from orig_cm to sub_cm and vice versa
 * subinfo     - sub cm information
 * pthresh     - the allowed difference in probability between HMMs
 * print_flag  - TRUE to print useful debugging info
 *
 * Returns: eslOK   if CM and sub CM are "close enough" (see code)
 *          eslFAIL otherwise, errbuf is filled
 */
int
check_sub_cm(CM_t *orig_cm, CM_t *sub_cm, char *errbuf, CMSubMap_t *submap, CMSubInfo_t *subinfo, float pthresh, int print_flag)
{
  int          status;
  CP9_t       *sub_hmm;  /* constructed CP9 HMM from the sub_cm */
  CP9_t       *orig_hmm; /* constructed CP9 HMM from the original cm
			   this will be reconfiged to match the sub_hmm */
  CP9Map_t *orig_cp9map; /* maps the orig_cm to the orig_hmm and vice versa */
  CP9Map_t *sub_cp9map;  /* maps the sub_cm to the sub_hmm and vice versa */

  int k;
  double **orig_phi;
  int *violation;
  int v_ct;
  int apredict_total_ct;
  int awrong_total_ct;
  int i;
  float diff;
  int nd;

  v_ct = 0;
  apredict_total_ct = 0;
  awrong_total_ct = 0;

  /* Build two CP9 HMMs, one for the orig_cm and one for the sub_cm */
  if((status = build_cp9_hmm(orig_cm, errbuf, FALSE, 0.0001, print_flag, &orig_hmm, &orig_cp9map)) != eslOK) return status;
  if((status = build_cp9_hmm(sub_cm,  errbuf, FALSE, 0.0001, print_flag, &sub_hmm,  &sub_cp9map)) != eslOK) return status;
  CP9Logoddsify(orig_hmm);
  CP9Logoddsify(sub_hmm);

  /* Look for 'impossible' cases where we know the sub_cm
   * construction procedure fails, in that the distribution of transitions out of CP9 nodes
   * built from the sub_cm will be the same distros out of corresponding CP9 nodes built from
   * the full CM. */
  cm2sub_cm_find_impossible_misc_cases(orig_cm, sub_cm, submap, subinfo, orig_cp9map, sub_cp9map, print_flag);
  cm2sub_cm_find_impossible_matr_cases(orig_cm, sub_cm, submap, subinfo, orig_cp9map, sub_cp9map, print_flag);

  /* Reconfig the orig_hmm so that it can only start in the spos node, and end from the epos node */
  /* Build the sub CP9 HMM by copying as much of the original cp9_hmm as possible */
  fill_phi_cp9(orig_hmm, &orig_phi, 1, FALSE);
  CP9_reconfig2sub(orig_hmm, submap->spos, submap->epos, submap->spos, submap->epos, orig_phi);

  if(print_flag)
	{
	  printf("PRINTING BUILT SUB HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, sub_hmm, TRUE);
	  printf("DONE PRINTING BUILT SUB HMM PARAMS:\n");

	  printf("PRINTING BUILT & RECONFIGED ORIG HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, orig_hmm, TRUE);
	  printf("DONE PRINTING BUILT & RECONFIGED ORIG HMM PARAMS:\n");
	}

  /* Check the parameters of the two CP9 HMMs */
  if(print_flag)
	{
	  printf("COMPARING CP9 HMM parameters in check_sub_cm()\n");
	  printf("orig | sub\n");
	}
  ESL_ALLOC(violation, sizeof(int) * (submap->sub_clen+1));
  for(k = 0; k <= sub_hmm->M; k++)
	{
	  violation[k] = FALSE;
	  if(print_flag) printf("Node: %d\n", k);
	  if(k > 0)
	{
	  for(i = 0; i < orig_cm->abc->K; i++)
	    {
	      diff = orig_hmm->mat[(submap->spos+k-1)][i] - sub_hmm->mat[k][i];
	      if(print_flag) printf("mat[%d][%d] = %8.5f | %8.5f | (%8.5f)\n", 0, i, orig_hmm->mat[(submap->spos+k-1)][i], sub_hmm->mat[k][i], diff);
	      if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
		{
		  ESL_FAIL(eslFAIL, errbuf, "check_sub_cm(): emission probability incorrect");
		}
	    }
	}
	  for(i = 0; i < orig_cm->abc->K; i++)
	{
	  diff = orig_hmm->ins[(submap->spos+k-1)][i] - sub_hmm->ins[k][i];
	  if(print_flag) printf("ins[%d][%d] = %8.5f | %8.5f | (%8.5f)\n", 0, i, orig_hmm->ins[(submap->spos+k-1)][i], sub_hmm->ins[k][i], diff);
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	    {
	      ESL_FAIL(eslFAIL, errbuf, "check_sub_cm(): emission probability incorrect");
	    }
	}

	  /* Transitions */
	  if(print_flag) printf("\n");
	  diff = orig_hmm->t[(submap->spos+k-1)][CTMM] - sub_hmm->t[k][CTMM];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTMM[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTMM], sub_hmm->t[k][CTMM], diff);
	}
	  else
	if(print_flag) printf("\tCTMM[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTMM], sub_hmm->t[k][CTMM], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTMI] - sub_hmm->t[k][CTMI];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTMI[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTMI], sub_hmm->t[k][CTMI], diff);
	}
	  else
	if(print_flag) printf("\tCTMI[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTMI], sub_hmm->t[k][CTMI], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTMD] - sub_hmm->t[k][CTMD];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTMD[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTMD], sub_hmm->t[k][CTMD], diff);
	}
	  else
	if(print_flag) printf("\tCTMD[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTMD], sub_hmm->t[k][CTMD], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTIM] - sub_hmm->t[k][CTIM];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTIM[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTIM], sub_hmm->t[k][CTIM], diff);
	}
	  else
	if(print_flag) printf("\tCTIM[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTIM], sub_hmm->t[k][CTIM], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTII] - sub_hmm->t[k][CTII];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTII[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTII], sub_hmm->t[k][CTII], diff);
	}
	  else
	if(print_flag) printf("\tCTII[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTII], sub_hmm->t[k][CTII], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTID] - sub_hmm->t[k][CTID];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTID[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTID], sub_hmm->t[k][CTID], diff);
	}
	  else
	if(print_flag) printf("\tCTID[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTID], sub_hmm->t[k][CTID], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTDM] - sub_hmm->t[k][CTDM];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTDM[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTDM], sub_hmm->t[k][CTDM], diff);
	}
	  else
	if(print_flag) printf("\tCTDM[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTDM], sub_hmm->t[k][CTDM], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTDI] - sub_hmm->t[k][CTDI];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTDI[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTDI], sub_hmm->t[k][CTDI], diff);
	}
	  else
	if(print_flag) printf("\tCTDI[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTDI], sub_hmm->t[k][CTDI], diff);

	  diff = orig_hmm->t[(submap->spos+k-1)][CTDD] - sub_hmm->t[k][CTDD];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	{
	  violation[k] = TRUE;
	  if(print_flag) printf("\tCTDD[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->t[(submap->spos+k-1)][CTDD], sub_hmm->t[k][CTDD], diff);
	}
	  else
	if(print_flag) printf("\tCTDD[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->t[(submap->spos+k-1)][CTDD], sub_hmm->t[k][CTDD], diff);

	  if(k > 0)
	{
	  diff = orig_hmm->begin[(submap->spos+k-1)] - sub_hmm->begin[k];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	    {
	      violation[0] = TRUE; /* begin actually has to do with the transition distro out of node 0 */
	      if(print_flag) printf("\t beg[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->begin[(submap->spos+k-1)], sub_hmm->begin[k], diff);
	    }
	  else
	    if(print_flag) printf("\t beg[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->begin[(submap->spos+k-1)], sub_hmm->begin[k], diff);

	  diff = orig_hmm->end[(submap->spos+k-1)] - sub_hmm->end[k];
	  if((diff > 0 && diff > pthresh) || (diff < 0 && diff < (-1. * pthresh)))
	    {
	      violation[k] = TRUE;
	      if(print_flag) printf("\t end[%d] = %8.5f | %8.5f | %8.5f VIOLATION\n", k, orig_hmm->end[(submap->spos+k-1)], sub_hmm->end[k], diff);
	    }
	  else
	    if(print_flag) printf("\t end[%d] = %8.5f | %8.5f | %8.5f\n", k, orig_hmm->end[(submap->spos+k-1)], sub_hmm->end[k], diff);
	}
	}

  /* Add-up the violations */
  for(nd = 0; nd <= (submap->epos-submap->spos+1); nd++)
	{
	  if(violation[nd] && subinfo->imp_cc[nd] == 0)
	{
	  v_ct++;
	  printf("VIOLATION[%3d]: TRUE | submap->spos: %3d | submap->epos: %3d | subinfo->imp_cc: %d\n", nd, submap->spos, submap->epos, subinfo->imp_cc[nd]);
	}
	  else if(violation[nd] && subinfo->imp_cc[nd] != 0)
	{
	  subinfo->apredict_ct[subinfo->imp_cc[nd]]++;
	  apredict_total_ct++;
	  if(print_flag)
	    printf("PREDICTED VIOLATION[%3d]: TRUE | submap->spos: %3d | submap->epos: %3d | subinfo->imp_cc: %d\n", nd, submap->spos, submap->epos, subinfo->imp_cc[nd]);
	}
	  else if(!violation[nd] && subinfo->imp_cc[nd] != 0)
	{
	  subinfo->apredict_ct[subinfo->imp_cc[nd]]++;
	  apredict_total_ct++;
	  subinfo->awrong_ct[subinfo->imp_cc[nd]]++;
	  awrong_total_ct++;
	  if(print_flag) printf("NON-VIOLATION[%3d] %3d : submap->spos: %3d | submap->epos: %3d | subinfo->imp_cc: %d\n", nd, awrong_total_ct, submap->spos, submap->epos, subinfo->imp_cc[nd]);
	}
	}

  /* Clean up and return */
  for(k = 0; k <= orig_hmm->M; k++)
	free(orig_phi[k]);
  free(orig_phi);

  free(violation);
  FreeCPlan9(orig_hmm);
  FreeCPlan9(sub_hmm);
  FreeCP9Map(orig_cp9map);
  FreeCP9Map(sub_cp9map);

  if(v_ct > 0) ESL_FAIL(eslFAIL, errbuf, "check_sub_cm(): check failed");
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "memory allocation error");
  return FALSE; /* never reached */
}

/**************************************************************************
 * EPN 10.23.06
 * Function: sub_cm2cm_parsetree()
 * Returns: void
 *
 * Purpose: Convert a parstree to a sub_cm to a parsetree for an original CM.
 *          We assume we're NOT in local mode. For any node n in the original
 *          CM for which 0 states in the sub_cm map to n, we declare that
 *          the delete state of that node was used in the converted original
 *          CM parse (or the S, B or E state if n is not MATP, MATL or MATR).
 *
 * Args:
 * CM_t *orig_cm             - the original, template CM
 * CM_t  *sub_cm             - the sub CM built from the orig_cm
 * Parsetree_t **ret_orig_tr - orig_cm parstree allocated, filled and returned here
 * Parsetree_t *sub_tr       - the sub_cm parstree already filled
 * CMSubMap_t *submap        - map from the sub_cm to orig_cm and vice versa
 * int print_flag    - TRUE to print useful debugging info
 *
 * Returns: eslOK on success
 *          eslEMEM if we run out of memory
 */

int
sub_cm2cm_parsetree(CM_t *orig_cm, CM_t *sub_cm, Parsetree_t **ret_orig_tr, Parsetree_t *sub_tr,
		    CMSubMap_t *submap, int print_flag)
{
  int  status;
  Parsetree_t *orig_tr; /* the parsetree we're creating for the original CM */
  int *ss_used;     /* [0..orig_cm->nodes-1], split state idx used in converted parsetree for each orig_cm nd */
  int *ss_emitl;    /* [0..orig_cm->nodes-1], tr->emitl[n] for each orig_cm node n */
  int *ss_emitr;    /* [0..orig_cm->nodes-1], tr->emitr[n] for each orig_cm node n */
  int *il_ct;       /* [0..orig_cm->nodes-1], number of times IL state of orig_cm node n was visited */
  int *ir_ct;       /* [0..orig_cm->nodes-1], number of times IR state of orig_cm node n was visited */
  int *il_used;     /* [0..orig_cm->nodes-1], idx of IL state in node n */
  int *ir_used;     /* [0..orig_cm->nodes-1], idx of IR state in node n */
  int *tr_nd_for_bifs; /* [0..orig_cm->nodes-1], if n is a BIF node, tr node of this BIF node, else -1 */
  int x;
  int nd;
  int sub_v;
  int orig_v1;
  int orig_v2;
  int orig_nd1;
  int orig_nd2;
  int cm_nd;
  int i;
  int parent_tr_nd;
  ESL_STACK   *pda;
  int          pos;
  int          ss;
  int          on_right;
  int emitl_flag;
  int emitr_flag;

  char **nodetypes;
  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  char **sttypes;
  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  if(print_flag) printf("orig_cm nodes: %d\n", orig_cm->nodes);

  ESL_ALLOC(ss_used,       sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(ss_emitl,      sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(ss_emitr,      sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(il_used,       sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(ir_used,       sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(il_ct,         sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(ir_ct,         sizeof(int) * orig_cm->nodes + 1);
  ESL_ALLOC(tr_nd_for_bifs,sizeof(int) * orig_cm->nodes + 1);
  /* i*_emitl[nd] is the last residue emitted by the i* state
   * of node nd, the first is (il_emitl[nd] - il_ct[nd] + 1)
   * or (ir_emitr[nd] + ir_ct[nd] - 1)
   */

  for(nd = 0; nd < orig_cm->nodes; nd++)
	{
	  ss_used[nd]   = -1;
	  ss_emitl[nd]  = -1;
	  ss_emitr[nd]  = -1;
	  il_ct[nd]     =  0; /* the number of times the IL state was used in the sub_cm parse */
	  ir_ct[nd]     =  0; /* the number of times the IR state was used in the sub_cm parse */
	  il_used[nd]   = -1;
	  ir_used[nd]   = -1;
	  tr_nd_for_bifs[nd] = -1; /* this will remain -1 except for bif nodes */
	}

  for(x = 0; x < sub_tr->n; x++)
	{
	  sub_v    = sub_tr->state[x];
	  if(print_flag) printf("x: %d sub_v: %d\n", x, sub_v);
	  orig_v1  = submap->s2o_smap[sub_v][0];
	  orig_v2  = submap->s2o_smap[sub_v][1];
	  if(print_flag) printf("orig_v1: %d | orig_v2: %d\n", orig_v1, orig_v2);
	  if(orig_v1 == -1)
	{
	  if(sub_cm->sttype[sub_v] != S_st &&
	     sub_cm->sttype[sub_v] != E_st &&
	     sub_cm->sttype[sub_v] != B_st &&
	     sub_cm->sttype[sub_v] != EL_st)
	    cm_Fail("ERROR 0 in sub_cm2cm_parstree()\n");
	  continue;
	}
	  orig_nd1 = orig_cm->ndidx[orig_v1];
	  if(orig_v2 != -1)
	orig_nd2 = orig_cm->ndidx[orig_v2];
	  else
	orig_nd2 = -1;

	  /* No sub_cm insert states can map to 2 orig_cm inserts */
	  if(orig_cm->sttype[orig_v1] == IL_st)
	{
	  il_used[orig_nd1] = orig_v1;
	  il_ct[orig_nd1]++;
	  if(orig_v2 != -1)
	    cm_Fail("ERROR 1 in sub_cm2cm_parstree()\n");
	}
	  else if(orig_cm->sttype[orig_v1] == IR_st)
	{
	  ir_used[orig_nd1] = orig_v1;
	  ir_ct[orig_nd1]++;
	  if(orig_v2 != -1)
	    cm_Fail("ERROR 2 in sub_cm2cm_parstree()\n");
	}
	  else if(sub_cm->ndtype[sub_cm->ndidx[sub_v]] == MATP_nd)
	{
	  ss_used[orig_nd1] = orig_v1;
	  if(orig_v2 != -1)
	    cm_Fail("ERROR 3 in sub_cm2cm_parsetree()\n");
	}
	  else if(orig_cm->ndtype[orig_nd1] == MATP_nd)
	{
	  if(orig_v2 == -1)
	    cm_Fail("ERROR 4 in sub_cm2cm_parsetree()\n");
	  /* We have to figure out which MATP split state sub_v corresponds to. */
	  if(sub_cm->ndtype[sub_cm->ndidx[sub_v]] != MATL_nd &&
	     sub_cm->ndtype[sub_cm->ndidx[sub_v]] != MATR_nd)
	    cm_Fail("ERROR 5 in sub_cm2cm_parsetree()\n");
	  if(orig_cm->ndtype[orig_nd2] != MATP_nd)
	    cm_Fail("ERROR 6 in sub_cm2cm_parsetree()\n");

	  if(sub_cm->sttype[sub_v] == D_st)
	    {
	      if(ss_used[orig_nd1] == -1 ||
		 orig_cm->sttype[ss_used[orig_nd1]] == D_st)
		ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1] + 3; /* MATP_D */

	      /* Else we do nothing, orig_cm->sttype[ss_used[orig_nd1]] is already
	       * either a ML_st or an MR_st */
	    }
	  else /* sub_cm->sttype[sub_v] != D_st */
	    {
	      if(ss_used[orig_nd1] == -1 ||
		 orig_cm->sttype[ss_used[orig_nd1]] == D_st)
		{
		  /* Figure out if sub_v maps to the left or right half of the MATP node */
		  if(orig_cm->sttype[orig_v1] == ML_st ||
		     orig_cm->sttype[orig_v2] == ML_st)
		    ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1] + 1; /* MATP_ML */
		  else if(orig_cm->sttype[orig_v1] == MR_st ||
			  orig_cm->sttype[orig_v2] == MR_st)
		    ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1] + 2; /* MATP_MR */
		  else
		    cm_Fail("ERROR 7 in sub_cm2cm_parsetree()\n");
		}
	      /* below is the only line we really need:
		 else
		 ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1]; */

	      else if(orig_cm->sttype[ss_used[orig_nd1]] == ML_st) /* just for safety; should erase eventually */
		{
		  if(orig_cm->sttype[orig_v1] == MR_st ||
		     orig_cm->sttype[orig_v2] == MR_st) /* just for safety; should erase eventually */
		    {
		      ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1]; /* MATP_MP */
		    }
		  else
		    cm_Fail("ERROR 8 in sub_cm2cm_parsetree()\n");
		}
	      else if(orig_cm->sttype[ss_used[orig_nd1]] == MR_st) /* just for safety; should erase eventually */
		{
		  if(orig_cm->sttype[orig_v1] == ML_st ||
		     orig_cm->sttype[orig_v2] == ML_st) /* just for safety; should erase eventually */
		    {
		      ss_used[orig_nd1] = orig_cm->nodemap[orig_nd1]; /* MATP_MP */
		    }
		  else
		    cm_Fail("ERROR 9 in sub_cm2cm_parsetree()\n");
		}
	    }
	}
	  else
	{
	  if(orig_v2 != -1)
	    cm_Fail("ERROR 5 in sub_cm2cm_parsetree()\n");
	  ss_used[orig_nd1] = orig_v1;
	}
	}

  /* Some MATL, MATR, and MATP nodes in the orig_cm might have 0 states that map to any state
   * used in the sub_cm parse. If we're not allowing local begins and ends, our strategy is
   * to claim that in the orig_cm parse the D state of these nodes was used.
   */
  for(nd = 0; nd < orig_cm->nodes; nd++)
	{
	  if(ss_used[nd] == -1)
	{
	  if(orig_cm->ndtype[nd] == MATP_nd)
	    ss_used[nd] = orig_cm->nodemap[nd] + 3; /* MATP_D */
	  if(orig_cm->ndtype[nd] == MATL_nd ||
	     orig_cm->ndtype[nd] == MATR_nd)
	    ss_used[nd] = orig_cm->nodemap[nd] + 1; /* MAT{L,R}_D */
	  if(orig_cm->ndtype[nd] == BIF_nd  ||
	     orig_cm->ndtype[nd] == BEGL_nd ||
	     orig_cm->ndtype[nd] == BEGR_nd ||
	     orig_cm->ndtype[nd] == END_nd)
	    ss_used[nd] = orig_cm->nodemap[nd];     /* BIF_B, END_E or BEG{L,R}_S */
	}
	}

  /* Determine emitl and emitr for each state in the orig_cm parse */
  /* This code is noticeably cleaner than the rest - it's Sean's, from
   * CreateEmitMap() adapted for our purposes here.
   */

  pos   = 1;
  ss    = 0;
  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;		/* 0 = left side. 1 would = right side. */
  if((status = esl_stack_IPush(pda, ss)) != eslOK) goto ERROR;
  while (esl_stack_IPop(pda, &ss) != eslEOD)
	{
	  esl_stack_IPop(pda, &on_right);

	  if (on_right)
	{
	  pos += ir_ct[orig_cm->ndidx[ss]]; /* account for right inserts */
	  if (orig_cm->sttype[ss] == MP_st || orig_cm->sttype[ss] == MR_st)
	    pos++;
	  ss_emitr[orig_cm->ndidx[ss]] = pos - 1;
	}
	  else
	{
	  ss_emitl[orig_cm->ndidx[ss]] = pos;
	  if (orig_cm->sttype[ss] == MP_st || orig_cm->sttype[ss] == ML_st)
	    pos++;

	  if (orig_cm->sttype[ss] == B_st)
	    {
	      /* push the BIF back on for its right side  */
	      if((status = esl_stack_IPush(pda, 1)) != eslOK) goto ERROR;
	      if((status = esl_stack_IPush(pda, ss)) != eslOK) goto ERROR;
	      /* push node index for right child */
	      if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
	      if((status = esl_stack_IPush(pda, orig_cm->cnum[ss])) != eslOK) goto ERROR;
	      /* push node index for left child */
	      if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
	      if((status = esl_stack_IPush(pda, orig_cm->cfirst[ss])) != eslOK) goto ERROR;
	    }
	  else
	    {
	      /* push the node back on for right side */
	      if((status = esl_stack_IPush(pda, 1)) != eslOK) goto ERROR;
	      if((status = esl_stack_IPush(pda, ss)) != eslOK) goto ERROR;
	      /* push split state of child node on */
	      if (orig_cm->sttype[ss] != E_st) {
		if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
		if((status = esl_stack_IPush(pda, ss_used[orig_cm->ndidx[ss]+1])) != eslOK) goto ERROR;
	      }
	    }
	  pos += il_ct[orig_cm->ndidx[ss]]; /* account for left inserts */
	}
	}

  if(print_flag)
	{
	  for(nd = 0; nd < orig_cm->nodes; nd++)
	{
	  printf("ss_used[%4d] (%4s) first state(%4d) | ", nd, nodetypes[(int) orig_cm->ndtype[nd]], orig_cm->nodemap[nd]);
	  if(ss_used[nd] != -1)
	    printf("%4d (%2s) | L: %3d R: %3d\n", ss_used[nd], sttypes[(int) orig_cm->sttype[ss_used[nd]]], ss_emitl[nd], ss_emitr[nd]);
	  else
	    printf("%4d\n", -1);
	}
	  for(nd = 0; nd < orig_cm->nodes; nd++)
	printf("il_ct[%4d] (st used: %4d) ct: %4d | ir_ct[%4d] ct: %4d (st used: %4d)\n", nd, il_used[nd], il_ct[nd], nd, ir_used[nd], ir_ct[nd]);

	}

  orig_tr = CreateParsetree(100);
  for(cm_nd = 0; cm_nd < orig_cm->nodes; cm_nd++)
	{
	  emitl_flag = 0;
	  emitr_flag = 0;
	  if(orig_cm->sttype[ss_used[cm_nd]] == MP_st ||
	 orig_cm->sttype[ss_used[cm_nd]] == ML_st)
	emitl_flag = 1;
	  if(orig_cm->sttype[ss_used[cm_nd]] == MP_st ||
	 orig_cm->sttype[ss_used[cm_nd]] == MR_st)
	emitr_flag = 1;

	  /* At least 1 state in each node must be visited (if we're not in local mode) */
	  if(orig_cm->ndtype[cm_nd] == BEGR_nd)
	{
	  parent_tr_nd =  tr_nd_for_bifs[orig_cm->ndidx[orig_cm->plast[orig_cm->nodemap[cm_nd]]]];
	  if(print_flag) printf("tr_nd_for_bifs[%d]\n", (orig_cm->ndidx[orig_cm->plast[orig_cm->nodemap[cm_nd]]]));
	  if(print_flag) printf("parent_tr_nd for cm_nd %d: %d\n", cm_nd, parent_tr_nd);
	  InsertTraceNode(orig_tr, parent_tr_nd, TRACE_RIGHT_CHILD, ss_emitl[cm_nd], ss_emitr[cm_nd], ss_used[cm_nd]);
	  orig_tr->nxtr[parent_tr_nd]  = orig_tr->n - 1; /* Go back and fix nxtr for the BIF parent of this BEGR */
	}
	  else
	{
	  InsertTraceNode(orig_tr, orig_tr->n-1, TRACE_LEFT_CHILD, ss_emitl[cm_nd], ss_emitr[cm_nd], ss_used[cm_nd]);
	  if(print_flag) printf("inserted trace node for orig_cm st %4s | emitl: %d | emitr: %d\n", sttypes[(int) orig_cm->sttype[ss_used[cm_nd]]], ss_emitl[cm_nd], ss_emitr[cm_nd]);
	}

	  /* Note: if we've just added a trace node for a BIF state, it's incomplete, in that it
	   * doesn't have the nextr correctly set. We'll go back and set this when we get to the
	   * right child (BEGR) of this BIF */
	  if(orig_cm->ndtype[cm_nd] == BIF_nd)
	{
	  tr_nd_for_bifs[cm_nd] = orig_tr->n - 1;
	  if(print_flag) printf("set tr_nd_for_bifs[%d]: %d\n", cm_nd, orig_tr->n);
	}

	  /* Add left inserts, if any */
	  for(i = 0; i < il_ct[cm_nd]; i++)
	{
	  InsertTraceNode(orig_tr, orig_tr->n-1, TRACE_LEFT_CHILD, (ss_emitl[cm_nd] + emitl_flag + i), (ss_emitr[cm_nd] - emitr_flag), il_used[cm_nd]);
	  if(print_flag) printf("inserted trace node for orig_cm st %4s | emitl: %d | emitr: %d\n", sttypes[(int) orig_cm->sttype[il_used[cm_nd]]], orig_tr->emitl[orig_tr->n-1], orig_tr->emitr[orig_tr->n+1]);
	}
	  /* Add right inserts, if any */
	  for(i = 0; i < ir_ct[cm_nd]; i++)
	{
	  InsertTraceNode(orig_tr, orig_tr->n-1, TRACE_LEFT_CHILD, (ss_emitl[cm_nd] + emitl_flag + il_ct[cm_nd]), (ss_emitr[cm_nd] - emitr_flag - i), ir_used[cm_nd]);
	  if(print_flag) printf("inserted trace node for orig_cm st %4s | emitl: %d | emitr: %d\n", sttypes[(int) orig_cm->sttype[ir_used[cm_nd]]], orig_tr->emitl[orig_tr->n-1], orig_tr->emitr[orig_tr->n+1]);
	}
	  if(print_flag) printf("END nd: %4d\n", cm_nd);
	}
  *ret_orig_tr = orig_tr;

  free(ss_used);
  free(ss_emitl);
  free(ss_emitr);
  free(il_used);
  free(ir_used);
  free(il_ct);
  free(ir_ct);
  free(tr_nd_for_bifs);
  free(nodetypes);
  free(sttypes);
  esl_stack_Destroy(pda);
  return eslOK;

 ERROR:
  return eslEMEM;
}

/* Function: SubCMLogoddsify()
 * Date:     EPN, Wed Aug 20 08:14:18 2008
 *
 * Purpose:  Convert the probabilities in a sub CM built
 *           from <mother_cm> to log-odds. Copy the <mother_cm>
 *           parameters where possible to save time.
 *
 * Returns:  eslOK on success;
 * Throws:   eslEINCOMPAT on contract violation.
 *           eslFAIL if we can't create CMConsensus_t object
 *           at end of the function.
 */
int
SubCMLogoddsify(CM_t *cm, char *errbuf, CM_t *mother_cm, CMSubMap_t *mother_map)
{
  if(!(mother_cm->flags & CMH_BITS)) ESL_FAIL(eslEINCOMPAT, errbuf, "SubCMLogoddsify(), mother_cm's CMH_BITS flag down, it's bit scores are invalid.");

  int v, mv, x, y;

  for (v = 0; v < cm->M; v++) {
	if (mother_map->s2o_id[v] == TRUE) { /* this state maps identically to a mother_cm state, copy parameters */
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st) {
	mv = mother_map->s2o_smap[v][0];
	esl_vec_FCopy(mother_cm->tsc[mv],  cm->cnum[v], cm->tsc[v]);
	esl_vec_ICopy(mother_cm->itsc[mv], cm->cnum[v], cm->itsc[v]);
#if eslDEBUGLEVEL >= 1
	for(x = 0; x < cm->cnum[v]; x++) {
	  if(esl_FCompare(mother_cm->t[mv][x], cm->t[v][x], 1E-5) != eslOK) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "You've got it wrong, mother_cm->t[mv:%d][x:%d] %.3f != cm->t[v:%d][x:%d] %.3f\n", mv, x, mother_cm->t[mv][x], v, x, cm->t[v][x]);
	}
#endif
	  }
	  if (cm->sttype[v] == MP_st) {
	esl_vec_FCopy(mother_cm->esc[mv],  cm->abc->K * cm->abc->K, cm->esc[v]);
	esl_vec_ICopy(mother_cm->iesc[mv], cm->abc->K * cm->abc->K, cm->iesc[v]);
	  }
	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st ||
	  cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	esl_vec_FCopy(mother_cm->esc[mv],  cm->abc->K, cm->esc[v]);
	esl_vec_ICopy(mother_cm->iesc[mv], cm->abc->K, cm->iesc[v]);
	  }
	  cm->beginsc[v]  = mother_cm->beginsc[mv];
	  cm->ibeginsc[v] = mother_cm->ibeginsc[mv];

	  cm->endsc[v]    = mother_cm->endsc[mv];
	  cm->iendsc[v]   = mother_cm->iendsc[mv];
	}
	else { /* this state does not map identically to a mother_cm state, we have to do the work calculate the parameters */
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st) {
	for (x = 0; x < cm->cnum[v]; x++) {
	  cm->tsc[v][x]  = sreLOG2(cm->t[v][x]);
	  cm->itsc[v][x] = Prob2Score(cm->t[v][x], 1.0);
	  /*printf("cm->t[%4d][%2d]: %f itsc->e: %f itsc: %d\n", v, x, cm->t[v][x], Score2Prob(cm->itsc[v][x], 1.0), cm->itsc[v][x]);*/
	}
	  }
	  if (cm->sttype[v] == MP_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  for (y = 0; y < cm->abc->K; y++) {
	    cm->esc[v][x*cm->abc->K+y]  = sreLOG2(cm->e[v][x*cm->abc->K+y] / (cm->null[x]*cm->null[y]));
	    cm->iesc[v][x*cm->abc->K+y] = Prob2Score(cm->e[v][x*cm->abc->K+y], (cm->null[x]*cm->null[y]));
	    /*printf("cm->e[%4d][%2d]: %f iesc->e: %f iesc: %d\n", v, (x*cm->abc->K+y), cm->e[v][(x*cm->abc->K+y)], Score2Prob(cm->iesc[v][x*cm->abc->K+y], (cm->null[x]*cm->null[y])), cm->iesc[v][(x*cm->abc->K+y)]);*/
	  }
	}
	  }
	  if (cm->sttype[v] == ML_st || cm->sttype[v] == MR_st ||
	  cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) {
	for (x = 0; x < cm->abc->K; x++) {
	  cm->esc[v][x]  = sreLOG2(cm->e[v][x] / cm->null[x]);
	  cm->iesc[v][x] = Prob2Score(cm->e[v][x], cm->null[x]);
	  /*printf("cm->e[%4d][%2d]: %f esc: %f null[%d]: %f\n", v, x, cm->e[v][x], cm->esc[v][x], x, cm->null[x]);*/
	  /*printf("cm->e[%4d][%2d]: %f iesc->e: %f iesc: %d\n", v, x, cm->e[v][x], Score2Prob(cm->iesc[v][x], (cm->null[x])), cm->iesc[v][x]);*/
	}
	  }
	  /* These work even if begin/end distributions are inactive 0's,
	   * sreLOG2 will set beginsc, endsc to -infinity.
	   */
	  cm->beginsc[v]  = sreLOG2(cm->begin[v]);
	  cm->ibeginsc[v] = Prob2Score(cm->begin[v], 1.0);
	  /*printf("cm->begin[%4d]: %f ibeginsc->e: %f ibeginsc: %d\n", v, cm->begin[v], Score2Prob(cm->ibeginsc[v], 1.0), cm->ibeginsc[v]);*/

	  cm->endsc[v]    = sreLOG2(cm->end[v]);
	  cm->iendsc[v]   = Prob2Score(cm->end[v], 1.0);
	  /*printf("cm->end[%4d]: %f iendsc->e: %f iendsc: %d\n\n", v, cm->end[v], Score2Prob(cm->iendsc[v], 1.0), cm->iendsc[v]);*/
	}
  }
  cm->iel_selfsc = Prob2Score(sreEXP2(cm->el_selfsc), 1.0);
  /*printf("cm->el_selfsc: %f prob: %f cm->iel_selfsc: %d prob: %f\n", cm->el_selfsc,
	 (sreEXP2(cm->el_selfsc)), cm->iel_selfsc, (Score2Prob(cm->iel_selfsc, 1.0)));
	 printf("-INFTY: %d prob: %f 2^: %f\n", -INFTY, (Score2Prob(-INFTY, 1.0)), sreEXP2(-INFTY));*/

  /* Allocate and fill optimized emission scores for this CM.
   * If they already exist, free them and recalculate them, slightly wasteful, oh well.
   */
  if(cm->oesc != NULL || cm->ioesc != NULL) FreeOptimizedEmitScores(cm->oesc, cm->ioesc, cm->M);

  cm->oesc  = SubFCalcAndCopyOptimizedEmitScoresFromMother(cm, mother_cm, mother_map);

  /* EPN, Wed Aug 20 15:26:31 2008
   * old, slow way:
   * cm->ioesc = ICalcOptimizedEmitScores(cm);
   */
  cm->ioesc = ICopyOptimizedEmitScoresFromFloats(cm, cm->oesc);

  /* Potentially, overwrite transitions with non-probabilistic
   * RSEARCH transitions. Currently only default transition
   * parameters are allowed, these are defined as DEFAULT_R*
   * in infernal.h
   * Note: This is untouched from CMLogoddsify(), we don't try
   *       to accelerate it, it's unusual that it will be executed.
   */
  if(cm->flags & CM_RSEARCHTRANS) {
	  float           alpha =   DEFAULT_RALPHA;
	  float           beta =    DEFAULT_RBETA;
	  float           alphap =  DEFAULT_RALPHAP;
	  float           betap =   DEFAULT_RBETAP;
	  float           beginsc = DEFAULT_RBEGINSC;
	  float           endsc =   DEFAULT_RENDSC;
	  int             nd;
	  /* First do the normal transitions */
	  for (v=0; v<cm->M; v++)
	{
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	    {
	      for (x=0; x<cm->cnum[v]; x++)
		{
		  cm->tsc[v][x] = -1. * rsearch_calculate_gap_penalty
		    (cm->stid[v], cm->stid[cm->cfirst[v]+x],
		     cm->ndtype[cm->ndidx[v]], cm->ndtype[cm->ndidx[cm->cfirst[v]+x]],
		     alpha, beta, alphap, betap);
		  /* alphas and rbetas were positive -- gap score is a penalty, so
		     multiply by -1 */
		  cm->itsc[v][x] = (int) floor(0.5 + INTSCALE * cm->tsc[v][x]);
		}
	    }
	}
	  /* Overwrite local begin and end scores */
	  for (v=cm->M - 1; v>=0; v--) {
	cm->beginsc[v] = IMPOSSIBLE;
	cm->endsc[v] = IMPOSSIBLE;
	  }

	  /* beginsc states */
	  for (nd = 2; nd < cm->nodes; nd++) {
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	    cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BIF_nd)
	  {
	    cm->beginsc[cm->nodemap[nd]] = beginsc;
	    cm->ibeginsc[cm->nodemap[nd]] = INTSCALE * beginsc;
	  }
	  }

	  /* endsc states */
	  for (nd = 1; nd < cm->nodes; nd++) {
	if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	     cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	     cm->ndtype[nd] == BEGR_nd) &&
	    cm->ndtype[nd+1] != END_nd)
	  {
	  cm->endsc[cm->nodemap[nd]] = endsc;
	  cm->iendsc[cm->nodemap[nd]] = INTSCALE * endsc;
	  }
	  }

	  cm->flags |= CMH_LOCAL_BEGIN;
	  cm->flags |= CMH_LOCAL_END;
	}
  /* raise flag saying we have valid log odds scores */
  cm->flags |= CMH_BITS;

  /* create cm->cmcons, we expect this to be valid if we have valid log odds score */
  if(cm->cmcons != NULL) FreeCMConsensus(cm->cmcons);
  if((cm->cmcons = CreateCMConsensus(cm, cm->abc)) == NULL) return eslFAIL;

  return eslOK;
}

/* Function: SubFCalcAndCopyOptimizedEmitScoresFromMother()
 * Date:     EPN, Wed Aug 20 15:40:23 2008
 *
 * Purpose:  Allocate, fill and return an optimized emission score vector
 *           of float scores for fast search/alignment.
 *           Fill emission scores by copying them when
 *           possible from a 'mother' CM if the current
 *           cm is a sub CM of the mother.
 *
 * Returns:  the 2D float emission score vector on success,
 *           dies immediately on memory allocation error.
 */
float **
SubFCalcAndCopyOptimizedEmitScoresFromMother(CM_t *cm, CM_t *mother_cm, CMSubMap_t *mother_map)
{
  int status;
  float **esc_vAA;
  ESL_DSQ a,b;
  int v;
  int cur_cell;
  int npairs = 0;
  int nsinglets = 0;
  float *ptr_to_start; /* points to block allocated to esc_vAA[0], nec b/c esc_vAA[0] gets set to NULL, because v == 0 is non-emitter */
  float **leftAA;
  float **rightAA;
  int mv;

  /* count pairs, singlets */
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  nsinglets++;
	  break;
	case MP_st:
	  npairs++;
	  break;
	}
  }

  /* set up our left and right vectors for all possible non-canonical residues,
   * these are calc'ed once and passed to FastPairScore*() functions to minimize
   * run time.
   */
  ESL_ALLOC(leftAA,  sizeof(float *) * cm->abc->Kp);
  ESL_ALLOC(rightAA, sizeof(float *) * cm->abc->Kp);
  for(a = 0; a <= cm->abc->K; a++) leftAA[a] = rightAA[a] = NULL; /* canonicals and gap, left/right unnec */
  for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	ESL_ALLOC(leftAA[a],  sizeof(float) * cm->abc->K);
	ESL_ALLOC(rightAA[a], sizeof(float) * cm->abc->K);
	esl_vec_FSet(leftAA[a],  cm->abc->K, 0.);
	esl_vec_FSet(rightAA[a], cm->abc->K, 0.);
	esl_abc_FCount(cm->abc, leftAA[a],  a, 1.);
	esl_abc_FCount(cm->abc, rightAA[a], a, 1.);
  }
  leftAA[cm->abc->Kp-1] = rightAA[cm->abc->Kp-1] = NULL; /* missing data, left/right unnec */

  /* precalculate possible emission scores for each state */
  ESL_ALLOC(esc_vAA,     sizeof(float *) * (cm->M));
  ESL_ALLOC(esc_vAA[0],  sizeof(float)   * ((cm->abc->Kp * nsinglets) + (cm->abc->Kp * cm->abc->Kp * npairs)));
  ptr_to_start = esc_vAA[0];
  cur_cell = 0;
  for(v = 0; v < cm->M; v++) {
	switch(cm->sttype[v]) {
	case IL_st:
	case ML_st:
	case IR_st:
	case MR_st:
	  esc_vAA[v] = ptr_to_start + cur_cell;
	  cur_cell += cm->abc->Kp;
	  if (mother_map->s2o_id[v] == TRUE) { /* this state maps identically to a mother_cm state, copy parameters */
	mv = mother_map->s2o_smap[v][0];
	esl_vec_FCopy(mother_cm->oesc[mv], cm->abc->Kp, esc_vAA[v]);
	  }
	  else {
	for(a = 0; a < cm->abc->K; a++) /* all canonical residues */
	  esc_vAA[v][a]  = cm->esc[v][a];
	esc_vAA[v][cm->abc->K] = IMPOSSIBLE; /* gap symbol is impossible */
	for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) /* all ambiguous residues */
	  esc_vAA[v][a]  = esl_abc_FAvgScore(cm->abc, a, cm->esc[v]);
	esc_vAA[v][cm->abc->Kp-1] = IMPOSSIBLE; /* missing data is IMPOSSIBLE */
	  }
	  break;
	case MP_st:
	  esc_vAA[v] = ptr_to_start + cur_cell;
	  esl_vec_FSet(esc_vAA[v], cm->abc->Kp * cm->abc->Kp, IMPOSSIBLE); /* init all cells to IMPOSSIBLE */
	  cur_cell += cm->abc->Kp * cm->abc->Kp;
	  if (mother_map->s2o_id[v] == TRUE) { /* this state maps identically to a mother_cm state, copy parameters */
	mv = mother_map->s2o_smap[v][0];
	esl_vec_FCopy(mother_cm->oesc[mv], cm->abc->Kp * cm->abc->Kp, esc_vAA[v]);
	  }
	  else {
	/* a is canonical, b is canonical */
	for(a = 0; a < cm->abc->K; a++) {
	  for(b = 0; b < cm->abc->K; b++) {
	    esc_vAA[v][(a * cm->abc->Kp) + b]  = cm->esc[v][(a * cm->abc->K) + b];
	  }
	}
	/* a is not canonical, b is canonical */
	for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	  for(b = 0; b < cm->abc->K; b++) {
	    esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreLeftOnlyDegenerate(cm->abc->K, cm->esc[v], leftAA[a], b);
	  }
	}
	/* a is canonical, b is not canonical */
	for(a = 0; a < cm->abc->K; a++) {
	  for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	    esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreRightOnlyDegenerate(cm->abc->K, cm->esc[v], rightAA[b], a);
	  }
	}
	/* a is not canonical, b is not canonical */
	for(a = cm->abc->K+1; a < cm->abc->Kp-1; a++) {
	  for(b = cm->abc->K+1; b < cm->abc->Kp-1; b++) {
	    esc_vAA[v][(a * cm->abc->Kp) + b]  = FastPairScoreBothDegenerate(cm->abc->K, cm->esc[v], leftAA[a], rightAA[b]);
	  }
	}
	/* everything else, when either a or b is gap or missing data, stays IMPOSSIBLE */
	  }
	  break;
	default:
	  esc_vAA[v] = NULL;
	  break;
	}
  }
  for(a = 0; a < cm->abc->Kp; a++) {
	if(leftAA[a] != NULL)  free(leftAA[a]);
	if(rightAA[a] != NULL) free(rightAA[a]);
  }
  free(leftAA);
  free(rightAA);
  return esc_vAA;

 ERROR:
  cm_Fail("memory allocation error.");
  return NULL; /* NEVERREACHED */
}

/* Function: CP9_reconfig2sub()
 * EPN 10.16.06
 *
 * Purpose:  Given a CM Plan 9 HMM and a start position
 *           (spos) and end position (epos) that a sub CM models,
 *           reconfigure the HMM so that it can only start in the
 *           node that models spos (spos_nd) end in the node that
 *           models epos (epos_nd).
 *
 *           If we're reconfiguring a CP9 HMM that ONLY models the
 *           consensus columns spos to epos, then spos_nd == 1
 *           and epos_nd == hmm->M, but this is not necessarily true.
 *           We may be reconfiguring a CP9 HMM that models the
 *           full alignment including positions before and/or after
 *           spos and epos. In this case spos_nd == spos and
 *           epos_nd == epos;
 *
 * Args:     hmm         - the CP9 model w/ data-dep prob's valid
 *           spos        - first consensus column modelled by some original
 *                         full length, template CP9 HMM that 'hmm' models.
 *           epos        - final consensus column modelled by some original
 *                         CP9 HMM that 'hmm' models.
 *           spos_nd     - the node of 'hmm' that models spos.
 *                         (1 if 'hmm' only has (epos-spos+1) nodes
 *                         (spos if 'hmm' has a node for each column of original aln)
 *           epos_nd     - the node of the 'hmm' in that models epos.
 *                         (hmm->M if 'hmm' only has (epos-spos+1) nodes
 *                         (epos if 'hmm' has a node for each column of original aln)
 *           orig_phi    - the 2D phi array for the original CP9 HMM.
 * Return:   (void)
 *           HMM probabilities are modified.
 */
void
CP9_reconfig2sub(CP9_t *hmm, int spos, int epos, int spos_nd,
		 int epos_nd, double **orig_phi)
{
  /* Make the necessary modifications. Since in cmalign --sub mode this
   * function will be called potentially once for each sequence, we
   * don't want to call CP9Logoddsify(), but rather only logoddsify
   * the parameters that are different.
   */

  /* Configure entry.
   * Exactly 3 ways to start, B->M_1 (hmm->begin[1]), B->I_0 (hmm->t[0][CTMI]),
   *                      and B->D_1 (hmm->t[0][CTMD])
   */
  /* prob of starting in M_spos is (1. - prob of starting in I_spos-1) as there is no D_spos-1 -> M_spos trans */

  if(spos > 1)
	{
	  hmm->begin[spos_nd] = 1.-((orig_phi[spos-1][HMMINSERT] * (1. - hmm->t[spos-1][CTII])) +
			        (orig_phi[spos  ][HMMDELETE] - (orig_phi[spos-1][HMMINSERT] * hmm->t[spos-1][CTID])));
	  hmm->t[spos_nd-1][CTMI] =   (orig_phi[spos-1][HMMINSERT] * (1. - hmm->t[spos-1][CTII]));
	  hmm->t[spos_nd-1][CTMD] =    orig_phi[spos  ][HMMDELETE] - (orig_phi[spos-1][HMMINSERT] * hmm->t[spos-1][CTID]);
	  hmm->t[spos_nd-1][CTMM] = 0.; /* probability of going from B(M_0) to M_1 is begin[1] */
	  hmm->t[spos_nd-1][CTMEL] = 0.; /* can't go to EL from B(M_0) */
	  hmm->t[spos_nd-1][CTDM] = 0.; /* D_0 doesn't exist */
	  hmm->t[spos_nd-1][CTDI] = 0.; /* D_0 doesn't exist */
	  hmm->t[spos_nd-1][CTDD] = 0.; /* D_0 doesn't exist */

	  hmm->bsc[spos_nd]       = Prob2Score(hmm->begin[1], 1.0);

	  hmm->tsc[CTMM][spos_nd-1] = -INFTY; /* probability of going from B(M_0) to M_1 is begin[1] */
	  hmm->tsc[CTMEL][spos_nd-1] = -INFTY;
	  hmm->tsc[CTDM][spos_nd-1] = -INFTY; /* D_0 doesn't exist */
	  hmm->tsc[CTDI][spos_nd-1] = -INFTY; /* D_0 doesn't exist */
	  hmm->tsc[CTDD][spos_nd-1] = -INFTY; /* D_0 doesn't exist */

	  hmm->tsc[CTMI][spos_nd-1] = Prob2Score(hmm->t[spos_nd-1][CTMI], 1.0);
	  hmm->tsc[CTMD][spos_nd-1] = Prob2Score(hmm->t[spos_nd-1][CTMD], 1.0);
	}

  if(epos < hmm->M)
	{
	  hmm->end[epos_nd]      = hmm->t[epos][CTMM] + hmm->t[epos][CTMD];
	  hmm->t[epos_nd][CTDM] += hmm->t[epos][CTDD];
	  hmm->t[epos_nd][CTIM] += hmm->t[epos][CTID];
	  hmm->t[epos_nd][CTMM]  = 0.; /* M->E is actually end[M] */
	  hmm->t[epos_nd][CTMEL]  = 0.;
	  hmm->t[epos_nd][CTMD]  = 0.; /* D_M+1 doesn't exist */
	  hmm->t[epos_nd][CTDD]  = 0.; /* D_M+1 doesn't exist */
	  hmm->t[epos_nd][CTID]  = 0.; /* D_M+1 doesn't exist */

	  hmm->esc[epos_nd]       = Prob2Score(hmm->end[epos_nd], 1.0);
	  hmm->tsc[CTDM][epos_nd] = Prob2Score(hmm->t[epos_nd][CTDM], 1.0);
	  hmm->tsc[CTIM][epos_nd] = Prob2Score(hmm->t[epos_nd][CTIM], 1.0);
	  hmm->tsc[CTMM][epos_nd] = -INFTY; /* M->E is actually end[M] */
	  hmm->tsc[CTMEL][epos_nd] = -INFTY;
	  hmm->tsc[CTMD][epos_nd] = -INFTY; /* D_M+1 doesn't exist */
	  hmm->tsc[CTDD][epos_nd] = -INFTY; /* D_M+1 doesn't exist */
	  hmm->tsc[CTID][epos_nd] = -INFTY; /* D_M+1 doesn't exist */
	}
  hmm->flags |= CPLAN9_HASBITS;	/* raise the log-odds ready flag */

  return;
}

#if 0
/* These two functions are not currently used, but could be useful for debugging
 * in the future */
static void  debug_print_misc_sub_cm_info(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CP9Map_t *orig_cp9map);
static void  debug_sub_cm_check_all_trans(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap);

/**************************************************************************
 * EPN 10.06.06
 * Function: debug_print_misc_sub_cm_info()
 **************************************************************************/
static void
debug_print_misc_sub_cm_info(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap, CP9Map_t *orig_cp9map)
{
  int status;
  int orig_il1;
  int orig_il2;
  int orig_ir1;
  int orig_ir2;
  int orig_ss;

  char **nodetypes;
  char **sttypes;
  char **sides;

  int orig_n1_type;
  int side_idx;

  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  ESL_ALLOC(sides, sizeof(char *) * 3);
  sides[0] = "L";
  sides[1] = "R";
  sides[2] = "N";

  orig_il1 = submap->s2o_smap[1][0]; /* 1st of up to 2 states that maps to sub_cm's ROOT_IL */
  orig_il2 = submap->s2o_smap[1][1]; /* 2nd state that maps to sub_cm's ROOT_IL or -1 if only 1 maps*/
  orig_ir1 = submap->s2o_smap[2][0]; /* 1st of up to 2 states that maps to sub_cm's ROOT_IR */
  orig_ir2 = submap->s2o_smap[2][1]; /* 2nd state that maps to sub_cm's ROOT_IR or -1 if only 1 maps*/

  /* We ASSUME that ambiguities have been removed, i.e. if two insert states map to either ROOT_IL
   * or ROOT_IR, one of them has been detached. We exploit this knowledge.
   */
  if(orig_il2 != -1)
	{
	  if(orig_cm->sttype[orig_il1+1] == E_st)
	orig_il1 = orig_il2; /* orig_il1 was detached */
	  else if(orig_cm->sttype[orig_il2+1] == E_st)
	{
	  /* do nothing */
	}
	  else
	cm_Fail("ERROR, can't determine which state was detached in debug_print_misc_sub_cm_info\n");
	}
  if(orig_ir2 != -1)
	{
	  if(orig_cm->sttype[orig_ir1+1] == E_st)
	orig_ir1 = orig_ir2; /* orig_ir1 was detached */
	  else if(orig_cm->sttype[orig_ir2+1] == E_st)
	{
	  /* do nothing */
	}
	  else
	cm_Fail("ERROR, can't determine which state was detached in debug_print_misc_sub_cm_info\n");
	}

  /* Now orig_il1 and orig_ir1 map to the ONLY insert states that map to sub_cm
   * ROOT_IL and ROOT_IR respectively.
   */
  printf("10.16.06 IL1: %3d %4s %2s | start:   %3d | end:   %3d\n", orig_il1, nodetypes[(int) orig_cm->ndtype[orig_cm->ndidx[orig_il1]]], sttypes[(int) orig_cm->sttype[orig_il1]], submap->spos, submap->epos);

  if(sub_cm->ndtype[1] == BIF_nd)
	{
	  orig_n1_type = 0;
	}
  else
	{
	  orig_n1_type = orig_cm->ndtype[orig_cm->ndidx[(submap->s2o_smap[3][0])]];
	}

  if(orig_n1_type == MATP_nd && sub_cm->ndtype[1] != MATR_nd)
	{
	  if(orig_cp9map->nd2lpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]] == submap->spos)
	side_idx = 0;
	  else if(orig_cp9map->nd2rpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]] == submap->spos)
	side_idx = 1;
	  else
	cm_Fail("ERROR MATP confusion! orig_cm node: %d | left: %d | right: %d | submap->spos: %d\n", (orig_cm->ndidx[(submap->s2o_smap[3][0])]), (orig_cp9map->nd2lpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]]), (orig_cp9map->nd2rpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]]), submap->spos);
	}
  else if (orig_n1_type == MATP_nd && sub_cm->ndtype[1] == MATR_nd)
	{
	  if(orig_cp9map->nd2lpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]] == submap->epos)
	side_idx = 0;
	  else if(orig_cp9map->nd2rpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]] == submap->epos)
	side_idx = 1;
	  else
	cm_Fail("ERROR MATP confusion! orig_cm node: %d | left: %d | right: %d | submap->spos: %d\n", (orig_cm->ndidx[(submap->s2o_smap[3][0])]), (orig_cp9map->nd2lpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]]), (orig_cp9map->nd2rpos[orig_cm->ndidx[(submap->s2o_smap[3][0])]]), submap->spos);
	}
  else
	{
	  side_idx = 2;
	}
  printf("10.16.06 IR1: %3d %4s %2s | sub-n1: %4s | orig-n1: %4s%1s | case:   ", orig_ir1, nodetypes[(int) orig_cm->ndtype[orig_cm->ndidx[orig_ir1]]], sttypes[(int) orig_cm->sttype[orig_ir1]], nodetypes[(int) sub_cm->ndtype[1]], nodetypes[(int) orig_n1_type], sides[side_idx]);

  /* figure out 'case' of ROOT transitions */
  orig_ss = submap->s2o_smap[3][0]; /* orig_ss is the 1 (of possibly 2) orig_cm states that map to the first
				     * state in sub_cm node 1 (sub_cm state 3)
				     */
  if((orig_il1 < orig_ir1) && (orig_ir1 < orig_ss))
	printf("1A\n");
  if((orig_il1 < orig_ss) && (orig_ss < orig_ir1))
	printf("1B\n");
  if((orig_ss < orig_il1) && (orig_il1 < orig_ir1))
	printf("1C\n");

  if((orig_ir1 < orig_il1) && (orig_il1 < orig_ss))
	printf("2A\n");
  if((orig_ir1 < orig_ss) && (orig_ss < orig_il1))
	printf("2B\n");
  if((orig_ss < orig_ir1) && (orig_ir1 < orig_il1))
	printf("2C\n");

  printf("\n");

  /* Begin 10.17.06 info */
  int ilmap, irmap;
  int ildual, irdual;
  int iloff, iroff;
  int other_insert_il;
  int other_insert_ir;

  if(orig_cm->sttype[orig_il1] == IL_st)
	ilmap = 0; /* sides[0] = "L" */
  else
	ilmap = 1; /* sides[1] = "R" */
  if(orig_cm->sttype[orig_ir1] == IL_st)
	irmap = 0; /* sides[0] = "L" */
  else
	irmap = 1; /* sides[1] = "R" */

  if(orig_cm->ndtype[orig_cm->ndidx[orig_il1]] == MATP_nd ||
	 orig_cm->ndtype[orig_cm->ndidx[orig_il1]] == ROOT_nd)
	ildual = TRUE;
  else
	ildual = FALSE;
  if(orig_cm->ndtype[orig_cm->ndidx[orig_ir1]] == MATP_nd ||
	 orig_cm->ndtype[orig_cm->ndidx[orig_ir1]] == ROOT_nd)
	irdual = TRUE;
  else
	irdual = FALSE;

  iloff = -1;
  if(ildual == TRUE)
	{
	  /* check if other insert state in orig_cm node that has insert that
	   * maps to sub_cm ROOT_IL maps to a state in the sub_cm
	   */
	  if(ilmap == 0) /* ROOT_IL maps to a IL */
	other_insert_il = orig_il1 + 1;
	  else           /* ROOT_IL maps to a IR */
	other_insert_il = orig_il1 - 1;
	  if(submap->o2s_smap[other_insert_il][0] == -1 &&
	 submap->o2s_smap[other_insert_il][1] == -1)
	iloff = TRUE;
	  else
	iloff = FALSE;
	}

  iroff = -1;
  if(irdual == TRUE)
	{
	  if(irmap == 0) /* ROOT_IR maps to a IL */
	other_insert_ir = orig_ir1 + 1;
	  else           /* ROOT_IR maps to a IR */
	other_insert_ir = orig_ir1 - 1;
	  if(submap->o2s_smap[other_insert_ir][0] == -1 &&
	 submap->o2s_smap[other_insert_ir][1] == -1)
	iroff = TRUE;
	  else
	iroff = FALSE;
	}

  CMEmitMap_t *orig_emap;         /* consensus emit map for the original, template CM */
  int other_cc_il, other_cc_ir;
  orig_emap = CreateEmitMap(orig_cm);
  other_cc_il = -1;
  other_cc_ir = -1;
  if(ildual == TRUE)
	{
	  if(orig_cm->sttype[other_insert_il] == IL_st) /* sub ROOT_IL maps to IR, other maps to IL */
 	{
	  other_cc_il = orig_emap->lpos[orig_cm->ndidx[other_insert_il]] + 1;
	  if(other_cc_il > submap->spos)
	    cm_Fail("ERROR FUNKY\n");
	  ildual = 4;
	}
	  else /* ROOT_IL maps to IL, other maps to IR */
	{
	  other_cc_il = orig_emap->rpos[orig_cm->ndidx[other_insert_il]] - 1;
	  if(other_cc_il < submap->epos)
	    ildual = 1;
	  if(other_cc_il == submap->epos)
	    ildual = 2;
	  if(other_cc_il > submap->epos)
	    ildual = 3;
	}
	}
  /*printf("10.17.06 other_insert_il: %d other_cc_il: %d submap->spos: %d submap->epos: %d ildual: %d\n", other_insert_il, other_cc_il, submap->spos, submap->epos, ildual);*/
  if(irdual == TRUE)
	{
	  if(orig_cm->sttype[other_insert_ir] == IL_st) /* sub ROOT_IR maps to IR, other maps to IL */
	{
	  other_cc_ir = orig_emap->lpos[orig_cm->ndidx[other_insert_ir]] + 1;
	  if(other_cc_ir > submap->spos)
	    irdual = 1;
	  if(other_cc_ir == submap->spos)
	    irdual = 2;
	  if(other_cc_ir < submap->spos)
	    irdual = 3;
	}
	  else /* ROOT_IR maps to IL, other maps to IR */
	{
	  other_cc_ir = orig_emap->rpos[orig_cm->ndidx[other_insert_ir]] - 1;
	  if(other_cc_ir < submap->epos)
	    cm_Fail("ERROR FUNKY\n");
	  irdual = 4;
	}
	}
  /*printf("10.17.06 other_insert_ir: %d other_cc_ir: %d submap->spos: %d submap->epos: %d irdual: %d\n", other_insert_ir, other_cc_ir, submap->spos, submap->epos, irdual);*/

  printf("10.17.06 ilmap: %5s ildual: %2d iloff: %2d irmap: %5s irdual: %2d iroff: %2d subn1: %4s orign1: %4s%1s\n", sides[ilmap], ildual, iloff, sides[irmap], irdual, iroff, nodetypes[(int) sub_cm->ndtype[1]], nodetypes[(int) orig_n1_type], sides[side_idx]);

  int start_flag;
  int v;
  int vend;

  if(orig_il1 < orig_ir1)
	{
	  v = orig_il1;
	  vend = orig_ir1;
	}
  else
	{
	  v = orig_ir1;
	  vend = orig_il1;
	}
  start_flag = 0;
  for(; v <= vend; v++)
	if(orig_cm->sttype[v] == S_st)
	  start_flag = 1;
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 11.01.06
 * debug_sub_cm_check_all_trans()
 */
void
debug_sub_cm_check_all_trans(CM_t *orig_cm, CM_t *sub_cm, CMSubMap_t *submap)
{
  int status;
  int nd;
  int v;
  int y, yoffset;
  float sum, ndsum;
  int orig_nd, orig_v1, orig_v2;

  char **nodetypes;
  ESL_ALLOC(nodetypes, sizeof(char *) * 8);
  nodetypes[0] = "BIF";
  nodetypes[1] = "MATP";
  nodetypes[2] = "MATL";
  nodetypes[3] = "MATR";
  nodetypes[4] = "BEGL";
  nodetypes[5] = "BEGR";
  nodetypes[6] = "ROOT";
  nodetypes[7] = "END";

  char **sttypes;
  ESL_ALLOC(sttypes, sizeof(char *) * 10);
  sttypes[0] = "D";
  sttypes[1] = "MP";
  sttypes[2] = "ML";
  sttypes[3] = "MR";
  sttypes[4] = "IL";
  sttypes[5] = "IR";
  sttypes[6] = "S";
  sttypes[7] = "E";
  sttypes[8] = "B";
  sttypes[9] = "EL";

  for(nd = 0; nd < sub_cm->nodes; nd++)
	{
	  sum = 0.;
	  if(sub_cm->ndtype[nd] != END_nd && sub_cm->ndtype[nd] != BIF_nd)
	{
	  ndsum = 0.;
	  v = sub_cm->nodemap[nd];
	  while(sub_cm->ndidx[v] == nd && sub_cm->sttype[v] != IL_st && sub_cm->sttype[v] != IR_st)
	    {
	      sum = 0.;
	      for(y = sub_cm->cfirst[v]; y < sub_cm->cfirst[v]+sub_cm->cnum[v]; y++)
		{
		  yoffset = y - sub_cm->cfirst[v];
		  printf("\t\tsub_cm->t[%3d][%3d]: %f\n", v, yoffset, sub_cm->t[v][yoffset]);
		  sum    += sub_cm->t[v][yoffset];
		}
	      orig_v1  = submap->s2o_smap[v][0];
	      orig_v2  = submap->s2o_smap[v][1];
	      orig_nd = orig_cm->ndidx[orig_v1];
	      if(sub_cm->ndtype[nd+1] != END_nd)
		{
		  if(orig_v2 != -1)
		    printf("sum t[%4d %4s %2s %2s] nd: %4d: %f\n", v, nodetypes[(int) orig_cm->ndtype[orig_nd]], sttypes[(int) orig_cm->sttype[orig_v1]], sttypes[(int) orig_cm->sttype[orig_v2]], nd, sum);
		  else
		    printf("sum t[%4d %4s %2s   ] nd: %4d: %f\n", v, nodetypes[(int) orig_cm->ndtype[orig_nd]], sttypes[(int) orig_cm->sttype[orig_v1]], nd, sum);
		}
	      ndsum += sum;
	      v++;
	    }
	  if(sub_cm->ndtype[nd+1] != END_nd)
	    printf("\tndsum t nd (%4s): %4d: %f\n", nodetypes[(int) orig_cm->ndtype[orig_nd]], nd, ndsum);
	}
	}
  free(nodetypes);
  free(sttypes);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}
#endif

/*** End of inlined file: cm_submodel.c ***/


/*** Start of inlined file: cm_tophits.c ***/


#include <stdlib.h>
#include <string.h>
#include <limits.h>



static int     remove_or_mark_overlaps_one_seq_fast  (CM_TOPHITS *th, int64_t idx1, int64_t idx2, int do_remove, char *errbuf);
static int     remove_or_mark_overlaps_one_seq_memeff(CM_TOPHITS *th, int64_t idx1, int64_t idx2, int do_remove, char *errbuf);
static int64_t overlap_nres(int64_t from1, int64_t to1, int64_t from2, int64_t to2, int64_t *ret_nes, char *errbuf);

/*****************************************************************
 * 1. The CM_TOPHITS object
 *****************************************************************/

/* Function:  cm_tophits_Create()
 * Synopsis:  Allocate a hit list.
 * Incept:    EPN, Tue May 24 13:11:06 2011
 *            SRE, Fri Dec 28 07:17:51 2007 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Allocates a new <CM_TOPHITS> hit list and return a pointer
 *            to it.
 *
 * Throws:    <NULL> on allocation failure.
 */
CM_TOPHITS *
cm_tophits_Create(void)
{
  CM_TOPHITS *h = NULL;
  int         default_nalloc = 256;
  int         status;

  ESL_ALLOC(h, sizeof(CM_TOPHITS));
  h->hit    = NULL;
  h->unsrt  = NULL;

  ESL_ALLOC(h->hit,   sizeof(CM_HIT *) * default_nalloc);
  ESL_ALLOC(h->unsrt, sizeof(CM_HIT)   * default_nalloc);
  h->Nalloc    = default_nalloc;
  h->N         = 0;
  h->nreported = 0;
  h->nincluded = 0;
  h->is_sorted_by_evalue           = TRUE;  /* but only because there's 0 hits */
  h->is_sorted_for_overlap_removal = FALSE; /* actually this is true with 0 hits, but for safety,
				             * we don't want multiple sorted_* fields as TRUE */
  h->is_sorted_by_position         = FALSE; /* ditto */
  h->hit[0]    = h->unsrt;  /* if you're going to call it "sorted" when it contains just one hit, you need this */
  return h;

 ERROR:
  cm_tophits_Destroy(h);
  return NULL;
}

/* Function:  cm_tophits_Grow()
 * Synopsis:  Reallocates a larger hit list, if needed.
 * Incept:    EPN, Tue May 24 13:13:52 2011
 *            SRE, Fri Dec 28 07:37:27 2007 [Janelia] (p7_tophits.c)
 *
 * Purpose:   If list <h> cannot hold another hit, doubles
 *            the internal allocation.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation failure; in this case,
 *            the data in <h> are unchanged.
 */
int
cm_tophits_Grow(CM_TOPHITS *h)
{
  void   *p;
  CM_HIT *ori    = h->unsrt;
  int     Nalloc = h->Nalloc * 2;    /* grow by doubling */
  int     i;
  int     status;

  if (h->N < h->Nalloc) return eslOK; /* we have enough room for another hit */

  ESL_RALLOC(h->hit,   p, sizeof(CM_HIT *) * Nalloc);
  ESL_RALLOC(h->unsrt, p, sizeof(CM_HIT)   * Nalloc);

  /* If we grow a sorted list, we have to translate the pointers
   * in h->hit, because h->unsrt might have just moved in memory.
   */
  if (h->is_sorted_by_evalue || h->is_sorted_for_overlap_removal || h->is_sorted_by_position) {
	for (i = 0; i < h->N; i++)
	  h->hit[i] = h->unsrt + (h->hit[i] - ori);
  }

  h->Nalloc = Nalloc;
  return eslOK;

 ERROR:
  return eslEMEM;
}

/* Function:  cm_tophits_CreateNextHit()
 * Synopsis:  Get pointer to new structure for recording a hit.
 * Incept:    EPN, Tue May 24 13:14:12 2011
 *            SRE, Tue Mar 11 08:44:53 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Ask the top hits object <h> to do any necessary
 *            internal allocation and bookkeeping to add a new,
 *            empty hit to its list; return a pointer to
 *            this new <CM_HIT> structure for data to be filled
 *            in by the caller.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation error.
 */
int
cm_tophits_CreateNextHit(CM_TOPHITS *h, CM_HIT **ret_hit)
{
  CM_HIT *hit = NULL;
  int     status;

  if ((status = cm_tophits_Grow(h)) != eslOK) goto ERROR;

  hit = &(h->unsrt[h->N]);
  h->N++;
  if (h->N >= 2) {
	h->is_sorted_by_evalue           = FALSE;
	h->is_sorted_for_overlap_removal = FALSE;
	h->is_sorted_for_overlap_markup  = FALSE;
	h->is_sorted_by_position         = FALSE;
  }

  hit->name             = NULL;
  hit->acc              = NULL;
  hit->desc             = NULL;

  hit->start            = 1;
  hit->stop             = 1;
  hit->in_rc            = FALSE;
  hit->score            = 0.0;
  hit->bias             = 0.0;
  hit->pvalue           = 0.0;
  hit->evalue           = 0.0;
  hit->has_evalue       = FALSE;

  hit->cm_idx           = -1;
  hit->clan_idx         = -1;
  hit->seq_idx          = -1;
  hit->pass_idx         = -1;
  hit->hit_idx          = h->N-1;

  hit->srcL             = -1;
  hit->hmmonly          = FALSE;
  hit->glocal           = FALSE;

  hit->ad               = NULL;
  hit->flags            = CM_HIT_FLAGS_DEFAULT;

  hit->any_oidx         = -1;
  hit->win_oidx         = -1;
  hit->any_bitE         = 0.0;
  hit->win_bitE         = 0.0;

  *ret_hit = hit;
  return eslOK;

 ERROR:
  *ret_hit = NULL;
  return status;
}

/* hit_sorter_by_evalue(), hit_sorter_for_overlap_removal, hit_sorter_for_overlap_markup_clans_only,
 * hit_sorter_for_overlap_markup_clans_agnostic and hit_sorter_by_position: qsort's pawns, below */
static int
  hit_sorter_by_evalue(const void *vh1, const void *vh2)
  {
  CM_HIT *h1 = *((CM_HIT **) vh1);  /* don't ask. don't change. Don't Panic. */
  CM_HIT *h2 = *((CM_HIT **) vh2);

  if      (h1->evalue > h2->evalue) return  1; /* first key, E-value, low to high */
  else if (h1->evalue < h2->evalue) return -1;
  else {
	if      (h1->score < h2->score) return  1; /* second key, bit score, high to low */
	else if (h1->score > h2->score) return -1;
	else {
	  if      (h1->seq_idx > h2->seq_idx) return  1; /* second key, seq_idx (unique id for sequences), low to high */
	  else if (h1->seq_idx < h2->seq_idx) return -1;
	  else {
	if      (h1->start > h2->start) return  1; /* third key, start position, low to high */
	else if (h1->start < h2->start) return -1;
	else                            return  (h1->pass_idx < h2->pass_idx ? 1 : -1 ); /* fourth key, pass_idx, high to low */
	  }
	}
  }
}

static int
hit_sorter_for_overlap_removal(const void *vh1, const void *vh2)
{
  CM_HIT *h1 = *((CM_HIT **) vh1);  /* don't ask. don't change. Don't Panic. */
  CM_HIT *h2 = *((CM_HIT **) vh2);

  if      (h1->cm_idx > h2->cm_idx)       return  1; /* first key, cm_idx (unique id for models), low to high */
  else if (h1->cm_idx < h2->cm_idx)       return -1;
  else {
	if      (h1->seq_idx > h2->seq_idx)   return  1; /* second key, seq_idx (unique id for sequences), low to high */
	else if (h1->seq_idx < h2->seq_idx)   return -1;
	else {
	  /* same model and same sequence; sort by strand, then score, then start position */
	  if     (h1->in_rc > h2->in_rc)      return  1; /* third key, strand (h1->in_rc = 1, h1->in_rc = 0), forward, then reverse */
	  else if(h1->in_rc < h2->in_rc)      return -1; /*                   (h1->in_rc = 0, h2->in_rc = 1), forward, then reverse */
	  else {
	if     (h1->score < h2->score)    return  1; /* fourth key is bit score, high to low */
	else if(h1->score > h2->score)    return -1;
	else {
	  if     (h1->start > h2->start)  return  1; /* fifth key is start position, low to high (irregardless of in_rc value) */
	  else if(h1->start < h2->start)  return -1;
	  else                            return  0;
	}
	  }
	}
  }
}

static int
hit_sorter_for_overlap_markup_clans_only(const void *vh1, const void *vh2)
{
  CM_HIT *h1 = *((CM_HIT **) vh1);  /* don't ask. don't change. Don't Panic. */
  CM_HIT *h2 = *((CM_HIT **) vh2);

  if      (h1->seq_idx > h2->seq_idx)   return  1; /* first key, seq_idx (unique id for sequences), low to high */
  else if (h1->seq_idx < h2->seq_idx)   return -1;
  else {
	/* same sequence; sort by strand, then clan_idx, then E-value, then score, then start position, then CM index */
	if     (h1->in_rc > h2->in_rc)      return  1; /* second key, strand (h1->in_rc = 1, h1->in_rc = 0), forward, then reverse */
	else if(h1->in_rc < h2->in_rc)      return -1; /*                    (h1->in_rc = 0, h2->in_rc = 1), forward, then reverse */
	else {
	  if     (h1->clan_idx > h2->clan_idx) return  1; /* third key is clan_idx, low to high */
	  else if(h1->clan_idx < h2->clan_idx) return -1;
	  else {
		if     (h1->evalue > h2->evalue)    return  1; /* fourth key is E-value, low to high */
		else if(h1->evalue < h2->evalue)    return -1;
		else {
		  if     (h1->score < h2->score)    return  1; /* fifth key is bit score, high to low */
		  else if(h1->score > h2->score)    return -1;
		  else {
			if     (h1->start > h2->start)  return  1; /* sixth key is start position, low to high (irregardless of in_rc value) */
			else if(h1->start < h2->start)  return -1;
			else {
			  if     (h1->cm_idx > h2->cm_idx) return  1; /* seventh key is cm_idx (unique id for models), low to high */
			  else if(h1->cm_idx < h2->cm_idx) return -1;
			  else                             return  0;
			}
		  }
		}
	  }
	}
  }
}

static int
hit_sorter_for_overlap_markup_clans_agnostic(const void *vh1, const void *vh2)
{
  CM_HIT *h1 = *((CM_HIT **) vh1);  /* don't ask. don't change. Don't Panic. */
  CM_HIT *h2 = *((CM_HIT **) vh2);

  if      (h1->seq_idx > h2->seq_idx)   return  1; /* first key, seq_idx (unique id for sequences), low to high */
  else if (h1->seq_idx < h2->seq_idx)   return -1;
  else {
	/* same sequence; sort by strand, then E-value, then score, then start position, then CM index */
	if     (h1->in_rc > h2->in_rc)      return  1; /* second key, strand (h1->in_rc = 1, h1->in_rc = 0), forward, then reverse */
	else if(h1->in_rc < h2->in_rc)      return -1; /*                    (h1->in_rc = 0, h2->in_rc = 1), forward, then reverse */
	else {
	  if     (h1->evalue > h2->evalue)    return  1; /* fourth key is E-value, low to high */
	  else if(h1->evalue < h2->evalue)    return -1;
	  else {
		if     (h1->score < h2->score)    return  1; /* fifth key is bit score, high to low */
		else if(h1->score > h2->score)    return -1;
		else {
		  if     (h1->start > h2->start)  return  1; /* sixth key is start position, low to high (irregardless of in_rc value) */
		  else if(h1->start < h2->start)  return -1;
		  else {
			if     (h1->cm_idx > h2->cm_idx) return  1; /* seventh key is cm_idx (unique id for models), low to high */
			else if(h1->cm_idx < h2->cm_idx) return -1;
			else                             return  0;
		  }
		}
	  }
	}
  }
}

static int
hit_sorter_by_position(const void *vh1, const void *vh2)
{
  CM_HIT *h1 = *((CM_HIT **) vh1);  /* don't ask. don't change. Don't Panic. */
  CM_HIT *h2 = *((CM_HIT **) vh2);

  if      (h1->cm_idx > h2->cm_idx)     return  1; /* first key, cm_idx (unique id for models), low to high */
  else if (h1->cm_idx < h2->cm_idx)     return -1; /* first key, cm_idx (unique id for models), low to high */
  else {
	if      (h1->seq_idx > h2->seq_idx) return  1; /* second key, seq_idx (unique id for sequences), low to high */
	else if (h1->seq_idx < h2->seq_idx) return -1;
	else {
	  /* same sequence, sort by strand, stop position then start position (if revcomp) or start position then stop position (if !revcomp) */
	  if     (h1->in_rc > h2->in_rc)    return  1; /* third key, strand (h1->in_rc = 1, h1->in_rc = 0), forward, then reverse */
	  else if(h1->in_rc < h2->in_rc)    return -1; /*                   (h1->in_rc = 0, h2->in_rc = 1), forward, then reverse */
	  else if(h1->in_rc) {
	if     (h1->stop > h2->stop)    return  1; /* both revcomp:     fourth key is stop  position, low to high */
	else if(h1->stop < h2->stop)    return -1;
	else                            return (h1->start  > h2->start  ? 1 : -1 ); /* both revcomp, same stop position, fourth key is start position, low to high */
	  }
	  else               {
	if     (h1->start > h2->start)  return  1; /* both !revcomp:    fourth key is start position, low to high */
	else if(h1->start < h2->start)  return -1;
	else                            return (h1->stop  > h2->stop    ? 1 : -1 ); /* both !revcomp, same start position, fourth key is stop position, low to high */
	  }
	}
  }
}

/* Function:  cm_tophits_SortByEvalue()
 * Synopsis:  Sorts a hit list by E-value.
 * Incept:    EPN, Tue May 24 13:30:23 2011
 *            SRE, Fri Dec 28 07:51:56 2007 (p7_tophits_Sort())
 *
 * Purpose:   Sorts a top hit list by E-value. After this call,
 *            <h->hit[i]> points to the i'th ranked <CM_HIT> for all
 *            <h->N> hits. First sort key is E-value (low to high),
 *            second is score (high to low), third is seq_idx
 *            (low to high), fourth is start position (low to high).

 * Returns:   <eslOK> on success.
 */
int
cm_tophits_SortByEvalue(CM_TOPHITS *h)
{
  int i;

  if (h->is_sorted_by_evalue) {
	h->is_sorted_for_overlap_removal = FALSE;
	h->is_sorted_for_overlap_markup  = FALSE;
	h->is_sorted_by_position         = FALSE;
	return eslOK;
  }
  /* initialize hit ptrs, this also unsorts if already sorted by seq_idx */
  for (i = 0; i < h->N; i++) h->hit[i] = h->unsrt + i;
  if (h->N > 1)  qsort(h->hit, h->N, sizeof(CM_HIT *), hit_sorter_by_evalue);
  h->is_sorted_for_overlap_removal = FALSE;
  h->is_sorted_for_overlap_markup  = FALSE;
  h->is_sorted_by_position         = FALSE;
  h->is_sorted_by_evalue           = TRUE;
  return eslOK;
}

/* Function:  cm_tophits_SortForOverlapRemoval()
 * Synopsis:  Sorts a hit list by cm index, sequence index, strand, then score.
 * Incept:    EPN, Tue Dec 20 09:17:47 2011
 *
 * Purpose:   Sorts a top hit list to ease removal of duplicates.
 *            After this call, <h->hit[i]> points to the i'th ranked
 *            <CM_HIT> for all <h->N> hits. First sort key is cm_idx
 *            (low to high), second is seq_idx (low to high) position
 *            (low to high), third is strand (forward then reverse),
 *            fourth key is score.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_SortForOverlapRemoval(CM_TOPHITS *h)
{
  int i;

  if (h->is_sorted_for_overlap_removal) {
	h->is_sorted_by_evalue          = FALSE;
	h->is_sorted_by_position        = FALSE;
	h->is_sorted_for_overlap_markup = FALSE;
	return eslOK;
  }
  /* initialize hit ptrs, this also unsorts if already sorted by score */
  for (i = 0; i < h->N; i++) h->hit[i] = h->unsrt + i;
  if (h->N > 1)  qsort(h->hit, h->N, sizeof(CM_HIT *), hit_sorter_for_overlap_removal);
  h->is_sorted_by_evalue           = FALSE;
  h->is_sorted_by_position         = FALSE;
  h->is_sorted_for_overlap_markup  = FALSE;
  h->is_sorted_for_overlap_removal = TRUE;

  return eslOK;
}

/* Function:  cm_tophits_SortForOverlapMarkup()
 * Synopsis:  Sorts a hit list by sequence index, strand, score, then model.
 * Incept:    EPN, Tue Dec 20 09:17:47 2011
 *
 * Purpose:   Sorts a top hit list to ease markup of overlaps that
 *            overlap on the same strand of the same sequence by
 *            different models.
 *
 *            After this call, <h->hit[i]> points to the i'th ranked
 *            <CM_HIT> for all <h->N> hits. First sort key is seq_idx
 *            (low to high), second is strand (forward then reverse),
 *            third key is E-value (low to high), fourth is score (high
 *            to low), fifth is start position (low to high) and
 *            sixth key is CM idx (unique id for models, low to high).
 *
 * Args:      do_clans_only - TRUE: we are only marking overlaps within clans
 *                            FALSE: we are marking all overlaps
 *                            This has implications on how we sort.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_SortForOverlapMarkup(CM_TOPHITS *h, int do_clans_only)
{
  int i;

  if (h->is_sorted_for_overlap_markup) {
	h->is_sorted_by_evalue           = FALSE;
	h->is_sorted_by_position         = FALSE;
	h->is_sorted_for_overlap_removal = FALSE;
	return eslOK;
  }
  /* initialize hit ptrs, this also unsorts if already sorted by score */
  for (i = 0; i < h->N; i++) h->hit[i] = h->unsrt + i;
  if (h->N > 1) {
	if(do_clans_only) {
	  qsort(h->hit, h->N, sizeof(CM_HIT *), hit_sorter_for_overlap_markup_clans_only);
	}
	else {
	  qsort(h->hit, h->N, sizeof(CM_HIT *), hit_sorter_for_overlap_markup_clans_agnostic);
	}
  }
  h->is_sorted_by_evalue           = FALSE;
  h->is_sorted_by_position         = FALSE;
  h->is_sorted_for_overlap_removal = FALSE;
  h->is_sorted_for_overlap_markup  = TRUE;

  return eslOK;
}

/* Function:  cm_tophits_SortByPosition()
 * Synopsis:  Sorts a hit list by cm index, sequence index, strand, position, then bit score.
 * Incept:    EPN, Tue Dec 20 09:17:47 2011
 *
 * Purpose:   Sorts a top hit list to ease merging of nearby hits after
 *            padding start and stop (like we do at the end of
 *            cm_pli_SeqCYKFilter()).
 *            After this call, <h->hit[i]> points to the i'th ranked
 *            <CM_HIT> for all <h->N> hits. First sort key is cm_idx
 *            (low to high), second is seq_idx (low to high) position
 *            (low to high), third is strand (forward then reverse),
 *            fourth key is start (if ! in_rc) or stop (if in_rc)
 *            (low to high for both strands).
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_SortByPosition(CM_TOPHITS *h)
{
  int i;

  if (h->is_sorted_by_position) {
	h->is_sorted_by_evalue           = FALSE;
	h->is_sorted_for_overlap_removal = FALSE;
	h->is_sorted_for_overlap_markup  = FALSE;
	return eslOK;
  }
  /* initialize hit ptrs, this also unsorts if already sorted by score */
  for (i = 0; i < h->N; i++) h->hit[i] = h->unsrt + i;
  if (h->N > 1)  qsort(h->hit, h->N, sizeof(CM_HIT *), hit_sorter_by_position);
  h->is_sorted_by_evalue           = FALSE;
  h->is_sorted_for_overlap_removal = FALSE;
  h->is_sorted_for_overlap_markup  = FALSE;
  h->is_sorted_by_position         = TRUE;

  return eslOK;
}

/* Function:  cm_tophits_Merge()
 * Synopsis:  Merge two top hits lists.
 * Incept:    EPN, Tue May 24 13:30:39 2011
 *            SRE, Fri Dec 28 09:32:12 2007 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Merge <h2> into <h1>. Upon return, <h1>
 *            contains the unsorted, merged list. <h2>
 *            is effectively destroyed; caller should
 *            not access it further, and may as well free
 *            it immediately.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation failure, and
 *            both <h1> and <h2> remain valid.
 */
int
cm_tophits_Merge(CM_TOPHITS *h1, CM_TOPHITS *h2)
{
  void    *p;
  CM_HIT  *new2;
  int      i;
  int      Nalloc = h1->Nalloc + h2->Nalloc;
  int      status;

  /* Attempt our allocations, so we fail early if we fail.
   * Reallocating h1->unsrt screws up h1->hit, so fix it.
   */
  ESL_RALLOC(h1->unsrt, p, sizeof(CM_HIT)   * Nalloc);
  ESL_RALLOC(h1->hit,   p, sizeof(CM_HIT *) * Nalloc);

  /* Update h2's data that relates to hit indices */
  for (i = 0; i < h2->N; i++)
	{
	  if(h2->unsrt[i].hit_idx  != -1) { h2->unsrt[i].hit_idx  += h1->N; }
	  if(h2->unsrt[i].any_oidx != -1) { h2->unsrt[i].any_oidx += h1->N; }
	  if(h2->unsrt[i].win_oidx != -1) { h2->unsrt[i].win_oidx += h1->N; }
	}

  /* Append h2's unsorted data array to h1. h2's data begin at <new2> */
  new2 = h1->unsrt + h1->N;
  memcpy(new2, h2->unsrt, sizeof(CM_HIT) * h2->N);

  /* h2 now turns over management of name, acc, desc memory to h1;
   * nullify its pointers, to prevent double free
   */
  for (i = 0; i < h2->N; i++)
	{
	  h2->unsrt[i].name = NULL;
	  h2->unsrt[i].acc  = NULL;
	  h2->unsrt[i].desc = NULL;
	  h2->unsrt[i].ad   = NULL;
	}

  /* Construct the new grown h1 */
  h1->Nalloc = Nalloc;
  h1->N     += h2->N;
  h1->is_sorted_by_evalue           = FALSE;
  h1->is_sorted_for_overlap_removal = FALSE;
  h1->is_sorted_by_position         = FALSE;

  /* reset pointers in sorted list (not really nec because we're not sorted) */
  for (i = 0; i < h1->N; i++) h1->hit[i] = h1->unsrt + i;

  return eslOK;

 ERROR:
  return status;
}


/* Function:  cm_tophits_GetMaxPositionLength()
 * Synopsis:  Returns maximum position length in hit list (targets).
 * Incept:    EPN, Tue May 24 13:31:13 2011
 *            TJW, Mon May 24 14:16:16 EDT 2010 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Returns the length of the longest hit location (start/end)
 *            of all the registered hits, in chars. This is useful when
 *            deciding how to format output.
 *
 *            The maximum is taken over all registered hits. This
 *            opens a possible side effect: caller might print only
 *            the top hits, and the max name length in these top hits
 *            may be different than the max length over all the hits.
 *
 *            If there are no hits in <h>, or none of the
 *            hits have names, returns 0.
 */
int
cm_tophits_GetMaxPositionLength(CM_TOPHITS *h)
{
  int i, max;

  max = 0;
  for (i = 0; i < h->N; i++) {
	max = ESL_MAX(max,
		  ESL_MAX(integer_textwidth(h->unsrt[i].start), integer_textwidth(h->unsrt[i].stop)));
  }
  return max;
}

/* Function:  cm_tophits_GetMaxTargetLength()
 * Synopsis:  Returns maximum target length in hit list.
 * Incept:    EPN, Wed Oct 22 10:36:11 2014
 *
 * Purpose:   Returns the length of the longest target length (srcL)
 *            of all the registered hits, in chars. This is useful when
 *            deciding how to format output.
 */
int
cm_tophits_GetMaxTargetLength(CM_TOPHITS *h)
{
  int i, max;

  max = 0;
  for (i = 0; i < h->N; i++) {
	max = ESL_MAX(max, integer_textwidth(h->unsrt[i].srcL));
  }
  return max;
}

/* Function:  cm_tophits_GetMaxNameLength()
 * Synopsis:  Returns maximum name length in hit list (targets).
 * Incept:    EPN, Tue May 24 13:34:12 2011
 *            SRE, Fri Dec 28 09:00:13 2007 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Returns the maximum name length of all the registered
 *            hits, in chars. This is useful when deciding how to
 *            format output.
 *
 *            The maximum is taken over all registered hits. This
 *            opens a possible side effect: caller might print only
 *            the top hits, and the max name length in these top hits
 *            may be different than the max length over all the hits.
 *
 *            If there are no hits in <h>, or none of the
 *            hits have names, returns 0.
 */
int
cm_tophits_GetMaxNameLength(CM_TOPHITS *h)
{
  int i, max;
  for (max = 0, i = 0; i < h->N; i++)
	if (h->unsrt[i].name != NULL) {
	  max = ESL_MAX(max, strlen(h->unsrt[i].name));
	}
  return max;
}

/* Function:  cm_tophits_GetMaxDescLength()
 * Synopsis:  Returns maximum length of the desc field in hit list.
 * Incept:    EPN, Wed Oct 22 10:36:11 2014
 *
 * Purpose:   Returns the length of the longest description (desc)
 *            of all the registered hits, in chars. This is useful when
 *            deciding how to format output.
 */
int
cm_tophits_GetMaxDescLength(CM_TOPHITS *h)
{
  int i, max;

  max = 0;
  for (i = 0; i < h->N; i++) {
	if(h->unsrt[i].desc != NULL) {
	  max = ESL_MAX(max, strlen(h->unsrt[i].desc));
	}
  }
  return max;
}

/* Function:  cm_tophits_GetMaxAccessionLength()
 * Synopsis:  Returns maximum accession length in hit list (targets).
 * Incept:    EPN, Tue May 24 13:35:23 2011
 *            SRE, Tue Aug 25 09:18:33 2009 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Same as <cm_tophits_GetMaxNameLength()>, but for
 *            accessions. If there are no hits in <h>, or none
 *            of the hits have accessions, returns 0.
 */
int
cm_tophits_GetMaxAccessionLength(CM_TOPHITS *h)
{
  int i, max, n;
  for (max = 0, i = 0; i < h->N; i++)
	if (h->unsrt[i].acc != NULL) {
	  n   = strlen(h->unsrt[i].acc);
	  max = ESL_MAX(n, max);
	}
  return max;
}

/* Function:  cm_tophits_GetMaxShownLength()
 * Synopsis:  Returns max shown name/accession length in hit list.
 * Incept:    EPN, Tue May 24 13:35:50 2011
 *            SRE, Tue Aug 25 09:30:43 2009 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Same as <cm_tophits_GetMaxNameLength()>, but
 *            for the case when --acc is on, where
 *            we show accession if one is available, and
 *            fall back to showing the name if it is not.
 *            Returns the max length of whatever is being
 *            shown as the reported "name".
 */
int
cm_tophits_GetMaxShownLength(CM_TOPHITS *h)
{
  int i, max, n;
  for (max = 0, i = 0; i < h->N; i++)
  {
	  if (h->unsrt[i].acc != NULL && h->unsrt[i].acc[0] != '\0')
	{
	  n   = strlen(h->unsrt[i].acc);
	  max = ESL_MAX(n, max);
	}
	  else if (h->unsrt[i].name != NULL)
	{
	  n   = strlen(h->unsrt[i].name);
	  max = ESL_MAX(n, max);
	}
  }
  return max;
}

/* Function:  cm_tophits_GetMaxClanLength()
 * Synopsis:  Returns maximum length of a clan name in hit list (targets).
 * Incept:    EPN, Wed Jan 28 09:11:43 2015
 *
 * Purpose:   Returns the length of the longest clan name of all of the
 *            registered hits, in chars. This is useful when deciding
 *            how to format output.
 *
 *            The maximum is taken over all registered hits. This
 *            opens a possible side effect: caller might print only
 *            the top hits, and the max name length in these top hits
 *            may be different than the max length over all the hits.
 *
 *            If there are no hits in <h>, <clan_name_kh> is NULL, or
 *            none of the hits have clans, returns 0.
 */
int
cm_tophits_GetMaxClanLength(CM_TOPHITS *h, ESL_KEYHASH *clan_name_kh)
{
  int i, max;

  if(clan_name_kh == NULL) return 0;

  max = 0;
  for (i = 0; i < h->N; i++) {
	if(h->unsrt[i].clan_idx != -1) {
	  max = ESL_MAX(max,
					strlen(esl_keyhash_Get(clan_name_kh, h->unsrt[i].clan_idx)));
	}
  }
  return max;
}

/* Function:  cm_tophits_Reuse()
 * Synopsis:  Reuse a hit list, freeing internals.
 * Incept:    EPN, Tue May 24 13:36:15 2011
 *            SRE, Fri Jun  6 15:39:05 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Reuse the tophits list <h>; save as
 *            many malloc/free cycles as possible,
 *            as opposed to <Destroy()>'ing it and
 *            <Create>'ing a new one.
 */
int
cm_tophits_Reuse(CM_TOPHITS *h)
{
  int i;

  if (h == NULL) return eslOK;
  if (h->unsrt != NULL)
  {
	  for (i = 0; i < h->N; i++)
	{
	  if (h->unsrt[i].name != NULL) free(h->unsrt[i].name);
	  if (h->unsrt[i].acc  != NULL) free(h->unsrt[i].acc);
	  if (h->unsrt[i].desc != NULL) free(h->unsrt[i].desc);
	  if (h->unsrt[i].ad != NULL)   cm_alidisplay_Destroy(h->unsrt[i].ad);
	}
  }
  h->N         = 0;
  h->is_sorted_by_evalue           = TRUE;  /* because there's no hits */
  h->is_sorted_for_overlap_removal = FALSE; /* actually this is true with 0 hits, but for safety,
			           	     * we don't want multiple sorted_* fields as TRUE */
  h->is_sorted_by_position         = FALSE; /* ditto */

  h->hit[0]    = h->unsrt;
  return eslOK;
}

/* Function:  cm_tophits_Destroy()
 * Synopsis:  Frees a hit list.
 * Incept:    EPN, Tue May 24 13:36:49 2011
 *            SRE, Fri Dec 28 07:33:21 2007 [Janelia] (p7_tophits.c)
 */
void
cm_tophits_Destroy(CM_TOPHITS *h)
{
  int i;
  if (h == NULL) return;
  if (h->hit   != NULL) free(h->hit);
  if (h->unsrt != NULL) {
	for (i = 0; i < h->N; i++) {
	  if (h->unsrt[i].name != NULL) free(h->unsrt[i].name);
	  if (h->unsrt[i].acc  != NULL) free(h->unsrt[i].acc);
	  if (h->unsrt[i].desc != NULL) free(h->unsrt[i].desc);
	  if (h->unsrt[i].ad != NULL)   cm_alidisplay_Destroy(h->unsrt[i].ad);
	}
	free(h->unsrt);
  }
  free(h);
  return;
}

/* Function:  cm_tophits_CloneHitMostly()
 * Synopsis:  Add a new hit to <dest_th>, a clone of hit <h> in <src_th>.
 * Incept:    EPN, Wed May 25 08:17:35 2011
 *
 * Purpose:   Create a new hit in the CM_TOPHITS object <dest_th>
 *            and copy the information from hit <h> in the sorted
 *            hitlist <src_th> into it.
 *
 *            An exception of copying info:
 *            the <hit_idx> for the cloned hit in <dest_th> will
 *            be dest_th->N, not <src_th->hit[h]->hit_idx.
 *
 *            NOTE: we do not copy name, acc, desc, or ad,
 *                  and also note that any_oidx and win_oidx
 *                  of new hit in <dest_th> will be set to -1
 *                  no matter what src_th->h's values are.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation error.
 */
int
cm_tophits_CloneHitMostly(CM_TOPHITS *src_th, int h, CM_TOPHITS *dest_th)
{
  CM_HIT *hit = NULL;
  int     status;

  if ((status = cm_tophits_CreateNextHit(dest_th, &hit)) != eslOK) goto ERROR;
  hit->cm_idx     = src_th->hit[h]->cm_idx;
  hit->clan_idx   = src_th->hit[h]->clan_idx;
  hit->seq_idx    = src_th->hit[h]->seq_idx;
  hit->pass_idx   = src_th->hit[h]->pass_idx;
  /* don't update hit->hit_idx, it will stay as set by CreateNextHit (dest_th->N-1) */
  hit->start      = src_th->hit[h]->start;
  hit->stop       = src_th->hit[h]->stop;
  hit->in_rc      = src_th->hit[h]->in_rc;
  hit->root       = src_th->hit[h]->root;
  hit->mode       = src_th->hit[h]->mode;
  hit->score      = src_th->hit[h]->score;
  hit->bias       = src_th->hit[h]->bias;
  hit->pvalue     = src_th->hit[h]->pvalue;
  hit->evalue     = src_th->hit[h]->evalue;
  hit->has_evalue = src_th->hit[h]->has_evalue;
  hit->srcL       = src_th->hit[h]->srcL;
  hit->hmmonly    = src_th->hit[h]->hmmonly;
  hit->glocal     = src_th->hit[h]->glocal;
  hit->flags      = src_th->hit[h]->flags;
  /* don't update hit->any_oidx, nor hit->win_oidx, they'll stay as -1 */
  hit->any_bitE   = src_th->hit[h]->any_bitE;
  hit->win_bitE   = src_th->hit[h]->win_bitE;
  hit->ad         = NULL;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tophits_ComputeEvalues()
 * Synopsis:  Compute E-values given effective database size.
 * Incept:    EPN, Tue Sep 28 05:26:20 2010
 *
 * Purpose:   After the cm pipeline has completed, the CM_TOPHITS object
 *            contains objects with p-values that haven't yet been
 *            converted to e-values. Compute E-values here based
 *            on the effective database size <eZ>.
 *
 *            Normally the effective database size is calculated based
 *            on the number of expected hits in the database, as determined
 *            for a set database size in cmcalibrate and scaled up for
 *            current database size. However, if the pipeline was run in
 *            HMM only mode we use nhmmer's convention of defining
 *            the effective database size as the total database size
 *            divided by a window length, usually om->max_length.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_ComputeEvalues(CM_TOPHITS *th, double eZ, int istart)
{
  int i;

  for (i = istart; i < th->N ; i++) {
	th->unsrt[i].evalue = th->unsrt[i].pvalue * eZ;
  }
  return eslOK;
}

/* Helper functions for removing overlapping hits from a set of hits
 * that all use the same model, are to the same sequence and are on
 * the same strand. The hits in the set are sorted by score.
 *
 * remove_or_mark_overlaps_one_seq_fast(): O(N) with number of hits N, but
 * less memory efficient (O(L), requiring an allocation of a char
 * array the length of the sequence). This is how RSEARCH and infernal
 * 1.0.2 did overlap removal.
 *
 * remove_or_mark_overlaps_one_seq_memeff(): O(N^2), but O(1) memory (not
 * counting the O(N) memory hit list). This is fast for small numbers
 * of sequences; up to about 10k seqs (10,000 hits takes about ~0.3
 * seconds with benchmark_cm_tophits, but 100,000 hits takes 43s).
 *
 * cm_tophits_RemoveOrMarkOverlaps() picks a function to call based on
 * length of the sequence L and number of hits N.
 *
 * If <do_remove> we'll remove duplicate hits, else we'll just
 * mark them up (this is used by cmscan to mark overlapping hits
 * to different models). If <do_remove> is FALSE, the hits do not
 * need to be to the same model, else they do need to be.
 *
 * Both functions:
 * Returns eslOK on success
 * Returns eslEINVAL if not all hits in the set have equal srcL, seq_idx, in_rc values (and cm_idx if do_remove == TRUE)
 * Returns eslERANGE if a hit includes positions outside of 1..srcL
 * Returns eslEMEM if out of memory (remove_overlaps_one_seq_fast() only)
 * errbuf is filled if not returning eslOK
 */
int remove_or_mark_overlaps_one_seq_fast(CM_TOPHITS *th, int64_t idx1, int64_t idx2, int do_remove, char *errbuf)
{
  int       status;
  int64_t   i;
  char     *covered         = NULL;  /* [1..pos..srcL] is position pos covered by a hit we've examined and kept (if do_remove)? */
  int64_t  *covered_any_idx = NULL;  /* [1..pos..srcL] highest scoring hit_idx that covers position pos */
  int64_t  *covered_win_idx = NULL;  /* [1..pos..srcL] highest scoring *winning* hit_idx that covers position pos */
  int       overlap_flag = FALSE;
  int64_t   srcL    = th->hit[idx1]->srcL;
  int64_t   cm_idx  = th->hit[idx1]->cm_idx;
  int64_t   seq_idx = th->hit[idx1]->seq_idx;
  int       in_rc   = th->hit[idx1]->in_rc;
  int64_t   pos, min, max; /* position indices in the sequence */
  int64_t   max_value = idx2+1; /* default value for covered_any_idx and covered_win_idx, so we can use ESL_MIN with range of valid values idx1..idx2 */

  if(   do_remove  && (! th->is_sorted_for_overlap_removal)) ESL_FAIL(eslEINVAL, errbuf, "removing overlapping hits but hit list is not sorted properly");
  if((! do_remove) && (! th->is_sorted_for_overlap_markup))  ESL_FAIL(eslEINVAL, errbuf, "marking overlapping hits but hit list is not sorted properly");

  /*printf("in remove_or_mark_overlaps_one_seq_fast() do_remove: %d i: %" PRId64 " j: %" PRId64 "\n", do_remove, idx1, idx2);
	cm_tophits_Dump(stdout, th);*/

  ESL_ALLOC(covered, sizeof(char) * (srcL+1));
  for(i = 0; i <= srcL; i++) covered[i] = FALSE;
  if(! do_remove) {
	ESL_ALLOC(covered_any_idx, sizeof(int64_t) * (srcL+1));
	ESL_ALLOC(covered_win_idx, sizeof(int64_t) * (srcL+1));
	for(i = 0; i <= srcL; i++) covered_any_idx[i] = max_value;
	for(i = 0; i <= srcL; i++) covered_win_idx[i] = max_value;
  }

  for(i = idx1; i <= idx2; i++) {
	/* verify that what we think is true is true */
	if(th->hit[i]->srcL    != srcL)                       ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, srcL inconsistent, hit %" PRId64, i);
	if(th->hit[i]->seq_idx != seq_idx)                    ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, seq_idx is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->in_rc   != in_rc)                      ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, in_rc is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->flags & CM_HIT_IS_MARKED_OVERLAP)      ESL_FAIL(eslEINVAL, errbuf, "marking overlapping hits, overlap flag already up for hit %" PRId64 "\n", i);
	if(th->hit[i]->start < 1 || th->hit[i]->start > srcL) ESL_FAIL(eslERANGE, errbuf, "removing/marking overlapping hits, start posn is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->stop  < 1 || th->hit[i]->stop  > srcL) ESL_FAIL(eslERANGE, errbuf, "removing/marking overlapping hits, stop posn is inconsistent, hit %" PRId64, i);

	if(do_remove && th->hit[i]->cm_idx  != cm_idx) ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, cm_idx is inconsistent, hit %" PRId64, i);

	if(! (th->hit[i]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	  /* i is not a duplicate that's already been removed */

	  min = ESL_MIN(th->hit[i]->start, th->hit[i]->stop);
	  max = ESL_MAX(th->hit[i]->start, th->hit[i]->stop);
	  overlap_flag = FALSE;
	  for(pos = min; pos <= max; pos++) {
		if(covered[pos] == TRUE) { overlap_flag = TRUE; break; }
	  }

	  /* how we process the hit differs significantly between
	   * whether we're in remove mode (do_remove is TRUE) or
	   * mark mode (do_remove is FALSE)
	   */
	  if(do_remove) {
		if(overlap_flag) {
		  th->hit[i]->flags |=  CM_HIT_IS_REMOVED_DUPLICATE;
		  th->hit[i]->flags &= ~CM_HIT_IS_REPORTED;  /* could be set if pli->use_bit_cutoffs (--cut_ga, --cut_nc, --cut_tc) */
		  th->hit[i]->flags &= ~CM_HIT_IS_INCLUDED;  /* could be set if pli->use_bit_cutoffs (--cut_ga, --cut_nc, --cut_tc) */
		}
		else {
		  for(pos = min; pos <= max; pos++) covered[pos] = TRUE;
		}
	  }
	  else { /* do_remove is FALSE */
		if(overlap_flag) {
		  /* marking overlaps, not removing them */
		  th->hit[i]->flags |=  CM_HIT_IS_MARKED_OVERLAP;
		  /* determine the hit_idx of the best hit it overlaps with (any_oidx)
		   * and the best non-marked hit it overlaps with (win_oidx),
		   * these will often be the same hit_idx
		   */
		  /* first, the best hit (any_oidx) */
		  th->hit[i]->any_oidx = covered_any_idx[min];
		  for(pos = min+1; pos <= max; pos++) {
			th->hit[i]->any_oidx = ESL_MIN(th->hit[i]->any_oidx, covered_any_idx[pos]);
		  }
		  if(th->hit[i]->any_oidx == max_value) th->hit[i]->any_oidx = -1; /* no overlap */

		  /* second, the best winning hit (win_oidx) */
		  th->hit[i]->win_oidx = covered_win_idx[min];
		  for(pos = min+1; pos <= max; pos++) {
			th->hit[i]->win_oidx = ESL_MIN(th->hit[i]->win_oidx, covered_win_idx[pos]);
		  }
		  if(th->hit[i]->win_oidx == max_value) th->hit[i]->win_oidx = -1; /* no overlap */

		  /* now th->hit[i]->any_oidx and th->hit[i]->win_oidx point to
		   * the sorted hit index, change it to the actual hit_idx
		   */
		  if(th->hit[i]->any_oidx != -1) th->hit[i]->any_oidx = th->hit[th->hit[i]->any_oidx]->hit_idx;
		  if(th->hit[i]->win_oidx != -1) th->hit[i]->win_oidx = th->hit[th->hit[i]->win_oidx]->hit_idx;
		} /* end of 'if(overlap_flag)' */
		else { /* no overlap */
		  /* need to keep track that this hit is the best scoring winning hit
		   * that covers any previously uncovered positions
		   */
		  for(pos = min; pos <= max; pos++) {
			if(covered_win_idx[pos] == max_value) covered_win_idx[pos] = i;
		  }
		}
		/* regardless of whether we found an overlap or not, we need
		 * to keep track that this hit is the best scoring hit that
		 * covers any previously uncovered positions, and update
		 * covered[] as well.
		 */
		for(pos = min; pos <= max; pos++) {
		  if(covered_any_idx[pos] == max_value) covered_any_idx[pos] = i;
		  covered[pos] = TRUE;
		}
	  }
	}
  }

  if(covered         != NULL) free(covered);
  if(covered_any_idx != NULL) free(covered_any_idx);
  if(covered_win_idx != NULL) free(covered_win_idx);
  return eslOK;

 ERROR:
  if(covered != NULL) free(covered);
  ESL_FAIL(status, errbuf, "removing/marking overlapping hits, out of memory");
  return status; /* NOT REACHED */
}

int remove_or_mark_overlaps_one_seq_memeff(CM_TOPHITS *th, int64_t idx1, int64_t idx2, int do_remove, char *errbuf)
{
  int64_t i, j;
  int64_t srcL    = th->hit[idx1]->srcL;
  int64_t cm_idx  = th->hit[idx1]->cm_idx;
  int64_t seq_idx = th->hit[idx1]->seq_idx;
  int     in_rc   = th->hit[idx1]->in_rc;
  int     overlap_flag = FALSE;

  /*printf("in remove_overlaps_one_seq_memeff() do_remove: %d i: %" PRId64 " j: %" PRId64 "\n", do_remove, idx1, idx2);
	cm_tophits_Dump(stdout, th);*/
  if(   do_remove  && (! th->is_sorted_for_overlap_removal)) ESL_FAIL(eslEINVAL, errbuf, "removing overlapping hits but hit list is not sorted properly");
  if((! do_remove) && (! th->is_sorted_for_overlap_markup))  ESL_FAIL(eslEINVAL, errbuf, "marking overlapping hits but hit list is not sorted properly");

  for(i = idx1; i <= idx2; i++) {
	/* verify that what we think is true is true */
	if(th->hit[i]->srcL    != srcL)                       ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, srcL inconsistent, hit %" PRId64, i);
	if(th->hit[i]->seq_idx != seq_idx)                    ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, seq_idx is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->in_rc   != in_rc)                      ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, in_rc is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->start < 1 || th->hit[i]->start > srcL) ESL_FAIL(eslERANGE, errbuf, "removing/marking overlapping hits, start posn is inconsistent, hit %" PRId64, i);
	if(th->hit[i]->stop  < 1 || th->hit[i]->stop  > srcL) ESL_FAIL(eslERANGE, errbuf, "removing/marking overlapping hits, stop posn is inconsistent, hit %" PRId64, i);
	if(do_remove && th->hit[i]->cm_idx  != cm_idx)        ESL_FAIL(eslEINVAL, errbuf, "removing/marking overlapping hits, cm_idx is inconsistent, hit %" PRId64, i);

	if(! (th->hit[i]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	  /* i is not a duplicate that's already been removed */
	  for(j = i+1; j <= idx2; j++) {
		if(! (th->hit[j]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
		  /* j has not already been removed */
		  overlap_flag = FALSE; /* set to TRUE below if i and j overlap */
		  /*printf("comparing %" PRId64 " and %" PRId64 "\n", i, j);*/
		  if(th->hit[j]->in_rc == FALSE &&                 /* both i and j are on forward strand */
			 (! (th->hit[j]->stop < th->hit[i]->start)) && /* one of two ways in which i and j DO NOT overlap */
			 (! (th->hit[i]->stop < th->hit[j]->start))) { /* the other way   in which i and j DO NOT overlap */
			/* i and j overlap, i is better scoring so remove/mark j */
			overlap_flag = TRUE;
		  }
		  else if(th->hit[j]->in_rc == TRUE &&                  /* both i and j are on reverse strand */
				  (! (th->hit[j]->start < th->hit[i]->stop)) && /* one of two ways in which i and j DO NOT overlap */
				  (! (th->hit[i]->start < th->hit[j]->stop))) { /* the other way   in which i and j DO NOT overlap */
			/* i and j overlap, i is better scoring so remove or mark j */
			overlap_flag = TRUE;
		  }
		  if(overlap_flag) {
			if(do_remove) {
			  th->hit[j]->flags |=  CM_HIT_IS_REMOVED_DUPLICATE;
			  th->hit[j]->flags &= ~CM_HIT_IS_REPORTED;  /* could be set if pli->use_bit_cutoffs (--cut_ga, --cut_nc, --cut_tc) */
			  th->hit[j]->flags &= ~CM_HIT_IS_INCLUDED;  /* could be set if pli->use_bit_cutoffs (--cut_ga, --cut_nc, --cut_tc) */
			  /*printf("\tremoved j (FWD) %5" PRId64 "..%5" PRId64 " overlaps with %5" PRId64 "..%5" PRId64 "\n", th->hit[i]->start, th->hit[i]->stop, th->hit[j]->start, th->hit[j]->stop);*/
			}
			else {
			  th->hit[j]->flags |=  CM_HIT_IS_MARKED_OVERLAP;
			  /* don't change reported/included flags */

			  /* update any_oidx and win_oidx */
			  if(th->hit[j]->any_oidx == -1) th->hit[j]->any_oidx = th->hit[i]->hit_idx;
			  /* if j's any_oidx or win_oidx is not -1, it must have
			   * already been set to a better hit, i.e. a lower i
			   * (and since we're sorted by score we know that's a
			   * better hit).
			   */
			  if((! (th->hit[i]->flags & CM_HIT_IS_MARKED_OVERLAP)) &&
				 (th->hit[j]->win_oidx == -1)) {
				th->hit[j]->win_oidx = th->hit[i]->hit_idx;
			  }
			}
		  }
		}
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_tophits_RemoveOrMarkOverlaps()
 * Synopsis:  Remove or mark overlapping hits from a tophits object sorted by seq_idx.
 * Incept:    EPN, Tue Jun 14 05:42:31 2011
 *
 * Purpose:   After the CM pipeline has completed, the CM_TOPHITS
 *            object may contain overlapping hits if the target was
 *            broken into overlapping windows. Scan through the
 *            tophits object, which, upon entering, is sorted by cm
 *            index, sequence index, strand, and score and remove hits
 *            greedily. For each hit for the same model, sequence and
 *            strand, remove all lower scoring hits that overlap with
 *            it. This is done by one of two helper functions
 *            (remove_or_mark_overlaps_one_seq_fast() or
 *            remove_or_mark_overlaps_one_seq_memeff() described near
 *            their definition above) depending on the length of the
 *            sequence and the number of hits.
 *
 *            This function can be used to either mark overlaps or
 *            remove them, determined by the
 *            th->is_sorted_for_overlap_removal and
 *            th->is_sorted_for_overlap_markup flags, exactly one
 *            of which must be true, otherwise we'll die.
 *
 *            <do_clans_only>: TRUE to only markup overlaps for hits in
 *            the same clan, FALSE to markup overlaps between all
 *            hits. IRRELEVANT if th->is_sorted_for_overlap_removal.
 *
 * Returns:   eslOK on success.
 *            eslEINVAL if th is not sorted appropriately, errbuf filled
 *            eslERANGE if a hit includes positions outside of 1..srcL, errbuf filled
 *            eslEMEM if we run out of memory, errbuf filled
 */
int
cm_tophits_RemoveOrMarkOverlaps(CM_TOPHITS *th, int do_clans_only, char *errbuf)
{
  int status;
  int64_t i, j;
  int64_t nhits  = 0;
  int do_remove = FALSE;
  int srcL_limit;

  if (th->is_sorted_for_overlap_removal &&
	  th->is_sorted_for_overlap_markup) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_tophits_RemoveOrMarkOverlaps() list is not sorted appropriately");
  }

  if (th->is_sorted_for_overlap_removal) {
	do_remove = TRUE;
	srcL_limit = 256000000;
  }
  else if (th->is_sorted_for_overlap_markup) {
	do_remove = FALSE;
	srcL_limit = 256000000 / 16;
	/* we require about 16X more memory in remove_or_mark_overlaps_one_seq_fast() if we're sorting for
	 * overlap markup, so our limit is 1/16 the length.
	 */
  }
  else {
	ESL_FAIL(eslEINVAL, errbuf, "cm_tophits_RemoveOrMarkOverlaps() list is not sorted appropriately");
  }
  if(do_remove && do_clans_only) {
	ESL_FAIL(eslEINVAL, errbuf, "cm_tophits_RemoveOrMarkOverlaps() list is sorted for overlap removal and we're trying to respect clan membership...shouldn't happen");
  }

  if (th->N<2) return eslOK;

  i = 0;
  while(i < th->N) {
	j = i+1;
	while(j < th->N &&
	  ((! do_remove) || (th->hit[j]->cm_idx  == th->hit[i]->cm_idx))  &&
	  th->hit[j]->seq_idx == th->hit[i]->seq_idx &&
	  th->hit[j]->in_rc   == th->hit[i]->in_rc   &&
	  ((! do_clans_only) || (th->hit[j]->clan_idx == th->hit[i]->clan_idx))) {
	  j++;
	}
	if(j != (i+1) &&                                         /* more than one hit in set i..j-1 */
	   ((! do_clans_only) || th->hit[i]->clan_idx != -1)) {  /* we're not only marking overlaps within same clan OR
															  * we are and all hits are in same clan, this way if
															  * do_clans_only is TRUE we won't remove overlaps between
															  * hits in families that are not members of any clan */
	  /* Hits i to j-1 form a set of hits that all share cm_idx (if
	   * 'do_remove == TRUE'), seq_idx, in_rc and clan_idx (if
	   * 'do_clans_only == TRUE'). Remove overlaps from this set in 1 of 2
	   * ways, depending on length of source sequence and number of
	   * hits.  remove_overlaps_one_seq_fast() will need to allocate a
	   * char array of size srcL, but it is significantly faster when
	   * nhits is big. If (do_remove) is FALSE then we need about 16X
	   * more memory in 'one_seq_fast()' method so our srcL_limit is
	   * 16-fold lower (calc'ed above).
	   */
	  nhits = (j-1)-i+1;
	  if(nhits < 5000 || th->hit[i]->srcL > srcL_limit) {
		if((status = remove_or_mark_overlaps_one_seq_memeff(th, i, j-1, do_remove, errbuf)) != eslOK) return status;
	  }
	  else { /* use fast, non mem-efficient way if >= 5000 hits and L is < srcL_limit */
		if((status = remove_or_mark_overlaps_one_seq_fast  (th, i, j-1, do_remove, errbuf)) != eslOK) return status;
	  }
	}
	i = j; /* skip ahead to begin next set */
  }
  /*printf("Leaving cm_tophits_RemoveOverlaps()\n");
	cm_tophits_Dump(stdout, th);*/

  return eslOK;
}

/* Function:  cm_tophits_UpdateHitPositions()
 * Synopsis:  Update sequence positions in a hit list.
 * Incept:    EPN, Wed May 25 09:12:52 2011
 *
 * Purpose: For hits <hit_start..th->N-1> in a hit list, update the
 *          positions of start, stop, ad->sqto and ad->sqfrom.  This
 *          is necessary when we've searched a chunk of subsequence
 *          that originated somewhere within a larger sequence.
 *
 *
 * Returns: <eslOK> on success.
 */
 int
 cm_tophits_UpdateHitPositions(CM_TOPHITS *th, int hit_start, int64_t seq_start, int in_revcomp)
{
  int i;
  if(in_revcomp) {
	for (i = hit_start; i < th->N ; i++) {
	  th->unsrt[i].start = seq_start - th->unsrt[i].start + 1;
	  th->unsrt[i].stop  = seq_start - th->unsrt[i].stop  + 1;
	  th->unsrt[i].in_rc = TRUE;
	  if(th->unsrt[i].ad != NULL) {
	th->unsrt[i].ad->sqfrom = seq_start - th->unsrt[i].ad->sqfrom + 1;
	th->unsrt[i].ad->sqto   = seq_start - th->unsrt[i].ad->sqto + 1;
	  }
	}

  }
  else {
	for (i = hit_start; i < th->N ; i++) {
	  th->unsrt[i].start += seq_start-1;
	  th->unsrt[i].stop  += seq_start-1;
	  th->unsrt[i].in_rc = FALSE;
	  if(th->unsrt[i].ad != NULL) {
	th->unsrt[i].ad->sqfrom += seq_start-1;
	th->unsrt[i].ad->sqto   += seq_start-1;
	  }
	}
  }
  return eslOK;
}

/* Function:  cm_tophits_SetSourceLengths()
 * Synopsis:  Update hit->srcL for all hits in a hitlist.
 * Incept:    EPN, Wed Nov 23 14:57:53 2011
 *
 * Purpose: For all hits in a hitlist, set the
 *          srcL value (full length of source sequence the hit originated
 *          in) given an array of <nseqs> source lengths indexed by seq_idx.
 *
 * Returns: <eslOK> on success.
 *          <eslEINVAL> if hit->seq_idx >= nseqs (we have a hit to a sequence
 *          we don't know the length of - something went wrong)
 */
 int
 cm_tophits_SetSourceLengths(CM_TOPHITS *th, int64_t *srcL, uint64_t nseqs)
{
  int i;
  for (i = 0; i < th->N ; i++) {
	if(th->unsrt[i].seq_idx >= nseqs) return eslEINVAL;
	th->unsrt[i].srcL = srcL[th->unsrt[i].seq_idx];
  }

  return eslOK;
}

/*---------------- end, CM_TOPHITS object -----------------------*/

/*****************************************************************
 * 2. Standard (human-readable) output of pipeline results
 *****************************************************************/

/* Function:  cm_tophits_Threshold()
 * Synopsis:  Apply score and E-value thresholds to a hitlist before output.
 * Incept:    EPN, Tue May 24 13:44:13 2011
 *            SRE, Tue Dec  9 09:04:55 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   After a pipeline has completed, go through it and mark all
 *            the targets and domains that are "significant" (satisfying
 *            the reporting thresholds set for the pipeline).
 *
 *            Also sets the final total number of reported and
 *            included targets, the number of reported and included
 *            targets in each target, and the size of the search space
 *            for per-domain conditional E-value calculations,
 *            <pli->domZ>. By default, <pli->domZ> is the number of
 *            significant targets reported.
 *
 *            If model-specific thresholds were used in the pipeline,
 *            we cannot apply those thresholds now. They were already
 *            applied in the pipeline. In this case all we're
 *            responsible for here is counting them (setting
 *            nreported, nincluded counters).
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_Threshold(CM_TOPHITS *th, CM_PIPELINE *pli)
{
  int h;   /* counter */

  /* Flag reported, included targets (if we're using general thresholds) */
  if (! pli->use_bit_cutoffs) {
	for (h = 0; h < th->N; h++) {
	  if (! (th->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	if (cm_pli_TargetReportable(pli, th->hit[h]->score, th->hit[h]->evalue)) {
	  th->hit[h]->flags |= CM_HIT_IS_REPORTED;
	  if (cm_pli_TargetIncludable(pli, th->hit[h]->score, th->hit[h]->evalue))
	    th->hit[h]->flags |= CM_HIT_IS_INCLUDED;
	}
	  }
	}
  }

  /* Count reported, included targets */
  th->nreported = 0;
  th->nincluded = 0;
  for (h = 0; h < th->N; h++) {
	if (! (th->hit[h]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	  if (th->hit[h]->flags & CM_HIT_IS_REPORTED)  th->nreported++;
	  if (th->hit[h]->flags & CM_HIT_IS_INCLUDED)  th->nincluded++;
	}
  }

  return eslOK;
}

/* Function:  cm_tophits_Targets()
 * Synopsis:  Standard output format for a top target hits list.
 * Incept:    EPN, Tue May 24 13:48:29 2011
 *            SRE, Tue Dec  9 09:10:43 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Output a list of the reportable top target hits in <th>
 *            in human-readable ASCII text format to stream <ofp>, using
 *            final pipeline accounting stored in <pli>.
 *
 *            Hits must have a valid alignment display in order
 *            to determine if they're truncated or not.
 *
 *            The tophits list <th> should already be sorted (see
 *            <cm_tophits_Sort()> and thresholded (see
 *            <cm_tophits_Threshold>).
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_Targets(FILE *ofp, CM_TOPHITS *th, CM_PIPELINE *pli, int textw)
{
  int    status;
  int    h,i;
  int    namew;
  int    posw;
  int    descw;
  int    rankw;
  char  *showname;
  int    have_printed_incthresh = FALSE;
  int    nprinted = 0;

  char *namestr     = NULL;
  char *posstr      = NULL;
  char *rankstr     = NULL;
  char *cur_rankstr = NULL;

  /* when --acc is on, we'll show accession if available, and fall back to name */
  if (pli->show_accessions) namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 8 : 9), cm_tophits_GetMaxShownLength(th));
  else                      namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 8 : 9), cm_tophits_GetMaxNameLength(th));

  posw = ESL_MAX(6, cm_tophits_GetMaxPositionLength(th));

  if (textw >  0) descw = ESL_MAX(32, textw - namew - (2*posw) - 31); /* 31 chars excluding desc is from the format: 1 + 2 + 9+2(E-value) + 6+2(score) + 1+2(strand) + 2+2+2+2(spacing) */
  else            descw = 0;                                          /* unlimited desc length is handled separately */

  rankw = ESL_MAX(4, (integer_textwidth(th->nreported)+2));

  ESL_ALLOC(namestr,     sizeof(char) * (namew+1));
  ESL_ALLOC(posstr,      sizeof(char) * (posw+1));
  ESL_ALLOC(rankstr,     sizeof(char) * (rankw+1));
  ESL_ALLOC(cur_rankstr, sizeof(char) * (rankw+1));

  for(i = 0; i < namew; i++) { namestr[i] = '-'; } namestr[namew] = '\0';
  for(i = 0; i < posw;  i++) { posstr[i]  = '-'; } posstr[posw]   = '\0';
  for(i = 0; i < rankw; i++) { rankstr[i] = '-'; } rankstr[rankw] = '\0';
  cur_rankstr[rankw] = '\0';

  fprintf(ofp, "Hit scores:\n");
  fprintf(ofp, " %*s %1s %9s %6s %5s  %-*s %*s %*s %1s %3s %5s %4s  %s\n", rankw, "rank",  "", "E-value",   " score", " bias", namew, (pli->mode == CM_SEARCH_SEQS ? "sequence":"modelname"), posw, "start", posw, "end", "", "mdl", "trunc", "gc", "description");
  fprintf(ofp, " %*s %1s %9s %6s %5s  %-*s %*s %*s %1s %3s %5s %4s  %s\n", rankw, rankstr, "", "---------", "------", "-----", namew, namestr, posw, posstr, posw, posstr, "", "---", "-----", "----", "-----------");

  nprinted = 0;
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_REPORTED) {

	  if (! (th->hit[h]->flags & CM_HIT_IS_INCLUDED) && ! have_printed_incthresh) {
	fprintf(ofp, " ------ inclusion threshold ------\n");
	have_printed_incthresh = TRUE;
	  }

	  if (pli->show_accessions) {
	/* the --acc option: report accessions rather than names if possible */
	if (th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') showname = th->hit[h]->acc;
	else                                                       showname = th->hit[h]->name;
	  }
	  else {
	showname = th->hit[h]->name;
	  }

	  sprintf(cur_rankstr, "(%d)", nprinted+1);

	  fprintf(ofp, " %*s %c %9.2g %6.1f %5.1f  %-*s %*" PRId64 " %*" PRId64 " %c %3s %5s %4.2f  ",
	      rankw, cur_rankstr,
	      (th->hit[h]->flags & CM_HIT_IS_INCLUDED ? '!' : '?'),
	      th->hit[h]->evalue,
	      th->hit[h]->score,
	      th->hit[h]->bias,
	      namew, showname,
	      posw, th->hit[h]->start,
	      posw, th->hit[h]->stop,
	      (th->hit[h]->in_rc == TRUE) ? '-' : '+',
	      th->hit[h]->hmmonly ? "hmm" : "cm",
	      cm_alidisplay_TruncString(th->hit[h]->ad),
	      th->hit[h]->ad->gc);

	  if (textw > 0) fprintf(ofp, "%-.*s\n", descw, th->hit[h]->desc == NULL ? "-" : th->hit[h]->desc);
	  else           fprintf(ofp, "%s\n",           th->hit[h]->desc == NULL ? "-" : th->hit[h]->desc);
	  /* do NOT use *s with unlimited (INT_MAX) line length. Some systems
	   * have an fprintf() bug here (we found one on an Opteron/SUSE Linux
	   * system (#h66))
	   */
	  nprinted++;
	}
  }
  if (th->nreported == 0) fprintf(ofp, "\n   [No hits detected that satisfy reporting thresholds]\n");

  if(namestr     != NULL) free(namestr);
  if(posstr      != NULL) free(posstr);
  if(rankstr     != NULL) free(rankstr);
  if(cur_rankstr != NULL) free(cur_rankstr);

  return eslOK;

 ERROR:
  if(namestr != NULL) free(namestr);
  if(posstr  != NULL) free(posstr);

  return status;
}

/* Function:  cm_tophits_F3Targets()
 * Synopsis:  Standard output format for a top target hits list
 *            in special terminate after filter stage F3 mode.
 *
 * Incept:    EPN, Wed Oct 22 13:29:23 2014
 *            SRE, Tue Dec  9 09:10:43 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Output a list of the reportable top target hits in <th>
 *            in human-readable ASCII text format to stream <ofp>, using
 *            final pipeline accounting stored in <pli>. This version
 *            is similar to cm_tophits_Targets() but reports a different
 *            set of fields.
 *
 *            The tophits list <th> should already be sorted (see
 *            <cm_tophits_Sort()> and thresholded (see
 *            <cm_tophits_Threshold>).
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_F3Targets(FILE *ofp, CM_TOPHITS *th, CM_PIPELINE *pli)
{
  int    status;
  int    h,i;
  int    namew;
  int    posw;
  int    descw;
  char  *showname;
  int    nprinted = 0;
  char   lseq, rseq;

  char *namestr     = NULL;
  char *descstr     = NULL;
  char *posstr      = NULL;

  /* when --acc is on, we'll show accession if available, and fall back to name */
  if (pli->show_accessions) namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 8 : 9), cm_tophits_GetMaxShownLength(th));
  else                      namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 8 : 9), cm_tophits_GetMaxNameLength(th));
  descw = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 9 : 8), cm_tophits_GetMaxDescLength(th));
  posw  = ESL_MAX(6, cm_tophits_GetMaxPositionLength(th));

  ESL_ALLOC(namestr, sizeof(char) * (namew+1));
  ESL_ALLOC(descstr, sizeof(char) * (descw+1));
  ESL_ALLOC(posstr,  sizeof(char) * (posw+1));

  for(i = 0; i < namew; i++) { namestr[i] = '-'; } namestr[namew] = '\0';
  for(i = 0; i < descw; i++) { descstr[i] = '-'; } descstr[descw] = '\0';
  for(i = 0; i < posw;  i++) { posstr[i]  = '-'; } posstr[posw]   = '\0';

  fprintf(ofp, "Windows that survived F3 filter stage:\n");
  fprintf(ofp, " %1s %-*s %-*s %6s %*s %*s\n", "", namew, (pli->mode == CM_SEARCH_SEQS) ? "sequence" : "modelname", descw, (pli->mode == CM_SEARCH_SEQS) ? "modelname" : "sequence", " score", posw, "start", posw, "end");
  fprintf(ofp, " %1s %*s %*s %6s %*s %*s\n", "", namew, namestr, descw, descstr, "------", posw, posstr, posw, posstr);

  nprinted = 0;
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_REPORTED) {

	  if (pli->show_accessions) {
	/* the --acc option: report accessions rather than names if possible */
	if (th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') showname = th->hit[h]->acc;
	else                                                       showname = th->hit[h]->name;
	  }
	  else {
	showname = th->hit[h]->name;
	  }
	  if(th->hit[h]->in_rc) {
		lseq = th->hit[h]->start == th->hit[h]->srcL ? '[' : '.';
		rseq = th->hit[h]->stop  == 1                ? ']' : '.';
	  }
	  else {
		lseq = th->hit[h]->start == 1                ? '[' : '.';
		rseq = th->hit[h]->stop  == th->hit[h]->srcL ? ']' : '.';
	  }

	  fprintf(ofp, " %c %-*s %-*s %6.1f %*" PRId64 " %*" PRId64 " %c %c%c\n",
	      (th->hit[h]->flags & CM_HIT_IS_INCLUDED ? '!' : '?'),
	      namew, showname,
	      descw, th->hit[h]->desc,
	      th->hit[h]->score,
	      posw, th->hit[h]->start,
	      posw, th->hit[h]->stop,
	      (th->hit[h]->in_rc == TRUE) ? '-' : '+',
	      lseq, rseq);
	  nprinted++;
	}
  }
  if (th->nreported == 0) fprintf(ofp, "\n   [No hits detected that satisfy reporting thresholds]\n");

  if(namestr != NULL) free(namestr);
  if(descstr != NULL) free(descstr);
  if(posstr  != NULL) free(posstr);

  return eslOK;

 ERROR:
  if(namestr != NULL) free(namestr);
  if(descstr != NULL) free(descstr);
  if(posstr  != NULL) free(posstr);

  return status;
}

/* Function:  cm_tophits_HitAlignments()
 * Synopsis:  Standard output format for alignments.
 * Incept:    EPN, Tue May 24 13:50:53 2011
 *            SRE, Tue Dec  9 09:32:32 2008 [Janelia] (p7_tophits.c::p7_tophits_Domains())
 *
 * Purpose:   For each reportable target sequence, output a tabular summary
 *            of each hit followed by its alignment.
 *
 *            Similar to <cm_tophits_Targets()>; see additional notes there.
 */
int
cm_tophits_HitAlignments(FILE *ofp, CM_TOPHITS *th, CM_PIPELINE *pli, int textw)
{
  int status;
  int h, i, nprinted;
  int namew, descw, rankw;
  char *showname;
  char *rankstr     = NULL;
  char *cur_rankstr = NULL;

  /* next 4 characters indicate whether alignment ends internal to model/sequence
   * and if it is in a truncated alignment mode. */
  char lmod;
  char rmod;
  char lseq;
  char rseq;

  rankw = ESL_MAX(4, (integer_textwidth(th->nreported)+2));
  ESL_ALLOC(rankstr,     sizeof(char) * (rankw+1));
  ESL_ALLOC(cur_rankstr, sizeof(char) * (rankw+1));
  for(i = 0; i < rankw; i++) { rankstr[i] = '-'; } rankstr[rankw] = '\0';
  cur_rankstr[rankw] = '\0';

  fprintf(ofp, "Hit alignments:\n");

  nprinted = 0;
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_REPORTED) {
	  if (pli->show_accessions && th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') {
	showname = th->hit[h]->acc;
	namew    = strlen(th->hit[h]->acc);
	  }
	  else {
	showname = th->hit[h]->name;
	namew = strlen(th->hit[h]->name);
	  }

	  if (textw > 0) {
	descw = ESL_MAX(32, textw - namew - 5);
	fprintf(ofp, ">> %s  %-.*s\n", showname, descw, (th->hit[h]->desc == NULL ? "" : th->hit[h]->desc));
	  }
	  else {
	fprintf(ofp, ">> %s  %s\n",    showname,        (th->hit[h]->desc == NULL ? "" : th->hit[h]->desc));
	  }

	  /* The hit info display is 97+rankw char wide:, where rankw is the maximum of 4 and 2 plus the number of digits in th->N.
	   * If (pli->be_verbose), the width grows by 58 chars.
	   *
	   *     rank     E-value  score  bias mdl mdl from   mdl to       seq from      seq to       acc trunc   gc| bands     tau   mx Mb seconds pass cfg mdllen      seqlen
	   *     ----   --------- ------ ----- --- -------- --------    ----------- -----------      ---- ----- ----|------ ------- ------- ------- ---- --- ------ -----------
	   *      (1) !    6.8e-9  123.4   0.3  cm        3       72 []         412         492 + .. 0.98    no 0.48|   hmm    5e-6    1.30    0.04    1 loc 123456 12345678901
	   *     (12) ?    1.8e-3  123.4  12.7 hmm        1       72 []         180         103 - .. 0.90    no 0.60|   hmm    0.01    0.65    2.23    3 glb     71     1000000
	   *    rankw 1 123456789 123456 12345 123 12345678 12345678 12 12345678901 12345678901 1 12 1234 12345 1234| 12345 1234567 1234567 1234567 1234 123 123456 12345789012
	   *        0         1        2        3         4         5         6         7         8        9        | 10        11        12        13        14        15
	   *        01234567890123456789012345678901234567890123456789012345678901234567890123456789012345789012345678901234567890123456789012345678901234567890123456789012345
	   *                                                                                                        |-> only shown if pli->be_verbose
	   * In rare cases, when CYK alignment is chosen or when computing
	   * posteriors is not feasible in allowable memory, the "acc"
	   * column will be replaced by a "cyksc" colum which is 6
	   * characters wide instead of 4.
	   */

	  fprintf(ofp, " %*s %1s %9s %6s %5s %-3s %8s %8s %2s %11s %11s %1s %2s",  rankw, "rank", "", "E-value", "score", "bias", "mdl", "mdl from", "mdl to", "", "seq from", "seq to", "", "");
	  if(th->hit[h]->ad->ppline) { fprintf(ofp, " %4s %5s %4s", "acc",   "trunc", "gc"); }
	  else                       { fprintf(ofp, " %6s %5s %4s", "cyksc", "trunc", "gc"); }
	  if(pli->be_verbose)        { fprintf(ofp, " %5s %7s %7s %7s %4s %3s %6s %11s", "bands", "tau", "mx Mb", "seconds", "pass", "cfg", "mdllen", "seqlen"); }
	  fprintf(ofp, "\n");

	  fprintf(ofp, " %*s %1s %9s %6s %5s %-3s %8s %8s %2s %11s %11s %1s %2s",  rankw, rankstr,  "", "---------", "------", "-----", "---", "--------", "--------", "", "-----------", "-----------", "", "");
	  if(th->hit[h]->ad->ppline) { fprintf(ofp, " %4s %5s %4s", "----",   "-----", "----"); }
	  else                       { fprintf(ofp, " %6s %5s %4s", "------", "-----", "----"); }
	  if(pli->be_verbose)        { fprintf(ofp, " %5s %7s %7s %7s %4s %3s %6s %11s", "-----", "-------", "-------", "-------", "----", "---", "------", "-----------"); }
	  fprintf(ofp, "\n");

	  if(cm_alidisplay_Is5PTrunc(th->hit[h]->ad)) { /* 5' truncated */
	lmod = '~';
	lseq = '~';
	  }
	  else { /* not 5' truncated */
	lmod = th->hit[h]->ad->cfrom_emit == 1 ? '[' : '.';
	if(th->hit[h]->in_rc) { lseq = th->hit[h]->ad->sqfrom == th->hit[h]->srcL ? '[' : '.'; }
	else                  { lseq = th->hit[h]->ad->sqfrom == 1                ? '[' : '.'; }
	  }
	  if(cm_alidisplay_Is3PTrunc(th->hit[h]->ad)) { /* 3' truncated */
	rmod = '~';
	rseq = '~';
	  }
	  else { /* not 3' truncated */
	rmod = th->hit[h]->ad->cto_emit == th->hit[h]->ad->clen ? ']' : '.';
	if(th->hit[h]->in_rc) { rseq = th->hit[h]->ad->sqto == 1                ? ']' : '.'; }
	else                  { rseq = th->hit[h]->ad->sqto == th->hit[h]->srcL ? ']' : '.'; }
	  }

	  sprintf(cur_rankstr, "(%d)", nprinted+1);

	  fprintf(ofp, " %*s %c %9.2g %6.1f %5.1f %3s %8d %8d %c%c %11" PRId64 " %11" PRId64 " %c %c%c",
	      rankw, cur_rankstr,
	      (th->hit[h]->flags & CM_HIT_IS_INCLUDED ? '!' : '?'),
	      th->hit[h]->evalue,
	      th->hit[h]->score,
	      th->hit[h]->bias,
	      th->hit[h]->hmmonly ? "hmm" : "cm",
	      th->hit[h]->ad->cfrom_emit,
	      th->hit[h]->ad->cto_emit,
	      lmod, rmod,
	      th->hit[h]->start,
	      th->hit[h]->stop,
	      (th->hit[h]->in_rc == TRUE) ? '-' : '+',
	      lseq, rseq);
	  if(th->hit[h]->ad->ppline) { fprintf(ofp, " %4.2f %5s %4.2f", th->hit[h]->ad->avgpp, cm_alidisplay_TruncString(th->hit[h]->ad), th->hit[h]->ad->gc); }
	  else                       { fprintf(ofp, " %6.1f %5s %4.2f", th->hit[h]->ad->sc,    cm_alidisplay_TruncString(th->hit[h]->ad), th->hit[h]->ad->gc); }
	  if(pli->be_verbose) {
	if(th->hit[h]->ad->tau > -0.5) { /* tau is -1. if aln did not use HMM bands */
	  fprintf(ofp, " %5s %7.2g", "hmm", th->hit[h]->ad->tau);
	}
	else {
	  fprintf(ofp, " %5s %7s", (pli->final_cm_search_opts & CM_SEARCH_QDB) ? "qdb" : "no", "-");
	}
	fprintf(ofp, " %7.2f %7.2f %4d %3s %6d %11" PRId64 "",
		th->hit[h]->ad->matrix_Mb,
		th->hit[h]->ad->elapsed_secs,
		th->hit[h]->pass_idx,
		th->hit[h]->glocal ? "glb" : "loc",
		th->hit[h]->ad->clen,
		th->hit[h]->srcL);
	  }
	  fputs("\n\n", ofp);

	  /*cm_alidisplay_Dump(ofp, th->hit[h]->ad);*/
	  cm_alidisplay_Print(ofp, th->hit[h]->ad, 40, textw, pli->show_accessions);
	  fputs("\n", ofp);
	  nprinted++;
	}
  }
  if (th->nreported == 0) {
	fprintf(ofp, "\n   [No hits detected that satisfy reporting thresholds]\n");
  }

  if(rankstr     != NULL) free(rankstr);
  if(cur_rankstr != NULL) free(cur_rankstr);
  return eslOK;

ERROR:
  if(rankstr     != NULL) free(rankstr);
  if(cur_rankstr != NULL) free(cur_rankstr);
  return status;

}

/* Function:  cm_tophits_HitAlignmentStatistics()
 * Synopsis:  Final alignment statistics output from a list of hits.
 * Incept:    EPN, Thu Jun 16 04:22:11 2011
 *
 * Purpose:   Print summary statistics on alignments performed
 *            for all hits in tophits object <th> to stream <ofp>.
 *            Statistics are compiled and reported for all hits,
 *            as well as for reported, included and removed duplicate
 *            hits independently.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_HitAlignmentStatistics(FILE *ofp, CM_TOPHITS *th, int used_hb, int used_cyk, double default_tau)
{
  uint64_t h;
  int is_reported;
  int is_included;
  int is_removed_duplicate;
  /*int is_marked_duplicate;*/ /* not used, currently */

  /* variables for alignments for all hits */
  int64_t all_naln = 0;                        /* total number alignments */
  int64_t all_noverflow_hb = 0;                /* # HMM banded alns PPs couldn't be calc'ed for due to mx size */
  int64_t all_ntau_mod_hb = 0;                 /* # HMM banded alns for which was increased due to mx size */
  double  all_tot_matrix_Mb = 0.;              /* summed Mb req'd for matrices used for alignments */
  double  all_min_matrix_Mb = eslINFINITY;     /* min Mb req'd over all alns */
  double  all_max_matrix_Mb = 0.;              /* max Mb req'd over all alns */
  double  all_avg_matrix_Mb = 0.;              /* avg Mb req'd over all alns */
  double  all_tot_elapsed_secs = 0.;           /* summed seconds for alignments */
  double  all_min_elapsed_secs = eslINFINITY;  /* min seconds over all alns */
  double  all_max_elapsed_secs = 0.;           /* max seconds over all alns */
  double  all_avg_elapsed_secs = 0.;           /* avg seconds over all alns */

  /* variables for alignments for reported hits */
  int64_t rep_naln = 0;                        /* total number alignments */
  int64_t rep_noverflow_hb = 0;                /* # HMM banded alns PPs couldn't be calc'ed for due to mx size */
  int64_t rep_ntau_mod_hb = 0;                 /* # HMM banded alns for which was increased due to mx size */
  double  rep_tot_matrix_Mb = 0.;              /* summed Mb req'd for matrices used for alignments */
  double  rep_min_matrix_Mb = eslINFINITY;     /* min Mb req'd over all alns */
  double  rep_max_matrix_Mb = 0.;              /* max Mb req'd over all alns */
  double  rep_avg_matrix_Mb = 0.;              /* avg Mb req'd over all alns */
  double  rep_tot_elapsed_secs = 0.;           /* summed seconds for alignments */
  double  rep_min_elapsed_secs = eslINFINITY;  /* min seconds over all alns */
  double  rep_max_elapsed_secs = 0.;           /* max seconds over all alns */
  double  rep_avg_elapsed_secs = 0.;           /* avg seconds over all alns */

  /* variables for alignments for included hits */
  int64_t inc_naln = 0;                        /* total number alignments */
  int64_t inc_noverflow_hb = 0;                /* # HMM banded alns PPs couldn't be calc'ed for due to mx size */
  int64_t inc_ntau_mod_hb = 0;                 /* # HMM banded alns for which was increased due to mx size */
  double  inc_tot_matrix_Mb = 0.;              /* summed Mb req'd for matrices used for alignments */
  double  inc_min_matrix_Mb = eslINFINITY;     /* min Mb req'd over all alns */
  double  inc_max_matrix_Mb = 0.;              /* max Mb req'd over all alns */
  double  inc_avg_matrix_Mb = 0.;              /* avg Mb req'd over all alns */
  double  inc_tot_elapsed_secs = 0.;           /* summed seconds for alignments */
  double  inc_min_elapsed_secs = eslINFINITY;  /* min seconds over all alns */
  double  inc_max_elapsed_secs = 0.;           /* max seconds over all alns */
  double  inc_avg_elapsed_secs = 0.;           /* avg seconds over all alns */

  /* variables for alignments for removed duplicate hits */
  int64_t dup_naln = 0;                        /* total number alignments */
  int64_t dup_noverflow_hb = 0;                /* # HMM banded alns PPs couldn't be calc'ed for due to mx size */
  int64_t dup_ntau_mod_hb = 0;                 /* # HMM banded alns for which was increased due to mx size */
  double  dup_tot_matrix_Mb = 0.;              /* summed Mb req'd for matrices used for alignments */
  double  dup_min_matrix_Mb = eslINFINITY;     /* min Mb req'd over all alns */
  double  dup_max_matrix_Mb = 0.;              /* max Mb req'd over all alns */
  double  dup_avg_matrix_Mb = 0.;              /* avg Mb req'd over all alns */
  double  dup_tot_elapsed_secs = 0.;           /* summed seconds for alignments */
  double  dup_min_elapsed_secs = eslINFINITY;  /* min seconds over all alns */
  double  dup_max_elapsed_secs = 0.;           /* max seconds over all alns */
  double  dup_avg_elapsed_secs = 0.;           /* avg seconds over all alns */

  /* variables for alignments for hmm only hits */
  int64_t hmmonly_naln = 0;                        /* total number alignments */

  for(h = 0; h < th->N; h++) {
	if(th->unsrt[h].ad->hmmonly) {
	  hmmonly_naln++;
	  /* we don't have stats on time, Mb used, so we can't summarize them */
	}
	else {
	  is_reported          = (th->unsrt[h].flags & CM_HIT_IS_REPORTED) ?          TRUE : FALSE;
	  is_included          = (th->unsrt[h].flags & CM_HIT_IS_INCLUDED) ?          TRUE : FALSE;
	  is_removed_duplicate = (th->unsrt[h].flags & CM_HIT_IS_REMOVED_DUPLICATE) ? TRUE : FALSE;
	  /*is_marked_duplicate  = (th->unsrt[h].flags & CM_HIT_IS_MARKED_OVERLAP)  ? TRUE : FALSE;*/
	  if(th->unsrt[h].ad != NULL) {
	all_naln++;
	all_tot_matrix_Mb    += th->unsrt[h].ad->matrix_Mb;
	all_tot_elapsed_secs += th->unsrt[h].ad->elapsed_secs;
	all_min_matrix_Mb     = ESL_MIN(all_min_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	all_max_matrix_Mb     = ESL_MAX(all_max_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	all_min_elapsed_secs  = ESL_MIN(all_min_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	all_max_elapsed_secs  = ESL_MAX(all_max_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	if(used_hb) {
	  if(fabs(default_tau - th->unsrt[h].ad->tau) > eslSMALLX1) all_ntau_mod_hb++;
	}
	if(used_hb && (! used_cyk)) {
	  if(th->unsrt[h].ad->ppline == NULL) all_noverflow_hb++;
	}

	/* update reported stats */
	if(is_reported) {
	  rep_naln++;
	  rep_tot_matrix_Mb    += th->unsrt[h].ad->matrix_Mb;
	  rep_tot_elapsed_secs += th->unsrt[h].ad->elapsed_secs;
	  rep_min_matrix_Mb     = ESL_MIN(rep_min_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  rep_max_matrix_Mb     = ESL_MAX(rep_max_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  rep_min_elapsed_secs  = ESL_MIN(rep_min_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  rep_max_elapsed_secs  = ESL_MAX(rep_max_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  if(used_hb && (! th->unsrt[h].ad->hmmonly)) {
	    if(fabs(default_tau - th->unsrt[h].ad->tau) > eslSMALLX1) rep_ntau_mod_hb++;
	  }
	  if(used_hb && (! used_cyk)) {
	    if(th->unsrt[h].ad->ppline == NULL) rep_noverflow_hb++;
	  }
	}

	/* update included stats */
	if(is_included) {
	  inc_naln++;
	  inc_tot_matrix_Mb    += th->unsrt[h].ad->matrix_Mb;
	  inc_tot_elapsed_secs += th->unsrt[h].ad->elapsed_secs;
	  inc_min_matrix_Mb     = ESL_MIN(inc_min_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  inc_max_matrix_Mb     = ESL_MAX(inc_max_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  inc_min_elapsed_secs  = ESL_MIN(inc_min_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  inc_max_elapsed_secs  = ESL_MAX(inc_max_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  if(used_hb && (! th->unsrt[h].ad->hmmonly)) {
	    if(fabs(default_tau - th->unsrt[h].ad->tau) > eslSMALLX1) inc_ntau_mod_hb++;
	  }
	  if(used_hb && (! used_cyk)) {
	    if(th->unsrt[h].ad->ppline == NULL) inc_noverflow_hb++;
	  }
	}

	/* update removed duplicate stats */
	if(is_removed_duplicate) {
	  dup_naln++;
	  dup_tot_matrix_Mb    += th->unsrt[h].ad->matrix_Mb;
	  dup_tot_elapsed_secs += th->unsrt[h].ad->elapsed_secs;
	  dup_min_matrix_Mb     = ESL_MIN(dup_min_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  dup_max_matrix_Mb     = ESL_MAX(dup_max_matrix_Mb,    th->unsrt[h].ad->matrix_Mb);
	  dup_min_elapsed_secs  = ESL_MIN(dup_min_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  dup_max_elapsed_secs  = ESL_MAX(dup_max_elapsed_secs, th->unsrt[h].ad->elapsed_secs);
	  if(used_hb) {
	    if(fabs(default_tau - th->unsrt[h].ad->tau) > eslSMALLX1) dup_ntau_mod_hb++;
	}
	  if(used_hb && (! used_cyk)) {
	    if(th->unsrt[h].ad->ppline == NULL) dup_noverflow_hb++;
	  }
	}
	  }
	}
  }
  /* Output */
  if(all_naln > 0) {
	all_avg_matrix_Mb    = all_tot_matrix_Mb    / (double) all_naln;
	all_avg_elapsed_secs = all_tot_elapsed_secs / (double) all_naln;
  }
  if(rep_naln > 0) {
	rep_avg_matrix_Mb    = rep_tot_matrix_Mb    / (double) rep_naln;
	rep_avg_elapsed_secs = rep_tot_elapsed_secs / (double) rep_naln;
  }
  if(inc_naln > 0) {
	inc_avg_matrix_Mb    = inc_tot_matrix_Mb    / (double) inc_naln;
	inc_avg_elapsed_secs = inc_tot_elapsed_secs / (double) inc_naln;
  }
  if(dup_naln > 0) {
	dup_avg_matrix_Mb    = dup_tot_matrix_Mb    / (double) dup_naln;
	dup_avg_elapsed_secs = dup_tot_elapsed_secs / (double) dup_naln;
  }

  fprintf(ofp, "Hit alignment statistics summary:\n");
  fprintf(ofp, "---------------------------------\n");
  if(all_naln > 0 || hmmonly_naln > 0) {
	fprintf(ofp, "%21s  %9s  %25s  %34s\n", "", "", "    matrix size (Mb)     ", "      alignment time (secs)       ");
	fprintf(ofp, "%21s  %9s  %25s  %34s\n", "", "", "-------------------------", "----------------------------------");
	fprintf(ofp, "%-21s  %9s  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "category", "# alns", "minimum", "average", "maximum", "minimum", "average", "maximum", "total");
	if(used_hb) {
	  fprintf(ofp, "  %7s", "ntaumod");
	  if(! used_cyk) {
	fprintf(ofp, "  %7s", "novrflw");
	  }
	}
	fprintf(ofp, "\n");
	fprintf(ofp, "%21s  %9s  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "---------------------", "---------", "-------", "-------", "-------", "-------", "-------", "-------", "-------");
	if(used_hb) {
	  fprintf(ofp, "  %7s", "-------");
	  if(! used_cyk) {
	fprintf(ofp, "  %7s", "-------");
	  }
	}
	fprintf(ofp, "\n");

	/* reported */
	if(rep_naln > 0) {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f", "reported",
	      rep_naln, rep_min_matrix_Mb, rep_avg_matrix_Mb, rep_max_matrix_Mb,
	      rep_min_elapsed_secs, rep_avg_elapsed_secs, rep_max_elapsed_secs, rep_tot_elapsed_secs);
	  if(used_hb) {
	fprintf(ofp, "  %7" PRId64 "", rep_ntau_mod_hb);
	if(! used_cyk) {
	  fprintf(ofp, "  %7" PRId64 "", rep_noverflow_hb);
	}
	  }
	}
	else {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "reported",
	      rep_naln, "-", "-", "-", "-", "-", "-", "-");
	  if(used_hb) {
	fprintf(ofp, "  %7s", "-");
	if(! used_cyk) {
	  fprintf(ofp, "  %7s", "-");
	}
	  }
	}
	fprintf(ofp, "\n");

	/* included */
	if(inc_naln > 0) {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f", "included",
	      inc_naln, inc_min_matrix_Mb,    inc_avg_matrix_Mb,    inc_max_matrix_Mb,
	      inc_min_elapsed_secs, inc_avg_elapsed_secs, inc_max_elapsed_secs, inc_tot_elapsed_secs);
	  if(used_hb) {
	fprintf(ofp, "  %7" PRId64 "", inc_ntau_mod_hb);
	if(! used_cyk) {
	  fprintf(ofp, "  %7" PRId64 "", inc_noverflow_hb);
	}
	  }
	}
	else {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "included",
	      inc_naln, "-", "-", "-", "-", "-", "-", "-");
	  if(used_hb) {
	fprintf(ofp, "  %7s", "-");
	if(! used_cyk) {
	  fprintf(ofp, "  %7s", "-");
	}
	  }
	}
	fprintf(ofp, "\n");

	/* removed duplicates */
	if(dup_naln > 0) {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f", "removed duplicates",
	      dup_naln, dup_min_matrix_Mb, dup_avg_matrix_Mb, dup_max_matrix_Mb,
	      dup_min_elapsed_secs, dup_avg_elapsed_secs, dup_max_elapsed_secs, dup_tot_elapsed_secs);
	  if(used_hb) {
	fprintf(ofp, "  %7" PRId64 "", dup_ntau_mod_hb);
	if(! used_cyk) {
	  fprintf(ofp, "  %7" PRId64 "", dup_noverflow_hb);
	}
	  }
	}
	else {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "removed duplicates",
	      dup_naln, "-", "-", "-", "-", "-", "-", "-");
	  if(used_hb) {
	fprintf(ofp, "  %7s", "-");
	if(! used_cyk) {
	  fprintf(ofp, "  %7s", "-");
	}
	  }
	}
	fprintf(ofp, "\n");

	/* all except hmm only */
	if(all_naln > 0) {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f", "all (except HMM only)",
	      all_naln, all_min_matrix_Mb, all_avg_matrix_Mb, all_max_matrix_Mb,
	      all_min_elapsed_secs, all_avg_elapsed_secs, all_max_elapsed_secs, all_tot_elapsed_secs);
	  if(used_hb) {
	fprintf(ofp, "  %7" PRId64 "", all_ntau_mod_hb);
	if(! used_cyk) {
	  fprintf(ofp, "  %7" PRId64 "", all_noverflow_hb);
	}
	  }
	}
	else {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "all (except HMM only)",
	      all_naln, "-", "-", "-", "-", "-", "-", "-");
	  if(used_hb) {
	fprintf(ofp, "  %7s", "-");
	if(! used_cyk) {
	  fprintf(ofp, "  %7s", "-");
	}
	  }
	}
	fprintf(ofp, "\n");

	/* hmm only */
	if(hmmonly_naln > 0) {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "HMM only",
	      hmmonly_naln, "?", "?", "?", "?", "?", "?", "?");
	}
	else {
	  fprintf(ofp, "%-21s  %9" PRId64 "  %7s  %7s  %7s  %7s  %7s  %7s  %7s", "HMM only",
	      hmmonly_naln, "-", "-", "-", "-", "-", "-", "-");
	}
	if(used_hb) {
	  fprintf(ofp, "  %7s", "-");
	  if(! used_cyk) {
	fprintf(ofp, "  %7s", "-");
	  }
	}
	fprintf(ofp, "\n");
  }
  else {
	fprintf(ofp, "\n   [No hits detected]\n");
  }
  return eslOK;
}

/* Function:  cm_tophits_Alignment()
 * Incept:    EPN, Wed Mar 21 16:21:21 2012
 * Synopsis:  Create a multiple alignment of all the included hits.
 *
 * Purpose:   Create a multiple alignment of all hits marked
 *            "includable" in the top hits list <th>, and return it in
 *            <*ret_msa>.
 *
 * Returns:   <eslOK> on success, if any hits were aligned then
 *            <*ret_msa> points to a new MSA that the caller is
 *            responsible for freeing, else if there are no
 *            reported hits that satisfy inclusion thresholds,
 *            <eslOK> is still returned but ret_msa is <NULL>.
 *
 * Throws:    <eslEINVAL> on contract violation. <eslEMEM> on
 *            allocation failure; <eslECORRUPT> on unexpected internal
 *            data corruption.  Potentially other non-eslOK
 *            values. <errbuf> is filled in all cases.
 */
int
cm_tophits_Alignment(CM_t *cm, const CM_TOPHITS *th, char *errbuf, ESL_MSA **ret_msa)
{
  ESL_SQ      **sqarr = NULL; /* [0..ninc-1] array of sequences, one for each hit */
  Parsetree_t **trarr = NULL; /* [0..ninc-1] array of parsetrees, one for each hit */
  char        **pparr = NULL; /* [0..ninc-1] array of pp strings, one for each hit */
  ESL_MSA      *msa   = NULL;
  int           ninc  = 0;
  int           h, i, y;
  int           status;

  if(cm->cmcons == NULL) ESL_FAIL(eslEINVAL, errbuf, "cm_tophits_Alignment(): cm->cmcons is NULL");

  /* How many hits will be included in the new alignment?
   */
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_INCLUDED) {
	  ninc++;
	}
  }

  if (ninc == 0) { status = eslOK; goto ERROR; /* caller will know that no msa was built b/c ret_msa will be NULL */ }

  /* Allocation */
  ESL_ALLOC(sqarr, sizeof(ESL_SQ *)      * (ninc));
  ESL_ALLOC(trarr, sizeof(Parsetree_t *) * (ninc));
  ESL_ALLOC(pparr, sizeof(char *) * (ninc));
  for (i = 0; i < ninc; i++) sqarr[i] = NULL;
  for (i = 0; i < ninc; i++) trarr[i] = NULL;
  for (i = 0; i < ninc; i++) pparr[i] = NULL;

  /* Make faux sequences, parsetrees from hit list */
  y = 0;
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_INCLUDED) {
	  if ((status = cm_alidisplay_Backconvert(cm, th->hit[h]->ad, errbuf, &(sqarr[y]), &(trarr[y]), &(pparr[y]))) != eslOK) goto ERROR;
	  y++;
	}
  }

  /* create the alignment */
  if((status = Parsetrees2Alignment(cm, errbuf, cm->abc, sqarr, NULL, trarr, pparr, ninc, NULL, NULL, TRUE, FALSE, &msa)) != eslOK) goto ERROR;

  /* Clean up */
  for (y = 0; y < ninc; y++) esl_sq_Destroy(sqarr[y]);
  for (y = 0; y < ninc; y++) FreeParsetree(trarr[y]);
  for (y = 0; y < ninc; y++) free(pparr[y]);
  free(sqarr);
  free(trarr);
  free(pparr);

  *ret_msa = msa;
  return eslOK;

 ERROR:
  if (sqarr != NULL) { for (y = 0; y < ninc; y++) if (sqarr[y] != NULL) esl_sq_Destroy(sqarr[y]); free(sqarr); }
  if (trarr != NULL) { for (y = 0; y < ninc; y++) if (trarr[y] != NULL) FreeParsetree(trarr[y]);  free(trarr); }
  if (pparr != NULL) { for (y = 0; y < ninc; y++) if (pparr[y] != NULL) free(pparr[y]);           free(pparr); }
  if (msa   != NULL) esl_msa_Destroy(msa);
  *ret_msa = NULL;
  return status;
}
/*---------------- end, standard output format ------------------*/

/*****************************************************************
 * 3. Tabular (parsable) output of pipeline results.
 *****************************************************************/

/* Function:  cm_tophits_TabularTargets1()
 * Synopsis:  Output parsable table of per-sequence hits in format '1'.
 * Incept:    EPN, Tue May 24 14:24:06 2011
 *            SRE, Wed Mar 18 15:26:17 2009 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Output a parseable table of reportable per-sequence hits
 *            in sorted tophits list <th> in an easily parsed ASCII
 *            tabular form to stream <ofp>, using final pipeline
 *            accounting stored in <pli>. Format #1 (only format
 *            output by 1.1rc1->1.1.1).
 *
 *            Designed to be concatenated for multiple queries and
 *            multiple top hits list.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_TabularTargets1(FILE *ofp, char *qname, char *qacc, CM_TOPHITS *th, CM_PIPELINE *pli, int show_header)
{
  int status;
  int i;
  int tnamew = ESL_MAX(20, cm_tophits_GetMaxNameLength(th));
  int qnamew = ESL_MAX(20, strlen(qname));
  int qaccw  = ((qacc != NULL) ? ESL_MAX(9, strlen(qacc)) : 9);
  int taccw  = ESL_MAX(9, cm_tophits_GetMaxAccessionLength(th));
  int posw   = ESL_MAX(8, cm_tophits_GetMaxPositionLength(th));

  char *qnamestr = NULL;
  char *tnamestr = NULL;
  char *qaccstr  = NULL;
  char *taccstr  = NULL;
  char *posstr   = NULL;

  ESL_ALLOC(tnamestr, sizeof(char) * (tnamew));
  ESL_ALLOC(taccstr,  sizeof(char) * (taccw+1));
  ESL_ALLOC(qnamestr, sizeof(char) * (qnamew+1));
  ESL_ALLOC(qaccstr,  sizeof(char) * (qaccw+1));
  ESL_ALLOC(posstr,   sizeof(char) * (posw+1));

  for(i = 0; i < tnamew-1; i++) { tnamestr[i] = '-'; } tnamestr[tnamew-1] = '\0'; /* need to account for single '#' */
  for(i = 0; i < taccw;    i++) { taccstr[i]  = '-'; } taccstr[taccw]     = '\0';
  for(i = 0; i < qnamew;   i++) { qnamestr[i] = '-'; } qnamestr[qnamew]   = '\0';
  for(i = 0; i < qaccw;    i++) { qaccstr[i]  = '-'; } qaccstr[qaccw]     = '\0';
  for(i = 0; i < posw;     i++) { posstr[i]   = '-'; } posstr[posw]       = '\0';

  int h;

  if (show_header) {
	fprintf(ofp, "#%-*s %-*s %-*s %-*s %3s %8s %8s %*s %*s %6s %5s %4s %4s %5s %6s %9s %3s %-s\n",
	    tnamew-1, "target name", taccw, "accession",  qnamew, "query name", qaccw, "accession",
	    "mdl", "mdl from", "mdl to",
	    posw, "seq from", posw, "seq to", "strand", "trunc", "pass", "gc", "bias", "score", "E-value", "inc", "description of target");
	fprintf(ofp, "#%-*s %-*s %-*s %-*s %-3s %-7s %-7s %*s %*s %6s %5s %4s %4s %5s %6s %9s %3s %s\n",
	    tnamew-1, tnamestr, taccw, taccstr, qnamew, qnamestr, qaccw, qaccstr,
	    "---", "--------", "--------",
	    posw, posstr, posw, posstr, "------", "-----", "----", "----", "-----", "------", "---------", "---", "---------------------");
  }
  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_REPORTED)    {
	  //      fprintf(ofp, "%-*s %-*s %-*s %-*s %3s %8d %8d %*" PRId64 " %*" PRId64 " %6s %5s %4d %4.2f %5.1f %6.1f %9.2g %-3s %s\n",
	  fprintf(ofp, "%-*s %-*s %-*s %-*s %3s %8d %8d %*" PRId64 " %*" PRId64 " %6s %5s %4d %4.2f %5.1f %6.1f %9.2g %-3s %s\n",
	      tnamew, th->hit[h]->name,
	      taccw,  ((th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') ? th->hit[h]->acc : "-"),
	      qnamew, qname,
	      qaccw,  ((qacc != NULL && qacc[0] != '\0') ? qacc : "-"),
	      th->hit[h]->hmmonly ? "hmm" : "cm",
	      th->hit[h]->ad->cfrom_emit, th->hit[h]->ad->cto_emit,
	      posw, th->hit[h]->start,
	      posw, th->hit[h]->stop,
	      (th->hit[h]->in_rc == TRUE) ? "-" : "+",
	      cm_alidisplay_TruncString(th->hit[h]->ad),
	      th->hit[h]->pass_idx,
	      th->hit[h]->ad->gc,
	      th->hit[h]->bias,
	      th->hit[h]->score,
	      th->hit[h]->evalue,
	      (th->hit[h]->flags & CM_HIT_IS_INCLUDED ? "!" : "?"),
	      (th->hit[h]->desc != NULL) ? th->hit[h]->desc : "-");
	}
  }
  if(qnamestr != NULL) free(qnamestr);
  if(tnamestr != NULL) free(tnamestr);
  if(qaccstr  != NULL) free(qaccstr);
  if(taccstr  != NULL) free(taccstr);
  if(posstr   != NULL) free(posstr);

  return eslOK;

 ERROR:
  if(qnamestr != NULL) free(qnamestr);
  if(tnamestr != NULL) free(tnamestr);
  if(qaccstr  != NULL) free(qaccstr);
  if(taccstr  != NULL) free(taccstr);
  if(posstr   != NULL) free(posstr);

  return status;
}

/* Function:  cm_tophits_TabularTargets2()
 * Synopsis:  Output parsable table of per-sequence hits in format '2'.
 * Incept:    EPN, Thu Dec 18 15:06:58 2014
 *            EPN, Tue May 24 14:24:06 2011 (cm_tophits_TabularTargets())
 *            SRE, Wed Mar 18 15:26:17 2009 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Output a parseable table of reportable per-sequence hits
 *            in sorted tophits list <th> in an easily parsed ASCII
 *            tabular form to stream <ofp>, using final pipeline
 *            accounting stored in <pli>. Format #2.
 *
 *            Format #2 differs from format 1 (cm_tophits_TabularTargets1(),
 *            the only tabular format available in Infernal 1.1rc1-->1.1.1)
 *            in that overlap information is output here (whether each hit
 *            has a higher scoring overlap and the index of the overlap
 *            as well as fractional overlap), as well as clan information
 *            if it's available.
 *
 *            Designed to be concatenated for multiple queries and
 *            multiple top hits list.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_TabularTargets2(FILE *ofp, char *qname, char *qacc, CM_TOPHITS *th, CM_PIPELINE *pli, int show_header, ESL_KEYHASH *clan_name_kh, int skip_overlaps, char *errbuf)
{
  int status;
  int i;
  int tnamew = ESL_MAX(20, cm_tophits_GetMaxNameLength(th));
  int qnamew = ESL_MAX(20, strlen(qname));
  int qaccw  = ((qacc != NULL) ? ESL_MAX(9, strlen(qacc)) : 9);
  int taccw  = ESL_MAX(9, cm_tophits_GetMaxAccessionLength(th));
  int posw   = ESL_MAX(8, cm_tophits_GetMaxPositionLength(th));
  int idxw1  = ESL_MAX(4, integer_textwidth(th->N));
  int idxw2  = ESL_MAX(6, integer_textwidth(th->N));
  int clanw  = ESL_MAX(9, cm_tophits_GetMaxClanLength(th, clan_name_kh));

  /* variables used only if pli->do_trm_F3 */
  char   lseq, rseq;
  /* variables used for dealing with overlap annotation */
  int      h;                    /* counter over hits */
  int64_t  as, ws;               /* current hit's sorted index for h->any_oidx and h->win_oidx */
  int64_t  ao, wo;               /* current hit's output index for h->any_oidx and h->win_oidx */
  int64_t *sorted_idxA = NULL;   /* [0..h..th->N-1] index of hit h in <th>, the sorted list of hits we're outputting */
  int64_t *output_idxA = NULL;   /* [0..h..th->N-1] index of hit h in output list of hits (not all hits are output, some (often many) are overlaps) */
  int     *has_overlapA = NULL;  /* [0..h..th->N-1] 'TRUE' if hit h has any overlapping hits, else 'FALSE' */
  int      maybe_skip;           /* set to TRUE or FALSE depending on whether this hit overlaps with another better
								  * scoring one, we'll skip a hit for which maybe_skip==TRUE if skip_overlaps is TRUE
								  */
  int64_t  noutput = 0;          /* keeps track of the number of this we have output thus far */
  int64_t  nres, len1, len2;     /* number of overlapping residues, and lengths of hits */

  char *qnamestr     = NULL;
  char *tnamestr     = NULL;
  char *qaccstr      = NULL;
  char *taccstr      = NULL;
  char *clanstr      = NULL;
  char *posstr       = NULL;
  char *idxstr1      = NULL;
  char *idxstr2      = NULL;
  char *olp_str      = NULL;
  char *any_oidxstr  = NULL;
  char *win_oidxstr  = NULL;
  char *any_ofctstr1 = NULL;
  char *any_ofctstr2 = NULL;
  char *win_ofctstr1 = NULL;
  char *win_ofctstr2 = NULL;
  char *clannamestr  = NULL;

  if(pli->mode != CM_SCAN_MODELS) { /* we'll only possibly have overlaps if in scan mode */
	ESL_XFAIL(eslEINVAL, errbuf, "Trying to output in format 2, but not in SCAN mode");
  }

  ESL_ALLOC(idxstr1,      sizeof(char) * (idxw1));
  ESL_ALLOC(idxstr2,      sizeof(char) * (idxw2+1));
  ESL_ALLOC(tnamestr,     sizeof(char) * (tnamew+1));
  ESL_ALLOC(taccstr,      sizeof(char) * (taccw+1));
  ESL_ALLOC(qnamestr,     sizeof(char) * (qnamew+1));
  ESL_ALLOC(qaccstr,      sizeof(char) * (qaccw+1));
  ESL_ALLOC(clanstr,      sizeof(char) * (clanw+1));
  ESL_ALLOC(posstr,       sizeof(char) * (posw+1));
  ESL_ALLOC(olp_str,      sizeof(char) * 4);
  ESL_ALLOC(any_oidxstr,  sizeof(char) * (idxw2+1)); /* string for hit index of best scoring overlap */
  ESL_ALLOC(win_oidxstr,  sizeof(char) * (idxw2+1)); /* string for hit index of best scoring overlap that is a 'winner' (has no better scoring overlap) */
  ESL_ALLOC(any_ofctstr1, sizeof(char) * 7);         /* string for fractional overlap b/t current hit and hit any_oidx wrt current hit */
  ESL_ALLOC(any_ofctstr2, sizeof(char) * 7);         /* string for fractional overlap b/t current hit and hit any_oidx wrt hit any_oidx */
  ESL_ALLOC(win_ofctstr1, sizeof(char) * 7);         /* string for fractional overlap b/t current hit and hit win_oidx wrt current hit */
  ESL_ALLOC(win_ofctstr2, sizeof(char) * 7);         /* string for fractional overlap b/t current hit and hit win_oidx wrt hit win_oidx */
  ESL_ALLOC(clannamestr,  sizeof(char) * clanw);     /* string for output of clan name */

  for(i = 0; i < idxw1-1;  i++) { idxstr1[i]  = '-'; } idxstr1[idxw1-1]   = '\0'; /* need to account for single '#' */
  for(i = 0; i < idxw2;    i++) { idxstr2[i]  = '-'; } idxstr2[idxw2]     = '\0';
  for(i = 0; i < tnamew;   i++) { tnamestr[i] = '-'; } tnamestr[tnamew]   = '\0';
  for(i = 0; i < taccw;    i++) { taccstr[i]  = '-'; } taccstr[taccw]     = '\0';
  for(i = 0; i < qnamew;   i++) { qnamestr[i] = '-'; } qnamestr[qnamew]   = '\0';
  for(i = 0; i < qaccw;    i++) { qaccstr[i]  = '-'; } qaccstr[qaccw]     = '\0';
  for(i = 0; i < clanw;    i++) { clanstr[i]  = '-'; } clanstr[clanw]     = '\0';
  for(i = 0; i < posw;     i++) { posstr[i]   = '-'; } posstr[posw]       = '\0';

  if(th->N > 0) {
	ESL_ALLOC(sorted_idxA, sizeof(int64_t) * th->N);
	ESL_ALLOC(output_idxA, sizeof(int64_t) * th->N);
	ESL_ALLOC(has_overlapA, sizeof(int) * th->N);
	for(h = 0; h < th->N; h++) sorted_idxA[h] = -1;
	for(h = 0; h < th->N; h++) output_idxA[h] = -1;
	for(h = 0; h < th->N; h++) has_overlapA[h] = FALSE;
	/* determine which hits are listed as any_oidx or win_oidx for any other hits */
	for(h = 0; h < th->N; h++) {
	  if(th->hit[h]->any_oidx != -1) has_overlapA[th->hit[h]->any_oidx] = TRUE;
	  if(th->hit[h]->win_oidx != -1) has_overlapA[th->hit[h]->win_oidx] = TRUE;
	  sorted_idxA[th->hit[h]->hit_idx] = h; /* save sorted idx */
	  /* and save the output index we'll use for this hit */
	  if ((th->hit[h]->flags & CM_HIT_IS_REPORTED) &&  /* hit is REPORTED */
		  (skip_overlaps == FALSE || (! (th->hit[h]->flags & CM_HIT_IS_MARKED_OVERLAP)))) { /* hit won't be skipped b/c it's an overlap */
		noutput++;
		output_idxA[h] = noutput; /* save output idx */
	  }
	}
	noutput = 0; /* very impt to reset this, so we list first hit as index 1, and not th->N+1 */
  }

  if (show_header) {
	if(pli->do_trm_F3) { /* terminated after F3, more compact output (we don't have all the info for the default output mode) */
	  fprintf(ofp, "#%-*s %-*s %-*s %-*s %6s %*s %*s %6s %6s %11s %3s %*s %6s %6s %*s %6s %6s\n",
			  idxw1-1, "idx", tnamew, "target name", qnamew, "query name", clanw, "clan name",
			  "score",
			  posw, "seq from", posw, "seq to",
			  "strand", "bounds", "seqlen",
			  "olp", idxw2, "anyidx", "afrct1", "afrct2", idxw2, "winidx", "wfrct1", "wfrct2");
	  fprintf(ofp, "#%-*s %-*s %-*s %-*s %6s %*s %*s %6s %6s %11s %3s %s %s %s %s %s %s\n",
			  idxw1-1, idxstr1, tnamew, tnamestr, qnamew, qnamestr, clanw, clanstr,
			  "------",
			  posw, posstr, posw, posstr, "------", "------", "-----------", "---", idxstr2, "------", "------", idxstr2, "------", "------");
	}
	else { /* pli->do_trm_F3 is FALSE, default output mode */
	  fprintf(ofp, "#%-*s %-*s %-*s %-*s %-*s %-*s %3s %8s %8s %*s %*s %6s %5s %4s %4s %5s %6s %9s %3s %3s %*s %6s %6s %*s %6s %6s %-s\n",
			  idxw1-1, "idx", tnamew, "target name", taccw, "accession",  qnamew, "query name", qaccw, "accession", clanw, "clan name",
			  "mdl", "mdl from", "mdl to",
			  posw, "seq from", posw, "seq to",
			  "strand", "trunc", "pass", "gc", "bias", "score", "E-value", "inc",
			  "olp", idxw2, "anyidx", "afrct1", "afrct2", idxw2, "winidx", "wfrct1", "wfrct2", "description of target");
	  fprintf(ofp, "#%-*s %-*s %-*s %-*s %-*s %-*s %-3s %-7s %-7s %*s %*s %6s %5s %4s %4s %5s %6s %9s %3s %3s %s %s %s %s %s %s %s\n",
			  idxw1-1, idxstr1, tnamew, tnamestr, taccw, taccstr, qnamew, qnamestr, qaccw, qaccstr, clanw, clanstr,
			  "---", "--------", "--------",
			  posw, posstr, posw, posstr, "------", "-----", "----", "----", "-----", "------", "---------", "---", "---", idxstr2, "------", "------", idxstr2, "------", "------", "---------------------");
	}
  }
  for (h = 0; h < th->N; h++) {
	/* next complex 'if' statement checks if will we output info on this hit */
	if ((th->hit[h]->flags & CM_HIT_IS_REPORTED) && /* hit is REPORTED */
		((skip_overlaps == FALSE) || (! (th->hit[h]->flags & CM_HIT_IS_MARKED_OVERLAP)))) { /* hit won't be skipped b/c it's an overlap */
	  as = (th->hit[h]->any_oidx == -1) ? -1 : sorted_idxA[th->hit[h]->any_oidx]; /* for convenience */
	  ws = (th->hit[h]->win_oidx == -1) ? -1 : sorted_idxA[th->hit[h]->win_oidx]; /* for convenience */
	  ao = (th->hit[h]->any_oidx == -1) ? -1 : output_idxA[sorted_idxA[th->hit[h]->any_oidx]]; /* for convenience */
	  wo = (th->hit[h]->win_oidx == -1) ? -1 : output_idxA[sorted_idxA[th->hit[h]->win_oidx]]; /* for convenience */

	  /* format the strings to print for overlap indices and fractions */
	  if(as != -1) {
		sprintf(any_oidxstr, "%" PRId64, ao);
		if(th->hit[h]->in_rc) {
		  if(! th->hit[as]->in_rc) ESL_XFAIL(eslEINCONCEIVABLE, errbuf, "hit %d in_rc (%" PRId64 "..%" PRId64 ") but any_oidx (%" PRId64 " %" PRId64 "..%" PRId64 ") is not", h, th->hit[h]->start, th->hit[h]->stop, as, th->hit[as]->start, th->hit[as]->stop);
		  len1 = th->hit[h]->start  - th->hit[h]->stop  + 1;
		  len2 = th->hit[as]->start - th->hit[as]->stop + 1;
		  status = overlap_nres(th->hit[h]->stop, th->hit[h]->start, th->hit[as]->stop, th->hit[as]->start, &nres, errbuf);
		  if(status != eslOK) goto ERROR;
		}
		else {
		  if(th->hit[as]->in_rc) ESL_XFAIL(eslEINCONCEIVABLE, errbuf, "hit %d not in_rc (%" PRId64 "..%" PRId64 ") but any_oidx (%" PRId64 " %" PRId64 "..%" PRId64 ") is ", h, th->hit[h]->start, th->hit[h]->stop, as, th->hit[as]->start, th->hit[as]->stop);
		  len1 = th->hit[h]->stop  - th->hit[h]->start  + 1;
		  len2 = th->hit[as]->stop - th->hit[as]->start + 1;
		  status = overlap_nres(th->hit[h]->start, th->hit[h]->stop, th->hit[as]->start, th->hit[as]->stop, &nres, errbuf);
		  if(status != eslOK) goto ERROR;
		}
		sprintf(any_ofctstr1, "%6.3f", (float) nres / (float) len1);
		sprintf(any_ofctstr2, "%6.3f", (float) nres / (float) len2);
	  }
	  if(ws != -1 && ws != as) { /* only calculate the win_* values if it's not identical to the any_* */
		sprintf(win_oidxstr, "%" PRId64, wo);
		if(th->hit[h]->in_rc) {
		  if(! th->hit[ws]->in_rc) ESL_XFAIL(eslEINCONCEIVABLE, errbuf, "hit %d in_rc (%" PRId64 "..%" PRId64 ") but win_oidx (%" PRId64 " %" PRId64 "..%" PRId64 ") is not", h, th->hit[h]->start, th->hit[h]->stop, ws, th->hit[ws]->start, th->hit[ws]->stop);
		  len1 = th->hit[h]->start  - th->hit[h]->stop  + 1;
		  len2 = th->hit[ws]->start - th->hit[ws]->stop + 1;
		  status = overlap_nres(th->hit[h]->stop, th->hit[h]->start, th->hit[ws]->stop, th->hit[ws]->start, &nres, errbuf);
		  if(status != eslOK) goto ERROR;
		}
		else {
		  if(th->hit[ws]->in_rc) ESL_XFAIL(eslEINCONCEIVABLE, errbuf, "hit %d not in_rc (%" PRId64 "..%" PRId64 ") but win_oidx (%" PRId64 " %" PRId64 "..%" PRId64 ") is ", h, th->hit[h]->start, th->hit[h]->stop, ws, th->hit[ws]->start, th->hit[ws]->stop);
		  len1 = th->hit[h]->stop  - th->hit[h]->start  + 1;
		  len2 = th->hit[ws]->stop - th->hit[ws]->start + 1;
		  status = overlap_nres(th->hit[h]->start, th->hit[h]->stop, th->hit[ws]->start, th->hit[ws]->stop, &nres, errbuf);
		  if(status != eslOK) goto ERROR;
		}
		sprintf(win_ofctstr1, "%6.3f", (float) nres / (float) len1);
		sprintf(win_ofctstr2, "%6.3f", (float) nres / (float) len2);
	  }
	  if     (th->hit[h]->flags & CM_HIT_IS_MARKED_OVERLAP) { sprintf(olp_str, " = "); maybe_skip = TRUE;  }
	  else if(has_overlapA[th->hit[h]->hit_idx] == TRUE)    { sprintf(olp_str, " ^ "); maybe_skip = FALSE; }
	  else                                                  { sprintf(olp_str, " * "); maybe_skip = FALSE; }

	  /* make sure the clan name string makes sense */
	  if(th->hit[h]->clan_idx != -1) {
		if(clan_name_kh == NULL)                                        ESL_XFAIL(eslEINVAL, errbuf, "trying to output tabular output of clans, but clan data structure is missing...");
		if(th->hit[h]->clan_idx >= esl_keyhash_GetNumber(clan_name_kh)) ESL_XFAIL(eslEINVAL, errbuf, "trying to output tabular output of clans, but clan index is invalid...");
	  }

	  if((skip_overlaps == FALSE) || (maybe_skip == FALSE)) { /* if skip_overlaps is TRUE, potentially skip this hit in the tabular output */
		noutput++;
		if(pli->do_trm_F3) { /* special 'terminate after F3 mode', different output */
		  if(th->hit[h]->in_rc) {
			lseq = th->hit[h]->start == th->hit[h]->srcL ? '[' : '.';
			rseq = th->hit[h]->stop  == 1                ? ']' : '.';
		  }
		  else {
			lseq = th->hit[h]->start == 1                ? '[' : '.';
			rseq = th->hit[h]->stop  == th->hit[h]->srcL ? ']' : '.';
		  }
		  fprintf(ofp, "%-*" PRId64 " %-*s %-*s %-*s %6.1f %*" PRId64 " %*" PRId64 " %6s %4s%c%c %11" PRId64 " %3s %*s %6s %6s %*s %6s %6s\n",
				  idxw1, noutput,
				  tnamew, th->hit[h]->name,
				  qnamew, qname,
				  clanw, (th->hit[h]->clan_idx == -1) ? "-" : esl_keyhash_Get(clan_name_kh, th->hit[h]->clan_idx),
				  th->hit[h]->score,
				  posw, th->hit[h]->start,
				  posw, th->hit[h]->stop,
				  (th->hit[h]->in_rc == TRUE) ? "-" : "+",
				  "", lseq, rseq, th->hit[h]->srcL,
				  olp_str,
				  idxw2, (as == -1) ? "-" : any_oidxstr,
				  (as == -1) ? "-" : any_ofctstr1,
				  (as == -1) ? "-" : any_ofctstr2,
				  idxw2, (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_oidxstr,
				  (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_ofctstr1,
				  (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_ofctstr2);
		}
		else { /* pli->do_trm_F3 is FALSE, default output mode */
		  fprintf(ofp, "%-*" PRId64 " %-*s %-*s %-*s %-*s %-*s %3s %8d %8d %*" PRId64 " %*" PRId64 " %6s %5s %4d %4.2f %5.1f %6.1f %9.2g %3s %3s %*s %6s %6s %*s %6s %6s %s\n",
				  idxw1, noutput,
				  tnamew, th->hit[h]->name,
				  taccw,  ((th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') ? th->hit[h]->acc : "-"),
				  qnamew, qname,
				  qaccw,  ((qacc != NULL && qacc[0] != '\0') ? qacc : "-"),
				  clanw, (th->hit[h]->clan_idx == -1) ? "-" : esl_keyhash_Get(clan_name_kh, th->hit[h]->clan_idx),
				  th->hit[h]->hmmonly ? "hmm" : "cm",
				  th->hit[h]->ad->cfrom_emit, th->hit[h]->ad->cto_emit,
				  posw, th->hit[h]->start,
				  posw, th->hit[h]->stop,
				  (th->hit[h]->in_rc == TRUE) ? "-" : "+",
				  cm_alidisplay_TruncString(th->hit[h]->ad),
				  th->hit[h]->pass_idx,
				  th->hit[h]->ad->gc,
				  th->hit[h]->bias,
				  th->hit[h]->score,
				  th->hit[h]->evalue,
				  (th->hit[h]->flags & CM_HIT_IS_INCLUDED ? " ! " : " ? "),
				  olp_str,
				  idxw2, (as == -1) ? "-" : any_oidxstr,
				  (as == -1) ? "-" : any_ofctstr1,
				  (as == -1) ? "-" : any_ofctstr2,
				  idxw2, (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_oidxstr,
				  (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_ofctstr1,
				  (ws == -1 || ws == as) ? ((ws == -1) ? "-" : "\"") : win_ofctstr2,
				  (th->hit[h]->desc != NULL) ? th->hit[h]->desc : "-");
		}
	  }
	}
  }
  if(qnamestr     != NULL) free(qnamestr);
  if(tnamestr     != NULL) free(tnamestr);
  if(qaccstr      != NULL) free(qaccstr);
  if(taccstr      != NULL) free(taccstr);
  if(clanstr      != NULL) free(clanstr);
  if(posstr       != NULL) free(posstr);
  if(idxstr1      != NULL) free(idxstr1);
  if(idxstr2      != NULL) free(idxstr2);
  if(olp_str      != NULL) free(olp_str);
  if(any_oidxstr  != NULL) free(any_oidxstr);
  if(win_oidxstr  != NULL) free(win_oidxstr);
  if(any_ofctstr1 != NULL) free(any_ofctstr1);
  if(any_ofctstr2 != NULL) free(any_ofctstr2);
  if(win_ofctstr1 != NULL) free(win_ofctstr1);
  if(win_ofctstr2 != NULL) free(win_ofctstr2);
  if(clannamestr  != NULL) free(clannamestr);
  if(sorted_idxA  != NULL) free(sorted_idxA);
  if(output_idxA  != NULL) free(output_idxA);
  if(has_overlapA != NULL) free(has_overlapA);

  return eslOK;

 ERROR:
  if(qnamestr     != NULL) free(qnamestr);
  if(tnamestr     != NULL) free(tnamestr);
  if(qaccstr      != NULL) free(qaccstr);
  if(taccstr      != NULL) free(taccstr);
  if(clanstr      != NULL) free(clanstr);
  if(posstr       != NULL) free(posstr);
  if(idxstr1      != NULL) free(idxstr1);
  if(idxstr2      != NULL) free(idxstr2);
  if(olp_str      != NULL) free(olp_str);
  if(any_oidxstr  != NULL) free(any_oidxstr);
  if(win_oidxstr  != NULL) free(win_oidxstr);
  if(any_ofctstr1 != NULL) free(any_ofctstr1);
  if(any_ofctstr2 != NULL) free(any_ofctstr2);
  if(win_ofctstr1 != NULL) free(win_ofctstr1);
  if(win_ofctstr2 != NULL) free(win_ofctstr2);
  if(clannamestr  != NULL) free(clannamestr);
  if(sorted_idxA  != NULL) free(sorted_idxA);
  if(output_idxA  != NULL) free(output_idxA);
  if(has_overlapA != NULL) free(has_overlapA);

  return status;
}

/* Helper function for determining overlap fractions.
 *
 * overlap_nres(): determines the number of residues overlapping between
 *                 from1..to1 and from2..to2, and returns it in <*ret_nres>.
 *                 eturns 0 if no overlap.
 *
 *                 The following must hold: from1 <= to1, from2 <= to2.
 *                 If either is not true, then we return eslEINVAL and
 *                 fill errbuf with an error message.
 *
 */
int64_t overlap_nres(int64_t from1, int64_t to1, int64_t from2, int64_t to2, int64_t *ret_nres, char *errbuf)
{
  int64_t tmp;
  int64_t nres;

  if(from1 > to1) ESL_FAIL(eslEINVAL, errbuf, "in overlap_nres, from1 (%" PRId64 ") > to1 (%" PRId64 ")", from1, to1);
  if(from2 > to2) ESL_FAIL(eslEINVAL, errbuf, "in overlap_nres, from2 (%" PRId64 ") > to2 (%" PRId64 ")", from2, to2);

  /* wwap if nec so that from1 <= <from2. */
  if(from1 > from2) {
	tmp   = from1; from1 = from2; from2 = tmp;
	tmp   =   to1;   to1 =   to2;   to2 = tmp;
  }

  /* 3 possible cases:
   * Case 1. from1 <=   to1 <  from2 <=   to2  overlap is 0
   * Case 2. from1 <= from2 <=   to1 <    to2
   * Case 3. from1 <= from2 <=   to2 <=   to1
  */
  if     (to1 < from2) { nres =  0; }                 /* case 1 */
  else if(to1 <   to2) { nres = (to1 - from2 + 1); }  /* case 2 */
  else if(to2 <=  to1) { nres = (to2 - from2 + 1); }  /* case 3 */
  else                 { ESL_FAIL(eslEINCONCEIVABLE, errbuf, "unforeseen case in overlap_nres(), from1..to1 (%" PRId64 "..%" PRId64 ") from2..to 2(%" PRId64 "..%" PRId64 ")", from1, to1, from2, to2); }

  *ret_nres = nres;
  return eslOK;
}

/* Function:  cm_tophits_F3TabularTargets1()
 * Synopsis:  Output format for a top target hits list in special
 *            'terminate after filter stage F3' mode.
 *
 * Incept:    EPN, Wed Oct 22 14:42:48 2014
 *            SRE, Tue Dec  9 09:10:43 2008 [Janelia] (p7_tophits.c)
 *
 * Purpose:   Output a parseable table of reportable per-sequence hits
 *            in sorted tophits list <th> in an easily parsed ASCII
 *            tabular form to stream <ofp>, using final pipeline
 *            accounting stored in <pli>. This version is similar
 *            to cm_tophits_TabularTargets() but reports a
 *            different set of fields. Mostly the same fields that are
 *            printed in cm_tophits_F3Targets() are printed here.
 *
 * Purpose:   Output a list of the reportable top target hits in <th>
 *            in human-readable ASCII text format to stream <ofp>, using
 *            final pipeline accounting stored in <pli>. This version
 *            is similar to cm_tophits_TabularTargets() but reports a different
 *            set of fields.
 *
 *            The tophits list <th> should already be sorted (see
 *            <cm_tophits_Sort*()> and thresholded (see
 *            <cm_tophits_Threshold>).
 *
 * Returns:   <eslOK> on success.
 */
int
cm_tophits_F3TabularTargets1(FILE *ofp, CM_TOPHITS *th, CM_PIPELINE *pli, int show_header)
{
  int    status;
  int    h,i;
  int    namew;
  int    posw;
  int    descw;
  char  *showname;
  char   lseq, rseq;

  char *namestr     = NULL;
  char *descstr     = NULL;
  char *posstr      = NULL;

  /* when --acc is on, we'll show accession if available, and fall back to name */
  if (pli->show_accessions) namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 9 : 10), cm_tophits_GetMaxShownLength(th));
  else                      namew = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 9 : 10), cm_tophits_GetMaxNameLength(th));
  descw = ESL_MAX((pli->mode == CM_SEARCH_SEQS ? 9 : 8), cm_tophits_GetMaxDescLength(th));
  posw  = ESL_MAX(6, cm_tophits_GetMaxPositionLength(th));

  ESL_ALLOC(namestr, sizeof(char) * (namew+1));
  ESL_ALLOC(descstr, sizeof(char) * (descw+1));
  ESL_ALLOC(posstr,  sizeof(char) * (posw+1));

  namestr[0] = '#';
  for(i = 1; i < namew; i++) { namestr[i] = '-'; } namestr[namew] = '\0';
  for(i = 0; i < descw; i++) { descstr[i] = '-'; } descstr[descw] = '\0';
  for(i = 0; i < posw;  i++) { posstr[i]  = '-'; } posstr[posw]   = '\0';

  if(show_header) {
	fprintf(ofp, "%-*s %-*s %6s %*s %*s %6s %6s %3s %11s\n", namew, (pli->mode == CM_SEARCH_SEQS) ? "#sequence" : "#modelname", descw, (pli->mode == CM_SEARCH_SEQS) ? "modelname" : "sequence", " score", posw, "start", posw, "end", "strand", "bounds", "ovp", "seqlen");
	fprintf(ofp, "%*s %*s %6s %*s %*s %6s %6s %3s %11s\n", namew, namestr, descw, descstr, "------", posw, posstr, posw, posstr, "------", "------", "---", "-----------");
  }

  for (h = 0; h < th->N; h++) {
	if (th->hit[h]->flags & CM_HIT_IS_REPORTED) {

	  if (pli->show_accessions) {
	/* the --acc option: report accessions rather than names if possible */
	if (th->hit[h]->acc != NULL && th->hit[h]->acc[0] != '\0') showname = th->hit[h]->acc;
	else                                                       showname = th->hit[h]->name;
	  }
	  else {
	showname = th->hit[h]->name;
	  }
	  if(th->hit[h]->in_rc) {
		lseq = th->hit[h]->start == th->hit[h]->srcL ? '[' : '.';
		rseq = th->hit[h]->stop  == 1                ? ']' : '.';
	  }
	  else {
		lseq = th->hit[h]->start == 1                ? '[' : '.';
		rseq = th->hit[h]->stop  == th->hit[h]->srcL ? ']' : '.';
	  }

	  fprintf(ofp, "%-*s %-*s %6.1f %*" PRId64 " %*" PRId64 " %6s %4s%c%c %3s %11" PRId64 "\n",
	      namew, showname,
	      descw, th->hit[h]->desc,
	      th->hit[h]->score,
	      posw, th->hit[h]->start,
	      posw, th->hit[h]->stop,
	      (th->hit[h]->in_rc == TRUE) ? "-" : "+",
	      "", lseq, rseq,
	      ((pli->mode == CM_SCAN_MODELS) ? (th->hit[h]->flags & CM_HIT_IS_MARKED_OVERLAP ? " = " : " * ") : " ? "),
			  th->hit[h]->srcL);
	}
  }
  if(namestr != NULL) free(namestr);
  if(descstr != NULL) free(descstr);
  if(posstr  != NULL) free(posstr);

  return eslOK;

 ERROR:
  if(namestr != NULL) free(namestr);
  if(descstr != NULL) free(descstr);
  if(posstr  != NULL) free(posstr);

  return status;
}

/* Function:  cm_tophits_TabularTail()
 * Synopsis:  Print a trailer on a tabular output file.
 * Incept:    SRE, Tue Jan 11 16:13:30 2011 [Janelia]
 *
 * Purpose:   Print some metadata as a trailer on a tabular output file:
 *            date/time, the program, INFERNAL version info, the
 *            pipeline mode (SCAN or SEARCH), the query and target
 *            filenames, a spoof commandline recording the entire
 *            program configuration, and a "fini!" that's useful for
 *            detecting successful output completion.
 *
 * Args:      ofp       - open tabular output file (--tblout)
 *            progname  - "cmscan", for example
 *            pipemode  - CM_SEARCH_SEQS | CM_SCAN_MODELS
 *            qfile     - name of query file, or '-' for stdin, or '[none]' if NULL
 *            tfile     - name of target file, or '-' for stdin, or '[none]' if NULL
 *            go        - program configuration; used to generate spoofed command line
 *
 * Returns:   <eslOK>.
 *
 * Throws:    <eslEMEM> on allocation failure.
 *            <eslESYS> if time() or ctime_r() system calls fail.
 *
 * Xref:      J7/54
 */
int
cm_tophits_TabularTail(FILE *ofp, const char *progname, enum cm_pipemodes_e pipemode, const char *qfile, const char *tfile, const ESL_GETOPTS *go)
{
   time_t date           = time(NULL);
   char  *spoof_cmd      = NULL;
   char  *cwd            = NULL;
   char   timestamp[32];
   char   modestamp[16];
   int    status;

  if ((status = esl_opt_SpoofCmdline(go, &spoof_cmd)) != eslOK) goto ERROR;
  if (date == -1)                                               ESL_XEXCEPTION(eslESYS, "time() failed");
  if ((ctime_r(&date, timestamp)) == NULL)                      ESL_XEXCEPTION(eslESYS, "ctime_r() failed");
  switch (pipemode) {
  case CM_SEARCH_SEQS: strcpy(modestamp, "SEARCH"); break;
  case CM_SCAN_MODELS: strcpy(modestamp, "SCAN");   break;
  default:             ESL_EXCEPTION(eslEINCONCEIVABLE, "wait, what? no such pipemode");
  }
  esl_getcwd(&cwd);

  fprintf(ofp, "#\n");
  fprintf(ofp, "# Program:         %s\n",      (progname == NULL) ? "[none]" : progname);
  fprintf(ofp, "# Version:         %s (%s)\n", INFERNAL_VERSION, INFERNAL_DATE);
  fprintf(ofp, "# Pipeline mode:   %s\n",      modestamp);
  fprintf(ofp, "# Query file:      %s\n",      (qfile    == NULL) ? "[none]" : qfile);
  fprintf(ofp, "# Target file:     %s\n",      (tfile    == NULL) ? "[none]" : tfile);
  fprintf(ofp, "# Option settings: %s\n",      spoof_cmd);
  fprintf(ofp, "# Current dir:     %s\n",      (cwd      == NULL) ? "[unknown]" : cwd);
  fprintf(ofp, "# Date:            %s",        timestamp); /* timestamp ends in \n */
  fprintf(ofp, "# [ok]\n");

  free(spoof_cmd);
  if (cwd) free(cwd);
  return eslOK;

 ERROR:
  if (spoof_cmd) free(spoof_cmd);
  if (cwd)       free(cwd);
  return status;
}
/*------------------- end, tabular output -----------------------*/

/*****************************************************************
 * 4. Debugging/dev code
 *****************************************************************/

/* Function:  cm_tophits_Dump()
 * Synopsis:  Print contents of CM_TOPHITS for inspection.
 *
 * Purpose:   Print contents of the <CM_TOPHITS> <th> to
 *            stream <fp> for inspection.
 *
 * Returns:   <eslOK>
 */
int
cm_tophits_Dump(FILE *fp, const CM_TOPHITS *th)
{
  uint64_t i;

  fprintf(fp, "CM_TOPHITS dump\n");
  fprintf(fp, "------------------\n");

  fprintf(fp, "N                             = %" PRId64 "\n", th->N);
  fprintf(fp, "Nalloc                        = %" PRId64 "\n", th->Nalloc);
  fprintf(fp, "nreported                     = %" PRId64 "\n", th->nreported);
  fprintf(fp, "nincluded                     = %" PRId64 "\n", th->nincluded);
  fprintf(fp, "is_sorted_by_evalue           = %s\n",  th->is_sorted_by_evalue           ? "TRUE" : "FALSE");
  fprintf(fp, "is_sorted_for_overlap_removal = %s\n",  th->is_sorted_for_overlap_removal ? "TRUE" : "FALSE");
  fprintf(fp, "is_sorted_by_overlap_markup   = %s\n",  th->is_sorted_for_overlap_markup  ? "TRUE" : "FALSE");
  fprintf(fp, "is_sorted_by_position         = %s\n",  th->is_sorted_by_position         ? "TRUE" : "FALSE");
  if(th->is_sorted_by_evalue) {
	for (i = 0; i < th->N; i++) {
	  fprintf(fp, "E-VALUE SORTED HIT %" PRId64 ":\n", i);
	  cm_hit_Dump(fp, th->hit[i]);
	}
  }
  else if(th->is_sorted_for_overlap_removal) {
	for (i = 0; i < th->N; i++) {
	  fprintf(fp, "OVERLAP REMOVAL SORTED HIT %" PRId64 ":\n", i);
	  cm_hit_Dump(fp, th->hit[i]);
	}
  }
  else if(th->is_sorted_by_position) {
	for (i = 0; i < th->N; i++) {
	  fprintf(fp, "POSITION SORTED HIT %" PRId64 ":\n", i);
	  cm_hit_Dump(fp, th->hit[i]);
	}
  }
  else if(th->is_sorted_for_overlap_markup) {
	for (i = 0; i < th->N; i++) {
	  fprintf(fp, "OVERLAP MARKUP SORTED HIT %" PRId64 ":\n", i);
	  cm_hit_Dump(fp, th->hit[i]);
	}
  }
  else {
	for (i = 0; i < th->N; i++) {
	  fprintf(fp, "UNSORTED HIT %" PRId64 ":\n", i);
	  cm_hit_Dump(fp, &(th->unsrt[i]));
	}
  }
  return eslOK;
}

/* Function:  cm_hit_AllowTruncation()
 * Synopsis:  Determine if a hit returned from a truncated DP scanner
 *            is allowed, and return TRUE if it is and should be
 *            reported. Otherwise return FALSE.
 *
 *            The decision depends on the pipeline pass index, the
 *            mode of the hit, the locality mode of the CM and whether
 *            or not the hit contains the first and/or final residue
 *            of its source sequence.
 *
 * Args:      cm       - the model, we need its emitmap and clen
 *            pass_idx - pass index hit was found in, if
 *                       PLI_PASS_STD_ANY or PLI_PASS_5P_AND_3P_ANY
 *                       or PLI_PASS_HMM_ONLY_ANY, we allow all hits.
 *            start    - start position of the hit
 *            stop     - end position of the hit
 *            i0       - start position of source sequence
 *            j0       - end position of source sequence
 *            mode     - marginal mode of hit
 *            b        - entry state of the hit, we used a
 *                       truncated begin into this state.
 * Returns:   informative string
 */
int
cm_hit_AllowTruncation(CM_t *cm, int pass_idx, int64_t start, int64_t stop, int64_t i0, int64_t j0, char mode, int b)
{
  int in_local_mode = (cm->flags & CMH_LOCAL_BEGIN) ? TRUE : FALSE;
  int nd = cm->ndidx[b];
  int lpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
  int rpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;

  /* if our pass index allows 'any' hit, return TRUE */
  if(pass_idx == PLI_PASS_STD_ANY || pass_idx == PLI_PASS_5P_AND_3P_ANY || pass_idx == PLI_PASS_HMM_ONLY_ANY) return TRUE;

  /* always allow full sequence hits i0..j0 */
  if(start == i0 && stop == j0) return TRUE;

  /* if we get here, hit does not include full seq i0..j0 */
  if(in_local_mode) {
	switch(mode) {
	case TRMODE_J: /* local J hit that doesn't span full seq: always allow it */
	  return TRUE; break;
	case TRMODE_L: /* local L hit that doesn't span full seq: j0 must be included */
	  return (stop  == j0) ? TRUE : FALSE; break;
	case TRMODE_R: /* local R hit that doesn't span full seq: i0 must be included */
	  return (start == i0) ? TRUE : FALSE; break;
	case TRMODE_T: /* local T hit that doesn't span full seq: don't allow it */
	  return FALSE; break;
	default:
	  return FALSE; break;
	}
  }
  else { /* local begins are off */
	switch(mode) {
	case TRMODE_J: /* global J hit that doesn't span full seq: b must span 1..clen to allow it*/
	  return (lpos == 1 && rpos == cm->clen) ? TRUE : FALSE; break;
	case TRMODE_L: /* global L hit that doesn't span full seq: j0 must be included and b must span 1 to allow it */
	  return (stop  == j0   && lpos == 1)        ? TRUE : FALSE; break;
	case TRMODE_R: /* global R hit that doesn't span full seq: i0 must be included and b must span clen to allow it */
	  return (start == i0   && rpos == cm->clen) ? TRUE : FALSE; break;
	case TRMODE_T: /* global T hit that doesn't span full seq: don't allow it */
	  return FALSE; break;
	default:
	  return FALSE; break;
	}
  }
  return FALSE; /* not reached */
}

/* Function:  cm_hit_Dump()
 * Synopsis:  Print contents of a CM_HIT for inspection.
 *
 * Purpose:   Print contents of the <CM_HIT> <h> to
 *            stream <fp> for inspection.
 *
 * Returns:   <eslOK>
 */
int
cm_hit_Dump(FILE *fp, const CM_HIT *h)
{
  fprintf(fp, "CM_HIT dump\n");
  fprintf(fp, "------------------\n");
  fprintf(fp, "hit_idx    = %" PRId64 "\n", h->hit_idx);
  fprintf(fp, "name       = %s\n",  h->name);
  fprintf(fp, "acc        = %s\n",  (h->acc  != NULL) ? h->acc  : "NULL");
  fprintf(fp, "desc       = %s\n",  (h->desc != NULL) ? h->desc : "NULL");
  fprintf(fp, "cm_idx     = %" PRId64 "\n", h->cm_idx);
  fprintf(fp, "clan_idx   = %d\n",          h->clan_idx);
  fprintf(fp, "seq_idx    = %" PRId64 "\n", h->seq_idx);
  fprintf(fp, "pass_idx   = %d\n",          h->pass_idx);
  fprintf(fp, "start      = %" PRId64 "\n", h->start);
  fprintf(fp, "stop       = %" PRId64 "\n", h->stop);
  fprintf(fp, "srcL       = %" PRId64 "\n", h->srcL);
  fprintf(fp, "in_rc      = %s\n",  h->in_rc ? "TRUE" : "FALSE");
  fprintf(fp, "root       = %d\n",  h->root);
  fprintf(fp, "mode       = %s\n",  MarginalMode(h->mode));
  fprintf(fp, "score      = %f\n",  h->score);
  fprintf(fp, "pvalue     = %f\n",  h->pvalue);
  fprintf(fp, "evalue     = %f\n",  h->evalue);
  fprintf(fp, "has_evalue = %s\n",  h->has_evalue ? "TRUE" : "FALSE");
  fprintf(fp, "any_oidx   = %" PRId64 "\n", h->any_oidx);
  fprintf(fp, "win_oidx   = %" PRId64 "\n", h->win_oidx);
  fprintf(fp, "any_bitE   = %f\n", h->any_bitE);
  fprintf(fp, "win_bitE   = %f\n", h->win_bitE);
  if(h->flags == 0) {
	fprintf(fp, "flags     = NONE\n");
  }
  else {
	fprintf(fp, "flags:\n");
	if(h->flags & CM_HIT_IS_REPORTED)          fprintf(fp, "\tCM_HIT_IS_REPORTED\n");
	if(h->flags & CM_HIT_IS_INCLUDED)          fprintf(fp, "\tCM_HIT_IS_INCLUDED\n");
	if(h->flags & CM_HIT_IS_REMOVED_DUPLICATE) fprintf(fp, "\tCM_HIT_IS_REMOVED_DUPLICATE\n");
	if(h->flags & CM_HIT_IS_MARKED_OVERLAP)  fprintf(fp, "\tCM_HIT_IS_MARKED_OVERLAP\n");
  }
  if(h->ad == NULL) {
	fprintf(fp, "ad        = NULL\n");
  }
  else {
	cm_alidisplay_Dump(fp, h->ad);
  }
  return eslOK;
}

/*****************************************************************
 * 4. Benchmark driver
 *****************************************************************/
#ifdef CM_TOPHITS_BENCHMARK
/*
  gcc -o benchmark-cm-tophits -std=gnu99 -g -O2 -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DCM_TOPHITS_BENCHMARK cm_tophits.c -linfernal -lhmmer -leasel -lm
  ./benchmark-cm-tophits

  As of 28 Dec 07, shows 0.20u for 10 lists of 10,000 hits each (at least ~100x normal expectation),
  so we expect top hits list time to be negligible for typical hmmsearch/hmmscan runs.

  If needed, we do have opportunity for optimization, however - especially in memory handling.
 */


#include <stdlib.h>
#include <stdio.h>



static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",             0 },
  { "-s",        eslARG_INT,    "181", NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>",                    0 },
  { "-M",        eslARG_INT,     "10", NULL, NULL,  NULL,  NULL, NULL, "number of top hits lists to simulate and merge",   0 },
  { "-N",        eslARG_INT,  "10000", NULL, NULL,  NULL,  NULL, NULL, "number of top hits to simulate per list",          0 },
  { "-X",        eslARG_INT,   "1000", NULL, NULL,  NULL,  NULL, NULL, "number of target sequences hits can come from",    0 },
  { "-Y",        eslARG_INT,     "10", NULL, NULL,  NULL,  NULL, NULL, "number of models hits can be to",                  0 },
  { "-Z",        eslARG_INT,    "100", NULL, NULL,  NULL,  NULL, NULL, "length of hits (fixed)",                           0 },
  { "-L",        eslARG_INT, "100000", NULL, NULL,  NULL,  NULL, NULL, "length of target sequences",                       0 },
  { "-v",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "dump hit list after removing overlaps",            0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options]";
static char banner[] = "benchmark driver for CM_TOPHITS";

int
main(int argc, char **argv)
{
  ESL_GETOPTS    *go       = cm_CreateDefaultApp(options, 0, argc, argv, banner, usage);
  ESL_STOPWATCH  *w        = esl_stopwatch_Create();
  ESL_RANDOMNESS *r        = esl_randomness_CreateFast(esl_opt_GetInteger(go, "-s"));
  int             N        = esl_opt_GetInteger(go, "-N");
  int             M        = esl_opt_GetInteger(go, "-M");
  int             X        = esl_opt_GetInteger(go, "-X");
  int             Y        = esl_opt_GetInteger(go, "-Y");
  int             L        = esl_opt_GetInteger(go, "-L");
  int             hitlen   = esl_opt_GetInteger(go, "-Z");
  CM_TOPHITS    **h        = NULL;
  CM_HIT         *hit      = NULL;
  float          *scores   = NULL;
  int            *seq_idxes= NULL;
  int            *cm_idxes = NULL;
  int            *starts   = NULL;
  int            *stops    = NULL;
  char            name[]   = "not_unique_name";
  char            acc[]    = "not_unique_acc";
  char            desc[]   = "Test description for the purposes of making the benchmark allocate space";
  int             i,j;
  int             nhits;
  int             nhits_unmarked;
  int             status;
  char            errbuf[eslERRBUFSIZE];

  /* prep work: generate our sort keys before starting to time anything    */
  ESL_ALLOC(h,         sizeof(CM_TOPHITS *) * M); /* allocate pointers for M lists */
  ESL_ALLOC(scores,    sizeof(double) * N * M);
  ESL_ALLOC(seq_idxes, sizeof(int) * N * M);
  ESL_ALLOC(cm_idxes,  sizeof(int) * N * M);
  ESL_ALLOC(starts,    sizeof(int) * N * M);
  ESL_ALLOC(stops,     sizeof(int) * N * M);
  for (i = 0; i < N*M; i++) scores[i]    = esl_random(r);
  for (i = 0; i < N*M; i++) seq_idxes[i] = esl_rnd_Roll(r, X);
  for (i = 0; i < N*M; i++) cm_idxes[i]  = esl_rnd_Roll(r, Y);
  for (i = 0; i < N*M; i++) starts[i]    = esl_rnd_Roll(r, L) + 1;
  for (i = 0; i < N*M; i++) stops[i]     = (esl_rnd_Roll(r, 2) == 0) ? ESL_MIN(starts[i] + hitlen - 1, L) : ESL_MAX(starts[i] - hitlen + 1, 1);

  esl_stopwatch_Start(w);

  /* generate M "random" lists and sort them */
  for (j = 0; j < M; j++)
	{
	  h[j] = cm_tophits_Create();
	  for (i = 0; i < N; i++)
	{
	  cm_tophits_CreateNextHit(h[j], &hit);
	  esl_strdup(name, -1, &(hit->name));
	  esl_strdup(acc,  -1, &(hit->acc));
	  esl_strdup(desc, -1, &(hit->desc));
	  hit->start   = starts[j*N+i];
	  hit->stop    = stops[j*N+i];
	  hit->score   = scores[j*N+i];
	  hit->seq_idx = seq_idxes[j*N+i];
	  hit->cm_idx  = cm_idxes[j*N+i];
	  hit->srcL    = L;
	  if     (hit->start < hit->stop) { hit->in_rc = FALSE; }
	  else if(hit->start > hit->stop) { hit->in_rc = TRUE;  }
	  else                            { hit->in_rc = (esl_rnd_Roll(r, 2) == 0) ? FALSE : TRUE; }
	}
	  if(esl_opt_GetBoolean(go, "-v")) cm_tophits_Dump(stdout, h[j]);
	}

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time hit creation:                                  ");
  esl_stopwatch_Start(w);

  /* then merge them into one big list in h[0] */
  for (j = 1; j < M; j++)
	{
	  cm_tophits_Merge(h[0], h[j]);
	  cm_tophits_Destroy(h[j]);
	}
  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_Merge():                            ");
  esl_stopwatch_Start(w);

  cm_tophits_SortForOverlapRemoval(h[0]);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_SortForOverlapRemoval():            ");
  esl_stopwatch_Start(w);

  if(esl_opt_GetBoolean(go, "-v")) cm_tophits_Dump(stdout, h[0]);

  if((status = cm_tophits_RemoveOrMarkOverlaps(h[0], /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_RemoveOrMarkOverlaps() (removing):  ");
  esl_stopwatch_Start(w);

  cm_tophits_SortForOverlapMarkup(h[0], FALSE);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_SortForOverlapMarkup():             ");
  esl_stopwatch_Start(w);

  if((status = cm_tophits_RemoveOrMarkOverlaps(h[0], /*do_clans=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);

  if(esl_opt_GetBoolean(go, "-v")) cm_tophits_Dump(stdout, h[0]);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_RemoveOrMarkOverlaps() (marking):   ");
  esl_stopwatch_Start(w);

  cm_tophits_SortByEvalue(h[0]);

  esl_stopwatch_Stop(w);
  esl_stopwatch_Display(stdout, w, "# CPU time cm_tophits_SortByEvalue():                     ");

  if(esl_opt_GetBoolean(go, "-v")) cm_tophits_Dump(stdout, h[0]);

  /* determine number of valid (not removed) hits */
  nhits = 0;
  nhits_unmarked = 0;
  for(i = 0; i < h[0]->N; i++) {
	if(! (h[0]->hit[i]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) {
	  nhits++;
	}
	if(! (h[0]->hit[i]->flags & CM_HIT_IS_MARKED_OVERLAP)) {
	  nhits_unmarked++;
	}
  }

  printf("# number of lists:               %d\n", M);
  printf("# sequence length                %d\n", L);
  printf("# number of sequences            %d\n", X);
  printf("# number of models               %d\n", Y);
  printf("# initial number of hits         %d\n", N*M);
  printf("# hit length                     %d\n", hitlen);
  printf("# number of non-removed hits     %d\n", nhits);
  printf("# number of non-marked  hits     %d\n", nhits_unmarked);

  cm_tophits_Destroy(h[0]);
  status = eslOK;

 ERROR:
  esl_getopts_Destroy(go);
  esl_stopwatch_Destroy(w);
  esl_randomness_Destroy(r);
  if (scores    != NULL) free(scores);
  if (seq_idxes != NULL) free(seq_idxes);
  if (cm_idxes  != NULL) free(cm_idxes);
  if (starts    != NULL) free(starts);
  if (stops     != NULL) free(stops);
  if (h         != NULL) free(h);
  return status;
}
#endif /*CM_TOPHITS_BENCHMARK*/
/*****************************************************************
 * 5. Test driver
 *****************************************************************/

#ifdef CM_TOPHITS_TESTDRIVE
/*
  gcc -o cm_tophits_utest -std=gnu99 -g -O2 -I. -L. -I../hmmer/src -L../hmmer/src -I../easel -L../easel -DCM_TOPHITS_TESTDRIVE cm_tophits.c -linfernal -lhmmer -leasel -lm
  ./cm_tophits_utest
*/


#include <stdlib.h>
#include <stdio.h>


static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",             0 },
  { "-s",        eslARG_INT,    "181", NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>",                    0 },
  { "-N",        eslARG_INT,    "100", NULL, NULL,  NULL,  NULL, NULL, "number of top hits to simulate",                   0 },
  { "-X",        eslARG_INT,   "1000", NULL, NULL,  NULL,  NULL, NULL, "number of target sequences hits can come from",    0 },
  { "-Y",        eslARG_INT,     "10", NULL, NULL,  NULL,  NULL, NULL, "number of CMs hits can be to",                     0 },
  { "-L",        eslARG_INT, "100000", NULL, NULL,  NULL,  NULL, NULL, "length of target sequences",                       0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};

static char usage[]  = "[-options]";
static char banner[] = "test driver for CM_TOPHITS";

int
main(int argc, char **argv)
{
  ESL_GETOPTS    *go       = cm_CreateDefaultApp(options, 0, argc, argv, banner, usage);
  ESL_RANDOMNESS *r        = esl_randomness_CreateFast(esl_opt_GetInteger(go, "-s"));
  int             N        = esl_opt_GetInteger(go, "-N");
  int             L        = esl_opt_GetInteger(go, "-L");
  int             X        = esl_opt_GetInteger(go, "-X");
  int             Y        = esl_opt_GetInteger(go, "-Y");
  CM_TOPHITS     *h1       = NULL;
  CM_TOPHITS     *h2       = NULL;
  CM_TOPHITS     *h3       = NULL;
  CM_TOPHITS     *h4       = NULL;
  CM_TOPHITS     *h5       = NULL;
  char            name[]   = "not_unique_name";
  char            acc[]    = "not_unique_acc";
  char            desc[]   = "Test description for the purposes of making the test driver allocate space";
  CM_HIT         *hit = NULL;
  int             i;
  int             status;
  char            errbuf[eslERRBUFSIZE];

  h1 = cm_tophits_Create();
  h2 = cm_tophits_Create();
  h3 = cm_tophits_Create();
  h4 = cm_tophits_Create();
  h5 = cm_tophits_Create();

  for (i = 0; i < N; i++)
	{
	  /* add hit to h1 */
	  cm_tophits_CreateNextHit(h1, &hit);
	  esl_strdup(name, -1, &(hit->name));
	  esl_strdup(acc,  -1, &(hit->acc));
	  esl_strdup(desc, -1, &(hit->desc));
	  hit->start   = esl_rnd_Roll(r, L);
	  hit->stop    = esl_rnd_Roll(r, L);
	  hit->score   = esl_random(r);
	  hit->evalue  = esl_random(r) + 5.0 * (double) (esl_rnd_Roll(r, 10) + 1); /* impt that this is greater than 0.1 and less than 200 */
	  hit->seq_idx = esl_rnd_Roll(r, X);
	  hit->cm_idx  = esl_rnd_Roll(r, Y);
	  hit->srcL    = L;

	  /* add hit to h2 */
	  cm_tophits_CreateNextHit(h2, &hit);
	  esl_strdup(name, -1, &(hit->name));
	  esl_strdup(acc,  -1, &(hit->acc));
	  esl_strdup(desc, -1, &(hit->desc));
	  hit->start   = esl_rnd_Roll(r, L);
	  hit->stop    = esl_rnd_Roll(r, L);
	  hit->score   = esl_random(r);
	  hit->evalue  = esl_random(r) + 1.0 * (double) (esl_rnd_Roll(r, 10) + 1); /* impt that this is greater than 0.1 and less than 200 */
	  hit->seq_idx = esl_rnd_Roll(r, X);
	  hit->cm_idx  = esl_rnd_Roll(r, Y);
	  hit->srcL    = L;

	  /* add hit to h3 */
	  cm_tophits_CreateNextHit(h3, &hit);
	  esl_strdup(name, -1, &(hit->name));
	  esl_strdup(acc,  -1, &(hit->acc));
	  esl_strdup(desc, -1, &(hit->desc));
	  hit->start   = esl_rnd_Roll(r, L);
	  hit->stop    = esl_rnd_Roll(r, L);
	  hit->score   = esl_random(r);
	  hit->evalue  = esl_random(r) + 10.0 * (double) (esl_rnd_Roll(r, 10) + 1); /* impt that this is greater than 0.1 and less than 200 */
	  hit->seq_idx = esl_rnd_Roll(r, X);
	  hit->cm_idx  = esl_rnd_Roll(r, Y);
	  hit->srcL    = L;

	  /* add hit to h4 */
	  cm_tophits_CreateNextHit(h4, &hit);
	  esl_strdup(name, -1, &(hit->name));
	  esl_strdup(acc,  -1, &(hit->acc));
	  esl_strdup(desc, -1, &(hit->desc));
	  hit->start   = esl_rnd_Roll(r, L);
	  hit->stop    = esl_rnd_Roll(r, L);
	  hit->score   = esl_random(r);
	  hit->evalue  = esl_random(r) + 15.0 * (double) (esl_rnd_Roll(r, 10) + 1); /* impt that this is greater than 0.1 and less than 200 */
	  hit->seq_idx = esl_rnd_Roll(r, X);
	  hit->cm_idx  = esl_rnd_Roll(r, Y);
	  hit->srcL    = L;
	}

  /* add a few more hits */
  cm_tophits_CreateNextHit(h1, &hit);
  esl_strdup("third", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 20.0;
  hit->evalue  = 0.1;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h2, &hit);
  esl_strdup("second", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 30.0;
  hit->evalue  = 0.01;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h3, &hit);
  esl_strdup("first", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 40.0;
  hit->evalue  = 0.001;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h1, &hit);
  esl_strdup("thirdtolast", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -1.0;
  hit->evalue  = 200.0;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h2, &hit);
  esl_strdup("secondtolast", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -11.0;
  hit->evalue  = 210.0;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h3, &hit);
  esl_strdup("last", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -21.0;
  hit->evalue  = 220.0;
  hit->cm_idx  = 0;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  /* add similar hits with a different model, to test overlap markup
   * (as opposed to overlap removal which was tested above)
   */
  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Bthird", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 20.0;
  hit->evalue  = 0.09;
  hit->cm_idx  = 1;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Bsecond", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 30.0;
  hit->evalue  = 0.009;
  hit->cm_idx  = 2;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Bfirst", -1, &(hit->name));
  hit->start   = L;
  hit->stop    = L;
  hit->score   = 40.0;
  hit->evalue  = 0.0009;
  hit->cm_idx  = 3;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Bthirdtolast", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -1.;
  hit->evalue  = 201.0;
  hit->cm_idx  = 4;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Bsecondtolast", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -11.;
  hit->evalue  = 211.0;
  hit->cm_idx  = 5;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_CreateNextHit(h4, &hit);
  esl_strdup("Blast", -1, &(hit->name));
  hit->start   = L+1;
  hit->stop    = L+1;
  hit->score   = -21.;
  hit->evalue  = 221.0;
  hit->cm_idx  = 6;
  hit->seq_idx = 0;
  hit->srcL    = L+1;

  cm_tophits_SortForOverlapRemoval(h1);
  if((status = cm_tophits_RemoveOrMarkOverlaps(h1, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
  cm_tophits_SortByEvalue(h1);
  if (strcmp(h1->hit[0]->name,   "third")        != 0)   esl_fatal("sort 1 failed (top is %s = %f)",  h1->hit[0]->name,   h1->hit[0]->score);
  if (strcmp(h1->hit[N+1]->name, "thirdtolast")  != 0)   esl_fatal("sort 1 failed (last is %s = %f)", h1->hit[N+1]->name, h1->hit[N+1]->score);

  cm_tophits_Merge(h1, h2);
  cm_tophits_SortForOverlapRemoval(h1);
  if((status = cm_tophits_RemoveOrMarkOverlaps(h1, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
  cm_tophits_SortByEvalue(h1);
  if (strcmp(h1->hit[0]->name,     "second")        != 0)   esl_fatal("sort 2 failed (top is %s = %f)",            h1->hit[0]->name,     h1->hit[0]->score);
  if (strcmp(h1->hit[1]->name,     "third")         != 0)   esl_fatal("sort 2 failed (second is %s = %f)",         h1->hit[1]->name,     h1->hit[1]->score);
  if (strcmp(h1->hit[2*N+2]->name, "thirdtolast")   != 0)   esl_fatal("sort 2 failed (second to last is %s = %f)", h1->hit[2*N+2]->name, h1->hit[2*N+2]->score);
  if (strcmp(h1->hit[2*N+3]->name, "secondtolast")  != 0)   esl_fatal("sort 2 failed (last is %s = %f)",           h1->hit[2*N+3]->name, h1->hit[2*N+3]->score);
  if (   h1->hit[0]->flags     & CM_HIT_IS_REMOVED_DUPLICATE)  esl_fatal("RemoveOrMarkOverlaps failed 1");
  if (! (h1->hit[1]->flags     & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 2");
  if (   h1->hit[2*N+2]->flags & CM_HIT_IS_REMOVED_DUPLICATE)  esl_fatal("RemoveOrMarkOverlaps failed 3");
  if (! (h1->hit[2*N+3]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 4");

  cm_tophits_Merge(h1, h3);
  cm_tophits_SortForOverlapRemoval(h1);
  if((status = cm_tophits_RemoveOrMarkOverlaps(h1, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
  cm_tophits_SortByEvalue(h1);
  if (strcmp(h1->hit[0]->name,     "first")         != 0)   esl_fatal("sort 3 failed (top    is %s = %f)",         h1->hit[0]->name,     h1->hit[0]->score);
  if (strcmp(h1->hit[1]->name,     "second")        != 0)   esl_fatal("sort 3 failed (second is %s = %f)",         h1->hit[1]->name,     h1->hit[1]->score);
  if (strcmp(h1->hit[2]->name,     "third")         != 0)   esl_fatal("sort 3 failed (third  is %s = %f)",         h1->hit[2]->name,     h1->hit[2]->score);
  if (strcmp(h1->hit[3*N+3]->name, "thirdtolast")   != 0)   esl_fatal("sort 3 failed (third to last is %s = %f)",  h1->hit[3*N+3]->name, h1->hit[3*N+3]->score);
  if (strcmp(h1->hit[3*N+4]->name, "secondtolast")  != 0)   esl_fatal("sort 3 failed (second to last is %s = %f)", h1->hit[3*N+4]->name, h1->hit[3*N+4]->score);
  if (strcmp(h1->hit[3*N+5]->name, "last")          != 0)   esl_fatal("sort 3 failed (last is %s = %f)",           h1->hit[3*N+5]->name, h1->hit[3*N+5]->score);
  if (   h1->hit[0]->flags     & CM_HIT_IS_REMOVED_DUPLICATE)  esl_fatal("RemoveOrMarkOverlaps failed 5");
  if (! (h1->hit[1]->flags     & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 6");
  if (! (h1->hit[2]->flags     & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 7");
  if (   h1->hit[3*N+3]->flags & CM_HIT_IS_REMOVED_DUPLICATE)  esl_fatal("RemoveOrMarkOverlaps failed 8");
  if (! (h1->hit[3*N+4]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 9");
  if (! (h1->hit[3*N+5]->flags & CM_HIT_IS_REMOVED_DUPLICATE)) esl_fatal("RemoveOrMarkOverlaps failed 10");

  /* test markup, first sort for removal and make sure we don't mark up any overlaps of different models */
  cm_tophits_Merge(h1, h4);
  cm_tophits_SortForOverlapRemoval(h1);
  if((status = cm_tophits_RemoveOrMarkOverlaps(h1, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
  cm_tophits_SortByEvalue(h1);
  if (strcmp(h1->hit[0]->name,     "Bfirst")        != 0)   esl_fatal("sort 4 failed (first  is %s = %f)",         h1->hit[0]->name,      h1->hit[0]->score);
  if (strcmp(h1->hit[1]->name,     "first")         != 0)   esl_fatal("sort 4 failed (second is %s = %f)",         h1->hit[1]->name,      h1->hit[1]->score);
  if (strcmp(h1->hit[2]->name,     "Bsecond")       != 0)   esl_fatal("sort 4 failed (third  is %s = %f)",         h1->hit[2]->name,      h1->hit[2]->score);
  if (strcmp(h1->hit[3]->name,     "second")        != 0)   esl_fatal("sort 4 failed (fourth is %s = %f)",         h1->hit[3]->name,      h1->hit[3]->score);
  if (strcmp(h1->hit[4]->name,     "Bthird")        != 0)   esl_fatal("sort 4 failed (fifth  is %s = %f)",         h1->hit[4]->name,      h1->hit[4]->score);
  if (strcmp(h1->hit[5]->name,     "third")         != 0)   esl_fatal("sort 4 failed (sixth  is %s = %f)",         h1->hit[5]->name,      h1->hit[5]->score);
  if (strcmp(h1->hit[4*N+6]->name, "thirdtolast")   != 0)   esl_fatal("sort 4 failed (sixth to last is %s = %f)",  h1->hit[4*N+6]->name,  h1->hit[4*N+6]->score);
  if (strcmp(h1->hit[4*N+7]->name, "Bthirdtolast")  != 0)   esl_fatal("sort 4 failed (fifth to last is %s = %f)",  h1->hit[4*N+7]->name,  h1->hit[4*N+7]->score);
  if (strcmp(h1->hit[4*N+8]->name, "secondtolast")  != 0)   esl_fatal("sort 4 failed (fourth to last is %s = %f)", h1->hit[4*N+8]->name,  h1->hit[4*N+8]->score);
  if (strcmp(h1->hit[4*N+9]->name, "Bsecondtolast") != 0)   esl_fatal("sort 4 failed (third to last is %s = %f)",  h1->hit[4*N+9]->name,  h1->hit[4*N+9]->score);
  if (strcmp(h1->hit[4*N+10]->name, "last")         != 0)   esl_fatal("sort 4 failed (second to last is %s = %f)", h1->hit[4*N+10]->name, h1->hit[4*N+10]->score);
  if (strcmp(h1->hit[4*N+11]->name, "Blast")        != 0)   esl_fatal("sort 4 failed (last is %s = %f)",           h1->hit[4*N+11]->name, h1->hit[4*N+11]->score);
  if (h1->hit[0]->flags      & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 11");
  if (h1->hit[1]->flags      & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 12");
  if (h1->hit[4*N+6]->flags  & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 13");
  if (h1->hit[4*N+7]->flags  & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 14");

  /* second sort for markup and make sure we DO mark up overlaps of different models */
  cm_tophits_SortForOverlapMarkup(h1, /*do_clans_only=*/FALSE);
  if((status = cm_tophits_RemoveOrMarkOverlaps(h1, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
  cm_tophits_SortByEvalue(h1);
  if (strcmp(h1->hit[0]->name,      "Bfirst")        != 0)     esl_fatal("sort 5 failed (first  is %s = %f)",         h1->hit[0]->name,      h1->hit[0]->score);
  if (strcmp(h1->hit[1]->name,      "first")         != 0)     esl_fatal("sort 5 failed (second is %s = %f)",         h1->hit[1]->name,      h1->hit[1]->score);
  if (strcmp(h1->hit[2]->name,      "Bsecond")       != 0)     esl_fatal("sort 5 failed (third  is %s = %f)",         h1->hit[2]->name,      h1->hit[2]->score);
  if (strcmp(h1->hit[3]->name,      "second")        != 0)     esl_fatal("sort 5 failed (fourth is %s = %f)",         h1->hit[3]->name,      h1->hit[3]->score);
  if (strcmp(h1->hit[4]->name,      "Bthird")        != 0)     esl_fatal("sort 5 failed (fifth  is %s = %f)",         h1->hit[4]->name,      h1->hit[4]->score);
  if (strcmp(h1->hit[5]->name,      "third")         != 0)     esl_fatal("sort 5 failed (sixth  is %s = %f)",         h1->hit[5]->name,      h1->hit[5]->score);
  if (strcmp(h1->hit[4*N+6]->name,  "thirdtolast")   != 0)     esl_fatal("sort 5 failed (sixth to last is %s = %f)",  h1->hit[4*N+6]->name,  h1->hit[4*N+6]->score);
  if (strcmp(h1->hit[4*N+7]->name,  "Bthirdtolast")  != 0)     esl_fatal("sort 5 failed (fifth to last is %s = %f)",  h1->hit[4*N+7]->name,  h1->hit[4*N+7]->score);
  if (strcmp(h1->hit[4*N+8]->name,  "secondtolast")  != 0)     esl_fatal("sort 5 failed (fourth to last is %s = %f)", h1->hit[4*N+8]->name,  h1->hit[4*N+8]->score);
  if (strcmp(h1->hit[4*N+9]->name,  "Bsecondtolast") != 0)     esl_fatal("sort 5 failed (third to last is %s = %f)",  h1->hit[4*N+9]->name,  h1->hit[4*N+9]->score);
  if (strcmp(h1->hit[4*N+10]->name, "last")          != 0)     esl_fatal("sort 5 failed (second to last is %s = %f)", h1->hit[4*N+10]->name, h1->hit[4*N+10]->score);
  if (strcmp(h1->hit[4*N+11]->name, "Blast")         != 0)     esl_fatal("sort 5 failed (last is %s = %f)",           h1->hit[4*N+11]->name, h1->hit[4*N+11]->score);
  if (   h1->hit[0]->flags      & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 15");
  if (   h1->hit[0]->flags      & CM_HIT_IS_MARKED_OVERLAP)    esl_fatal("RemoveOrMarkOverlaps failed 16");
  if (   h1->hit[1]->flags      & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 17");
  if (! (h1->hit[1]->flags      & CM_HIT_IS_MARKED_OVERLAP))   esl_fatal("RemoveOrMarkOverlaps failed 18");
  if (   h1->hit[4*N+6]->flags  & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 19");
  if (   h1->hit[4*N+6]->flags  & CM_HIT_IS_MARKED_OVERLAP)    esl_fatal("RemoveOrMarkOverlaps failed 20");
  if (   h1->hit[4*N+7]->flags  & CM_HIT_IS_REMOVED_DUPLICATE) esl_fatal("RemoveOrMarkOverlaps failed 21");
  if (! (h1->hit[4*N+7]->flags  & CM_HIT_IS_MARKED_OVERLAP))   esl_fatal("RemoveOrMarkOverlaps failed 22");

  if (h1->hit[1]->any_oidx     != (4*N)+9-1)  esl_fatal("RemoveOrMarkOverlaps failed 23");
  if (h1->hit[1]->win_oidx     != (4*N)+9-1)  esl_fatal("RemoveOrMarkOverlaps failed 24");

  /* One final test of the overlap any_oidx and win_oidx values,
   * with a fabricated example of a rare case where they're not identical.
   * We do this in two passes, the first pass will only do 5 hits and
   * will use the function remove_or_mark_overlaps_one_seq_memeff(),
   * the second will do 5005 hits and so will use the function
   * remove_or_mark_overlaps_one_seq_fast().
   */
  int p, z;
  for(p = 0; p <= 1; p++) {
	if(p > 0) {
	  cm_tophits_Destroy(h5);
	  h5 = cm_tophits_Create();
	}

	cm_tophits_CreateNextHit(h5, &hit);
	esl_strdup("hit1", -1, &(hit->name));
	hit->start   = 1;
	hit->stop    = 200;
	hit->score   = 100.;
	hit->evalue  = 0.0001;
	hit->cm_idx  = 0;
	hit->seq_idx = 0;
	hit->srcL    = 20000;

	cm_tophits_CreateNextHit(h5, &hit);
	esl_strdup("hit2", -1, &(hit->name));
	hit->start   = 1;
	hit->stop    = 300;
	hit->score   = 90.;
	hit->evalue  = 0.001;
	hit->cm_idx  = 1;
	hit->seq_idx = 0;
	hit->srcL    = 20000;

	cm_tophits_CreateNextHit(h5, &hit);
	esl_strdup("hit3", -1, &(hit->name));
	hit->start   = 305;
	hit->stop    = 500;
	hit->score   = 80.;
	hit->evalue  = 0.01;
	hit->cm_idx  = 2;
	hit->seq_idx = 0;
	hit->srcL    = 20000;

	cm_tophits_CreateNextHit(h5, &hit);
	esl_strdup("hit4", -1, &(hit->name));
	hit->start   = 201;
	hit->stop    = 500;
	hit->score   = 70.;
	hit->evalue  = 0.1;
	hit->cm_idx  = 3;
	hit->seq_idx = 0;
	hit->srcL    = 20000;

	cm_tophits_CreateNextHit(h5, &hit);
	esl_strdup("hit5", -1, &(hit->name));
	hit->start   = 201;
	hit->stop    = 299;
	hit->score   = 60.;
	hit->evalue  = 1;
	hit->cm_idx  = 4;
	hit->seq_idx = 0;
	hit->srcL    = 20000;

	if(p > 0) {
	  for(z = 0; z < 10000; z++) {
		cm_tophits_CreateNextHit(h5, &hit);
		esl_strdup("extrahit", -1, &(hit->name));
		hit->start   = 1000 + z;
		hit->stop    = 1000 + z;
		hit->score   = 30.;
		hit->evalue  = 5;
		hit->cm_idx  = 5;
		hit->seq_idx = 0;
		hit->srcL    = 20000;
	  }
	}

	cm_tophits_SortForOverlapRemoval(h5);
	if((status = cm_tophits_RemoveOrMarkOverlaps(h5, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);
	cm_tophits_SortForOverlapMarkup(h5, /*do_clans_only=*/FALSE);
	if((status = cm_tophits_RemoveOrMarkOverlaps(h5, /*do_clans_only=*/FALSE, errbuf)) != eslOK) cm_Fail(errbuf);

	cm_tophits_SortByEvalue(h5);
	if (strcmp(h5->hit[0]->name,  "hit1")  != 0)     esl_fatal("sort 6 failed pass %d (first  is %s = %f)", p+1,    h5->hit[0]->name,      h5->hit[0]->score);
	if (strcmp(h5->hit[1]->name,  "hit2")  != 0)     esl_fatal("sort 6 failed pass %d (first  is %s = %f)", p+1,    h5->hit[1]->name,      h5->hit[1]->score);
	if (strcmp(h5->hit[2]->name,  "hit3")  != 0)     esl_fatal("sort 6 failed pass %d (first  is %s = %f)", p+1,    h5->hit[2]->name,      h5->hit[2]->score);
	if (strcmp(h5->hit[3]->name,  "hit4")  != 0)     esl_fatal("sort 6 failed pass %d (first  is %s = %f)", p+1,    h5->hit[3]->name,      h5->hit[3]->score);
	if (strcmp(h5->hit[4]->name,  "hit5")  != 0)     esl_fatal("sort 6 failed pass %d (first  is %s = %f)", p+1,    h5->hit[4]->name,      h5->hit[4]->score);

	if (h5->hit[0]->any_oidx != -1) esl_fatal("RemoveOrMarkOverlaps failed 25 (pass %d)", p+1);
	if (h5->hit[0]->win_oidx != -1) esl_fatal("RemoveOrMarkOverlaps failed 26 (pass %d)", p+1);

	if (h5->hit[1]->any_oidx != 0)  esl_fatal("RemoveOrMarkOverlaps failed 27 (pass %d)", p+1);
	if (h5->hit[1]->any_oidx != 0)  esl_fatal("RemoveOrMarkOverlaps failed 28 (pass %d)", p+1);

	if (h5->hit[2]->any_oidx != -1) esl_fatal("RemoveOrMarkOverlaps failed 29 (pass %d)", p+1);
	if (h5->hit[2]->win_oidx != -1) esl_fatal("RemoveOrMarkOverlaps failed 30 (pass %d)", p+1);

	if (h5->hit[3]->any_oidx != 1)  esl_fatal("RemoveOrMarkOverlaps failed 31 (pass %d)", p+1);
	if (h5->hit[3]->win_oidx != 2)  esl_fatal("RemoveOrMarkOverlaps failed 32 (pass %d)", p+1);

	if (h5->hit[4]->any_oidx != 1)  esl_fatal("RemoveOrMarkOverlaps failed 33 (pass %d)", p+1);
	if (h5->hit[4]->win_oidx != -1) esl_fatal("RemoveOrMarkOverlaps failed 34 (pass %d)", p+1);

  } /* end of 'for(p = 0; p <= 1; p++)' */

  if (cm_tophits_GetMaxNameLength(h1) != strlen(name)) esl_fatal("GetMaxNameLength() failed");

  cm_tophits_Destroy(h1);
  cm_tophits_Destroy(h2);
  cm_tophits_Destroy(h3);
  cm_tophits_Destroy(h4);
  cm_tophits_Destroy(h5);
  esl_randomness_Destroy(r);
  esl_getopts_Destroy(go);
  return eslOK;
}
#endif /*CM_TOPHITS_TESTDRIVE*/
/*****************************************************************
 * Infernal - inference of RNA secondary structure alignments
 * Version 1.1.2; July 2016
 * Copyright (C) 2016 Howard Hughes Medical Institute.
 * Other copyrights also apply. See the COPYRIGHT file for a full list.
 *
 * Infernal is distributed under the terms of the GNU General Public License
 * (GPLv3). See the LICENSE file for details.
 *****************************************************************/

/*** End of inlined file: cm_tophits.c ***/


/*** Start of inlined file: cm_trunc.c ***/


#include <stdlib.h>
#include <string.h>
#include <limits.h>


/*****************************************************************
 *   1. CM_TR_PENALTIES data structure functions,
 *       info on truncated alignment score penalties.
 *****************************************************************/

/* Function: cm_tr_penalties_Create()
 * Date:     EPN, Sat Jan 21 12:03:52 2012
 *
 * Purpose:  Allocate and initialize a CM_TR_PENALTIES object.
 *           A CM and its emit map are required to determine
 *           truncation penalty scores. This is annoyingly
 *           complex, see verbose notes within code below.
 *
 *           Some of the code in this function, specifically
 *           that which calculates the probability of a fragment
 *           aligning at a given node, is checkable, but only
 *           if we disallow truncated begins into insert states.
 *           However, we want to allow truncated begins in reality.
 *           I've left in a flag for ignoring inserts (<ignore_inserts>)
 *           I used in testing this function. Set it to TRUE to
 *           perform the test.
 *
 * Returns:  Newly allocated CM_TR_PENALTIES object. NULL if out
 *           of memory.
 */
CM_TR_PENALTIES *
cm_tr_penalties_Create(CM_t *cm, int ignore_inserts, char *errbuf)
{
  int status;
  int v, nd, m, i1, i2;
  int lpos, rpos;
  int i;

  /* variables used for determining ratio of inserts to match at each consensus position */
  float   *mexpocc  = NULL;  /* [0..c..clen] probability match  state is used to emit at cons posn c */
  float   *iexpocc  = NULL;  /* [0..c..clen] probability insert state is used to emit after cons posn c */
  double  *psi      = NULL;  /* [0..v..M-1]  expected occupancy of state v */
  float    m_psi, i1_psi, i2_psi; /* temp psi values */
  float    summed_psi;
  CM_TR_PENALTIES *trp = NULL;

  /* variables used for calculating global truncation penalties */
  float g_5and3; /* fragment probability if 5' and 3' truncation are allowed */
  float g_5or3;  /* fragment probability if 5' or  3' truncation are allowed */

  /* variables used for calculating local truncation penalties */
  float *begin = NULL;           /* local begin probabilities 0..v..M-1 */
  int   subtree_clen;            /* consensus length of subtree under this node */
  float prv53, prv5, prv3;       /* previous node's fragment probability, 5'&3', 5' only, 3'only */
  float cur53, cur5, cur3;       /* current node's fragment probability, 5'&3', 5' only, 3'only */
  int   nfrag53, nfrag5, nfrag3; /* number of fragments, 5'&3', 5' only, 3'only */

  if(cm == NULL || cm->emap == NULL) goto ERROR;

  ESL_ALLOC(trp, sizeof(CM_TR_PENALTIES));

  trp->M = cm->M;
  trp->ignored_inserts = ignore_inserts;

  /* Define truncation penalties for each state v. This will be
   * the score for doing a truncated begin into state v.
   *
   * Important note: For this discussion we assume that sequences can
   * only be truncated at consensus positions, which means we don't
   * have to worry about truncated begins into inserts. This is an
   * approximation (also made by Diana and Sean in the 2009 trCYK
   * paper) that greatly simplifies the explanation of the calculation
   * of the truncation penalties.  The examples in my ELN3 notebook
   * also use this simplification. However, I need to be able to do
   * truncated begins into insert states in some cases (some pass/mode
   * combinations see ELN bottom of p.47). I explain first the
   * rationale for calculating truncation penalties ignoring inserts
   * and then I describe how I adapt those penalties to allow
   * for inserts.
   *
   * This is a lengthy comment. I've divided it into 3 sections:
   * Section 1. Global mode truncation penalties, ignoring inserts.
   * Section 2. Local mode truncation penalties, ignoring inserts.
   * Section 3. Adapting truncation penalties to allow for inserts.
   *
   **************************************************************
   * Section 1. Global mode truncation penalties, ignoring inserts.
   *
   * We want the truncation penalty to be the log of the probability
   * that the particular fragment we're aligning was generated from
   * the following generative process. The generative process differs
   * between global and local mode.
   *
   * In global mode:
   * o Sample global parsetree which spans consensus positions 1..clen.
   * o Randomly choose g and h in range 1..clen, where h >= g and
   *   truncate sequence from g..h. The first residue will either be
   *   an insert before position g, or a match at position g of the
   *   model. The final residue will either be an insert after position
   *   h or a match at position h of the model.
   *
   * All g,h fragments are equiprobable, so the probability of any
   * particular fragment is 2 / (clen * (clen+1)). So log_2 of this
   * value is the truncation penalty for all truncated alignments in
   * global mode where both 5' and 3' truncation are allowed.
   *
   * We store this penalty, per-state in the
   * g_ptyAA[TRPENALTY_5P_AND_3P][0..v..M-1].  The penalty is
   * identical for all emitting states. The penalty value for
   * non-emitters is IMPOSSIBLE because truncated begins are
   * not allowed into non-emitters.
   *
   * If only 5' OR 3' truncation is allowed, we only truncate at g or
   * h, which menas there's 1/clen possible fragments and log_2
   * (1/clen) is our global truncation penalty.
   *
   * However, if 5' truncation is allowed we can only do a truncated
   * begin into states that with a consensus subtree that spans
   * position clen (since we don't allow a truncation at the 3' end).
   * Thus any state whose subtree that doesn't span clen gets
   * an IMPOSSIBLE value for its truncation score in:
   * g_ptyAA[TRPENALTY_5P_ONLY][0..v..M-1].
   *
   * Likewise, if 3' truncation is allowed we can only do a truncated
   * begin into states that with a consensus subtree that spans
   * position 1 (since we don't allow a truncation at the 5' end).
   *
   * There's an example of computing all three types of penalties for
   * a simple CM in ELN 3 p43.
   *
   ************************************************************
   * Section 2. Local mode truncation penalties, ignoring inserts.
   *
   * Generative process that generates fragments in local mode:
   * o Sample local begin state b with consensus subtree from i..j from
   *   local begin state distribution.
   * o Randomly choose g and h in range i..j, where h >= g and
   *   truncate sequence from g..h. The first residue will either be
   *   an insert before position g, or a match at position g of the
   *   model. The final residue will either be an insert after position
   *   h or a match at position h of the model.
   *
   * Unlike in global mode, in local mode all fragments are not
   * equiprobable since the local begin state distribution can be
   * anything, and each b allows different sets of fragments to be
   * generated (because they can only span from i to j).
   *
   * The truncation penalty should be the log of the probability of
   * aligning the current fragment to the model. So we need to know
   * the probability of generating each possible fragment.
   * We could calculate probability of any fragment g,h with the
   * following inefficient algorithm:
   *
   * For each start fragment point g,
   *   For each start fragment point h,
   *     For each state v,
   *       If lpos[v] <= g && rpos[v] >= h, then
   *       prob[g][h] += begin[v] * 2. / (st_clen[v] * (st_clen[v]+1));
   *
   * Where lpos[v]/rpos[v] are the left/right consensus positions in
   * consensus subtree rooted at state v. And st_clen[v] is rpos[v] -
   * lpos[v] + 1, the consensus length of that subtree.
   *
   * This gives us prob[g][h], the probability of generating fragment
   * g,h. But we want to apply the penalty to a state, not to a
   * fragment, to avoid needing to know the fragment boundaries g,h
   * during the DP recursion when applying the penalty.
   *
   * To facilitate this, we need to find state t, the state with
   * smallest subtree that contains g,h. State t is relevant because
   * it is the state which will root the alignment of the fragment g,h
   * by using a truncated begin transition into t. This gives a new
   * algorithm:
   *
   * For each start fragment point g,
   *   For each start fragment point h,
   *     Identify state t, the max valued state for which
   *       lpos[v] <= g && rpos[v] >= h, then {
   *         prob[t] += prob[g][h]
   *         fcount[t]++;
   *       }
   *
   * prob[t] will be the probability of observing an alignment that
   * uses a truncated begin into t to align any fragment. Then we take
   * average over all fragments: prob[t] / fcount[t] (since we'll only
   * be aligning one of those fragments) and use the log of that
   * probability as the penalty for observing a truncated alignment
   * rooted at state t. Conveniently, it turns out that all fragments
   * that share t are equiprobable (have equal prob[g][h] values), so
   * the average probability is the actual probability for each
   * fragment, and thus the correct penalty to apply.
   *
   * Fortunately, we can compute the correct penalty much more
   * efficiently than the two algorithms shown above. The
   * efficient way is implemented below. A test that the penalties
   * are correctly computed is in cm_tr_penalties_Validate().
   *
   * This discussion assumes we're truncating 5' and 3', but if we're
   * only truncating 5' or 3' The situation is a little different.
   *
   * There's an example of computing all three types of penalties for
   * a simple CM in ELN3 p44-45.
   *
   ************************************************************
   * Section 3. Adapting truncation penalties to allow for inserts.
   *
   * We need to be able to do truncated begins into insert states
   * because we enforce that the first/final residue of a sequence be
   * included in 5'/3' truncated alignments and we want to be able
   * to properly align those residues if they're probably emitted
   * by insert states.
   *
   * The methods/logic explained in sections 1 and 2 above I believe
   * is correct IF we ignore inserts (assume truncated begins into
   * them are impossible). But we need to allow inserts, so I modify
   * the truncation penalties as described above to allow for inserts
   * as follows. We can calculate the appropriate truncated begin
   * penalty for all MATP_MP, MATL_ML, MATR_MR, BIF_B states as with
   * the methods described above by ignoring inserts. This gives us a
   * probability p of using that state as the root of the truncated
   * alignment, i.e. the truncated begin state. (The log_2 of this
   * probability is the penalty.) We then partition p amongst the
   * MATP_MP, MATL_ML, MATR_MR, BIF_B states and any parent insert
   * states, i.e. any insert state that can transition into the
   * match/bif state. For each match/bif state there's 0, 1 or 2
   * parent inserts. We then partition p based on the relative
   * expected occupancy of these inserts versus the match/bif state.
   *
   * This is certainly 'incorrect' in that it doesn't reflect the
   * true probability of a fragment being aligned to each of the
   * states, but it should be a close approximation. I think doing
   * it correctly is basically impossible in the context of a single
   * state-specific penalty (i.e. the penalty would have to be per-fragment
   * which would be hard to deal with in the DP functions).
   */

  /* allocate and initialize the penalty arrays */
  ESL_ALLOC(trp->g_ptyAA,  sizeof(float *) * NTRPENALTY);
  ESL_ALLOC(trp->l_ptyAA,  sizeof(float *) * NTRPENALTY);
  ESL_ALLOC(trp->ig_ptyAA, sizeof(int *)   * NTRPENALTY);
  ESL_ALLOC(trp->il_ptyAA, sizeof(int *)   * NTRPENALTY);

  for(i = 0; i < NTRPENALTY; i++) {
	trp->g_ptyAA[i]  = NULL;
	trp->l_ptyAA[i]  = NULL;
	trp->il_ptyAA[i] = NULL;
	trp->ig_ptyAA[i] = NULL;
	ESL_ALLOC(trp->g_ptyAA[i],  sizeof(float) * cm->M);
	ESL_ALLOC(trp->l_ptyAA[i],  sizeof(float) * cm->M);
	ESL_ALLOC(trp->ig_ptyAA[i], sizeof(int)   * cm->M);
	ESL_ALLOC(trp->il_ptyAA[i], sizeof(int)   * cm->M);
	esl_vec_FSet(trp->g_ptyAA[i],   cm->M, IMPOSSIBLE);
	esl_vec_FSet(trp->l_ptyAA[i],   cm->M, IMPOSSIBLE);
	esl_vec_ISet(trp->ig_ptyAA[i],  cm->M, -INFTY);
	esl_vec_ISet(trp->il_ptyAA[i],  cm->M, -INFTY);
  }

  /* DumpEmitMap(stdout, cm->emap, cm); */

  /* Calculate local begin probabilities and expected occupancy */
  ESL_ALLOC(begin, sizeof(float) * cm->M);
  cm_CalculateLocalBeginProbs(cm, cm->pbegin, cm->t, begin);
  if((status = cm_ExpectedPositionOccupancy(cm, &mexpocc, &iexpocc, &psi, NULL, NULL, NULL)) != eslOK) goto ERROR;

  /* Fill global and local truncation penalties in a single loop. We
   * step through all nodes and set the truncation penalties for the
   * MATP_MP, MATL_ML, MATR_MR, and BIF_B states and any parent
   * inserts (i1, i2) of those states.
   */
  g_5and3 = 2. / (cm->clen * (cm->clen+1)); /* for global mode: probability of all fragments if we're truncating 5' and 3' */
  g_5or3  = 1. / cm->clen;                  /* for global mode: probability of all fragments if we're only truncating 5' or  3' */

  prv5 = prv3 = prv53 = 0.; /* initialize 'previous' probability values used for calc'ing local truncation penalties */
  for(nd = 0; nd < cm->nodes; nd++) {
	lpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd] + 1;
	rpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd] - 1;

	/* now set penalties for match and insert states m, i1 and maybe i2 (if we're a MATP_MP or BIF_B) */
	if(cm->ndtype[nd] == END_nd) {
	  prv5 = prv3 = prv53 = 0.;
	}
	else if(cm->ndtype[nd] == BEGL_nd || cm->ndtype[nd] == BEGR_nd) {
	  prv5  = (cm->ndtype[nd] == BEGL_nd) ? 0. : trp->l_ptyAA[TRPENALTY_5P_ONLY][cm->plast[cm->nodemap[nd]]];  /* parent BIF_B's probability */;
	  prv3  = (cm->ndtype[nd] == BEGR_nd) ? 0. : trp->l_ptyAA[TRPENALTY_3P_ONLY][cm->plast[cm->nodemap[nd]]];  /* parent BIF_B's probability */;
	  prv53 = trp->l_ptyAA[TRPENALTY_5P_AND_3P][cm->plast[cm->nodemap[nd]]];  /* parent BIF_B's probability */
	}
	else if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BIF_nd) {
	  /* determine match states and insert states that pertain to this node */
	  m = cm->nodemap[nd]; /* MATP_MP, MATL_ML, MATR_MR, or BIF_B */
	  InsertsGivenNodeIndex(cm, nd-1, &i1, &i2);

	  m_psi = psi[m];
	  if(cm->ndtype[nd] == MATP_MP) { m_psi += (psi[m+1] + psi[m+2]); } /* include MATP_ML and MATP_MR psi */
	  i1_psi = (i1 == -1) ? 0. : psi[i1];
	  i2_psi = (i2 == -1) ? 0. : psi[i2];
	  summed_psi = m_psi + i1_psi + i2_psi;
	  if(ignore_inserts) {
	i1_psi = i2_psi = 0.;
	summed_psi = m_psi;
	  }

	  /* Global penalties */
	  /* sanity check, we should only set truncation penalty once per state */
	  if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_AND_3P][m]))  goto ERROR;
	  if((i1 != -1) && NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_AND_3P][i1])) goto ERROR;
	  if((i2 != -1) && NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_AND_3P][i2])) goto ERROR;
	  /* divide up the probability g_5and3 amongst relevant states m, i1, i2, weighted by psi */
	  trp->g_ptyAA[TRPENALTY_5P_AND_3P][m]  = (m_psi  / summed_psi) * g_5and3;
	  if(i1 != -1) trp->g_ptyAA[TRPENALTY_5P_AND_3P][i1] = (i1_psi / summed_psi) * g_5and3;
	  if(i2 != -1) trp->g_ptyAA[TRPENALTY_5P_AND_3P][i2] = (i2_psi / summed_psi) * g_5and3;

	  /* same thing, for 5P only and 3P only */
	  if(rpos == cm->clen) { /* else it will remain IMPOSSIBLE */
	trp->g_ptyAA[TRPENALTY_5P_ONLY][m]  = (m_psi / summed_psi) * g_5or3;
	if(i1 != -1) trp->g_ptyAA[TRPENALTY_5P_ONLY][i1] = (i1_psi / summed_psi) * g_5or3;
	if(i2 != -1) trp->g_ptyAA[TRPENALTY_5P_ONLY][i2] = (i2_psi / summed_psi) * g_5or3;
	  }
	  if(lpos == 1) { /* else it will remain IMPOSSIBLE */
	trp->g_ptyAA[TRPENALTY_3P_ONLY][m]  = (m_psi  / summed_psi) * g_5or3;
	if(i1 != -1) trp->g_ptyAA[TRPENALTY_3P_ONLY][i1] = (i1_psi / summed_psi) * g_5or3;
	if(i2 != -1) trp->g_ptyAA[TRPENALTY_3P_ONLY][i2] = (i2_psi / summed_psi) * g_5or3;
	  }

	  /* Local penalties */
	  subtree_clen = rpos - lpos + 1;
	  nfrag5  = subtree_clen;
	  nfrag3  = subtree_clen;
	  nfrag53 = (subtree_clen * (subtree_clen+1)) / 2;

	  /* determine probability of observing a fragment aligned at
	   * state m (here, m is what I call t above and in notes) and
	   * partition that probability between m and i1 and/or i2 by
	   * relative occupancy of match versus inserts
	   */
	  cur5  = begin[m] / (float) nfrag5  + prv5;
	  cur3  = begin[m] / (float) nfrag3  + prv3;
	  cur53 = begin[m] / (float) nfrag53 + prv53;

	  /* sanity check, we should only set truncation penalty once per state */
	  if(NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_5P_AND_3P][m]))  goto ERROR;
	  if((i1 != -1) && NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_5P_AND_3P][i1])) goto ERROR;
	  if((i2 != -1) && NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_5P_AND_3P][i2])) goto ERROR;

	  trp->l_ptyAA[TRPENALTY_5P_AND_3P][m]  = (m_psi  / summed_psi) * cur53;
	  if(i1 != -1) trp->l_ptyAA[TRPENALTY_5P_AND_3P][i1] = (i1_psi / summed_psi) * cur53;
	  if(i2 != -1) trp->l_ptyAA[TRPENALTY_5P_AND_3P][i2] = (i2_psi / summed_psi) * cur53;

	  trp->l_ptyAA[TRPENALTY_5P_ONLY][m]  = (m_psi  / summed_psi) * cur5;
	  if(i1 != -1) trp->l_ptyAA[TRPENALTY_5P_ONLY][i1] = (i1_psi / summed_psi) * cur5;
	  if(i2 != -1) trp->l_ptyAA[TRPENALTY_5P_ONLY][i2] = (i2_psi / summed_psi) * cur5;

	  trp->l_ptyAA[TRPENALTY_3P_ONLY][m]  = (m_psi  / summed_psi) * cur3;
	  if(i1 != -1) trp->l_ptyAA[TRPENALTY_3P_ONLY][i1] = (i1_psi / summed_psi) * cur3;
	  if(i2 != -1) trp->l_ptyAA[TRPENALTY_3P_ONLY][i2] = (i2_psi / summed_psi) * cur3;

	  prv5  = (cm->ndtype[nd] == MATL_nd) ? cur5 : 0.;
	  prv3  = (cm->ndtype[nd] == MATR_nd) ? cur3 : 0.;
	  prv53 = cur53;
	}
  }

  /* all penalties are currently probabilities, convert them to log
   * probs and set integer penalties (careful, we have to check if
   * IMPOSSIBLE first)
   */
  for(v = 0; v < cm->M; v++)
	{
	  if((cm->stid[v] == MATP_MP || cm->stid[v] == MATL_ML || cm->stid[v] == MATR_MR || cm->stid[v] == BIF_B) ||
	 ((cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) && (! StateIsDetached(cm, v))))
	{
	  /* Check for rare special case: if we're a MATP_IL and next
	   * two states are MATP_IR and END_E, then we won't have set
	   * a trunction penalty. This state will keep an impossible
	   * truncated begin score, if we did a truncated begin into
	   * it we'd just emit from the MATP_IL and then go to the
	   * END_E anyway (the MATP_IR will be detached.
	   */
	  if(cm->stid[v] == MATP_IL && cm->ndtype[cm->ndidx[v]+1] == END_nd) continue;

	  /* glocal 5P AND 3P: all of these should have been set to a non-IMPOSSIBLE value */
	  if(! NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_AND_3P][v])) goto ERROR;
	  trp->ig_ptyAA[TRPENALTY_5P_AND_3P][v] = Prob2Score(trp->g_ptyAA[TRPENALTY_5P_AND_3P][v], 1.0);
	  trp->g_ptyAA[TRPENALTY_5P_AND_3P][v]  = sreLOG2(trp->g_ptyAA[TRPENALTY_5P_AND_3P][v]);

	  /* glocal 5P only: some may be IMPOSSIBLE */
	  if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_ONLY][v])) {
	    trp->ig_ptyAA[TRPENALTY_5P_ONLY][v] = Prob2Score(trp->g_ptyAA[TRPENALTY_5P_ONLY][v], 1.0);
	    trp->g_ptyAA[TRPENALTY_5P_ONLY][v]  = sreLOG2(trp->g_ptyAA[TRPENALTY_5P_ONLY][v]);
	  }
	  /* glocal 5P only: some may be IMPOSSIBLE */
	  if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_3P_ONLY][v])) {
	    trp->ig_ptyAA[TRPENALTY_3P_ONLY][v] = Prob2Score(trp->g_ptyAA[TRPENALTY_3P_ONLY][v], 1.0);
	    trp->g_ptyAA[TRPENALTY_3P_ONLY][v]  = sreLOG2(trp->g_ptyAA[TRPENALTY_3P_ONLY][v]);
	  }

	  /* local penalties all of these should have been set to a non-IMPOSSIBLE value */
	  if(! NOT_IMPOSSIBLE(trp->il_ptyAA[TRPENALTY_5P_AND_3P][v])) goto ERROR;
	  if(! NOT_IMPOSSIBLE(trp->il_ptyAA[TRPENALTY_5P_ONLY][v]))   goto ERROR;
	  if(! NOT_IMPOSSIBLE(trp->il_ptyAA[TRPENALTY_3P_ONLY][v]))   goto ERROR;

	  trp->il_ptyAA[TRPENALTY_5P_AND_3P][v] = Prob2Score(trp->l_ptyAA[TRPENALTY_5P_AND_3P][v], 1.0);
	  trp->il_ptyAA[TRPENALTY_5P_ONLY][v]   = Prob2Score(trp->l_ptyAA[TRPENALTY_5P_ONLY][v], 1.0);
	  trp->il_ptyAA[TRPENALTY_3P_ONLY][v]   = Prob2Score(trp->l_ptyAA[TRPENALTY_3P_ONLY][v], 1.0);
	  trp->l_ptyAA[TRPENALTY_5P_AND_3P][v]  = sreLOG2(trp->l_ptyAA[TRPENALTY_5P_AND_3P][v]);
	  trp->l_ptyAA[TRPENALTY_5P_ONLY][v]    = sreLOG2(trp->l_ptyAA[TRPENALTY_5P_ONLY][v]);
	  trp->l_ptyAA[TRPENALTY_3P_ONLY][v]    = sreLOG2(trp->l_ptyAA[TRPENALTY_3P_ONLY][v]);
	}
	}

  if(ignore_inserts) {
	if((status = cm_tr_penalties_Validate(trp, cm, 0.0001, errbuf)) != eslOK) { printf("%s", errbuf);  goto ERROR; }
  }

  /* cm_tr_penalties_Dump(stdout, cm, trp); */

  if(mexpocc != NULL) free(mexpocc);
  if(iexpocc != NULL) free(iexpocc);
  if(psi     != NULL) free(psi);
  if(begin   != NULL) free(begin);

  return trp;

 ERROR:
  if(mexpocc != NULL) free(mexpocc);
  if(iexpocc != NULL) free(iexpocc);
  if(psi     != NULL) free(psi);
  if(begin   != NULL) free(begin);
  if(trp     != NULL) cm_tr_penalties_Destroy(trp);

  return NULL;
}

/* Function: cm_tr_penalties_IdxForPass()
 * Date:     EPN, Wed Feb 15 15:07:54 2012
 *
 * Purpose:  Return the appropriate truncation
 *           penalty index given a pipeline pass
 *           index.
 *
 * Returns:  truncation penalty index, either
 *           TRPENALTY_5P_AND_3P, TRPENALTY_5P_ONLY, or
 *           TRPENALTY_3P_ONLY.
 */
int
cm_tr_penalties_IdxForPass(int pass_idx)
{
  switch(pass_idx) {
  case PLI_PASS_5P_ONLY_FORCE:   return TRPENALTY_5P_ONLY; break;
  case PLI_PASS_3P_ONLY_FORCE:   return TRPENALTY_3P_ONLY; break;
  case PLI_PASS_5P_AND_3P_FORCE: return TRPENALTY_5P_AND_3P; break;
  case PLI_PASS_5P_AND_3P_ANY:   return TRPENALTY_5P_AND_3P; break;
  default: return -1; break;
  }
}

/* Function: cm_tr_penalties_Validate()
 * Date:     EPN, Fri Jan 27 14:57:04 2012
 *
 * Purpose:  Validate a CM_TR_PENALTIES object by checking that
 *           all possible fragments in local mode sum to 1.0
 *           for the three scenarios: 5' and 3' truncation,
 *           5' truncation only and 3' truncation only.
 *
 *           This is an expensive test and was written only to test
 *           the code that determines fragment probability (really
 *           only for local mode) in cm_tr_penalties_Create().  It can
 *           only be run if the <ignore_inserts> flag was set to TRUE
 *           when cm_tr_penalties_Create() was called.  However, in
 *           real life that inserts should not be ignored, so this
 *           test should never actually be run except during testing
 *           (it also is helpful for understanding the logic behind
 *           the derivation of the truncated begin
 *           penalties/probabilities).
 *
 * Returns:  eslOK if all checks pass within tolerance level.
 *           eslFAIL if any check fails, errbuf is filled.
 */
int
cm_tr_penalties_Validate(CM_TR_PENALTIES *trp, CM_t *cm, double tol, char *errbuf)
{
  if(! trp->ignored_inserts) ESL_FAIL(eslFAIL, errbuf, "cm_tr_penalties_Validate(), trp->ignored_inserts flag is not TRUE");

  /* This is an expensive test of the trp->l_ptyAA values, the truncation
   * penalties for local mode alignment. We test each of the three arrays
   * in trp->ptyAA, one each for the following three scenarios:
   *
   * 1. trp->l_ptyAA[TRPENALTY_5P_AND_3P][0..v..M-1]: penalty for state v
   *    when 5' and 3' truncation are allowed.
   * 2. trp->l_ptyAA[TRPENALTY_5P_ONLY][0..v..M-1]: penalty for state v when
   *    only 5' truncation is allowed.
   * 3. trp->l_ptyAA[TRPENALTY_3P_ONLY][0..v..M-1]: penalty for state v when
   *    only 3' truncation is allowed.
   *
   * The test is to enumerate all possible g,h fragments in the
   * consensus yield 1..clen, for those that can possibly be generated
   * in the scenario (^), determine the state t with the smallest
   * subtree yield that contains g..h. This is the state at which an
   * alignment of a g..h fragment would be rooted. We then add the
   * probability of a truncated parsetree rooted at v (that is,
   * exp_2(trp->l_ptyAA[][t])) to a growing sum. After all fragments
   * are considered the sum should be 1.0.  If it is then our
   * penalties are valid, if not they're invalid and we computed them
   * incorrectly.
   *
   * (^): When 5' and 3' truncation are both allowed, all fragments can be
   * generated, but not all fragments (for most models) can be generated if
   * only 5' or 3' truncation is allowed.
   *
   */

  double sump = 0.;  /* the sum, should be 1.0 after all fragments are considered */
  int    lpos, rpos; /* left and right consensus positions of a parsetree */
  int    g, h;       /* fragment start/stop */
  int    keep_going; /* break the loop when this is set to FALSE */
  int    nd, v;
  /* test 1: trp->l_ptyAA[TRPENALTY_5P_AND_3P]: */
  for(g = 1; g <= cm->clen; g++) {
	for(h = g; h <= cm->clen; h++) {
	  /* determine which node a truncated parsetree from [a..b] would align to,
	   * this will be lowest node in the model whose subtree spans a..b
	   */
	  nd = cm->nodes-1;
	  keep_going = TRUE;
	  while(keep_going) {
	if(nd == 0) ESL_FAIL(eslFAIL, errbuf, "cm_tr_penalties_Validate: 5' and 3' test, unable to find node that spans %d..%d\n", g, h);
	lpos = cm->emap->lpos[nd];
	rpos = cm->emap->rpos[nd];
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATL_nd) lpos++; /* lpos was one less than what we want */
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATR_nd) rpos--; /* rpos was one more than what we want */
	if((cm->ndtype[nd] == BIF_nd || cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATR_nd) &&
	   (lpos <= g && rpos >= h)) {
	  keep_going = FALSE;
	}
	else { nd--; }
	  }
	  v = cm->nodemap[nd];
	  sump += sreEXP2(trp->l_ptyAA[TRPENALTY_5P_AND_3P][v]);
	  /* printf("LRBOTH g: %3d h: %3d nd: %3d adding %10.5f  (%10.5f)\n", g, h, nd, trp->l_ptyAA[TRPENALTY_5P_AND_3P][v], sump); */
	}
  }
  printf("L and R sump:  %.5f\n", sump);
  if(esl_DCompare(1.0, sump, tol) != eslOK) ESL_FAIL(eslFAIL, errbuf, "cm_tr_penalties_Validate(), 5' and 3' truncation test failed (%g != 1.0)", sump);

  /* test 2: trp->l_ptyAA[TRPENALTY_5P_ONLY]: */
  sump = 0.;
  for(g = 1; g <= cm->clen; g++) {
	for(h = g; h <= cm->clen; h++) {
	  /* determine which node a truncated parsetree from [g..h] would align to,
	   * this will be lowest node in the model whose subtree spans g..h.
	   * Since we're only truncating on the left, an alignment from
	   * g..h may be impossible, only those fragments for which a node exists with
	   * lpos <= g and rpos==h will be possible.
	   */
	  nd = cm->nodes-1;
	  keep_going = TRUE;
	  while(keep_going && nd > 0) {
	lpos = cm->emap->lpos[nd];
	rpos = cm->emap->rpos[nd];
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATL_nd) lpos++; /* lpos was one less than what we want */
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATR_nd) rpos--; /* rpos was one more than what we want */
	if((cm->ndtype[nd] == BIF_nd || cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATR_nd) &&
	   (lpos <= g && rpos == h)) {
	  keep_going = FALSE;
	}
	else { nd--; }
	  }
	  if(keep_going == FALSE) {
	v = cm->nodemap[nd];
	sump += sreEXP2(trp->l_ptyAA[TRPENALTY_5P_ONLY][v]);
	  }
	}
  }
  printf("L only  sump:  %.5f\n", sump);
  if(esl_DCompare(1.0, sump, tol) != eslOK) ESL_FAIL(eslFAIL, errbuf, "cm_tr_penalties_Validate(), 5' only truncation test failed (%g != 1.0)", sump);

  /* test 3: trp->l_ptyAA[TRPENALTY_3P_ONLY]: */
  sump = 0.;
  for(g = 1; g <= cm->clen; g++) {
	for(h = g; h <= cm->clen; h++) {
	  /* determine which node a truncated parsetree from [g..h] would align to,
	   * this will be lowest node in the model whose subtree spans g..h
	   * since we're only truncating on the right, an alignment from
	   * g..h may be impossible, only those for which a node exists with
	   * lpos==g and rpos >= h will be possible.
	   */
	  nd = cm->nodes-1;
	  keep_going = TRUE;
	  while(keep_going && nd > 0) {
	lpos = cm->emap->lpos[nd];
	rpos = cm->emap->rpos[nd];
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATL_nd) lpos++; /* lpos was one less than what we want */
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATR_nd) rpos--; /* rpos was one more than what we want */
	if((cm->ndtype[nd] == BIF_nd || cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATR_nd) &&
	   (lpos == g && rpos >= h)) {
	  keep_going = FALSE;
	}
	else { nd--; }
	  }
	  if(keep_going == FALSE) {
	v = cm->nodemap[nd];
	sump += sreEXP2(trp->l_ptyAA[TRPENALTY_3P_ONLY][v]);
	  }
	}
  }
  printf("R only  sump:  %.5f\n", sump);
  if(esl_DCompare(1.0, sump, tol) != eslOK) ESL_FAIL(eslFAIL, errbuf, "cm_tr_penalties_Validate(), 3' only truncation test failed (%g != 1.0)", sump);

  return eslOK;
}

/* Function: cm_tr_penalties_Sizeof()
 * Date:     EPN, Sat Jan 21 15:37:58 2012
 *
 * Purpose:  Calculate and return the size of a CM_TR_PENALTIES
 *           object in Mb.
 */

float
cm_tr_penalties_Sizeof(CM_TR_PENALTIES *trp)
{
  float bytes = 0.;

  if(trp == NULL) return 0.;

  bytes = sizeof(CM_TR_PENALTIES);
  bytes += sizeof(float *) * NTRPENALTY; /* g_ptyAA, 1st dim */
  bytes += sizeof(int *)   * NTRPENALTY; /* ig_ptyAA, 1st dim */
  bytes += sizeof(float *) * NTRPENALTY; /* l_ptyAA, 1st dim */
  bytes += sizeof(int *)   * NTRPENALTY; /* il_ptyAA, 1st dim */
  bytes += sizeof(float) * NTRPENALTY * trp->M; /* g_ptyAA, 2nd dim */
  bytes += sizeof(int)   * NTRPENALTY * trp->M; /* ig_ptyAA, 2nd dim */
  bytes += sizeof(float) * NTRPENALTY * trp->M; /* l_ptyAA, 2nd dim */
  bytes += sizeof(int)   * NTRPENALTY * trp->M; /* il_ptyAA, 2nd dim */

  return bytes / 1000000.;
}

/* Function:  cm_tr_penalties_Dump()
 *
 * Purpose:   Print contents of the <CM_TR_PENALTIES> <trp> to
 *            stream <fp> for inspection.
 *
 * Returns:   void
 */
void
cm_tr_penalties_Dump(FILE *fp, const CM_t *cm, const CM_TR_PENALTIES *trp)
{
  int v, nd, subtree_clen;

  fprintf(fp, "CM_TR_PENALTIES dump\n");
  fprintf(fp, "--------------------\n");
  fprintf(fp, "M               = %d\n", trp->M);
  fprintf(fp, "ignored_inserts = %s\n", trp->ignored_inserts ? "TRUE" : "FALSE");
  fprintf(fp, "clen            = %d\n", cm->clen);

  fprintf(fp, "\nglobal/glocal penalties:\n");
  fprintf(fp, "%5s  %5s  %7s  %7s  %10s  %10s  %10s  %10s  %10s  %10s\n", "stidx", "ndidx", "stid", "st_clen", "f5P_AND_3P", "i5P_AND_3P", "f5P_ONLY", "i5P_ONLY", "f3P_ONLY", "i3P_ONLY");
  fprintf(fp, "%5s  %5s  %7s  %7s  %10s  %10s  %10s  %10s  %10s  %10s\n", "-----", "-----", "-------", "-------", "----------", "----------", "----------", "----------", "----------", "-----------");
  fprintf(fp, "\n");
  for(v = 0; v < cm->M; v++) {
	nd = cm->ndidx[v];
	subtree_clen = cm->emap->rpos[nd]-cm->emap->lpos[nd]+1;
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATL_nd) subtree_clen--; /* lpos was one less than what we want */
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATR_nd) subtree_clen--; /* rpos was one more than what we want */
	fprintf(fp, "%5d  %5d  %-7s  %7d", v, cm->ndidx[v], CMStateid(cm->stid[v]), subtree_clen);
	if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_AND_3P][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->g_ptyAA[TRPENALTY_5P_AND_3P][v], trp->ig_ptyAA[TRPENALTY_5P_AND_3P][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_5P_ONLY][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->g_ptyAA[TRPENALTY_5P_ONLY][v], trp->ig_ptyAA[TRPENALTY_5P_ONLY][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	if(NOT_IMPOSSIBLE(trp->g_ptyAA[TRPENALTY_3P_ONLY][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->g_ptyAA[TRPENALTY_3P_ONLY][v], trp->ig_ptyAA[TRPENALTY_3P_ONLY][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	fprintf(fp, "\n");
  }

  fprintf(fp, "\nlocal penalties:\n");
  fprintf(fp, "%5s  %5s  %7s  %7s  %10s  %10s  %10s  %10s  %10s  %10s\n", "stidx", "ndidx", "stid", "st_clen", "f5P_AND_3P", "i5P_AND_3P", "f5P_ONLY", "i5P_ONLY", "f3P_ONLY", "i3P_ONLY");
  fprintf(fp, "%5s  %5s  %7s  %7s  %10s  %10s  %10s  %10s  %10s  %10s\n", "-----", "-----", "-------", "-------", "----------", "----------", "----------", "----------", "----------", "-----------");
  fprintf(fp, "\n");
  for(v = 0; v < cm->M; v++) {
	nd = cm->ndidx[v];
	subtree_clen = cm->emap->rpos[nd]-cm->emap->lpos[nd]+1;
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATL_nd) subtree_clen--; /* lpos was one less than what we want */
	if(cm->ndtype[nd] != MATP_nd && cm->ndtype[nd] != MATR_nd) subtree_clen--; /* rpos was one more than what we want */
	fprintf(fp, "%5d  %5d  %-7s  %7d", v, cm->ndidx[v], CMStateid(cm->stid[v]), subtree_clen);
	if(NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_5P_AND_3P][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->l_ptyAA[TRPENALTY_5P_AND_3P][v], trp->il_ptyAA[TRPENALTY_5P_AND_3P][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	if(NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_5P_ONLY][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->l_ptyAA[TRPENALTY_5P_ONLY][v], trp->il_ptyAA[TRPENALTY_5P_ONLY][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	if(NOT_IMPOSSIBLE(trp->l_ptyAA[TRPENALTY_3P_ONLY][v])) {
	  fprintf(fp, "  %10.3f  %10d", trp->l_ptyAA[TRPENALTY_3P_ONLY][v], trp->il_ptyAA[TRPENALTY_3P_ONLY][v]);
	}
	else {
	  fprintf(fp, "  %10s  %10s", "IMPOSSIBLE", "-INFTY");
	}
	fprintf(fp, "\n");
  }

  return;
}

/* Function: cm_tr_penalties_Destroy()
 * Date:     EPN, Sat Jan 21 10:30:53 2012
 *
 * Purpose:  Destroy a CM_TR_PENALTIES object.
 *
 * Returns:  void
 */
void
cm_tr_penalties_Destroy(CM_TR_PENALTIES *trp)
{
  int i;

  if(trp == NULL) return;

  if(trp->g_ptyAA != NULL) {
	for(i = 0; i < NTRPENALTY; i++) {
	  if(trp->g_ptyAA[i] != NULL) free(trp->g_ptyAA[i]);
	}
	free(trp->g_ptyAA);
  }
  if(trp->ig_ptyAA != NULL) {
	for(i = 0; i < NTRPENALTY; i++) {
	  if(trp->ig_ptyAA[i] != NULL) free(trp->ig_ptyAA[i]);
	}
	free(trp->ig_ptyAA);
  }

  if(trp->l_ptyAA != NULL) {
	for(i = 0; i < NTRPENALTY; i++) {
	  if(trp->l_ptyAA[i] != NULL) free(trp->l_ptyAA[i]);
	}
	free(trp->l_ptyAA);
  }
  if(trp->il_ptyAA != NULL) {
	for(i = 0; i < NTRPENALTY; i++) {
	  if(trp->il_ptyAA[i] != NULL) free(trp->il_ptyAA[i]);
	}
	free(trp->il_ptyAA);
  }

  free(trp);
  trp = NULL;

  return;
}

/*** End of inlined file: cm_trunc.c ***/


/*** Start of inlined file: cm_p7_band.c ***/
#include <stdio.h>
#include <math.h>
#include <assert.h>


#define  p7_IMPOSSIBLE -987654321

/* Function:  p7_gmx_Match2DMatrix()
 * Synopsis:  Copy the dp match cells of a generic matrix
 *            to a ESL_DMATRIX, for visualization with esl_dmx_Visualize()
 *
 * Incept:    SRE, Fri Jul 13 09:56:04 2007 [Janelia]
 *
 * Purpose:   Dump matrix <gx> to stream <fp> for diagnostics.
 */
int
p7_gmx_Match2DMatrix(P7_GMX *gx, int do_diff, ESL_DMATRIX **ret_D, double *ret_min, double *ret_max)
{
  int i, k;
  ESL_DMATRIX *D;
  double min =  eslINFINITY;
  double max = -eslINFINITY;
  float sc;

  D = esl_dmatrix_Create(gx->M+1, gx->L);
  /* fill k == 0 row, the X matrix E state (logically, the begin state) scores */
  for (i = 1; i <= gx->L; i++) {
	D->mx[0][(i-1)] = gx->xmx[i * p7G_NXCELLS + 0];
  }

  for (i = 1; i <= gx->L; i++) {
	for (k = 1; k <= gx->M; k++) {
	  sc = gx->dp[i][k * p7G_NSCELLS + p7G_M];
	  if(do_diff) {
	if((i < 2) || (k < 2)) D->mx[k][(i-1)] = 0.;
	else                   D->mx[k][(i-1)] = sc - ESL_MAX(D->mx[k][(i-2)], D->mx[0][(i-2)]);
	  }
	  else {
	D->mx[k][(i-1)] = sc;
	  }
	  min = ESL_MIN(min, D->mx[k][(i-1)]);
	  max = ESL_MAX(max, D->mx[k][(i-1)]);
	}
  }

  *ret_D = D;
  *ret_min = min;
  *ret_max = max;
  return eslOK;
}

/****************************************************************
 * Stolen from hmmer/h3/heatmap.c SVN revision 2171
 * as dmx_Visualize. Then modified so that the full
 * matrix is printed (not half split diagonally).
 */
/* my_dmx_Visualize()
 * Incept:    SRE, Wed Jan 24 11:58:21 2007 [Janelia]
 *
 * Purpose:
 *
 *            Color scheme roughly follows Tufte, Envisioning
 *            Information, p.91, where he shows a beautiful
 *            bathymetric chart. The CMYK values conjoin two
 *            recommendations from ColorBrewer (Cindy Brewer
 *            and Mark Harrower)
 *            [http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html],
 *            specifically the 9-class sequential2 Blues and
 *            9-class sequential YlOrBr.
 *
 *            Might eventually become part of Easel, once mature?
 *
 * Note:      Binning rules basically follow same convention as
 *            esl_histogram. nb = xmax-xmin/w, so w = xmax-xmin/nb;
 *            picking bin is (int) ceil((x - xmin)/w) - 1. (xref
 *            esl_histogram_Score2Bin()). This makes bin b contain
 *            values bw+min < x <= (b+1)w+min. (Which means that
 *            min itself falls in bin -1, whoops - but we catch
 *            all bin<0 and bin>=nshades and put them in the extremes.
 *
 * Args:
 *
 * Returns:
 *
 * Throws:    (no abnormal error conditions)
 *
 * Xref:
 */
int
my_dmx_Visualize(FILE *fp, ESL_DMATRIX *D, double min, double max, double min2fill)
{
   int    nshades   = 18;
   double cyan[]    = { 1.00, 1.00, 0.90, 0.75, 0.57, 0.38, 0.24, 0.13, 0.03,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.07, 0.20, 0.40, 0.60};
   double magenta[] = { 0.55, 0.45, 0.34, 0.22, 0.14, 0.08, 0.06, 0.03, 0.01,
			0.00, 0.03, 0.11, 0.23, 0.40, 0.55, 0.67, 0.75, 0.80};
   double yellow[]  = { 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.10, 0.25, 0.40, 0.65, 0.80, 0.90, 1.00, 1.00, 1.00};
   double black[]   = { 0.30, 0.07, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00};
   double w;
   int    i,j;
   int    bin;
   int    boxsize;		/* box size in points */
   int    xcoord, ycoord;	/* postscript coords in points */
   int    leftmargin, rightmargin;
   int    bottommargin, topmargin;
   float  fboxsize;		/* box size in fractional points */

   /* Set some defaults that might become arguments later.
	*/
   leftmargin   = rightmargin = 20;
   bottommargin = topmargin   = 20;

   /* Determine some working parameters
	*/
   w = (max-min) / (double) nshades; /* w = bin size for assigning values->colors*/
   boxsize = ESL_MAX(1, (ESL_MIN((792 - bottommargin) / D->n,
				 (612 - leftmargin)   / D->m)));
   fboxsize= ESL_MIN( (792. - ((float) bottommargin + topmargin))   / (float) D->n,
		      (612. - ((float) leftmargin   + rightmargin)) / (float) D->m);

   fprintf(fp, "%.4f %.4f scale\n", (fboxsize/(float) boxsize), (fboxsize/(float) boxsize));
   /* printf("n: %d\nm: %d\n", D->n, D->m); */
   for (i = 0; i < D->n; i++) {
	 /* printf("\n"); */
	 /* for (j = i; j < D->n; j++) */
	 for (j = 0; j < D->m; j++)
	   {
	 /* printf("i: %4d j: %4d %5.1f\n", i, j, D->mx[i][j]); */
	 xcoord = j * boxsize + leftmargin;
	 ycoord = (D->m-(i+1)) * boxsize + bottommargin; /* difference w/heatmap.c: (D->m-i+1) */

	 if      (D->mx[i][j]  <  min2fill)    continue;
	 /* if      ((i > 0) && (j > 0) && (D->mx[i][j] <=  D->mx[i-1][j-1]) && (D->mx[i][j] < min2fill))    continue;*/
	 else if (D->mx[i][j] == -eslINFINITY) bin = 0;
	 else if (D->mx[i][j] ==  eslINFINITY) bin = nshades-1;
	 else {
	   bin    = (int) ceil((D->mx[i][j] - min) / w) - 1;
	   if (bin < 0)        bin = 0;
	   if (bin >= nshades) bin = nshades-1;
	 }

	 printf("%4d %4d %10.3f\n", i, j, D->mx[i][j]);
	 fprintf(fp, "newpath\n");
	 fprintf(fp, "  %d %d moveto\n", xcoord, ycoord);
	 fprintf(fp, "  0  %d rlineto\n", boxsize);
	 fprintf(fp, "  %d 0  rlineto\n", boxsize);
	 fprintf(fp, "  0 -%d rlineto\n", boxsize);
	 fprintf(fp, "  closepath\n");
	 fprintf(fp, " %.2f %.2f %.2f %.2f setcmykcolor\n",
		 cyan[bin], magenta[bin], yellow[bin], black[bin]);
	 fprintf(fp, "  fill\n");
	   }
   }
  fprintf(fp, "showpage\n");
  return eslOK;
}

/* Function: my_p7_GTraceMSV()
 * Incept:   EPN, Mon Aug 11 10:01:23 2008
 *
 * Purpose:  Traceback of a MSV matrix: retrieval of optimum alignment.
 *
 *           Based on p7_GTrace().
 *
 *           This function is currently implemented as a
 *           reconstruction traceback, rather than using a shadow
 *           matrix. Because H3 uses floating point scores, and we
 *           can't compare floats for equality, we have to compare
 *           floats for near-equality and therefore, formally, we can
 *           only guarantee a near-optimal traceback. However, even in
 *           the unlikely event that a suboptimal is returned, the
 *           score difference from true optimal will be negligible.
 *
 * Args:     dsq    - digital sequence aligned to, 1..L
 *           L      - length of <dsq>
 *           gm     - profile
 *           mx     - MSV matrix to trace, L x M
 *           tr     - storage for the recovered traceback.
 *
 * Return:   <eslOK> on success.
 *           <eslFAIL> if even the optimal path has zero probability;
 *           in this case, the trace is set blank (<tr->N = 0>).
 *           <eslEINCOMPAT> if the optimal trace is discontiguous wrt
 *           the sequence, node k > kp emits residue i < ip, while kp
 *           emits ip. In this case, trace is invalid - caller must
 *           know this.
 *
 * Note:     Care is taken to evaluate the prev+tsc+emission
 *           calculations in exactly the same order that Viterbi did
 *           them, lest you get numerical problems with
 *           a+b+c = d; d-c != a+b because d,c are nearly equal.
 *           (This bug appeared in dev: xref J1/121.)
 */

/* for HMMER3 P7 HMMs */
#define P7MMX(i,k) (dp[(i)][(k) * p7G_NSCELLS + p7G_M])
#define P7XMX(i,s) (xmx[(i) * p7G_NXCELLS + (s)])
#define P7MSC(k)   (rsc[(k) * p7P_NR     + p7P_MSC])

/* for CP9 HMMs */
#define CP9TSC(s,k) (tsc[(k) * cp9O_NTRANS + (s)])

int
my_p7_GTraceMSV(const ESL_DSQ *dsq, int L, const P7_PROFILE *gm, const P7_GMX *gx, P7_TRACE *tr, int **ret_i2k, int **ret_k2i, float **ret_isc, int **ret_iconflict)
{
  int     status = eslOK;
  int     i;			/* position in seq (1..L) */
  int     k;			/* position in model (1..M) */
  int     M   = gm->M;
  float **dp  = gx->dp;
  float  *xmx = gx->xmx;
  float   tol = 1e-5;
  float   esc = p7_profile_IsLocal(gm) ? 0 : -eslINFINITY;
  /* new vars */
  float        tloop = logf((float) L / (float) (L+3));
  float        tmove = logf(     3.0f / (float) (L+3));
  float        tbmk  = logf(     2.0f / ((float) gm->M * (float) (gm->M+1)));
  float        tec   = logf(0.5f);

  int *k2i; /* [0.1..k..gm->M] = i, residue i emitted from node k's match state in MSV trace */
  int *i2k; /* [0.1..i..L]     = k, residue i emitted from node k's match state in MSV trace */
  int *iconflict; /* [0.1..i..L] = TRUE | FALSE. TRUE to eventually remove the kmer with pin at i */
  float *isc; /*[0.1..i..L]    = sc, match emission score for residue i is sc */

  ESL_ALLOC(k2i, sizeof(int)   * (gm->M+1));
  ESL_ALLOC(i2k, sizeof(int)   * (L+1));
  ESL_ALLOC(iconflict, sizeof(int)   * (L+1));
  ESL_ALLOC(isc, sizeof(float) * (L+1));
  esl_vec_ISet(k2i, (gm->M+1), -1);
  esl_vec_ISet(i2k, (L+1),     -1);
  esl_vec_ISet(iconflict, (L+1), FALSE);
  esl_vec_FSet(isc, (L+1),     -eslINFINITY);

  if ((status = p7_trace_Reuse(tr)) != eslOK) goto ERROR;

  /* Initialization.
   * (back to front. ReverseTrace() called later.)
   */
  if ((status = p7_trace_Append(tr, p7T_T, 0, 0)) != eslOK) goto ERROR;
  if ((status = p7_trace_Append(tr, p7T_C, 0, 0)) != eslOK) goto ERROR;
  i    = L;			/* next position to explain in seq */

  /* Traceback
   */
  while (tr->st[tr->N-1] != p7T_S) {
	float const *rsc = gm->rsc[dsq[i]];

	switch (tr->st[tr->N-1]) {
	case p7T_C:		/* C(i) comes from E(i) */
	  if   (P7XMX(i,p7G_C) == -eslINFINITY) ESL_XEXCEPTION(eslFAIL, "impossible C reached at i=%d", i);

	  if (esl_FCompare(P7XMX(i, p7G_C), P7XMX(i-1, p7G_C) + tloop, tol) == eslOK) {
	tr->i[tr->N-1]    = i--;  /* first C doesn't emit: subsequent ones do */
	status = p7_trace_Append(tr, p7T_C, 0, 0);
	  } else if (esl_FCompare(P7XMX(i, p7G_C), P7XMX(i, p7G_E) + tec, tol) == eslOK)
	status = p7_trace_Append(tr, p7T_E, 0, 0);
	  else ESL_XEXCEPTION(eslFAIL, "C at i=%d couldn't be traced", i);
	  break;

	case p7T_E:		/* E connects from any M state. k set here */
	  if (P7XMX(i, p7G_E) == -eslINFINITY) ESL_XEXCEPTION(eslFAIL, "impossible E reached at i=%d", i);

	  if (esl_FCompare(P7XMX(i, p7G_E), P7MMX(i,M), tol) == eslOK) { k = M; status = p7_trace_Append(tr, p7T_M, M, i); }
	  else {
	for (k = M-1; k >= 1; k--)
	  if (esl_FCompare(P7XMX(i, p7G_E), P7MMX(i,k) + esc, tol) == eslOK)
	    { status = p7_trace_Append(tr, p7T_M, k, i); break; }
	if (k < 0) ESL_XEXCEPTION(eslFAIL, "E at i=%d couldn't be traced", i);
	  }
	  break;

	case p7T_M:			/* M connects from i-1,k-1, or B */
	  if (P7MMX(i,k) == -eslINFINITY) ESL_XEXCEPTION(eslFAIL, "impossible M reached at k=%d,i=%d", k,i);
	  if      (esl_FCompare(P7MMX(i,k), P7XMX(i-1,p7G_B) + tbmk  + P7MSC(k), tol) == eslOK) status = p7_trace_Append(tr, p7T_B, 0,   0);
	  else if (esl_FCompare(P7MMX(i,k), P7MMX(i-1,k-1)           + P7MSC(k), tol) == eslOK) {
	status = p7_trace_Append(tr, p7T_M, k-1, i-1);
	/*if(k2i[(k-1)] != -1) { status = eslEINCOMPAT; printf("! discontiguous trace k2i[k-1=%d] != -1 (%d) i-1 = %d\n", k-1, k2i[(k-1)], i-1); goto ERROR;} */
	/*if(i2k[(i-1)] != -1) { status = eslEINCOMPAT; printf("! discontiguous trace i2k[i-1=%d] != -1 (%d) k-1 = %d\n", i-1, i2k[(i-1)], k-1); goto ERROR;} */
	if(i2k[(i-1)] != -1 || k2i[(k-1)] != -1) {
	  iconflict[(k2i[(k-1)])] = TRUE; /* eventually remove pin kmer that included k we *thought* pinned i-1 */
	  iconflict[(i-1)]        = TRUE; /* eventually remove pin kmer that includes k we currently think pins i-1 */
	}
	k2i[(k-1)] = i-1;
	i2k[(i-1)] = k-1;
	isc[(i-1)] = P7MSC(k);
	  }
	  else ESL_XEXCEPTION(eslFAIL, "M at k=%d,i=%d couldn't be traced", k,i);

	  if (status != eslOK) goto ERROR;
	  k--;
	  i--;
	  break;

	case p7T_N:			/* N connects from S, N */
	  if (P7XMX(i, p7G_N) <= p7_IMPOSSIBLE) ESL_XEXCEPTION(eslFAIL, "impossible N reached at i=%d", i);

	  if (i == 0) status = p7_trace_Append(tr, p7T_S, 0, 0);
	  else if (esl_FCompare(P7XMX(i,p7G_N), P7XMX(i-1, p7G_N) + tloop, tol) == eslOK)
	{
	  tr->i[tr->N-1] = i--;
	  status = p7_trace_Append(tr, p7T_N, 0, 0);
	}
	  else ESL_XEXCEPTION(eslFAIL, "N at i=%d couldn't be traced", i);
	  break;

	case p7T_B:			/* B connects from N, J */
	  if (P7XMX(i,p7G_B) == -eslINFINITY) ESL_XEXCEPTION(eslFAIL, "impossible B reached at i=%d", i);

	  if (esl_FCompare(P7XMX(i,p7G_B), P7XMX(i, p7G_N) + tmove, tol)  == eslOK)
	status = p7_trace_Append(tr, p7T_N, 0, 0);
	  else if (esl_FCompare(P7XMX(i,p7G_B),  P7XMX(i, p7G_J) + tmove, tol) == eslOK)
	status = p7_trace_Append(tr, p7T_J, 0, 0);
	  else  ESL_XEXCEPTION(eslFAIL, "B at i=%d couldn't be traced", i);
	  break;

	case p7T_J:			/* J connects from E(i) or J(i-1) */
	  if (P7XMX(i,p7G_J) == -eslINFINITY) ESL_XEXCEPTION(eslFAIL, "impossible J reached at i=%d", i);

	  if (esl_FCompare(P7XMX(i,p7G_J), P7XMX(i-1,p7G_J) + tloop, tol) == eslOK) {
	tr->i[tr->N-1] = i--;
	status = p7_trace_Append(tr, p7T_J, 0, 0);
	  } else if (esl_FCompare(P7XMX(i,p7G_J), P7XMX(i,p7G_E) + tec, tol) == eslOK)
	status = p7_trace_Append(tr, p7T_E, 0, 0);
	  else  ESL_XEXCEPTION(eslFAIL, "J at i=%d couldn't be traced", i);
	  break;

	default: ESL_XEXCEPTION(eslFAIL, "bogus state in traceback");
	} /* end switch over statetype[tpos-1] */

	if (status != eslOK) goto ERROR;
  } /* end traceback, at S state */

  if ((status = p7_trace_Reverse(tr)) != eslOK) goto ERROR;
  if (ret_i2k != NULL) { *ret_i2k = i2k; } else free(i2k);
  if (ret_k2i != NULL) { *ret_k2i = k2i; } else free(k2i);
  if (ret_isc != NULL) { *ret_isc = isc; } else free(isc);
  if (ret_iconflict != NULL) { *ret_iconflict = iconflict; } else free(iconflict);
  return eslOK;

 ERROR:
  if (ret_i2k != NULL) { *ret_i2k = i2k; } else free(i2k);
  if (ret_k2i != NULL) { *ret_k2i = k2i; } else free(k2i);
  if (ret_isc != NULL) { *ret_isc = isc; } else free(isc);
  return status;
}

/* Function: Parsetree2i_to_k()
 * Date:     EPN, Mon Aug 11 13:41:38 2008
 *
 * Purpose:  Given a parsetree, fill a vector i2k[0.1..i..L] = k, saying that
 *           residue i is emitted into consensus column k. If k <= 0, this implies
 *           residue i was inserted after consensus column (-1 * k).
 *
 * Returns:  eslOK on success
 *           eslEINCOMPAT on contract violation.
 */
int
Parsetree2i_to_k(CM_t *cm, CMEmitMap_t *emap, int L, char *errbuf, Parsetree_t *tr, int **ret_i2k)
{
  int status;                   /* Easel status code */
  int tidx;			/* counter through positions in the parsetree        */
  int v;			/* state index in CM */
  int nd;
  int *i2k;

  ESL_ALLOC(i2k, sizeof(int) * (L+1));
  esl_vec_ISet(i2k, (L+1), -1 * (cm->clen + 1));

  /* contract check */
  if(emap   == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "Parsetree2i_to_k(): emap == NULL.");

		/* trivial preorder traverse, since we're already numbered that way */
  for (tidx = 0; tidx < tr->n; tidx++) {
	v = tr->state[tidx];        	/* index of parent state in CM */
	nd = cm->ndidx[v];
	if (v == cm->M) continue;      	/* special case: v is EL, local alignment end */
	switch (cm->sttype[v]) {
	case MP_st:
	  i2k[tr->emitl[tidx]] = emap->lpos[nd];
	  i2k[tr->emitr[tidx]] = emap->rpos[nd];
	  break;

	case ML_st:
	  i2k[tr->emitl[tidx]] = emap->lpos[nd];
	  break;

	case MR_st:
	  i2k[tr->emitr[tidx]] = emap->rpos[nd];
	  break;

	case IL_st:
	  i2k[tr->emitl[tidx]] = (-1 * emap->lpos[nd]);
	  break;

	case IR_st:
	  i2k[tr->emitr[tidx]] = (-1 * (emap->rpos[nd] - 1)); /* IR's emit to before consensus column rpos */
	  break;

	}
  }

  *ret_i2k = i2k;
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Parsetree2i_to_k(), memory allocation error.");
  return status; /* NEVERREACHED */
}

/* Function: prune_i2k()
 * Incept:   EPN, Mon Aug 11 15:02:35 2008
 *
 * Purpose:  Prune an i2k array of pins. Optionally prune by the following
 *           criteria (in this order):
 *           o match score of the pin
 *           o length (n) of n-mer each pin exists in
 *           o proximity to end of n-mer
 *
 * Args:     i2k        - the input pin array, modified (pruned) in place
 *           iconflict  - [0.1..i..L] TRUE if i:i2k[i] pin is involved in a conflict, remove the whole nmer pin
 *           isc        - score (match emission) for each pin
 *           L          - length of current sequence
 *           phi        - phi array, phi[k][v] is expected number of times (probability)
 *                        state v (0 = match, 1 insert, 2 = delete) in
 *                        node k is *entered*. Node 0 is special, state 0 = B state, state 1 = N_state, state 2 = NULL
 *                        Calculated *without* taking insert->insert transitions into account.
 *           min_sc     - minimum score to allow as a pin, 0. to allow any score
 *           min_len    - min n-mer size, 1 to allow any size
 *           min_end    - min distance from end to allow, prune away any others, 0 to not prune based on end proximity
 *           min_mprob  - min match phi probability to allow in a pin
 *           min_mcprob - min cumulative match phi probability to allow in a nmer pin
 *           max_iprob  - max insert phi probability to allow in a pin
 *           max_ilprob - max insert phi probability to allow in a state to the left of a pin
 *
 * Return:   <eslOK> on success.
 *
 */
int
prune_i2k(int *i2k, int *iconflict, float *isc, int L, double **phi, float min_sc, int min_len, int min_end, float min_mprob, float min_mcprob, float max_iprob, float max_ilprob)
{
  int     i, j;

  int do_end;
  int do_sc;
  int do_len;
  float   tol = 1e-5;
  float mcprob = 1.; /* cumulative match probability */
  int n = 0;
  int ip;

  do_sc   = (esl_FCompare(0., min_sc, tol) == eslOK) ? FALSE : TRUE;
  do_end  = (min_end == 0)  ? FALSE : TRUE;
  do_len  = (min_len == 1) ? FALSE : TRUE;

  /* pass 1, prune on conflict from trace, this must be first pass */
  for(i = 1; i <= L; i++) {
	if(iconflict[i] == TRUE) {
	  /* remove entire nmer's pins */
	  ip = i;
	  while((ip > 0)  && (i2k[ip] != -1)) i2k[ip--] = -1;
	  ip = i;
	  while((ip <= L) && (i2k[ip] != -1)) i2k[ip++] = -1;
	}
  }

  /* pass 2, prune on scores */
  if(do_sc) {
	for(i = 1; i <= L; i++) if((i2k[i] != -1) && (isc[i] < min_sc)) i2k[i] = -1;
  }

  /* pass 3, prune on phi values */
  for(i = 1; i <= L; i++) {
	if(i2k[i] != -1) { /* position i is currently pinned */
	   if ((phi[i2k[i]][HMMMATCH]      < min_mprob)   || /* match  prob too low */
	   (phi[i2k[i]][HMMINSERT]     > max_iprob)   || /* insert to the right prob too high */
	   (phi[(i2k[i]-1)][HMMINSERT] > max_ilprob)) {  /* insert to the left  prob too high */
	 /* remove pin */
	 /*printf("removing pin %4d %.4f\n", i, phi[i2k[i]][HMMMATCH]);*/
	 i2k[i] = -1;
	   }
	}
  }

  /* pass 4, prune on nmer length, match score, match phi probability, and distance from end */
  if(do_len || do_end) { /* determine the size n of the n-mer each residue i is in */
	for(i = 1; i <= L; i++) {
	  if((i2k[i] == -1) || /* position i is not pinned */
	 ((i2k[(i-1)] != -1) && !(i2k[(i-1)] == (i2k[i]-1)))) { /* position i is pinned to k, position i-1 is pinned to kp, but k and kp are not consecutive */
	/* we just ended an n-mer (n >= 0) */
	if(n > 0 && n < min_len) {
	  for(j = (i - n); j < i; j++) i2k[j] = -1; /* remove the n-mer */
	  mcprob = 1.;
	}
	else if (do_end && n >= min_len) { /* n >= min_len, remove those within do_end of end */
	  for(j = (i - n);        j < (i - (n+1)) + min_end; j++) i2k[j] = -1; /* remove the part of the n-mer within nend residues of the beginning edge */
	  for(j = (i - min_end);  j < i;                     j++) i2k[j] = -1; /* remove the part of the n-mer within nend residues of the end edge */
	}
	if(i2k[i] == -1) { /* position i is not pinned */
	  mcprob = 1.;
	  n = 0;
	}
	else { /* position i is pinned to k, position i-1 is pinned to kp, but k and kp are not consecutive */
	  mcprob = phi[(i2k[i])][HMMMATCH];
	  n = 1;
	  if(mcprob < min_mcprob) { i2k[i] = -1; n = 0; mcprob = 1.; }
	}
	  }
	  else {
	n++;
	mcprob *= phi[(i2k[i])][HMMMATCH];
	if(mcprob < min_mcprob) { /* remove the n-mer up to this point */
	  for(j = (i - n); j < i; j++) i2k[j] = -1; /* remove the n-mer */
	  mcprob = 1.;
	  n = 0;
	}
	  }
	}
	/* deal with possibility that last n residues were an n-mer, with n < min_len */
	if(n > 0 && n < min_len) { for(j = (i - n); j < i; j++) i2k[j] = -1; /* remove the n-mer */}
  }

  return eslOK;
}

/* Function: p7_pins2bands()
 * Incept:   EPN, Mon Aug 11 15:41:44 2008
 *
 * Purpose:  Given an i2k pins array, determine the imin and imax bands.
 *
 * Args:     i2k      - the input pin array, modified (pruned) in place
 *           errbuf   - for error messages
 *           L        - length of current sequence
 *           M        - number of nodes in the HMM
 *           pad      - pad on each side of pin, if pad = 3, we allow +/- 3 residues from pin
 *           ret_kmin - [0.i..L] = k, min node k for residue i
 *           ret_kmax - [0.i..L] = k, max node k for residue i
 *           ret_ncells - number of cells within bands, to return
#if 0
 *           ret_imin - [0.k..M] = i, min residue i for node k
 *           ret_imax - [0.k..M] = i, max residue i for node k
#endif
 *
 * Return:   <eslOK> on success.
 *
 */
int
p7_pins2bands(int *i2k, char *errbuf, int L, int M, int pad, int **ret_kmin, int **ret_kmax, int *ret_ncells)
{
  int     status;

  int i;
  int kn = 0;
  int kx = M;
  int *kmin, *kmax;

  ESL_ALLOC(kmin, sizeof(int) * (L+1));
  ESL_ALLOC(kmax, sizeof(int) * (L+1));

  /* traverse residues left to right to get kmins */
  for(i = 0; i <= L; i++) {
	if(i2k[i] != -1) {
	  if(kn >= i2k[i] && kn > 1) {
	ESL_FAIL(eslFAIL, errbuf, "p7_pins2bands() error i: %d, i2k[i]: %d but current kn: %d\n", i, i2k[i], kn);
	  }
	  kn = ESL_MAX(1, i2k[i] - pad);
	}
	kmin[i] = kn;
  }

  /* traverse nodes right to left to get imaxs */
  for(i = L; i >= 0; i--) {
	if(i2k[i] != -1) {
	  if(kx <= i2k[i] && kx < L) ESL_FAIL(eslFAIL, errbuf, "p7_pins2bands() error: i: %d, i2k[i]: %d but current kx: %d\n", i, i2k[i], kx);
	  kx = ESL_MIN(M, i2k[i] + pad);
	}
	kmax[i] = kx;
  }

  /* M_0 == B state, which must start the parse with i == 0 */
  kmin[0] = 0;

  /* get number of cells if wanted */
  int ncells;
  if(ret_ncells != NULL) {
	ncells = 0;
	for(i = 1; i <= L; i++) ncells += kmax[i] - kmin[i] + 1;
	*ret_ncells = ncells;
  }

  if(ret_kmin != NULL) { *ret_kmin = kmin; } else free(kmin);
  if(ret_kmax != NULL) { *ret_kmax = kmax; } else free(kmax);
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "p7_pins2bands() memory error.");
  return status; /* NEVERREACHED */

#if 0
  /* if we want to get imin/imax instead of kmin/kmax */
  int in = 1;
  int ix = L;
  int *imin;
  int *imax;
  int *k2i;

  ESL_ALLOC(imin, sizeof(int) * (M+1));
  ESL_ALLOC(imax, sizeof(int) * (M+1));
  ESL_ALLOC(k2i,  sizeof(int) * (M+1));

  imin[0] = imax[0] = -1;
  esl_vec_ISet(k2i, (M+1), -1);

  for(i = 1; i <= L; i++) if(i2k[i] != -1) k2i[i2k[i]] = i;

  /* traverse nodes left to right to get imins */
  for(k = 1; k <= M; k++) {
	if(k2i[k] != -1) {
	  if(k2i[k] != 1 && in >= k2i[k]) ESL_FAIL(eslFAIL, errbuf, "p7_pins2bands() error k: %d, k2i[k]: %d but current in: %d\n", k, k2i[k], in);
	  in = ESL_MAX(1, k2i[k] - pad);
	}
	imin[k] = in;
  }

  /* traverse nodes right to left to get imaxs */
  for(k = M; k >= 1; k--) {
	if(k2i[k] != L && k2i[k] != -1) {
	  if(ix <= k2i[k]) ESL_FAIL(eslFAIL, errbuf, "p7_pins2bands() error: k: %d, k2i[k]: %d but current ix: %d\n", k, k2i[k], ix);
	  ix = ESL_MIN(L, k2i[k] + pad);
	}
	imax[k] = ix;
  }

  free(k2i);

  /* get number of cells if wanted */
  int ncells;
  if(ret_ncells != NULL) {
	ncells = 0;
	for(k = 1; k <= M; k++) ncells += imax[k] - imin[k] + 1;
	*ret_ncells = ncells;
  }
  if(ret_imin != NULL) { *ret_imin = imin; } else free(imin);
  if(ret_imax != NULL) { *ret_imax = imax; } else free(imax);
#endif
}

/* Function: DumpP7Bands()
 * Incept:   EPN, Thu Aug 14 08:45:54 2008
 *
 * Purpose:  Given i2k and kmin, kmax arrays, print them.
 *
 * Args:     i2k      - [0.k..M] = i, node k is pinned to residue i
 *           kmin     - [0.i..L] = k, min node k for residue i
 *           kmax     - [0.i..L] = k, max node k for residue i
 *           L        - length of current sequence
 *
 * Return:   <eslOK> on success.
 *
 */
int
DumpP7Bands(FILE *fp, int *i2k, int *kmin, int *kmax, int L)
{
  int i;

  fprintf(fp, "# %4s  %4s  %4s ... %4s\n", "i", "i2k", "kmin", "kmax");
  fprintf(fp, "# %4s  %4s  %13s\n", "----", "----", "-------------");
  for(i = 0; i <= L; i++) {
	fprintf(fp, "  %4d  %4d  %4d ... %4d\n", i, i2k[i], kmin[i], kmax[i]);
  }
  return eslOK;

}

/* Function: cp9_ForwardP7B()
 *
 * Purpose:  Runs the banded Forward dynamic programming algorithm on an
 *           input sequence (1..L). Complements cp9_BackwardP7B().
 *           The 'P7B' suffix indicates plan 7 HMM derived bands
 *           in the kmin and kmax arrays are applied.  This function
 *           was derived from cp9_Forward(), differences from that
 *           function were introduced solely to impose bands on the
 *           matrix.
 *
 *           Because of the bands, some options that exist to cp9_Forward()
 *           (like be_efficient and do_scan and reporting hits in scan mode)
 *           are not available here. This function is meant to be used
 *           solely for first stage of a Forward, Backward, Posterior type
 *           calculation.
 *
 *           Also due to bands, only L is passed as seq length, instead
 *           of i0 and j0 (seq start/stop).  This simplifies the application
 *           of bands kmin[i]/kmax[i] refers to residue i.
 *
 *           This function requires that local EL states are turned off, if
 *           they're not it returns. A separate function should exist to align
 *           with EL states on, I don't think it's worth the extra computations to
 *           make 1 function that handles both.
 *
 *           See additional notes in cp9_Forward() "Purpose" section.
 *
 * Args:
 *           cp9       - the CP9 HMM
 *           errbuf    - char buffer for error messages
 *           mx        - the matrix, expanded to correct size (if nec), and filled here
 *           dsq       - sequence in digitized form
 *           L         - start of target subsequence (1 for beginning of dsq)
 *           kmin      - [0.1..i..N] minimum k for residue i
 *           kmax      - [0.1..i..N] maximum k for residue i
 *           ret_sc    - RETURN: log P(S|M,bands)/P(S|R), as a bit score
 *
 * Returns:  eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
#define INBAND(i,k) ((k >= kmin[i]) && (k <= kmax[i]))

int
cp9_ForwardP7B(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int L, int *kmin, int *kmax, float *ret_sc)
{
  int          status;
  int          i;           /* j-W: position in the subsequence                             */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]          */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]          */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]          */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]              */
  int         *erow;        /* end score for each position [0..1]                           */
  int          M;           /* cp9->M, query length, number of consensus nodes of model */

  int          kp, kn, kx, kpcur, kpprv;

  /* Contract checks */
  if(cp9 == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, cp9 is NULL.\n");
  if(dsq == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, dsq is NULL.");
  if(mx == NULL)                       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, mx is NULL.\n");
  if(mx->M != cp9->M)                 ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, mx->M != cp9->M.\n");
  if(kmin == NULL || kmax == NULL)     ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, kmin and/or kmax == NULL.\n");
  if(cp9->flags & CPLAN9_EL)           ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B, cp9 EL flag up.\n");

  M = cp9->M;

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  /* gamma allocation and initialization.
   * This is a little SHMM that finds an optimal scoring parse
   * of multiple nonoverlapping hits. */

  /* Rearrange DP matrix for this seq */
  if((status = GrowCP9Matrix(mx, errbuf, L, M, kmin, kmax, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_ForwardP7B(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));

  /* Initialization of the zero row. */
  mmx[0][0] = 0;      /* M_0 is state B, and everything starts in B */
  imx[0][0] = -INFTY; /* I_0 is state N, can't get here without emitting*/
  dmx[0][0] = -INFTY; /* D_0 doesn't exist. */
  elmx[0][0]= -INFTY; /* can't go from B to EL state */
  erow[0]   = -INFTY;

  /* Because there's a D state for every node 1..M,
	 dmx[0][k] is possible for all k 1..M (if it's within kmin[0]..kmax[0]) */
  int sc;
  i = 0;
  kn = ESL_MAX(1, kmin[0]);
  kp = kn - kmin[0];
  for (k = kn; k <= kmax[0]; k++, kp++) {
	assert(kp >= 0);
	mmx[0][kp] = imx[0][kp] = elmx[0][kp] = -INFTY;      /* need seq to get here */
	sc = -INFTY;
	if(kp > 0) { /* if kp == 0, kp-1 is outside the bands */
	  sc = ILogsum(ILogsum(mmx[0][kp-1] + CP9TSC(cp9O_MD,k-1),
			   imx[0][kp-1] + CP9TSC(cp9O_ID,k-1)),
		   dmx[0][kp-1] + CP9TSC(cp9O_DD,k-1));
	}
	dmx[0][kp] = sc;
  }
  /* We can do a full parse through all delete states. */
  erow[0] = -INFTY;
  if(INBAND(0, M)) { erow[0] = dmx[0][M] + CP9TSC(cp9O_DM,M); }

  /*****************************************************************
   * The main loop: scan the sequence from position 1 to L.
   *****************************************************************/
  /* Recursion. */

  for (i = 1; i <= L; i++)
	{
	  prv = i-1;
	  cur = i;
	  int const *isc = cp9->isc[dsq[i]];
	  int const *msc = cp9->msc[dsq[i]];
	  int endsc     = -INFTY;
	  int sc;

	  if(kmin[i] == 0) {
	mmx[i][0]  = -INFTY;
	dmx[i][0]  = -INFTY;  /*D_0 is non-existent*/
	elmx[i][0] = -INFTY;  /*no EL state for node 0 */
	sc = ILogsum(ILogsum(mmx[i-1][0] + CP9TSC(cp9O_MI,0),
			     imx[i-1][0] + CP9TSC(cp9O_II,0)),
		     dmx[i-1][0] + CP9TSC(cp9O_DI,0));
	imx[i][0] = sc + isc[0];
	kn = 1; /* kmin[i] + 1 */
	  }
	  else {
	kn = kmin[i];
	  }

	  /*match state*/
	  kn = ESL_MAX(kn, (kmin[i-1]+1)); /* start at first cell from which we can look back to a valid cell at *mx[i-1][k-1] */
	  kx = ESL_MIN(kmax[i], kmax[i-1]+1);

	  /* NOT SURE ABOUT THIS AND HOW IT COUPLES WITH BLOCK ABOVE kmin[i] == 0 */
	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) mmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) mmx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kn - kmin[i-1];
	  for (k = kn; k <= kx; k++, kpcur++, kpprv++) {
	/*printf("M i: %d kpprv: %d\n", i, kpprv);*/
	assert((kpprv-1) >= 0);

	sc = ILogsum(ILogsum(mmx[i-1][kpprv-1] + CP9TSC(cp9O_MM,k-1),
			     imx[i-1][kpprv-1] + CP9TSC(cp9O_IM,k-1)),
		     dmx[i-1][kpprv-1] + CP9TSC(cp9O_DM,k-1));

	/* FIX ME: inefficient! check B->M_K transition */
	if(INBAND(i-1, 0)) { /* if i-1 is in k == 0's band */
	  assert(kmin[(i-1)] == 0);
	  if(mmx[i-1][0] != -INFTY)
	   sc = ILogsum(sc, mmx[i-1][0] + CP9TSC(cp9O_BM,k));
	}

	if(sc != -INFTY) {
	  mmx[i][kpcur] = sc + msc[k];
	  /* E state update */
	  endsc = ILogsum(endsc, mmx[i][kpcur] + CP9TSC(cp9O_ME,k));
	}
	else {
	  mmx[i][kpcur] = -INFTY;
	  /* don't update E state */
	}
	///printf("mmx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kpcur, mmx[i][kpcur]);
	  }

	  /* insert state*/
	  kn = ESL_MAX(kmin[i], kmin[i-1]);
	  kx = ESL_MIN(kmax[i], kmax[i-1]);

	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) imx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) imx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kn - kmin[i-1];
	  for (k = kn; k <= kx; k++, kpcur++, kpprv++) {
	/*insert state*/
	assert(kpprv >= 0);
	/* HERE, EVENTUALLY IF kmin/kmax differ b/t Match and Inserts:
	 * only look at match states from k that have i-1 within band */
	/* all insert states from k should have i-1 within band */
	/*printf("I i: %d kpprv: %d\n", i, kpprv);*/
	sc = ILogsum(ILogsum(mmx[i-1][kpprv] + CP9TSC(cp9O_MI,k),
			     imx[i-1][kpprv] + CP9TSC(cp9O_II,k)),
		     dmx[i-1][kpprv] + CP9TSC(cp9O_DI,k));
	if(sc != -INFTY) imx[i][kpcur] = sc + isc[k];
	else             imx[i][kpcur] = -INFTY;
	///printf("imx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kpcur, imx[i][kpcur]);
	  }

	  /*delete state*/
	  kn = kmin[i]+1;

	  for (kpcur = 0; kpcur < (kn - kmin[i]); kpcur++) dmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  for (k = kn; k <= kmax[i]; k++, kpcur++) { /* should I be adding one for delete off-by-one?? */
	sc = ILogsum(ILogsum(mmx[i][kpcur-1] + CP9TSC(cp9O_MD,k-1),
			     imx[i][kpcur-1] + CP9TSC(cp9O_ID,k-1)),
		     dmx[i][kpcur-1] + CP9TSC(cp9O_DD,k-1));
	dmx[i][kpcur] = sc;
	///printf("dmx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kpcur, dmx[i][kpcur]);
	  }
	  /*printf("mmx [jp:%d][%d]: %d\n", jp, k, mmx[j][k]);
	    printf("imx [jp:%d][%d]: %d\n", jp, k, imx[j][k]);
	    printf("dmx [jp:%d][%d]: %d\n", jp, k, dmx[j][k]);
	    printf("elmx[jp:%d][%d]: %d\n", jp, k, elmx[j][k]);*/

	  if(INBAND(i, M)) {
	endsc = ILogsum(ILogsum(endsc, dmx[i][M-kmin[i]] + CP9TSC(cp9O_DM,M)), /* transition from D_M -> end */
			imx[i][M-kmin[i]] + CP9TSC(cp9O_IM,M)); /* transition from I_M -> end */
	  }
	  /* transition penalty to EL incurred when EL was entered */
	  /*printf("endsc: %d\n", endsc);*/

	  erow[i] = endsc;
	} /* end loop over end positions i */

  *ret_sc = Scorify(erow[L]);
  ESL_DPRINTF1(("cp9_ForwardP7B() return score: %10.4f\n", Scorify(erow[L])));

  return eslOK;
}

/* Function: cp9_ForwardP7B_OLD_WITH_EL()
 *
 * Purpose:  Runs the banded Forward dynamic programming algorithm on an
 *           input sequence (1..L). Complements cp9_BackwardP7B().
 *           The 'P7B' suffix indicates plan 7 HMM derived bands
 *           in the kmin and kmax arrays are applied.  This function
 *           was derived from cp9_Forward(), differences from that
 *           function were introduced solely to impose bands on the
 *           matrix.
 *
 *           Because of the bands, some options that exist to cp9_Forward()
 *           (like be_efficient and do_scan and reporting hits in scan mode)
 *           are not available here. This function is meant to be used
 *           solely for first stage of a ForwardP7B, BackwardP7B, Posterior type
 *           calculation.
 *
 *           Also due to bands, only L is passed as seq length, instead
 *           of i0 and j0 (seq start/stop).  This simplifies the application
 *           of bands kmin[i]/kmax[i] refers to residue i.
 *
 *           See additional notes in cp9_Forward() "Purpose" section.
 *
 *           NOTE: EPN, Thu Aug 14 09:54:36 2008
 *           This is the original version written to potentially handle EL
 *           states, but I think omitting them when they're off is significantly
 *           more efficient, so I wrote a competing function called
 *           cp9_ForwardP7B(). Note the included EL dp steps HAVE NOT BEEN
 *           TESTED YET! I just left them here as a starting point if I
 *           ever want to implement them.
 *
 * Args:
 *           cp9       - the CP9 HMM
 *           errbuf    - char buffer for error messages
 *           mx        - the matrix, expanded to correct size (if nec), and filled here
 *           dsq       - sequence in digitized form
 *           L         - start of target subsequence (1 for beginning of dsq)
 *           kmin      - [0.1..i..N] minimum k for residue i
 *           kmax      - [0.1..i..N] maximum k for residue i
 *           ret_sc    - RETURN: log P(S|M,bands)/P(S|R), as a bit score
 *
 * Returns:  eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */

int
cp9_ForwardP7B_OLD_WITH_EL(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int L, int *kmin, int *kmax, float *ret_sc)
{
  int          status;
  int          i;           /* j-W: position in the subsequence                             */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int          c;           /* counter for EL states                                        */
  int          M;           /* cp9->M, query length, number of consensus nodes of model */

  int          kn, kx, kpcur, kpprv, kpprv_el;

  /* Contract checks */
  if(cp9 == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B_OLD_WITH_EL, cm->cp9 is NULL.\n");
  if(dsq == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B_OLD_WITH_EL, dsq is NULL.");
  if(mx == NULL)                       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B_OLD_WITH_EL, mx is NULL.\n");
  if(mx->M != cp9->M)                  ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B_OLD_WITH_EL, mx->M != cp9->M.\n");
  if(kmin == NULL || kmax == NULL)     ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ForwardP7B_OLD_WITH_EL, kmin and/or kmax == NULL.\n");

  M = cp9->M;

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  /* gamma allocation and initialization.
   * This is a little SHMM that finds an optimal scoring parse
   * of multiple nonoverlapping hits. */

  /* Grow DP matrix if nec, to either 2 rows or L+1 rows (depending on be_efficient),
   * stays M+1 columns */
  if((status = GrowCP9Matrix(mx, errbuf, L, M, kmin, kmax, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_ForwardP7B_OLD_WITH_EL(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));

  /* Initialization of the zero row. */
  mmx[0][0] = 0;      /* M_0 is state B, and everything starts in B */
  imx[0][0] = -INFTY; /* I_0 is state N, can't get here without emitting*/
  dmx[0][0] = -INFTY; /* D_0 doesn't exist. */
  elmx[0][0]= -INFTY; /* can't go from B to EL state */
  erow[0]   = -INFTY;

  /* Because there's a D state for every node 1..M,
	 dmx[0][k] is possible for all k 1..M */
  int sc;
  i = 0;
  kn    = ESL_MAX(1, kmin[0]+1);
  kpcur = kn - kmin[0];
  for (k = kn; k <= kmax[0]; k++, kpcur++) {
	assert(kpcur >= 1);
	mmx[0][kpcur] = imx[0][kpcur] = elmx[0][kpcur] = -INFTY;      /* need seq to get here */
	sc = ILogsum(ILogsum(mmx[0][kpcur-1] + CP9TSC(cp9O_MD,k-1),
			 imx[0][kpcur-1] + CP9TSC(cp9O_ID,k-1)),
		 dmx[0][kpcur-1] + CP9TSC(cp9O_DD,k-1));
	dmx[0][kpcur] = sc;
  }
  /* We can do a full parse through all delete states. */
  erow[0] = -INFTY;
  if(INBAND(0, M)) { erow[0] = dmx[0][M] + CP9TSC(cp9O_DM,M); }

  /*****************************************************************
   * The main loop: scan the sequence from position 1 to L.
   *****************************************************************/
  /* Recursion. */

  for (i = 1; i <= L; i++)
	{
	  prv = i-1;
	  cur = i;
	  int const *isc = cp9->isc[dsq[i]];
	  int const *msc = cp9->msc[dsq[i]];
	  int endsc     = -INFTY;
	  int el_selfsc = cp9->el_selfsc;
	  int sc;

	  if(kmin[i] == 0) {
	mmx[i][0]  = -INFTY;
	dmx[i][0]  = -INFTY;  /*D_0 is non-existent*/
	elmx[i][0] = -INFTY;  /*no EL state for node 0 */
	sc = ILogsum(ILogsum(mmx[i-1][0] + CP9TSC(cp9O_MI,0),
			     imx[i-1][0] + CP9TSC(cp9O_II,0)),
		     dmx[i-1][0] + CP9TSC(cp9O_DI,0));
	imx[i][0] = sc + isc[0];
	kn = 1; /* kmin[i] + 1 */
	  }
	  else {
	kn = kmin[i];
	  }

	  /*match state*/
	  kn = ESL_MAX(kn, (kmin[i-1]+1)); /* start at first cell from which we can look back to a valid cell at *mx[i-1][k-1] */
	  kx = ESL_MIN(kmax[i], kmax[i-1]+1);

	  /* NOT SURE ABOUT THIS AND HOW IT COUPLES WITH BLOCK ABOVE kmin[i] == 0 */
	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) mmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) mmx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) elmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) elmx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kn - kmin[i-1];
	  for (k = kn; k <= kx; k++, kpcur++, kpprv++) {
	/*printf("M i: %d kpprv: %d\n", i, kpprv);*/
	assert((kpprv-1) >= 0);

	sc = ILogsum(ILogsum(mmx[i-1][kpprv-1] + CP9TSC(cp9O_MM,k-1),
			     imx[i-1][kpprv-1] + CP9TSC(cp9O_IM,k-1)),
		     dmx[i-1][kpprv-1] + CP9TSC(cp9O_DM,k-1));

	/* FIX ME: inefficient! check B->M_K transition */
	if(INBAND(i-1, 0)) { /* if i-1 is in k == 0's band */
	  assert(kmin[(i-1)] == 0);
	  if(mmx[i-1][0] != -INFTY)
	   sc = ILogsum(sc, mmx[i-1][0] + CP9TSC(cp9O_BM,k));
	}

	/* check possibility we came from an EL, if they're valid */
	for(c = 0; c < cp9->el_from_ct[k]; c++) { /* el_from_ct[k] is >= 0 */
	  if(INBAND(i-1, cp9->el_from_idx[k][c])) {
	    kpprv_el = cp9->el_from_idx[k][c] - kmin[(i-1)];
	    sc = ILogsum(sc, elmx[i-1][kpprv_el]);
	  }
	} /* transition penalty to EL incurred when EL was entered */
	if(sc != -INFTY) {
	  mmx[i][kpcur] = sc + msc[k];
	  /* E state update */
	  endsc = ILogsum(endsc, mmx[i][kpcur] + CP9TSC(cp9O_ME,k));
	}
	else {
	  mmx[i][kpcur] = -INFTY;
	  /* don't update E state */
	}
	/*printf("k: %4d mmx[i:%4d][kpcur:%4d]: %d\n", k, i, kpcur, mmx[i][kpcur]);*/

	/* el state */
	sc = -INFTY;
	if((cp9->flags & CPLAN9_EL) && cp9->has_el[k]) /* not all HMM nodes have an EL state (for ex:
								  HMM nodes that map to right half of a MATP_MP) */
	  {
	    if(mmx[i][kpcur] != -INFTY) {
	      kpprv_el = k - kmin[(i-1)];
	      sc = ILogsum(mmx[i][kpcur]  + CP9TSC(cp9O_MEL,k), /* transitioned from cur node's match state */
			   elmx[i-1][kpprv_el] + el_selfsc);      /* transitioned from cur node's EL state emitted ip on transition */
	    }
	  }
	elmx[i][kpcur] = sc;
	  }

	  /* insert state*/
	  kn = ESL_MAX(kmin[i], kmin[i-1]);
	  kx = ESL_MIN(kmax[i], kmax[i-1]);

	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) imx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) imx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kn - kmin[i-1];
	  for (k = kn; k <= kx; k++, kpcur++, kpprv++) {
	/*insert state*/
	assert(kpprv >= 0);
	/* HERE, EVENTUALLY IF kmin/kmax differ b/t Match and Inserts:
	 * only look at match states from k that have i-1 within band */
	/* all insert states from k should have i-1 within band */
	/*printf("I i: %d kpprv: %d\n", i, kpprv);*/
	sc = ILogsum(ILogsum(mmx[i-1][kpprv] + CP9TSC(cp9O_MI,k),
			     imx[i-1][kpprv] + CP9TSC(cp9O_II,k)),
		     dmx[i-1][kpprv] + CP9TSC(cp9O_DI,k));
	if(sc != -INFTY) imx[i][kpcur] = sc + isc[k];
	else             imx[i][kpcur] = -INFTY;
	/*printf("k: %4d imx[i:%4d][kpcur:%4d]: %d\n", k, i, kpcur, imx[i][kpcur]);*/
	  }

	  /*delete state*/
	  kn = kmin[i]+1;

	  for (kpcur = 0; kpcur < (kn - kmin[i]); kpcur++) dmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  kpcur = kn - kmin[i]; /* unnec, loop above ends with this */
	  for (k = kn; k <= kmax[i]; k++, kpcur++) { /* should I be adding one for delete off-by-one?? */
	sc = ILogsum(ILogsum(mmx[i][kpcur-1] + CP9TSC(cp9O_MD,k-1),
			     imx[i][kpcur-1] + CP9TSC(cp9O_ID,k-1)),
		     dmx[i][kpcur-1] + CP9TSC(cp9O_DD,k-1));
	dmx[i][kpcur] = sc;
	/*printf("k: %4d dmx[i:%4d][kpcur:%4d]: %d\n", k, i, kpcur, dmx[i][kpcur]);*/
	  }
	  /*printf("mmx [jp:%d][%d]: %d\n", jp, k, mmx[j][k]);
	    printf("imx [jp:%d][%d]: %d\n", jp, k, imx[j][k]);
	    printf("dmx [jp:%d][%d]: %d\n", jp, k, dmx[j][k]);
	    printf("elmx[jp:%d][%d]: %d\n", jp, k, elmx[j][k]);*/

	  if(INBAND(i, M)) {
	endsc = ILogsum(ILogsum(endsc, dmx[i][M-kmin[i]] + CP9TSC(cp9O_DM,M)), /* transition from D_M -> end */
			imx[i][M-kmin[i]] + CP9TSC(cp9O_IM,M)); /* transition from I_M -> end */
	for(c = 0; c < cp9->el_from_ct[M+1]; c++) { /* el_from_ct[k] is >= 0 */
	  if(INBAND(i, cp9->el_from_idx[M+1][c])) {
	    kpprv_el = cp9->el_from_idx[M+1][c] - kmin[i];
	    endsc = ILogsum(endsc, elmx[i][kpprv_el]);
	  }
	}
	  }
	/* transition penalty to EL incurred when EL was entered */
	  /*printf("endsc: %d\n", endsc);*/

	  erow[i] = endsc;
	} /* end loop over end positions i */

  *ret_sc = Scorify(erow[L]);
  ESL_DPRINTF1(("cp9_ForwardP7B_OLD_WITH_EL() return score: %10.4f\n", Scorify(erow[L])));

  return eslOK;
}

/* Function: cp9_BackwardP7B()
 *
 * Purpose:  Runs the banded Backward dynamic programming algorithm on an
 *           input sequence (1..L). Complements cp9_ForwardP7B().
 *           The 'P7B' suffix indicates plan 7 HMM derived bands
 *           in the kmin and kmax arrays are applied.  This function
 *           was derived from cp9_Backward(), differences from that
 *           function were introduced solely to impose bands on the
 *           matrix.
 *
 *           Because of the bands, some options that exist to cp9_Forward()
 *           (like be_efficient and do_scan and reporting hits in scan mode)
 *           are not available here. This function is meant to be used
 *           solely for second stage of a Forward, Backward, Posterior type
 *           calculation.
 *
 *           Also due to bands, only L is passed as seq length, instead
 *           of i0 and j0 (seq start/stop).  This simplifies the application
 *           of bands kmin[i]/kmax[i] refers to residue i.
 *
 *           This function requires that local EL states are turned off, if
 *           they're not it returns. A separate function should exist to align
 *           with EL states on, I don't think it's worth the extra computations to
 *           make 1 function that handles both.
 *
 *           See additional notes in cp9_Backward() "Purpose" section.
 *
 * Args:
 *           cp9       - the CP9 HMM
 *           errbuf    - char buffer for error messages
 *           mx        - the matrix, expanded to correct size (if nec), and filled here
 *           dsq       - sequence in digitized form
 *           L         - start of target subsequence (1 for beginning of dsq)
 *           kmin      - [0.1..i..N] minimum k for residue i
 *           kmax      - [0.1..i..N] maximum k for residue i
 *           ret_sc    - RETURN: log P(S|M,bands)/P(S|R), as a bit score, this is B->M[0][0]
 *
 * Returns:  eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
int
cp9_BackwardP7B(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int L, int *kmin, int *kmax, float *ret_sc)
{
  int          status;
  int          i;           /*     j-W: position in the subsequence                         */
  int          k;           /* CP9 HMM node position                                        */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int          c;           /* counter for EL states */
  int          M;           /* cp9->M */
  int          kpcur, kpprv, kpcur_el;
  int          kprv, kprvn, kprvx;
  int          kn, kx;
  float        fsc;

  /* Contract checks */
  if(cp9 == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_BackwardP7B, cp9 is NULL.\n");
  if(dsq == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_BackwardP7B, dsq is NULL.");
  if(mx == NULL)                       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_BackwardP7B, mx is NULL.\n");
  if(mx->M != cp9->M)                  ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_BackwardP7B, mx->M != cm->clen.\n");
  if(cp9->flags & CPLAN9_EL)       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_BackwardP7B, cp9 EL flag up!\n");

  M = cp9->M;

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  /* Rearrange DP matrix for this seq */
  if((status = GrowCP9Matrix(mx, errbuf, L, M, kmin, kmax, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_BackwardP7B(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));

  /* Initialization of the L row. */
  i = L;

  /*******************************************************************
   * 0 Handle EL, looking at EL_k->E for all valid k.
   * we're going backwards so we have to work out of order, we could get
   * around this by storing the nodes each EL goes TO in an el_to_ct[] vec. */
  /* init to -INFTY */
  kpcur = 0;
  for (k = kmin[i]; k <= kmax[i]; k++, kpcur++) elmx[i][kpcur] = -INFTY;
  if(cp9->flags & CPLAN9_EL)
	{
	  for(c = 0; c < cp9->el_from_ct[cp9->M+1]; c++) /* el_from_ct[cp9->M+1] holds # ELs that can go to END */
	if(INBAND(i, cp9->el_from_idx[M+1][c])) {
	  kpcur_el = cp9->el_from_idx[M+1][c] - kmin[i];
	  elmx[i][kpcur_el] = 0.;
	}
	}
  /*******************************************************************/

  /* elmx[cur][cp9->M] is either 0 (if EL_M exists (it would nec be in el_from_idx[cp9->M+1] array if it does, so
   * it would be filled with 0 in above loop), or -INFTY if it doesn't exist. We don't add possibility of EL_M -> EL_M
   * self loop b/c it's impossible to do that without emitting, and we've already seen our last res emitted.
   * either way we don't have to modify it */

  if(INBAND(i, M)) { /* if i is in k == M's band */
	assert(M == kmax[i]);
	kpcur = M-kmin[i];
	mmx[i][kpcur]  = 0. +
	  ILogsum(elmx[i][kpcur] + CP9TSC(cp9O_MEL, M),/* M_M<-EL_M<-E, with 0 self loops in EL_M */
	      CP9TSC(cp9O_ME,M));                      /* M_M<-E ... everything ends in E (the 0; 2^0=1.0) */
	mmx[i][kpcur] += cp9->msc[dsq[i]][M];  /* ... + emitted match symbol */
	imx[i][kpcur]  = 0. + CP9TSC(cp9O_IM,M);     /* I_M<-E ... everything ends in E (the 0; 2^0=1.0) */
	imx[i][kpcur] += cp9->isc[dsq[i]][M];  /* ... + emitted insert symbol */
	dmx[i][kpcur]  = CP9TSC(cp9O_DM,M);          /* D_M<-E */
	kx = M-1;
	kpcur--;
  }
  else { kx = kmax[i]; kpcur = kmax[i]-kmin[i]; }
  /*******************************************************************
   * No need to look at EL_k->M_M b/c elmx[i] with i == L means last emitted residue was L+1
   * and this is impossible if we've come from M_M (only would be valid if we were coming from
   * E which is handled above with the EL_k->E code).
   *******************************************************************/

  for (k = kx; k >= kmin[i]; k--, kpcur--)
	{
	  mmx[i][kpcur]  = 0 + CP9TSC(cp9O_ME,k);  /*M_k<- E */

	  if(INBAND(i, k+1)) {
	mmx[i][kpcur]  = ILogsum(mmx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_MD,k));
	  }
	  if(cp9->flags & CPLAN9_EL)
	mmx[i][kpcur]  = ILogsum(mmx[i][kpcur], elmx[i][kpcur] + CP9TSC(cp9O_MEL,k));

	  mmx[i][kpcur] += cp9->msc[dsq[i]][k];

	  /*******************************************************************
	   * No need to look at EL_k->M_M b/c elmx[i] with i == L means last emitted residue was L+1
	   * and this is impossible if we've come from M_M (only would be valid if we were coming from
	   * E which is handled above with the EL_k->E code).
	   *******************************************************************/

	  if(INBAND(i, k+1)) {
	imx[i][kpcur]  = dmx[i][kpcur+1] + CP9TSC(cp9O_ID,k);
	imx[i][kpcur] += cp9->isc[dsq[i]][k];

	dmx[i][kpcur]  = dmx[i][kpcur+1] + CP9TSC(cp9O_DD,k);
	  }
	  else {
	imx[i][kpcur] = -INFTY;
	dmx[i][kpcur] = -INFTY;
	  }
	  /* elmx[i][k] was set above, out of order */

	  ////printf("mmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, mmx[i][kpcur]);
	  ////printf("imx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, imx[i][kpcur]);
	  ////printf("dmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, dmx[i][kpcur]);
	}

  if(INBAND(i, 0)) {
	/* remember M_0 is special, the B state, a non-emitter */
	mmx[i][0]  = dmx[i][1] + CP9TSC(cp9O_MD,0); /* M_0(B)->D_1, no seq emitted, all deletes */
	/* above line is diff from CPBackwardOLD() which has mmx[i][0] = -INFTY; */
	imx[i][0]  = dmx[i][1] + CP9TSC(cp9O_ID,0);
	imx[i][0] += cp9->isc[dsq[i]][0];

	dmx[i][0]   = -INFTY; /*D_0 doesn't exist*/
	elmx[i][0]  = -INFTY; /*EL_0 doesn't exist*/
  }

  /*****************************************************************
   * The main loop: scan the sequence from position j0-1 to i0.
   *****************************************************************/
  /* Reision */
  for (i = L-1; i >= 1; i--)
	{
	  /* init EL mx to -INFTY */
	  kpcur = 0;
	  for (k = kmin[i]; k <= kmax[i]; k++, kpcur++) elmx[i][kpcur] = -INFTY;

	  /* Deal with node k == M first */
	  /* elmx[i][k] could have come from self (EL_k), we
	   * can't have come from END b/c we haven't emitted the last res of the seq yet.
	   */
	  if(INBAND(i, M)) {
	kpcur = M-kmin[i];
	if((cp9->flags & CPLAN9_EL) && (cp9->has_el[M]))
	  elmx[i][kpcur] = elmx[i][kpcur] + cp9->el_selfsc;

	if(INBAND(i+1, M)) {
	  kpprv = M-kmin[i+1];
	  mmx[i][kpcur]  = imx[i+1][kpprv] + CP9TSC(cp9O_MI,M);
	  mmx[i][kpcur] += cp9->msc[dsq[i]][M];

	  imx[i][kpcur]  = imx[i+1][kpprv] + CP9TSC(cp9O_II,M);
	  imx[i][kpcur] += cp9->isc[dsq[i]][M];

	  dmx[i][M]  = imx[i+1][kpprv] + CP9TSC(cp9O_DI,M);
	}
	else {
	  mmx[i][kpcur] = imx[i][kpcur] = dmx[i][kpcur] = -INFTY;
	}

	if((cp9->flags & CPLAN9_EL) && (cp9->has_el[M]))
	  mmx[i][kpcur] = ILogsum(mmx[i][kpcur], elmx[i][kpcur] + CP9TSC(cp9O_MEL,M));

	/*******************************************************************
	 * 1b Handle EL, looking at EL_k->M_M for all valid k.
	 * EL_k->M_M transition, which has no transition penalty */
	if(INBAND(i+1, M)) {
	  if(cp9->flags & CPLAN9_EL)
	    {
	      for(c = 0; c < cp9->el_from_ct[M]; c++) /* el_from_ct[M] holds # ELs that can go to M_M */
		if(INBAND(i, cp9->el_from_idx[M][c])) {
		  kpcur_el = cp9->el_from_idx[M][c] - kmin[i];
		  elmx[i][kpcur_el] = ILogsum(elmx[i][kpcur_el], mmx[i+1][kpprv]);
		}
	    }
	}
	  }

	  /*********************************************************/
	  /* MATCH: *_k <- M_k+1 transitions FROM a match state*/
	  kn = ESL_MAX(kmin[i], kmin[i+1]-1); /* start at first cell from which we can look ahead to a valid cell at mmx[i-1][k-1] */
	  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
	  kx = ESL_MIN(kmax[i], kmax[i+1]-1);

	  for (kpcur = 0;            kpcur < (kn - kmin[i]);   kpcur++) mmx[i][kpcur] = imx[i][kpcur] = dmx[i][kpcur] = elmx[i][kpcur] = -INFTY; /* impossible to reach these guys */
	  for (kpcur = kx-kmin[i]+1; kpcur <= kmax[i]-kmin[i]; kpcur++) mmx[i][kpcur] = imx[i][kpcur] = dmx[i][kpcur] = elmx[i][kpcur] = -INFTY; /* impossible to reach these guys */

	  kpcur = kx - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kx - kmin[i+1];
	  for (k = kx; k >= kn; k--, kpcur--, kpprv--)
	{
	  /* Handle EL, looking at EL_k->M_k for all valid k and EL_k->EL_k
	   * we're going backwards so we have to work out of order
	   * we could get around this by storing the nodes each EL goes TO
	   * in an el_to_ct[] vector. */
	  if(cp9->flags & CPLAN9_EL) {
	    for(c = 0; c < cp9->el_from_ct[k]; c++) { /* el_from_ct[k] holds # ELs that can go to M_k */
	      if(INBAND(i, cp9->el_from_idx[k][c])) {
		kpcur_el = cp9->el_from_idx[k][c] - kmin[i];
		elmx[i][kpcur_el] = ILogsum(elmx[i][kpcur_el], mmx[i+1][kpprv]);
		/* EL<-M, penalty incurred when we enter EL (i.e. leave going backwards) */
	      }
	    }
	  }

	  /* Finish off elmx[i][k] with possibility of coming from self (EL_k),
	   * elmx[i][k] will have been filled by block above for ks > current k,
	   * no M_k -> EL_k' with k' > k */
	  if(INBAND(i+1, k)) {
	    if((cp9->flags & CPLAN9_EL) && (cp9->has_el[k]))
	      elmx[i][k] = ILogsum(elmx[i][kpcur], elmx[i+1][kpprv] + cp9->el_selfsc);
	  }
	  mmx[i][kpcur] = mmx[i+1][kpprv+1] + CP9TSC(cp9O_MM,k);
	  imx[i][kpcur] = mmx[i+1][kpprv+1] + CP9TSC(cp9O_IM,k);
	  dmx[i][kpcur] = mmx[i+1][kpprv+1] + CP9TSC(cp9O_DM,k);
	}

	  /*********************************************************/
	  /* INSERTIONS: *_k <- I_k+1 transitions FROM a insert state*/
	  kn = ESL_MAX(kmin[i], kmin[i+1]); /* start at first cell from which we can look ahead to a valid cell at imx[i-1][k] */
	  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
	  kx = ESL_MIN(kmax[i], kmax[i+1]);

	  kpcur = kx - kmin[i]; /* unnec, loop above ends with this */
	  kpprv = kx - kmin[i+1];
	  for (k = kx; k >= kn; k--, kpcur--, kpprv--)
	{
	  mmx[i][kpcur] = ILogsum(mmx[i][kpcur], imx[i+1][kpprv] + CP9TSC(cp9O_MI,k));
	  imx[i][kpcur] = ILogsum(imx[i][kpcur], imx[i+1][kpprv] + CP9TSC(cp9O_II,k));
	  dmx[i][kpcur] = ILogsum(dmx[i][kpcur], imx[i+1][kpprv] + CP9TSC(cp9O_DI,k));
	}

	  /*********************************************************/
	  /* DELETIONS: *_k <- D_k+1 transitions FROM a delete state*/
	  kn = ESL_MAX(kmin[i], kmin[i]-1); /* start at first cell from which we can look ahead to a valid cell at imx[i-1][k] */
	  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
	  kx = ESL_MIN(kmax[i], kmax[i]-1);

	  kpcur = kx - kmin[i]; /* unnec, loop above ends with this */
	  for (k = kx; k >= kn; k--, kpcur--)
	{
	  mmx[i][kpcur] = ILogsum(mmx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_MD,k));
	  imx[i][kpcur] = ILogsum(imx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_ID,k));
	  dmx[i][kpcur] = ILogsum(dmx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_DD,k));

	  /* now add in the emission score */
	  mmx[i][kpcur] += cp9->msc[dsq[i]][k];
	  imx[i][kpcur] += cp9->isc[dsq[i]][k];
	}
	  /* there's one valid cell that we didn't consider in above loop to add emission score
	   * b/c D_k <- D_k+1 (so k+1 is out of bounds for Delete) */
	  for(k = kx+1; k <= kmax[i]; k++) {
	kpcur = k - kmin[i]; /* unnec, loop above ends with this */
	mmx[i][kpcur] += cp9->msc[dsq[i]][k];
	imx[i][kpcur] += cp9->isc[dsq[i]][k];
	  }
	  /*********************************************************/
	  kpcur = kmax[i] - kmin[i];
	  for(k = kmax[i]; k >= kmin[i] && k > 0; k--, kpcur--) {
	////printf("mmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, mmx[i][kpcur]);
	////printf("imx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, imx[i][kpcur]);
	////printf("dmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, dmx[i][kpcur]);
	  }
	  /* special case when k == 0 */
	  kpcur = 0;
	  kpprv = 0 - kmin[i+1];
	  if(INBAND(i, 0)) {
	assert(kmin[i] == 0);
	dmx[i][kpcur]  = -INFTY; /* D_0 does not exist */
	elmx[i][kpcur] = -INFTY; /* EL_0 does not exist */

	/* INSERT k=0 */
	imx[i][kpcur] = -INFTY;
	/* imx[i][0] is filled same as imx[i][1..k] in the loop above */
	if(INBAND(i+1, 1)) {
	  if(mmx[i+1][kpprv+1] != -INFTY)
	    imx[i][kpcur] = ILogsum(imx[i][kpcur], mmx[i+1][kpprv+1] + CP9TSC(cp9O_IM,0));
	}
	if(INBAND(i+1, 0)) {
	  if(imx[i+1][kpprv] != -INFTY)
	    imx[i][kpcur] = ILogsum(imx[i][kpcur], imx[i+1][kpprv] + CP9TSC(cp9O_II,0));
	}
	if(INBAND(i, 1)) {
	  if(dmx[i][kpcur+1] != -INFTY)
	    imx[i][kpcur] = ILogsum(imx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_ID,0));
	}

	/*M_0 is the B state, it doesn't emit, and can be reached from any match via a begin transition */
	kprvn = ESL_MAX(1, kmin[i+1]);
	kprvx = kmax[i+1];
	/* careful, don't change kpcur - this is a special case the M_0 state, we loop over all M_k children, only kpprv changes */
	kpprv = kprvx - kmin[i+1];
	mmx[i][kpcur] = -INFTY;
	for(kprv = kprvx; kprv >= kprvn; kprv--, kpprv--) {
	  if(mmx[i+1][kpprv] != -INFTY)
	    mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (mmx[i+1][kpprv] + CP9TSC(cp9O_BM,kprv)));
	}
	k = 0;
	if(INBAND(i+1, 0)) {
	  kpprv = k - kmin[i+1];
	  if(imx[i+1][kpprv] != -INFTY) {
	    mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (imx[i+1][kpprv] + CP9TSC(cp9O_MI,0)));
	  }
	}
	if(INBAND(i, 1)) {
	  if(dmx[i][kpcur+1] != -INFTY) {
	    mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (dmx[i][kpcur+1] + CP9TSC(cp9O_MD,0)));     /* B->D_1 */
	  }
	}
	  }
	  ////printf("mmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, 0, kpcur, mmx[i][kpcur]);
	  ////printf("imx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, 0, kpcur, imx[i][kpcur]);
	  ////printf("dmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, 0, kpcur, dmx[i][kpcur]);
	}

  /*******************************************************************/
  /* Special case: i == 0 */

  /* initialize all match, inserts, deletes and ELs to -INFTY
   * deletes and M_0 cells MAY get changed later, inserts and ELs always stay -INFTY
   * b/c we need at least 1 residue to get to those cells */

  i = 0;
  kpcur = k - kmin[0];
  for (kpcur = 0; kpcur <= kmax[0] - kmin[0]; kpcur++) mmx[i][kpcur] = imx[i][kpcur] = dmx[i][kpcur] = elmx[i][kpcur] = -INFTY;

  /* D_M(i == 0) <- I_M(i = 1) */
  if(INBAND(i, M)) {
	kpcur = M - kmin[i];
	kpprv = M - kmin[i+1];
	if(INBAND(i+1, M)) {
	  dmx[i][kpcur]  = imx[i+1][kpprv] + CP9TSC(cp9O_DI,M);
	}
  }

  /* update D_k(i == 0) cells */
  /* D_k(i == 0) <- M_k+1(i == 1) */
  kn = ESL_MAX(kmin[i], kmin[i+1]-1); /* start at first cell from which we can look back to a valid cell at *mx[i-1][k-1] */
  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
  kx = ESL_MIN(kmax[i], kmax[i+1]-1);
  kpcur = kx - kmin[i];
  kpprv = kx - kmin[i+1];
  for (k = kx; k >= kn; k--, kpcur--, kpprv--)
	dmx[i][kpcur]  = mmx[i+1][kpprv+1] + CP9TSC(cp9O_DM,k);

  /* D_k(i == 0) <- I_k(i == 1) */
  kn = ESL_MAX(kmin[i], kmin[i+1]); /* start at first cell from which we can look ahead to a valid cell at imx[i-1][k] */
  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
  kx = ESL_MIN(kmax[i], kmax[i+1]);
  kpcur = kx - kmin[i]; /* unnec, loop above ends with this */
  kpprv = kx - kmin[i+1];
  for (k = kx; k >= kn; k--, kpcur--, kpprv--)
	dmx[i][kpcur] = ILogsum(dmx[i][kpcur], imx[i+1][kpprv] + CP9TSC(cp9O_DI,k));

  /* D_k(i == 0) <- D_k+1(i == 0) */
  kn = ESL_MAX(kmin[i], kmin[i]-1); /* start at first cell from which we can look ahead to a valid cell at imx[i-1][k] */
  kn = ESL_MAX(kn, 1); /* kn can't go all the way down to 0, that's a special case, handled outside the main loop */
  kx = ESL_MIN(kmax[i], kmax[i]-1);
  kpcur = kx - kmin[i]; /* unnec, loop above ends with this */
  for (k = kx; k >= kn; k--, kpcur--)
	dmx[i][kpcur] = ILogsum(dmx[i][kpcur], dmx[i][kpcur+1] + CP9TSC(cp9O_DD,k));

	////printf("mmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, mmx[i][kpcur]);
	////printf("imx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, imx[i][kpcur]);
	////printf("dmx[i:%4d][k:%4d(kp:%4d)] %10d\n", i, k, kpcur, dmx[i][kpcur]);

  /* Case when k == 0 (i is still 0) */
  k = 0;
  if(INBAND(i, 0)) {
	assert(kmin[i]  == 0);
	imx[i][0] = -INFTY; /* need seq to get here */
	dmx[i][0]   = -INFTY; /* D_0 does not exist */
	elmx[i][0]  = -INFTY; /* EL_0 does not exist */
	mmx[i][0] = -INFTY;

	/*M_0 is the B state, it doesn't emit, and can be reached from any match via a begin transition */
	kprvn = ESL_MAX(1, kmin[i+1]);
	kprvx = kmax[i+1];

	kpcur = 0; /* special case, M_0 = B state */
	/* careful, this is a different assignment to kpcur b/c it's the M_0 state, we loop over all M_k children, only kpprv changes */
	kpprv = kprvx - kmin[i+1];
	mmx[i][kpcur] = -INFTY;
	for(kprv = kprvx; kprv >= kprvn; kprv--, kpprv--) {
	  if(mmx[i+1][kpprv] != -INFTY)
	mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (mmx[i+1][kpprv] + CP9TSC(cp9O_BM,kprv)));
	}
	k = 0;
	if(INBAND(i+1, 0)) {
	  kpprv = k - kmin[i+1];
	  if(imx[i+1][kpprv] != -INFTY) {
	mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (imx[i+1][kpprv] + CP9TSC(cp9O_MI,0)));
	  }
	}
	if(INBAND(i, 1)) {
	  if(dmx[i][kpcur+1] != -INFTY) {
	mmx[i][kpcur] = ILogsum(mmx[i][kpcur], (dmx[i][kpcur+1] + CP9TSC(cp9O_MD,0)));     /* B->D_1 */
	  }
	}
  }
  /* No EL contribution here, can't go B->EL_* */

  fsc = Scorify(mmx[i][0]);
  /**********************************************************************************/
  /* End of Backward recursion */

  ESL_DPRINTF1(("cp9_BackwardP7B() return score: %10.4f\n", fsc));
  return eslOK;
}

/* Function: cp9_CheckFBP7B()
 *
 * Purpose:  Debugging function to make sure the P7 banded
 *           DP functions cp9_ForwardP7B() and cp9_BackwardP7B()
 *            are working by checking:
 *           For all positions i, and states k within kmin[i]..kmax[i]:
 *             sum_k f[i][k] * b[i][k] = P(x|hmm)
 *
 * Args:     fmx    - p7 banded forward dp matrix, already filled
 *           bmx    - p7 banded backward dp matrix, already filled
 *           hmm    - the model
 *           sc     - P(x|hmm, p7 bands) the probability of the entire
 *                    seq given the model
 *           i0     - start of target subsequence (often 1, beginning of dsq)
 *           j0     - end of target subsequence (often L, end of dsq)
 *           dsq    - the digitized sequence
 *
 * Note about sequence position indexing: although this function
 * works on a subsequence from i0 to j0, fmx and bmx have offset indices,
 * from 1 to L, with L = j0-i0+1.
 *
 * Return:   eslOK on success;
 *           eslFAIL if any residue fails check
 */
int
cp9_CheckFBP7B(CP9_MX *fmx, CP9_MX *bmx, CP9_t *hmm, char *errbuf, float sc, int i0, int j0, ESL_DSQ *dsq, int *kmin, int *kmax)
{
  if(fmx == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFBP7B(), fmx is NULL.\n");
  if(bmx == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFBP7B(), bmx is NULL.\n");
  if(dsq == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFBP7B(), dsq is NULL.");

  int k, i;
  float max_diff;  /* maximum allowed difference between sc and
		    * sum_k f[i][k] * b[i][k] for any i */
  float diff;
  int fb_sum;
  float fb_sc;
  int   L;		/* subsequence length */
  int   kp;             /* k', relative k within band; k-kmin[i] */
  int to_add;

  L  = j0-i0+1;		/* the length of the subsequence */
  max_diff = 0.1;       /* tolerance, must be within .1 bits of original score */

  /* In all possible paths through the model, each residue of the sequence must have
   * been emitted by exactly 1 insert, match or EL state. */
  for (i = 1; i <= L; i++) {
	fb_sum = -INFTY;
	kp = 0;
	for (k = kmin[i]; k <= kmax[i]; k++, kp++) {
	  if     (fmx->mmx[i][kp] == -INFTY) to_add = -INFTY;
	  else if(bmx->mmx[i][kp] == -INFTY) to_add = -INFTY;
	  else {
	to_add = fmx->mmx[i][kp] + bmx->mmx[i][kp];
	if(k > 0) to_add -= hmm->msc[dsq[i]][k];
	  }
	  /* hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx
	   * unless, we're talking about M_0, the B state, it doesn't emit */
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->mmx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kp, fmx->mmx[i][kp]);
	printf("bmx->mmx[i:%4d][k:%4d(%4d)]: %d sum: %d\n", i, k, kp, (bmx->mmx[i][kp]-hmm->msc[dsq[i]][k]), fb_sum);*/

	  if     (fmx->imx[i][kp] == -INFTY) to_add = -INFTY;
	  else if(bmx->imx[i][kp] == -INFTY) to_add = -INFTY;
	  else  {
	to_add  = fmx->imx[i][kp] + bmx->imx[i][kp];
	to_add -= hmm->isc[dsq[i]][k];
	  }
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->imx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kp, fmx->imx[i][kp]);
	printf("bmx->imx[i:%4d][k:%4d(%4d)]: %d sum: %d\n", i, k, kp, (bmx->imx[i][kp]-hmm->isc[dsq[i]][k]), fb_sum);*/

	  if     (fmx->elmx[i][kp] == -INFTY) to_add = -INFTY;
	  else if(bmx->elmx[i][kp] == -INFTY) to_add = -INFTY;
	  else  {
	to_add  = fmx->elmx[i][kp] + bmx->elmx[i][kp];
	/* EL emissions are by definition zero scoring */
	  }
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->elmx[i:%4d][k:%4d(%4d)]: %d\n", i, k, kp, fmx->elmx[i][kp]);
	printf("bmx->elmx[i:%4d][k:%4d(%4d)]: %d sum: %d\n", i, k, kp, bmx->elmx[i][kp], fb_sum);*/
	}
	fb_sc  = Scorify(fb_sum);
	diff = fabs(fb_sc - sc);
	/*printf("FB CHECK: i: %4d %10.4f %10.4f (%10.4f)\n", i, fb_sc, sc, diff);*/
	if((fabs(diff) > max_diff))
	  ESL_FAIL(eslFAIL, errbuf, "cp9_CheckFB(), residue at posn i:%d violates sum_k f[i][k]*b[i][k]=P(x|hmm), sum_k = %.4f bits (should be %.4f)\n", i, fb_sc, sc);
  }
  ESL_DPRINTF1(("cp9_CheckFB() passed, Forward/Backward matrices pass check.\n"));
  /*printf("cp9_CheckFB() passed, Forward/Backward matrices pass check.\n");*/
  return eslOK;
}

/* Function: cp9_Seq2BandsP7B
 * Date    : EPN, Fri Aug 15 13:43:21 2008
 *
 * Purpose:  Given a CM with precalc'ed CP9 HMM, CP9Map, and HMMER3 plan 7
 *           HMM bands for the CP9 HMM DP matrices, a sequence and
 *           a CP9Bands_t structure, calculate the CP9 HMM bands and store them
 *           in the CP9Bands_t structure.
 *
 *           Note: this function was never updated to handle truncated
 *           alignment.
 *
 * Args:     cm          - the covariance model
 *           errbuf      - char buffer for reporting errors
 *           fmx         - CP9 dp matrix for Forward()
 *           bmx         - CP9 dp matrix for Backward()
 *           pmx         - CP9 dp matrix to fill with posteriors, can == bmx
 *           dsq         - sequence in digitized form
 *           L           - length of sequence we're aligning (1..L)
 *           cp9b        - PRE-ALLOCATED, the HMM bands for this sequence, filled here.
 *           kmin        - P7 dervied band to enforce: [0.i..L] = k, min node k for residue i
 *           kmax        - P7 derived band to enforce: [0.i..L] = k, min node k for residue i
 *           debug_level - verbosity level for debugging printf()s
 * Return:  eslOK on success;
 *
 */
int
cp9_Seq2BandsP7B(CM_t *cm, char *errbuf, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, ESL_DSQ *dsq, int L, CP9Bands_t *cp9b, int *kmin, int *kmax, int debug_level)
{
  int   status;
  int   use_sums;     /* TRUE to fill and use posterior sums during HMM band calc, yields wider bands  */
  float sc;
  int do_old_hmm2ij;
  CP9_t *cp9 = NULL;  /* ptr to cp9 HMM (this could be Lcp9, Rcp9, Tcp9 if we update this function to possibly handle truncated alignment) */

  /* Contract checks */
  if(cm->cp9map == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2BandsP7B, but cm->cp9map is NULL.\n");
  if(dsq == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2BandsP7B, dsq is NULL.");
  if(!((cm->align_opts & CM_ALIGN_HBANDED) || (cm->search_opts & CM_SEARCH_HBANDED)))        ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2BandsP7B, CM_ALIGN_HBANDED and CM_SEARCH_HBANDED flags both down, exactly 1 must be up.\n");
  if((cm->search_opts & CM_SEARCH_HMMALNBANDS) && (!(cm->search_opts & CM_SEARCH_HBANDED))) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2BandsP7B, CM_SEARCH_HMMALNBANDS flag raised, but not CM_SEARCH_HBANDED flag, this doesn't make sense\n");
  if(cm->tau > 0.5)      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2BandsP7B, cm->tau (%f) > 0.5, we can't deal.", cm->tau);

  use_sums = ((cm->align_opts & CM_ALIGN_SUMS) || (cm->search_opts & CM_SEARCH_SUMS)) ? TRUE : FALSE;
  do_old_hmm2ij = ((cm->align_opts & CM_ALIGN_HMM2IJOLD) || (cm->search_opts & CM_SEARCH_HMM2IJOLD)) ? TRUE : FALSE;

  /* Determine which cp9 HMM to use: If the CM has local begins on, use cm->cp9loc, else use cm->cp9glb */
  cp9 = cm->cp9;
  if(cp9 == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Posteriors, relevant cp9 is NULL.\n");

  /* Step 1: Get HMM Forward/Backward DP matrices.
   * Step 2: F/B       -> HMM bands.
   * Step 3: HMM bands -> CM bands.
   */

  /* Step 1: Get HMM Forward/Backward DP matrices. */
  if((status = cp9_ForwardP7B (cp9, errbuf, fmx, dsq, L, kmin, kmax, &sc)) != eslOK) return status;
  if((status = cp9_BackwardP7B(cp9, errbuf, bmx, dsq, L, kmin, kmax, &sc)) != eslOK) return status;

  if(cm->align_opts & CM_ALIGN_CHECKFB) {
	if((status = cp9_CheckFBP7B(fmx, bmx, cp9, errbuf, sc, 1, L, dsq, kmin, kmax)) != eslOK) return status;
	printf("Forward/Backward matrices checked.\n");
  }

  /* Step 2: F/B -> HMM bands. */
  if(use_sums){
	printf("USE SUMS!\n");
	exit(1);
  }
  else {
	if((status = cp9_FB2HMMBandsP7B(cp9, errbuf, dsq, fmx, bmx, pmx, cp9b, L, cp9b->hmm_M,
				    (1.-cm->tau), do_old_hmm2ij, kmin, kmax, debug_level)) != eslOK) return status;
	cp9b->tau = cm->tau;
  }
  if(debug_level > 0) cp9_DebugPrintHMMBands(stdout, L, cp9b, cm->tau, 1);

  /* Step 3: HMM bands  ->  CM bands. */
  if(do_old_hmm2ij) {
	if((status = cp9_HMM2ijBands_OLD(cm, errbuf, cm->cp9b, cm->cp9map, 1, L, FALSE, debug_level)) != eslOK) return status;
  }
  else {
	if((status = cp9_HMM2ijBands(cm, errbuf, cp9, cm->cp9b, cm->cp9map, 1, L, FALSE, FALSE, debug_level)) != eslOK) return status;
	/* For debugging, uncomment this block:
	   if((status = cp9_HMM2ijBands(cm, errbuf, cm->cp9b, cm->cp9map, i0, j0, doing_search, FALSE, debug_level)) != eslOK) {
	   ESL_SQ *tmp;
	   tmp = esl_sq_CreateDigitalFrom(cm->abc, "irrelevant", dsq+i0-1, (j0-i0+1), NULL, NULL, NULL);
	   esl_sq_Textize(tmp);
	   printf("HEY! cm: %s\n", cm->name);
	   printf(">irrelevant\n%s\n", tmp->seq);
	   esl_sq_Destroy(tmp);
	   return status;
	}
	*/
  }

  /* Use the CM bands on i and j to get bands on d, specific to j. */
  /* cp9_GrowHDBands() must be called before ij2d_bands() so hdmin, hdmax are adjusted for new seq */
  if((status = cp9_GrowHDBands(cp9b, errbuf)) != eslOK) return status;
  ij2d_bands(cm, L, cp9b->imin, cp9b->imax, cp9b->jmin, cp9b->jmax, cp9b->hdmin, cp9b->hdmax, FALSE, debug_level);

#if eslDEBUGLEVEL >= 1
  if((status = cp9_ValidateBands(cm, errbuf, cp9b, 1, L, FALSE)) != eslOK) return status;
  ESL_DPRINTF1(("bands validated.\n"));
#endif
  if(debug_level > 0) debug_print_ij_bands(cm);

  if(debug_level > 0) PrintDPCellsSaved_jd(cm, cp9b->jmin, cp9b->jmax, cp9b->hdmin, cp9b->hdmax, L);

  return eslOK;
}

/* Function: cp9_Seq2PosteriorsP7B
 * Date    : EPN, Tue Aug 19 13:12:12 2008
 *
 * Purpose:  Given a CM with precalc'ed CP9 HMM and CP9Map, and HMMER3 plan 7
 *           HMM bands for the CP9 HMM DP matrices, and a sequence,
 *           run HMM Forward and Backward algorithms, and return a CP9 posterior
 *           matrix.
 *
 *           Note: this function was never updated to handle
 *           truncated alignment (b/c it's currently not hooked up
 *           to any of the Infernal applications).
 *
 * Args:     cm           - the covariance model
 *           errbuf       - char buffer for error messages
 *           fmx          - CP9 dp matrix for Forward()
 *           bmx          - CP9 dp matrix for Backward()
 *           pmx          - CP9 dp matrix to fill with posteriors, can == bmx
 *           dsq          - sequence in digitized form
 *           L            - length of the sequence we're aligning (1..L)
 *           kmin         - P7 dervied band to enforce: [0.i..L] = k, min node k for residue i
 *           kmax         - P7 derived band to enforce: [0.i..L] = k, min node k for residue i
 *           debug_level  - verbosity level for debugging printf()s
 *
 * Return:  eslOK on success
 */
int
cp9_Seq2PosteriorsP7B(CM_t *cm, char *errbuf, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, ESL_DSQ *dsq, int L, int *kmin, int *kmax, int debug_level)
{
  int status;
  float sc;
  CP9_t *cp9 = NULL;  /* ptr to cp9 HMM (this could be Lcp9, Rcp9, Tcp9 if we update this function to possibly handle truncated alignment) */

  /* Contract checks */
  if(dsq == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors(), dsq is NULL.");
  if(cm->cp9map == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, but cm->cp9map is NULL.\n");
  if((cm->align_opts & CM_ALIGN_HBANDED) && (cm->search_opts & CM_SEARCH_HBANDED))
	ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, CM_ALIGN_HBANDED and CM_SEARCH_HBANDED flags both up, exactly 1 must be up.\n");
  if((cm->search_opts & CM_SEARCH_HMMALNBANDS) && (! (cm->search_opts & CM_SEARCH_HBANDED)))
	ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, CM_SEARCH_HMMALNBANDS flag raised, but not CM_SEARCH_HBANDED flag, this doesn't make sense\n");

  /* determine which cp9 HMM to use, if CM is has local begins use cp9 (its local too) else use cp9glb (its global) */
  cp9 = cm->cp9;
  if(cp9 == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Posteriors, relevant cp9 is NULL.\n");

  /* Step 1: Get HMM posteriors.*/
  if((status = cp9_ForwardP7B (cp9, errbuf, fmx, dsq, L, kmin, kmax, &sc)) != eslOK) return status;
  if(debug_level > 0) printf("CP9P7B Forward  score : %.4f\n", sc);

  if((status = cp9_BackwardP7B(cp9, errbuf, bmx, dsq, L, kmin, kmax, &sc)) != eslOK) return status;
  if(debug_level > 0) printf("CP9 Backward  score : %.4f\n", sc);

  if(cm->align_opts & CM_ALIGN_CHECKFB) {
	if((status = cp9_CheckFBP7B(fmx, bmx, cp9, errbuf, sc, 1, L, dsq, kmin, kmax)) != eslOK) return status;
	printf("Forward/Backward matrices checked.\n");
  }

  /* Get posteriors */
  if((status = cp9_PosteriorP7B(dsq, errbuf, L, cp9, fmx, bmx, pmx, kmin, kmax)) != eslOK) return status;

  return eslOK;
}

/* Function: cp9_PosteriorP7B()
 * based on Ian Holmes' hmmer/src/postprob.c::P7EmitterPosterior()
 *
 * Purpose:  Combines HMMER3 p7 banded Forward and Backward matrices into a
 *           posterior probability matrix. For emitters (match and inserts) the
 *           entries in row i of this matrix are the logs of the posterior
 *           probabilities of each state emitting symbol i of the sequence.
 *           For non-emitters the entries in row i of this matrix are the
 *           logs of the posterior probabilities of each state being 'visited'
 *           when the last emitted residue in the parse was symbol i of the
 *           sequence.
 *
 * Args:     dsq      - sequence in digitized form
 *           errbuf   - for error messages
 *           L        - length of target subsequence 1..L
 *           hmm      - the model
 *           forward  - pre-calculated forward matrix
 *           backward - pre-calculated backward matrix
 *           pm       - pre-allocated dynamic programming matrix for posteriors
 *           kmin     - P7 derived band to enforce: [0.i..L] = k, min node k for residue i
 *           kmax     - P7 derived band to enforce: [0.i..L] = k, min node k for residue i
 *
 * Return:   eslOK on success;
 */
int
cp9_PosteriorP7B(ESL_DSQ *dsq, char *errbuf, int L, CP9_t *hmm, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, int *kmin, int *kmax)
{
  int i;
  int k;
  int sc;
  int M = hmm->M;
  int kp, kn, kx;
  /*float temp_sc;*/

  if(bmx != pmx) GrowCP9Matrix(pmx, errbuf, L, M, kmin, kmax, NULL, NULL, NULL, NULL, NULL);

  /* parses must start/stop at (i = 1)/(j = L) */
  sc = bmx->mmx[0][0];

  /* note boundary conditions, i = 1 */
  assert(kmin[0] == 0);
  pmx->mmx[0][0] = fmx->mmx[0][0] + bmx->mmx[0][0] - sc; /* fmx->mmx[0][0] is 0, bmx->mmx[1][0] is overall score */
  pmx->imx[0][0] = -INFTY; /*need seq to get here*/
  pmx->dmx[0][0] = -INFTY; /*D_0 does not exist*/
  i  = 0;
  kn = ESL_MAX(kmin[i], 1);
  kx = kmax[i];
  kp = kn - kmin[i];
  for (k = kn; k <= kx; k++, kp++) {
	pmx->mmx[0][kp] = -INFTY; /*need seq to get here*/
	pmx->imx[0][kp] = -INFTY; /*need seq to get here*/
	pmx->dmx[0][kp] = fmx->dmx[0][kp] + bmx->dmx[0][kp] - sc;
  }

  for (i = 1; i <= L; i++) {
	  k = 0;
	  if(INBAND(i,0)) {
	kp = k - kmin[i];
	assert(kp == 0);
	pmx->mmx[i][kp] = ESL_MAX(fmx->mmx[i][kp] + bmx->mmx[i][kp] - sc, -INFTY); /* M_0 doesn't emit */
	pmx->imx[i][kp] = ESL_MAX(fmx->imx[i][kp] + bmx->imx[i][kp] - hmm->isc[dsq[i]][0] - sc, -INFTY);
	/*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	pmx->dmx[i][kp] = -INFTY; /* D_0 doesn't exist */
	  }

	  kn = ESL_MAX(kmin[i], 1);
	  kx = kmax[i];
	  kp = kn - kmin[i];
	  for(k = kn; k <= kx; k++, kp++)
	{
	  pmx->mmx[i][kp] = ESL_MAX(fmx->mmx[i][kp] + bmx->mmx[i][kp] - hmm->msc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->imx[i][kp] = ESL_MAX(fmx->imx[i][kp] + bmx->imx[i][kp] - hmm->isc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->dmx[i][kp] = ESL_MAX(fmx->dmx[i][kp] + bmx->dmx[i][kp] - sc, -INFTY);
	}
	}

  /*
	float temp_sc;
	for(i = 0; i <= L; i++)
	{
	kp = 0;
	for(k = kmin[i]; k <= kmax[i]; k++, kp++)
	{
	temp_sc = Score2Prob(mx->mmx[i][kp], 1.);
	if(temp_sc > .0001)
	printf("mx->mmx[%3d][%3d]: %9d | %8f\n", i, k, mx->mmx[i][kp], temp_sc);
	temp_sc = Score2Prob(mx->imx[i][kp], 1.);
	if(temp_sc > .0001)
	printf("mx->imx[%3d][%3d]: %9d | %8f\n", i, k, mx->imx[i][kp], temp_sc);
	temp_sc = Score2Prob(mx->dmx[i][kp], 1.);
	if(temp_sc > .0001)
	printf("mx->dmx[%3d][%3d]: %9d | %8f\n", i, k, mx->dmx[i][kp], temp_sc);
	}
	}*/
  return eslOK;
}

/* Function: cp9_FB2HMMBandsP7B()
 * Date:     EPN, Fri Aug 15 14:00:59 2008
 *
 * Purpose: Determine the band on all HMM states given HMMER3 Plan 7 Banded
 *          Forward and Backward matrices. Do this by calculating and summing
 *          log posterior probabilities that each state emitted/was visited at each posn,
 *          starting at the band ends, and creeping in, until the half the
 *          maximum allowable probability excluded is reached on each side.
 *
 * Args:
 *
 * CP9_t hmm        the HMM
 * errbuf           char buffer for error messages
 * CP9_MX fmx:      forward DP matrix, already calc'ed
 * CP9_MX bmx:      backward DP matrix, already calc'ed
 * CP9_MX pmx:      DP matrix for posteriors, filled here, can == bmx
 * dsq              the digitized sequence
 * CP9Bands_t cp9b  CP9 bands data structure
 * int   L          length of target subsequence (1..L)
 * int   M          number of nodes in HMM (num columns of pmx matrix)
 * double p_thresh  the probability mass we're requiring is within each band
 * int do_old_hmm2ij TRUE if we'll use old cp9_HMM2ijBands_OLD() function downstream
 * int kmin         P7 dervied band to enforce: [0.i..L] = k, min node k for residue i
 * int kmax         P7 derived band to enforce: [0.i..L] = k, min node k for residue i
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 *
 * Returns: eslOK on success;
 */
int
cp9_FB2HMMBandsP7B(CP9_t *hmm, char *errbuf, ESL_DSQ *dsq, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, CP9Bands_t *cp9b,
		   int L, int M, double p_thresh, int do_old_hmm2ij, int *kmin, int *kmax, int debug_level)
{
  int status;
  int k;                                  /* counter over nodes of the model */
  int thresh = Prob2Score(((1. - p_thresh)/2.), 1.); /* allowable prob mass excluded on each side */

  /* *_m = match, *_i = insert, *_d = delete */
  int *kthresh_m, *kthresh_i, *kthresh_d; /* [0..k..hmm->M], individual thresholds for each state */
  int *nset_m, *nset_i, *nset_d;          /* [0..k..hmm->M], has minimum been set for this state? */
  int *xset_m, *xset_i, *xset_d;          /* [0..k..hmm->M], has maximum been set for this state? */
  int *mass_m, *mass_i, *mass_d;          /* [0..k..hmm->M], summed log prob of pmx->mx[i][k] from 0..k or k..L */
  int i;                                  /* actual position */
  int sc;                                 /* summed score of all parses (derived from backward matrix)
					   * if(cm->search_opts & CM_SEARCH_HMMALNBANDS) Forward and Backward
					   * were run in 'scan mode' where each residue can be begin/end of a parse,
					   * so we have to sum up parses that end at each posn,
					   * if ! (cm->search_opts & CM_SEARCH_HMMALNBANDS) we know we have
					   * to start at residue 1 and end at residue L, so sc is simply bmx->mmx[0][0]
					   */
  int hmm_is_localized;                   /* TRUE if HMM has local begins, ends or ELs on */
  int kp, kn, kx;

  hmm_is_localized = ((hmm->flags & CPLAN9_LOCAL_BEGIN) || (hmm->flags & CPLAN9_LOCAL_END) || (hmm->flags & CPLAN9_EL)) ? TRUE : FALSE;

  if(bmx != pmx) GrowCP9Matrix(pmx, errbuf, L, M, kmin, kmax, NULL, NULL, NULL, NULL, NULL);

  /* allocations and initializations */
  ESL_ALLOC(nset_m, sizeof(int) * (M+1));
  ESL_ALLOC(nset_i, sizeof(int) * (M+1));
  ESL_ALLOC(nset_d, sizeof(int) * (M+1));
  ESL_ALLOC(xset_m, sizeof(int) * (M+1));
  ESL_ALLOC(xset_i, sizeof(int) * (M+1));
  ESL_ALLOC(xset_d, sizeof(int) * (M+1));
  ESL_ALLOC(mass_m, sizeof(int) * (M+1));
  ESL_ALLOC(mass_i, sizeof(int) * (M+1));
  ESL_ALLOC(mass_d, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_m, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_i, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_d, sizeof(int) * (M+1));

  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  esl_vec_ISet(nset_m, M+1, FALSE);
  esl_vec_ISet(nset_i, M+1, FALSE);
  esl_vec_ISet(nset_d, M+1, FALSE);
  esl_vec_ISet(xset_m, M+1, FALSE);
  esl_vec_ISet(xset_i, M+1, FALSE);
  esl_vec_ISet(xset_d, M+1, FALSE);

  sc = bmx->mmx[0][0]; /* Forward/Backward run in 'align mode' parses must start at 1, end at L */
  /* sc is summed log prob of all possible parses of seq 1..L */

  /* note boundary conditions, i = 1 */
  assert(kmin[0] == 0);
  pmx->mmx[0][0] = fmx->mmx[0][0] + bmx->mmx[0][0] - sc; /* fmx->mmx[0][0] is 0, bmx->mmx[1][0] is overall score */
  pmx->imx[0][0] = -INFTY; /*need seq to get here*/
  pmx->dmx[0][0] = -INFTY; /*D_0 does not exist*/
  if((mass_m[0] = pmx->mmx[0][0]) > thresh) {
	cp9b->pn_min_m[0] = 0;
	nset_m[0] = TRUE;
  }
  mass_i[0] = -INFTY; /* b/c pmx->imx[0][0] is -INFTY, set above */
  mass_d[0] = -INFTY; /* b/c pmx->dmx[0][0] is -INFTY, set above */

  i  = 0;
  kn = ESL_MAX(kmin[i], 1);
  kx = kmax[i];
  kp = kn - kmin[i];
  for (k = kn; k <= kx; k++, kp++) {
	pmx->mmx[0][kp] = -INFTY; /*need seq to get here*/
	pmx->imx[0][kp] = -INFTY; /*need seq to get here*/
	pmx->dmx[0][kp] = fmx->dmx[0][kp] + bmx->dmx[0][kp] - sc;
	/* mass_m[k] doesn't change b/c pmx->mmx[0][kp] is -INFTY */
	/* mass_i[k] doesn't change b/c pmx->imx[0][kp] is -INFTY */
	if((mass_d[k] = pmx->dmx[0][kp]) > thresh) {
	  cp9b->pn_min_d[k] = 0;
	  nset_d[k] = TRUE;
	}
  }

  /* Find minimum position in band for each state (M,I,D) of each node (0..M) */
  for (i = 1; i <= L; i++) {
	  k = 0;
	  if(INBAND(i,0)) {
	kp = k - kmin[i];
	assert(kp == 0);
	pmx->mmx[i][kp] = ESL_MAX(fmx->mmx[i][kp] + bmx->mmx[i][kp] - sc, -INFTY); /* M_0 doesn't emit */
	if(! nset_m[0]) {
	  if((mass_m[0] = ILogsum(mass_m[0], pmx->mmx[i][kp])) > thresh) {
	    cp9b->pn_min_m[0] = i;
	    nset_m[0] = TRUE;
	  }
	}

	pmx->imx[i][kp] = ESL_MAX(fmx->imx[i][kp] + bmx->imx[i][kp] - hmm->isc[dsq[i]][0] - sc, -INFTY);
	/*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	if(! nset_i[0]) {
	  if((mass_i[0] = ILogsum(mass_i[0], pmx->imx[i][kp])) > thresh) {
	    cp9b->pn_min_i[0] = i;
	    nset_i[0] = TRUE;
	  }
	}
	pmx->dmx[i][kp] = -INFTY; /* D_0 doesn't exist */
	  }

	  kn = ESL_MAX(kmin[i], 1);
	  kx = kmax[i];
	  kp = kn - kmin[i];
	  for(k = kn; k <= kx; k++, kp++)
	{
	  pmx->mmx[i][kp] = ESL_MAX(fmx->mmx[i][kp] + bmx->mmx[i][kp] - hmm->msc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->imx[i][kp] = ESL_MAX(fmx->imx[i][kp] + bmx->imx[i][kp] - hmm->isc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->dmx[i][kp] = ESL_MAX(fmx->dmx[i][kp] + bmx->dmx[i][kp] - sc, -INFTY);

	  if(! nset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[i][kp])) > thresh) {
	      cp9b->pn_min_m[k] = i;
	      nset_m[k] = TRUE;
	    }
	  }
	  if(! nset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[i][kp])) > thresh) {
	      cp9b->pn_min_i[k] = i;
	      nset_i[k] = TRUE;
	    }
	  }
	  if(! nset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[i][kp])) > thresh) {
	      cp9b->pn_min_d[k] = i;
	      nset_d[k] = TRUE;
	    }
	  }
	}
	}

  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  /* Find maximum position in band for each state (M,I,D) of each node (0..M)
   * by moving from L down to 1 */
  for (i = L; i >= 1; i--) /* i is the relative position in the seq */
	{
	  kp = 0;
	  for(k = kmin[i]; k <= kmax[i]; k++, kp++)
	{
	  if(! xset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[i][kp])) > thresh) {
	      cp9b->pn_max_m[k] = i;
	      xset_m[k] = TRUE;
	    }
	  }
	  if(! xset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[i][kp])) > thresh) {
	      cp9b->pn_max_i[k] = i;
	      xset_i[k] = TRUE;
	    }
	  }
	  if(! xset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[i][kp])) > thresh) {
	      cp9b->pn_max_d[k] = i;
	      xset_d[k] = TRUE;
	    }
	  }
	}
	}
  /* note boundary conditions, i = 0 */
  if(INBAND(0,0)) {
	assert(kmin[0] == 0);
	if(! xset_m[0]) {
	  if((mass_m[0] = ILogsum(mass_m[0], pmx->mmx[0][0])) > thresh) {
	cp9b->pn_max_m[0] = 0;
	xset_m[0] = TRUE;
	  }
	}
  }
  /* mass_i[0] is unchaged because b/c pmx->imx[0][0] is -INFTY, set above */
  /* mass_d[0] is unchaged because b/c pmx->dmx[0][0] is -INFTY, set above */
  kn = ESL_MAX(kmin[i], 1);
  kx = kmax[i];
  kp = kn - kmin[i];
  for(k = kn; k <= kx; k++, kp++) {
	/* mass_m[k] doesn't change b/c pmx->mmx[0][k] is -INFTY */
	/* mass_i[k] doesn't change b/c pmx->mmx[0][k] is -INFTY */
	if(!xset_d[k]) {
	  if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[0][kp])) > thresh) {
	cp9b->pn_max_d[k] = 0;
	xset_d[k] = TRUE;
	  }
	}
  }

  /* new technique as of EPN, Sun Jan 27 08:48:34 2008 */
  /* Some states may not have had their min/max set. This occurs if the entire
   * state is outside the band (i.e. the summed probability the state is entered for ANY i
   * is less than our threshold. Current strategy in this situation is to set the
   * pn_min_* and pn_max_* values as special flags, (-2) so the function that
   * uses them to derive i and j bands knows this is the case and handles it
   * accordingly.
   */
  int mset;
  int dset;
  for(k = 0; k <= M; k++) {
	mset = dset = TRUE;
	/* theoretically either nset_*[k] and xset_*[k] should be either both TRUE or both
	 * FALSE, but I'm slightly worried about rare precision issues, so we check if one
	 * or the other is unset, and if so, we set both to argmax position */
	if(((! nset_m[k])) || (! xset_m[k]) || (cp9b->pn_max_m[k] < cp9b->pn_min_m[k])) {
	  cp9b->pn_min_m[k] = cp9b->pn_max_m[k] = -1;
	  mset = FALSE;
	}
	if(((! nset_i[k])) || (! xset_i[k]) || (cp9b->pn_max_i[k] < cp9b->pn_min_i[k])) {
	  cp9b->pn_min_i[k] = cp9b->pn_max_i[k] = -1;
	}
	if(((! nset_d[k])) || (! xset_d[k]) || (cp9b->pn_max_d[k] < cp9b->pn_min_d[k])) {
	  cp9b->pn_min_d[k] = cp9b->pn_max_d[k] = -1;
	  dset = FALSE;
	}
	if((!hmm_is_localized) && (mset == FALSE && dset == FALSE)) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "node: %d match nor delete HMM state bands were set in non-localized, non-scanning HMM, lower tau (should be << 0.5).\n", k);
  }

  cp9b->pn_min_d[0] = -1; /* D_0 doesn't exist */
  cp9b->pn_max_d[0] = -1; /* D_0 doesn't exist */

  if(debug_level > 0) cp9_DebugPrintHMMBands(stdout, L, cp9b, (1.-p_thresh), 1);

  free(mass_m);
  free(mass_i);
  free(mass_d);
  free(nset_m);
  free(nset_i);
  free(nset_d);
  free(xset_m);
  free(xset_i);
  free(xset_d);
  free(kthresh_m);
  free(kthresh_i);
  free(kthresh_d);

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: p7_Seq2Bands
 * Date    : EPN, Fri Aug 15 14:29:01 2008
 *
 * Purpose:  Given a CM with a valid Plan 7 HMM - run the MSV algorithm
 *           to determine bands to be used on the CP9 HMM parse.
 *
 * Args:     cm          - the covariance model
 *           errbuf      - char buffer for reporting errors
 *           P7_PROFILE  - generic profile
 *           P7_GMX      - generic P7 dp matrix
 *           P7_BG       - P7 null model
 *           P7_TR       - P7 trace
 *           dsq         - sequence in digitized form
 *           L           - length of sequence we're aligning (1..L)
 *           phi         - phi array, phi[k][v] is expected number of times (probability)
 *                         state v (0 = match, 1 insert, 2 = delete) in
 *                         node k is *entered*. Node 0 is special, state 0 = B state, state 1 = N_state, state 2 = NULL
 *                         Calculated *without* taking insert->insert transitions into account.
 *           sc7         - minimum score to allow as a pin, 0. to allow any score
 *           len7        - min n-mer size, 1 to allow any size
 *           end7        - min distance from end to allow, prune away any others, 0 to not prune based on end proximity
 *           mprob7      - min match phi probability to allow in a pin
 *           mcprob7     - min cumulative match phi probability to allow in a nmer pin
 *           iprob7      - max insert phi probability to allow in a pin
 *           ilprob7     - max insert phi probability to allow in a state to the left of a pin
 *           ret_i2k     - [0.i..L] = k, residue i emitted from node k's match state in MSV trace
 *           ret_kmin    - [0.i..L] = k, min node k for residue i
 *           ret_kmax    - [0.i..L] = k, max node k for residue i
 *           ret_ncells  - number of cells within bands, to return
 *
 * Return:  eslOK on success;
 *
 */
int
p7_Seq2Bands(CM_t *cm, char *errbuf, P7_PROFILE *gm, P7_GMX *gx, P7_BG *bg, P7_TRACE *p7_tr, ESL_DSQ *dsq, int L,
	     double **phi, float sc7, int len7, int end7, float mprob7, float mcprob7, float iprob7, float ilprob7, int pad7,
	     int **ret_i2k, int **ret_kmin, int **ret_kmax, int *ret_ncells)
{
  int   status;
  float usc, nullsc;
  int *k2i, *i2k;
  float *isc;
  int *iconflict;
  int *kmin, *kmax;
  int ncells;

  /* setup for all modes */
  p7_bg_SetLength(bg, L);
  p7_bg_NullOne(bg, dsq, L, &nullsc);

  /* generic mode setup */
  p7_gmx_GrowTo(gx, cm->mlp7->M, L);
  p7_ReconfigLength(gm, L);
  gx->M = cm->mlp7->M;
  gx->L = L;

  /* Step 1: MSV algorithm M->M transitions only
   * Step 2: traceback MSV to get pins
   * Step 3: prune pins
   * Step 4: pins -> bands
   */

  /* Step 1: MSV algorithm */

  /* optimized MSV */
  /*
	p7_oprofile_ReconfigLength(cm->mlp7_om, L);
	esl_stopwatch_Start(watch);
	my_p7_MSVFilter(dsq, L, cm->mlp7_om, ox, gx, &usc);
	got    esl_stopwatch_Stop(watch);
	FormatTimeString(time_buf, watch->user, TRUE);
	fprintf(stdout, "OMSV  %8.2f  %11s\n", ((usc -nullsc) / eslCONST_LOG2), time_buf);
  */

  p7_GMSV(dsq, L, gm, gx, 2.0, &usc);

  /* Step 2: traceback MSV */
  status = my_p7_GTraceMSV(dsq, L, gm, gx, p7_tr, &i2k, &k2i, &isc, &iconflict);

  /* Step 3: prune pins */
  if(status == eslOK) { /* trace is valid */
	prune_i2k(i2k, iconflict, isc, L, phi, sc7, len7, end7, mprob7, mcprob7, iprob7, ilprob7);
  }
  else if (status == eslEINCOMPAT) { /* trace was discontiguous, abort! remove all pins */
	esl_vec_ISet(k2i, (cm->mlp7->M+1), -1);
	esl_vec_ISet(i2k, (L+1), -1);
	return status;
  }

  /* Step 4: pins -> bands */
  if((status = p7_pins2bands(i2k, errbuf, L, cm->clen, pad7, &kmin, &kmax, &ncells)) != eslOK) return status;
  /*DumpP7Bands(stdout, i2k, kmin, kmax, L); */

  /* print gmx in heatmap format */
  /*
	ESL_DMATRIX *D;
	double min;
	double max;
	FILE *hfp;
	p7_gmx_Match2DMatrix(gx, TRUE, &D, &min, &max);
	hfp = fopen("cur.ps", "w");
	my_dmx_Visualize(hfp, D, 0.01, max, 0.01);
	fclose(hfp);
	esl_dmatrix_Destroy(D);
	*/

  *ret_i2k  = i2k;
  *ret_kmin = kmin;
  *ret_kmax = kmax;
  *ret_ncells = ncells;

  free(iconflict);
  free(isc);
  free(k2i);

  return eslOK;
}

/**************************************************************
 * Function: CP9NodeForPosnP7B()
 * Incept:   EPN, Tue Aug 19 14:30:51 2008
 *
 * Purpose:  Given a P7 banded CP9 posterior matrix,
 *           determine the node of the CP9 HMM that is most likely to
 *           have emitted (from either its Match or Insert state)
 *           a given posn in the target sequence.
 *
 * Args:     hmm       - the CM plan 9 HMM
 *           errbuf    - for error messages
 *           x         - posn of target subsequence we're interested in
 *           L         - last position of target sequence
 *           post      - the posterior matrix for the hmm
 *           kn        - min node k for residue x
 *           kx        - max node k for residue x
 *           ret_node  - RETURN: index of node with highest probability of emitting x
 *           ret_type  - RETURN: type of state in ret_node with highest probability
 *           print_flag- TRUE to print out info on most likely node
 *
 *
 * Returns:  eslOK on success;
 *           eslEINVAL on contract violation.
 *           eslEINCOMPAT if kmin[x] >=
 */
int
CP9NodeForPosnP7B(CP9_t *hmm, char *errbuf, int x, CP9_MX *post,
		  int kn, int kx, int *ret_node, int *ret_type, int print_flag)
{
  /* post->mmx[i][kp]: posterior probability that posn i was emitted from node k's
	 match state, k = kp + kmin[i] */
  int  max_k;    /* node index with highest posterior probability of emitting posn x */
  int  max_type; /* type of state in max_k node with max probability '0' for match,
		    '1' for insert */
  int  max_sc;   /* score (log probability) from post matrix for max_k node max_type state type */
  int  k;        /* counter over nodes */
  int  kp;       /* k': k offset in position x's band */

  if(kn > kx) ESL_FAIL(eslEINVAL, errbuf, "ERROR in CP9NodeForPosn(), kn (%d) > kx (%d)\n", kn, kx);

  kp = 0;
  k  = kn;
  if(post->mmx[x][0] > post->imx[x][0]) {
	max_sc     = post->mmx[x][0];
	max_type   = 0; /* match */
  }
  else {
	max_sc     = post->imx[x][0];
	max_type   = 1; /* insert */
  }
  max_k = k;

  /* move left to right through HMM nodes */
  for(k = kn+1, kp = 1; k <= kx; k++, kp++) {
	if(post->mmx[x][kp] > max_sc) {
	  max_k  = k;
	  max_sc = post->mmx[x][kp];
	  max_type = 0; /* match */
	}
	if(post->imx[x][kp] > max_sc) {
	  max_k  = k;
	  max_sc = post->imx[x][kp];
	  max_type = 1; /* insert */
	}
  }

  if(print_flag) {
	if(max_type == 0) printf("MATCH  | mx->mmx[%3d][%3d]: %9d | %8f\n", x, max_k, post->mmx[x][max_k-kn],  Score2Prob(post->mmx[x][max_k-kn], 1.));
	else      	      printf("INSERT | mx->imx[%3d][%3d]: %9d | %8f\n", x, max_k, post->imx[x][max_k-kn], Score2Prob(post->imx[x][max_k-kn], 1.));
  }
  *ret_node = max_k;
  *ret_type = max_type;
  return eslOK;
}

/* Function: P7BandsAdjustForSubCM()
 * Incept:   EPN, Tue Aug 19 14:47:55 2008
 *
 * Purpose:  Correct k bands kmin, kmax built from an original CM for it's sub CM model
 *           that models spos..epos.
 *
 * Args:     kmin     - [0.i..L] = k, min node k for residue i
 *           kmax     - [0.i..L] = k, max node k for residue i
 *           L        - length of current sequence
 *           spos     - min k valid in sub CM
 *           epos     - max k valid in sub CM
 *
 * Return:   <eslOK> on success.
 *
 */
int
P7BandsAdjustForSubCM(int *kmin, int *kmax, int L, int spos, int epos)
{
  int i;
  int M = epos - spos + 1;
  for(i = 0; i <= L; i++) {
	kmin[i] = ESL_MAX(kmin[i] - (spos-1), 0);
	kmin[i] = ESL_MIN(kmin[i], M);

	kmax[i] = ESL_MAX(kmax[i] - (spos-1), 0);
	kmax[i] = ESL_MIN(kmax[i], M);
  }
  kmin[0] = 0; /* hard-coded, M_0 is begin state, it must emit full sequence */

  return eslOK;
}

/*** End of inlined file: cm_p7_band.c ***/


/*** Start of inlined file: cm_p7_domaindef.c ***/

#include <math.h>
#include <string.h>


static int is_multidomain_region         (P7_DOMAINDEF *ddef, int i, int j);
/* Note: is_multidomain_region is *identical* to the function of the same name in p7_domaindef.c*/
static int glocal_region_trace_ensemble  (P7_DOMAINDEF *ddef, const P7_PROFILE *gm, const ESL_DSQ *dsq, int ireg, int jreg, const P7_GMX *fwd, P7_GMX *wrk, int do_null2, int *ret_nc);
static int glocal_rescore_isolated_domain(P7_DOMAINDEF *ddef, const P7_PROFILE *gm, const ESL_SQ *sq, P7_GMX *gx1, P7_GMX *gx2,
					  int i, int j, int null2_is_done, int do_null2, int do_aln);

/* Function:  p7_domaindef_GlocalByPosteriorHeuristics()
 * Synopsis:  Define glocal domains in a sequence using posterior probs.
 * Incept:    EPN, Tue Oct  5 10:02:34 2010
 *            SRE, Sat Feb 23 08:17:44 2008 [Janelia] (p7_domaindef_ByPosteriorHeuristics())
 *
 * Purpose:   Given a sequence <sq> and model <gm> for which we have
 *            already calculated a Forward and Backward parsing
 *            matrices <gxf> and <gxb>; use posterior probability
 *            heuristics to determine an annotated domain structure;
 *            and for each domain found, score it (with null2
 *            calculations) and obtain an optimal accuracy alignment,
 *            using <fwd> and <bck> matrices as workspace for the
 *            necessary full-matrix DP calculations. Caller provides a
 *            new or reused <ddef> object to hold these results.
 *
 *            As a special case, if the profile is in unihit mode
 *            upon entering, we don't ever modify its configuration.
 *            This is especially important if this function is
 *            being used within a search/scan pipeline with a
 *            specially configured p7 profile in which N->N and/or
 *            C->C transitions have been set to IMPOSSIBLE. (If
 *            we were to call ReconfigLength() on such a profile
 *            we would make those transitions possible.)
 *
 *            One case in which profile reconfiguration is necessary
 *            is when multiple domains are suspected. However, we
 *            guard against this if the profile enters in unihit mode
 *            by no allowing multiple domains (in fact, it should
 *            never happen because J states are unreachable in unihit
 *            profiles). If multiple domains are suspected in this case,
 *             we return eslEINCONCEIVABLE.
 *
 *            Upon return, <ddef> contains the definitions of all the
 *            domains: their bounds, their null-corrected Forward
 *            scores, and their optimal posterior accuracy alignments.
 *
 *            <do_null2> is TRUE if we'll eventually apply a null2
 *            penalty FALSE if not. If FALSE, we can save time by
 *            skipping Backward calls at some stages.
 *
 * Returns:   <eslOK> on success.
 *
 *            <eslERANGE> on numeric overflow in posterior
 *            decoding. This should not be possible for multihit
 *            models.
 *
 *            <eslEINCONCEIVABLE> if profile enters as unihit but
 *            multiple domains are suspected.
 */
int
p7_domaindef_GlocalByPosteriorHeuristics(const ESL_SQ *sq, P7_PROFILE *gm,
					 P7_GMX *gxf, P7_GMX *gxb, P7_GMX *fwd, P7_GMX *bck,
					 P7_DOMAINDEF *ddef, int do_null2)
{
  int i, j;
  int triggered;
  int d;
  int i2,j2;
  int last_j2;
  int nc;
  int saveL     = gm->L;	/* Save the length config of <om>; will restore upon return */
  int save_mode = gm->mode;	/* Likewise for the mode. */
  int status;
  int save_mode_is_unihit;

  save_mode_is_unihit = (p7_IsMulti(save_mode)) ? FALSE : TRUE; /* if save_mode_is_unihit is TRUE, we never modify profile's configuration (length nor mode) */

  if ((status = p7_domaindef_GrowTo(ddef, sq->n))       != eslOK) return status;  /* ddef's btot,etot,mocc now ready for seq of length n */
  /*printf("GDD P7 mode: %d\n", gm->mode);*/
  if ((status = p7_GDomainDecoding(gm, gxf, gxb, ddef)) != eslOK) return status;  /* ddef->{btot,etot,mocc} now made.                    */

  /*printf("In p7_domaindef_GlocalByPosteriorHeuristics(): mode: %d rt1: %g rt2: %g rt3: %g nsamples: %d reseed: %d\n", save_mode, ddef->rt1, ddef->rt2, ddef->rt3, ddef->nsamples, ddef->do_reseeding);*/

  esl_vec_FSet(ddef->n2sc, sq->n+1, 0.0);          /* ddef->n2sc null2 scores are initialized                        */
  ddef->nexpected = ddef->btot[sq->n];             /* posterior expectation for # of domains (same as etot[sq->n])   */

  if(! save_mode_is_unihit) p7_ReconfigUnihit(gm, saveL); /* process each domain in unihit mode, regardless of gm->mode     */
  i     = -1;
  triggered = FALSE;
  for (j = 1; j <= sq->n; j++)
	{
	  /*printf("GDD j: %5d  m: %.5f  b: %8.3f  e: %8.3f    bhere: %8.3f  ehere: %8.3f\n",
	j,
	ddef->mocc[j],
	ddef->btot[j],
	ddef->etot[j],
	ddef->btot[j] - ddef->btot[j-1],
	ddef->etot[j] - ddef->etot[j-1]);
	  */
	  if (! triggered)
	{			/* xref J2/101 for what the logic below is: */
	  if       (ddef->mocc[j] - (ddef->btot[j] - ddef->btot[j-1]) <  ddef->rt2) i = j;
	  else if  (i == -1)                                                        i = j;
	  if       (ddef->mocc[j]                                     >= ddef->rt1) triggered = TRUE;
	}
	  else if (ddef->mocc[j] - (ddef->etot[j] - ddef->etot[j-1])  <  ddef->rt2)
	{
	  /* We have a region i..j to evaluate. */
	  p7_gmx_GrowTo(fwd, gm->M, j-i+1);
	  p7_gmx_GrowTo(bck, gm->M, j-i+1);
	  ddef->nregions++;
	  if (is_multidomain_region(ddef, i, j))
	    {
	      if(save_mode_is_unihit) return eslEINCONCEIVABLE;

	      /* This region appears to contain more than one domain, so we have to
			   * resolve it by cluster analysis of posterior trace samples, to define
			   * one or more domain envelopes.
	       */
	      ddef->nclustered++;

	      /* Resolve the region into domains by stochastic trace
	       * clustering; assign position-specific null2 model by
	       * stochastic trace clustering; there is redundancy
	       * here; we will consolidate later if null2 strategy
	       * works
	       */
	      p7_ReconfigMultihit(gm, saveL);
	      p7_GForward(sq->dsq+i-1, j-i+1, gm, fwd, NULL);
	      glocal_region_trace_ensemble(ddef, gm, sq->dsq, i, j, fwd, bck, do_null2, &nc);
	      p7_ReconfigUnihit(gm, saveL);
	      /* ddef->n2sc is now set on i..j by the traceback-dependent method */

	      last_j2 = 0;
	      for (d = 0; d < nc; d++) {
		p7_spensemble_GetClusterCoords(ddef->sp, d, &i2, &j2, NULL, NULL, NULL);
		if (i2 <= last_j2) ddef->noverlaps++;

		/* Note that k..m coords on model are available, but
				 * we're currently ignoring them.  This leads to a
				 * rare clustering bug that we eventually need to fix
				 * properly [xref J3/32]: two different regions in one
				 * profile HMM might have hit same seq domain, and
				 * when we now go to calculate an OA trace, nothing
				 * constrains us to find the two different alignments
				 * to the HMM; in fact, because OA is optimal, we'll
				 * find one and the *same* alignment, leading to an
				 * apparent duplicate alignment in the output.
				 *
				 * Registered as #h74, Dec 2009, after EBI finds and
				 * reports it.  #h74 is worked around in p7_tophits.c
				 * by hiding all but one envelope with an identical
				 * alignment, in the rare event that this
				 * happens. [xref J5/130].
		 */
		ddef->nenvelopes++;
		if (glocal_rescore_isolated_domain(ddef, gm, sq, fwd, bck, i2, j2, TRUE, do_null2, FALSE) == eslOK)
		  last_j2 = j2;
	      }
	      p7_spensemble_Reuse(ddef->sp);
	      p7_trace_Reuse(ddef->tr);
	    }
	  else
	    {
	      /* The region looks simple, single domain; convert the region to an envelope. */
	      ddef->nenvelopes++;
	      glocal_rescore_isolated_domain(ddef, gm, sq, fwd, bck, i, j, FALSE, do_null2, FALSE);
	    }
	  i     = -1;
	  triggered = FALSE;
	}
	}

  /* If profile was unihit upon entrance, we didn't modify its configuration (length nor mode),
   * else restore it to its original multihit mode, and to its original length model */
  if (! save_mode_is_unihit) {
	p7_ReconfigMultihit(gm, saveL);
  }

  return eslOK;
}

/*****************************************************************
 * 3. Internal routines
 *****************************************************************/

/* is_multidomain_region()
 * SRE, Fri Feb  8 11:35:04 2008 [Janelia]
 *
 * This defines the trigger for when we need to hand a "region" off to
 * a deeper analysis (using stochastic tracebacks and clustering)
 * because there's reason to suspect it may encompass two or more
 * domains.
 *
 * The criterion is to find the split point z at which the expected
 * number of E occurrences preceding B occurrences is maximized, and
 * if that number is greater than the heuristic threshold <ddef->rt3>,
 * then return TRUE. In other words, we're checking to see if there's
 * any point in the region at which it looks like an E was followed by
 * a B, as expected for a multidomain interpretation of the region.
 *
 * More precisely: return TRUE if  \max_z [ \min (B(z), E(z)) ]  >= rt3
 * where
 *   E(z) = expected number of E states occurring in region before z is emitted
 *        = \sum_{y=i}^{z} eocc[i]  =  etot[z] - etot[i-1]
 *   B(z) = expected number of B states occurring in region after z is emitted
 *        = \sum_{y=z}^{j} bocc[i]  =  btot[j] - btot[z-1]
 *
 *
 * Because this relies on the <ddef->etot> and <ddef->btot> arrays,
 * <calculate_domain_posteriors()> needs to have been called first.
 *
 * Xref:    J2/101.
 */
static int
is_multidomain_region(P7_DOMAINDEF *ddef, int i, int j)
{
  int   z;
  float max;
  float expected_n;

  max = -1.0;
  for (z = i; z <= j; z++)
	{
	  expected_n = ESL_MIN( (ddef->etot[z] - ddef->etot[i-1]), (ddef->btot[j] - ddef->btot[z-1]));
	  max        = ESL_MAX(max, expected_n);
	}
  return ( (max >= ddef->rt3) ? TRUE : FALSE);
}

/* glocal_region_trace_ensemble()
 * EPN, Tue Oct  5 10:13:25 2010
 *
 * Based on p7_domaindef.c's region_trace_ensemble(). Modified so that
 * generic matrices (which can be used for glocally configured models)
 * can be used. An additional parameter <do_null2> has been added,
 * so that null2-related calculations are only done if necessary.
 * That is, they're skipped if null2 has been turned off in the pipeline.
 *
 * Notes from p7_domaindef.c::region_trace_ensemble():
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * SRE, Fri Feb  8 11:49:44 2008 [Janelia]
 *
 * Here, we've decided that region <ireg>..<jreg> in sequence <dsq> might be
 * composed of more than one domain, and we're going to use clustering
 * of a posterior ensemble of stochastic tracebacks to sort it out.
 *
 * Caller provides a filled Forward matrix in <fwd> for the sequence
 * region <dsq+ireg-1>, length <jreg-ireg+1>, for the model <om>
 * configured in multihit mode with its target length distribution
 * set to the total length of <dsq>: i.e., the same model
 * configuration used to score the complete sequence (if it weren't
 * multihit, we wouldn't be worried about multiple domains).
 *
 * Caller also provides a DP matrix in <wrk> containing at least one
 * row, for use as temporary workspace. (This will typically be the
 * caller's Backwards matrix, which we haven't yet used at this point
 * in the processing pipeline.)
 *
 * Caller provides <ddef>, which defines heuristic parameters that
 * control the clustering, and provides working space for the
 * calculation and the answers. The <ddef->sp> object must have been
 * reused (i.e., it needs to be fresh; we're going to use it here);
 * the caller needs to Reuse() it specifically, because it can't just
 * Reuse() the whole <ddef>, when it's in the process of analyzing
 * regions.
 *
 * Upon return, <*ret_nc> contains the number of clusters that were
 * defined.
 *
 * The caller can retrieve info on each cluster by calling
 * <p7_spensemble_GetClusterCoords(ddef->sp...)> on the
 * <P7_SPENSEMBLE> object in <ddef>.
 *
 * Other information on what's happened in working memory:
 *
 * <ddef->n2sc[ireg..jreg]> now contains log f'(x_i) / f(x_i) null2 scores
 *    for each residue.
 *
 * <ddef->sp> gets filled in, and upon return, it's holding the answers
 *    (the cluster definitions). When the caller is done retrieving those
 *    answers, it needs to <esl_spensemble_Reuse()> it before calling
 *    <region_trace_ensemble()> again.
 *
 * <ddef->tr> is used as working memory for sampled traces.
 *
 * <wrk> has had its zero row clobbered as working space for a null2 calculation.
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
static int
glocal_region_trace_ensemble(P7_DOMAINDEF *ddef, const P7_PROFILE *gm, const ESL_DSQ *dsq, int ireg, int jreg,
			     const P7_GMX *fwd, P7_GMX *wrk, int do_null2, int *ret_nc)
{
  int    Lr  = jreg-ireg+1;
  int    t, d, d2;
  int    nov, n;
  int    nc;
  int    pos;
  float  null2[p7_MAXCODE];

  esl_vec_FSet(ddef->n2sc+ireg, Lr, 0.0); /* zero the null2 scores in region */

  /* By default, we make results reproducible by forcing a reset of
   * the RNG to its originally seeded state.
   */
  if (ddef->do_reseeding)
	esl_randomness_Init(ddef->r, esl_randomness_GetSeed(ddef->r));

  /* Collect an ensemble of sampled traces; calculate null2 odds ratios from these if nec */
  for (t = 0; t < ddef->nsamples; t++)
	{
	  p7_GStochasticTrace(ddef->r, dsq+ireg-1, Lr, gm, fwd, ddef->tr);
	  p7_trace_Index(ddef->tr);

	  pos = 1;
	  for (d = 0; d < ddef->tr->ndom; d++)
	{
	  p7_spensemble_Add(ddef->sp, t, ddef->tr->sqfrom[d]+ireg-1, ddef->tr->sqto[d]+ireg-1, ddef->tr->hmmfrom[d], ddef->tr->hmmto[d]);

	  if(do_null2) {
	    p7_GNull2_ByTrace(gm, ddef->tr, ddef->tr->tfrom[d], ddef->tr->tto[d], wrk, null2);

	    /* residues outside domains get bumped +1: because f'(x) = f(x), so f'(x)/f(x) = 1 in these segments */
	    for (; pos <= ddef->tr->sqfrom[d]; pos++) ddef->n2sc[ireg+pos-1] += 1.0;

	    /* Residues inside domains get bumped by their null2 ratio */
	    for (; pos <= ddef->tr->sqto[d];   pos++) ddef->n2sc[ireg+pos-1] += null2[dsq[ireg+pos-1]];
	  }
	}
	  if(do_null2) {
	/* the remaining residues in the region outside any domains get +1 */
	for (; pos <= Lr; pos++)  ddef->n2sc[ireg+pos-1] += 1.0;
	  }
	  p7_trace_Reuse(ddef->tr);
	}

  /* Convert the accumulated n2sc[] ratios in this region to log odds null2 scores on each residue. */
  if(do_null2) {
	for (pos = ireg; pos <= jreg; pos++)
	  ddef->n2sc[pos] = logf(ddef->n2sc[pos] / (float) ddef->nsamples);
  }

  /* Cluster the ensemble of traces to break region into envelopes. */
  p7_spensemble_Cluster(ddef->sp, ddef->min_overlap, ddef->of_smaller, ddef->max_diagdiff, ddef->min_posterior, ddef->min_endpointp, &nc);

  /* A little hacky now. Remove "dominated" domains relative to seq coords. */
  for (d = 0; d < nc; d++)
	ddef->sp->assignment[d] = 0; /* overload <assignment> to flag that a domain is dominated */

  /* who dominates who? (by post prob) */
  for (d = 0; d < nc; d++)
	{
	  for (d2 = d+1; d2 < nc; d2++)
	{
	  nov = ESL_MIN(ddef->sp->sigc[d].j, ddef->sp->sigc[d2].j) - ESL_MAX(ddef->sp->sigc[d].i, ddef->sp->sigc[d2].i) + 1;
	  if (nov == 0) break;
	  n   = ESL_MIN(ddef->sp->sigc[d].j - ddef->sp->sigc[d].i + 1,  ddef->sp->sigc[d2].j - ddef->sp->sigc[d2].i + 1);
	  if ((float) nov / (float) n >= 0.8) /* overlap */
	    {
	      if (ddef->sp->sigc[d].prob > ddef->sp->sigc[d2].prob) ddef->sp->assignment[d2] = 1;
	      else                                                  ddef->sp->assignment[d]  = 1;
	    }
	}
	}

  /* shrink the sigc list, removing dominated domains */
  d = 0;
  for (d2 = 0; d2 < nc; d2++)
	{
	  if (ddef->sp->assignment[d2]) continue; /* skip domain d2, it's dominated. */
	  if (d != d2) memcpy(ddef->sp->sigc + d, ddef->sp->sigc + d2, sizeof(struct p7_spcoord_s));
	  d++;
	}
  ddef->sp->nc = d;
  *ret_nc = d;
  return eslOK;
}

/* glocal_rescore_isolated_domain()
 * EPN, Tue Oct  5 10:16:12 2010
 *
 * Based on p7_domaindef.c's rescore_isolated_domain(). Modified
 * so that generic matrices (which can be used for glocally configured
 * models) can be used. This function finds a single glocal domain, not a
 * single local one.
 *
 * Also modified to optionally remove the Backward and OA alignment.
 * The decision to do these is determined by three input parameters:
 * <null2_is_done>: TRUE if we've already computed the null2 scores for
 *                  this region (see Sean's notes below).
 * <do_null2>:      TRUE if we will apply a null2 penalty eventually
 *                  to this domain
 * <do_aln>:        TRUE if we need the OA alignment
 *
 * Notes (verbatim) from p7_domaindef.c::rescore_isolated_domain():
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * SRE, Fri Feb  8 09:18:33 2008 [Janelia]
 *
 * We have isolated a single domain's envelope from <i>..<j> in
 * sequence <sq>, and now we want to score it in isolation and obtain
 * an alignment display for it.
 *
 * (Later, we can add up all the individual domain scores from this
 * seq into a new per-seq score, to compare to the original per-seq
 * score).
 *
 * The caller provides model <om> configured in unilocal mode; by
 * using unilocal (as opposed to multilocal), we're going to force the
 * identification of a single domain in this envelope now.
 *
 * The alignment is an optimal accuracy alignment (sensu IH Holmes),
 * also obtained in unilocal mode.
 *
 * The caller provides DP matrices <ox1> and <ox2> with sufficient
 * space to hold Forward and Backward calculations for this domain
 * against the model. (The caller will typically already have matrices
 * sufficient for the complete sequence lying around, and can just use
 * those.) The caller also provides a <P7_DOMAINDEF> object which is
 * (efficiently, we trust) managing any necessary temporary working
 * space and heuristic thresholds.
 *
 * Returns <eslOK> if a domain was successfully identified, scored,
 * and aligned in the envelope; if so, the per-domain information is
 * registered in <ddef>, in <ddef->dcl>.
 *
 * And here's what's happened to our working memory:
 *
 * <ddef>: <ddef->tr> has been used, and possibly reallocated, for
 *         the OA trace of the domain. Before exit, we called
 *         <Reuse()> on it.
 *
 * <ox1> : happens to be holding OA score matrix for the domain
 *         upon return, but that's not part of the spec; officially
 *         its contents are "undefined".
 *
 * <ox2> : happens to be holding a posterior probability matrix
 *         for the domain upon return, but we're not making that
 *         part of the spec, so caller shouldn't rely on this;
 *         spec just makes its contents "undefined".
 */
static int
glocal_rescore_isolated_domain(P7_DOMAINDEF *ddef, const P7_PROFILE *gm, const ESL_SQ *sq,
			       P7_GMX *gx1, P7_GMX *gx2, int i, int j, int null2_is_done,
			       int do_null2, int do_aln)
{
  P7_DOMAIN     *dom           = NULL;
  int            Ld            = j-i+1;
  float          domcorrection = 0.0;
  float          envsc, oasc;
  int            z;
  int            pos;
  float          null2[p7_MAXCODE];
  int            status;

  p7_GForward (sq->dsq + i-1, Ld, gm, gx1, &envsc);

  oasc = 0.;
  if(do_null2 || do_aln) {
	p7_GBackward(sq->dsq + i-1, Ld, gm, gx2, NULL);

	status = p7_GDecoding(gm, gx1, gx2, gx2);      /* <ox2> is now overwritten with post probabilities     */
	if (status == eslERANGE) return eslFAIL;      /* rare: numeric overflow; domain is assumed to be repetitive garbage [J3/119-212] */

	/* Is null2 set already for this i..j? (It is, if we're in a domain that
	 * was defined by stochastic traceback clustering in a multidomain region;
	 * it isn't yet, if we're in a simple one-domain region). If it isn't,
	 * do it now, by the expectation (posterior decoding) method.
	 */
	if ((! null2_is_done) && do_null2) {
	  p7_GNull2_ByExpectation(gm, gx2, null2);
	  for (pos = i; pos <= j; pos++)
	ddef->n2sc[pos]  = logf(null2[sq->dsq[pos]]);
	}
	if(do_null2) {
	  for (pos = i; pos <= j; pos++)
	domcorrection   += ddef->n2sc[pos];	        /* domcorrection is in units of NATS */
	}

	if(do_aln) {
	  /* Find an optimal accuracy alignment */
	  p7_GOptimalAccuracy(gm, gx2, gx1, &oasc);      /* <ox1> is now overwritten with OA scores              */
	  p7_GOATrace        (gm, gx2, gx1, ddef->tr);   /* <tr>'s seq coords are offset by i-1, rel to orig dsq */

	  /* hack the trace's sq coords to be correct w.r.t. original dsq */
	  for (z = 0; z < ddef->tr->N; z++)
	if (ddef->tr->i[z] > 0) ddef->tr->i[z] += i-1;
	}
	/* get ptr to next empty domain structure in domaindef's results */
  }
  if (ddef->ndom == ddef->nalloc) {
	void *p;
	ESL_RALLOC(ddef->dcl, p, sizeof(P7_DOMAIN) * (ddef->nalloc*2));
	ddef->nalloc *= 2;
  }
  dom = &(ddef->dcl[ddef->ndom]);

  /* store the results in it */
  dom->ienv          = i;
  dom->jenv          = j;
  dom->envsc         = envsc;         /* in units of NATS */
  dom->domcorrection = domcorrection; /* in units of NATS, will be 0. if do_null2 == FALSE */
  dom->oasc          = oasc;	      /* in units of expected # of correctly aligned residues, will be 0. if do_aln == FALSE */
  dom->dombias       = 0.0;	/* gets set later, using bg->omega and dombias */
  dom->bitscore      = 0.0;	/* gets set later by caller, using envsc, null score, and dombias */
  dom->lnP           = 1.0;	/* gets set later by caller, using bitscore */
  dom->is_reported   = FALSE;	/* gets set later by caller */
  dom->is_included   = FALSE;	/* gets set later by caller */
  dom->ad            = NULL;
  dom->iali          = i;
  dom->jali          = j;

  ddef->ndom++;

  if(do_aln) {
	p7_trace_Reuse(ddef->tr);
  }
  return eslOK;

 ERROR:
  if(do_aln) {
	p7_trace_Reuse(ddef->tr);
  }
  return status;
}

/*** End of inlined file: cm_p7_domaindef.c ***/


/*** Start of inlined file: cm_p7_modelconfig_trunc.c ***/


#include <math.h>
#include <float.h>
#include <string.h>
#include <ctype.h>


/*****************************************************************
 * 1. Routines in the exposed API.
 *****************************************************************/

/* Function:  p7_ProfileConfig5PrimeTrunc()
 */
int
p7_ProfileConfig5PrimeTrunc(P7_PROFILE *gm, int L)
{
  int status;
  int k;

  /* we should be in glocal mode */
  assert(! p7_IsLocal(gm->mode));

  /* Local mode entry, uniform:  1/M */
  for (k = 1; k <= gm->M; k++)
	p7P_TSC(gm, k-1, p7P_BM) = log(1. / gm->M); /* note off-by-one: entry at Mk stored as [k-1][BM] */

  /* set profile's mode to UNIGLOCAL, even though we're really a hybrid of local/glocal
   * We do this so p7_GForward, p7_GBackward set end scores to -eslINFINITY
   * forcing us to only exit from last node of the model
   */
  gm->mode = p7_UNIGLOCAL;

  /* borrowed and modified from p7_ReconfigUnihit(),
   * make J unreachable (unihit) and N->N transitions impossible (special to this func)
   */
  gm->xsc[p7P_N][p7P_MOVE] = gm->xsc[p7P_E][p7P_MOVE] = 0.0f;
  gm->xsc[p7P_N][p7P_LOOP] = gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;

  /* Remaining specials, [C][MOVE | LOOP] are set by ReconfigLength5PrimeTrunc()
   */
  gm->L = 0;			/* force ReconfigLength to reconfig */
  if ((status = p7_ReconfigLength5PrimeTrunc(gm, L)) != eslOK) return status;

  return eslOK;
}

/* Function:  p7_ProfileConfig3PrimeTrunc()
 */
int
p7_ProfileConfig3PrimeTrunc(const P7_HMM *hmm, P7_PROFILE *gm, int L)
{
  int status;
  int k;
  float  Z;

  /* we should be in glocal mode */
  assert(! p7_IsLocal(gm->mode));

  /* glocal mode entry: left wing retraction, must be in log space for precision
   * (copied from HMMER's modelconfig.c:p7_ProfileConfig()) */
  Z = log(hmm->t[0][p7H_MD]);
  p7P_TSC(gm, 0, p7P_BM) = log(1.0 - hmm->t[0][p7H_MD]);
  for (k = 1; k < hmm->M; k++)
	{
	  p7P_TSC(gm, k, p7P_BM) = Z + log(hmm->t[k][p7H_DM]);
	  Z += log(hmm->t[k][p7H_DD]);
	}
  /* set profile's mode to UNILOCAL, even though we're really a hybrid of local/glocal
   * We do this so p7_GForward, p7_GBackward do NOT set end scores to -eslINFINITY
   * this allows us to exit from any model node (like local ends in a CP9)
   */
  gm->mode = p7_UNILOCAL;

  /* borrowed and modified from p7_ReconfigUnihit(),
   * make J unreachable (unihit) and C->C transitions impossible (special to this func)
   */
  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_E][p7P_MOVE] = 0.0f;
  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;

  /* Remaining specials, [N][MOVE | LOOP] are set by ReconfigLength5PrimeTrunc()
   */
  gm->L = 0;			/* force ReconfigLength to reconfig */
  if ((status = p7_ReconfigLength3PrimeTrunc(gm, L)) != eslOK) return status;

  return eslOK;
}

/* Function:  p7_ProfileConfig5PrimeAnd3PrimeTrunc()
 */
int
p7_ProfileConfig5PrimeAnd3PrimeTrunc(P7_PROFILE *gm, int L)
{
  assert(gm->mode == p7_LOCAL);

  /* gm should already be set up as local with equiprobable begins and ends,
   * we just need to make it unihit, and make N->N and C->C transitions impossible
   */
  gm->xsc[p7P_N][p7P_MOVE] = gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_E][p7P_MOVE] = 0.0f;
  gm->xsc[p7P_N][p7P_LOOP] = gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;
  gm->nj = 0.0f;
  gm->L  = L;
  gm->mode = p7_UNILOCAL;
  /* don't call ReconfigLength() */

  return eslOK;
}

/* Function:  p7_ReconfigLength5PrimeTrunc()
 */
int
p7_ReconfigLength5PrimeTrunc(P7_PROFILE *gm, int L)
{
  float ploop, pmove;

  /* mode should be set as p7_UNIGLOCAL for 5' trunc case, even though its
   * actually in a hybrid local/glocal mode. It's impt it is p7_UNIGLOCAL
   * so it is behaves appropriately in other HMMER functions.
   */
  assert(gm->mode == p7_UNIGLOCAL);

  /* Configure C transitions so it bears the total
   * unannotated sequence length L.
   */
  pmove = (1.0f + gm->nj) / ((float) L + 1.0f + gm->nj); /* 1/(L+1) */
  ploop = 1.0f - pmove;
  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = log(ploop); /* J should be irrelevant, b/c we've set unihit */
  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = log(pmove);
  gm->L  = L;
  return eslOK;
}

/* Function:  p7_ReconfigLength3PrimeTrunc()
 */
int
p7_ReconfigLength3PrimeTrunc(P7_PROFILE *gm, int L)
{
  float ploop, pmove;

  /* mode should be set as p7_UNILOCAL for 5' trunc case, even though its
   * actually in a hybrid local/glocal mode. It's impt it is p7_UNILOCAL
   * so it is behaves appropriately in other HMMER functions.
   */
  assert(gm->mode == p7_UNILOCAL);

  /* Configure N transitions so it bears the total
   * unannotated sequence length L.
   */
  pmove = (1.0f + gm->nj) / ((float) L + 1.0f + gm->nj); /* 1/(L+1) */
  ploop = 1.0f - pmove;
  gm->xsc[p7P_N][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = log(ploop); /* J should be irrelevant, b/c we've set unihit */
  gm->xsc[p7P_N][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = log(pmove);
  gm->L  = L;
  return eslOK;
}

/*** End of inlined file: cm_p7_modelconfig_trunc.c ***/


/*** Start of inlined file: cm_p7_modelmaker.c ***/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>


/* Function: BuildP7HMM_MatchEmitsOnly()
 * Incept:   EPN, Tue Aug  5 15:33:00 2008
 *
 * Purpose:  Create and fill a P7_HMM object from a CM and it's CP9 HMM.
 *           Copy only the match emissions of the CP9 HMM, the rest of
 *           the p7 model parameters are irrelevant.
 *
 * Args:     cm        - the cm
 *           cp9       - the cp9 HMM to build the p7 HMM from (usually cm->cp9loc)
 *           ret_p7    - RETURN: new p7 model
 *
 * Return:   eslOK   on success
 *
 * Throws:   eslEINCOMPAT on contract violation
 *           eslEMEM on memory error
 */
int
BuildP7HMM_MatchEmitsOnly(CM_t *cm, CP9_t *cp9, P7_HMM **ret_p7)
{
  int        status;
  P7_HMM     *hmm = NULL;        /* RETURN: new hmm */
  int        k;

  if(cp9 == NULL)         return eslEINCOMPAT;
  if(cp9->M != cm->clen)  return eslEINCOMPAT;

  if ((hmm    = p7_hmm_Create(cm->clen, cm->abc)) == NULL)  return eslEMEM;
  if ((status = p7_hmm_Zero(hmm))                 != eslOK) return status;

  /* copy only match emissions */
  for (k = 1; k <= cm->clen; k++) esl_vec_FCopy(cp9->mat[k], cm->abc->K, hmm->mat[k]);

  /* parameterize, hacked from hmmer/p7_prior.c::p7_ParameterEstimation() */
  /* match transitions */
  for (k = 1; k <= hmm->M; k++) esl_vec_FNorm(hmm->t[k],   3);

  /* insert transitions */
  for (k = 1; k <= hmm->M; k++) esl_vec_FNorm(hmm->t[k]+3, 2);

  /* delete transitions */
  for (k = 1; k < hmm->M; k++) esl_vec_FNorm(hmm->t[k]+5, 2);
  /* For k=0, which is unused; convention sets TMM=1.0, TMD=0.0
   * For k=M, TMM = 1.0 (to the E state) and TMD=0.0 (no next D; must go to E).
   */
  hmm->t[0][p7H_DM] = hmm->t[hmm->M][p7H_DM] = 1.0;
  hmm->t[0][p7H_DD] = hmm->t[hmm->M][p7H_DD] = 0.0;

  /* insert emissions */
  for (k = 0; k <= hmm->M; k++) esl_vec_FNorm(hmm->ins[k], hmm->abc->K); /* normalize inserts (0.25 each) */

  p7_hmm_SetName(hmm, cm->name);
  p7_hmm_SetAccession(hmm, cm->acc);
  p7_hmm_SetDescription(hmm, cm->desc);
  p7_hmm_SetCtime(hmm);
  if((status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK) goto ERROR;
  if(cm->comlog != NULL) {
	if((status = esl_strdup(cm->comlog, -1, &(hmm->comlog))) != eslOK) goto ERROR;
  }
  else {
	hmm->comlog = NULL;
  }

  hmm->eff_nseq = cm->eff_nseq;
  hmm->nseq     = cm->nseq;
  hmm->checksum = 0;

  *ret_p7 = hmm;

  return eslOK;

 ERROR:
  if(hmm != NULL) p7_hmm_Destroy(hmm);
  return status;
}

/* Function: cm_cp9_to_p7()
 * Incept:   EPN, Fri Sep 24 13:46:37 2010
 *
 * Purpose:  Create and fill a P7_HMM object from a CM and a CP9 HMM.
 *
 * Args:     cm     - the cm, must have a cp9 model in it.
 *           cp9    - the CP9 HMM, usually cm->cp9loc
 *           errbuf - for error messages
 *
 * Return:   eslOK on success
 * Throws:   eslEINCOMPAT on contract violation, errbuf filled.
 *           eslEMEM on memory error, errbuf filled.
 */
int
cm_cp9_to_p7(CM_t *cm, CP9_t *cp9, char *errbuf)
{
  int        status;
  int        k;

  /* contract check */
  if(cp9 == NULL)            ESL_XFAIL(eslEINCOMPAT, errbuf, "trying to create a p7 from cp9 HMM, but cp9 is NULL");
  if(cm->mlp7 != NULL)       ESL_XFAIL(eslEINCOMPAT, errbuf, "trying to create ml p7, but it already exists");
  if(cm->W == 0)             ESL_XFAIL(eslEINCOMPAT, errbuf, "trying to create ml p7, cm->W is 0");
  if(cp9->M != cm->clen)     ESL_XFAIL(eslEINCOMPAT, errbuf, "trying to create ml p7, cm->clen != cp9->M");
  if(cm->cmcons == NULL)     ESL_XFAIL(eslEINCOMPAT, errbuf, "trying to create ml p7, cm->cmcons is NULL, we need it's structure string");

  if ((cm->mlp7 = p7_hmm_Create(cm->clen, cm->abc)) == NULL) ESL_XFAIL(eslEMEM, errbuf, "out of memory");
  p7_hmm_Zero(cm->mlp7);

  /* copy transitions */
  for (k = 0; k <= cm->mlp7->M; k++) {
	cm->mlp7->t[k][p7H_MM] = cp9->t[k][CTMM];
	cm->mlp7->t[k][p7H_MI] = cp9->t[k][CTMI];
	cm->mlp7->t[k][p7H_MD] = cp9->t[k][CTMD];
	cm->mlp7->t[k][p7H_IM] = cp9->t[k][CTIM];
	cm->mlp7->t[k][p7H_II] = cp9->t[k][CTII];
	cm->mlp7->t[k][p7H_DM] = cp9->t[k][CTDM];
	cm->mlp7->t[k][p7H_DD] = cp9->t[k][CTDD];
	/* note: the cp9 CTDI and CTID transitions do not exist the p7 model */
  }
  /* normalize match transitions */
  for (k = 1; k <= cm->mlp7->M; k++) esl_vec_FNorm(cm->mlp7->t[k],  3);
  /* normalize insert transitions */
  for (k = 0; k < cm->mlp7->M; k++) esl_vec_FNorm(cm->mlp7->t[k]+3, 2);
  /* normalize delete transitions */
  for (k = 1; k < cm->mlp7->M; k++) esl_vec_FNorm(cm->mlp7->t[k]+5, 2);

  /* enforce HMMER conventions */
  cm->mlp7->t[cm->mlp7->M][p7H_MD] = 0.0;
  esl_vec_FNorm(cm->mlp7->t[cm->mlp7->M], 3);
  cm->mlp7->t[0][p7H_DM] = cm->mlp7->t[cm->mlp7->M][p7H_DM] = 1.0;
  cm->mlp7->t[0][p7H_DD] = cm->mlp7->t[cm->mlp7->M][p7H_DD] = 0.0;

  /* enforce INFERNAL CP9 convention, the 0'th node's MM transition is really begin[0] */
  cm->mlp7->t[0][p7H_MM] = cp9->begin[1];
  esl_vec_FNorm(cm->mlp7->t[0], 3);

  /* match emissions: copy, then normalize (should be unnec actually) */
  for (k = 1; k <= cm->clen; k++) esl_vec_FCopy(cp9->mat[k], cm->abc->K, cm->mlp7->mat[k]);
  for (k = 1; k <= cm->clen; k++) esl_vec_FNorm(cm->mlp7->mat[k], cm->abc->K);
  /* special case */
  esl_vec_FSet(cm->mlp7->mat[0], cm->mlp7->abc->K, 0.);
  cm->mlp7->mat[0][0] = 1.0;

  /* insert emissions: copy, then normalize (should be unnec actually) */
  for (k = 0; k <= cm->clen; k++) esl_vec_FCopy(cp9->ins[k], cm->abc->K, cm->mlp7->ins[k]);
  for (k = 0; k <= cm->clen; k++) esl_vec_FNorm(cm->mlp7->ins[k], cm->abc->K);

  /* copy cm->W as max_length */
  cm->mlp7->max_length = cm->W;

  p7_hmm_SetName       (cm->mlp7, cm->name);
  p7_hmm_SetAccession  (cm->mlp7, cm->acc);
  p7_hmm_SetDescription(cm->mlp7, cm->desc);
  p7_hmm_SetCtime      (cm->mlp7);
  if((status = p7_hmm_SetConsensus(cm->mlp7, NULL)) != eslOK) ESL_XFAIL(status, errbuf, "out of memory");
  if(cm->comlog != NULL) {
	if((status = esl_strdup(cm->comlog, -1, &(cm->mlp7->comlog))) != eslOK) goto ERROR;
  }
  else {
	cm->mlp7->comlog = NULL;
  }

  /* copy CM's RF annotation to mlp7 */
  if(cm->flags & CMH_RF && cm->rf != NULL) {
	ESL_ALLOC(cm->mlp7->rf, sizeof(char) * (cm->clen+2));
	strcpy(cm->mlp7->rf, cm->rf);
	cm->mlp7->flags |= p7H_RF;
  }

  /* copy CM's consensus structure annotation to mlp7 */
  if(cm->cmcons != NULL) {
	ESL_ALLOC(cm->mlp7->cs, sizeof(char) * (cm->clen+2));
	cm->mlp7->cs[0] = ' ';
	for(k = 1; k <= cm->clen; k++) {
	  cm->mlp7->cs[k] = cm->cmcons->cstr[k-1]; /* cmcons->cstr is 0..cm->clen-1, mlp7->cs is 1..cm->clen */
	}
	cm->mlp7->cs[cm->clen+1] = '\0';
	cm->mlp7->flags |= p7H_CS;
  }

  cm->mlp7->eff_nseq = cm->eff_nseq;
  cm->mlp7->nseq     = cm->nseq;
  cm->mlp7->checksum = 0;

  /* set the model composition */
  if ((status = p7_hmm_SetComposition(cm->mlp7)) != eslOK) ESL_XFAIL(status, errbuf, "out of memory");

  cm->flags |= CMH_MLP7; /* raise the P7 flag */

  return eslOK;

 ERROR:
  if(cm->mlp7 != NULL) { p7_hmm_Destroy(cm->mlp7); cm->mlp7 = NULL; }
  return status;
}

/* Function: cm_p7_Calibrate()
 * Incept:   EPN, Tue Nov  9 06:16:57 2010
 *
 * Purpose:  Calibrate a p7 HMM for local MSV, Viterbi, Forward and
 *           also glocal Forward.
 *
 * Args:     hmm       - the hmm
 *           errbuf    - for error messages
 *           ElmL      - length of sequences to sample for local MSV
 *           ElvL      - length of sequences to sample for local Vit
 *           ElfL      - length of sequences to sample for local Fwd
 *           EgfL      - length of sequences to sample for glocal Fwd
 *           ElmN      - number of sequences to sample for local MSV
 *           ElvN      - number of sequences to sample for local Vit
 *           ElfN      - number of sequences to sample for local Fwd
 *           EgfN      - number of sequences to sample for glocal Fwd
 *           ElfT      - fraction of tail mass to fit for  local Fwd (usually (HMMER3 is) 0.04)
 *           EgfT      - fraction of tail mass to fit for glocal Fwd
 *           ret_gfmu  - RETURN: mu for glocal forward
 *           ret_gflambda - RETURN: lambda for glocal forward
 *
 * Return:   eslOK   on success
 *
 * Throws:   eslEINCOMPAT on contract violation
 *           eslEMEM on memory error
 */
int
cm_p7_Calibrate(P7_HMM *hmm, char *errbuf,
		int ElmL, int ElvL, int ElfL, int EgfL,
		int ElmN, int ElvN, int ElfN, int EgfN,
		double ElfT, double EgfT,
		double *ret_gfmu, double *ret_gflambda)
{
  int        status;
  P7_OPROFILE    *om = NULL;
  P7_BG          *bg = NULL;
  P7_PROFILE     *gm = NULL;
  ESL_RANDOMNESS *r  = NULL;
  double lmmu, lvmu, lftau, gfmu;
  double lmlam, lvlam, lflam, gflambda, lambda;

  /*printf("cm_p7_Calibrate:\n\tElmL: %d\n\tElvL: %d\n\tElfL: %d\n\tEgfL: %d\n\tElmN: %d\n\tElvN: %d\n\tElfN: %d\n\tEgfN: %d\n\tElfT: %f\n\tEgfT: %f\n\n", ElmL, ElvL, ElfL, EgfL, ElmN, ElvN, ElfN, EgfN, ElfT, EgfT, do_real, do_null3, do_fitlam, do_bias);*/

  /* most of this code stolen from hmmer's evalues.c::p7_Calibrate() */
  if ((r      = esl_randomness_CreateFast(42)) == NULL)                   ESL_XFAIL(eslEMEM, errbuf, "cm_p7_Calibrate(): failed to create RNG");
  if ((bg     = p7_bg_Create(hmm->abc)) == NULL)                          ESL_XFAIL(eslEMEM, errbuf, "cm_p7_Calibrate(): failed to allocate background");
  if ((gm     = p7_profile_Create(hmm->M, hmm->abc))  == NULL)            ESL_XFAIL(eslEMEM, errbuf, "cm_p7_Calibrate(): failed to allocate profile");
  if ((status = p7_ProfileConfig(hmm, bg, gm, ElmL, p7_LOCAL)) != eslOK)  ESL_XFAIL(status,  errbuf, "cm_p7_Calibrate(): failed to configure profile");
  if ((om     = p7_oprofile_Create(hmm->M, hmm->abc)) == NULL)            ESL_XFAIL(eslEMEM, errbuf, "cm_p7_Calibrate(): failed to create optimized profile");
  if ((status = p7_oprofile_Convert(gm, om)) != eslOK)                    ESL_XFAIL(status,  errbuf, "cm_p7_Calibrate(): failed to convert to optimized profile");

  /* The calibration steps themselves */
  lambda = lmlam = lvlam = lflam = 0.;
  if ((status = p7_Lambda      (hmm, bg, &lambda))                         != eslOK) ESL_XFAIL(status,  errbuf, "failed to determine lambda");
  if ((status = p7_MSVMu    (r, om, bg, ElmL, ElmN, lambda, &lmmu))        != eslOK) ESL_XFAIL(status,  errbuf, "failed to determine msv mu");
  if ((status = p7_ViterbiMu(r, om, bg, ElvL, ElvN, lambda, &lvmu))        != eslOK) ESL_XFAIL(status,  errbuf, "failed to determine vit mu");
  if ((status = p7_Tau      (r, om, bg, ElfL, ElfN, lambda, ElfT, &lftau)) != eslOK)   ESL_XFAIL(status,  errbuf, "failed to determine fwd tau");

  /* set the p7's evparam[] */
  hmm->evparam[p7_MMU]     = lmmu;
  hmm->evparam[p7_MLAMBDA] = lambda;
  hmm->evparam[p7_VMU]     = lvmu;
  hmm->evparam[p7_VLAMBDA] = lambda;
  hmm->evparam[p7_FTAU]    = lftau;
  hmm->evparam[p7_FLAMBDA] = lambda;
  hmm->flags              |= p7H_STATS;

  /* finally, determine Glocal Forward stats */
  if ((status = p7_ProfileConfig(hmm, bg, gm, EgfL, p7_GLOCAL)) != eslOK) goto ERROR;
  if ((status = cm_p7_Tau(r, errbuf, NULL, gm, bg, EgfL, EgfN, lambda, EgfT, &gfmu)) != eslOK) ESL_XFAIL(status,  errbuf, "failed to determine fwd tau");
  gflambda = lambda;

  esl_randomness_Destroy(r);
  p7_bg_Destroy(bg);
  p7_oprofile_Destroy(om);
  p7_profile_Destroy(gm);

  if(ret_gfmu != NULL)     *ret_gfmu = gfmu;
  if(ret_gflambda != NULL) *ret_gflambda = gflambda;

  return eslOK;

 ERROR:
  if(r != NULL)  esl_randomness_Destroy(r);
  if(bg != NULL) p7_bg_Destroy(bg);
  if(om != NULL) p7_oprofile_Destroy(om);
  if(gm != NULL) p7_profile_Destroy(gm);
  if(ret_gfmu != NULL) *ret_gfmu = 0.;
  if(ret_gflambda != NULL) *ret_gflambda = 0.;
  return status;
}

/* Function:  cm_p7_Tau()
 * Synopsis:  Determine Forward tau by brief simulation.
 * Incept:    SRE, Thu Aug  9 15:08:39 2007 [Janelia] (p7_Tau())
 *
 * Purpose:   Identical to p7_Tau() except that it can handle
 *            either an optimized profile or a generic profile,
 *            the latter of which is used for glocal Forward.
 *            See hmmer/evalues.c::cm_p7_Tau for additional information.
 *
 * Args:      r      : source of randomness
 *            om     : configured profile (optimized), if non-NULL, <gm> must be NULL
 *            gm     : configured profile (generic),   if non-NULL, <om> must be NULL
 *            bg     : null model (for background residue frequencies)
 *            L      : mean length model for seq emission from profile
 *            N      : number of sequences to generate
 *            lambda : expected slope of the exponential tail (from p7_Lambda())
 *            tailp  : tail mass from which we will extrapolate mu
 *            ret_tau : RETURN: estimate for the Forward tau (base of exponential tail)
 *
 * Returns:   <eslOK> on success, and <*ret_fv> is the score difference
 *            in bits.
 *
 * Throws:    <eslEMEM> on allocation error, and <*ret_fv> is 0.
 */
int
cm_p7_Tau(ESL_RANDOMNESS *r, char *errbuf, P7_OPROFILE *om, P7_PROFILE *gm, P7_BG *bg, int L, int N, double lambda, double tailp, double *ret_tau)
{
  P7_OMX  *ox = NULL;
  P7_GMX  *gx = NULL;

  ESL_DSQ *dsq     = NULL;
  double  *xv      = NULL;
  float    sc, fsc, nullsc;
  double   gmu, glam;
  int      status;
  int      i;
  int do_generic;

  if(om == NULL && gm == NULL) { status = eslEINVAL; goto ERROR; }
  if(om != NULL && gm != NULL) { status = eslEINVAL; goto ERROR; }
  do_generic = (gm != NULL) ? TRUE : FALSE;

  if(do_generic) {
	gx = p7_gmx_Create(gm->M, L); /* DP matrix: for ForwardParser,  L rows */
	if (gx == NULL) { status = eslEMEM; goto ERROR; }
  }
  else {
	ox = p7_omx_Create(om->M, 0, L);     /* DP matrix: for ForwardParser,  L rows */
	if (ox == NULL) { status = eslEMEM; goto ERROR; }
  }

  ESL_ALLOC(xv,  sizeof(double)  * N);
  ESL_ALLOC(dsq, sizeof(ESL_DSQ) * (L+2));

  if(do_generic) p7_ReconfigLength(gm, L);
  else           p7_oprofile_ReconfigLength(om, L);
  p7_bg_SetLength(bg, L);

  for (i = 0; i < N; i++)
	{
	  if((status = esl_rsq_xfIID(r, bg->f, bg->abc->K, L, dsq)) != eslOK) goto ERROR;
	  if(do_generic) {
	if ((status = p7_GForward(dsq, L, gm, gx, &fsc))           != eslOK) goto ERROR;
	  }
	  else {
	if ((status = p7_ForwardParser(dsq, L, om, ox, &fsc))      != eslOK) goto ERROR;
	  }
	  if((status = p7_bg_NullOne(bg, dsq, L, &nullsc))          != eslOK) goto ERROR;
	  sc = (fsc - nullsc) / eslCONST_LOG2;
	  xv[i] = sc;
	}

  if ((status = esl_gumbel_FitComplete(xv, N, &gmu, &glam)) != eslOK) goto ERROR;
  /* Explanation of the eqn below: first find the x at which the Gumbel tail
   * mass is predicted to be equal to tailp. Then back up from that x
   * by log(tailp)/lambda to set the origin of the exponential tail to 1.0
   * instead of tailp.
   */
  *ret_tau =  esl_gumbel_invcdf(1.0-tailp, gmu, glam) + (log(tailp) / lambda);

  free(xv);
  free(dsq);
  if (ox != NULL) p7_omx_Destroy(ox);
  if (gx != NULL) p7_gmx_Destroy(gx);
  return eslOK;

 ERROR:
  *ret_tau = 0.;
  if (xv  != NULL) free(xv);
  if (dsq != NULL) free(dsq);
  if (ox  != NULL) p7_omx_Destroy(ox);
  if (gx  != NULL) p7_gmx_Destroy(gx);
  return status;
}

/* Function: cm_SetFilterHMM()
 * Incept:   EPN, Mon Dec 27 07:59:47 2010
 *
 * Purpose:  Assign a p7 HMM as a CM's filter hmm (cm->fp7)
 *
 * Args:     cm       - the CM
 *           hmm      - the HMM to add
 *           gfmu     - glocal forward mu parameter
 *           gflambda - glocal forward lambda parameter
 *           errbuf   - for error messages
 *
 * Return:   eslOK   on success
 *
 * Throws:   eslEINCOMPAT on contract violation
 *           eslEMEM on memory error
 */
int
cm_SetFilterHMM(CM_t *cm, P7_HMM *hmm, double gfmu, double gflambda)
{
  if(cm->fp7 != NULL) {
	p7_hmm_Destroy(cm->fp7);
  }
  cm->fp7 = hmm;

  if(hmm->flags & p7H_STATS) {
	cm->fp7_evparam[CM_p7_LMMU]     = hmm->evparam[p7_MMU];
	cm->fp7_evparam[CM_p7_LMLAMBDA] = hmm->evparam[p7_MLAMBDA];
	cm->fp7_evparam[CM_p7_LVMU]     = hmm->evparam[p7_VMU];
	cm->fp7_evparam[CM_p7_LVLAMBDA] = hmm->evparam[p7_VLAMBDA];
	cm->fp7_evparam[CM_p7_LFTAU]    = hmm->evparam[p7_FTAU];
	cm->fp7_evparam[CM_p7_LFLAMBDA] = hmm->evparam[p7_FLAMBDA];
	cm->fp7_evparam[CM_p7_GFMU]     = gfmu;
	cm->fp7_evparam[CM_p7_GFLAMBDA] = gflambda;
  }
  else { /* this should never happen */
	cm->fp7_evparam[CM_p7_LMMU]     = 0.;
	cm->fp7_evparam[CM_p7_LMLAMBDA] = 0.;
	cm->fp7_evparam[CM_p7_LVMU]     = 0.;
	cm->fp7_evparam[CM_p7_LVLAMBDA] = 0.;
	cm->fp7_evparam[CM_p7_LFTAU]    = 0.;
	cm->fp7_evparam[CM_p7_LFLAMBDA] = 0.;
	cm->fp7_evparam[CM_p7_GFMU]     = 0.;
	cm->fp7_evparam[CM_p7_GFLAMBDA] = 0.;
  }
  cm->flags |= CMH_FP7; /* raise the FP7 flag */

  return eslOK;
}

/* Function: dump_p7()
 * Incept:   EPN, Fri Sep 24 14:22:49 2010
 *
 * Purpose:  Dump parameters of a p7 HMM to a file.
 *
 * Args:     hmm       - the p7 HMM
 *           fp        - the file to print to
 *
 * Return:   eslOK   on success
 *
 * Throws:   eslEINCOMPAT on contract violation
 *           eslEMEM on memory error
 */
int
dump_p7(P7_HMM *hmm, FILE *fp)
{
  return p7_hmmfile_WriteASCII(fp, -1, hmm);
}

/* Function: cm_p7_hmm_Sizeof()
 * Incept:   EPN, Wed Jan 18 10:10:10 2012
 *
 * Purpose:  Calculate and return size of a P7_HMM
 *           in Mb.
 *
 * Args:     hmm       - the p7 HMM
 *
 * Return:   size of hmm in Mb
 */
float
cm_p7_hmm_Sizeof(P7_HMM *hmm)
{
  float bytes = 0.;

  bytes = sizeof(P7_HMM);

  if(hmm->M > 0 && hmm->abc != NULL)
  /* following from p7_hmm_CreateBody() */
  bytes += sizeof(float *) * (hmm->M+1); /* t */
  bytes += sizeof(float *) * (hmm->M+1); /* mat */
  bytes += sizeof(float *) * (hmm->M+1); /* ins */

  bytes += sizeof(float) * p7H_NTRANSITIONS*(hmm->M+1); /* t */
  bytes += sizeof(float *) * hmm->abc->K * (hmm->M+1); /* mat */
  bytes += sizeof(float *) * hmm->abc->K * (hmm->M+1); /* ins */

  if(hmm->rf        != NULL) bytes += sizeof(char) * (hmm->M+2);
  if(hmm->consensus != NULL) bytes += sizeof(char) * (hmm->M+2);
  if(hmm->cs        != NULL) bytes += sizeof(char) * (hmm->M+2);
  if(hmm->ca        != NULL) bytes += sizeof(char) * (hmm->M+2);
  if(hmm->map       != NULL) bytes += sizeof(int)  * (hmm->M+1);

  return bytes / 1000000.;
}

/* Function:  cm_p7_hmm_SetConsensus()
 * Incept:    EPN, Wed May  9 14:13:37 2012
 * Synopsis:  Set the consensus residue line of the HMM.
 *
 * Purpose:   Sets the consensus annotation line of the model <hmm>.
 *
 *            Based on p7_hmm_SetConsensus() which is flexible to
 *            setting the consensus as a single sequence or a
 *            consensus from a multiple sequence alignment.  Here,
 *            only the latter case is handled, i.e. but in the future,
 *            we should relax this to allow for single sequence
 *            models.
 *
 *            This function only exists because p7_hmm_SetConsensus()
 *            uses a threshold probability of 0.9 for setting
 *            a consensus residue as uppercase, while we want
 *            to be able to use 0.5 since that's what we use with
 *            single stranded CM positions. (Actually we use 1.0
 *            bits, which equates to a 0.5 probability for a default
 *            null1 model (so using 0.5 will be wrong for non-standard
 *            null models...)).
 *
 *            The most likely (highest emission probability) residue
 *            is the consensus at each position.  If the emission
 *            probability is $\geq$ certain threshold (0.5), the
 *            residue is upper cased.
 *
 * Args:      hmm - model with valid probability parameters mat[1..M][x]
 *
 * Returns:   <eslOK> on success. The <p7H_CONS> flag on the <hmm> is raised
 *            if it wasn't already. The <hmm->consensus> line is set.
 *
 * Throws:    <eslEMEM> on allocation error. The <p7H_CONS> is dropped, even
 *            if it was up to begin with, and the <hmm->consensus> is <NULL>,
 *            even if we had one to begin with.
 *
 */
int
cm_p7_hmm_SetConsensus(P7_HMM *hmm)
{
  int   k, x;
  float mthresh = 0.5;
  int   status;

  /* allocation, if needed */
  if (! hmm->consensus) ESL_ALLOC(hmm->consensus, sizeof(char) * (hmm->M+2));

  /* set our arbitrary threshold for upper/lower casing */

  hmm->consensus[0] = ' ';
  for (k = 1; k <= hmm->M; k++)
	{
	  x = esl_vec_FArgMax(hmm->mat[k], hmm->abc->K);
	  hmm->consensus[k] = ((hmm->mat[k][x] >= mthresh) ? toupper(hmm->abc->sym[x]) : tolower(hmm->abc->sym[x]));
	}
  hmm->consensus[hmm->M+1] = '\0';
  hmm->flags  |= p7H_CONS;
  return eslOK;

 ERROR:
  if (hmm->consensus) free(hmm->consensus);
  hmm->consensus = NULL;
  hmm->flags    &= (~p7H_CONS);
  return status;
}

/*** End of inlined file: cm_p7_modelmaker.c ***/


/*** Start of inlined file: cp9.c ***/
/* cp9.c based on HMMER 2.x's plan7.c
 * EPN 02.27.06
 *
 * Support for CM-Plan 9 HMM data structure, CP9_t.
 *
 * All of the CP9 code is based on analogous HMMER 2.x Plan 7 HMM
 * code.
 *
 */


#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <math.h>


/* Functions: AllocCPlan9(), AllocCPlan9Shell(), AllocCPlan9Body(), FreeCPlan9()
 *
 * Purpose:   Allocate or free a CPlan9 HMM structure.
 *            Can either allocate all at once (AllocCPlan9()) or
 *            in two steps (AllocCPlan9Shell(), AllocCPlan9Body()).
 *            The two step method is used in CP9_hmmio.c where we start
 *            parsing the header of an HMM file but don't
 *            see the size of the model 'til partway thru the header.
 */
CP9_t *
AllocCPlan9(int M, const ESL_ALPHABET *abc)
{
  CP9_t *hmm;

  hmm = AllocCPlan9Shell();
  AllocCPlan9Body(hmm, M, abc);
  return hmm;
}
CP9_t *
AllocCPlan9Shell(void)
{
  int    status;
  CP9_t *hmm;

  ESL_ALLOC(hmm, sizeof(CP9_t));
  hmm->abc = NULL;

  hmm->M = 0;

  hmm->t      = NULL;
  hmm->mat    = NULL;
  hmm->ins    = NULL;

  hmm->tsc     = hmm->msc     = hmm->isc     = NULL;
  hmm->tsc_mem = hmm->msc_mem = hmm->isc_mem = NULL;

  hmm->begin  = NULL;
  hmm->end    = NULL;

  hmm->bsc = hmm->bsc_mem = NULL;
  hmm->esc = hmm->esc_mem = NULL;

  hmm->otsc = NULL;

  hmm->has_el      = NULL;
  hmm->el_from_ct  = NULL;
  hmm->el_from_idx = NULL;
  hmm->el_from_cmnd= NULL;

  hmm->flags = 0;
  return hmm;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return NULL; /* never reached */
}

void
AllocCPlan9Body(CP9_t *hmm, int M, const ESL_ALPHABET *abc)
{
  int status;
  int k, x;

  hmm->abc = abc;

  hmm->M = M;

  ESL_ALLOC(hmm->t,   (M+1) *           sizeof(float *));
  ESL_ALLOC(hmm->mat, (M+1) *           sizeof(float *));
  ESL_ALLOC(hmm->ins, (M+1) *           sizeof(float *));
  ESL_ALLOC(hmm->t[0],(cp9_NTRANS*(M+1)) *  sizeof(float));
  ESL_ALLOC(hmm->mat[0],(abc->K*(M+1))   * sizeof(float));
  ESL_ALLOC(hmm->ins[0],(abc->K*(M+1))   * sizeof(float));

  ESL_ALLOC(hmm->tsc, cp9_NTRANS     *   sizeof(int *));
  ESL_ALLOC(hmm->msc, hmm->abc->Kp   *   sizeof(int *));
  ESL_ALLOC(hmm->isc, hmm->abc->Kp   *   sizeof(int *));
  ESL_ALLOC(hmm->tsc_mem,(cp9_NTRANS*(M+1))     *       sizeof(int));
  ESL_ALLOC(hmm->msc_mem,(hmm->abc->Kp*(M+1)) * sizeof(int));
  ESL_ALLOC(hmm->isc_mem,(hmm->abc->Kp*(M+1)) * sizeof(int));

  hmm->tsc[0] = hmm->tsc_mem;
  hmm->msc[0] = hmm->msc_mem;
  hmm->isc[0] = hmm->isc_mem;

  /* transition scores reordered */
  ESL_ALLOC(hmm->otsc, sizeof(int)   * (M+1)  * cp9O_NTRANS);

  /* note allocation strategy for important 2D arrays -- trying
   * to keep locality as much as possible, cache efficiency etc.
   */
  for (k = 1; k <= M; k++) {
	hmm->mat[k] = hmm->mat[0] + k * abc->K;
	hmm->ins[k] = hmm->ins[0] + k * abc->K;
	hmm->t[k]   = hmm->t[0]   + k * cp9_NTRANS;
  }
  for (x = 1; x < hmm->abc->Kp; x++) {
	hmm->msc[x] = hmm->msc[0] + x * (M+1);
	hmm->isc[x] = hmm->isc[0] + x * (M+1);
  }
  for (x = 0; x < cp9_NTRANS; x++)
	hmm->tsc[x] = hmm->tsc[0] + x * (M+1);

  /* tsc[x][0] is used as a boundary condition sometimes [Viterbi()],
   * so set to -inf always.
   */
  for (x = 0; x < cp9_NTRANS; x++)
	hmm->tsc[x][0] = -INFTY;

  ESL_ALLOC(hmm->begin, (M+1) * sizeof(float));
  ESL_ALLOC(hmm->end,   (M+1) * sizeof(float));

  ESL_ALLOC(hmm->bsc_mem, (M+1) * sizeof(int));
  ESL_ALLOC(hmm->esc_mem, (M+1) * sizeof(int));

  ESL_ALLOC(hmm->null, (abc->K) * sizeof(float));

  hmm->bsc = hmm->bsc_mem;
  hmm->esc = hmm->esc_mem;

  /* end[0], begin[0], esc[0] and bsc[0] are never
   * used, set them to 0. and -INFTY */
  hmm->end[0] = hmm->begin[0] = -INFTY;
  hmm->esc[0] = hmm->bsc[0] = -INFTY;

  ESL_ALLOC(hmm->has_el,     (M+1) * sizeof(int));
  ESL_ALLOC(hmm->el_from_ct, (M+2) * sizeof(int));
  ESL_ALLOC(hmm->el_from_idx,(M+2) * sizeof(int *));
  ESL_ALLOC(hmm->el_from_cmnd,(M+2) * sizeof(int *));
  esl_vec_ISet(hmm->has_el,     M+1, FALSE);
  esl_vec_ISet(hmm->el_from_ct, M+1, 0);
  for(k = 0; k <= M+1; k++) {
	hmm->el_from_idx[k] = NULL;
	hmm->el_from_cmnd[k] = NULL;
  }

  return;
 ERROR:
  cm_Fail("Memory allocation error.");
}

void
FreeCPlan9(CP9_t *hmm)
{
  int k;
  if (hmm->null       != NULL) free(hmm->null);
  if (hmm->bsc_mem    != NULL) free(hmm->bsc_mem);
  if (hmm->begin      != NULL) free(hmm->begin);
  if (hmm->esc_mem    != NULL) free(hmm->esc_mem);
  if (hmm->end        != NULL) free(hmm->end);
  if (hmm->msc_mem    != NULL) free(hmm->msc_mem);
  if (hmm->isc_mem    != NULL) free(hmm->isc_mem);
  if (hmm->tsc_mem    != NULL) free(hmm->tsc_mem);
  if (hmm->mat        != NULL) free(hmm->mat[0]);
  if (hmm->ins        != NULL) free(hmm->ins[0]);
  if (hmm->t          != NULL) free(hmm->t[0]);
  if (hmm->msc        != NULL) free(hmm->msc);
  if (hmm->isc        != NULL) free(hmm->isc);
  if (hmm->tsc        != NULL) free(hmm->tsc);
  if (hmm->otsc       != NULL) free(hmm->otsc);
  if (hmm->mat        != NULL) free(hmm->mat);
  if (hmm->ins        != NULL) free(hmm->ins);
  if (hmm->t          != NULL) free(hmm->t);
  if (hmm->has_el     != NULL) free(hmm->has_el);
  if (hmm->el_from_ct != NULL) free(hmm->el_from_ct);
  if(hmm->el_from_idx != NULL)
	{
	  for(k = 0; k <= hmm->M+1; k++)
	if(hmm->el_from_idx[k] != NULL)
	  free(hmm->el_from_idx[k]);
	  free(hmm->el_from_idx);
	}
  if(hmm->el_from_cmnd != NULL)
	{
	  for(k = 0; k <= hmm->M+1; k++)
	if(hmm->el_from_cmnd[k] != NULL)
	  free(hmm->el_from_cmnd[k]);
	  free(hmm->el_from_cmnd);
	}

  free(hmm);
}

/* Function: ZeroCPlan9()
 *
 * Purpose:  Zeros the counts/probabilities fields in a model.
 *           Leaves null model untouched.
 */
void
ZeroCPlan9(CP9_t *hmm)
{
  int k;
  esl_vec_FSet(hmm->ins[0], hmm->abc->K, 0.);
  esl_vec_FSet(hmm->t[0], cp9_NTRANS, 0.);
  for (k = 1; k <= hmm->M; k++)
	{
	  esl_vec_FSet(hmm->t[k], cp9_NTRANS, 0.);
	  esl_vec_FSet(hmm->mat[k], hmm->abc->K, 0.);
	  esl_vec_FSet(hmm->ins[k], hmm->abc->K, 0.);
	}
  esl_vec_FSet(hmm->begin+1, hmm->M, 0.);
  esl_vec_FSet(hmm->end+1, hmm->M, 0.);

  /* initialize the el_* data structures, these
   * depend on the CM guide tree and will be set
   * when the CP9 is constructed from the CM.
   */
  for (k = 0; k <= (hmm->M); k++)
	{
	  hmm->has_el[k]      = FALSE;
	  hmm->el_from_ct[k]  = 0;
	  hmm->el_from_idx[k] = NULL;
	  hmm->el_from_cmnd[k] = NULL;
	}
  /* special case hmm->M+1 corresponds to the E state here */
  hmm->el_from_ct[(hmm->M+1)]  = 0;
  hmm->el_from_idx[(hmm->M+1)] = NULL;
  hmm->el_from_cmnd[(hmm->M+1)] = NULL;

  hmm->flags &= ~CPLAN9_HASBITS;	/* invalidates scores */
  hmm->flags &= ~CPLAN9_HASPROB;	/* invalidates probabilities */
  hmm->el_self = 0.; /* EL self transition probability */
}

/* Function: CPlan9SetNullModel()
 *
 * Purpose:  Set the null model section of an HMM.
 *           Convenience function.
 *
 *            Assumes null* is allocated to hmm->abc->K
 */
void
CPlan9SetNullModel(CP9_t *hmm, float *null, float p1)
{
  int x;
  for (x = 0; x < hmm->abc->K; x++)
	hmm->null[x] = null[x];
  hmm->p1 = p1;
}

/* Function: cp9_Clone()
 * Date:     EPN, Thu Dec  1 10:30:18 2011
 * Purpose:  Clone a CP9 HMM CP9_t object
 */
CP9_t *
cp9_Clone(CP9_t *cp9)
{
  CP9_t *cp9dup = NULL;
  int    status;

  if ((cp9dup = AllocCPlan9(cp9->M, cp9->abc)) == NULL) return NULL;
  if ((status = cp9_Copy(cp9, cp9dup)) != eslOK) goto ERROR;
  return cp9dup;

 ERROR:
  FreeCPlan9(cp9dup);
  return NULL;
}

/* Function:  cp9_Copy()
 * Synopsis:  Copy a CM plan 9 HMM.
 *
 * Purpose:   Copies cp9 hmm <src> to cp9 hmm <dst>, where <dst>
 *            has already been allocated to be of sufficient size.
 *
 *            <src> should be properly normalized, no check is done to
 *            ensure that. If <src> is logoddsified (src->flags &
 *            CPLAN9_HASBITS) its bit scores will be copied to <dst>,
 *            otherwise they are invalid and won't be copied.
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation error; <eslEINVAL> if <dst> is too small
 *            to fit <src>.
 */
int
cp9_Copy(const CP9_t *src, CP9_t *dst)
{
  int status;
  int k;
  int src_has_bits = (src->flags & CPLAN9_HASBITS) ? TRUE : FALSE;

  if (src->M != dst->M) return eslEINVAL;

  dst->abc = src->abc;

  for(k = 0; k <= src->M; k++) {
	esl_vec_FCopy(src->t[k],   cp9_NTRANS,  dst->t[k]);
	esl_vec_FCopy(src->mat[k], src->abc->K, dst->mat[k]);
	esl_vec_FCopy(src->ins[k], src->abc->K, dst->ins[k]);
  }
  esl_vec_FCopy(src->begin, src->M+1, dst->begin);
  esl_vec_FCopy(src->end,   src->M+1, dst->end);
  if(src_has_bits) {
	esl_vec_ICopy(src->bsc_mem, src->M+1, dst->bsc_mem);
	esl_vec_ICopy(src->esc_mem, src->M+1, dst->esc_mem);
  }

  /* exploit linear-memory of these 2d arrays */
  if(src_has_bits) {
	esl_vec_ICopy(src->tsc_mem, cp9_NTRANS   * (src->M+1), dst->tsc_mem);
	esl_vec_ICopy(src->msc_mem, src->abc->Kp * (src->M+1), dst->msc_mem);
	esl_vec_ICopy(src->isc_mem, src->abc->Kp * (src->M+1), dst->isc_mem);
	esl_vec_ICopy(src->otsc,    cp9O_NTRANS  * (src->M+1), dst->otsc);
  }

  /* EL info */
  dst->el_self     = src->el_self;
  dst->el_selfsc   = src->el_selfsc;
  esl_vec_ICopy(src->has_el,     src->M+1,    dst->has_el);
  esl_vec_ICopy(src->el_from_ct, src->M+2,    dst->el_from_ct);
  for(k = 0; k <= src->M+1; k++) {
	if(src->el_from_ct[k] > 0) {
	  ESL_ALLOC(dst->el_from_idx[k],  sizeof(int) * src->el_from_ct[k]);
	  ESL_ALLOC(dst->el_from_cmnd[k], sizeof(int) * src->el_from_ct[k]);
	  esl_vec_ICopy(src->el_from_idx[k],  src->el_from_ct[k], dst->el_from_idx[k]);
	  esl_vec_ICopy(src->el_from_cmnd[k], src->el_from_ct[k], dst->el_from_cmnd[k]);
	}
  }

  dst->null2_omega = src->null2_omega;
  dst->null3_omega = src->null3_omega;
  esl_vec_FCopy(src->null, src->abc->K, dst->null);

  dst->p1    = src->p1;
  dst->flags = src->flags;

  return eslOK;

 ERROR:
  return status;
}

/* Function: cp9_Sizeof()
 * Date:     EPN, Wed Jan 18 05:46:02 2012
 * Purpose:  Return size of a CP9_t object, in Mb.
 */
float
cp9_Sizeof(CP9_t *cp9)
{
  float bytes = 0.;
  int   M = cp9->M; /* for convenience */

  bytes += sizeof(CP9_t);
  if(cp9->M > 0 && cp9->abc != NULL) {
	/* from AllocCPlan9Body() */
	bytes += sizeof(float *) * (M+1); /* hmm->t */
	bytes += sizeof(float *) * (M+1); /* hmm->mat */
	bytes += sizeof(float *) * (M+1); /* hmm->ins */
	bytes += sizeof(float)   * (cp9_NTRANS*(M+1)); /* hmm->t[0] */
	bytes += sizeof(float)   * (cp9->abc->K*(M+1));     /* hmm->mat[0] */
	bytes += sizeof(float)   * (cp9->abc->K*(M+1));     /* hmm->ins[0] */

	bytes += sizeof(int *) * cp9_NTRANS;   /* hmm->tsc */
	bytes += sizeof(int *) * cp9->abc->Kp; /* hmm->msc */
	bytes += sizeof(int *) * cp9->abc->Kp; /* hmm->isc */
	bytes += sizeof(int)   * (cp9_NTRANS*(M+1)); /* hmm->tsc_mem */
	bytes += sizeof(int)   * (cp9->abc->Kp*(M+1)); /* hmm->msc_mem */
	bytes += sizeof(int)   * (cp9->abc->Kp*(M+1)); /* hmm->isc_mem */

	bytes += sizeof(int)   * (M+1) * cp9O_NTRANS; /* hmm->otsc */

	bytes += sizeof(float) * (M+1); /* hmm->begin */
	bytes += sizeof(float) * (M+1); /* hmm->end   */
	bytes += sizeof(int)   * (M+1); /* hmm->bsc_mem */
	bytes += sizeof(int)   * (M+1); /* hmm->esc_mem */
	bytes += sizeof(float) * (cp9->abc->K); /* hmm->null */

	bytes += sizeof(int)   * (M+1); /* hmm->has_el */
	bytes += sizeof(int)   * (M+2); /* hmm->el_from_ct */
	bytes += sizeof(int *) * (M+2); /* hmm->el_from_idx */
	bytes += sizeof(int *) * (M+2); /* hmm->el_from_cmnd */

	int k;
	for(k = 0; k <= cp9->M+1; k++) {
	  if(cp9->el_from_ct[k] > 0) {
	bytes += sizeof(int) * cp9->el_from_ct[k]; /* hmm->el_from_idx */
	bytes += sizeof(int) * cp9->el_from_ct[k]; /* hmm->el_from_cmnd */
	  }
	}
  }

  return (bytes / 1000000.);
}

/* Function: cp9_GetNCalcsPerResidue()
 * Date:     EPN, Thu Jan 17 06:12:37 2008
 *
 * Returns: eslOK on success, eslEINCOMPAT on contract violation.
 *          <ret_cp9_ncalcs_per_res> set as millions of DP calculations
 *          per residue for the CP9 HMM.
 */
int
cp9_GetNCalcsPerResidue(CP9_t *cp9, char *errbuf, float *ret_cp9_ncalcs_per_res)
{
  int cp9_ntrans;
  float cp9_ncalcs_per_res;

  if(cp9 == NULL)                    ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_GetNCalcsPerRes(), cp9 == NULL.");
  if(ret_cp9_ncalcs_per_res == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_GetNCalcsPerRes(), ret_cp9_ncalcs_per_res == NULL.");

  /* determine millions of CP9 DP calcs per residue */
  cp9_ntrans = NHMMSTATETYPES * NHMMSTATETYPES; /* 3*3 = 9 transitions in global mode */
  if(cp9->flags & CPLAN9_LOCAL_BEGIN) cp9_ntrans++;
  if(cp9->flags & CPLAN9_LOCAL_END)   cp9_ntrans++;
  if(cp9->flags & CPLAN9_EL)          cp9_ntrans++;
  cp9_ncalcs_per_res = (cp9_ntrans * cp9->M) / 1000000.; /* convert to millions of calcs per residue */

  *ret_cp9_ncalcs_per_res = cp9_ncalcs_per_res;
  return eslOK;
}

/* Function: CP9Logoddsify()
 *
 * Purpose:  Take an HMM with valid probabilities, and
 *           fill in the integer log-odds score section of the model.
 *
 *    Notes on log-odds scores (simplified from plan7.c):
 *         type of parameter       probability        score
 *         -----------------       -----------        ------
 *         any emission             p_x           log_2 p_x/null_x
 *         any transition           t_x           log_2 t_x
 *
 * Args:      hmm          - the hmm to calculate scores in.
 *
 * Return:    (void)
 *            hmm scores are filled in.
 */
void
CP9Logoddsify(CP9_t *hmm)
{
  /*printf("in CP9Logoddsify()\n");*/
  int k;			/* counter for model position */
  int x;			/* counter for symbols        */
  int *sc;
  int status;

  if (hmm->flags & CPLAN9_HASBITS) return;

  ESL_ALLOC(sc, hmm->abc->Kp * sizeof(int));

  /* Symbol emission scores
   */

  sc[hmm->abc->K]     = -INFTY; /* gap character */
  sc[hmm->abc->Kp-1]  = -INFTY; /* missing data character */
  sc[hmm->abc->Kp-2]  = -INFTY; /* non-residue data character */

  /* Insert emission scores, relies on sc[K, Kp-1] initialization to -inf above */
  for (k = 0; k <= hmm->M; k++) {
	for (x = 0; x < hmm->abc->K; x++)
	  sc[x] = Prob2Score(hmm->ins[k][x], hmm->null[x]);
	esl_abc_IExpectScVec(hmm->abc, sc, hmm->null);
	for (x = 0; x < hmm->abc->Kp; x++) {
	  hmm->isc[x][k] = sc[x];
	}
  }

  /* Match emission scores, relies on sc[K, Kp-1] initialization to -inf above */
  for (k = 1; k <= hmm->M; k++) {
	for (x = 0; x < hmm->abc->K; x++)
	  sc[x] = Prob2Score(hmm->mat[k][x], hmm->null[x]);
	esl_abc_IExpectScVec(hmm->abc, sc, hmm->null);
	for (x = 0; x < hmm->abc->Kp; x++) {
	  hmm->msc[x][k] = sc[x];
	}
  }

  for (k = 0; k <= hmm->M; k++)
	{
	  hmm->tsc[CTMM][k] = Prob2Score(hmm->t[k][CTMM], 1.0);
	  hmm->tsc[CTMI][k] = Prob2Score(hmm->t[k][CTMI], 1.0);
	  hmm->tsc[CTMD][k] = Prob2Score(hmm->t[k][CTMD], 1.0);
	  hmm->tsc[CTMEL][k] = Prob2Score(hmm->t[k][CTMEL], 1.0);
	  hmm->tsc[CTIM][k] = Prob2Score(hmm->t[k][CTIM], 1.0);
	  hmm->tsc[CTII][k] = Prob2Score(hmm->t[k][CTII], 1.0);
	  hmm->tsc[CTID][k] = Prob2Score(hmm->t[k][CTID], 1.0);
	  if(k != 0)
	{
	  hmm->tsc[CTDM][k] = Prob2Score(hmm->t[k][CTDM], 1.0);
	  hmm->tsc[CTDI][k] = Prob2Score(hmm->t[k][CTDI], 1.0);
	  hmm->tsc[CTDD][k] = Prob2Score(hmm->t[k][CTDD], 1.0);
	}
	  else
	{
	  hmm->tsc[CTDM][k] = -INFTY;
	  hmm->tsc[CTDD][k] = -INFTY; /*D_0 doesn't exist*/
	  hmm->tsc[CTDI][k] = -INFTY;
	}
	  if(k != 0)
	{
	  hmm->bsc[k]   = Prob2Score(hmm->begin[k], 1.0);
	  hmm->esc[k] = Prob2Score(hmm->end[k], 1.0);
	}
	}
  hmm->el_selfsc = Prob2Score(hmm->el_self, 1.0);

  /* Finally, fill the efficiently reordered transition scores for this HMM. */
  for (k = 0 ; k <= hmm->M; k++) {
	int *otsc_k = hmm->otsc + k*cp9O_NTRANS;
	otsc_k[cp9O_MM] = hmm->tsc[CTMM][k];
	otsc_k[cp9O_MI] = hmm->tsc[CTMI][k];
	otsc_k[cp9O_MD] = hmm->tsc[CTMD][k];
	otsc_k[cp9O_IM] = hmm->tsc[CTIM][k];
	otsc_k[cp9O_II] = hmm->tsc[CTII][k];
	otsc_k[cp9O_DM] = hmm->tsc[CTDM][k];
	otsc_k[cp9O_DD] = hmm->tsc[CTDD][k];
	otsc_k[cp9O_ID] = hmm->tsc[CTID][k];
	otsc_k[cp9O_DI] = hmm->tsc[CTDI][k];
	otsc_k[cp9O_BM] = hmm->bsc[k];
	otsc_k[cp9O_MEL]= hmm->tsc[CTMEL][k];
	otsc_k[cp9O_ME] = hmm->esc[k];
  }

  hmm->flags |= CPLAN9_HASBITS;	/* raise the log-odds ready flag */

  free(sc);

  return;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return; /* never reached */
}

/* Function: CPlan9Renormalize()
 *
 * Purpose:  Take an HMM in counts form, and renormalize
 *           all of its probability vectors. Also enforces
 *           CM Plan9 restrictions on nonexistent transitions.
 *
 * Args:     hmm - the model to renormalize.
 *
 * Return:   (void)
 *           hmm is changed.
 */
void
CPlan9Renormalize(CP9_t *hmm)
{
  int   k;			/* counter for model position */
  float d;			/* denominator */

				/* match emissions */
  esl_vec_FSet(hmm->mat[0], hmm->abc->K, 0.);   /*M_0 is B state, non-emitter*/
  for (k = 1; k <= hmm->M; k++)
	esl_vec_FNorm(hmm->mat[k], hmm->abc->K);
				/* insert emissions */
  for (k = 0; k <= hmm->M; k++)
	esl_vec_FNorm(hmm->ins[k], hmm->abc->K);

				/* begin transitions */
  d = esl_vec_FSum(hmm->begin+1, hmm->M) + hmm->t[0][CTMI] + hmm->t[0][CTMD] + hmm->t[0][CTMEL];
  /* hmm->t[0][CTMEL] should always be 0., can't local end from the M_0 == B state */
  esl_vec_FScale(hmm->begin+1, hmm->M, 1./d);
  hmm->t[0][CTMI] /= d;
  hmm->t[0][CTMD] /= d;
  hmm->t[0][CTMEL] /= d;

  esl_vec_FNorm(hmm->t[0] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT);	        /* transitions out of insert for node 0 (state N)*/
  esl_vec_FSet (hmm->t[0] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE, 0.);
				/* main model transitions */
  for (k = 1; k <= hmm->M; k++) /* safe for node M too, hmm->t[hmm->M][CTMM] should be 0.*/
	{
	  d = esl_vec_FSum(hmm->t[k], cp9_TRANS_NMATCH) + hmm->end[k];
	  esl_vec_FScale(hmm->t[k], cp9_TRANS_NMATCH, 1./d);
	  hmm->end[k] /= d;

	  esl_vec_FNorm(hmm->t[k] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT);	/* insert */
	  esl_vec_FNorm(hmm->t[k] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE);	/* delete */
	}
								 /* null model emissions */
  esl_vec_FNorm(hmm->null, hmm->abc->K);

  hmm->flags &= ~CPLAN9_HASBITS;	/* clear the log-odds ready flag */
  hmm->flags |= CPLAN9_HASPROB;	/* set the probabilities OK flag */
}

/*** End of inlined file: cp9.c ***/


/*** Start of inlined file: cp9_dp.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


#define CP9TSC(s,k) (tsc[(k) * cp9O_NTRANS + (s)])

#define IAMI_M  (1<<0)
#define IAMI_I  (1<<1)
#define IAMI_D  (1<<2)
#define IAMI_EL (1<<3)
#define nIAMI_S 4

#define IAMI_MM  (1<<0)
#define IAMI_IM  (1<<1)
#define IAMI_DM  (1<<2)
#define IAMI_BM  (1<<3)
#define IAMI_MI  (1<<4)
#define IAMI_II  (1<<5)
#define IAMI_DI  (1<<6)
#define IAMI_MD  (1<<7)
#define IAMI_ID  (1<<8)
#define IAMI_DD  (1<<9)
#define IAMI_ME  (1<<10)
#define IAMI_MEL (1<<11)
#define nIAMI_T  12

#define TDIFF_MI_M 0
#define TDIFF_MI_I 1
#define TDIFF_MI_D 2
#define nTDIFF 3

/* Function: cp9_Viterbi()
 *
 * Purpose:  Runs the Viterbi dynamic programming algorithm on an
 *           input subsequence (i0-j0).
 *           Somewhat flexible based on input options.
 *
 * Note:     IDENTICAL to CP9Forward() below with maxes replacing
 *           sums in DP recursion, and the possibility of returning a
 *           CP9 trace if doing_align == TRUE. See CP9Forward() for more info,
 *           including more verbose 'Purpose' and description of arguments.
 *
 * Returns:  <ret_sc>: if(!do_scan)     log P(S,tr|M)/P(S,tr|R), as a bit score
 *                     else         max log P(S,tr|M)/P(S,tr|R), for argmax subseq S of input seq i0..j0,
 *           eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
int
cp9_Viterbi(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int i0, int j0, int do_scan, int doing_align,
	    int be_efficient, int **ret_psc, int *ret_maxres, CP9trace_t **ret_tr, float *ret_sc)
{
  int          status;
  int          j;           /*     actual   position in the subsequence                     */
  int          jp;          /* j': relative position in the subsequence                     */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int          L;           /* j0-i0+1: subsequence length                                  */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int         *scA;         /* prob (seq from j0..jp | HMM) [0..jp..cp9->M]             */
  float        fsc;         /* float log odds score                                         */
  float        best_sc;     /* score of best hit overall                                    */
  float        best_pos;    /* residue (j) giving best_sc, where best hit ends              */
  int          nrows;       /* num rows for DP matrix, 2 or L+1 depending on be_efficient   */
  int          c;           /* counter for EL states                                        */
  CP9trace_t  *tr;          /* CP9 trace for full seq i0..j0, used if ret_tr != NULL        */
  int          M;           /* cp9->M, query length, number of consensus nodes of model */

  /* Contract checks */
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Viterbi, dsq is NULL.");
  if(mx == NULL)                             ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Viterbi, mx is NULL.\n");

  best_sc     = IMPOSSIBLE;
  best_pos    = -1;
  L = j0-i0+1;
  M = cp9->M;

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  /* Grow DP matrix if nec, to either 2 rows or L+1 rows (depending on be_efficient),
   * stays M+1 columns */
  if(be_efficient) nrows = 1; /* mx will be 2 rows */
  else             nrows = L; /* mx will be L+1 rows */
  if((status = GrowCP9Matrix(mx, errbuf, nrows, M, NULL, NULL, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_Viterbi(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));

  /* scA will hold P(seq up to j | Model) in int log odds form */
  ESL_ALLOC(scA, sizeof(int) * (j0-i0+2));

  /* Initialization of the zero row. */
  mmx[0][0] = 0;      /* M_0 is state B, and everything starts in B */
  imx[0][0] = -INFTY; /* I_0 is state N, can't get here without emitting*/
  dmx[0][0] = -INFTY; /* D_0 doesn't exist. */
  elmx[0][0]= -INFTY; /* can't go from B to EL state */
  erow[0]   = -INFTY;

  /* Because there's a D state for every node 1..M,
	 dmx[0][k] is possible for all k 1..M */
  int sc;
  for (k = 1; k <= M; k++)
	{
	  mmx[0][k] = imx[0][k] = elmx[0][k] = -INFTY;      /* need seq to get here */
	  sc = ESL_MAX(mmx[0][k-1] + CP9TSC(cp9O_MD,k-1),
		   imx[0][k-1] + CP9TSC(cp9O_ID,k-1));
	  sc = ESL_MAX(sc, dmx[0][k-1] + CP9TSC(cp9O_DD,k-1));
	  dmx[0][k] = sc;
	}
  /* We can do a full parse through all delete states. */
  erow[0]  = dmx[0][M] + CP9TSC(cp9O_DM,M);
  scA[0]   = erow[0];
  fsc      = Scorify(scA[0]);
  /*printf("jp: %d j: %d fsc: %f isc: %d\n", jp, j, fsc, isc[jp]);*/
  if(fsc > best_sc) { best_sc = fsc; best_pos= i0-1; }
  /*printf("jp: %d j: %d fsc: %f sc: %d\n", 0, i0-1, Scorify(sc[0]), sc[0]);*/

  /*****************************************************************
   * The main loop: scan the sequence from position i0 to j0.
   *****************************************************************/
  /* Recursion. */
  for (j = i0; j <= j0; j++)
	{
	  int const *isc = cp9->isc[dsq[j]];
	  int const *msc = cp9->msc[dsq[j]];

	  int endsc     = -INFTY;
	  int el_selfsc = cp9->el_selfsc;
	  int sc;

	  jp = j-i0+1;     /* jp is relative position in the sequence 1..L */
	  cur = (j-i0+1);
	  prv = (j-i0);

	  if(be_efficient) {
	cur %= 2;
	prv %= 2;
	  }

	  /* The 1 difference between a Viterbi scanner and the
	   * regular Viterbi. In non-scanner parse must begin in B at
	   * position 0 (i0-1), in scanner we can start at any position
	   * in the seq. */
	  mmx[cur][0]  = (do_scan == TRUE) ? 0 : -INFTY;
	  dmx[cur][0]  = -INFTY;  /*D_0 is non-existent*/
	  elmx[cur][0] = -INFTY;  /*no EL state for node 0 */

	  sc = ESL_MAX(mmx[prv][0] + CP9TSC(cp9O_MI,0),
		   imx[prv][0] + CP9TSC(cp9O_II,0));
	  sc = ESL_MAX(sc, dmx[prv][0] + CP9TSC(cp9O_DI,0));
	  imx[cur][0] = ESL_MAX(sc + isc[0], -INFTY);

	  for (k = 1; k <= M; k++)
	{
	  /*match state*/
	  sc = ESL_MAX(    mmx[prv][k-1] + CP9TSC(cp9O_MM,k-1),
			   imx[prv][k-1] + CP9TSC(cp9O_IM,k-1));
	  sc = ESL_MAX(sc, dmx[prv][k-1] + CP9TSC(cp9O_DM,k-1));
	  sc = ESL_MAX(sc, mmx[prv][0]   + CP9TSC(cp9O_BM,k));
	  /* check possibility we came from an EL, if they're valid */
	  for(c = 0; c < cp9->el_from_ct[k]; c++) /* el_from_ct[k] is >= 0 */
	    sc = ESL_MAX(sc, elmx[prv][cp9->el_from_idx[k][c]]);
	    /* transition penalty to EL incurred when EL was entered */
	  mmx[cur][k] = ESL_MAX(sc + msc[k], -INFTY);

	  /* E state update */
	  endsc = ESL_MAX(endsc, mmx[cur][k] + CP9TSC(cp9O_ME,k));

	  /*insert state*/
	  sc = ESL_MAX(    mmx[prv][k] + CP9TSC(cp9O_MI,k),
		           imx[prv][k] + CP9TSC(cp9O_II,k));
	  sc = ESL_MAX(sc, dmx[prv][k] + CP9TSC(cp9O_DI,k));
	  imx[cur][k] = ESL_MAX(sc + isc[k], -INFTY);

	  /*delete state*/
	  sc = ESL_MAX(    mmx[cur][k-1] + CP9TSC(cp9O_MD,k-1),
		           imx[cur][k-1] + CP9TSC(cp9O_ID,k-1));
	  sc = ESL_MAX(sc, dmx[cur][k-1] + CP9TSC(cp9O_DD,k-1));
	  dmx[cur][k] = sc;

	  /*el state*/
	  sc = -INFTY;
	  if((cp9->flags & CPLAN9_EL) && cp9->has_el[k]) /* not all HMM nodes have an EL state (for ex:
								    HMM nodes that map to right half of a MATP_MP) */
	    {
	      sc = ESL_MAX(sc, mmx[cur][k]  + CP9TSC(cp9O_MEL,k));
	      sc = ESL_MAX(sc, elmx[prv][k] + el_selfsc);
	    }
	  elmx[cur][k] = sc;
	}

	  endsc = ESL_MAX(endsc, dmx[cur][M] + CP9TSC(cp9O_DM,M)); /* transition from D_M -> end */
	  endsc = ESL_MAX(endsc, imx[cur][M] + CP9TSC(cp9O_IM,M)); /* transition from I_M -> end */
	  for(c = 0; c < cp9->el_from_ct[M+1]; c++) /* el_from_ct[k] is >= 0 */
	/* transition penalty to EL incurred when EL was entered */
	endsc = ESL_MAX(endsc, elmx[cur][cp9->el_from_idx[M+1][c]]);

	  erow[cur] = endsc;
	  scA[jp]   = endsc;
	  fsc = Scorify(endsc);

	  if(fsc > best_sc) { best_sc = fsc; best_pos= j; }
	} /* end loop over end positions j */

  if(doing_align) { /* best_sc is the alignment score */
	best_sc  = Scorify(scA[(j0-i0+1)]); /* L = j0-i0+1 */
	best_pos = i0;
	if(ret_tr != NULL) {
	  CP9ViterbiTrace(cp9, dsq, i0, j0, mx, &tr);
	  if(tr == NULL) ESL_FAIL(eslFAIL, errbuf, "CP9ViterbiTrace() returned NULL, problem with traceback.");
	  /* CP9PrintTrace(stdout, tr, cp9, dsq); */
	  *ret_tr = tr;
	}
  }
  if(ret_sc != NULL)     *ret_sc     = best_sc;
  if(ret_maxres != NULL) *ret_maxres = best_pos;
  if(ret_psc != NULL)    *ret_psc    = scA;
  else                    free(scA);
  ESL_DPRINTF1(("cp9_Viterbi() return score: %10.4f\n", best_sc));

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.");
}

/* Function: cp9_ViterbiBackward()
 *
 * Purpose:  Runs the Viterbi dynamic programming algorithm BACKWARDS on an
 *           input subsequence (i0-j0).
 *           Somewhat flexible based on input options.
 *
 * Note:     IDENTICAL to CP9Backward() below with maxes replacing
 *           sums in DP recursion, and the possibility of returning a
 *           CP9 trace if doing_align == TRUE. See CP9Backward() for more info,
 *           including more verbose 'Purpose' and description of arguments.
 *
 * Returns:  <ret_sc>: if(!do_scan)     log P(S,tr|M)/P(S,tr|R), as a bit score
 *                     else         max log P(S,tr|M)/P(S,tr|R), for argmax subseq S of input seq i0..j0,
 *           eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
int
cp9_ViterbiBackward(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int i0, int j0, int do_scan, int doing_align,
		    int be_efficient, int **ret_psc, int *ret_maxres, CP9trace_t **ret_tr, float *ret_sc)
{
  int          status;
  int          i;           /* actual position in the subsequence                           */
  int          ip;          /* i': relative position in the subsequence                     */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int          L;           /* j0-i0+1: subsequence length                                  */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int         *scA;         /* prob (seq from j0..jp | HMM) [0..jp..cp9->M]             */
  float        fsc;         /* float log odds score                                         */
  float        best_sc;     /* score of best hit overall                                    */
  float        best_pos;    /* residue (i) giving best_sc, where best hit starts            */
  int          nrows;       /* num rows for DP matrix, 2 or L+1 depending on be_efficient   */
  int          c;           /* counter for EL states */
  int          M;           /* cp9->M, query length, number of consensus nodes of model */

  /* Contract checks */
  if(cp9 == NULL)                        ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ViterbiBackward, cp9 is NULL.\n");
  if(dsq == NULL)                            ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ViterbiBackward, dsq is NULL.");
  if(mx == NULL)                             ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_ViterbiBackward, mx is NULL.\n");

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  best_sc     = IMPOSSIBLE;
  best_pos    = -1;
  L = j0-i0+1;
  M = cp9->M;

  /* Grow DP matrix if nec, to either 2 rows or L+1 rows (depending on be_efficient),
   * stays M+1 columns */
  if(be_efficient) nrows = 1; /* mx will be 2 rows */
  else             nrows = L; /* mx will be L+1 rows */
  if((status = GrowCP9Matrix(mx, errbuf, nrows, M, NULL, NULL, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_ViterbiBackward(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));

  /* scA will hold P(seq up to j | Model) in int log odds form */
  ESL_ALLOC(scA, sizeof(int) * (j0-i0+2));

  /* Initialization of the L (i = j0, cur = (j0-i) = (j0-j0) %2 = 0) row. */
  if(be_efficient) cur = 0;
  else cur = j0-i0+1; /* L */
  ip = j0-i0+1;  /*L */
  i  = j0;

  /*******************************************************************
   * 0 Handle EL, looking at EL_k->E for all valid k.
   * we're going backwards so we have to work out of order, we could get
   * around this by storing the nodes each EL goes TO in an el_to_ct[] vec. */
  /* init to -INFTY */
  for (k = 1; k <= cp9->M; k++) elmx[cur][k] = -INFTY;
  if(cp9->flags & CPLAN9_EL) {
	for(c = 0; c < cp9->el_from_ct[cp9->M+1]; c++) /* el_from_ct[cp9->M+1] holds # ELs that can go to END */
	  elmx[cur][cp9->el_from_idx[cp9->M+1][c]] = 0.; /* EL<-E, penalty incurred when we enter EL (i.e. leave going backwards) */
  }
  /*******************************************************************/

  /* elmx[cur][cp9->M] is either 0 (if EL_M exists (it would nec be in el_from_idx[cp9->M+1] array if it does, so
   * it would be filled with 0 in above loop), or -INFTY if it doesn't exist. We don't add possibility of EL_M -> EL_M
   * self loop b/c it's impossible to do that without emitting, and we've already seen our last res emitted.
   * either way we don't have to modify it */

  mmx[cur][cp9->M]  = ESL_MAX(elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M),/* M_M<-EL_M<-E, with 0 self loops in EL_M */
				  CP9TSC(cp9O_ME,cp9->M));                              /* M_M<-E ... everything ends in E (the 0; 2^0=1.0) */
  mmx[cur][cp9->M] += cp9->msc[dsq[i]][cp9->M];  /* ... + emitted match symbol */
  imx[cur][cp9->M]  = CP9TSC(cp9O_IM,cp9->M);    /* I_M<-E ... everything ends in E (the 0; 2^0=1.0) */
  imx[cur][cp9->M] += cp9->isc[dsq[i]][cp9->M];  /* ... + emitted insert symbol */
  dmx[cur][cp9->M]  = CP9TSC(cp9O_DM,cp9->M);    /* D_M<-E */

  /*******************************************************************
   * No need to look at EL_k->M_M b/c elmx[cur] with cur == L means last emitted residue was L+1
   * and this is impossible if we've come from M_M (only would be valid if we were coming from
   * E which is handled above with the EL_k->E code).
   *******************************************************************/
  for (k = cp9->M-1; k >= 1; k--)
	{
	  mmx[cur][k]  = CP9TSC(cp9O_ME,k);  /*M_k<- E */
	  mmx[cur][k]  = ESL_MAX(mmx[cur][k], dmx[cur][k+1] + CP9TSC(cp9O_MD,k));
	  if(cp9->flags & CPLAN9_EL)
	mmx[cur][k]  = ESL_MAX(mmx[cur][k], elmx[cur][k] + CP9TSC(cp9O_MEL,k));
	  mmx[cur][k] += cp9->msc[dsq[i]][k];

	  /*******************************************************************
	   * No need to look at EL_k->M_M b/c elmx[cur] with cur == L means last emitted residue was L+1
	   * and this is impossible if we've come from M_M (only would be valid if we were coming from
	   * E which is handled above with the EL_k->E code).
	   *******************************************************************/
	  imx[cur][k]  = dmx[cur][k+1] + CP9TSC(cp9O_ID,k);
	  imx[cur][k] += cp9->isc[dsq[i]][k];

	  dmx[cur][k]  = dmx[cur][k+1] + CP9TSC(cp9O_DD,k);
	  /* elmx[cur][k] was set above, out of order */
	}

  /* remember M_0 is special, the B state, a non-emitter */
  mmx[cur][0]  = dmx[cur][1] + CP9TSC(cp9O_MD,0); /* M_0(B)->D_1, no seq emitted, all deletes */
  /* above line is diff from CPBackwardOLD() which has mmx[cur][0] = -INFTY; */
  imx[cur][0]  = dmx[cur][1] + CP9TSC(cp9O_ID,0);
  imx[cur][0] += cp9->isc[dsq[i]][0];

  dmx[cur][0]   = -INFTY; /*D_0 doesn't exist*/
  elmx[cur][0]  = -INFTY; /*EL_0 doesn't exist*/

  scA[ip] = mmx[cur][0]; /* all parses must start in M_0, the B state */
  fsc = Scorify(scA[ip]);
  /*printf("ip: %d i: %d fsc: %f i: %d\n", ip, i, fsc, scA[ip]);*/
  /* we can't have a hit starting here, b/c it would correspond to all deletes,
   * no seq emitted, so we skip the check for if(fsc > best_sc) */

  /*printf("scA[ip:%d]: %d\n", ip, scA[ip]);*/

  /*printf("mmx[ip:%d][%d]: %d cur: %d\n", L+1, 0, mmx[cur][0], cur);
	printf("imx[ip:%d][%d]: %d cur: %d\n", L+1, 0, imx[cur][0], cur);
	printf("dmx[ip:%d][%d]: %d cur: %d\n", L+1, 0, dmx[cur][0], cur);*/

  /*****************************************************************
   * The main loop: scan the sequence from position j0-1 to i0.
   *****************************************************************/
  /* Recursion */
  for (i = j0-1; i >= (i0-1); i--)
	{
	  ip = i-i0+1;		/* ip is relative index in dsq (0 to L-1) */
	  if(be_efficient) { cur = (j0-i) % 2;  prv = (j0-i+1) % 2; }
	  else             { cur = ip;          prv = ip+1;         }

	  /* init EL mx to -INFTY */
	  for (k = 1; k <= cp9->M; k++) elmx[cur][k] = -INFTY;
	  if(ip > 0) {
	/* elmx[cur][k] is possibly of coming from self (EL_k), we
	 * can't have come from END b/c we haven't emitted the last res of the seq yet.
	 */
	if((cp9->flags & CPLAN9_EL) && (cp9->has_el[cp9->M]))
	  elmx[cur][cp9->M] = elmx[cur][cp9->M] + cp9->el_selfsc;

	mmx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_MI,cp9->M);
	mmx[cur][cp9->M] += cp9->msc[dsq[i]][cp9->M];

	if((cp9->flags & CPLAN9_EL) && (cp9->has_el[cp9->M]))
	  mmx[cur][cp9->M] = ESL_MAX(mmx[cur][cp9->M],
					 elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M));

	imx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_II,cp9->M);
	imx[cur][cp9->M] += cp9->isc[dsq[i]][cp9->M];
	  }
	  else { /* ip == 0 */
	mmx[cur][cp9->M] = -INFTY;  /* need seq to get here */
	imx[cur][cp9->M] = -INFTY;  /* need seq to get here */
	elmx[cur][cp9->M]= -INFTY;  /* first emitted res can't be from an EL, need to see >= 1 matches */
	  }
	  dmx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_DI,cp9->M);

	  /*******************************************************************
	   * 1b Handle EL, looking at EL_k->M_M for all valid k.
	   * EL_k->M_M transition, which has no transition penalty */
	  if(cp9->flags & CPLAN9_EL)
	{
	  for(c = 0; c < cp9->el_from_ct[cp9->M]; c++) /* el_from_ct[cp9->M] holds # ELs that can go to M_M */
	    elmx[cur][cp9->el_from_idx[cp9->M][c]] = ESL_MAX(elmx[cur][cp9->el_from_idx[cp9->M][c]], mmx[prv][cp9->M]);
	}

	  /* A main difference between a Backward scanner and
	   * regular Backward: a scanner can end at the END
	   * state at any position, regular can only end at
	   * the final position j0. */
	  if(do_scan) {
	if(ip > 0) {
	  /*******************************************************************
	   * 2 Handle EL, looking at EL_k->E for all valid k.
	   * EL_k->M_M transition, which has no transition penalty */
	  if(cp9->flags & CPLAN9_EL) {
	    for(c = 0; c < cp9->el_from_ct[cp9->M+1]; c++) /* el_from_ct[cp9->M] holds # ELs that can go to END */
	      elmx[cur][cp9->el_from_idx[cp9->M+1][c]] = 0.; /* EL<-E, penalty incurred when we enter EL (i.e. leave going backwards) */
	  }
	  /*******************************************************************/
	  /* elmx[cur][cp9->M] is either 0 (if EL_M exists (it would nec be in el_from_idx[cp9->M+1] array if it does, so
	   * it would be filled with 0 in above loop), or -INFTY if it doesn't exist. We don't add possibility of EL_M -> EL_M
	   * self loop b/c it's impossible to do that without emitting, and we've already seen our last res emitted,
	   * either way we don't have to modify it */

	  mmx[cur][cp9->M] = ESL_MAX(mmx[cur][cp9->M],
					 elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M) + cp9->msc[dsq[i]][cp9->M]); /* M_M<-EL_M<-E, with 0 selfs in EL_M */
	  mmx[cur][cp9->M] = ESL_MAX(mmx[cur][cp9->M],
					 CP9TSC(cp9O_ME,cp9->M) + cp9->msc[dsq[i]][cp9->M]); /* M_M<-E ... */
	  /* IMPT DIFFERENCE WITH cp9_Backward(): we need to add in contribution of emission within the ESL_MAX()s above
	   * here in Viterbi since we're doing a max, but in cp9_Backward we don't b/c we do a sum and don't want
	   * to double count that emission, since it was added once already above */

	  imx[cur][cp9->M] = ESL_MAX(imx[cur][cp9->M],
					 (CP9TSC(cp9O_IM,cp9->M) +            /* I_M<-E + (only in scanner)     */
					  0 +                                     /* all parses end in E, 2^0 = 1.0;*/
					  cp9->isc[dsq[i]][cp9->M]));     /* + emitted insert symbol        */
	  /* IMPT DIFFERENCE WITH cp9_Backward(): we need to add in contribution of emission within the ESL_MAX() above
	   * here in Viterbi since we're doing a max, but in cp9_Backward we don't b/c we do a sum and don't want
	   * to double count that emission, since it was added once already above */
	}
	dmx[cur][cp9->M] =  ESL_MAX(dmx[cur][cp9->M],
					(CP9TSC(cp9O_DM,cp9->M) +            /* D_M<-E + (only in scanner)     */
					 0));                                        /* all parses end in E, 2^0 = 1.0;*/
	  }
	  /*printf("mmx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, mmx[cur][cp9->M], cur);
	printf("imx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, imx[cur][cp9->M], cur);
	printf("dmx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, dmx[cur][cp9->M], cur);*/

	  for (k = cp9->M-1; k >= 1; k--) {
	if(ip > 0) {
	  /*******************************************************************
	   * 3 Handle EL, looking at EL_k->M_k for all valid k and EL_k->EL_k
	   * we're going backwards so we have to work out of order
	   * we could get around this by storing the nodes each EL goes TO
	   * in an el_to_ct[] vector. */
	  if(cp9->flags & CPLAN9_EL) {
	    for(c = 0; c < cp9->el_from_ct[k]; c++) /* el_from_ct[k] holds # ELs that can go to M_k */
	      elmx[cur][cp9->el_from_idx[k][c]] = ESL_MAX(elmx[cur][cp9->el_from_idx[k][c]], mmx[prv][k]);
	    /* EL<-M, penalty incurred when we enter EL (i.e. leave going backwards) */
	  }
	  /*******************************************************************/

	  /* Finish off elmx[cur][k] with possibility of coming from self (EL_k),
	   * elmx[cur][k] will have been filled by block above for ks > current k,
	   * no M_k -> EL_k' with k' > k */
	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[k]))
	    elmx[cur][k] = ESL_MAX(elmx[cur][k], elmx[prv][k] + cp9->el_selfsc);

	  mmx[cur][k]  = ESL_MAX(ESL_MAX((mmx[prv][k+1] + CP9TSC(cp9O_MM,k)),
					 (imx[prv][k]   + CP9TSC(cp9O_MI,k))),
				 (dmx[cur][k+1] + CP9TSC(cp9O_MD,k)));
	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[k]))
		mmx[cur][k] = ESL_MAX(mmx[cur][k], elmx[cur][k] + CP9TSC(cp9O_MEL,k)); /* penalty for entering EL */
	      mmx[cur][k] += cp9->msc[dsq[i]][k];

	      imx[cur][k]  = ESL_MAX(ESL_MAX((mmx[prv][k+1] + CP9TSC(cp9O_IM,k)),
					     (imx[prv][k]   + CP9TSC(cp9O_II,k))),
				     (dmx[cur][k+1] + CP9TSC(cp9O_ID,k)));
	      imx[cur][k] += cp9->isc[dsq[i]][k];

	}
	else { /* ip == 0 */
	  mmx[cur][k] = -INFTY; /* need seq to get here, unless we come from E in a scanner (below) */
	  imx[cur][k] = -INFTY; /* need seq to get here */
	  elmx[cur][k]= -INFTY;  /* first emitted res can't be from an EL, need to see >= 1 matches */
	}
	if(do_scan && ip > 0) { /* add possibility of ending at this position from this state */
	  mmx[cur][k] =
	    ESL_MAX(mmx[cur][k],
		    (CP9TSC(cp9O_ME,k) +                /* M_k<-E + (only in scanner)     */
		     0 +                                /* all parses end in E, 2^0 = 1.0;*/
		     cp9->msc[dsq[i]][k]));         /* emitted match symbol */
	  /* IMPT DIFFERENCE WITH cp9_Backward(): we need to add in contribution of emission within the ESL_MAX() above
	   * here in Viterbi since we're doing a max, but in cp9_Backward we don't b/c we do a sum and don't want
	   * to double count that emission, since it was added once already above */

	  /* No EL contribution here b/c we'd be looking for M_k<-EL_k<-E, but EL_k<-E is impossible
	   * for k != cp9->M; */
	}
	dmx[cur][k]  = ESL_MAX(ESL_MAX((mmx[prv][k+1] + CP9TSC(cp9O_DM,k)),
				       (imx[prv][k]   + CP9TSC(cp9O_DI,k))),
			       (dmx[cur][k+1] + CP9TSC(cp9O_DD,k)));
	  } /* end of for (k = cp9->M-1; k >= 1; k--) { */
	  /* Case when k == 0 */
	  /* imx[cur][0] is filled same as imx[cur][1..k] in the loop above */
	  if(ip > 0) {
	imx[cur][0] = ESL_MAX(ESL_MAX((mmx[prv][1] + CP9TSC(cp9O_IM,0)),
				      (imx[prv][0] + CP9TSC(cp9O_II,0))),
			      (dmx[cur][1] + CP9TSC(cp9O_ID,k)));
	imx[cur][0] += cp9->isc[dsq[i]][k];
	  }
	  else /* ip == 0 */
	imx[cur][0] = -INFTY; /* need seq to get here */
	  dmx[cur][0]   = -INFTY; /* D_0 does not exist */
	  elmx[cur][0]  = -INFTY; /* EL_0 does not exist */

	  /*M_0 is the B state, it doesn't emit, and can be reached from any match via a begin transition */
	  mmx[cur][0] = -INFTY;
	  for (k = cp9->M; k >= 1; k--) mmx[cur][0] = ESL_MAX(mmx[cur][0], (mmx[prv][k] + CP9TSC(cp9O_BM,k)));
	  mmx[cur][0] = ESL_MAX(mmx[cur][0], (imx[prv][0] + CP9TSC(cp9O_MI,0)));
	  mmx[cur][0] = ESL_MAX(mmx[cur][0], (dmx[cur][1] + CP9TSC(cp9O_MD,0)));     /* B->D_1 */
	  /* No EL contribution here, can't go B->EL_* */

	  /* determine isc, the int score of all possible parses starting at the current
	   * position (i) of the target sequence. */
	  scA[ip] = mmx[cur][0]; /* all parses must start in M_0, the B state */
	  fsc = Scorify(scA[ip]);

	  /* Update best_sc:
	   * There's a 'backwards-specific' off-by-one here, that only occurs b/c we're going backwards,
	   * this is probably implementation specific (meaning getting rid of it is possible, but
	   * I can't figure it out), but we deal with it (albeit confusingly) as follows:
	   *
	   * '*off-by-one*' marked comments below refers to this issue:
	   * All Backward hits are rooted in M_O, the B (begin) state, which is a non-emitter.
	   * let i = ip+i0-1 => ip = i-i0+1;
	   * so sc[ip] = backward->mmx[ip][0] = summed log prob of all parses that end at j0,
	   * and start at position i+1 of the sequence (because i+1 is the last residue
	   * whose emission has been accounted for).
	   */

	  if(fsc > best_sc) { best_sc = fsc; best_pos= i+1; } /* *off-by-one* */
	} /* end loop over start positions i */

  if(doing_align) { /* best_sc is the alignment score */
	best_sc  = Scorify(scA[(j0-i0+1)]); /* L = j0-i0+1 */
	best_pos = i0;
  }
  if(ret_sc != NULL)     *ret_sc     = best_sc;
  if(ret_maxres != NULL) *ret_maxres = best_pos;
  if(ret_psc != NULL)    *ret_psc    = scA;
  else                    free(scA);
  ESL_DPRINTF1(("cp9_ViterbiBackward() return score: %10.4f\n", best_sc));

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.");
}

/* Function: cp9_Forward()
 *
 * Purpose:  Runs the Forward dynamic programming algorithm on an
 *           input subsequence (i0-j0). Complements cp9_Backward().
 *           Somewhat flexible based on input options as follows:
 *
 *           if(be_efficient): only allocates 2 rows of the Forward
 *           matrix, else allocates full L+1 matrix.
 *
 *           if(do_scan): allows parses to start at any position i
 *           i0..j0, changing meaning of DP matrix cells as discussed
 *           below.
 *
 *           if(! do_scan): all parses must begin at i0.
 *
 *           Reference for algorithm (when do_scan is FALSE):
 *           Durbin et. al. Biological Sequence Analysis; p. 58.
 *
 *           The meaning of the Forward (F) matrix DP cells for
 *           matches (M) inserts (I) and deletes (D):
 *
 *           For relative subsequence positions ip = 0..L:
 *           For HMM nodes 1..M:
 *           F->M[ip][k] : sum of all parses emitting seq
 *                         from i0..ip that visit node k's match
 *                         state, which emits posn ip
 *           F->I[ip][k] : sum of all parses emitting seq from
 *                         i0..ip that visit node k's insert
 *                         state, which emits posn ip
 *           F->D[ip][k] : sum of all parses emitting seq from
 *                         i0..ip that visit node k's delete
 *                         delete state, last emitted (leftmost)
 *                         posn was ip
 *
 *           For *special* HMM node 0:
 *           F->M[ip][0] : M_0 is the Begin state, which does not
 *                         emit, so this is the sum of all parses
 *                         emitting seq from i0..ip that start
 *                         in the begin state, the last emitted
 *                         (leftmost) posn was ip.
 *
 *           Note: if ip=0, only D_k and M_0 states can have
 *                 non-IMPOSSIBLE values.
 *
 *           if(do_scan) the 'i0..ip' in the above definitions is
 *           changed to iE..ip such that i0 <= iE <= ip. Meaning
 *           any residue can be the first residue emitted in the
 *           parse. This means F->M[ip][0] is the sum of all parses
 *           emitting a subseq starting anywhere from i0..ip and
 *           ending at ip.
 *
 *
 * Args:
 *           cp9       - the cp9 HMM
 *           errbuf    - char buffer for error messages
 *           dsq       - sequence in digitized form
 *           i0        - start of target subsequence (1 for beginning of dsq)
 *           j0        - end of target subsequence (L for end of dsq)
 *           do_scan   - TRUE if we're scanning, HMM can start to emit anywhere i0..j0,
 *                       FALSE if we're not, HMM must start emitting at i0, end emitting at j0
 *           doing_align  - TRUE if reason we've called this function is to help get posteriors
 *                          for CM alignment, in which case we can skip the traceback.
 *           be_efficient- TRUE to keep only 2 rows of DP matrix in memory, FALSE keep whole thing
 *           ret_psc   - RETURN: int log odds Forward score for each end point [0..(j0-i0+1)]
 *           ret_maxres- RETURN: start position that gives maximum score max argmax_i sc[i]
 *           ret_sc    - RETURN: see below
 *
 * Returns:  <ret_sc>: if(!do_scan)     log P(S|M)/P(S|R), as a bit score
 *                     else         max log P(S|M)/P(S|R), for argmax subseq S of input seq i0..j0,
 *           eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
int
cp9_Forward(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int i0, int j0, int do_scan, int doing_align,
	    int be_efficient, int **ret_psc, int *ret_maxres, float *ret_sc)
{
  int          status;
  int          j;           /*     actual   position in the subsequence                     */
  int          jp;          /* j': relative position in the subsequence                     */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int          L;           /* j0-i0+1: subsequence length                                  */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int         *scA;         /* prob (seq from j0..jp | HMM) [0..jp..cp9->M]             */
  float        fsc;         /* float log odds score                                         */
  float        best_sc;     /* score of best hit overall                                    */
  float        best_pos;    /* residue (j) giving best_sc, where best hit ends              */
  int          nrows = 2;   /* number of rows for the dp matrix                             */
  int          c;           /* counter for EL states                                        */
  int          M;           /* cp9->M, query length, number of consensus nodes of model */

  /* Contract checks */
  if(cp9 == NULL)                  ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Forward, cp9 is NULL.\n");
  if(dsq == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Forward, dsq is NULL.");
  if(mx == NULL)                       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Forward, mx is NULL.\n");

  best_sc     = IMPOSSIBLE;
  best_pos    = -1;
  L = j0-i0+1;
  M = cp9->M;

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  /* Grow DP matrix if nec, to either 2 rows or L+1 rows (depending on be_efficient),
   * stays M+1 columns */
  if(be_efficient) nrows = 1; /* mx will be 2 rows */
  else             nrows = L; /* mx will be L+1 rows */
  if((status = GrowCP9Matrix(mx, errbuf, nrows, M, NULL, NULL, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_Forward(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));
  ESL_DPRINTF1(("cp9_Forward do_scan: %d\n", do_scan));

  /* scA will hold P(seq up to j | Model) in int log odds form */
  ESL_ALLOC(scA, sizeof(int) * (j0-i0+2));

  /* Initialization of the zero row. */
  mmx[0][0] = 0;      /* M_0 is state B, and everything starts in B */
  imx[0][0] = -INFTY; /* I_0 is state N, can't get here without emitting*/
  dmx[0][0] = -INFTY; /* D_0 doesn't exist. */
  elmx[0][0]= -INFTY; /* can't go from B to EL state */
  erow[0]   = -INFTY;

  /* Because there's a D state for every node 1..M,
	 dmx[0][k] is possible for all k 1..M */
  int sc;
  for (k = 1; k <= M; k++)
	{
	  mmx[0][k] = imx[0][k] = elmx[0][k] = -INFTY;      /* need seq to get here */
	  sc = ILogsum(ILogsum(mmx[0][k-1] + CP9TSC(cp9O_MD,k-1),
			   imx[0][k-1] + CP9TSC(cp9O_ID,k-1)),
		   dmx[0][k-1] + CP9TSC(cp9O_DD,k-1));
	  dmx[0][k] = sc;
	}
  /* We can do a full parse through all delete states. */
  erow[0]  = dmx[0][M] + CP9TSC(cp9O_DM,M);
  scA[0]   = erow[0];
  fsc      = Scorify(scA[0]);
  /*printf("jp: %d j: %d fsc: %f isc: %d\n", jp, j, fsc, isc[jp]);*/
  if(fsc > best_sc)
	{
	  best_sc = fsc;
	  best_pos= i0-1;
	}
  /*printf("jp: %d j: %d fsc: %f sc: %d\n", 0, i0-1, Scorify(sc[0]), sc[0]);*/

  /*****************************************************************
   * The main loop: scan the sequence from position i0 to j0.
   *****************************************************************/
  /* Recursion. */

  /* int ctr = 0; */
  for (j = i0; j <= j0; j++)
	{
	  int const *isc = cp9->isc[dsq[j]];
	  int const *msc = cp9->msc[dsq[j]];
	  int endsc     = -INFTY;
	  int el_selfsc = cp9->el_selfsc;
	  int sc;

	  jp = j-i0+1;     /* jp is relative position in the sequence 1..L */
	  cur = (j-i0+1);
	  prv = (j-i0);

	  if(be_efficient)
	{
	  cur %= 2;
	  prv %= 2;
	}

	  /* The 1 difference between a Viterbi scanner and the
	   * regular Viterbi. In non-scanner parse must begin in B at
	   * position 0 (i0-1), in scanner we can start at any position
	   * in the seq. */
	  mmx[cur][0]  = (do_scan == TRUE) ? 0 : -INFTY;
	  dmx[cur][0]  = -INFTY;  /*D_0 is non-existent*/
	  elmx[cur][0] = -INFTY;  /*no EL state for node 0 */

	  sc = ILogsum(ILogsum(mmx[prv][0] + CP9TSC(cp9O_MI,0),
			   imx[prv][0] + CP9TSC(cp9O_II,0)),
		   dmx[prv][0] + CP9TSC(cp9O_DI,0));
	  imx[cur][0] = sc + isc[0];

	  for (k = 1; k <= M; k++)
	{
	  /*match state*/
	  sc = ILogsum(ILogsum(mmx[prv][k-1] + CP9TSC(cp9O_MM,k-1),
			       imx[prv][k-1] + CP9TSC(cp9O_IM,k-1)),
		       ILogsum(dmx[prv][k-1] + CP9TSC(cp9O_DM,k-1),
			       mmx[prv][0]   + CP9TSC(cp9O_BM,k  )));
	  /* check possibility we came from an EL, if they're valid */
	  for(c = 0; c < cp9->el_from_ct[k]; c++) /* el_from_ct[k] is >= 0 */
	    sc = ILogsum(sc, elmx[prv][cp9->el_from_idx[k][c]]);
	    /* transition penalty to EL incurred when EL was entered */
	  mmx[cur][k] = sc + msc[k];

	  /* E state update */
	  endsc = ILogsum(endsc, mmx[cur][k] + CP9TSC(cp9O_ME,k));

	  /*insert state*/
	  sc = ILogsum(ILogsum(mmx[prv][k] + CP9TSC(cp9O_MI,k),
			       imx[prv][k] + CP9TSC(cp9O_II,k)),
		       dmx[prv][k] + CP9TSC(cp9O_DI,k));
	  imx[cur][k] = sc + isc[k];

	  /*delete state*/
	  sc = ILogsum(ILogsum(mmx[cur][k-1] + CP9TSC(cp9O_MD,k-1),
			       imx[cur][k-1] + CP9TSC(cp9O_ID,k-1)),
		       dmx[cur][k-1] + CP9TSC(cp9O_DD,k-1));
	  dmx[cur][k] = sc;

	  /*el state*/
	  sc = -INFTY;
	  if((cp9->flags & CPLAN9_EL) && cp9->has_el[k]) /* not all HMM nodes have an EL state (for ex:
								    HMM nodes that map to right half of a MATP_MP) */
	    {
	      sc = ILogsum(mmx[cur][k]  + CP9TSC(cp9O_MEL,k), /* transitioned from cur node's match state */
			   elmx[prv][k] + el_selfsc);      /* transitioned from cur node's EL state emitted ip on transition */
	    }
	  elmx[cur][k] = sc;
	  /*printf("mmx [jp:%d][%d]: %d\n", jp, k, mmx[cur][k]);
	    printf("imx [jp:%d][%d]: %d\n", jp, k, imx[cur][k]);
	    printf("dmx [jp:%d][%d]: %d\n", jp, k, dmx[cur][k]);
	    printf("elmx[jp:%d][%d]: %d\n", jp, k, elmx[cur][k]);*/
	}
	  endsc = ILogsum(ILogsum(endsc, dmx[cur][M] + CP9TSC(cp9O_DM,M)), /* transition from D_M -> end */
		      imx[cur][M] + CP9TSC(cp9O_IM,M)); /* transition from I_M -> end */
	  for(c = 0; c < cp9->el_from_ct[M+1]; c++) /* el_from_ct[k] is >= 0 */
	endsc = ILogsum(endsc, elmx[cur][cp9->el_from_idx[M+1][c]]);
	/* transition penalty to EL incurred when EL was entered */
	  /*printf("endsc: %d\n", endsc);*/

	  erow[cur] = endsc;
	  scA[jp]   = endsc;
	  fsc = Scorify(endsc);

	  if(fsc > best_sc) { best_sc = fsc; best_pos= j; }
	} /* end loop over end positions j */

  if(doing_align) { /* best_sc is the alignment score */
	best_sc  = Scorify(scA[(j0-i0+1)]); /* L = j0-i0+1 */
	best_pos = i0;
  }
  if(ret_sc != NULL)     *ret_sc     = best_sc;
  if(ret_maxres != NULL) *ret_maxres = best_pos;
  if(ret_psc != NULL)    *ret_psc    = scA;
  else                    free(scA);
  ESL_DPRINTF1(("cp9_Forward() return score: %10.4f\n", best_sc));

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.");
}

/* Function: cp9_Backward()
 *
 * Purpose:  Runs the Backward dynamic programming algorithm on an
 *           input subsequence (i0-j0). Complements CP9Forward().
 *           Somewhat flexible based on input options as follows:
 *
 *           if(be_efficient): only allocates 2 rows of the Backward
 *           matrix, else allocates full L+1 matrix.
 *
 *           if(do_scan): allows parses to end at
 *           at any position j in i0..j0, and start at any position
 *           i in i0..j0, changing meaning of DP matrix cells as
 *           discussed below.
 *
 *           if(! do_scan): all parses must end at j0
 *
 *           Reference for algorithm (when do_scan is FALSE):
 *           Durbin et. al. Biological Sequence Analysis; p. 59.
 *           With 1 IMPORTANT difference, emission scores for
 *           residue at posn j are part of the sum in DP cells
 *           for position j, but in Durbin, emission scores for
 *           residue at posn j+1 are part of the sum in DP cells
 *           for position j. The Durbin method makes it more
 *           straightforward to combine Backward and Forward
 *           cells to get posteriors, but it causes precision issues
 *           (overall Backward Score P(seq|X) != overall Forward Score
 *            P(seq|X) solely due to integer log odds scaling precision
 *            issues as investigated in
 *            ~nawrockie/notebook/7_0410_inf_hmmfb_hbanded_scan/00LOG)
 *           So I've resorted to the algorithm implemented here, the
 *           meaning of the Backward DP cells is given below. This
 *           implementation requires the subtraction of an emission
 *           score when combining corresponding Forward and Backward
 *           DP cells to get posteriors, b/c they've been double
 *           counted.
 *
 *           I've wasted a lot of time rewrapping my head around this
 *           function when I revisit it, so I'll be verbose about the
 *           the meaning of the Backward (B) matrix DP cells for
 *           matches (M) inserts (I) and deletes (D) here:
 *
 *           For relative subsequence positions jp = 0..L:
 *           For HMM nodes 1..M:
 *           B->M[jp][k] : sum of all parses emitting seq
 *                         from jp+1..j0 that visit node k's match
 *                         state, which emitted posn jp
 *           B->I[jp][k] : sum of all parses emitting seq from
 *                         jp+1..j0 that visit node k's insert
 *                         state, which emitted posn jp
 *           B->D[jp][k] : sum of all parses emitting seq from
 *                         jp+1..j0 that visit node k's delete
 *                         delete state, last emitted (rightmost)
 *                         posn was jp+1
 *           B->EL[jp][k]: sum of all parses emitting seq from
 *                         jp+1..j0 that visit node k's EL
 *                         state, which MAY OR MAY NOT have
 *                         emitted any posns >= jp+1, last
 *                         emitted (rightmost) posn was jp+1.
 *                         Some nodes k do not have an EL state
 *                         (if cp9->has_el[k] == FALSE)
 *                         NOTE: EL can act as non-emitter if 0
 *                         self loops taken or emitter if >= 1
 *                         self loops taken, this is why we
 *                         treat jp as having NOT YET BEEN EMITTED
 *                         which is different than the M and I
 *                         convention.
 *
 *           For *special* HMM node 0:
 *           B->M[jp][0] : M_0 is the Begin state, which does not
 *                         emit, so this is the sum of all parses
 *                         emitting seq from jp+1..j0 that start
 *                         in the begin state, the last emitted
 *                         (rightmost) posn was jp+1.
 *
 *           Note: if jp=0, only D and M_0 states can have
 *                 non-IMPOSSIBLE values.
 *
 *           if(do_scan) the 'jp+1..j0' in the above definitions is
 *           changed to jp+1..jE such that jp+1 <= jE <= j0. Meaning
 *           any residue can be the final residue emitted in the
 *           parse. This means B->M[jp][0] is the sum of all parses
 *           emitting a subseq ending anywhere from jp+1..j0 and
 *           starting at jp+1.
 *
 *           The *will emit* in the above definitions refers to
 *           the fact that emission scores from a state x are not
 *           counted in the matrix score for state x, and are only
 *           added when we calculate a matrix score for state y,
 *           after transitioning (backwards) from y to x. See
 *           code. This is done to facilitate combining Forward
 *           and Backward cells to get posterior probabilities
 *           in CP9Posterior().
 *
 * Args:
 *           cp9       - the CP9 HMM
 *           errbuf    - char buffer for error messages
 *           dsq       - sequence in digitized form
 *           i0        - start of target subsequence (1 for beginning of dsq)
 *           j0        - end of target subsequence (L for end of dsq)
 *           W         - the maximum size of a hit
 *           hit_len_guess - the presumed length of a hit, this is needed b/c we only
 *                           determine start points (i) in this function, but when we store 'hits'
 *                           we need a start point j, j=i+hit_len_guess-1.
 *                           This is only used if (! j_is_fixed).
 *           cutoff    - minimum score to report
 *           do_scan   - TRUE if we're scanning, HMM can start to emit anywhere i0..j0,
 *                       FALSE if we're not, HMM must start emitting at i0, end emitting at j0
 *           doing_align  - TRUE if reason we've called this function is to help get posteriors
 *                          for CM alignment, in which case we can skip the traceback.
 *           be_efficient- TRUE to keep only 2 rows of DP matrix in memory, FALSE keep whole thing
 *           do_null3  - TRUE to do NULL3 score correction, FALSE not to
 *           ret_psc   - RETURN: int log odds Backward score for each start point [0..(j0-i0+1)]
 *           ret_maxres- RETURN: start position that gives maximum score max argmax_i sc[i]
 *           ret_sc    - RETURN: see below
 *
 * Returns:  <ret_sc>: if(!do_scan)     log P(S|M)/P(S|R), as a bit score, this is B->M[0][0]
 *                     else         max log P(S|M)/P(S|R), for argmax subseq S of input seq i0..j0,
 *                                                         this is max_jp B->M[jp][0]
 *           eslOK on success;
 *           eslEINCOMPAT on contract violation;
 */
int
cp9_Backward(CP9_t *cp9, char *errbuf, CP9_MX *mx, ESL_DSQ *dsq, int i0, int j0, int do_scan, int doing_align,
	     int be_efficient, int **ret_psc, int *ret_maxres, float *ret_sc)
{
  int          status;
  int          i;           /* actual position in the subsequence                           */
  int          ip;          /* i': relative position in the subsequence                     */
  int          cur, prv;    /* rows in DP matrix 0 or 1                                     */
  int          k;           /* CP9 HMM node position                                        */
  int          L;           /* j0-i0+1: subsequence length                                  */
  int        **mmx;         /* DP matrix for match  state scores [0..1][0..cp9->M]      */
  int        **imx;         /* DP matrix for insert state scores [0..1][0..cp9->M]      */
  int        **dmx;         /* DP matrix for delete state scores [0..1][0..cp9->M]      */
  int        **elmx;        /* DP matrix for EL state scores [0..1][0..cp9->M]          */
  int         *erow;        /* end score for each position [0..1]                           */
  int         *scA;         /* prob (seq from j0..jp | HMM) [0..jp..cp9->M]             */
  float        fsc;         /* float log odds score                                         */
  float        best_sc;     /* score of best hit overall                                    */
  float        best_pos;    /* residue (i) giving best_sc, where best hit starts            */
  int          nrows;       /* num rows for DP matrix, 2 or L+1 depending on be_efficient   */
  int          c;           /* counter for EL states */
  int          M;           /* cp9->M */

  /* Contract checks */
  if(cp9 == NULL)                  ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Backward, cp9 is NULL.\n");
  if(dsq == NULL)                      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Backward, dsq is NULL.");
  if(mx == NULL)                       ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Backward, mx is NULL.\n");

  int const *tsc = cp9->otsc; /* ptr to efficiently ordered transition scores           */

  best_sc     = IMPOSSIBLE;
  best_pos    = -1;
  L = j0-i0+1;
  M = cp9->M;

  /* Grow DP matrix if nec, to either 2 rows or L+1 rows (depending on be_efficient),
   * stays M+1 columns */
  if(be_efficient) nrows = 1; /* mx will be 2 rows */
  else             nrows = L; /* mx will be L+1 rows */
  if((status = GrowCP9Matrix(mx, errbuf, nrows, M, NULL, NULL, &mmx, &imx, &dmx, &elmx, &erow)) != eslOK) return status;
  ESL_DPRINTF2(("cp9_Backward(): CP9 matrix size: %.8f Mb rows: %d.\n", mx->size_Mb, mx->rows));
  ESL_DPRINTF1(("cp9_Backward do_scan: %d\n", do_scan));

  /* scA will hold P(seq from i..j0 | Model) for each i in int log odds form */
  ESL_ALLOC(scA, sizeof(int) * (j0-i0+3));

  /* Initialization of the L (i = j0, cur = (j0-i) = (j0-j0) %2 = 0) row. */
  if(be_efficient) cur = 0;
  else cur = j0-i0+1; /* L */
  ip = j0-i0+1;  /*L */
  i  = j0;

  /*******************************************************************
   * 0 Handle EL, looking at EL_k->E for all valid k.
   * we're going backwards so we have to work out of order, we could get
   * around this by storing the nodes each EL goes TO in an el_to_ct[] vec. */
  /* init to -INFTY */
  for (k = 1; k <= cp9->M; k++)
	elmx[cur][k] = -INFTY;
  if(cp9->flags & CPLAN9_EL)
	{
	  for(c = 0; c < cp9->el_from_ct[cp9->M+1]; c++) /* el_from_ct[cp9->M+1] holds # ELs that can go to END */
	elmx[cur][cp9->el_from_idx[cp9->M+1][c]] = 0.; /* EL<-E, penalty incurred when we enter EL (i.e. leave going backwards) */
	}
  /*******************************************************************/

  /* elmx[cur][cp9->M] is either 0 (if EL_M exists (it would nec be in el_from_idx[cp9->M+1] array if it does, so
   * it would be filled with 0 in above loop), or -INFTY if it doesn't exist. We don't add possibility of EL_M -> EL_M
   * self loop b/c it's impossible to do that without emitting, and we've already seen our last res emitted.
   * either way we don't have to modify it */

  mmx[cur][cp9->M]  = 0. +
	ILogsum(elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M),/* M_M<-EL_M<-E, with 0 self loops in EL_M */
	    CP9TSC(cp9O_ME,cp9->M));                             /* M_M<-E ... everything ends in E (the 0; 2^0=1.0) */
  mmx[cur][cp9->M] += cp9->msc[dsq[i]][cp9->M];  /* ... + emitted match symbol */
  imx[cur][cp9->M]  = 0. + CP9TSC(cp9O_IM,cp9->M);     /* I_M<-E ... everything ends in E (the 0; 2^0=1.0) */
  imx[cur][cp9->M] += cp9->isc[dsq[i]][cp9->M];  /* ... + emitted insert symbol */
  dmx[cur][cp9->M]  = CP9TSC(cp9O_DM,cp9->M);          /* D_M<-E */

  /*******************************************************************
   * No need to look at EL_k->M_M b/c elmx[cur] with cur == L means last emitted residue was L+1
   * and this is impossible if we've come from M_M (only would be valid if we were coming from
   * E which is handled above with the EL_k->E code).
   *******************************************************************/

  for (k = cp9->M-1; k >= 1; k--)
	{
	  mmx[cur][k]  = 0 + CP9TSC(cp9O_ME,k);  /*M_k<- E */
	  mmx[cur][k]  = ILogsum(mmx[cur][k], dmx[cur][k+1] + CP9TSC(cp9O_MD,k));
	  if(cp9->flags & CPLAN9_EL)
	mmx[cur][k]  = ILogsum(mmx[cur][k], elmx[cur][k] + CP9TSC(cp9O_MEL,k));
	  mmx[cur][k] += cp9->msc[dsq[i]][k];

	  /*******************************************************************
	   * No need to look at EL_k->M_M b/c elmx[cur] with cur == L means last emitted residue was L+1
	   * and this is impossible if we've come from M_M (only would be valid if we were coming from
	   * E which is handled above with the EL_k->E code).
	   *******************************************************************/
	  imx[cur][k]  = dmx[cur][k+1] + CP9TSC(cp9O_ID,k);
	  imx[cur][k] += cp9->isc[dsq[i]][k];

	  dmx[cur][k]  = dmx[cur][k+1] + CP9TSC(cp9O_DD,k);
	  /* elmx[cur][k] was set above, out of order */
	}

  /* remember M_0 is special, the B state, a non-emitter */
  mmx[cur][0]  = dmx[cur][1] + CP9TSC(cp9O_MD,0); /* M_0(B)->D_1, no seq emitted, all deletes */
  /* above line is diff from CPBackwardOLD() which has mmx[cur][0] = -INFTY; */
  imx[cur][0]  = dmx[cur][1] + CP9TSC(cp9O_ID,0);
  imx[cur][0] += cp9->isc[dsq[i]][0];

  dmx[cur][0]   = -INFTY; /*D_0 doesn't exist*/
  elmx[cur][0]  = -INFTY; /*EL_0 doesn't exist*/

  scA[ip] = mmx[cur][0]; /* all parses must start in M_0, the B state */
  fsc = Scorify(scA[ip]);

  /*****************************************************************
   * The main loop: scan the sequence from position j0-1 to i0.
   *****************************************************************/
  /* Recursion */
  for (i = j0-1; i >= i0; i--)
	{
	  ip = i-i0+1;		/* ip is relative index in dsq (0 to L-1) */
	  if(be_efficient) { cur = (j0-i)  %2; prv = (j0-i+1)%2; }
	  else { cur = ip; prv = ip+1; }

	  /* init EL mx to -INFTY */
	  for (k = 0; k <= cp9->M; k++) elmx[cur][k] = -INFTY;

	  /* elmx[cur][k] is possibly of coming from self (EL_k), we
	   * can't have come from END b/c we haven't emitted the last res of the seq yet.
	   */
	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[cp9->M]))
	    elmx[cur][cp9->M] = elmx[cur][cp9->M] + cp9->el_selfsc;

	  mmx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_MI,cp9->M);
	  mmx[cur][cp9->M] += cp9->msc[dsq[i]][cp9->M];

	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[cp9->M]))
	mmx[cur][cp9->M] = ILogsum(mmx[cur][cp9->M],
				       elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M));

	  imx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_II,cp9->M);
	  imx[cur][cp9->M] += cp9->isc[dsq[i]][cp9->M];

	  dmx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_DI,cp9->M);

	  /*******************************************************************
	   * 1b Handle EL, looking at EL_k->M_M for all valid k.
	   * EL_k->M_M transition, which has no transition penalty */
	  if(cp9->flags & CPLAN9_EL)
	{
	  for(c = 0; c < cp9->el_from_ct[cp9->M]; c++) /* el_from_ct[cp9->M] holds # ELs that can go to M_M */
	    elmx[cur][cp9->el_from_idx[cp9->M][c]] = ILogsum(elmx[cur][cp9->el_from_idx[cp9->M][c]], mmx[prv][cp9->M]);
	}

	  /* A main difference between a Backward scanner and
	   * regular Backward: a scanner can end at the END
	   * state at any position, regular can only end at
	   * the final position j0. */
	  if(do_scan) {
	  /*******************************************************************
	   * 2 Handle EL, looking at EL_k->E for all valid k.
	   * EL_k->M_M transition, which has no transition penalty */
	  if(cp9->flags & CPLAN9_EL)
	    {
	      for(c = 0; c < cp9->el_from_ct[cp9->M+1]; c++) /* el_from_ct[cp9->M] holds # ELs that can go to END */
		elmx[cur][cp9->el_from_idx[cp9->M+1][c]] = 0.; /* EL<-E, penalty incurred when we enter EL (i.e. leave going backwards) */
	    }
	  /*******************************************************************/
	  /* elmx[cur][cp9->M] is either 0 (if EL_M exists (it would nec be in el_from_idx[cp9->M+1] array if it does, so
	   * it would be filled with 0 in above loop), or -INFTY if it doesn't exist. We don't add possibility of EL_M -> EL_M
	   * self loop b/c it's impossible to do that without emitting, and we've already seen our last res emitted,
	   * either way we don't have to modify it */

	  mmx[cur][cp9->M]  =
	    ILogsum(mmx[cur][cp9->M],
		    ILogsum(elmx[cur][cp9->M] + CP9TSC(cp9O_MEL,cp9->M),/* M_M<-EL_M<-E, with 0 selfs in EL_M */
			    CP9TSC(cp9O_ME,cp9->M)));                             /* M_M<-E ... */
	  /* DO NOT add contribution of emitting i from M, it's been added above */

	  imx[cur][cp9->M]  =
	    ILogsum(imx[cur][cp9->M],
		    (CP9TSC(cp9O_IM,cp9->M) +            /* I_M<-E + (only in scanner)     */
		     0));                                        /* all parses end in E, 2^0 = 1.0;*/
	  /* DO NOT add contribution of emitting i from M, it's been added above */
	  dmx[cur][cp9->M] =
	    ILogsum(dmx[cur][cp9->M],
		    (CP9TSC(cp9O_DM,cp9->M) +            /* D_M<-E + (only in scanner)     */
		     0));                                        /* all parses end in E, 2^0 = 1.0;*/
	}
	  /*printf("mmx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, mmx[cur][cp9->M], cur);
	printf("imx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, imx[cur][cp9->M], cur);
	printf("dmx[ip:%d][%d]: %d cur: %d\n", ip, cp9->M, dmx[cur][cp9->M], cur);*/

	  for (k = cp9->M-1; k >= 1; k--)
	{
	  /*******************************************************************
	   * 3 Handle EL, looking at EL_k->M_k for all valid k and EL_k->EL_k
	   * we're going backwards so we have to work out of order
	   * we could get around this by storing the nodes each EL goes TO
	   * in an el_to_ct[] vector. */
	  if(cp9->flags & CPLAN9_EL) {
	    for(c = 0; c < cp9->el_from_ct[k]; c++) /* el_from_ct[k] holds # ELs that can go to M_k */
	      elmx[cur][cp9->el_from_idx[k][c]] = ILogsum(elmx[cur][cp9->el_from_idx[k][c]], mmx[prv][k]);
	    /* EL<-M, penalty incurred when we enter EL (i.e. leave going backwards) */
	  }
	  /*******************************************************************/

	  /* Finish off elmx[cur][k] with possibility of coming from self (EL_k),
	   * elmx[cur][k] will have been filled by block above for ks > current k,
	   * no M_k -> EL_k' with k' > k */
	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[k]))
	    elmx[cur][k] = ILogsum(elmx[cur][k], elmx[prv][k] + cp9->el_selfsc);

	  mmx[cur][k]  = ILogsum(ILogsum((mmx[prv][k+1] + CP9TSC(cp9O_MM,k)),
					 (imx[prv][k]   + CP9TSC(cp9O_MI,k))),
				 (dmx[cur][k+1] + CP9TSC(cp9O_MD,k)));
	  if((cp9->flags & CPLAN9_EL) && (cp9->has_el[k]))
	    mmx[cur][k] = ILogsum(mmx[cur][k], elmx[cur][k] + CP9TSC(cp9O_MEL,k)); /* penalty for entering EL */
	  mmx[cur][k] += cp9->msc[dsq[i]][k];

	  imx[cur][k]  = ILogsum(ILogsum((mmx[prv][k+1] + CP9TSC(cp9O_IM,k)),
					 (imx[prv][k]   + CP9TSC(cp9O_II,k))),
				 (dmx[cur][k+1] + CP9TSC(cp9O_ID,k)));
	  imx[cur][k] += cp9->isc[dsq[i]][k];

	  if(do_scan) { /* add possibility of ending at this position from this state */
	    mmx[cur][k] =
	      ILogsum(mmx[cur][k],
		      (CP9TSC(cp9O_ME,k) +                  /* M_k<-E + (only in scanner)     */
		       0));                               /* all parses end in E, 2^0 = 1.0;*/
	    /* DO NOT add contribution of emitting i from M, it's been added above */
	    /* No EL contribution here b/c we'd be looking for M_k<-EL_k<-E, but EL_k<-E is impossible
	     * for k != cp9->M; */
	  }
	  dmx[cur][k]  = ILogsum(ILogsum((mmx[prv][k+1] + CP9TSC(cp9O_DM,k)),
					 (imx[prv][k]   + CP9TSC(cp9O_DI,k))),
				 (dmx[cur][k+1] + CP9TSC(cp9O_DD,k)));
	}
	  /* Case when k == 0 */
	  /* imx[cur][0] is filled same as imx[cur][1..k] in the loop above */
	  imx[cur][0] = ILogsum(ILogsum((mmx[prv][1] + CP9TSC(cp9O_IM,0)),
				    (imx[prv][0] + CP9TSC(cp9O_II,0))),
			    (dmx[cur][1] + CP9TSC(cp9O_ID,k)));
	  imx[cur][0] += cp9->isc[dsq[i]][k];
	  dmx[cur][0]   = -INFTY; /* D_0 does not exist */
	  elmx[cur][0]  = -INFTY; /* EL_0 does not exist */

	  /*M_0 is the B state, it doesn't emit, and can be reached from any match via a begin transition */
	  mmx[cur][0] = -INFTY;
	  for (k = cp9->M; k >= 1; k--)
	mmx[cur][0] = ILogsum(mmx[cur][0], (mmx[prv][k] + CP9TSC(cp9O_BM,k)));
	  mmx[cur][0] = ILogsum(mmx[cur][0], (imx[prv][0] + CP9TSC(cp9O_MI,0)));
	  mmx[cur][0] = ILogsum(mmx[cur][0], (dmx[cur][1] + CP9TSC(cp9O_MD,0)));     /* B->D_1 */
	  /* No EL contribution here, can't go B->EL_* */

	  /* determine isc, the int score of all possible parses starting at the current
	   * position (i) of the target sequence. */
	  scA[ip] = mmx[cur][0]; /* all parses must start in M_0, the B state */
	  fsc = Scorify(scA[ip]);

	  /* Update best_sc, the little semi-Markov model that deals with multihit parsing:
	   * There's a 'backwards-specific' off-by-one here, that only occurs b/c we're going backwards,
	   * this is probably implementation specific (meaning getting rid of it is possible, but
	   * I can't figure it out), but we deal with it (albeit confusingly) as follows:
	   *
	   * '*off-by-one*' marked comments below refers to this issue:
	   * All Backward hits are rooted in M_O, the B (begin) state, which is a non-emitter.
	   * let i = ip+i0-1 => ip = i-i0+1;
	   * so scA[ip] = backward->mmx[ip][0] = summed log prob of all parses that end at j0,
	   * and start at position i+1 of the sequence (because i+1 is the last residue
	   * whose emission has been accounted for).
	   */

	  if(fsc > best_sc) { best_sc = fsc; best_pos= i+1; } /* *off-by-one* */
	}
  /*******************************************************************/
  /* Special case: ip == 0, i = i0-1; */
  ip = i-i0+1;		/* ip is relative index in dsq (0 to L-1) */
  if(be_efficient) {
	cur = (j0-i)  %2;
	prv = (j0-i+1)%2;
  }
  else {
	cur = ip;
	prv = ip+1;
  }

  /* init EL mx to -INFTY */
  for (k = 1; k <= cp9->M; k++) elmx[cur][k] = -INFTY;

  mmx[cur][cp9->M] = -INFTY;  /* need seq to get here */
  imx[cur][cp9->M] = -INFTY;  /* need seq to get here */
  elmx[cur][cp9->M]= -INFTY;  /* first emitted res can't be from an EL, need to see >= 1 matches */
  dmx[cur][cp9->M]  = imx[prv][cp9->M] + CP9TSC(cp9O_DI,cp9->M);
  /* A main difference between a Backward scanner and
   * regular Backward: a scanner can end at the END
   * state at any position, regular can only end at
   * the final position j0. */
  if(do_scan)
	{
	  dmx[cur][cp9->M] =
	ILogsum(dmx[cur][cp9->M],
		(CP9TSC(cp9O_DM,cp9->M) +            /* D_M<-E + (only in scanner)     */
		 0));                                        /* all parses end in E, 2^0 = 1.0;*/
	}
  for (k = cp9->M-1; k >= 1; k--)
	{
	  mmx[cur][k] = -INFTY; /* need seq to get here, unless we come from E in a scanner (below) */
	  imx[cur][k] = -INFTY; /* need seq to get here */
	  elmx[cur][k]= -INFTY;  /* first emitted res can't be from an EL, need to see >= 1 matches */
	  dmx[cur][k]  = ILogsum(ILogsum((mmx[prv][k+1] + CP9TSC(cp9O_DM,k)),
				     (imx[prv][k]   + CP9TSC(cp9O_DI,k))),
			     (dmx[cur][k+1] + CP9TSC(cp9O_DD,k)));
	}

  /* Case when k == 0 */
  /* imx[cur][0] is filled same as imx[cur][1..k] in the loop above */
  imx[cur][0] = -INFTY; /* need seq to get here */
  dmx[cur][0]   = -INFTY; /* D_0 does not exist */
  elmx[cur][0]  = -INFTY; /* EL_0 does not exist */

  /*M_0 is the B state, it doesn't emit, and can be reached from any match via a begin transition */
  mmx[cur][0] = -INFTY;
  for (k = cp9->M; k >= 1; k--)
	mmx[cur][0] = ILogsum(mmx[cur][0], (mmx[prv][k] + CP9TSC(cp9O_BM,k)));
  mmx[cur][0] = ILogsum(mmx[cur][0], (imx[prv][0] + CP9TSC(cp9O_MI,0)));
  mmx[cur][0] = ILogsum(mmx[cur][0], (dmx[cur][1] + CP9TSC(cp9O_MD,0)));     /* B->D_1 */
  /* No EL contribution here, can't go B->EL_* */

  scA[ip] = mmx[cur][0]; /* all parses must start in M_0, the B state */
  fsc = Scorify(scA[ip]);

  /* Update best_sc for special case of ip == 0, '* off-by-one *' explained above still applies */
  if(fsc > best_sc) { best_sc = fsc; best_pos= i+1; } /* *off-by-one* */

  /* end of special case, ip == 0 */
  /**********************************************************************************/
  /* End of Backward recursion */

  if(doing_align) { /* best_sc is the alignment score */
	best_sc  = Scorify(scA[0]);
	best_pos = i0;
  }
  if(ret_sc != NULL)     *ret_sc     = best_sc;
  if(ret_maxres != NULL) *ret_maxres = best_pos;
  if(ret_psc != NULL)    *ret_psc    = scA;
  else                    free(scA);
  ESL_DPRINTF1(("cp9_Backward() return score: %10.4f\n", best_sc));

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "Memory allocation error.");
}

/* Function: cp9_CheckFB()
 *
 * Purpose:  Debugging function to make sure CP9Forward() and
 *           CP9Backward are working by checking:
 *           For all positions i, and states k:
 *             sum_k f[i][k] * b[i][k] = P(x|hmm)
 *
 * Args:     fmx    - forward dp matrix, already filled
 *           bmx    - backward dp matrix, already filled
 *           hmm    - the model
 *           sc     - P(x|hmm) the probability of the entire
 *                    seq given the model
 *           i0     - start of target subsequence (often 1, beginning of dsq)
 *           j0     - end of target subsequence (often L, end of dsq)
 *           dsq    - the digitized sequence
 *
 * Note about sequence position indexing: although this function
 * works on a subsequence from i0 to j0, fmx and bmx have offset indices,
 * from 1 to W, with W = j0-i0+1.
 *
 * Return:   eslOK on success;
 *           eslFAIL if any residue fails check
 */
int
cp9_CheckFB(CP9_MX *fmx, CP9_MX *bmx, CP9_t *hmm, char *errbuf, float sc, int i0, int j0, ESL_DSQ *dsq)
{
  if(fmx == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFB(), fmx is NULL.\n");
  if(bmx == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFB(), bmx is NULL.\n");
  if(dsq == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_CheckFB(), dsq is NULL.");

  int k, i;
  float max_diff;  /* maximum allowed difference between sc and
		    * sum_k f[i][k] * b[i][k] for any i */
  float diff;
  int fb_sum;
  float fb_sc;
  int   W;		/* subsequence length */
  int   ip;		/* i': relative position in the subsequence  */
  int to_add;

  W  = j0-i0+1;		/* the length of the subsequence */
  max_diff = 0.1;       /* tolerance, must be within .1 bits of original score */

  /* In all possible paths through the model, each residue of the sequence must have
   * been emitted by exactly 1 insert, match or EL state. */
  for (ip = 1; ip <= W; ip++) {
	i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	fb_sum = -INFTY;
	for (k = 0; k <= hmm->M; k++) {
	  if     (fmx->mmx[ip][k] == -INFTY) to_add = -INFTY;
	  else if(bmx->mmx[ip][k] == -INFTY) to_add = -INFTY;
	  else {
	to_add = fmx->mmx[ip][k] + bmx->mmx[ip][k];
	if(k > 0) to_add -= hmm->msc[dsq[i]][k];
	  }
	  /* hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx
	   * unless, we're talking about M_0, the B state, it doesn't emit */
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->mmx[ip:%d][k:%d]: %d\n", ip, k, fmx->mmx[ip][k]);
	printf("bmx->mmx[ip:%d][k:%d]: %d sum: %d\n", ip, k, (bmx->mmx[ip][k]-hmm->msc[dsq[i]][k]), fb_sum);
	  */
	  if     (fmx->imx[ip][k] == -INFTY) to_add = -INFTY;
	  else if(bmx->imx[ip][k] == -INFTY) to_add = -INFTY;
	  else  {
	to_add  = fmx->imx[ip][k] + bmx->imx[ip][k];
	to_add -= hmm->isc[dsq[i]][k];
	  }
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->imx[ip:%d][k:%d]: %d\n", ip, k, fmx->imx[ip][k]);
	printf("bmx->imx[ip:%d][k:%d]: %d sum: %d\n", ip, k, (bmx->imx[ip][k]-hmm->isc[dsq[i]][k]), fb_sum);
	  */
	  if     (fmx->elmx[ip][k] == -INFTY) to_add = -INFTY;
	  else if(bmx->elmx[ip][k] == -INFTY) to_add = -INFTY;
	  else  {
	to_add  = fmx->elmx[ip][k] + bmx->elmx[ip][k];
	/* EL emissions are by definition zero scoring */
	  }
	  fb_sum = ILogsum(fb_sum, to_add);

	  /*printf("fmx->elmx[ip:%d][k:%d]: %d\n", ip, k, fmx->elmx[ip][k]);
	printf("bmx->elmx[ip:%d][k:%d]: %d sum: %d\n", ip, k, bmx->elmx[ip][k], fb_sum);
	  */
	}
	fb_sc  = Scorify(fb_sum);
	diff = fabs(fb_sc - sc);
	if((fabs(diff) > max_diff))
	  ESL_FAIL(eslFAIL, errbuf, "cp9_CheckFB(), residue at posn i:%d violates sum_k f[i][k]*b[i][k]=P(x|hmm), sum_k = %.4f bits (should be %.4f)\n", i, fb_sc, sc);
  }
  ESL_DPRINTF1(("cp9_CheckFB() passed, Forward/Backward matrices pass check.\n"));
  return eslOK;
}

/*****************************************************************
 * Benchmark driver
 *****************************************************************/
#ifdef IMPL_CP9_DP_BENCHMARK
/* gcc -g -O2 -DHAVE_CONFIG_H -I../easel  -c old_cp9_dp.c
 * gcc -o benchmark-cp9_dp -g -O2 -I. -L. -I../easel -L../easel -DIMPL_CP9_DP_BENCHMARK cp9_dp.c old_cp9_dp.o -linfernal -leasel -lm
 * ./benchmark-cp9_dp <cmfile>
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",           0 },
  { "-r",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "set random number seed randomly",                0 },
  { "-s",        eslARG_INT,     "33", NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>",                  0 },
  { "-L",        eslARG_INT, "500000", NULL, "n>0", NULL,  NULL, NULL, "length of random target seqs",                   0 },
  { "-N",        eslARG_INT,      "1", NULL, "n>0", NULL,  NULL, NULL, "number of random target seqs",                   0 },
  { "-f",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute optimized Forward scan implementation",  0 },
  { "-o",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute old (version 0.8) Forward scan implementation", 0},
  { "-w",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute slow Viterbi scan implementation",  0 },
  { "-z",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute slow Viterbi backward scan implementation",  0 },
  { "-g",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "configure HMM for glocal alignment [default: local]", 0 },
  { "-a",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "do alignment, don't scan", 0 },
  { "--noel",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "turn local ends off [default: on, unless -g]", 0 },
  { "--full",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "calculate full matrix, not just 2 rows",         0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile>";
static char banner[] = "benchmark driver for the fast scanning CM plan 9 HMM Viterbi implementation";

int
main(int argc, char **argv)
{
  int             status;
  ESL_GETOPTS    *go      = esl_getopts_CreateDefaultApp(options, 1, argc, argv, banner, usage);
  CM_t            *cm;
  ESL_STOPWATCH  *w       = esl_stopwatch_Create();
  ESL_RANDOMNESS *r       = NULL;
  ESL_ALPHABET   *abc     = NULL;
  int             L       = esl_opt_GetInteger(go, "-L");
  int             N       = esl_opt_GetInteger(go, "-N");
  ESL_DSQ        *dsq     = malloc(sizeof(ESL_DSQ) * (L+2));
  int             i;
  float           sc;
  char            *cmfile = esl_opt_GetArg(go, 1);
  CMFILE          *cmfp;	/* open input CM file stream */
  int             do_scan;
  int             do_align;
  int             minL = 0;
  int             be_safe;
  char            errbuf[eslERRBUFSIZE];

  if (esl_opt_GetBoolean(go, "-r"))  r = esl_randomness_CreateTimeseeded();
  else                               r = esl_randomness_Create(esl_opt_GetInteger(go, "-s"));

  if ((cmfp = CMFileOpen(cmfile, NULL)) == NULL) cm_Fail("Failed to open covariance model save file %s\n", cmfile);
  if (!(CMFileRead(cmfp, &abc, &cm)))            cm_Fail("Failed to read CM");
  CMFileClose(cmfp);

  if(! esl_opt_GetBoolean(go, "-g")) {
	cm->config_opts |= CM_CONFIG_LOCAL;
	cm->config_opts |= CM_CONFIG_HMMLOCAL;
  }
  if(! esl_opt_GetBoolean(go, "--noel")) {
	cm->config_opts |= CM_CONFIG_LOCAL;
	cm->config_opts |= CM_CONFIG_HMMEL;
  }
  ConfigCM(cm, TRUE); /* TRUE says: calculate W */
  init_ilogsum();

  if (esl_opt_GetBoolean(go, "-a"))  { do_scan = FALSE; do_align = TRUE;  }
  else                               { do_scan = TRUE;  do_align = FALSE; }

  for (i = 0; i < N; i++)
	{
	  esl_rsq_xfIID(r, cm->null, abc->K, L, dsq);

	  esl_stopwatch_Start(w);
	  if((status = cp9_Viterbi(cm->cp9, errbuf, cm->cp9_mx, dsq, 1, L,
			       do_scan,   /* are we scanning? */
			       do_align,  /* are we aligning? */
			       (! esl_opt_GetBoolean(go, "--full")),  /* memory efficient ? */
			       NULL,   /* don't want best score at each posn back */
			       NULL,   /* don't want the max scoring posn back */
			       NULL,   /* don't want traces back */
			       &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i+1), "cp9_Viterbi(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  if (esl_opt_GetBoolean(go, "-b"))
	{
	  esl_stopwatch_Start(w);
	  if((status = cp9_ViterbiBackward(cm->cp9, errbuf, cm->cp9_mx, dsq, 1, L,
					   do_scan,   /* are we scanning? */
					   do_align,  /* are we aligning? */
					   (! esl_opt_GetBoolean(go, "--full")),  /* memory efficient ? */
					   NULL,   /* don't want best score at each posn back */
					   NULL,   /* don't want the max scoring posn back */
					   NULL,   /* don't want traces back */
					   &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i+1), "cp9_ViterbiBackward(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}

	  if (esl_opt_GetBoolean(go, "-f"))
	{
	  esl_stopwatch_Start(w);
	  if((status = cp9_Forward(cm->cp9, errbuf, cm->cp9_mx, dsq, 1, L,
				   do_scan,   /* are we scanning? */
				   do_align,  /* are we aligning? */
				   (! esl_opt_GetBoolean(go, "--full")),  /* memory efficient ? */
				   NULL,   /* don't want best score at each posn back */
				   NULL,   /* don't want the max scoring posn back */
				   &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%4d %-30s %10.4f bits ", (i+1), "cp9_Forward(): ", sc);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");
	}
	}
  FreeCM(cm);
  free(dsq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_randomness_Destroy(r);
  esl_getopts_Destroy(go);
  return 0;
}
#endif /*IMPL_CP9_DP_BENCHMARK*/

/*****************************************************************
 * Debugging program
 *****************************************************************/
#ifdef DEBUG_CP9_DP
/* gcc -o debug-cp9_dp -g -O2 -I. -L. -I../easel -L../easel -I../hmmer/src -L../hmmer/src -DDEBUG_CP9_DP cp9_dp.c -linfernal -lhmmer -leasel -lm
 * ./debug-cp9_dp <cmfile> <fafile>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


static ESL_OPTIONS options[] = {
  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
  { "-h",        eslARG_NONE,    NULL, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",           0 },
  { "-r",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "set random number seed randomly",                0 },
  { "-s",        eslARG_INT,     "33", NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>",                  0 },
  { "-L",        eslARG_INT, "500000", NULL, "n>0", NULL,  NULL, NULL, "length of random target seqs",                   0 },
  { "-N",        eslARG_INT,      "1", NULL, "n>0", NULL,  NULL, NULL, "number of random target seqs",                   0 },
  { "-f",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "also execute optimized Forward scan implementation",  0 },
  { "-g",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "configure HMM for glocal alignment [default: local]", 0 },
  { "-a",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "do alignment, don't scan", 0 },
  { "--noel",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "turn local ends off [default: on, unless -g]", 0 },
  { "--full",    eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "calculate full matrix, not just 2 rows",         0 },
  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
static char usage[]  = "[-options] <cmfile>";
static char banner[] = "benchmark driver for the fast scanning CM plan 9 HMM Viterbi implementation";

int
main(int argc, char **argv)
{
  int             status;
  ESL_GETOPTS    *go      = esl_getopts_CreateDefaultApp(options, 2, argc, argv, banner, usage);
  CM_t            *cm;
  ESL_STOPWATCH  *w       = esl_stopwatch_Create();
  ESL_ALPHABET   *abc     = NULL;
  ESL_SQ         *sq      = NULL;
  float           sc;
  char            *cmfile  = esl_opt_GetArg(go, 1);
  char            *sqfile = esl_opt_GetArg(go, 2);
  CMFILE          *cmfp;	/* open input CM file stream */
  int             do_scan;
  int             do_align;
  char            errbuf[eslERRBUFSIZE];
  ESL_SQFILE     *sqfp;           /* open sequence input file stream */
  int             maxi, maxj, maxi2;

  /* open input sequence file */
  status = esl_sqfile_Open(sqfile, eslSQFILE_UNKNOWN, NULL, &sqfp);
  if (status == eslENOTFOUND)    ESL_FAIL(status, errbuf, "File %s doesn't exist or is not readable\n", sqfile);
  else if (status == eslEFORMAT) ESL_FAIL(status, errbuf, "Couldn't determine format of sequence file %s\n", sqfile);
  else if (status == eslEINVAL)  ESL_FAIL(status, errbuf, "Can’t autodetect stdin or .gz.");
  else if (status != eslOK)      ESL_FAIL(status, errbuf, "Sequence file open failed with error %d\n", status);

  if ((cmfp = CMFileOpen(cmfile, NULL)) == NULL)               cm_Fail("Failed to open covariance model save file %s\n", cmfile);
  if ((status = (CMFileRead(cmfp, NULL, &abc, &cm))) != eslOK) cm_Fail("Failed to read CM");
  CMFileClose(cmfp);
  esl_sqfile_SetDigital(sqfp, abc);

  if(! esl_opt_GetBoolean(go, "-g")) {
	cm->config_opts |= CM_CONFIG_LOCAL;
	cm->config_opts |= CM_CONFIG_HMMLOCAL;
	if(! esl_opt_GetBoolean(go, "--noel")) {
	  cm->config_opts |= CM_CONFIG_HMMEL;
	}
  }
  ConfigCM(cm, NULL, TRUE, NULL, NULL); /* TRUE says: calculate W */
  init_ilogsum();

  if (esl_opt_GetBoolean(go, "-a"))  { do_scan = FALSE; do_align = TRUE;  }
  else                               { do_scan = TRUE;  do_align = FALSE; }

  sq = esl_sq_CreateDigital(abc);
  while((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	  esl_stopwatch_Start(w);
	  if((status = cp9_Viterbi(cm->cp9, errbuf, cm->cp9_mx, sq->dsq, 1, sq->n, cm->W, cm->W, 0., NULL,
			       do_scan,   /* are we scanning? */
			       do_align,  /* are we aligning? */
			       (! esl_opt_GetBoolean(go, "--full")),  /* memory efficient ? */
			       FALSE,  /* don't do NULL3 */
			       NULL,   /* don't want best score at each posn back */
			       &maxj,  /* return the max scoring end posn */
			       NULL,   /* don't want traces back */
			       &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%-30s %10.4f bits endpoint: %4d", "cp9_Viterbi(): ", sc, maxj);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_stopwatch_Start(w);
	  if((status = cp9_ViterbiBackward(cm->cp9, errbuf, cm->cp9_mx, sq->dsq, 1,
				       (do_align) ? sq->n : maxj,
				       cm->W, cm->W, 0., NULL,
				       do_scan,   /* are we scanning? */
				       do_align,  /* are we aligning? */
				       (! esl_opt_GetBoolean(go, "--full")),  /* memory efficient ? */
				       FALSE,  /* don't do NULL3 */
				       NULL,   /* don't want best score at each posn back */
				       &maxi,  /* return the max scoring start posn */
				       NULL,   /* don't want traces back */
				       &sc)) != eslOK) cm_Fail(errbuf);
	  printf("%-30s %10.4f bits startpnt: %4d", "cp9_ViterbiBackward(): ", sc, maxi);
	  esl_stopwatch_Stop(w);
	  esl_stopwatch_Display(stdout, w, " CPU time: ");

	  esl_sq_Reuse(sq);

	  printf("\n");
  }
  FreeCM(cm);
  esl_sq_Destroy(sq);
  esl_alphabet_Destroy(abc);
  esl_stopwatch_Destroy(w);
  esl_getopts_Destroy(go);
  return 0;
}
#endif /*DEBUG_CP9_DP*/

/*** End of inlined file: cp9_dp.c ***/


/*** Start of inlined file: cp9_modelmaker.c ***/
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


static float      cm2hmm_emit_prob(CM_t *cm, CP9Map_t *cp9map, int x, int i, int k);
static void       cm2hmm_special_trans_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, double *psi, char ***tmap);
static void       cm2hmm_trans_probs_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, int k, double *psi, char ***tmap);
static void       hmm_add_single_trans_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, int a, int b, int k, int hmm_trans_idx, double *psi, char ***tmap);
static float      cm_sum_subpaths_cp9(CM_t *cm, CP9Map_t *cp9map, int start, int end, char ***tmap, int k, double *psi);
static int        check_psi_vs_phi_cp9(CM_t *cm, char *errbuf, CP9Map_t *cp9map, double *psi, double **phi, double threshold, int debug_level);
static int        CP9_node_chi_squared(CP9_t *ahmm, CP9_t *shmm, int nd, float threshold, int print_flag);
static int        check_cm_adj_bp(CM_t *cm, CP9Map_t *cp9map);
static float      FChiSquareFit(float *f1, float *f2, int N);

/* EPN 10.26.06
 * Function: AllocCP9Map()
 *
 * Purpose:  Allocate a CP9Map_t object that stores information mapping
 *           a CP9 HMM to a CM and vice versa. See infernal.h for
 *           description.
 *
 * Args:
 * int hmm_M;   - number of CP9 HMM nodes, the consensus length
 * int cm_M;    - number of states in the CM
 * int cm_nodes - number of nodes in the CM
 * Returns: CMSubInfo_t
 */
CP9Map_t *
AllocCP9Map(CM_t *cm)
{
  int       status;
  CP9Map_t *cp9map;
  int v,ks,i;

  ESL_ALLOC(cp9map, sizeof(struct cp9map_s));

  /* Determine the consensus length (to be set as hmm_M) of the CM */
  cp9map->hmm_M = 0;
  for(v = 0; v <= cm->M; v++)
	{
	  if(cm->stid[v] ==  MATP_MP)
	cp9map->hmm_M += 2;
	  else if(cm->stid[v] == MATL_ML || cm->stid[v] == MATR_MR)
	cp9map->hmm_M++;
	}
  cp9map->cm_M     = cm->M;
  cp9map->cm_nodes = cm->nodes;

  /* Allocate and initialize arrays */
  ESL_ALLOC(cp9map->nd2lpos, sizeof(int)   * cp9map->cm_nodes);
  ESL_ALLOC(cp9map->nd2rpos, sizeof(int)   * cp9map->cm_nodes);
  for(i = 0; i < cp9map->cm_nodes; i++)
	cp9map->nd2lpos[i] = cp9map->nd2rpos[i] = -1;

  ESL_ALLOC(cp9map->pos2nd, sizeof(int)    * (cp9map->hmm_M+1));
  ESL_ALLOC(cp9map->hns2cs, sizeof(int **) * (cp9map->hmm_M+1));
  for(i = 0; i <= cp9map->hmm_M; i++)
	{
	  cp9map->pos2nd[i] = -1;
	  ESL_ALLOC(cp9map->hns2cs[i], sizeof(int *) * 3);
	  for(ks = 0; ks < 3; ks++)
	{
	  ESL_ALLOC(cp9map->hns2cs[i][ks], sizeof(int) * 2);
	  cp9map->hns2cs[i][ks][0] = cp9map->hns2cs[i][ks][1] = -1;
	}
	}

  ESL_ALLOC(cp9map->cs2hn, sizeof(int *)  * (cp9map->cm_M+1));
  ESL_ALLOC(cp9map->cs2hs, sizeof(int *)  * (cp9map->cm_M+1));
  for(v = 0; v <= cp9map->cm_M; v++)
	{
	  ESL_ALLOC(cp9map->cs2hn[v], sizeof(int) * 2);
	  ESL_ALLOC(cp9map->cs2hs[v], sizeof(int) * 2);
	  for(i = 0; i <= 1; i++)
	cp9map->cs2hn[v][i] = cp9map->cs2hs[v][i] = -1;
	}

  return cp9map;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function: SizeofCP9Map()
 * Incept:   EPN, Wed Jan 18 09:50:56 2012
 * Purpose:  Calculate and return the size of
 *           a CP9Map_t object in megabytes.
 */
float
SizeofCP9Map(CP9Map_t *cp9map)
{
  float bytes = 0.;

  bytes = sizeof(CP9Map_t);

  /* following from AllocCP9Map() */
  bytes += sizeof(int)    *  cp9map->cm_nodes; /* nd2lpos */
  bytes += sizeof(int)    *  cp9map->cm_nodes; /* nd2rpos */
  bytes += sizeof(int)    * (cp9map->hmm_M+1);  /* pos2nd */
  bytes += sizeof(int **) * (cp9map->hmm_M+1);  /* hns2cs */
  bytes += sizeof(int *)  * (cp9map->hmm_M+1) * 3;  /* hns2cs */
  bytes += sizeof(int)    * (cp9map->hmm_M+1) * 3 * 2;  /* hns2cs */
  bytes += sizeof(int *)  * (cp9map->cm_M+1);  /* cs2hn */
  bytes += sizeof(int *)  * (cp9map->cm_M+1);  /* cs2hs */
  bytes += sizeof(int *)  * (cp9map->cm_M+1) * 2;  /* cs2hs */
  bytes += sizeof(int *)  * (cp9map->cm_M+1) * 2;  /* cs2hn */

  return (bytes / 1000000.);
}

/* Function: FreeCP9Map()
 * Returns:  void
 */

void
FreeCP9Map(CP9Map_t *cp9map)
{
  int v,k,ks;
  for(v = 0; v <= cp9map->cm_M; v++)
	{
	  free(cp9map->cs2hn[v]);
	  free(cp9map->cs2hs[v]);
	}
  free(cp9map->cs2hn);
  free(cp9map->cs2hs);

  for(k = 0; k <= cp9map->hmm_M; k++)
  {
	for(ks = 0; ks < 3; ks++)
	  free(cp9map->hns2cs[k][ks]);
	free(cp9map->hns2cs[k]);
  }
  free(cp9map->hns2cs);

  free(cp9map->nd2lpos);
  free(cp9map->nd2rpos);
  free(cp9map->pos2nd);
  free(cp9map);
}

/**************************************************************************
 * EPN 03.12.06
 * Function: build_cp9_hmm()
 *
 * Purpose:  Given a CM, build a CM Plan 9 HMM that mirrors the CM as closely
 *           as possible. This HMM is a Weinberg/Ruzzo style ML HMM; i.e. if
 *           we sampled an 'infinite MSA' from the CM and built a ML HMM from it
 *           (using no pseudo-counts), it would be the same as the HMM we construct
 *           here.
 *
 * Args:
 * cm          - the CM
 * do_psi_test - TRUE to do a psi vs phi test, FALSE not to
 * thresh      - allowable difference in expected number of times mapping
 *               cm and hmm states are entered
 * debug_level - level for debugging print statements
 * ret_hmm     - RETURN: CM Plan 9 HMM
 * ret_cp9map  - RETURN: map from the CP9 HMM to the CM and vice versa
 *
 * Returns: eslOK if CP9 is constructed (and passes the psi vs phi test if <do_psi_test>)
 *          eslEINCOMPAT on contract violation, errbuf is filled
 *          eslFAIL if we get some error, errbuf is filled.
 */
int
build_cp9_hmm(CM_t *cm, char *errbuf, int do_psi_test, float thresh, int debug_level,
	      CP9_t **ret_hmm, CP9Map_t **ret_cp9map)
{
  int       status;
  int       k;                 /* counter of consensus columns (HMM nodes)*/
  int       i;
  double    *psi;              /* expected num times each state visited in CM */
  double   **phi;              /* expected num times each state visited in HMM*/
  char     ***tmap;
  int *ap;                     /* CM state(s) (1 or 2) that maps to HMM state in node k*/
  int k_state;                 /* 0, 1 or 2, state in hmm node k*/
  CP9Map_t *cp9map;
  CP9_t  *hmm;       /* CM plan 9 HMM we're going to construct from the sub_cm */

  /* Contract check, we can't be in local mode in the CM */
  if(cm->flags & CMH_LOCAL_BEGIN) ESL_FAIL(eslEINCOMPAT, errbuf, "build_cp9_hmm(): CMH_LOCAL_BEGIN flag is up.\n");
  if(cm->flags & CMH_LOCAL_END)   ESL_FAIL(eslEINCOMPAT, errbuf, "build_cp9_hmm(): CMH_LOCAL_END flag is up.\n");

  /* Allocate and initialize the cp9map */
  cp9map = AllocCP9Map(cm);
  /* Map the CM states to CP9 states and nodes and vice versa */
  CP9_map_cm2hmm(cm, cp9map, debug_level);

  hmm    = AllocCPlan9(cp9map->hmm_M, cm->abc);
  ZeroCPlan9(hmm);
  CPlan9SetNullModel(hmm, cm->null, 1.0); /* set p1 = 1.0 which corresponds to the CM */
  CPlan9InitEL(hmm, cm); /* set up hmm->el_from_ct and hmm->el_from_idx data, which
			  * explains how the EL states are connected in the HMM. */
  hmm->null2_omega = cm->null2_omega;
  hmm->null3_omega = cm->null3_omega;

  ESL_ALLOC(ap, sizeof(int) * 2);
  if(debug_level > 1)
	{
	  printf("-------------------------------------------------\n");
	  printf("In build_CP9_hmm()\n");
	}

  tmap = cm_CreateTransitionMap();
  psi  = cm_ExpectedStateOccupancy(cm);

  /* Special case 1st insert state maps to state 1 in the CM */
  for(i = 0; i < cm->abc->K; i++)
	{
	  hmm->ins[0][i] = cm->e[1][i];
	}
  for(k = 1; k <= hmm->M; k++)
	{
	  for(i = 0; i < cm->abc->K; i++)
	{
	  hmm->mat[k][i] = 0.0;
	  hmm->ins[k][i] = 0.0;
	}
	  /* First, take care of the match state. */
	  k_state = HMMMATCH;
	  ap[0] = cp9map->hns2cs[k][k_state][0];
	  ap[1] = cp9map->hns2cs[k][k_state][1];
	  /* ap[0] is a CM state that maps to HMM node k's match state */
	  /* ap[1] is potentially another CM state that maps to HMM node k's match state
		 (ex. if node k maps to the left half of a MATP node), and potentially = -1
		 if no other state maps to hmm node k's match state.*/
	  /* psi[ap[0]] is the expected number of times cm state ap[0] is entered. */
	  for(i = 0; i < cm->abc->K; i++)
	{
	  hmm->mat[k][i] += psi[ap[0]] *
	    cm2hmm_emit_prob(cm, cp9map, ap[0], i, k);
	  if(ap[1] != -1)
	    hmm->mat[k][i] += psi[ap[1]] *
	      cm2hmm_emit_prob(cm, cp9map, ap[1], i, k);
	}

	  /* Now, do the insert state. */
	  k_state = HMMINSERT;
	  ap[0] = cp9map->hns2cs[k][k_state][0];
	  ap[1] = cp9map->hns2cs[k][k_state][1];
	  /* ap[0] is the only CM state that maps to HMM node k's insert state */
	  /* ap[1] should be -1 unless k = hmm->M. */
	  /* psi[ap[0]] is the expected number of times cm state ap[0] is entered. */
	  for(i = 0; i < cm->abc->K; i++)
	{
	  hmm->ins[k][i] += psi[ap[0]] *
	    cm2hmm_emit_prob(cm, cp9map, ap[0], i, k);
	  if(ap[1] != -1)
	    hmm->ins[k][i] += psi[ap[1]] *
	      cm2hmm_emit_prob(cm, cp9map, ap[1], i, k);
	}
	}

  /* Done with emissions, fill in transitions of HMM (significantly more complex) */

  /* Step 1. Fill 'special' transitions, those INTO node 1, the N->N and N->M_1 transitions,
   * as well as transitions OUT of node M.
   */
  cm2hmm_special_trans_cp9(cm, hmm, cp9map, psi, tmap);

  for(k = 1; k < hmm->M; k++)
	{
	  cm2hmm_trans_probs_cp9(cm, hmm, cp9map, k, psi, tmap);
	}

  CPlan9Renormalize(hmm);

  if(debug_level > 1)
	debug_print_cp9_params(stdout, hmm, TRUE);
  if(do_psi_test) {
	/* Fill phi to check to make sure our HMM is "close enough" to our CM.
	 * phi[k][0..2] is the expected number of times HMM node k state 0 (match), 1(insert),
	 * or 2(delete) is entered. These should be *very close* (within 0.00001) to the psi
	 * values for the CM states that they map to (psi[v] is the expected number of times
	 * state v is entered in the CM).
	 */
	fill_phi_cp9(hmm, &phi, 1, FALSE);
	if((status = check_psi_vs_phi_cp9(cm, errbuf, cp9map, psi, phi, (double) thresh, debug_level)) != eslOK) return status;
	for(k = 0; k <= hmm->M; k++) free(phi[k]);
	free(phi);
  }

  free(ap);
  free(psi);
  cm_FreeTransitionMap(tmap);

  *ret_hmm    = hmm;
  *ret_cp9map = cp9map;
  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "memory allocation error");
  return 0; /* never reached */
}

/* Function to map an HMM to a CM:
 * CP9_map_cm2hmm()
 */

/**************************************************************************
 * EPN 03.15.06
 * Function: CP9_map_cm2hmm()
 *
 * Purpose:  Determine maps between a CM and an HMM by filling 3 multi-dimensional
 *           arrays. All arrays must be pre-allocated and freed by caller.
 * Args:
 * CM_t *cm          - the CM
 * CP9Map *cp9map    - map from the CM to the HMM and vice versa
 * int debug_level   - verbosity for debugging printf statements
 * Returns: (void)
 */
void
CP9_map_cm2hmm(CM_t *cm, CP9Map_t *cp9map, int debug_level)
{
  int k;       /* HMM node counter */
  int ks;      /* HMM state counter (0(Match) 1(insert) or 2(delete)*/
  int n;       /* CM node that maps to HMM node k */
  int nn;      /* CM node index */
  int n_begr;  /* CM node index */
  int is_left; /* TRUE if HMM node k maps to left half of CM node n */
  int is_right;/* TRUE if HMM node k maps to right half of CM node n */
  int v;       /* state index in CM */
  int v1, v2;
  CMEmitMap_t *emap;           /* consensus emit map for the CM */

  /* Map the nodes of each CM to consensus column indices and vice versa
   * Prior to 10.26.06 I had a function called map_consensus_columns which did
   * this, but it was replaced here by a CreateEmitMap() call, and a selective copying
   * of the emitmap data to get the cp9map->nd2lpos and cp9map->nd2rpos data.
   * When I implemented map_consensus_columns I was unaware CreateEmitMap() already
   * did what I needed. (EPN) */
  emap = CreateEmitMap(cm);

  /* We copy the emitmap lpos and rpos values, but only for MATP, MATL, MATR,
   * for any other node types cp9map->nd2lpos == cp9map->nd2rpos == -1 (this
   * arrays are initialized to all -1 in AllocCP9Map()).
   */
  for(n = 0; n < cm->nodes; n++)
	{
	  if(cm->ndtype[n] == MATP_nd ||
	 cm->ndtype[n] == MATL_nd)
	{
	  cp9map->nd2lpos[n] = emap->lpos[n];
	  cp9map->pos2nd[cp9map->nd2lpos[n]] = n;
	}
	  if(cm->ndtype[n] == MATP_nd ||
	 cm->ndtype[n] == MATR_nd)
	{
	  cp9map->nd2rpos[n] = emap->rpos[n];
	  cp9map->pos2nd[cp9map->nd2rpos[n]] = n;
	}
	}
  FreeEmitMap(emap);

  /* Handle special case, HMM node k = 0 first */
  /*ROOT_S*/
  k = 0;
  ks = 0;
  v = 0;
  map_helper(cm, cp9map, k, ks, v);

  /*ROOT_IL*/
  ks = 1;
  v = 1;
  map_helper(cm, cp9map, k, ks, v);

  /*handle ROOT_IR at end of function*/

  /* Step through HMM nodes, filling in maps as we go */
  for(k = 1; k <= cp9map->hmm_M; k++)
	{
	  n = cp9map->pos2nd[k];
	  if(cp9map->nd2lpos[n] == k)
	{
	  is_left = TRUE;
	  is_right = FALSE;
	}
	  else if(cp9map->nd2rpos[n] == k)
	{
	  is_left = FALSE;
	  is_right = TRUE;
	}
	  switch(cm->ndtype[n])
	{
	case ROOT_nd:
	case BIF_nd:
	case BEGL_nd:
	case BEGR_nd:
	case END_nd:
	  printf("ERROR: HMM node k doesn't map to MATP, MATR or MATL\n");
	  exit(1);
	  break;

	case MATP_nd:
	  if(is_left)
	    {
	      ks = 0; /*match*/
	      v = cm->nodemap[n]; /*MATP_MP*/
	      map_helper(cm, cp9map, k, ks, v);
	      v = cm->nodemap[n] + 1; /*MATP_ML*/
	      map_helper(cm, cp9map, k, ks, v);

	      ks = 1; /*insert*/
	      v = cm->nodemap[n] + 4; /*MATP_IL*/
	      map_helper(cm, cp9map, k, ks, v);

	      ks = 2; /*delete*/
	      v = cm->nodemap[n] + 2; /*MATP_MR*/
	      map_helper(cm, cp9map, k, ks, v);
	      v = cm->nodemap[n] + 3; /*MATP_D*/
	      map_helper(cm, cp9map, k, ks, v);
	    }
	  else if(is_right)
	    {
	      ks = 0; /*match*/
	      v = cm->nodemap[n]; /*MATP_MP*/
	      map_helper(cm, cp9map, k, ks, v);
	      v = cm->nodemap[n] + 2; /*MATP_MR*/
	      map_helper(cm, cp9map, k, ks, v);

	      ks = 1; /*insert*/
	      /* whoa... careful, we want the CM state that will insert to the RIGHT
	       * of column k (the right consensus column modelled by MATP node n),
	       * but MATP_IR inserts to the LEFT of column k.
	       * What we need to determine is the CM node nn that models column k+1,
	       * and further which half (left or right) of nn models k+1, then
	       * we can map the HMM state to the correct CM state (see code).
	       */
	      if(k != cp9map->hmm_M) /* Special case if HMM node k is the last node (consensus column)
				 dealt below*/
		{
		  nn = cp9map->pos2nd[k+1];
		  if(cp9map->nd2lpos[nn] == (k+1))
		    {
		      /* find the closest BEGR node above node nn */
		      n_begr = nn;
		      while(n_begr >= 0 && (cm->ndtype[n_begr] != BEGR_nd))
			n_begr--;
		      if(n_begr == -1)
			{
			  printf("ERROR: can't find BEGR node above node %d\n", nn);
			  printf("k is %d\n", k);
			  exit(1);
			}
		      v = cm->nodemap[n_begr] + 1; /*BEGR_IL*/
		      map_helper(cm, cp9map, k, ks, v);
		    }
		  else if(cp9map->nd2rpos[nn] == (k+1))
		    {
		      /*simple*/
		      if(cm->ndtype[nn] == MATP_nd)
			{
			  v = cm->nodemap[nn] + 5; /*MATP_IR*/
			  map_helper(cm, cp9map, k, ks, v);
			}
		      else if(cm->ndtype[nn] == MATR_nd)
			{
			  v = cm->nodemap[nn] + 2; /*MATR_IR*/
			  map_helper(cm, cp9map, k, ks, v);
			}
		    }
		} /* end of if (k != cp9map->hmm_M) */
	      else /* k == cp9map->hmm_M */
		{
		  v = 2; /*ROOT_IR*/
		  map_helper(cm, cp9map, k, ks, v);
		}
	      /* NOT DONE YET, the MATP_IR has to map to an HMM state,
	       * if the previous column (k-1) is modelled by a CM MATR or
	       * MATP node, then the above block will take care of this situation
	       * (in the previous iteration of this loop when k = k-1),
	       * HOWEVER, if (k-1) is modelled by a MATL, then this
	       * MATP_IR's contribution to the HMM will be ignored,
	       * unless we do something about it.
	       */
	      if(cp9map->nd2lpos[cp9map->pos2nd[k-1]] == (k-1)) /*k-1 modelled by MATL or MATP*/
		{
		  if(cm->ndtype[cp9map->pos2nd[k-1]] != MATL_nd)
		    {
		      if(cm->ndtype[cp9map->pos2nd[k-1]] == MATP_nd)
			{
			  /* A rare, but possible case. Previous column
			   * k-1 column is modelled by left half of the MATP
			   * node whose right half models column k.
			   * Proceed below.
			   */
			}
		      else
			{
			  printf("ERROR, full understanding of the CM architecture remains elusive (0)...\n");
			  exit(1);
			}
		    }
		  v = cm->nodemap[n] + 5; /*MATP_IR*/
		  map_helper(cm, cp9map, (k-1), ks, v);
		}

	      ks = 2; /*delete*/
	      v = cm->nodemap[n] + 1; /*MATP_ML*/
	      map_helper(cm, cp9map, k, ks, v);

	      v = cm->nodemap[n] + 3; /*MATP_D*/
	      map_helper(cm, cp9map, k, ks, v);
	    }
	  break;

	case MATL_nd:
	  ks = 0; /*match*/
	  v = cm->nodemap[n]; /*MATL_ML*/
	  map_helper(cm, cp9map, k, ks, v);

	  ks = 1; /*insert*/
	  v = cm->nodemap[n] + 2; /*MATL_IL*/
	  map_helper(cm, cp9map, k, ks, v);

	  ks = 2; /*delete*/
	  v = cm->nodemap[n] + 1; /*MATL_D*/
	  map_helper(cm, cp9map, k, ks, v);

	  if(k == cp9map->hmm_M) /* can't forget about ROOT_IR */
	    {
	      ks = 1; /*insert*/
	      v  = 2; /*ROOT_IR*/
	      map_helper(cm, cp9map, k, ks, v);
	    }

	  break;

	case MATR_nd:
	  ks = 0; /*match*/
	  v = cm->nodemap[n]; /*MATR_MR*/
	  map_helper(cm, cp9map, k, ks, v);

	  ks = 1; /*insert*/
	  /* whoa... careful, we want the CM state that will insert to the RIGHT
	   * of column k (the consensus column modelled by MATR node n),
	   * but MATR_IR inserts to the LEFT of column k.
	   * What we need to determine is the CM node nn that models column k+1,
	   * and further which half (left or right) of nn models k+1, then
	   * we can map the HMM state to the correct CM state (see code).
	   */
	  /* Special case if HMM node k is the last node (consensus column) */
	  if(k != cp9map->hmm_M) /* we deal with situation if k == hmm_M below */
	    {
	      nn = cp9map->pos2nd[k+1];
	      if(cp9map->nd2lpos[nn] == (k+1))
		{
		  /* find the closest BEGR node above node nn */
		  n_begr = nn;
		  while((cm->ndtype[n_begr] != BEGR_nd) && n_begr >= 0)
		    n_begr--;
		  if(n_begr == -1)
		    {
		      printf("ERROR: can't find BEGR node above node %d\n", nn);
		  exit(1);
		    }
		  v = cm->nodemap[n_begr] + 1; /*BEGR_IL*/
		  map_helper(cm, cp9map, k, ks, v);
		}
	      else if(cp9map->nd2rpos[nn] == (k+1))
		{
		  /*simple*/
		  if(cm->ndtype[nn] == MATP_nd)
		    {
		      v = cm->nodemap[nn] + 5;
		      map_helper(cm, cp9map, k, ks, v);
		    }
		  else if(cm->ndtype[nn] == MATR_nd)
		    {
		      v = cm->nodemap[nn] + 2; /*MATP_IR*/
		      map_helper(cm, cp9map, k, ks, v);
		    }
		}
	    } /* end of if (k != cp9map->hmm_M) */
	  else /* k == cp9map->hmm_M */
	    {
	      v = 2; /*ROOT_IR*/
	      map_helper(cm, cp9map, k, ks, v);
	    }
	  if(cp9map->nd2lpos[cp9map->pos2nd[k-1]] == (k-1)) /*k-1 modelled by MATL*/
	    {
	      printf("ERROR, full understanding of the CM architecture remains elusive (1)...\n");
	      exit(1);
	    }

	  ks = 2; /*delete*/
	  v = cm->nodemap[n] + 1; /*MATR_D*/
	  map_helper(cm, cp9map, k, ks, v);
	  break;
	}
	}

  /* Check to make sure that insert states map to exactly 1 HMM node state or 0 HMM states,
   * if it's an ambiguity issue. */
  for(v = 0; v <= cm->M; v++)
	{
	  if((cm->sttype[v] == IL_st || cm->sttype[v] == IR_st) &&
	 ((cp9map->cs2hn[v][0] == -1) || cp9map->cs2hn[v][1] != -1))
	{
	  if(cm->sttype[(v+1)] != E_st) /* v has been detached to remove ambiguities */
	    {
	      printf("ERROR during cp9map->cs2hn construction\ncp9map->cs2hn[%d][0]: %d | cp9map->cs2hn[%d][1]: %d AND v is an INSERT state\n", v, cp9map->cs2hn[v][0], v, cp9map->cs2hn[v][1]);
	      exit(1);
	    }
	}
	  /* each CM state should map to only 1 HMM state. */
	}

  /* print cp9map->hns2cs, checking consistency with cp9map->cs2hn and cp9map->cs2hs along
	 the way.  */
  for(k = 0; k <= cp9map->hmm_M; k++)
	{
	  for(ks = 0; ks < 3; ks++)
	{
	  v1 = cp9map->hns2cs[k][ks][0];
	  v2 = cp9map->hns2cs[k][ks][1];
	  if(ks == 1 && v2 != -1)
	    {
	      printf("ERROR in CP9_map_cm2hmm: HMM insert state of node: %d\n\tmaps to 2 CM states (%d and %d)\n", k, v1, v2);
	      exit(1);
	    }

	  if(debug_level > 1)
	    printf("hns2cs[%3d][%3d][0]: %3d | hns2cs[%3d][%3d[1]: %3d\n", k, ks, v1, k, ks, v2);
	  if(v1 != -1 && (cp9map->cs2hn[v1][0] == k && cp9map->cs2hs[v1][0] == ks))
	    {
	      /* okay */
	    }
	  else if(v1 != -1 && (cp9map->cs2hn[v1][1] == k && cp9map->cs2hs[v1][1] == ks))
	    {
	      /* okay */
	    }
	  else if(v2 != -1 && (cp9map->cs2hn[v2][0] == k && cp9map->cs2hs[v2][0] == ks))
	    {
	      /* okay */
	    }
	  else if(v2 != -1 && (cp9map->cs2hn[v2][1] == k && cp9map->cs2hs[v2][1] == ks))
	    {
	      /* okay */
	    }
	  else if(v1 == -1 && v2 == -1 && (k == 0 && ks == 2))
	    {
	      /*okay - D_0 maps to nothing */
	    }
	  else if(v1 == -1 && v2 == -1 && (k != 0 || ks != 2))
	    /* only cp9map->hns2cs[0][2] (D_0) should map to nothing*/
	    {
	      /* not okay */
	      printf("maps inconsistent case 1, HMM node state (non D_0) maps to no CM state, v1: %d | v2: %d k: %d | ks: %d\n", v1, v2, k, ks);
	      exit(1);
	    }
	  else
	    {
	      /* not okay */
	      printf("maps inconsistent case 2 v1: %d | v2: %d k: %d | ks: %d\n", v1, v2, k, ks);
	      exit(1);
	    }
	}
	}
  return;
}

/**************************************************************************
 * EPN 03.15.06
 * map_helper
 *
 * Helper function for map_cm2hmm_and_hmm2cm_cp9().
 * UPDATED 11.13.06: Checks for, and refrains from mapping a CM insert state
 *                   that has been detached (END_E-1 state) to remove ambiguities
 *                   from the model to an HMM state.
 *
 * Purpose:  Fill in specific parts of the maps, given k, ks, and v.
 * Args:
 * CM_t *cm           - the CM
 * CP9Map_t *cp9map   - the CM to CP9 map
 * int k              - the hmm node coordinate we're filling maps in for
 * int ks             - the hmm state (0,1,or 2) coordinate we're filling maps in for
 * int v              - the CM state coordinate we're filling maps in for
 * Returns: (void)
 */
void
map_helper(CM_t *cm, CP9Map_t *cp9map, int k, int ks, int v)
{
  if(ks == 1 && cm->sttype[(v+1)] == E_st) /* insert */
	{
	  return;
	}
  if(cp9map->cs2hn[v][0] == -1)
	{
	  cp9map->cs2hn[v][0] = k;
	  if(cp9map->cs2hs[v][0] != -1)
	cm_Fail("ERROR in map_helper, cp9map->cs2hn[%d][0] is -1 but cp9map->cs2hs[%d][0] is not, this shouldn't happen.\n", v, v);
	  cp9map->cs2hs[v][0] = ks;
	}
  else if (cp9map->cs2hn[v][1] == -1)
	{
	  cp9map->cs2hn[v][1] = k;
	  if(cp9map->cs2hs[v][1] != -1)
	cm_Fail("ERROR in map_helper, cp9map->cs2hn[%d][0] is -1 but cp9map->cs2hs[%d][0] is not, this shouldn't happen.\n", v, v);
	  cp9map->cs2hs[v][1] = ks;
	}
  else
	cm_Fail("ERROR in map_helper, cp9map->cs2hn[%d][1] is not -1, and we're trying to add to it, this shouldn't happen.\n", v);

  if(cp9map->hns2cs[k][ks][0] == -1)
	cp9map->hns2cs[k][ks][0] = v;
  else if(cp9map->hns2cs[k][ks][1] == -1)
	cp9map->hns2cs[k][ks][1] = v;
  else
	cm_Fail("ERROR in map_helper, cp9map->hns2cs[%d][%d][1] is not -1, and we're trying to add to it, this shouldn't happen.\n", k, ks);
  return;
}

/**************************************************************************
 * EPN 03.13.06
 * cm2hmm_emit_prob()
 *
 * Purpose:  For a specific CM state, determine the probability of emitting
 *           residue i of the 4-letter RNA alphabet {A,C,G,U}.
 *
 *
 * Args:
 * CM_t *cm          - the CM
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * int x             - the CM state
 * int i             - the residue index in A=0, C=1, G=2, U=3
 * int k             - HMM node CM state x maps to
 *
 * Returns: (float) probability of emitting letter i from correct half of CM state x.
 */
static float
cm2hmm_emit_prob(CM_t *cm, CP9Map_t *cp9map, int x, int i, int k)
{
  float ret_eprob;
  int   is_left;
  int   j;

  if(cp9map->nd2lpos[cp9map->pos2nd[k]] == k)
	is_left = TRUE;
  else
	is_left = FALSE;

  ret_eprob = 0.;

  /* trivial for non MATP_MP */
  if(cm->stid[x] != MATP_MP)
	ret_eprob = cm->e[x][i];

  else if(cm->stid[x] == MATP_MP)
	{
	  /* determine which of the 16 indices to use */
	  if(is_left)
	for(j = (i*cm->abc->K); j < ((i+1)*cm->abc->K); j++)
	  ret_eprob += cm->e[x][j];
	  else
	for(j = i; j < (cm->abc->K*cm->abc->K); j+=cm->abc->K)
	  ret_eprob += cm->e[x][j];
	}
  return ret_eprob;
}

/**************************************************************************
 * EPN 03.12.06
 * cm2hmm_special_trans_cp9
 *
 * Purpose:  Fill the special transition probabilities (those INTO HMM node 1
 *           and out of node M) for a CM plan 9 HMM given a CM.
 *
 * Args:
 * CM_t *cm          - the CM
 * cplan9_s *hmm     - the HMM
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * double *psi       - psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap;     - the hard-coded transition map
 *
 * Returns: (void)
 */
static void
cm2hmm_special_trans_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, double *psi,
			 char ***tmap)
{
  int  status;
  int *ap; /* CM states a' that map to HMM state a,
	      * ap[1] is -1 if only 1 CM state maps to a*/
  int *bp; /* CM states b' that map to HMM state b,
	      * bp[1] is -1 if only 1 CM state maps to b*/
  int k_state; /*either HMMMATCH, HMMINSERT, or HMMDELETE*/
  int k;      /* HMM node index */
  int hmm_trans_idx; /*0-8;  CTMM, CTMI, CTMD, CTIM, CTII, CTID, CTDM, CTDI, or CTDD*/
  float d;

  ESL_ALLOC(ap, sizeof (int) * 2);
  ESL_ALLOC(bp, sizeof (int) * 2);

  /* Fill all special transitions with virtual counts, later normalize these into
   * probabilities. CM p9 Special transitions are: transitions into HMM node 1, and
   * transitions out of HMM node hmm->M, and the N->N self transition.
   *
   * Strategy:
   *
   * for each HMM transition from special state B (M_0) (maps to CM's ROOT_S) and N (I_0)
   *       (maps to CM's ROOT_IL) to state b in HMM node 1:
   *     - determine CM state(s) b' (can be 1 or 2) that map to HMM state b.
   *       (we must be moving down the CM (i.e. state num (ROOT_S) = 0 and (ROOT_IL) = 1)
   *     - determine sum(B->b') or sum(N->b') the summed probability of all paths from state(s)
   *       B to b' or N to b'.
   *
   *       set virtual counts of transitions as follows:
   *       hmm->t[0][CTMI] (B->N)   = sum(over state(s) b' that map to N) psi[0] * ROOT_S -> b'
   *                                 (just ROOT_S->ROOT_IL)
   *       hmm->t[0][CTMD] (B->D_1) = sum(over state(s) b' that map to D_1) psi[0] * ROOT_S -> b'
   *       begin[1] (B->M_1) = sum(over state(s) b' that map to M_1) psi[0] * ROOT_S -> b'
   *       hmm->t[0][CTIM]   = sum(over state(s) b' that map to M_1) psi[1] * ROOT_IL -> b'
   *       hmm->t[0][CTII]   = sum(over state(s) b' that map to N)   psi[1] * ROOT_IL -> b'
   *                      (just ROOT_IL->ROOT_IL)
   *       hmm->t[0][CTID]   = sum(over state(s) b' that map to D_1) psi[1] * ROOT_IL -> b'
   *
   *       note: psi[0] = 1.0
   *
   * fill transitions out of node hmm->M.
   * for each HMM transition from state a in HMM node M to either state END_E or state b
   *       in node M:
   *     - determine CM state(s) a' and b' (can be 1 or 2 for each a' and b') that map
   *       to HMM states a and b respectively
   *
   *     - IF a' > b' (we're moving DOWN the CM)
   *       determine sum(a'->b') the summed probability of all paths from state(s)
   *       a' to b'.
   *
   *       set virtual counts of HMM transition a->b as
   *       sum(over states a' and b') psi[a'] * a' -> b'
   *
   *     - ELSE IF a' < b' (we're moving UP the CM)
   *       determine sum(b'->a') the summed probability of all paths from state(s)
   *       b' to a'
   *
   *       set virtual counts of HMM transition a->b as
   *       sum(over states a' and b') psi[b'] * b' -> a'
   *
   * Where psi[x] is the expected number of times CM state x is entered, as calc'ed
   * in cm_ExpectedStateOccapancy(). psi[0] = 1.0
   *
   */

  /* Set up the probability of transitioning into the first HMM node's states. */

  /* Transition 1 CTMM*/
  /* Special case, transition prob into M_1 from B is actually
   * hmm->begin[1]; first we calc what it should be, then
   * we switch hmm->t[0][CTMM] and hmm->begin[1].
   */
  k = 0;
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMMATCH;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*printf("0 CTMM: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, n, ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTMM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);
  /*hmm_set_single_trans_cp9(cm, hmm, cp9map, ap, bp, k, hmm_trans_idx, psi, tmap);*/
  /* switch 'em */
  hmm->begin[1] = hmm->t[0][CTMM];
  hmm->t[0][CTMM] = 0.;

  /* Transition 2: CTMI; B -> N
   */
  k = 0;
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  hmm_trans_idx = CTMI;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 3: CTMD; B -> D_1 */
  k = 0;
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMDELETE;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  hmm_trans_idx = CTMD;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 4: CTIM; N -> M_1*/
  k = 0;
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMMATCH;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  hmm_trans_idx = CTIM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 5: CTII; N -> N */
  k = 0;
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  hmm_trans_idx = CTII;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 6: CTID; N -> D_1 */
  k = 0;
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMDELETE;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  hmm_trans_idx = CTID;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transitions 7-9, CTDM, CTDI, CTDD, all 0.0, there's no D_0 state */
  hmm->t[0][CTDM] = 0.;
  hmm->t[0][CTDI] = 0.;
  hmm->t[0][CTDD] = 0.;

  /* Finally, normalize the transition probabilities
   * Not strictly necessary, a CPlan9Renormalize() call will do this*/

  d =esl_vec_FSum(hmm->begin+1, hmm->M) + hmm->t[0][CTMI] + hmm->t[0][CTMD];
  esl_vec_FScale(hmm->begin+1, hmm->M, 1./d);
  hmm->t[0][CTMI] /= d;
  hmm->t[0][CTMD] /= d;

  esl_vec_FNorm(hmm->t[0]+cp9_TRANS_INSERT_OFFSET, 3);	/* transitions out of insert for node 0 (state N)*/

  k = 0;
  /*
  printf("S hmm->t[%d][CTMM]: %f\n", k, hmm->t[k][CTMM]);
  printf("S hmm->begin[%3d]: %f\n", 1, hmm->begin[1]);
  printf("S hmm->t[%d][CTMI]: %f\n", k, hmm->t[k][CTMI]);
  printf("S hmm->t[%d][CTMD]: %f\n", k, hmm->t[k][CTMD]);
  printf("S hmm->t[%d][CTIM]: %f\n", k, hmm->t[k][CTIM]);
  printf("S hmm->t[%d][CTII]: %f\n", k, hmm->t[k][CTII]);
  printf("S hmm->t[%d][CTID]: %f\n", k, hmm->t[k][CTID]);
  printf("S hmm->t[%d][CTDM]: %f\n", k, hmm->t[k][CTDM]);
  printf("S hmm->t[%d][CTDI]: %f\n", k, hmm->t[k][CTDI]);
  printf("S hmm->t[%d][CTDD]: %f\n\n", k, hmm->t[k][CTDD]);
  printf("\n");
  */
  /*********************************************************************/
  /*********************************************************************/
  /* Now handle transitions OUT of HMM node M */
  /* Transition 1: CTMM; this is M_M -> E
   * a = node M, match state.
   * b = E state
   */
  k = hmm->M;
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  bp[0] = (cm->M) - 1;
  bp[1] = -1;
  hmm_trans_idx = CTMM;
  /* special case, this transition is hmm->end[hmm->M] NOT hmm->t[M][CTMM]. */
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);
  /* switch 'em */
  hmm->end[hmm->M] = hmm->t[hmm->M][CTMM];
  hmm->t[hmm->M][CTMM] = 0.;

  /* Transition 2: CTMI; this is M_M -> I_M
   * a = node M, match state
   * b = node M, insert state
   */
  k = hmm->M;
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*printf("CTMI: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTMI;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 3: CTMD, no corresponding transitiona
   * This is an illegal HMM transition.
   */
  hmm->t[hmm->M][CTMD] = 0.;

  /* Transition 4: CTIM; this is I_M -> E
   * a = node k, insert state.
   * b = E state
   */
  k = hmm->M;
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  bp[0] = (cm->M) - 1;
  bp[1] = -1;
  hmm_trans_idx = CTIM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 5: CTII; this is I_M -> I_M
   * a = node M, insert state.
   * b = node M, insert state.
   */
  k = hmm->M;
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*printf("CTII: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTII;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 6: CTID, no corresponding transition.
   * This is an illegal HMM transition.
   */
  hmm->t[hmm->M][CTID] = 0.;

  /* Transition 7: CTDM; this is D_M -> E
   * a = node M, delete state.
   * b = E state
   */
  k = hmm->M;
  k_state = HMMDELETE;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  bp[0] = (cm->M) - 1;
  bp[1] = -1;
  hmm_trans_idx = CTDM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 8: CTDI - this is D_M -> I_M
   * a = node M, delete state.
   * b = node M, insert state.
   */
  k = hmm->M;
  k_state = HMMDELETE;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*printf("CTDI: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTDI;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 9: CTDD, no corresponding transition.
   * This is an illegal HMM transition.
   */
  hmm->t[hmm->M][CTDD] = 0.;

  /* Finally, normalize the transition probabilities
   * Not strictly necessary, a CPlan9Renormalize() call will do this*/
  k = hmm->M;
  d =esl_vec_FSum(hmm->t[k], 4) + hmm->end[k];
  esl_vec_FScale(hmm->t[k], 4, 1./d);
  hmm->end[k] /= d;
  esl_vec_FNorm(hmm->t[k]+cp9_TRANS_INSERT_OFFSET, 3);
  esl_vec_FNorm(hmm->t[k]+cp9_TRANS_DELETE_OFFSET, 3);

  /*
  printf("S hmm->t[%d][CTMM]: %f\n", k, hmm->t[k][CTMM]);
  printf("S hmm->end[%3d]   : %f\n", k, hmm->end[k]);
  printf("S hmm->t[%d][CTMI]: %f\n", k, hmm->t[k][CTMI]);
  printf("S hmm->t[%d][CTMD]: %f\n", k, hmm->t[k][CTMD]);
  printf("S hmm->t[%d][CTIM]: %f\n", k, hmm->t[k][CTIM]);
  printf("S hmm->t[%d][CTII]: %f\n", k, hmm->t[k][CTII]);
  printf("S hmm->t[%d][CTID]: %f\n", k, hmm->t[k][CTID]);
  printf("S hmm->t[%d][CTDM]: %f\n", k, hmm->t[k][CTDM]);
  printf("S hmm->t[%d][CTDI]: %f\n", k, hmm->t[k][CTDI]);
  printf("S hmm->t[%d][CTDD]: %f\n\n", k, hmm->t[k][CTDD]);
  printf("\n");
  */

  free(ap);
  free(bp);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 03.12.06
 * cm2hmm_trans_probs_cp9()
 *
 * Purpose:  Fill transition "virtual counts" from HMM node k to
 *           the following HMM node (k+1) given a CM, then normalize to
 *           probabilities.
 *
 * Reference: Zasha Weinberg thesis p.123-124
 *
 * Args:
 * CM_t *cm          - the CM
 * cplan9_s *hmm     - the CM plan 9 HMM
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * int k             - the HMM node we're filling transitions for
 * double *psi       - psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap;     - the hard-coded transition map
 *
 * Returns: (void)
 */
static void
cm2hmm_trans_probs_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, int k, double *psi, char ***tmap)
{
  int status;
  int *ap; /* CM states a' that map to HMM state a,
	      * ap[1] is -1 if only 1 CM state maps to a*/
  int *bp; /* CM states b' that map to HMM state b,
	      * bp[1] is -1 if only 1 CM state maps to b*/

  int k_state; /*either HMMMATCH, HMMINSERT, or HMMDELETE*/

  int hmm_trans_idx; /*0-8;  CTMM, CTMI, CTMD, CTIM, CTII, CTID, CTDM, CTDI, or CTDD*/
  float d;

  /*printf("in cm2hmm_trans_probs_cp9: k: %d\n", k);*/

  ESL_ALLOC(ap, sizeof (int) * 2);
  ESL_ALLOC(bp, sizeof (int) * 2);

  /* Fill all 9 transitions with virtual counts, later normalize these into
   * probabilities.
   *
   * Strategy:
   *
   * for each HMM transition from state a in node k to state b in either node k or k+1:
   *     - determine CM state(s) a' and b' (can be 1 or 2 for each a' and b') that map
   *       to HMM states a and b respectively
   *
   *     - IF a' > b' (we're moving DOWN the CM)
   *       determine sum(a'->b') the summed probability of all paths from state(s)
   *       a' to b'.
   *
   *       set virtual counts of HMM transition a->b as
   *       sum(over states a' and b') psi[a'] * a' -> b'
   *
   *     - ELSE IF a' < b' (we're moving UP the CM)
   *       determine sum(b'->a') the summed probability of all paths from state(s)
   *       b' to a'
   *
   *       set virtual counts of HMM transition a->b as
   *       sum(over states a' and b') psi[b'] * b' -> a'
   *
   * Where psi[x] is the expected number of times CM state x is entered, as calc'ed
   * in cm_ExpectedStateOccupancy().
   *
   */

  /* Transition 1: CTMM
   * a = node k, match state.
   * b = node k+1, match state.
   */
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMMATCH;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  hmm_trans_idx = CTMM;
  /*////printf("CTMM: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);
  /*hmm_set_single_trans_cp9(cm, hmm, cp9map, ap, bp, k, hmm_trans_idx, psi, tmap);*/

  /* Transition 2: CTMI
   * a = node k, match state.
   * b = node k, insert state.
   */
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*////printf("CTMI: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTMI;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 3: CTMD
   * a = node k, match state.
   * b = node k+1, delete state.
   */
  k_state = HMMMATCH;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMDELETE;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*////printf("CTMD: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTMD;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 4: CTIM
   * a = node k, insert state.
   * b = node k+1, match state.
   */
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMMATCH;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*////printf("CTIM: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTIM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 5: CTII
   * a = node k, insert state.
   * b = node k, insert state.
   */
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*////printf("CTII: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/

  hmm_trans_idx = CTII;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 6: CTID - a CM plan 9 transition not in plan 7
   * a = node k, insert state.
   * b = node k+1, delete state.
   */
  k_state = HMMINSERT;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMDELETE;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*////printf("CTID: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTID;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 7: CTDM
   * a = node k, delete state.
   * b = node k+1, match state.
   */
  k_state = HMMDELETE;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMMATCH;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*////printf("CTDM: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTDM;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 8: CTDI - a CM plan 9 transition not in plan 9
   * a = node k, delete state.
   * b = node k, insert state.
   */
  k_state = HMMDELETE;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMINSERT;
  bp[0] = cp9map->hns2cs[k][k_state][0];
  bp[1] = cp9map->hns2cs[k][k_state][1];
  /*////printf("CTDI: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTDI;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Transition 9: CTDD
   * a = node k, delete state.
   * b = node k+1, delete state.
   */
  k_state = HMMDELETE;
  ap[0] = cp9map->hns2cs[k][k_state][0];
  ap[1] = cp9map->hns2cs[k][k_state][1];

  k_state = HMMDELETE;
  bp[0] = cp9map->hns2cs[k+1][k_state][0];
  bp[1] = cp9map->hns2cs[k+1][k_state][1];
  /*////printf("CTDD: k: %4d | n: %4d | ap[0]: %4d ap[1]: %4d | bp[0]: %4d bp[1]: %4d\n", k, cp9map->pos2nd[k], ap[0], ap[1], bp[0], bp[1]);*/
  hmm_trans_idx = CTDD;
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[0], bp[1], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[0], k, hmm_trans_idx, psi, tmap);
  hmm_add_single_trans_cp9(cm, hmm, cp9map, ap[1], bp[1], k, hmm_trans_idx, psi, tmap);

  /* Finally, normalize the transition probabilities
   * Not strictly necessary, a CPlan9Renormalize() call will do this*/
  d = esl_vec_FSum(hmm->t[k], 4) + hmm->end[k];
  esl_vec_FScale(hmm->t[k], 4, 1./d);
  hmm->end[k] /= d;

  esl_vec_FNorm(hmm->t[k]+cp9_TRANS_INSERT_OFFSET, 3);
  esl_vec_FNorm(hmm->t[k]+cp9_TRANS_DELETE_OFFSET, 3);
  /* print transition probs for HMM */
  /*
	printf("hmm->t[%d][CTMM]: %f\n", k, hmm->t[k][CTMM]);
	printf("hmm->t[%d][CTMI]: %f\n", k, hmm->t[k][CTMI]);
	printf("hmm->t[%d][CTMD]: %f\n", k, hmm->t[k][CTMD]);
	printf("hmm->t[%d][CTMEL]: %f\n", k, hmm->t[k][CTMD]);
	printf("hmm->t[%d][CTIM]: %f\n", k, hmm->t[k][CTIM]);
	printf("hmm->t[%d][CTII]: %f\n", k, hmm->t[k][CTII]);
	printf("hmm->t[%d][CTID]: %f\n", k, hmm->t[k][CTID]);
	printf("hmm->t[%d][CTDM]: %f\n", k, hmm->t[k][CTDM]);
	printf("hmm->t[%d][CTDI]: %f\n", k, hmm->t[k][CTDI]);
	printf("hmm->t[%d][CTDD]: %f\n\n", k, hmm->t[k][CTDD]);
	printf("\n");
  */
  free(ap);
  free(bp);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 03.14.06
 * fill_phi_cp9()
 *
 * Purpose:  Fill phi matrix for a CM plan 9 HMM.
 *           phi[k][v] is the expected number of times
 *           HMM node k's state v (either 0 (match), 1 (insert) or
 *           (2) delete) is entered in the HMM.
 *
 * Args:
 * cplan9_s *hmm      - the HMM
 * double **phi       - phi array, phi[k][v] is expected number of times
 *                      state v (0 = match, 1 insert, 2 = delete) in
 *                      node k is visited. Node 0 is special,
 *                      state 0 = B state, state 1 = N_state, state 2 = NULL
 * int spos           - the first original consensus column this CP9 HMM
 *                      models (only != 1 if we're building a CP9 for a sub CM).
 * int entered_only   - calculated expected number of times each state is
 *                      entered only, ignored insert->insert self transitions
 *
 * Notes:
 *                    - phi is allocated here, must be freed by caller.
 * Returns: ret_phi
 */
void
fill_phi_cp9(CP9_t *hmm, double ***ret_phi, int spos, int entered_only)
{
  int status;
  int k;
  double **phi;
  double  *phi_ins = NULL;

  ESL_ALLOC(phi, sizeof(double *) * (hmm->M+1));
  for(k = 0; k <= hmm->M; k++)
	ESL_ALLOC(phi[k], sizeof(double) * 3);

  if(entered_only) ESL_ALLOC(phi_ins, sizeof(double) * (hmm->M+1));

  /* Initialize phi values as all 0.0 */
  for (k = 0; k <= hmm->M; k++)
	phi[k][0] = phi[k][1] = phi[k][2] = 0.;

  /* the M_spos-1 is the B state, where all parses start */
  phi[spos-1][HMMMATCH]   = 1.0;
  phi[spos-1][HMMINSERT]  = phi[spos-1][HMMMATCH] * hmm->t[spos-1][CTMI];
  if(entered_only) phi_ins[spos-1] = phi[spos-1][HMMINSERT];
  phi[spos-1][HMMINSERT] += phi[spos-1][HMMINSERT] * (hmm->t[spos-1][CTII] /
						      (1. - hmm->t[spos-1][CTII]));
  phi[spos-1][HMMDELETE]  = 0.;

  /* Handle all other nodes (including M) */
  for (k = 1; k <= hmm->M; k++)
	{
	  if(k == (spos-1))
	continue;

	  /* match could've come from k-1 match, k-1 insert or k-1 delete */
	  phi[k][HMMMATCH] += phi[k-1][HMMMATCH] * hmm->t[k-1][CTMM];
	  phi[k][HMMMATCH] += phi[k-1][HMMDELETE] * hmm->t[k-1][CTDM];
	  phi[k][HMMMATCH] += phi[k-1][HMMINSERT] * hmm->t[k-1][CTIM];
	  phi[k][HMMMATCH] += hmm->begin[k];

	  /* again, we have to do deletes prior to inserts */
	  /* deletes could've come from k-1 match, k-1 delete, k-1 insert */
	  phi[k][HMMDELETE] += phi[k-1][HMMMATCH] * hmm->t[k-1][CTMD];
	  phi[k][HMMDELETE] += phi[k-1][HMMINSERT] * hmm->t[k-1][CTID];
	  phi[k][HMMDELETE] += phi[k-1][HMMDELETE] * hmm->t[k-1][CTDD];

	  /* inserts could've come from k match, k delete, or k insert */
	  phi[k][HMMINSERT] += phi[k][HMMMATCH] * hmm->t[k][CTMI];
	  phi[k][HMMINSERT] += phi[k][HMMDELETE] * hmm->t[k][CTDI];
	  /* self loops are special */
	  if(entered_only) phi_ins[k] = phi[k][HMMINSERT]; /* we'll copy it back at the end */
	  phi[k][HMMINSERT] += (phi[k][HMMINSERT] * (hmm->t[k][CTII] / (1-hmm->t[k][CTII])));

	  /*printf("phi[%d][HMMMATCH]: %f\n", k, phi[k][HMMMATCH]);
	printf("phi[%d][HMMINSERT]: %f\n", k, phi[k][HMMINSERT]);
	printf("phi[%d][HMMDELETE]: %f\n", k, phi[k][HMMDELETE]);
	  */
	}
  if(entered_only) { /* overwrite phi insert probabilities */
	for(k = 0; k <= hmm->M; k++) phi[k][HMMINSERT] = phi_ins[k];
	free(phi_ins);
  }
  *ret_phi = phi;
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/**************************************************************************
 * EPN 03.15.06
 * Function: hmm_add_single_trans_cp9()
 *
 * Purpose:  Add a virtual counts contribution to a single CM plan 9 HMM transition.
 *
 * Args:
 * CM_t *cm          - the CM
 * cplan9_s *hmm     - the HMM
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * int a             - a CM state that maps to HMM state we're transitioning out of
 * int b             - a CM state that maps to HMM state we're transitioning into
 * int k             - the HMM node we're setting a single transition for
 * int hmm_trans_idx - 0-8, the HMM transition index we're setting
 * double *psi       - psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * char ***tmap;      - the hard-coded transition map
 * Returns: (void)
 */
static void
hmm_add_single_trans_cp9(CM_t *cm, CP9_t *hmm, CP9Map_t *cp9map, int a, int b, int k, int hmm_trans_idx,
			double *psi, char ***tmap)
{
  /* check if we've got real CM state ids */
  /*
	printf("\t\tin hmm_add_single_trans_cp9, a: %d | b: %d | k: %d | hmm_trans_idx: %d\n", a, b, k, hmm_trans_idx);
	printf("\t\tbeg hmm_cm->t[%d][%d] : %.9f\n", k, hmm_trans_idx, hmm->t[k][hmm_trans_idx]);
  */
  if(a == -1 || b == -1)
	return;

  if(a <= b) /* going DOWN the CM */
	hmm->t[k][hmm_trans_idx] += psi[a] * cm_sum_subpaths_cp9(cm, cp9map, a, b, tmap, k, psi);
  else if (a > b) /* going UP the CM */
	hmm->t[k][hmm_trans_idx] += psi[b] * cm_sum_subpaths_cp9(cm, cp9map, b, a, tmap, k, psi);
  /*printf("\t\tend hmm_cm->t[%d][%d] : %.9f\n", k, hmm_trans_idx, hmm->t[k][hmm_trans_idx]);*/
}

/**************************************************************************
 * EPN 02.24.06
 * cm_sum_subpaths_cp9()
 *
 * Purpose:  Calculate probability of getting from one state (start) to
 *           another (end) in a CM, taking special considerations.
 *
 *           Sum the probability of all subpaths that start
 *           at "start" and end at "end" (ignoring "end"->"end" and
 *           "start" -> "start" transitions if they exist)
 *
 *           This function is used to help determine CM plan 9 HMM
 *           transition probabilities. If we're trying to set a particular
 *           transition (1 of 9) out of HMM node k, we ignore the contribution
 *           of subparses that correspond to other transitions out of node k.
 *           For example, we don't want to include the probability of an
 *           insert(node a) ->match (node a+1) sub parse when calculating
 *           the transition probability for match(node a) -> match (node a+1),
 *           (CTMM) because CTIM maps to that transition.
 *
 * Args:
 * CM_t *cm          - the CM
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * int start         - state index we're starting at
 * int end           - state index we're ending in
 * int ***tmap       - the hard-coded transition map
 * int k             - HMM node we're calc'ing transition (out of node k) for
 * double *psi       - psi[v] is the expected number of times state v is entered
 *                     in a CM parse
 * Returns: Float, the summed probability of all subpaths through the CM
 *          starting at "start" and ending at "end".
 */
static float
cm_sum_subpaths_cp9(CM_t *cm, CP9Map_t *cp9map, int start, int end, char ***tmap,
		    int k, double *psi)
{
  int status;
  int v; /* state index in CM */

  double *sub_psi; /*sub_psi[v] is the expected number of times state v is
		    * entered given we started at state "start", this is
		    * the summed probability of all paths starting at "start"
		    * and ending at v.
		    */
  float to_return;
  int y;
  int x;
  char tmap_val;
  int is_insert; /* 1 if v is insert, 0 if not */
  float insert_to_start; /* is start is not an insert and the insert state of
			  * HMM node k < start, this is the
			  * contribution of insert -> start (which should be ignored
			  * because the TMI and TDI transitions solely map to
			  * this transition probability.
			  */

  /*printf("\t\t\tin cm_sum_subpaths_cp9, start: %d | end: %d\n", start, end);*/
  if(start > end)
	{
	  printf("ERROR in cm_sum_subpaths_cp9: start: %d > end: %d\n", start, end);
	  exit(1);
	}
  if(start == end)
	{
	  if(cm->sttype[start] != IL_st && cm->sttype[start] != IR_st)
	{
	  /* This is possible, though unlikely. It only happens (I think and hope) if
	   * we've got two adjacent (k and k+1) columns modelled by the same MATP node n,
	   * so when setting a transition from node k ->  node k+1, we enter this function
	   * three times with start == end. Once with each MATP_MP, MATP_ML, MATP_MR, and MATP_D
	   * because these states map to the beginning and ending states of the M_k->M_k+1,
	   * M_k->D_k+1, D_k->M_k+1, and D_k->D_k+1 transitions respectively.
	   * The solution is to return 1.0,
	   * so the contribution is simply psi[MATP_M*] (in the function
	   * hmm_add_single_trans_cp9 that called this function).
	   */
	  if((cm->stid[start] != MATP_MP && cm->stid[start] != MATP_D) &&
	     (cm->stid[start] != MATP_ML && cm->stid[start] != MATP_MR))
	    {
	      printf("ERROR asking for self transition of non-insert, non-MATP state: %d\n", start);
	      exit(1);
	    }
	  return 1.0;
	}
	  /* else we just return the self-insert probability */
	  /*printf("\t\t\tReturning self insert prob: %f\n", cm->t[start][0]);*/
	  return cm->t[start][0];
	}
  to_return = 0.;

  ESL_ALLOC(sub_psi, sizeof(double) * (end - start + 1));
  /* Initialize sub_psi[0]. Need to check if we need to ignore the probability
   * mass from the CM insert state(s) that maps to the HMM insert state of this node
   * (these insert states are cp9map->hns2cs[k][1][0] and (potentially) cp9map->hns2cs[k][1][1])
   * that goes through "start" (which must map to either the M or
   * D state of this HMM node).
   */
  sub_psi[0] = 1.; /* have to start in "start" */

  if((cm->sttype[start] != IL_st && cm->sttype[start] != IR_st) &&
	 (cm->sttype[end] != IL_st && cm->sttype[end] != IR_st))
	{
	  insert_to_start = 0.;
	  if(cp9map->hns2cs[k][1][0] < start)
	insert_to_start = psi[cp9map->hns2cs[k][1][0]] * cm_sum_subpaths_cp9(cm, cp9map, cp9map->hns2cs[k][1][0], start, tmap, k, psi);
	  if((cp9map->hns2cs[k][1][1] != -1) && (cp9map->hns2cs[k][1][1] < start))
	insert_to_start += psi[cp9map->hns2cs[k][1][1]] * cm_sum_subpaths_cp9(cm, cp9map, cp9map->hns2cs[k][1][1], start, tmap, k, psi);
	  sub_psi[0] -= insert_to_start / psi[start];
	  /*printf("\t\tinsert_to_start: %f sub_psi[0]: %f\n", insert_to_start, sub_psi[0]);*/
	}
  /* note: when cm_sum_subpaths_cp9 is called recursively above
   * it will never result in another recursive call,
   * because its "start" is an insert state.
   */

  for (v = (start+1); v <= end; v++)
	{
	  /*printf("\t\t\tv: %d\n", v);*/
	  sub_psi[v-start] = 0.;
	  if(cm->sttype[v] == IL_st || cm->sttype[v] == IR_st)
	is_insert = 1;
	  else
	is_insert = 0;

	  if(cm->sttype[v] == S_st)
	{
	  /* previous state is necessarily either a BIF_B or a END_E, either
	   * way we handle as if the transition FROM previous state to this
	   * state is 1.0 */
	  sub_psi[v-start] = sub_psi[(v-1)-start] * 1.;
	}
	  /* check if v is an insert state that maps to node k, if so we don't want
	   * to double count its contribution (it will be counted in a subsequent cm_sum_subpaths_CP9()
	   * call), so we skip it here.
	   */
	  if((v != end && is_insert) && ((cp9map->cs2hn[v][0] == k) || cp9map->cs2hn[v][1] == k))
	{
	  /*skip the contribution*/
	  /*
	    printf("v: %d | skipping the contribution\n", v);
	    printf("\tcs2hn_map[%d][0] : %d\n", v, cs2hn_map[v][0]);
	    printf("\tcs2hn_map[%d][1] : %d\n", v, cs2hn_map[v][1]);
	    printf("\tcs2hn_map[start][0] : %d\n", v, cs2hn_map[start][0]);
	    printf("\tcs2hn_map[start][1] : %d\n", v, cs2hn_map[start][1]);
	  */
	}
	  else
	{
	  for (y = cm->pnum[v]-1; y >= is_insert; y--)
	    {
	      x = cm->plast[v] - y;
	      /* x is a parent of v, we're adding contribution
	       * of transition from x to v. */
	      tmap_val = tmap[(int) cm->stid[x]][(int) cm->ndtype[cm->ndidx[v]+is_insert]][(int) cm->stid[v]];
#if eslDEBUGLEVEL >= 1
	      if(tmap_val == -1)
		{
		  printf("tmap ERROR 1\n");
		  printf("v: %d | pnum[v]: %d | plast[v]: %d | y: %d | x: %d | d1: %d | d2: %d | d3: %d\n", v, cm->pnum[v], cm->plast[v], y, x, ((int) cm->stid[x]), ((int) (cm->ndtype[cm->ndidx[v]+is_insert])), ((int) cm->stid[v]));
		  exit(1);
		}
#endif
	      if((x - start) < 0)
		sub_psi[v-start] += 0.;
	      else
		sub_psi[v-start] += sub_psi[x-start] * cm->t[x][(int) tmap_val];
	    }
	  if(v != end && is_insert) /* we don't want to include the probability of an
				       insert self-loop to end itself */
	    {
	      sub_psi[v-start] += sub_psi[v-start] * (cm->t[v][0] / (1-cm->t[v][0]));
	      /*the contribution of the self insertion loops*/
	    }
	}
	}
  to_return = (float) sub_psi[end-start];
  free(sub_psi);
  return to_return;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/**************************************************************************
 * EPN 03.19.06
 * check_psi_vs_phi_cp9()
 *
 * Purpose:  Check that psi and phi values for CM states that map to HMM states
 *           are within a certain threshold. Assumes all HMM insert state maps
 *           to exactly 1 CM insert state - i.e. ambiguities have been removed.
 *           (As of version 0.71 ambiguities are always removed).
 * Args:
 * CM_t *cm          - the CM
 * errbuf            - for error messages.
 * CP9Map_t *cp9map  - the map from the CM to HMM and vice versa
 * double *psi       - psi[v] is expected number of times CM state v is entered
 * double **phi      - phi array, phi[k][v] is expected number of times
 *                     HMM state v (0 = match, 1 insert, 2 = delete) in
 *                     node k is visited.
 * double threshold  - the threshold that mapping (potentially summed) psi and
 *                     phi values are allowed to be different by, without throwing an error.
 * int debug_level   - level for debugging print statements
 *
 * Returns: eslOK: if CM and HMM are "close enough" (see code)
 *          !eslOK: otherwise, errbuf is filled
 */
static int
check_psi_vs_phi_cp9(CM_t *cm, char *errbuf,CP9Map_t *cp9map, double *psi, double **phi, double threshold,
		     int debug_level)
{
  int status;
  int v; /* CM state index*/
  int k;
  int y;
  double summed_psi;
  int *ap; /*CM state that maps to HMM state in node k*/
  int k_state; /*0, 1 or 2, state in hmm node k*/
  int violation;
  int v_ct;
  double diff;
  int ret_val; /* return value */
  int adj_bp_flag; /* a special case in which we always return TRUE after printing a warning */

  if (cm->flags & CMH_LOCAL_BEGIN) ESL_FAIL(eslEINCOMPAT, errbuf, "internal error: we're in CM local mode while trying to build a CP9 HMM");

  adj_bp_flag = FALSE;
  if(check_cm_adj_bp(cm, cp9map))
	{
	  adj_bp_flag = TRUE;
	/* if check_cm_adj_bp() returns TRUE, then the following rare (but possible) situation
	 * is true: Two adjacent consensus columns are modelled by the same MATP node. In this
	 * case it is difficult for the CM plan 9 architecture to mirror the insert state
	 * that maps to both the MATP_IL and MATP_IR of this node. It is more difficult than
	 * for any other possible CM topology situation, so we relax the threshold when
	 * checking psi and phi.
	 */
	}
  ret_val = TRUE;
  v_ct = 0;
  ESL_ALLOC(ap, sizeof(int) * 2);

  for(v = 0; v < cm->M; v++)
	if(cm->stid[v] != BIF_B)
	  {
	for(y = 0; y < cm->cnum[v]; y++)
	  if(debug_level > 1) printf("cm->t[%d][%d]: %f\n", v, y, cm->t[v][y]);
	if(debug_level > 1) printf("\n");
	  }

  for (k = 0; k <= cp9map->hmm_M; k++)
	{
	  k_state = HMMMATCH;
	  ap[0] = cp9map->hns2cs[k][k_state][0];
	  ap[1] = cp9map->hns2cs[k][k_state][1];
	  summed_psi = psi[ap[0]];
	  if(ap[1] != -1)
	summed_psi += psi[ap[1]];
	  violation = FALSE;
	  diff = phi[k][0] - summed_psi;
	  if((diff > threshold) || ((-1. * diff) > threshold))
	{
	  violation = TRUE;
	  v_ct++;
	}
	  if(violation)
	printf("M k: %4d | phi: %f | psi: %f VIOLATION (%f) (cm v1: %d cm v2: %d)\n", k, phi[k][0], summed_psi, diff, ap[0], ap[1]);
	  else if(debug_level > 1)
	printf("M k: %4d | phi: %f | psi: %f\n", k, phi[k][0], summed_psi);

	  k_state = HMMINSERT;
	  ap[0] = cp9map->hns2cs[k][k_state][0];
	  ap[1] = cp9map->hns2cs[k][k_state][1];
	  if(ap[1] != -1)
	cm_Fail("ERROR, HMM insert state of node %d maps to 2 CM insert states: %d and %d\n", k, ap[0], ap[1]);
	  summed_psi = psi[ap[0]];
	  violation = FALSE;
	  diff = phi[k][1] - summed_psi;
	  if((diff > threshold) || ((-1. * diff) > threshold))
	{
	  violation = TRUE;
	  v_ct++;
	}
	  if(violation)
	printf("I k: %4d | phi: %f | psi: %f VIOLATION (%f) (cm v1: %d cm v2: %d)\n", k, phi[k][1], summed_psi, diff, ap[0], ap[1]);
	  else if(debug_level > 1)
	printf("I k: %4d | phi: %f | psi: %f\n", k, phi[k][1], summed_psi);

	  k_state = HMMDELETE;
	  ap[0] = cp9map->hns2cs[k][k_state][0];
	  ap[1] = cp9map->hns2cs[k][k_state][1];
	 if(k == 0)
	summed_psi = 0.;      /*no such state in HMM or CM*/
	  else
	{
	  summed_psi = psi[ap[0]];
	  if(ap[1] != -1)
	    summed_psi += psi[ap[1]];
	}
	  violation = FALSE;
	  diff = phi[k][2] - summed_psi;
	  if((diff > threshold) || ((-1. * diff) > threshold))
	{
	  violation = TRUE;
	  v_ct++;
	}
	  if(violation)
	printf("D k: %4d | phi: %f | psi: %f VIOLATION (%f) (cm v1: %d cm v2: %d)\n", k, phi[k][2], summed_psi, diff, ap[0], ap[1]);
	  else if(debug_level > 1)
	{
	  printf("D k: %4d | phi: %f | psi: %f\n\n", k, phi[k][2], summed_psi);
	}
	}
  free(ap);

  if(v_ct > 0)
	{
	  printf("ERROR, %d HMM states violate the %f threshold b/t psi and phi.\n", v_ct, threshold);
	  ret_val = FALSE;
	}
  if(adj_bp_flag == TRUE) return eslOK; /* always return TRUE for models with bps modelling adjacent columns (should be rare) */

  if(ret_val == FALSE) ESL_FAIL(eslFAIL, errbuf, "cp9 hmm fails psi/phi test");

  return eslOK;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/**************************************************************************
 * EPN 03.13.06
 * debug_print_cp9_params()
 *
 * Purpose:  Print out emission and transition probabilities and scores
 *           for a CM plan 9 HMM.
 *
 * Args:
 * fp                - often stdout
 * cplan9_s *hmm     - counts form CM plan 9 HMm
 * print_scores      - TRUE to print scores, FALSE not to
 * Returns: (void)
 */
void
debug_print_cp9_params(FILE *fp, CP9_t *hmm, int print_scores)
{
  int k, i;

  /*fprintf(fp, "Printing CP9 HMM parameters in debug_print_cp9_params:\n\n");*/

  fprintf(fp, "Consensus Length: %d\n", hmm->M);
  fprintf(fp, "Node: 0\n");
  for(i = 0; i < hmm->abc->K; i++)
	{
	  if(print_scores) fprintf(fp, "ins[%3d][%3d] = %.3f | %10d\n", 0, i, hmm->ins[0][i], hmm->isc[i][0]);
	  else             fprintf(fp, "ins[%3d][%3d] = %.3f\n", 0, i, hmm->ins[0][i]);
	}
  fprintf(fp, "\n");

  k=0;
  if(print_scores) {
	fprintf(fp, "\tCTMM[%d]  = %f | %d\n", k, hmm->t[0][CTMM], hmm->tsc[CTMM][0]);
	fprintf(fp, "\tCTMI[%d]  = %f | %d\n", k, hmm->t[0][CTMI], hmm->tsc[CTMI][0]);
	fprintf(fp, "\tCTMD[%d]  = %f | %d\n", k, hmm->t[0][CTMD], hmm->tsc[CTMD][0]);
	fprintf(fp, "\tCTMEL[%d] = %f | %d\n", k, hmm->t[0][CTMEL], hmm->tsc[CTMEL][0]);
	fprintf(fp, "\tCTIM[%d]  = %f | %d\n", k, hmm->t[0][CTIM], hmm->tsc[CTIM][0]);
	fprintf(fp, "\tCTII[%d]  = %f | %d\n", k, hmm->t[0][CTII], hmm->tsc[CTII][0]);
	fprintf(fp, "\tCTID[%d]  = %f | %d\n", k, hmm->t[0][CTID], hmm->tsc[CTID][0]);
	fprintf(fp, "\tCTDM[%d]  = %f | %d\n", k, hmm->t[0][CTDM], hmm->tsc[CTDM][0]);
	fprintf(fp, "\tCTDI[%d]  = %f | %d\n", k, hmm->t[0][CTDI], hmm->tsc[CTDI][0]);
	fprintf(fp, "\tCTDD[%d]  = %f | %d\n", k, hmm->t[0][CTDD], hmm->tsc[CTDD][0]);
  }
  else  {
	fprintf(fp, "\tCTMM[%d]  = %f\n", k, hmm->t[0][CTMM]);
	fprintf(fp, "\tCTMI[%d]  = %f\n", k, hmm->t[0][CTMI]);
	fprintf(fp, "\tCTMD[%d]  = %f\n", k, hmm->t[0][CTMD]);
	fprintf(fp, "\tCTMEL[%d] = %f\n", k, hmm->t[0][CTMEL]);
	fprintf(fp, "\tCTIM[%d]  = %f\n", k, hmm->t[0][CTIM]);
	fprintf(fp, "\tCTII[%d]  = %f\n", k, hmm->t[0][CTII]);
	fprintf(fp, "\tCTID[%d]  = %f\n", k, hmm->t[0][CTID]);
	fprintf(fp, "\tCTDM[%d]  = %f\n", k, hmm->t[0][CTDM]);
	fprintf(fp, "\tCTDI[%d]  = %f\n", k, hmm->t[0][CTDI]);
	fprintf(fp, "\tCTDD[%d]  = %f\n", k, hmm->t[0][CTDD]);
  }
  for(k = 1; k <= hmm->M; k++)
	{
	  fprintf(fp, "Node: %d\n", k);
	  for(i = 0; i < hmm->abc->Kp; i++)
	{
	  if(print_scores)
	    fprintf(fp, "mat[%3d][%3d] = %.3f | %10d\n", k, i, hmm->mat[k][i], hmm->msc[i][k]);
	  else
	    fprintf(fp, "mat[%3d][%3d] = %.3f\n", k, i, hmm->mat[k][i]);
	}
	  for(i = 0; i < hmm->abc->Kp; i++)
	{
	  if(print_scores)
	    fprintf(fp, "ins[%3d][%3d] = %.3f | %10d\n", k, i, hmm->ins[k][i], hmm->isc[i][k]);
	  else
	    fprintf(fp, "ins[%3d][%3d] = %.3f\n", k, i, hmm->ins[k][i]);
	}
	  fprintf(fp, "\n");
	  if(print_scores) {
	fprintf(fp, "\tCTMM[%d]  = %f | %10d\n", k, hmm->t[k][CTMM], hmm->tsc[CTMM][k]);
	fprintf(fp, "\tCTMI[%d]  = %f | %10d\n", k, hmm->t[k][CTMI], hmm->tsc[CTMI][k]);
	fprintf(fp, "\tCTMD[%d]  = %f | %10d\n", k, hmm->t[k][CTMD], hmm->tsc[CTMD][k]);
	fprintf(fp, "\tCTMEL[%d] = %f | %10d\n", k, hmm->t[k][CTMEL], hmm->tsc[CTMEL][k]);
	fprintf(fp, "\tCTIM[%d]  = %f | %10d\n", k, hmm->t[k][CTIM], hmm->tsc[CTIM][k]);
	fprintf(fp, "\tCTII[%d]  = %f | %10d\n", k, hmm->t[k][CTII], hmm->tsc[CTII][k]);
	fprintf(fp, "\tCTID[%d]  = %f | %10d\n", k, hmm->t[k][CTID], hmm->tsc[CTID][k]);
	fprintf(fp, "\tCTDM[%d]  = %f | %10d\n", k, hmm->t[k][CTDM], hmm->tsc[CTDM][k]);
	fprintf(fp, "\tCTDI[%d]  = %f | %10d\n", k, hmm->t[k][CTDI], hmm->tsc[CTDI][k]);
	fprintf(fp, "\tCTDD[%d]  = %f | %10d\n", k, hmm->t[k][CTDD], hmm->tsc[CTDD][k]);
	fprintf(fp, "\t beg[%d]  = %f | %10d\n", k, hmm->begin[k], hmm->bsc[k]);
	fprintf(fp, "\t end[%d]  = %f | %10d\n", k, hmm->end[k], hmm->esc[k]);
	  }
	  else {
	fprintf(fp, "\tCTMM[%d]  = %f\n", k, hmm->t[k][CTMM]);
	fprintf(fp, "\tCTMI[%d]  = %f\n", k, hmm->t[k][CTMI]);
	fprintf(fp, "\tCTMD[%d]  = %f\n", k, hmm->t[k][CTMD]);
	fprintf(fp, "\tCTMEL[%d] = %f\n", k, hmm->t[k][CTMEL]);
	fprintf(fp, "\tCTIM[%d]  = %f\n", k, hmm->t[k][CTIM]);
	fprintf(fp, "\tCTII[%d]  = %f\n", k, hmm->t[k][CTII]);
	fprintf(fp, "\tCTID[%d]  = %f\n", k, hmm->t[k][CTID]);
	fprintf(fp, "\tCTDM[%d]  = %f\n", k, hmm->t[k][CTDM]);
	fprintf(fp, "\tCTDI[%d]  = %f\n", k, hmm->t[k][CTDI]);
	fprintf(fp, "\tCTDD[%d]  = %f\n", k, hmm->t[k][CTDD]);
	fprintf(fp, "\t beg[%d]  = %f\n", k, hmm->begin[k]);
	fprintf(fp, "\t end[%d]  = %f\n", k, hmm->end[k]);
	  }
	  fprintf(fp, "\n");
	}
}

/**************************************************************************
 * EPN 09.01.06
 * Function: CP9_check_by_sampling()
 *
 * Purpose:  Given a CM and a CM plan 9 hmm that is supposed to mirror
 *           the CM as closely as possible (Weinberg-Ruzzo style, with
 *           differences due to differences in the CM Plan 9 architecture
 *           and the architecture that they use), check if the CM and CP9
 *           actually do correspond as closely as possible. Do this by
 *           generating alignments from the CM, determining CP9 HMM
 *           tracebacks implicit in the alignments and amassing counts
 *           from the tracebacks to use to build a new CP9 HMM
 *           without using pseudocounts (the infinite MSA idea introduced
 *           by Zasha Weinberg in the ML-HMM Bioinformatics paper). Finally
 *           compare the parameters of that CP9 HMM to the one we've
 *           built.
 *
 *           The option is given to truncate the alignments generated
 *           from the CM before and after specified consensus columns
 *           prior to building the ML HMM. This option was added to
 *           allow testing of the subCM construction procedure.
 *           To NOT truncate, simply pass 1 and hmm->M as the first
 *           and last consensus columns to use.
 *
 *           NOTE: code to sample an alignment from the CM taken from
 *                 cmemit.c (which was ported from HMMER's hmmemit.c).
 *
 * Returns: eslOK if CM and HMM are "close enough" (see code)
 *          !eslOK otherwise, errbuf is filled.
 */
int
CP9_check_by_sampling(CM_t *cm, CP9_t *hmm, char *errbuf, ESL_RANDOMNESS  *r, CMSubInfo_t *subinfo,
		      int spos, int epos, float chi_thresh, int nsamples, int print_flag)
{
  int status;
  Parsetree_t **tr;             /* Parsetrees of emitted aligned sequences */
  ESL_SQ      **sq;             /* sequences */
  ESL_MSA           *msa;       /* alignment */
  float             *wgt;
  char *name;                   /* name for emitted seqs */
  int i, nd;
  int L;
  int apos;
  int *matassign;
  int *useme;
  CP9trace_t **cp9_tr;          /* fake tracebacks for each seq            */
  CP9_t  *shmm;                 /* the new, CM plan9 HMM; built by sampling*/
  int msa_nseq;                 /* this is the number of sequences per MSA,
				 * current strategy is to sample (nseq/nseq_per_msa)
				 * alignments from the CM, and add counts from
				 * each to the shmm in counts form (to limit memory)
				 */
  int nsampled;                 /* number of sequences sampled thus far */
  int cc;
  int v_ct;                 /* number of nodes that violate our threshold */
  int spredict_total_ct;       /* total number of nodes we thought would be violations */
  int swrong_total_ct; /* total number of nodes we thought would be violations but were not */
  int namelen;         /* max int size for name */
  char *tmp_name;           /* name for the seqs */

  spredict_total_ct = 0;
  swrong_total_ct = 0;
  v_ct = 0;

  msa_nseq = 1000;

  /* Allocate and zero the new HMM we're going to build by sampling from
   * the CM.
   */
  shmm = AllocCPlan9(hmm->M, hmm->abc);
  ZeroCPlan9(shmm);
  CPlan9SetNullModel(shmm, hmm->null, 1.0); /* set p1 = 1.0 which corresponds to the CM */

  CPlan9Renormalize(hmm);
  CMRenormalize(cm);

  /* sample MSA(s) from the CM */
  nsampled = 0;
  ESL_ALLOC(sq, sizeof(ESL_SQ *)       * msa_nseq);
  ESL_ALLOC(tr, (sizeof(Parsetree_t *) * msa_nseq));
  ESL_ALLOC(wgt,(sizeof(float)         * msa_nseq));
  esl_vec_FSet(wgt, msa_nseq, 1.0);
  namelen = 3 + IntMaxDigits() + 1;  /* IntMaxDigits() returns number of digits in INT_MAX */
  ESL_ALLOC(tmp_name, sizeof(char) * namelen);

  while(nsampled < nsamples)
	{
	  if(nsampled != 0)	{
	/* clean up from previous MSA */
	free(matassign);
	free(useme);
	for (i = 0; i < msa_nseq; i++) {
	  CP9FreeTrace(cp9_tr[i]);
	  FreeParsetree(tr[i]);
	  esl_sq_Destroy(sq[i]);
	}
	free(cp9_tr);
	esl_msa_Destroy(msa);
	  }
	  /* Emit msa_nseq parsetrees from the CM */
	  if(nsampled + msa_nseq > nsamples)
	msa_nseq = nsamples - nsampled;
	  for (i = 0; i < msa_nseq; i++) {
	ESL_ALLOC(name, sizeof(char) * namelen);
	sprintf(name, "seq%d", i+1);
	if((status = EmitParsetree(cm, errbuf, r, name, TRUE, &(tr[i]), &(sq[i]), &L)) != eslOK) return status;
	free(name);
	  }
	  /* Build a new MSA from these parsetrees */
	  Parsetrees2Alignment(cm, errbuf, cm->abc, sq, NULL, tr, NULL, msa_nseq, NULL, NULL, TRUE, FALSE, &msa);
	  /* MSA should be in text mode, not digitized */
	  if(msa->flags & eslMSA_DIGITAL) ESL_FAIL(eslEINCOMPAT, errbuf, "CP9_check_by_sampling(): sampled MSA should NOT be digitized.\n");

	  /* Truncate the alignment prior to consensus column spos and after
	 consensus column epos */
	  ESL_ALLOC(useme, sizeof(int) * (msa->alen+1));
	  for (apos = 0, cc = 0; apos < msa->alen; apos++) {
	/* Careful here, placement of cc++ increment is impt,
	 * we want all inserts between cc=spos-1 and cc=spos,
	 * and between cc=epos and cc=epos+1.
	 */
	useme[apos] = (cc < (spos-1) || cc > epos) ? 0 : 1;
	if (!esl_abc_CIsGap(cm->abc, msa->rf[apos])) {
	  cc++;
	  if(cc == (epos+1)) useme[apos] = 0;
	  /* we misassigned this guy, overwrite */
	}
	  }
	  if((status = esl_msa_ColumnSubset(msa, errbuf, useme)) != eslOK) return status;

	  /* Determine match assignment from RF annotation
	   */
	  ESL_ALLOC(matassign, sizeof(int) * (msa->alen+1));
	  matassign[0] = 0;
	  for (apos = 0; apos < msa->alen; apos++) {
	matassign[apos+1] = 0;
	if (!esl_abc_CIsGap(cm->abc, msa->rf[apos]))
	  matassign[apos+1] = 1;
	  }
	  /* make fake tracebacks for each seq */
	  if((status = esl_msa_Digitize(cm->abc, msa, NULL)) == eslEINVAL) ESL_FAIL(status, errbuf, "CP9_check_by_sampling(): esl_msa_Digitize() returned eslEINVAL, some characters must be invalid in msa.");
	  CP9_fake_tracebacks(msa, matassign, &cp9_tr);

	  /* build model from tracebacks (code from HMMER's modelmakers.c::matassign2hmm() */
	  for (i = 0; i < msa->nseq; i++)
	CP9TraceCount(shmm, sq[i]->dsq, wgt[i], cp9_tr[i]);

	  nsampled += msa_nseq;
	}

  /* clean up from previous MSA */
  free(matassign);
  free(useme);
  free(tmp_name);
  for (i = 0; i < msa_nseq; i++) {
	CP9FreeTrace(cp9_tr[i]);
	FreeParsetree(tr[i]);
	esl_sq_Destroy(sq[i]);
  }
  esl_msa_Destroy(msa);
  free(cp9_tr);
  free(tr);
  free(sq);
  free(wgt);

  /* The new shmm is in counts form, filled with observations from MSAs sampled
   * from the CM.
   * We want to do a series of chi-squared tests to determine the probability that
   * the observed samples from the CM were not taken from the corresponding CM Plan 9
   * HMM probability distributions (the CM Plan 9 is supposed to exactly mirror the
   * CM in this way).
   */
  if(print_flag)
	{
	  printf("PRINTING BUILT HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, hmm, TRUE);
	  printf("DONE PRINTING BUILT HMM PARAMS:\n");

	  printf("PRINTING SAMPLED HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, shmm, TRUE);
	  printf("DONE PRINTING SAMPLED HMM PARAMS:\n");
	}
  for(nd = 0; nd <= shmm->M; nd++) {
	if(print_flag) printf("nd:%d\n", nd);
	if(!(CP9_node_chi_squared(hmm, shmm, nd, chi_thresh, print_flag))) {
	  if(subinfo == NULL) {
	v_ct++;
	printf("SAMPLING VIOLATION[%3d]: TRUE | spos: %3d | epos: %3d\n", nd, spos, epos);
	  }
	  else if(subinfo != NULL && subinfo->imp_cc[nd] == 0) {
	v_ct++;
	printf("SAMPLING VIOLATION[%3d]: TRUE | spos: %3d | epos: %3d | subinfo->imp_cc: %d\n", nd, spos, epos, subinfo->imp_cc[nd]);
	  }
	  else if(subinfo != NULL && subinfo->imp_cc[nd] != 0) {
	spredict_total_ct++;
	subinfo->spredict_ct[subinfo->imp_cc[nd]]++;
	if(print_flag) printf("PREDICTED SAMPLING VIOLATION[%3d]: TRUE | spos: %3d | epos: %3d | subinfo->imp_cc: %d\n", nd, spos, epos, subinfo->imp_cc[nd]);
	  }
	}
	else if(subinfo != NULL && subinfo->imp_cc[nd] != 0) {
	  /* We predicted this node would fail, but it didn't */
	  spredict_total_ct++;
	  subinfo->spredict_ct[subinfo->imp_cc[nd]]++;
	  swrong_total_ct++;
	  subinfo->swrong_ct[subinfo->imp_cc[nd]]++;
	  if(print_flag) printf("NON-VIOLATION[%3d] %3d : spos: %3d | epos: %3d | non-subinfo->imp_cc: %d\n", nd, swrong_total_ct, spos, epos, subinfo->imp_cc[nd]);
	}
  }

  /*Next, renormalize shmm and logoddisfy it */
  CPlan9Renormalize(shmm);
  CP9Logoddsify(shmm);

  if(print_flag)
	{
	  printf("PRINTING BUILT HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, hmm, TRUE);
	  printf("DONE PRINTING BUILT HMM PARAMS:\n");

	  printf("PRINTING SAMPLED HMM PARAMS:\n");
	  debug_print_cp9_params(stdout, shmm, TRUE);
	  printf("DONE PRINTING SAMPLED HMM PARAMS:\n");

	  /* Output the alignment */
	  /*WriteStockholm(stdout, msa);*/
	}
  FreeCPlan9(shmm);

  if(v_ct > 0) ESL_FAIL(eslFAIL, errbuf, "CP9_check_by_sampling(): check failed");
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "memory allocation error");
  return FALSE; /* never reached */
}

/* Function: CP9_node_chi_squared()
 *
 * Purpose : Given two CM Plan 9 HMMs, one in normalized form (ahmm), and one in
 *           raw counts form (shmm), determine for a specific node nd,
 *           the probability the samples implicit in the shmm were taken
 *           from the corresponding probability distribution in ahmm using
 *           the chi-squared test. Return FALSE IFF the probability that some
 *           set of counts was not taken from the corresponding ahmm distribution
 *           (probability null hypothesis is rejected) is above the probability
 *           threshold thresh.
 *
 * Args:
 * cplan9_s *ahmm    - an HMM with the probability distributions that define
 *                     the null hypothesis for the chi-squared tests (we
 *                     think the counts in shmm were taken from these distributions).
 * cplan9_s *shmm    - an HMM in counts form
 * int         nd    - node of the HMM to check.
 * float   threshold - probability threshold for rejecting
 * int print_flag    - TRUE to print useful debugging info
 */
int
CP9_node_chi_squared(CP9_t *ahmm, CP9_t *shmm, int nd, float threshold, int print_flag)
{
  int status;
  double p;
  int x;
  float m_nseq, i_nseq, d_nseq;
  float check_m_nseq, check_i_nseq;
  float *temp_ahmm_trans;
  float *temp_shmm_trans;
  int ret_val;

  ret_val = TRUE;

  if(nd > shmm->M || nd >  ahmm->M)
	cm_Fail("ERROR CP9_node_chi_squared() is being grossly misused.\n");

  CPlan9Renormalize(ahmm);
  /*
	EPN, Thu Feb  7 17:49:46 2008
	I think this CPlan9GlobalConfig() call is superfluous, in my tests it did nothing.
	I could be wrong in some cases though. I'm not too too worried about it though,
	because this function was useful primarily during development of the CP9 and sub CM
	construction code, which I now trust. And more importantly, this function (CP9_node_chi_squared)
	CANNOT be called from anything but cp9-test and sub_cm-test which are testsuite
	executables.

	The reason I wanted to get rid of this CPlan9GlobalConfig() call is b/c I've changed
	how CP9's are locally configured, and the M_0->I_0, M_0->D_1, M_M->I_M and D_M->I_M transitions
	are all set to IMPOSSIBLE (to make a local CP9 more like a local CM), and thus it makes it
	hard to change a locally configured CP9 back to global mode b/c the initial values of those
	transitions is lost (the solution would be to add vectors to the cp9 data structure that
	remember these transition probs, but I don't have to do that if I NEVER need to globalize
	a locally configured CP9 (and this was the only function call of CPlan9GlobalConfig().
	CPlan9GlobalConfig() has been relocated to old_miscfuncs.c where it is not compiled
	or used.

	start of old code block
	~~~~~~~~~~~~~~~~~~~~~~~~~
	CPlan9GlobalConfig(ahmm);
	~~~~~~~~~~~~~~~~~~~~~~~~~
	end of old code block
  */

  CP9Logoddsify(ahmm);

  /* First determine the sum of the counts for each state. This
   * is the number of samples that visited match, insert and
   * delete state of this node.
   */

  if(nd == 0)
	m_nseq  = shmm->begin[1]; /* this is begin -> M_1 transition */
  else if(nd == shmm->M)
	m_nseq  = shmm->end[nd];   /* this is M_M -> end transition */
  else
	m_nseq  = shmm->t[nd][CTMM];
  m_nseq += shmm->t[nd][CTMI];
  m_nseq += shmm->t[nd][CTMD];

  i_nseq  = shmm->t[nd][CTIM];
  i_nseq += shmm->t[nd][CTII];
  i_nseq += shmm->t[nd][CTID];

  if(nd != 0) /* node 0 has no delete state */
	{
	  d_nseq  = shmm->t[nd][CTDM];
	  d_nseq += shmm->t[nd][CTDI];
	  d_nseq += shmm->t[nd][CTDD];
	}

  if(nd != 0) {
	check_m_nseq = 0.;
	for (x = 0; x < ahmm->abc->K; x++) check_m_nseq += shmm->mat[nd][x];
	if(fabs(check_m_nseq - m_nseq) > 0.0001) cm_Fail("ERROR: node: %d has different number of sampled match emissions and transitions.\n");
  }
  check_i_nseq = 0.;
  for (x = 0; x < ahmm->abc->K; x++) check_i_nseq += shmm->ins[nd][x];
  if((check_i_nseq >= i_nseq && ((check_i_nseq - i_nseq) > 0.0001)) ||
	 (check_i_nseq  < i_nseq && ((i_nseq - check_i_nseq) > 0.0001)))
	cm_Fail("ERROR: node: %d has different number of sampled insert emissions and transitions.\n");

  /* Perform chi-squared tests using code borrowed from SRE in
   * infernal/testsuite/bandcyk-montecarlo-test.c */
  /* Check match emissions */
  if(nd != 0) {
	esl_vec_FScale(ahmm->mat[nd], ahmm->abc->K, esl_vec_FSum(shmm->mat[nd], ahmm->abc->K)); /* convert to #'s */
	p = FChiSquareFit(ahmm->mat[nd], shmm->mat[nd], ahmm->abc->K);	    /* compare #'s    */
	if (p < threshold) {
	  printf("Rejected match emission distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	  ret_val = FALSE;
	}
  }
  /* check insert emissions */
  esl_vec_FScale(ahmm->ins[nd], ahmm->abc->K, esl_vec_FSum(shmm->ins[nd], ahmm->abc->K)); /* convert to #'s */
  p = FChiSquareFit(ahmm->ins[nd], shmm->ins[nd], ahmm->abc->K);	/* compare #'s    */
  if (p < threshold) {
	printf("Rejected insert emission distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	ret_val = FALSE;
  }

  /* check transitions */
  /* out of match, we're in global NW mode, so only non-zero begin is begin[1],
   * and only non-zero end is end[hmm->M] */
  ESL_ALLOC(temp_ahmm_trans, sizeof(float) * cp9_NTRANS);
  ESL_ALLOC(temp_shmm_trans, sizeof(float) * cp9_NTRANS);
  if(nd == 0 || nd == shmm->M) {
	if(nd == 0) { /* careful, begin[1] is really hmm->t[0][CTMM] */
	  temp_ahmm_trans[0] = ahmm->begin[1];
	  temp_shmm_trans[0] = shmm->begin[1];
	  for(x = 1; x < cp9_TRANS_NMATCH; x++) {
	temp_ahmm_trans[x] = ahmm->t[0][x];
	temp_shmm_trans[x] = shmm->t[0][x];
	  }
	}
	if(nd == shmm->M) { /* careful, end[hmm->M] is really hmm->t[hmm->M][CTMM] */
	  temp_ahmm_trans[0] = ahmm->end[ahmm->M];
	  temp_shmm_trans[0] = shmm->end[shmm->M];
	  for(x = 1; x < cp9_TRANS_NMATCH; x++) {
	temp_ahmm_trans[x] = ahmm->t[ahmm->M][x];
	temp_shmm_trans[x] = shmm->t[shmm->M][x];
	  }
	}
	esl_vec_FScale(temp_ahmm_trans, cp9_TRANS_NMATCH, esl_vec_FSum(temp_shmm_trans, cp9_TRANS_NMATCH));     /* convert to #'s */
	p = FChiSquareFit(temp_ahmm_trans, temp_shmm_trans, cp9_TRANS_NMATCH);   /* compare #'s    */
	if (p < threshold) {
	  printf("Rejected match transition distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	  ret_val = FALSE;
	}
  }
  else {
	esl_vec_FScale(ahmm->t[nd], cp9_TRANS_NMATCH, esl_vec_FSum(shmm->t[nd], cp9_TRANS_NMATCH));     /* convert to #'s */
	p = FChiSquareFit(ahmm->t[nd], shmm->t[nd], cp9_TRANS_NMATCH);   /* compare #'s    */
	if (p < threshold) {
	  printf("Rejected match transition distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	  ret_val = FALSE;
	}
  }
  /* out of insert */
  esl_vec_FScale   (ahmm->t[nd] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT, esl_vec_FSum(shmm->t[nd]+cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT));     /* convert to #'s */
  p = FChiSquareFit(ahmm->t[nd] + cp9_TRANS_INSERT_OFFSET, shmm->t[nd] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT);   /* compare #'s    */
  if (p < threshold) {
	printf("Rejected insert transition distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	ret_val = FALSE;
  }

  /* out of delete */
  if(nd != 0) { /* D_0 does not exist */
	esl_vec_FScale     (ahmm->t[nd] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE, esl_vec_FSum(shmm->t[nd] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE));     /* convert to #'s */
	  p = FChiSquareFit(ahmm->t[nd] + cp9_TRANS_DELETE_OFFSET, shmm->t[nd] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE);   /* compare #'s    */
	  if (p < threshold) {
	printf("Rejected delete transition distribution for CP9 node %d: chi-squared p = %f\n", nd, p);
	ret_val = FALSE;
	  }
  }
  else if(print_flag) printf("\n");

  free(temp_ahmm_trans);
  free(temp_shmm_trans);

  /* we've scaled some probabilities into counts, we want to get back into prob form */
  CPlan9Renormalize(ahmm);

  return ret_val;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* never reached */
}

/**************************************************************************
 * EPN 09.24.06 [AA 599 DC->STL]
 * debug_print_phi_cp9()
 *
 * Purpose:  Print out phi values for a given CP9 HMM.
 *
 * Args:
 * cplan9_s *hmm     - the HMM
 * double **phi      - phi array, phi[k][v] is expected number of times

 *                     HMM state v (0 = match, 1 insert, 2 = delete) in
 *                     node k is visited.
 * Returns: (void)
 */
void
debug_print_phi_cp9(CP9_t *hmm, double **phi)
{
  int k;

  for(k = 0; k <= hmm->M; k++)
	{
	  printf("phi[%4d][M]: %f\n", k, phi[k][0]);
	  printf("phi[%4d][I]: %f\n", k, phi[k][1]);
	  if(k != 0)
	printf("phi[%4d][D]: %f\n\n", k, phi[k][2]);
	  else
	printf("\n");
	}
  return;
}

/**************************************************************************
 * FChiSquareFit()
 * Stolen line for line from SRE's infernal/testsuite/bandcyk-montecarlo-test.c
 * and changed from double's to float's.
 */

static float
FChiSquareFit(float *f1, float *f2, int N)
{
  int    i;
  float diff;
  float chisq = 0.0;
  int    n;
  double qax;

  n = 0;
  for (i = 0; i < N; i++)
	{
	  if (f1[i] == 0. && f2[i] == 0.) continue;
	  diff = f1[i] - f2[i];
	  chisq += diff * diff / (f1[i]+f2[i]);
	  n++;
	}

  if (n > 1)
	{
	  if(esl_stats_IncompleteGamma(((float) n-1.)/2., chisq/2., NULL, &qax) != eslOK)
	cm_Fail("ERROR in FChiSquareFit() call to esl_stats_IncompleteGamma()");
	  return (float) qax;
	}
  else
	return -1.;
}

/**************************************************************************
 * EPN 03.13.06
 * check_cm_adj_bp()
 *
 * Purpose:  Check if two adjacent consensus columns (HMM nodes) are modelled by the
 *           same MATP node.
 *
 * Args:
 * CM_t *cm          - the CM
 * CP9Map_t          - map from CM to HMM and vice versa
 * Returns: TRUE if two adjacent consensus columns are modelled by the same MATP_nd
 *          FALSE if not
 */
static int
check_cm_adj_bp(CM_t *cm, CP9Map_t *cp9map)
{
  int k, prev_k;
  prev_k = cp9map->pos2nd[1];
  for(k = 2; k <= cp9map->hmm_M; k++)
	{
	  if(cp9map->pos2nd[k] == prev_k)
	return TRUE;
	  prev_k = cp9map->pos2nd[k];
	}
  return FALSE;
}

/* Function: MakeDealignedString()
 * Incept:   EPN, Mon Aug  6 10:21:49 2007
 *           stolen from Squid during Easelization, there's no equivalent
 *           in Easel.
 *
 * Purpose:  Given an aligned text string of some type (either sequence or
 *           secondary structure, for instance), dealign it relative
 *           to a given aseq. Return a ptr to the new string.
 *
 * Args:     abc   : the alphabet
 *           aseq  : template alignment
 *           alen  : length of aseq
 *           ss:   : string to make dealigned copy of; same length as aseq
 *           ret_s : RETURN: dealigned copy of ss
 *
 * Return:   1 on success, 0 on failure (and squid_errno is set)
 *           ret_s is alloc'ed here and must be freed by caller
 */
int
MakeDealignedString(const ESL_ALPHABET *abc, char *aseq, int alen, char *ss, char **ret_s)
{
  int status;
  char *new;
  int   apos, rpos;

  ESL_ALLOC(new, (alen+1) * sizeof(char));
  for (apos = rpos = 0; apos < alen; apos++)
	if (! esl_abc_CIsGap(abc, aseq[apos]))
	  {
	new[rpos] = ss[apos];
	rpos++;
	  }
  new[rpos] = '\0';
  if (alen != strlen(ss))
	{ cm_Fail("ERROR dealigning sequence."); }
  *ret_s = new;
  return eslOK;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0; /* never reached */
}

/* Function: sub_build_cp9_hmm_from_mother()
 * Date:     EPN, Wed Aug 20 16:05:26 2008
 *
 * Purpose:  Given a CM, and it's mother (CM is a sub CM of it's mother)
 *           build a CM Plan 9 HMM that mirrors the CM as closely
 *           as possible. This HMM is a Weinberg/Ruzzo style ML HMM; i.e. if
 *           we sampled an 'infinite MSA' from the CM and built a ML HMM from it
 *           (using no pseudo-counts), it would be the same as the HMM we construct
 *           here.
 *
 *           Use parameters from the mother CM's cp9 HMM where possible to
 *           save time. Sub CM CP9 model construction takes a long time which
 *           is bad b/c a new sub CM is built for each target sequence in
 *           cmalign.
 *
 * Args:
 * CM_t        *cm         - the CM
 * char        *errbuf     - for error messages
 * CM_t        *mother_cm  - mother CM, cm is a sub CM of mother_cm
 * CMSubMap_t  *mother_map - map from cm to mother_cm and vice versa
 * cplan9_s   **ret_hmm    - CM Plan 9 HMM to be allocated, filled in and returned
 * CP9Map_t   **ret_cp9map - map from the CP9 HMM to the CM and vice versa
 *                           Allocated and returned from here, caller must free.
 * int          do_psi_test - TRUE to do a psi vs phi test, FALSE not to
 * float psi_vs_phi_threshold - allowable difference in expected number of times mapping
 *                              cm and hmm states are entered.
 * Returns: eslOK if CP9 is constructed (and passes the psi vs phi test if do_psi_test is TRUE)
 *          ! eslOK upon failure, with informative error message written to errbuf.
 */
int
sub_build_cp9_hmm_from_mother(CM_t *cm, char *errbuf, CM_t *mother_cm, CMSubMap_t *mother_map, CP9_t **ret_hmm, CP9Map_t **ret_cp9map, int do_psi_test,
			      float psi_vs_phi_threshold, int debug_level)
{
  int     status;
  int       k;                 /* counter of consensus columns (HMM nodes)*/
  int       mk,x;
  double    *psi;              /* expected num times each state visited in CM */
  double   **phi;              /* expected num times each state visited in HMM*/
  CP9Map_t *cp9map;
  CP9_t  *hmm;       /* CM plan 9 HMM we're going to construct from the sub_cm */
  float d;
  char ***tmap = NULL;

  /* Contract check, we can't be in local mode in the CM */
  if(cm->flags & CMH_LOCAL_BEGIN) ESL_FAIL(eslEINCOMPAT, errbuf, "sub_build_cp9_hmm_from_mother(), CMH_LOCAL_BEGIN flag is up");
  if(cm->flags & CMH_LOCAL_END)   ESL_FAIL(eslEINCOMPAT, errbuf, "sub_build_cp9_hmm_from_mother(), CMH_LOCAL_END flag is up");
  if(mother_cm->cp9->flags & CPLAN9_EL) ESL_FAIL(eslEINCOMPAT, errbuf, "sub_build_cp9_hmm_from_mother(), mother_cm's cp9 has EL local ends on");
  if(!(mother_cm->cp9->flags & CPLAN9_LOCAL_BEGIN)) ESL_FAIL(eslEINCOMPAT, errbuf, "sub_build_cp9_hmm_from_mother(), mother_cm's cp9 does not have local begins on");
  if(!(mother_cm->cp9->flags & CPLAN9_LOCAL_END))   ESL_FAIL(eslEINCOMPAT, errbuf, "sub_build_cp9_hmm_from_mother(), mother_cm's cp9 does not have local ends on.");

  /* Allocate and initialize the cp9map */
  cp9map = AllocCP9Map(cm);
  /* Map the CM states to CP9 states and nodes and vice versa */
  CP9_map_cm2hmm(cm, cp9map, debug_level);

  hmm    = AllocCPlan9(cp9map->hmm_M, cm->abc);
  ZeroCPlan9(hmm);
  CPlan9SetNullModel(hmm, cm->null, 1.0); /* set p1 = 1.0 which corresponds to the CM */
  CPlan9InitEL(hmm, cm); /* set up hmm->el_from_ct and hmm->el_from_idx data, which
			  * explains how the EL states are connected in the HMM. */
  hmm->null2_omega = cm->null2_omega;
  hmm->null3_omega = cm->null3_omega;

  /* THIS COULD BE REMOVED IF WE DON"T DO THE PHI/PSI TEST! */
  if((psi = cm_ExpectedStateOccupancy(cm)) == NULL) goto ERROR;
  tmap = cm_CreateTransitionMap();

  /* fill in transitions into node 1 and out of node M */
  cm2hmm_special_trans_cp9(cm, hmm, cp9map, psi, tmap);

  /* renormalize only node 0 and node M transitions */
  /* node 0 */
  /* match */
  d = hmm->begin[1] +  hmm->t[0][CTMI] + hmm->t[0][CTMD] + hmm->t[0][CTMEL];  /* we know that begin[k>1] == 0, we set it as such, so we skip their contribution */
  hmm->begin[1] /= d;
  hmm->t[0][CTMI] /= d;
  hmm->t[0][CTMD] /= d;
  hmm->t[0][CTMEL] /= d;
  /* insert */
  esl_vec_FNorm(hmm->t[0] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT);	        /* transitions out of insert for node 0 (state N)*/
  /* delete */
  esl_vec_FSet (hmm->t[0] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE, 0.);            /* D_0 does not exist */

  /* node M */
  /* match */
  d = esl_vec_FSum(hmm->t[hmm->M], cp9_TRANS_NMATCH) + hmm->end[hmm->M];
  esl_vec_FScale(hmm->t[hmm->M], cp9_TRANS_NMATCH, 1./d);
  hmm->end[hmm->M] /= d;
  /* insert */
  esl_vec_FNorm(hmm->t[hmm->M] + cp9_TRANS_INSERT_OFFSET, cp9_TRANS_NINSERT);	/* insert */
  /* delete */
  esl_vec_FNorm(hmm->t[hmm->M] + cp9_TRANS_DELETE_OFFSET, cp9_TRANS_NDELETE);	/* delete */

  /* logoddsify them */
  for(x = 0; x < cp9_NTRANS; x++) hmm->tsc[x][0]      = Prob2Score(hmm->t[0][x],      1.0);
  for(x = 0; x < cp9_NTRANS; x++) hmm->tsc[x][hmm->M] = Prob2Score(hmm->t[hmm->M][x], 1.0);
  hmm->bsc[1]      = Prob2Score(hmm->begin[1],    1.0);
  hmm->esc[hmm->M] = Prob2Score(hmm->end[hmm->M], 1.0);

  /* now for 1..M-1, copy the parameters from the mother's template HMM. */
  for(k = 0; k <= (mother_map->epos-mother_map->spos+1); k++) {
	mk = k + mother_map->spos - 1;
	  if(k > 0) {
	esl_vec_FCopy(mother_cm->cp9->mat[mk], mother_cm->cp9->abc->K,  hmm->mat[k]);
	for(x = 0; x < mother_cm->cp9->abc->Kp; x++) {
	  hmm->msc[x][k] = mother_cm->cp9->msc[x][mk];
	}
	  }
	  esl_vec_FCopy(mother_cm->cp9->ins[mk], mother_cm->cp9->abc->K,  hmm->ins[k]);
	  for(x = 0; x < mother_cm->cp9->abc->Kp; x++) {
	hmm->isc[x][k] = mother_cm->cp9->isc[x][mk];
	  }

	  /* transitions, skip k == 0 and M, we filled them out in cm2hmm_special_trans_cp9() */
	  if(k > 1) {
	  hmm->begin[k]   = 0.;
	  hmm->bsc[k]     = -INFTY;
	  }
	  if(k > 0 && k < hmm->M) {
	/* careful with transitions out of match, we have to renormalize as
	 * we go b/c mother_cm's cp9 has local ends up */
	for(x = cp9_TRANS_MATCH_OFFSET; x < cp9_TRANS_NMATCH; x++) {
	  hmm->t[k][x]   = mother_cm->cp9->t[mk][x]   / (1. - mother_cm->cp9->end[mk]);
	  hmm->tsc[x][k] = Prob2Score(hmm->t[k][x], 1.0);
	}

	/* the rest of the probs/scores we can just copy b/c they're unaffected by local begins/ends */
	esl_vec_FCopy(mother_cm->cp9->t[mk] + cp9_TRANS_INSERT_OFFSET, cp9_NTRANS - cp9_TRANS_INSERT_OFFSET,  hmm->t[k] + cp9_TRANS_INSERT_OFFSET);
	for(x = cp9_TRANS_INSERT_OFFSET; x < cp9_NTRANS; x++) {
	  hmm->tsc[x][k] = mother_cm->cp9->tsc[x][mk];
	}
	hmm->end[k]     = 0.;
	hmm->esc[k]     = -INFTY;
	  }
  }

  /* Ripped out of cp9Logoddsify(),
   * Finally, fill the efficiently reordered transition scores for this HMM. */
  for (k = 0 ; k <= hmm->M; k++) {
	int *otsc_k = hmm->otsc + k*cp9O_NTRANS;
	otsc_k[cp9O_MM] = hmm->tsc[CTMM][k];
	otsc_k[cp9O_MI] = hmm->tsc[CTMI][k];
	otsc_k[cp9O_MD] = hmm->tsc[CTMD][k];
	otsc_k[cp9O_IM] = hmm->tsc[CTIM][k];
	otsc_k[cp9O_II] = hmm->tsc[CTII][k];
	otsc_k[cp9O_DM] = hmm->tsc[CTDM][k];
	otsc_k[cp9O_DD] = hmm->tsc[CTDD][k];
	otsc_k[cp9O_ID] = hmm->tsc[CTID][k];
	otsc_k[cp9O_DI] = hmm->tsc[CTDI][k];
	otsc_k[cp9O_BM] = hmm->bsc[k];
	otsc_k[cp9O_MEL]= hmm->tsc[CTMEL][k];
	otsc_k[cp9O_ME] = hmm->esc[k];
  }

  hmm->flags |= CPLAN9_HASBITS;	/* raise the log-odds ready flag */

  if(debug_level > 1) debug_print_cp9_params(stdout, hmm, TRUE);
  if(do_psi_test) {
	/* Fill phi to check to make sure our HMM is "close enough" to our CM.
	 * phi[k][0..2] is the expected number of times HMM node k state 0 (match), 1(insert),
	 * or 2(delete) is entered. These should be *very close* (within 0.00001) to the psi
	 * values for the CM states that they map to (psi[v] is the expected number of times
	 * state v is entered in the CM).
	 */
	fill_phi_cp9(hmm, &phi, 1, FALSE);
	if((status = check_psi_vs_phi_cp9(cm, errbuf, cp9map, psi, phi, (double) psi_vs_phi_threshold, debug_level)) != eslOK) return status;
	for(k = 0; k <= hmm->M; k++) free(phi[k]);
	free(phi);
  }

  *ret_hmm    = hmm;
  *ret_cp9map = cp9map;

  cm_FreeTransitionMap(tmap);
  free(psi);

  return eslOK;

 ERROR:
  ESL_FAIL(eslEMEM, errbuf, "memory allocation error.");
  return 0; /* NEVERREACHED */
}

/* Function: CPlan9InitEL()
 * Incept:   EPN, Tue Jun 19 13:10:56 2007
 *
 * Purpose:  Initialize a CP9 HMM for possible EL local ends
 *           by determining how the EL states should be connected
 *           based on the CM node topology.
 *
 * Args:     cp9 - the CP9 HMM, built from cm
 *           cm  - the CM the cp9 was built from
 *
 * Return:   (void)
 */
void
CPlan9InitEL(CP9_t *cp9, CM_t *cm)
{
  int status;
  int k;                     /* counter over HMM nodes */
  int nd;
  int *tmp_el_from_ct;

  if(cm->emap == NULL) cm_Fail("CPlan9InitEL() cm->emap is NULL");

  /* First copy the CM el self transition score/probability: */
  cp9->el_self   = sreEXP2(cm->el_selfsc);
  cp9->el_selfsc = Prob2Score(cp9->el_self, 1.0);

  /* For each HMM node k, we can transit FROM >= 0 EL states from
   * HMM nodes kp. Determine how many such valid transitions exist
   * from each node, then allocate and fill cp9->el_from_idx[k] and
   * cp9->el_from_cmnd arrays based on that.
   * This two-pass method saves memory b/c we only allocate for
   * what we'll need.
   */

  /* Initialize to 0 */
  for(k = 0; k <= cp9->M; k++)
	{
	  cp9->el_from_ct[k] = 0;
	  cp9->has_el[k] = FALSE;
	}
  cp9->el_from_ct[(cp9->M+1)] = 0; /* special case, we can get to E state from EL states */

  /* first pass to get number of valid transitions */
  for(nd = 0; nd < cm->nodes; nd++)
	{
	  if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	   cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	   cm->ndtype[nd] == BEGR_nd) &&
	  cm->ndtype[nd+1] != END_nd)
	{
	  /*printf("HMM node %d can be reached from HMM node %d's EL state\n", cm->emap->rpos[nd], cm->emap->lpos[nd]);*/
	  cp9->el_from_ct[cm->emap->rpos[nd]]++;
	  cp9->has_el[cm->emap->lpos[nd]] = TRUE;
	}
	}

  /* allocate cp9->el_from_idx[k], cp9->el_from_cmnd for all k */
  for(k = 0; k <= (cp9->M+1); k++)
	{
	  if(cp9->el_from_idx[k] != NULL) /* if !NULL we already filled it, shouldn't happen */
	cm_Fail("ERROR in CPlan9InitEL() el_from_idx has already been initialized\n");
	  if(cp9->el_from_ct[k] > 0)
	{
	  ESL_ALLOC(cp9->el_from_idx[k], sizeof(int) * cp9->el_from_ct[k]);
	  ESL_ALLOC(cp9->el_from_cmnd[k],sizeof(int) * cp9->el_from_ct[k]);
	}
	  /* else it remains NULL */
	}

  /* now fill in cp9->el_from_idx, we need a new counter array */
  ESL_ALLOC(tmp_el_from_ct, sizeof(int) * (cp9->M+2));
  for(k = 0; k <= (cp9->M+1); k++)
	tmp_el_from_ct[k] = 0;
  for(nd = 0; nd < cm->nodes; nd++)
	{
	  if ((cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd ||
	   cm->ndtype[nd] == MATR_nd || cm->ndtype[nd] == BEGL_nd ||
	   cm->ndtype[nd] == BEGR_nd) &&
	  cm->ndtype[nd+1] != END_nd)
	{
	  k = cm->emap->rpos[nd];
	  cp9->el_from_idx[k][tmp_el_from_ct[k]] = cm->emap->lpos[nd];
	  cp9->el_from_cmnd[k][tmp_el_from_ct[k]] = nd;
	  tmp_el_from_ct[k]++;
	}
	}

  /* Debugging printfs */
  /*  for(k = 0; k <= (cp9->M+1); k++)
	{
	  for(c = 0; c < cp9->el_from_ct[k]; c++)
	printf("cp9->el_from_idx[%3d][%2d]: %4d\n", k, c, cp9->el_from_idx[k][c]);
	  if(cp9->has_el[k])
	  printf("node k:%3d HAS an EL!\n", k);
	  }*/

  /* Free memory and exit */
  free(tmp_el_from_ct);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/*** End of inlined file: cp9_modelmaker.c ***/


/*** Start of inlined file: cp9_mx.c ***/

#include <stdio.h>
#include <stdlib.h>


/*****************************************************************
 *   1. CP9_MX data structure functions,
 *      matrix of integer log odd scores for CP9 HMM alignment/search
 *****************************************************************/

/* Function: CreateCP9Matrix()
 * based on  CreatePlan7Matrix() <-- this function's comments below
 * Purpose:  Create a dynamic programming matrix for standard Forward,
 *           Backward, or Viterbi, with scores kept as scaled log-odds
 *           integers. Keeps 2D arrays compact in RAM in an attempt
 *           to maximize cache hits.
 *
 *           The mx structure can be dynamically grown, if a new
 *           HMM or seq exceeds the currently allocated size. Dynamic
 *           growing is more efficient than an alloc/free of a whole
 *           matrix for every new target. The ResizePlan7Matrix()
 *           call does this reallocation, if needed. Here, in the
 *           creation step, we set up some pads - to inform the resizing
 *           call how much to overallocate when it realloc's.
 *
 * Args:     N     - N+1 rows are allocated, usually N == 1 for
 *                   scanning in memory efficient mode, or N == L, length of sequence.
 *           M     - size of model in nodes
 *
 * Return:   mx
 *           mx is allocated here. Caller frees with FreeCP9Matrix(mx).
 */
CP9_MX *
CreateCP9Matrix(int N, int M)
{
  int status;
  CP9_MX *mx;
  int i;

  ESL_ALLOC(mx,      sizeof(CP9_MX));
  ESL_ALLOC(mx->mmx, sizeof(int *) * (N+1));
  ESL_ALLOC(mx->imx, sizeof(int *) * (N+1));
  ESL_ALLOC(mx->dmx, sizeof(int *) * (N+1));
  ESL_ALLOC(mx->elmx,sizeof(int *) * (N+1));
  /* slightly wasteful, some nodes can't go to EL (for ex: right half of MATPs) */
  ESL_ALLOC(mx->erow,    sizeof(int) * (N+1));
  ESL_ALLOC(mx->mmx_mem, sizeof(int) * ((N+1)*(M+1)));
  ESL_ALLOC(mx->imx_mem, sizeof(int) * ((N+1)*(M+1)));
  ESL_ALLOC(mx->dmx_mem, sizeof(int) * ((N+1)*(M+1)));
  ESL_ALLOC(mx->elmx_mem,sizeof(int) * ((N+1)*(M+1)));

  /* The indirect assignment below looks wasteful; it's actually
   * used for aligning data on 16-byte boundaries as a cache
   * optimization in the fast altivec implementation
   */
  mx->mmx[0] = (int *) mx->mmx_mem;
  mx->imx[0] = (int *) mx->imx_mem;
  mx->dmx[0] = (int *) mx->dmx_mem;
  mx->elmx[0]= (int *) mx->elmx_mem;
  for (i = 1; i <= N; i++)
	{
	  mx->mmx[i] = mx->mmx[0] + (i*(M+1));
	  mx->imx[i] = mx->imx[0] + (i*(M+1));
	  mx->dmx[i] = mx->dmx[0] + (i*(M+1));
	  mx->elmx[i]= mx->elmx[0]+ (i*(M+1));
	}

  mx->M = M;
  mx->rows = N;
  mx->kmin = NULL;
  mx->kmax = NULL;
  mx->ncells_allocated = (M+1) * (N+1);
  mx->ncells_valid     = (M+1) * (N+1);
  mx->size_Mb =  (float) sizeof(CP9_MX);
  mx->size_Mb += (float) (sizeof(int *) * (mx->rows+1) * 4); /* mx->*mx ptrs */
  mx->size_Mb += (float) (sizeof(int)   * (mx->rows+1) * (M+1) * 4); /* mx->*mx_mem */
  mx->size_Mb += (float) (sizeof(int)   * (mx->rows+1));             /* mx->erow */
  mx->size_Mb /= 1000000.;

  return mx;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function: FreeCP9Matrix()
 * based on  FreePlan7Matrix() <-- this function's comments below
 * Purpose:  Free a dynamic programming matrix allocated by CreatePlan7Matrix().
 *
 * Return:   (void)
 */
void
FreeCP9Matrix(CP9_MX *mx)
{
  free (mx->mmx_mem);
  free (mx->imx_mem);
  free (mx->dmx_mem);
  free (mx->elmx_mem);
  free (mx->mmx);
  free (mx->imx);
  free (mx->dmx);
  free (mx->elmx);
  free (mx->erow);
  /* don't free mx->kmin, mx->kmax, they could be used by multiple matrices,
   * kmin and kmax in this structure are just pointers to those arrays */
  free (mx);
}

/* Function: GrowCP9Matrix()
 *
 * Purpose:  Reallocate a CP9 dp matrix, if necessary, for seq for
 *           length N, or 2 rows (if we're scanning in memory
 *           efficient mode, in this case N == 1, nrows = N+1).
 *
 *           Note: unlike HMMER, M never changes, so we only have
 *           to worry about increasing the number of rows if nec.
 *
 *           Returns individual ptrs to the four matrix components
 *           as a convenience.
 *
 *           This function allocates the requested matrix regardless
 *           of it's size.
 *
 *           If kmin and kmax are non-NULL, the matrix will be a p7
 *           HMM banded matrix as defined by bands in kmin, kmax.
 *           In this case N must be length of the sequence. If caller
 *           wants a non-banded CP9 matrix, pass kmin = kmax = NULL.
 *
 * Args:     mx    - an already allocated matrix to grow.
 *           N     - seq length to allocate for; N+1 rows
 *           M     - size of model, contract enforces this must == mx->M
 *           kmin  - OPTIONAL: [0.1..i..N] minimum k for residue i
 *           kmax  - OPTIONAL: [0.1..i..N] maximum k for residue i
 *           mmx, imx, dmx, elmx, erow
 *                 - RETURN: ptrs to four mx components as a convenience
 *
 * Return:   eslOK on success, eslEINCOMPAT if contract is violated,
 *           mx is (re)allocated here.
 */
int
GrowCP9Matrix(CP9_MX *mx, char *errbuf, int N, int M, int *kmin, int *kmax, int ***mmx, int ***imx, int ***dmx, int ***elmx, int **erow)
{
  int status;
  void *p;
  int i;
  int ncells_needed = 0;
  int do_banded;
  int cur_ncells = 0;
  int do_reallocate;

  if(mx->M != M) ESL_FAIL(eslEINCOMPAT, errbuf, "GrowCP9Matrix(), mx->M: %d != M passed in: %d\n", mx->M, M);
  if(N < 0)      ESL_FAIL(eslEINCOMPAT, errbuf, "GrowCP9Matrix(), N: %d < 0\n", N);

  do_banded = (kmin != NULL && kmax == NULL) ?  TRUE : FALSE;
  if(do_banded) {
	for (i = 0; i <= N; i++) ncells_needed += (kmax[i] - kmin[i] + 1);
  }
  else ncells_needed = (N+1) * (M+1);
  do_reallocate = (ncells_needed <= mx->ncells_allocated) ? FALSE : TRUE;

  if(do_reallocate) {
	/* we need more space */
	ESL_RALLOC(mx->mmx,  p, sizeof(int *) * (N+1));
	ESL_RALLOC(mx->imx,  p, sizeof(int *) * (N+1));
	ESL_RALLOC(mx->dmx,  p, sizeof(int *) * (N+1));
	ESL_RALLOC(mx->elmx, p, sizeof(int *) * (N+1));
	ESL_RALLOC(mx->erow, p, sizeof(int)   * (N+1));
	ESL_RALLOC(mx->mmx_mem,  p, sizeof(int) * ncells_needed);
	ESL_RALLOC(mx->imx_mem,  p, sizeof(int) * ncells_needed);
	ESL_RALLOC(mx->dmx_mem,  p, sizeof(int) * ncells_needed);
	ESL_RALLOC(mx->elmx_mem, p, sizeof(int) * ncells_needed);
	mx->ncells_allocated = ncells_needed;

	/* update size */
	mx->size_Mb =  (float) sizeof(CP9_MX);
	mx->size_Mb += (float) (sizeof(int *) * (N+1) * 4);           /* mx->*mx ptrs */
	mx->size_Mb += (float) (sizeof(int)   * (ncells_needed * 4)); /* mx->*mx_mem */
	mx->size_Mb += (float) (sizeof(int)   * (N+1));               /* mx->erow */
	mx->size_Mb /= 1000000.;
  }

  if(do_banded || do_reallocate) { /* rearrange pointers */
	mx->mmx[0]  = mx->mmx_mem;
	mx->imx[0]  = mx->imx_mem;
	mx->dmx[0]  = mx->dmx_mem;
	mx->elmx[0] = mx->elmx_mem;

	if(do_banded) {
	  cur_ncells = kmax[0] - kmin[0] + 1;
	  for (i = 1; i <= N; i++) {
	mx->mmx[i] = mx->mmx[0] + cur_ncells;
	mx->imx[i] = mx->imx[0] + cur_ncells;
	mx->dmx[i] = mx->dmx[0] + cur_ncells;
	mx->elmx[i]= mx->elmx[0]+ cur_ncells;
	cur_ncells += kmax[i] - kmin[i] + 1;
	  }
	}
	else { /* non-banded, we only get here if we didn't go to done, i.e. we reallocated */
	  for (i = 1; i <= N; i++) {
	mx->mmx[i] = mx->mmx[0] + (i*(M+1));
	mx->imx[i] = mx->imx[0] + (i*(M+1));
	mx->dmx[i] = mx->dmx[0] + (i*(M+1));
	mx->elmx[i]= mx->elmx[0]+ (i*(M+1));
	  }
	}
  }

  mx->rows = N;
  mx->kmin = kmin; /* could be NULL */
  mx->kmax = kmax; /* could be NULL */
  mx->ncells_valid = ncells_needed;
  if (mmx != NULL) *mmx = mx->mmx;
  if (imx != NULL) *imx = mx->imx;
  if (dmx != NULL) *dmx = mx->dmx;
  if (elmx!= NULL) *elmx= mx->elmx;
  if (erow != NULL) *erow = mx->erow;
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, ("GrowCP9Matrix(), memory reallocation error."));
}

/* Function: InitializeCP9Matrix()
 * Purpose:  Set all valid cells in a CP9 matrix to -INFTY
 *
 * Return:   (void)
 */
void
InitializeCP9Matrix(CP9_MX *mx)
{
  esl_vec_ISet(mx->mmx_mem, mx->ncells_valid, -INFTY);
  esl_vec_ISet(mx->imx_mem, mx->ncells_valid, -INFTY);
  esl_vec_ISet(mx->dmx_mem, mx->ncells_valid, -INFTY);
  esl_vec_ISet(mx->elmx_mem, mx->ncells_valid, -INFTY);
  esl_vec_ISet(mx->erow, mx->rows, -INFTY);
  return;
}

/*** End of inlined file: cp9_mx.c ***/


/*** Start of inlined file: cp9_trace.c ***/
/* cp9_trace.c
 * EPN, Wed Dec  5 13:05:17 2007
 *
 * Note: all of these functions originated in cp9.c [EPN 02.27.06]
 *
 * Support for the CM Plan 9 HMM trace CP9trace_t structure.
 * This was based heavily on HMMER's 2.x data structures.
 *
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <math.h>


/* Function: CP9AllocTrace(), CP9ReallocTrace(), CP9FreeTrace()
 *
 * Purpose:  allocation and freeing of traceback structures
 */
void
CP9AllocTrace(int tlen, CP9trace_t **ret_tr)
{
  int status;
  CP9trace_t *tr;

  ESL_ALLOC(tr, sizeof(CP9trace_t));
  ESL_ALLOC(tr->statetype, sizeof(char) * tlen);
  ESL_ALLOC(tr->nodeidx,   sizeof(int)  * tlen);
  ESL_ALLOC(tr->pos,       sizeof(int)  * tlen);
  *ret_tr = tr;
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}
void
CP9ReallocTrace(CP9trace_t *tr, int tlen)
{
  int status;
  void *tmp;

  ESL_RALLOC(tr->statetype, tmp, tlen * sizeof(char));
  ESL_RALLOC(tr->nodeidx,   tmp, tlen * sizeof(int));
  ESL_RALLOC(tr->pos,       tmp, tlen * sizeof(int));
  return;

 ERROR:
  cm_Fail("Memory reallocation error.");
}
void
CP9FreeTrace(CP9trace_t *tr)
{
  if (tr == NULL) return;
  free(tr->pos);
  free(tr->nodeidx);
  free(tr->statetype);
  free(tr);
}

/* Function: CP9_fake_tracebacks()
 *
 * Purpose:  From a consensus assignment of columns to MAT/INS, construct fake
 *           tracebacks for each individual sequence.
 *
 * Args:     msa       - msa alignment
 *           matassign - assignment of column 1 if MAT, 0 if INS;
 *                       [1..alen] (off one from aseqs)
 *           ret_tr    - RETURN: array of tracebacks
 *
 * Return:   (void)
 *           ret_tr is alloc'ed here. Caller must free.
 */
void
CP9_fake_tracebacks(ESL_MSA *msa, int *matassign, CP9trace_t ***ret_tr)
{
  if(! (msa->flags & eslMSA_DIGITAL))
	cm_Fail("ERROR in CP9_fake_tracebacks(), msa should be digitized.\n");

  int  status;
  CP9trace_t **tr;
  int  idx;                     /* counter over sequences          */
  int  i;                       /* position in raw sequence (1..L) */
  int  k;                       /* position in HMM                 */
  int  apos;                    /* position in alignment columns   */
  int  tpos;			/* position in traceback           */
  int  first_match;             /* first match column */
  /*int  last_match;*/              /* last match column, not used */

  ESL_ALLOC(tr, sizeof(CP9trace_t *) * msa->nseq);

  first_match = -1;
  /*last_match  = -1;*/
  for (apos = 0; apos < msa->alen; apos++)
	{
	  if(matassign[apos+1] && first_match == -1) first_match = apos;
	  /*if(matassign[apos+1]) last_match = apos;*/
	}

  for (idx = 0; idx < msa->nseq; idx++)
	{
	  CP9AllocTrace(msa->alen+2, &tr[idx]);  /* allow room for B & E */

				/* all traces start with M_0 state (the B state)... */
	  tr[idx]->statetype[0] = CSTB;
	  tr[idx]->nodeidx[0]   = 0;
	  tr[idx]->pos[0]       = 0;

	  i = 1;
	  k = 0;
	  tpos = 1;

	  for (apos = 0; apos < msa->alen; apos++)
		{
	  tr[idx]->statetype[tpos] = CSTBOGUS; /* bogus, deliberately, to debug */

	  if (matassign[apos+1] && !(esl_abc_XIsGap(msa->abc, msa->ax[idx][(apos+1)])))
	  {			/* MATCH */
	      k++;		/* move to next model pos */
	      tr[idx]->statetype[tpos] = CSTM;
	      tr[idx]->nodeidx[tpos]   = k;
	      tr[idx]->pos[tpos]       = i;
	      i++;
	      tpos++;
	    }
		  else if (matassign[apos+1])
			{                   /* DELETE */
	      /* We should be careful about S/W transitions; but we have
	       * an ambiguity, based on the MSA, we can't tell if we
	       * did a local begin (some M->E transition) or if we
	       * went through a bunch of D state's before the first match
	       * B->D_1 -> D_2 .... -> M_x. For now, we assume we're not in
	       * S/W mode, and treat it as the latter case, see
	       * HMMER's modelmaker.c:fake_tracebacks() for code
	       * on one *would* implement the S/W consideration IF
	       * there wasn't a B->D_1 transition allowed.
	       */
	      k++;		/* *always* move on model when match column seen */
	      tr[idx]->statetype[tpos] = CSTD;
	      tr[idx]->nodeidx[tpos]   = k;
	      tr[idx]->pos[tpos]       = 0;
	      tpos++;
			}
	  else if (! (esl_abc_XIsGap(msa->abc, msa->ax[idx][(apos+1)])))
	    {			/* INSERT */
	      tr[idx]->statetype[tpos] = CSTI;
			  tr[idx]->nodeidx[tpos]   = k;
			  tr[idx]->pos[tpos]       = i;
	      i++;
	      tpos++;
	    }
	}
	   /* all traces end with E state */
	  /* We should be careful about S/W transitions; but we have
	   * an ambiguity, based on the MSA, we can't tell if we
	   * did a local end (some M->E transition) or if we
	   * went through a bunch of D state's before the final
	   * D_M -> E transition. For now, we assume we're not in
	   * S/W mode, and treat it as the latter case, see
	   * HMMER's modelmaker.c:fake_tracebacks() for code
	   * on one *would* implement the S/W consideration IF
	   * there wasn't a D_M -> E transition allowed.
	   */
	  tr[idx]->statetype[tpos] = CSTE;
	  tr[idx]->nodeidx[tpos]   = 0;
	  tr[idx]->pos[tpos]       = 0;
	  tpos++;
	  tr[idx]->tlen = tpos;
	}    /* end for sequence # idx */

  *ret_tr = tr;
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function: CP9TraceCount()
 * EPN 09.04.06 based on Eddy's P7TraceCount() from HMMER's trace.c
 *
 * Purpose:  Count a traceback into a count-based HMM structure.
 *           (Usually as part of a model parameter re-estimation.)
 *           Traceback should not have any EL state visits in it.
 *
 * Args:     hmm   - counts-based CM Plan 9 HMM
 *           dsq   - sequence that traceback aligns to the HMM (1..L)
 *           wt    - weight on the sequence
 *           tr    - alignment of seq to HMM
 *
 * Return:   (void)
 */
void
CP9TraceCount(CP9_t *hmm, ESL_DSQ *dsq, float wt, CP9trace_t *tr)
{
  /* contract check */
  if(dsq == NULL)            cm_Fail("ERROR in CP9TraceCount(), dsq is NULL.");
  if(hmm->flags & CPLAN9_EL) cm_Fail("CP9TraceCount(), EL states are on, which this function is not setup for.");

  int tpos;                     /* position in tr */
  int i;			/* symbol position in seq */

  for (tpos = 0; tpos < tr->tlen; tpos++)
	{
	  i = tr->pos[tpos];

	  /* Emission counts.
	   */
	  if (tr->statetype[tpos] == CSTM)
	esl_abc_FCount(hmm->abc, hmm->mat[tr->nodeidx[tpos]], dsq[i], wt);
	  else if (tr->statetype[tpos] == CSTI)
	esl_abc_FCount(hmm->abc, hmm->ins[tr->nodeidx[tpos]], dsq[i], wt);

	  /* State transition counts
	   */
	  switch (tr->statetype[tpos]) {
	  case CSTB:
	switch (tr->statetype[tpos+1]) {
	case CSTM: hmm->begin[tr->nodeidx[tpos+1]] += wt; break;
	case CSTI: hmm->t[0][CTMI]                 += wt; break;
	case CSTD: hmm->t[0][CTMD]                 += wt; break;
	default:
	  cm_Fail("illegal state transition %s->%s in traceback",
	      CP9Statetype(tr->statetype[tpos]),
	      CP9Statetype(tr->statetype[tpos+1]));
	}
	break;
	  case CSTM:
	switch (tr->statetype[tpos+1]) {
	case CSTM: hmm->t[tr->nodeidx[tpos]][CTMM] += wt; break;
	case CSTI: hmm->t[tr->nodeidx[tpos]][CTMI] += wt; break;
	case CSTD: hmm->t[tr->nodeidx[tpos]][CTMD] += wt; break;
	case CSTE: hmm->end[tr->nodeidx[tpos]]     += wt; break;
	default:
	  cm_Fail("illegal state transition %s->%s in traceback",
	      CP9Statetype(tr->statetype[tpos]),
	      CP9Statetype(tr->statetype[tpos+1]));
	}
	break;
	  case CSTI:
	switch (tr->statetype[tpos+1]) {
	case CSTM: hmm->t[tr->nodeidx[tpos]][CTIM] += wt; break;
	case CSTI: hmm->t[tr->nodeidx[tpos]][CTII] += wt; break;
	case CSTD: hmm->t[tr->nodeidx[tpos]][CTID] += wt; break;
	case CSTE:
	  /* This should only happen from the final insert (I_M) state */
	  if((tpos+1) != (tr->tlen-1))
	    cm_Fail("illegal state transition %s->%s (I is not final insert) in traceback",
		CP9Statetype(tr->statetype[tpos]),
		CP9Statetype(tr->statetype[tpos+1]));
	  hmm->t[tr->nodeidx[tpos]][CTIM] += wt; break;
	  break;
	default:
	  cm_Fail("illegal state transition %s->%s in traceback",
	      CP9Statetype(tr->statetype[tpos]),
	      CP9Statetype(tr->statetype[tpos+1]));
	}
	break;
	  case CSTD:
	switch (tr->statetype[tpos+1]) {
	case CSTM: hmm->t[tr->nodeidx[tpos]][CTDM] += wt; break;
	case CSTI: hmm->t[tr->nodeidx[tpos]][CTDI] += wt; break;
	case CSTD: hmm->t[tr->nodeidx[tpos]][CTDD] += wt; break;
	case CSTE:
	  /* This should only happen from the final delete (D_M) state */
	  if((tpos+1) != (tr->tlen-1))
	    cm_Fail("illegal state transition %s->%s (D is not final delete) in traceback",
		CP9Statetype(tr->statetype[tpos]),
		CP9Statetype(tr->statetype[tpos+1]));
	  hmm->t[tr->nodeidx[tpos]][CTDM] += wt; break;
	  break;
	default:
	  cm_Fail("illegal state transition %s->%s in traceback",
	      CP9Statetype(tr->statetype[tpos]),
	      CP9Statetype(tr->statetype[tpos+1]));
	}
	break;
	  case CSTEL:
	cm_Fail("EL in traceback in CP9TraceCount(), this function is being abused.");
	break;
	  case CSTE:
	break; /* E is the last. It makes no transitions. */

	  default:
	cm_Fail("illegal state %s in traceback",
	    CP9Statetype(tr->statetype[tpos]));
	  }
	}
}

/* Function: CP9TraceScore()
 *           based on HMMER 2.3.2's P7TraceScore by SRE
 *
 * Purpose:  Score a traceback and return the score in scaled bits.
 * Incept:   EPN, Wed May 30 06:07:14 2007
 *
 * Args:     hmm   - HMM with valid log odds scores.
 *           dsq   - digitized sequence that traceback aligns to the HMM (1..sq->n)
 *           tr    - alignment of seq to HMM
 *
 * Return:   (void)
 */
float
CP9TraceScore(CP9_t *hmm, ESL_DSQ *dsq, CP9trace_t *tr)
{
  int score;			/* total score as a scaled integer */
  int tpos;                     /* position in tr */
  char sym;		        /* digitized symbol in dsq */

  /* Contract check */
  if(dsq == NULL)
	cm_Fail("ERROR in CP9TraceScore, dsq is NULL.");

  /*CP9PrintTrace(stdout, tr, hmm, sq); */
  score = 0;
  for (tpos = 0; tpos < tr->tlen-1; tpos++)
	{
	  sym = dsq[tr->pos[tpos]];

	  /* Emissions from M and I states.
	   */
	  if (tr->statetype[tpos] == CSTM)
	score += hmm->msc[(int) sym][tr->nodeidx[tpos]];
	  else if (tr->statetype[tpos] == CSTI)
	score += hmm->isc[(int) sym][tr->nodeidx[tpos]];

	  /* State transitions. Including EL emissions, EL emits on transition
	   */
	  score += CP9TransitionScoreLookup(hmm,
					tr->statetype[tpos], tr->nodeidx[tpos],
					tr->statetype[tpos+1], tr->nodeidx[tpos+1]);
	}
  return Scorify(score);
}

/* Function: CP9Statetype()
 *
 * Purpose:  Returns the state type in text.
 * Example:  CP9Statetype(M) = "M"
 */
char *
CP9Statetype(char st)
{
  switch (st) {
  case CSTM: return "M";
  case CSTD: return "D";
  case CSTI: return "I";
  case CSTB: return "B";
  case CSTE: return "E";
  case CSTEL: return "L";
  default: return "BOGUS";
  }
}

/* Function: CP9PrintTrace()
 *           based on HMMER's 2.3.2 P7PrintTrace()
 *
 * Purpose:  Print out a traceback structure.
 *           If hmm is non-NULL, also print transition and emission scores.
 * Incept:   EPN, Wed May 30 06:07:57 2007
 *
 * Args:     fp  - stderr or stdout, often
 *           tr  - trace structure to print
 *           hmm - NULL or hmm containing scores to print
 *           dsq - NULL or digitized sequence trace refers to.
 */
void
CP9PrintTrace(FILE *fp, CP9trace_t *tr, CP9_t *hmm, ESL_DSQ *dsq)
{
  /* Contract check */
  if((dsq != NULL) && (hmm == NULL))
	cm_Fail("ERROR in CP9PrintTrace, dsq is non-NULL but HMM is NULL.\n");

  int          tpos;		/* counter for trace position */
  unsigned int sym;
  int          sc;

  if (tr == NULL) {
	fprintf(fp, " [ trace is NULL ]\n");
	return;
  }

  if (hmm == NULL) {
	fprintf(fp, "st  node   rpos  - traceback len %d\n", tr->tlen);
	fprintf(fp, "--  ---- ------\n");
	for (tpos = 0; tpos < tr->tlen; tpos++) {
	  fprintf(fp, "%1s  %4d %6d\n",
	      CP9Statetype(tr->statetype[tpos]),
	      tr->nodeidx[tpos],
	      tr->pos[tpos]);
	}
  } else {
	if (!(hmm->flags & CPLAN9_HASBITS))
	  cm_Fail("oi, you can't print scores from that hmm, it's not ready.");

	sc = 0;
	fprintf(fp, "st  node   rpos  transit emission - traceback len %d\n", tr->tlen);
	fprintf(fp, "--  ---- ------  ------- --------\n");
	for (tpos = 0; tpos < tr->tlen; tpos++) {
	  if (dsq != NULL) sym = dsq[tr->pos[tpos]];

	  fprintf(fp, "%1s  %4d %6d  %7d",
	      CP9Statetype(tr->statetype[tpos]),
	      tr->nodeidx[tpos],
	      tr->pos[tpos],
	      (tpos < tr->tlen-1) ?
	      CP9TransitionScoreLookup(hmm, tr->statetype[tpos], tr->nodeidx[tpos],
				    tr->statetype[tpos+1], tr->nodeidx[tpos+1]) : 0);

	  if (tpos < tr->tlen-1)
	sc += CP9TransitionScoreLookup(hmm, tr->statetype[tpos], tr->nodeidx[tpos],
				       tr->statetype[tpos+1], tr->nodeidx[tpos+1]);

	  if (dsq != NULL) {
	if (tr->statetype[tpos] == CSTM)
	  {
	    fprintf(fp, " %8d %c", hmm->msc[(int) sym][tr->nodeidx[tpos]],
		    hmm->abc->sym[(int) sym]);
	    sc += hmm->msc[(int) sym][tr->nodeidx[tpos]];
	  }
	else if (tr->statetype[tpos] == CSTI)
	  {
	    fprintf(fp, " %8d %c", hmm->isc[(int) sym][tr->nodeidx[tpos]],
		    (char) tolower((int) hmm->abc->sym[(int) sym]));
	    sc += hmm->isc[(int) sym][tr->nodeidx[tpos]];
	  }
	else if (tr->statetype[tpos] == CSTEL)
	  {
	    if(tr->statetype[tpos-1] == CSTEL) /* we will emit on self transit */
	      {
		fprintf(fp, " %8d %c", 0,
			(char) tolower((int) hmm->abc->sym[(int) sym]));
	      }
	    else /* we just entered EL, no emission */
	      {
		fprintf(fp, " %8s %c", "-", '-');
	      }
	  }
	  } else {
	fprintf(fp, " %8s %c", "-", '-');
	  }

	  fputs("\n", fp);
	}
	fprintf(fp, "                 ------- --------\n");
	fprintf(fp, "           total: %6d\n\n", sc);
  }
}

/* Function: CP9TransitionScoreLookup()
 *           based on HMMER's 2.3.2 function of same name
 *
 * Incept:   EPN, Wed May 30 06:09:04 2007
 * Purpose:  Convenience function used in CP9PrintTrace() and CP9TraceScore();
 *           given state types and node indices for a transition,
 *           return the integer score for that transition.
 */
int
CP9TransitionScoreLookup(CP9_t *hmm, char st1, int k1,
			 char st2, int k2)
{
  switch (st1) {
  case CSTB:
	switch (st2) {
	case CSTM: return hmm->bsc[k2];
	case CSTI: return hmm->tsc[CTMI][0];
	case CSTD: return hmm->tsc[CTMD][0];
	default:      cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	}
	break;
  case CSTM:
	switch (st2) {
	case CSTM: return hmm->tsc[CTMM][k1];
	case CSTI: return hmm->tsc[CTMI][k1];
	case CSTD: return hmm->tsc[CTMD][k1];
	case CSTE: return hmm->esc[k1];
	case CSTEL: return hmm->tsc[CTMEL][k1];
	default:      cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	}
	break;
  case CSTI:
	switch (st2) {
	case CSTM: return hmm->tsc[CTIM][k1];
	case CSTI: return hmm->tsc[CTII][k1];
	case CSTD: return hmm->tsc[CTID][k1];
	case CSTE: return hmm->tsc[CTIM][k1]; /* This should only happen from the final insert (I_M) state */
	default:      cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	}
	break;
  case CSTD:
	switch (st2) {
	case CSTM: return hmm->tsc[CTDM][k1];
	case CSTI: return hmm->tsc[CTDI][k1];
	case CSTD: return hmm->tsc[CTDD][k1];
	case CSTE: return hmm->tsc[CTDM][k1]; /* This should only happen from the final delete (D_M) state */
	default:      cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	}
	break;
  case CSTEL:
	switch (st2) {
	case CSTM: return 0; /* transition to EL penalty incurred when M->EL transition takes place */
	case CSTE: return 0; /* transition to EL penalty incurred when M->EL transition takes place */
	case CSTEL: return hmm->el_selfsc; /* penalty for EL->EL self transition loop */
	default:      cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	}
	break;
  case CSTE: /* this should never happen, it means we transitioned from E, which is not
	      * allowed. */
	cm_Fail("illegal %s->%s transition", CP9Statetype(st1), CP9Statetype(st2));
	break;
  default:        cm_Fail("illegal state %s in traceback", CP9Statetype(st1));
  }
  /*NOTREACHED*/
  return 0;
}

/* Function: CP9ViterbiTrace()
 * Date:     EPN, Wed May 30 17:32:05 2007
 *           based on HMMER 2.3.2's P7ViterbiTrace()
 *
 * Purpose:  Traceback of a Viterbi matrix: i.e. retrieval
 *           of optimum alignment.
 *
 * Args:     hmm    - hmm, log odds form, used to make mx
 *           dsq    - sequence aligned to (digital form) 1..L
 *           i0     - first residue of sequence, often 1
 *           j0     - last residue of sequence, often L
 *           mx     - the matrix to trace back in, L x hmm->M
 *           ret_tr - RETURN: traceback.
 *
 * Return:   (void)
 *           ret_tr is allocated here. Free using CP9FreeTrace().
 */
void
CP9ViterbiTrace(CP9_t *hmm, ESL_DSQ *dsq, int i0, int j0,
		CP9_MX *mx, CP9trace_t **ret_tr)
{
  /* contract check */
  if(dsq == NULL)
	cm_Fail("ERROR in CP9ViterbiTrace(), dsq is NULL.");

  CP9trace_t *tr;
  int curralloc;		/* current allocated length of trace */
  int tpos;			/* position in trace */
  int i;			/* position in seq (1..N) */
  int k;			/* position in model (1..M) */
  int *erow, **mmx, **imx, **dmx, **elmx;
  int sc;			/* temp var for pre-emission score */
  int error_flag;
  int c;                        /* counter over possible EL states */

  /* Overallocate for the trace.
   * B- ... - E  : 2 states + N is minimum trace;
   * add N more as buffer.
   */
  curralloc = (j0-i0+1) * 2 + 2;
  CP9AllocTrace(curralloc, &tr);

  mmx = mx->mmx;
  imx = mx->imx;
  dmx = mx->dmx;
  elmx= mx->elmx;
  erow= mx->erow;

  /* Initialization of trace
   * We do it back to front; ReverseTrace() is called later.
   */
  tr->statetype[0] = CSTE;
  tr->nodeidx[0]   = 0;
  tr->pos[0]       = 0;
  tpos = 1;
  i    = j0;			/* current i (seq pos) we're trying to assign */

  /* Traceback
   */
  while (tr->statetype[tpos-1] != CSTB) {
	error_flag = FALSE;
	switch (tr->statetype[tpos-1]) {
	case CSTM:			/* M connects from i-1,k-1, B or an EL*/
	  /*printf("CSTM k: %d i:%d \n", k, i);*/
	  sc = mmx[i+1][k+1] - hmm->msc[dsq[i+1]][k+1];
	  if (sc <= -INFTY) { CP9FreeTrace(tr); *ret_tr = NULL; return; }
	  else if (sc == mmx[i][k] + hmm->tsc[CTMM][k])
	{
	  tr->statetype[tpos] = CSTM;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = i--;
	}
	  else if (sc == imx[i][k] + hmm->tsc[CTIM][k])
	{
	  tr->statetype[tpos] = CSTI;
	  tr->nodeidx[tpos]   = k;
	  tr->pos[tpos]       = i--;
	}
	  else if (sc == dmx[i][k] + hmm->tsc[CTDM][k])
	{
	  tr->statetype[tpos] = CSTD;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = 0;
	}
	  else /* Check if we came from an EL state (could be more than 1 choice) */
	{
	  error_flag = TRUE;
	  /* note we look at el_from_ct[k+1] not k for same reason we look
	   * at bsc[k+1] above, we're going backwards, this is a tricky off-by-one */
	  for(c = 0; c < hmm->el_from_ct[k+1]; c++) /* el_from_ct[k+1] is >= 0 */
	    {
	      /* transition penalty to EL incurred when EL was entered */
	      if(sc == elmx[i][hmm->el_from_idx[k+1][c]])
		{
		  tr->statetype[tpos] = CSTEL;
		  k = hmm->el_from_idx[(k+1)][c];
		  tr->nodeidx[tpos]   = k;
		  tr->pos[tpos]       = i--;
		  error_flag = FALSE;
		  break;
		}
	    }
	}
	  if(error_flag)
	{
	  /* one last possibility, we came from B, check this last, in
	   * case hmm->bsc[k+1] happens to be identical to sc but
	   * we're not done the parse yet (i.e. one of the cases
	   * above equaled sc). */
	  if (sc == hmm->bsc[k+1])
	    {
	      tr->statetype[tpos] = CSTB;
	      tr->nodeidx[tpos]   = 0;
	      tr->pos[tpos]       = 0;
	      if(tr->pos[tpos-1] != 1)
		cm_Fail("traceback failed: premature begin");
	      error_flag = FALSE;
	    }
	}
	  if(error_flag)
	cm_Fail("traceback failed");
	  break;

	case CSTD:			/* D connects from M,D,I, (D_1 also connects from B (M_0) */
	  /*printf("CSTD k: %d i:%d \n", k, i);*/
	   sc = dmx[i][k+1];
	   if (sc <= -INFTY) { CP9FreeTrace(tr); *ret_tr = NULL; return; }
	   else if(k == 0) /* D_1 connects from B(M_0), and I_0, when k == 0, we're dealing with D_1, a confusing off-by-one */
	{
	  if(sc == mmx[i][k] + hmm->tsc[CTMD][k])
	    {
	      tr->statetype[tpos] = CSTB;
	      tr->nodeidx[tpos]   = 0;
	      tr->pos[tpos]       = 0;
	    }
	  else if (sc == imx[i][k] + hmm->tsc[CTID][k])
	    {
	      tr->statetype[tpos] = CSTI;
	      tr->nodeidx[tpos]   = k;
	      tr->pos[tpos]       = i--;
	    }
	  else cm_Fail("traceback failed");
	} /* else k != 0 */
	  else if (sc == mmx[i][k] + hmm->tsc[CTMD][k])
	{
	  tr->statetype[tpos] = CSTM;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = i--;
	}
	  else if (sc == imx[i][k] + hmm->tsc[CTID][k])
	{
	  tr->statetype[tpos] = CSTI;
	  tr->nodeidx[tpos]   = k;
	  tr->pos[tpos]       = i--;
	}
	  else if (sc == dmx[i][k] + hmm->tsc[CTDD][k])
	{
	  tr->statetype[tpos] = CSTD;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = 0;
	}
	  else cm_Fail("traceback failed");
	  break;

	case CSTI:			/* I connects from M,I,D, (I_0 connects from B also(*/
	  /*printf("CSTI k: %d i:%d \n", k, i);*/
	  sc = imx[i+1][k] - hmm->isc[dsq[i+1]][k];
	  if (sc <= -INFTY) { CP9FreeTrace(tr); *ret_tr = NULL; return; }
	  else if(k == 0) /* I_0 connects from B(M_0), and I_0 */
	{
	  if(sc == mmx[i][k] + hmm->tsc[CTMI][k])
	    {
	      tr->statetype[tpos] = CSTB;
	      tr->nodeidx[tpos]   = 0;
	      tr->pos[tpos]       = 0;
	    }
	  else if (sc == imx[i][k] + hmm->tsc[CTII][k])
	    {
	      tr->statetype[tpos] = CSTI;
	      tr->nodeidx[tpos]   = k;
	      tr->pos[tpos]       = i--;
	    }
	}
	  /* else k != 0 */
	  else if (sc == mmx[i][k] + hmm->tsc[CTMI][k])
	{
	  tr->statetype[tpos] = CSTM;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = i--;
	}

	  else if (sc == imx[i][k] + hmm->tsc[CTII][k])
	{
	  tr->statetype[tpos] = CSTI;
	  tr->nodeidx[tpos]   = k;
	  tr->pos[tpos]       = i--;
	}
	  else if (sc == dmx[i][k] + hmm->tsc[CTDI][k])
	{
	  tr->statetype[tpos] = CSTD;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = 0;
	}
	  else cm_Fail("traceback failed");
	  break;

	case CSTE:			/* E connects from any M state. k set here
				 * also can connect from I_M or D_M (diff from p7)
				 * or even EL_M if it exists */
	  if (erow[i] <= -INFTY) { CP9FreeTrace(tr); *ret_tr = NULL; return; }
	  if (erow[i] == imx[i][hmm->M] + hmm->tsc[CTIM][hmm->M])
	{
	  k = hmm->M;
	  tr->statetype[tpos] = CSTI;
	  tr->nodeidx[tpos]   = k;
	  tr->pos[tpos]       = i--;
	}
	  else if (erow[i] == dmx[i][hmm->M] + hmm->tsc[CTDM][hmm->M])
	{
	  k = hmm->M;
	  tr->statetype[tpos] = CSTD;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = 0;
	}
	  else
	{
	  error_flag = TRUE;
	  for (k = hmm->M; k >= 1; k--)
	    if (erow[i] == mmx[i][k] + hmm->esc[k])
	      {
		tr->statetype[tpos] = CSTM;
		tr->nodeidx[tpos]   = k--;
		tr->pos[tpos]       = i--;
		error_flag = FALSE;
		break;
	      }
	  if(error_flag)
	    {
	      /* Check if we came from an EL state (could be more than 1 choice) */
	      /* hmm->el_from-ct[hmm->M+1] is # of ELs that can transit to E (END) */
	      for(c = hmm->el_from_ct[hmm->M+1]-1; c >= 0; c--) /* el_from_ct[] is >= 0 */
		{
		  /* transition penalty to EL incurred when EL was entered */
		  if(erow[i] == elmx[i][hmm->el_from_idx[hmm->M+1][c]])
		    {
		      tr->statetype[tpos] = CSTEL;
		      k = hmm->el_from_idx[(hmm->M+1)][c];
		      tr->nodeidx[tpos]   = k;
		      tr->pos[tpos]       = i--;
		      error_flag = FALSE;
		      break;
		    }
		}
	    }
	}
	  if (k < 0 || error_flag) cm_Fail("traceback failed");
	  break;

	case CSTEL:			/* EL connects from certain M states and itself */
	  /*printf("CSTEL k: %d i:%d \n", k, i);*/
	  /* check if we are staying in the EL */
	  sc = elmx[i+1][k];
	  if (sc == elmx[i][k] + hmm->el_selfsc) /* i >= 2, first residue must be emitted by a match, not an EL */
	{
	  tr->statetype[tpos] = CSTEL;
	  tr->nodeidx[tpos]   = k;
	  tr->pos[tpos]       = i--;
	}
	  else if(sc  == mmx[i+1][k]   + hmm->tsc[CTMEL][k])    /* M->EL->M with 0 self loops in EL */
	{
	  tr->statetype[tpos] = CSTM;
	  tr->nodeidx[tpos]   = k--;
	  tr->pos[tpos]       = i+1; /* special case, we decremented i prematurely b/c we
				      * had no way of knowing it was our last visit to EL, before
				      * we went to M (since we're working backwards this is actually
				      * the first visit to EL).
				      */
	}
	  else cm_Fail("traceback failed");
	  break;

	default:
	  cm_Fail("traceback failed");

	} /* end switch over statetype[tpos-1] */

	tpos++;
	if (tpos == curralloc)
	  {				/* grow trace if necessary  */
	curralloc += (j0-i0+1);
	CP9ReallocTrace(tr, curralloc);
	  }

  } /* end traceback, at S state; tpos == tlen now */
  tr->tlen = tpos;
  CP9ReverseTrace(tr);

  *ret_tr = tr;
}

/* Function: CP9ReverseTrace()
 * Date:     EPN, Wed May 30 17:52:18 2007
 *           identical to SRE's P7ReverseTrace() from HMMER 2.3.2
 *
 * Purpose:  Reverse the arrays in a traceback structure.
 *           Tracebacks from Forward() and Viterbi() are
 *           collected backwards, and call this function
 *           when they're done.
 *
 *           It's possible to reverse the arrays in place
 *           more efficiently; but the realloc/copy strategy
 *           has the advantage of reallocating the trace
 *           into the right size of memory. (Tracebacks
 *           overallocate.)
 *
 * Args:     tr - the traceback to reverse. tr->tlen must be set.
 *
 * Return:   (void)
 *           tr is modified.
 */
void
CP9ReverseTrace(CP9trace_t *tr)
{
  int    status;
  char  *statetype;
  int   *nodeidx;
  int   *pos;
  int    opos, npos;

  /* Allocate
   */
  ESL_ALLOC(statetype, sizeof(char)* tr->tlen);
  ESL_ALLOC(nodeidx,   sizeof(int) * tr->tlen);
  ESL_ALLOC(pos,       sizeof(int) * tr->tlen);

  /* Reverse the trace.
   */
  for (opos = tr->tlen-1, npos = 0; npos < tr->tlen; npos++, opos--)
	{
	  statetype[npos] = tr->statetype[opos];
	  nodeidx[npos]   = tr->nodeidx[opos];
	  pos[npos]       = tr->pos[opos];
	}

  /* Swap old, new arrays.
   */
  free(tr->statetype);
  free(tr->nodeidx);
  free(tr->pos);
  tr->statetype = statetype;
  tr->nodeidx   = nodeidx;
  tr->pos       = pos;
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function: CP9Traces2Alignment()
 *           based on SRE's P7Traces2Alignment() from HMMER 2.3.2
 *
 * Purpose:  Convert an array of traceback structures for a set
 *           of sequences into a new multiple alignment. Modified
 *           from HMMER to account for possible EL local-end
 *           insertions (which don't exist in P7). Including EL
 *           insertions requires an emit map from the CM.
 *
 *           Insertions/ELs are put into lower case and
 *           are not aligned; instead, Nterm is right-justified,
 *           Cterm is left-justified, and internal insertions
 *           are split in half and the halves are justified in
 *           each direction (the objective being to increase
 *           the chances of getting insertions aligned well enough
 *           for them to become a match). SAM gap char conventions
 *           are used: - in match columns, . in insert columns
 *
 * Args:     cm         - the CM the CP9 was built from, needed to get emitmap,
 *                        so we know where to put EL transitions
 *           cp9        - the CP9 used to determine the traces (cm->cp9loc or cm->cp9glb)
 *           abc        - alphabet to use to create the return MSA
 *           sq         - sequences
 *           wgt        - weights for seqs, NULL for none
 *           nseq       - number of sequences
 *           tr         - array of tracebacks
 *           do_full    - TRUE to always include all match columns in alignment
 *           do_matchonly - TRUE to ONLY include match columns
 *           ret_msa    - MSA, alloc'ed created here
 *
 * Return:   eslOK on succes, eslEMEM on memory error.
 *           MSA structure in ret_msa, caller responsible for freeing.
 */
int
CP9Traces2Alignment(CM_t *cm, CP9_t *cp9, const ESL_ALPHABET *abc, ESL_SQ **sq, float *wgt,
		    int nseq, CP9trace_t **tr, int do_full, int do_matchonly,
		    ESL_MSA **ret_msa)
{
  int status;                   /* easel status flag */
  ESL_MSA   *msa;               /* RETURN: new alignment */
  int    idx;                   /* counter for sequences */
  int    alen;                  /* width of alignment */
  int   *maxins = NULL;         /* array of max inserts between aligned columns */
  int   *maxels = NULL;         /* array of max ELs emissions between aligned columns */
  int   *matmap = NULL;         /* matmap[k] = apos of match k [1..M] */
  int    nins;                  /* counter for inserts */
  int    cpos;                  /* HMM node, consensus position */
  int    apos;                  /* position in aligned sequence (0..alen-1)*/
  int    rpos;                  /* position in raw digital sequence (1..L)*/
  int    tpos;                  /* position counter in traceback */
  int    epos;                  /* position ctr for EL insertions */
  int    statetype;		/* type of current state, e.g. STM */
  CMEmitMap_t *emap = NULL;     /* consensus emit map for the CM */
  int         *imap = NULL;     /* first apos for an insert following a cpos */
  int         *elmap = NULL;    /* first apos for an EL following a cpos */
  int         *matuse = NULL;   /* TRUE if we need a cpos in mult alignment */
  int         *eluse = NULL;    /* TRUE if we have an EL after cpos in alignment */
  int        **eposmap = NULL;  /* [seq idx][CP9 node idx] where each EL should emit to */
  int         *iuse = NULL;     /* TRUE if we have an I after cpos in alignment */
  CMConsensus_t *con = NULL;    /* consensus information for the CM */
  int          next_match;      /* used for filling eposmap */
  int          c;               /* counter over possible EL froms */
  int         *insleft;         /* [0..cpos..clen] TRUE if inserts *following* cpos should be flush right */
  int          nd;              /* counter over nodes */
  int          max_ins_or_el[2];/* for regularizing (splitting) inserts */
  int          pass_offset[2];  /* for regularizing (splitting) inserts */
  int          pass;            /* for regularizing (splitting) inserts */
  char         errbuf[eslERRBUFSIZE];

  /* Contract checks */
  if(cp9 == NULL)
	cm_Fail("ERROR in CP9Traces2Alignment, cp9 is NULL.\n");
  if(cm->cp9map == NULL)
	cm_Fail("ERROR in CP9Traces2Alignment, cm->cp9map is NULL.\n");
  /* We allow the caller to specify the alphabet they want the
   * resulting MSA in, but it has to make sense (see next few lines). */
  if(cm->abc->type == eslRNA)
	{
	  if(abc->type != eslRNA && abc->type != eslDNA)
	cm_Fail("ERROR in CP9Traces2Alignment(), cm alphabet is RNA, but requested output alphabet is neither DNA nor RNA.");
	}
  else if(cm->abc->K != abc->K)
	cm_Fail("ERROR in CP9Traces2Alignment(), cm alphabet size is %d, but requested output alphabet size is %d.", cm->abc->K, abc->K);

  /* create the emit map */
  emap = CreateEmitMap(cm);

  /* Determine which direction we emit to for each consensus column,
   * IL's emit left, IR's emit right, but this info isn't indexed by
   * consensus column, so we use an emitmap to get it.  This is used
   * to determine if we go IL before EL or EL before IR when inserting
   * both regular IL/IR inserts and EL inserts in same place. This is
   * also used if we have enabled (cm->align_opts &
   * CM_ALIGN_FLUSHINSERTS) which overides default behavior to split
   * the inserts and adopts 'flush left for IL / flush right for IR'
   * behavior (which older versions of Infernal used).
   */
  ESL_ALLOC(insleft, sizeof(int) * (emap->clen+1));
  esl_vec_ISet(insleft, (cm->clen+1), -1);
  for(nd = 0; nd < cm->nodes; nd++)
	{
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == BEGR_nd || cm->ndtype[nd] == ROOT_nd)
	if(insleft[emap->lpos[nd]] == -1) /* deal with sole CM grammar ambiguity */
	  insleft[emap->lpos[nd]] = TRUE;
	  if(cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd)
	insleft[emap->rpos[nd]-1] = FALSE;
	}
  if(insleft[emap->clen] == -1) insleft[emap->clen] = FALSE; /* special case, insleft[emap->clen] == -1 IFF cpos==emap->clen is modelled by MATR or MATP. */
  /* check we've constructed insleft properly, TEMPORARY */
  for(cpos = 0; cpos <= emap->clen; cpos++)
	ESL_DASSERT1((insleft[cpos] != -1));

  /* Here's the problem. We want to align the match states in columns,
   * but some sequences have inserted symbols in them; we need some
   * sort of overall knowledge of where the inserts are and how long
   * they are in order to create the alignment.
   *
   * Here's our trick. maxins[] and maxels[] are 0..hmm->M arrays;
   * maxins[i] stores the maximum number of times insert substate
   * i was used. maxels[i] stores the max number of times an EL insertion
   * occurs after insert substate i. maxins[i] + maxels[i]
   * is the maximum number of gaps to insert between canonical
   * column i and i+1.  maxins[0], maxels[0] is the N-term tail;
   * maxins[M], maxels[0] is the C-term tail.
   */
  ESL_ALLOC(matuse, sizeof(int) * (emap->clen+1));
  ESL_ALLOC(eluse,  sizeof(int) * (emap->clen+1));
  ESL_ALLOC(iuse,   sizeof(int) * (emap->clen+1));
  ESL_ALLOC(maxins, sizeof(int) * (emap->clen+1));
  ESL_ALLOC(maxels, sizeof(int) * (emap->clen+1));
  ESL_ALLOC(matmap, sizeof(int) * (emap->clen+1));
  ESL_ALLOC(imap,   sizeof(int) * (emap->clen+1));
  ESL_ALLOC(elmap,  sizeof(int) * (emap->clen+1));
  ESL_ALLOC(eposmap,sizeof(int *) * (nseq));

  /* eposmap is 2D b/c different traces can have different epos
   * (position where EL inserts) for the same EL state, for example:
   * an EL state for node 9 may reconnect at node 25 in one parse
   * and node 50 in another if there's a CM MATL node with subtree
   * lpos=9 rpos=50, and a CM BEGL node with subtree lpos=9 rpos=25,
   * i.e. there are 2 CM EL states being mirrored by 1 HMM EL state.
   */
  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if(!do_full || cpos == 0)
	matuse[cpos] = 0;
	  else
	matuse[cpos] = 1;
	  maxins[cpos] = maxels[cpos] = 0;
	  iuse[cpos] = eluse[cpos] = imap[cpos] = elmap[cpos] = 0;
	}

  /* Look at all the traces; find maximum length of
   * insert needed at each of the clen+1 possible gap
   * points. (There are two types of insert, I/EL)
   * Also find whether we don't need some of the match
   * (consensus) columns.
   */
  for (idx = 0; idx < nseq; idx++)
	{
	  ESL_ALLOC(eposmap[idx], sizeof(int) * (emap->clen+1));
	  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  iuse[cpos] = eluse[cpos] = 0;
	  eposmap[idx][cpos] = -1;
	}

	  /* Determine the eposmap, the cpos EL's go into for each cpos for each seq.
	   * This depends on the first match state entered after each EL, so we go bottom up */
	  next_match = -1;
	  for (tpos = tr[idx]->tlen - 1; tpos >= 0; tpos--)
	{
	  statetype = tr[idx]->statetype[tpos]; /* just for clarity */
	  cpos      = tr[idx]->nodeidx[tpos];
	  if(statetype == CSTM) next_match = cpos;
	  if(statetype == CSTE) next_match = cp9->M+1;
	  if(statetype == CSTEL) eposmap[idx][cpos] = next_match; /* this will be overwritten below */
	}
	  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if(eposmap[idx][cpos] != -1)
	    {
	      /*printf("cpos: %d eposmap[idx][cpos]: %d ct: %d\n", cpos, eposmap[idx][cpos], cp9->el_from_ct[eposmap[idx][cpos]]);*/
	      /* determine the epos based on the CM emit map and cp9->el* data structures */
	      for(c = 0; c < cp9->el_from_ct[eposmap[idx][cpos]]; c++)
		{
		  if(cp9->el_from_idx[eposmap[idx][cpos]][c] == cpos)
		    {
		      eposmap[idx][cpos] = emap->epos[cp9->el_from_cmnd[eposmap[idx][cpos]][c]];
		      break;
		    }
		  if(c == (cp9->el_from_ct[eposmap[idx][cpos]] - 1))
		    cm_Fail("Couldn't determine epos for cpos: %d\n", cpos);
		}
	    }
	}

	  for (tpos = 0; tpos < tr[idx]->tlen; tpos++)
	{
	  cpos = tr[idx]->nodeidx[tpos];
	  switch (tr[idx]->statetype[tpos]) {
	    case CSTI: iuse[cpos]++; break;
	  case CSTM: matuse[tr[idx]->nodeidx[tpos]] = 1; break;
	  case CSTEL:
	    eluse[eposmap[idx][cpos]]++;
	    break;
	  case CSTD:
	  case CSTE:
	  case CSTB:
	    break;
	  default:
	    cm_Fail("CP9Traces2Alignment reports unrecognized statetype %c",
		CP9Statetype(tr[idx]->statetype[tpos]));
	  }
	} /* end looking at trace i */
	  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if (iuse[cpos]  > maxins[cpos]) maxins[cpos]  = iuse[cpos];
	  if (eluse[cpos] > maxels[cpos]) maxels[cpos]  = eluse[cpos]-1; /* EL only emits on self loops */
	}
	} /* end calculating lengths used by all traces */

  /***********************************************
   * Construct the alignment
   ***********************************************/

  /* Now we can calculate the total length of the multiple alignment, alen;
   * and the maps imap and  elmap that turn a cpos into an apos
   * in the multiple alignment: e.g. for an insert that follows consensus
   * position cpos, put it at or after apos = imap[cpos] in aseq[][].
   */

  matmap[0] = -1; /* M_0 is B state, non-emitter */
  alen = 0;
  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if (matuse[cpos])
	{
	  matmap[cpos] = alen;
	  alen++;
	}
	  else
	matmap[cpos] = -1;

	  if(insleft[cpos]) { /* IL state inserts here, IL's go before EL's */
	imap[cpos]  = alen; alen += maxins[cpos];
	elmap[cpos] = alen; alen += maxels[cpos];
	  }
	  else { /* IR state inserts here, IR's go after EL's */
	elmap[cpos] = alen; alen += maxels[cpos];
	imap[cpos]  = alen; alen += maxins[cpos];
	  }
	}
								/* allocation for new alignment */
  if((msa = esl_msa_Create(nseq, alen)) == NULL) goto ERROR;
  msa->nseq = nseq;
  msa->alen = alen;
  msa->abc  = (ESL_ALPHABET *) abc;

  for (idx = 0; idx < nseq; idx++)
	{
	  if(sq[idx]->dsq == NULL) cm_Fail("ERROR in CP9Traces2Alignment(), sq's should be digitized.\n");

	  for (cpos = 0; cpos <= emap->clen; cpos++)
	iuse[cpos] = eluse[cpos] = 0;
	  /* blank an aseq */
	  for (apos = 0; apos < alen; apos++)
	msa->aseq[idx][apos] = '.';
	  for (cpos = 0; cpos <= emap->clen; cpos++)
	if (matmap[cpos] != -1) msa->aseq[idx][matmap[cpos]] = '-';
	  msa->aseq[idx][alen] = '\0';

	  /* align the sequence */
	  apos = 0;
	  for (tpos = 0; tpos < tr[idx]->tlen; tpos++)
	{
	  statetype = tr[idx]->statetype[tpos]; /* just for clarity */
	  rpos      = tr[idx]->pos[tpos];
	  cpos      = tr[idx]->nodeidx[tpos];

	  if (statetype == CSTM)
	    {
	      apos = matmap[cpos];
	      msa->aseq[idx][apos] = abc->sym[sq[idx]->dsq[rpos]];
	    }
	  else if (statetype == CSTD)
	    apos = matmap[cpos]+1;	/* need for handling D->I; xref STL6/p.117 */
	  else if (statetype == CSTI)
	    {
	      /* flush all inserts left for now, we'll split or flush-right after we're done with all seqs */
	      apos = imap[cpos] + iuse[cpos];
	      msa->aseq[idx][apos] = (char) tolower((int) abc->sym[sq[idx]->dsq[rpos]]);
	      iuse[cpos]++;
	    }
	  else if (statetype == CSTEL)
	    {
	      /*printf("CSTEL cpos: %d rpos: %d epos: %d\n", cpos, rpos);*/
	      epos = eposmap[idx][cpos];
	      if(tr[idx]->statetype[tpos-1] == CSTEL) /* we don't emit on first EL visit */
		{
		  apos = elmap[epos] + eluse[epos];
		  msa->aseq[idx][apos] = (char) tolower((int) abc->sym[sq[idx]->dsq[rpos]]);
		  eluse[epos]++;
		}
	    }
	  else if (statetype == CSTE)
	    apos = matmap[emap->clen]+1;	/* set position for C-term tail */
	}

	  /* All insertions (IL/IR/EL) are currently flush-left, but they won't all remain so.
	   * Two options for what to do:
	   * 1. Split insertions (this is default):
	   *    5' extension (ROOT_IL: prior to cpos 1) is right-justified.
	   *    Internal inserts are split in half
	   *    3' extension (ROOT_IR: after final cpos) remains left-justified.
	   * 2. Flush IL's left, IR's right only ON if cm->align_opts & CM_ALIGN_FLUSHINSERTS (this was Infernal pre-1.0 default)
	   *    use insleft array to determine which type of insert (IL,IR) emits after each
	   *    consensus column, and flush inserts appropriately.
	   *
	   * We have to be careful about EL's. We don't want to group IL/IR's and EL's together and then split them
	   * because we need to annotate IL/IR's as '.'s in the consensus structure and EL's as '~'. So we split
	   * each of the 2 group of inserts separately (IL or IR's (their can only be one per position)) and EL's.
	   * This is done somewhat confusingly (but without repeating too much code) with the
	   * for (pass = 0; pass <= 1; pass++) loop, and the max_ins_or_el[] and pass_offset[] arrays.
	   */

	  /* deal with inserts before cpos 1, don't think they're can be EL's here, but we leave it in case I'm forgetting.
	   * if there are EL's they would come after any ROOT_ILs */
	  if(!(cm->align_opts & CM_ALIGN_FLUSHINSERTS)) /* default behavior, flush ROOT_IL right, else leave ROOT_IL flush left */
	rightjustify(msa->abc, msa->aseq[idx], maxins[0]);
	  if(!(cm->align_opts & CM_ALIGN_FLUSHINSERTS)) /* default behavior, flush pre-cpos=1 ELs right, else leave them flush left */
	rightjustify(msa->abc, msa->aseq[idx]+maxins[0], maxels[0]);

	  for (cpos = 1; cpos < emap->clen; cpos++)
	{
	  if(insleft[cpos]) { /* ILs then ELs */
	    max_ins_or_el[0] = maxins[cpos];
	    max_ins_or_el[1] = maxels[cpos];
	    pass_offset[0]   = 0;
	    pass_offset[1]   = maxins[cpos]; /* we'll have to add this to get to appropriate alignment position when pass==1 */
	  }
	  else { /* ELs then IRs */
	    max_ins_or_el[0] = maxels[cpos];
	    max_ins_or_el[1] = maxins[cpos];
	    pass_offset[0]   = 0;
	    pass_offset[1]   = maxels[cpos]; /* we'll have to add this to get to appropriate alignment position when pass==1 */
	  }
	  for(pass = 0; pass <= 1; pass++)
	    {
	      if (max_ins_or_el[pass]  > 1)
		{
		  apos = matmap[cpos]+1 + pass_offset[pass];
		  if(! (cm->align_opts & CM_ALIGN_FLUSHINSERTS)) /* default behavior, split insert in half */
		    {
		      for (nins = 0; islower((int) (msa->aseq[idx][apos])); apos++)
			nins++;
		      nins /= 2;		/* split the insertion in half */
		      rightjustify(msa->abc, msa->aseq[idx]+matmap[cpos]+1 + pass_offset[pass] + nins, max_ins_or_el[pass]-nins);
		    }
		  /* else revert to pre-1.0 infernal behavior, flush IL's left, and flush IR's right */
		  else if(!(insleft[cpos])) /* only insert right if next consensus column doesn't insert left */
		    rightjustify(msa->abc, msa->aseq[idx] + apos, max_ins_or_el[pass]);
		}
	    }
	}
	  /* deal with inserts after final cpos 1,
	   * if there are EL's they would come before any ROOT_IRs */
	  if(cm->align_opts & CM_ALIGN_FLUSHINSERTS) /* old behavior, flush ROOT_IR right, else (default) leave ROOT_IR flush left */
	  rightjustify(msa->abc, msa->aseq[idx]+matmap[emap->clen]+1, maxels[emap->clen]);
	  if(cm->align_opts & CM_ALIGN_FLUSHINSERTS) /* old behavior, flush ROOT_IR right, else (default) leave ROOT_IR flush left */
	  rightjustify(msa->abc, msa->aseq[idx]+matmap[emap->clen]+1+maxels[emap->clen], maxins[emap->clen]);
	}
  /***********************************************
   * Build the rest of the MSA annotation.
   ***********************************************/

  msa->nseq = nseq;
  msa->alen = alen;
  ESL_ALLOC(msa->au, sizeof(char) * (strlen(INFERNAL_VERSION)+10));
  sprintf(msa->au, "Infernal %s", INFERNAL_VERSION);

  /* copy names and weights */
  for (idx = 0; idx < nseq; idx++)
	{
	  if((status = esl_strdup(sq[idx]->name, -1, &(msa->sqname[idx]))) != eslOK) goto ERROR;
	  if (wgt == NULL) msa->wgt[idx] = 1.0;
	  else             msa->wgt[idx] = wgt[idx];
	}

  /* Construct the secondary structure consensus line, msa->ss_cons:
   *       IL, IR are annotated as .
   *       EL is annotated as ~
   *       and match columns use the structure code.
   * Also the primary sequence consensus/reference coordinate system line,
   * msa->rf.
   */
  ESL_ALLOC(msa->ss_cons, (sizeof(char) * (alen+1)));
  ESL_ALLOC(msa->rf,      (sizeof(char) * (alen+1)));
  con = CreateCMConsensus(cm, abc);

  for (cpos = 0; cpos <= emap->clen; cpos++)
	{
	  if (matuse[cpos])
	{ /* CMConsensus is off-by-one right now, 0..clen-1 relative to cpos's 1..clen */
	  if (con->ct[cpos-1] != -1 && matuse[con->ct[cpos-1]+1] == 0) {
	    msa->ss_cons[matmap[cpos]] = '.';
	    msa->rf[matmap[cpos]]      = con->cseq[cpos-1];
	  } else {
	    msa->ss_cons[matmap[cpos]] = con->cstr[cpos-1];
	    msa->rf[matmap[cpos]]      = con->cseq[cpos-1];
	  }
	}
	  if (maxins[cpos] > 0)
	for (apos = imap[cpos]; apos < imap[cpos] + maxins[cpos]; apos++)
	  {
	    msa->ss_cons[apos] = '.';
	    msa->rf[apos] = '.';
	  }
	  if (maxels[cpos] > 0)
	{
	  for (apos = elmap[cpos]; apos < elmap[cpos] + maxels[cpos]; apos++)
	  {
	    msa->ss_cons[apos] = '~';
	    msa->rf[apos] = '~';
	  }
	}
	}
  msa->ss_cons[alen] = '\0';
  msa->rf[alen] = '\0';

  /* If we only want the match columns, shorten the alignment
   * by getting rid of the inserts. (Alternatively we could probably
   * simplify the building of the alignment, but all that pretty code
   * above already existed, so we do this post-msa-building shortening).
   */
  if(do_matchonly)
	{
	  int *useme;
	  ESL_ALLOC(useme, sizeof(int) * (msa->alen));
	  esl_vec_ISet(useme, msa->alen, FALSE);
	  for(cpos = 0; cpos <= emap->clen; cpos++)
	if(matmap[cpos] != -1) useme[matmap[cpos]] = TRUE;
	  if((status = esl_msa_ColumnSubset(msa, errbuf, useme)) != eslOK) return status;
	  free(useme);
	}

  /* Free and return */
  FreeCMConsensus(con);
  FreeEmitMap(emap);
  free(eluse);
  free(iuse);
  free(matuse);
  free(maxins);
  free(maxels);
  free(matmap);
  free(imap);
  free(elmap);
  free(insleft);
  esl_Free2D((void **) eposmap, nseq);
  *ret_msa = msa;
  return eslOK;

 ERROR:
  if(con   != NULL)  FreeCMConsensus(con);
  if(emap  != NULL)  FreeEmitMap(emap);
  if(matuse!= NULL)  free(matuse);
  if(iuse != NULL)   free(iuse);
  if(elmap != NULL)  free(elmap);
  if(maxels!= NULL)  free(maxels);
  if(matmap!= NULL)  free(matmap);
  esl_Free2D((void **) eposmap, nseq);
  if(msa   != NULL)  esl_msa_Destroy(msa);
  return status;
}

/* Function: CP9TraceScoreCorrectionNull2()
 * Based on HMMER2's TraceScoreCorrection()
 * Date:     Sun Dec 21 12:05:47 1997 [StL]
 *
 * Purpose:  Calculate a correction (in integer log_2 odds) to be
 *           applied to a sequence, using a second null model,
 *           based on a traceback. M/I emissions are corrected;
 *           The null model is constructed /post hoc/ as the
 *           average over all the M,I distributions used by the trace.
 *
 * Return:   the log_2-odds score correction.
 */
int
CP9TraceScoreCorrectionNull2(CP9_t *hmm, char *errbuf, CP9trace_t *tr, ESL_DSQ *dsq, int start, float omega, float *ret_sc)
{
  int status;
  float *p;		/* null2 model distribution */
  int *sc;	        /* null2 model scores       */
  int   a;              /* residue index counters */
  int   tpos;
  int score;

  /* Rarely, the alignment was totally impossible, and tr is NULL.
   */
  if (tr == NULL) return 0.0;

  /* Set up model: average over the emission distributions of
   * all M, I states that appear in the trace. Ad hoc? Sure, you betcha.
   */
  /* trivial preorder traverse, since we're already numbered that way */
  ESL_ALLOC(p, sizeof(float) * hmm->abc->K);
  esl_vec_FSet(p, hmm->abc->K, 0.0);
  for (tpos = 0; tpos < tr->tlen; tpos++) {
	 if      (tr->statetype[tpos] == CSTM) esl_vec_FAdd(p, hmm->mat[tr->nodeidx[tpos]], hmm->abc->K);
	 else if (tr->statetype[tpos] == CSTI) esl_vec_FAdd(p, hmm->ins[tr->nodeidx[tpos]], hmm->abc->K);
  }
  esl_vec_FNorm(p, hmm->abc->K);

  ESL_ALLOC(sc,  sizeof(int) * (hmm->abc->Kp));
  /* calculate null2 scores of each possible emission, first the base alphabet */
  for (a = 0; a < hmm->abc->K; a++)     sc[a] = Prob2Score(p[a], hmm->null[a]);
  /* the ambiguities */
  for (a = hmm->abc->K+1; a < hmm->abc->Kp-1; a++) sc[a] = esl_abc_IAvgScore(hmm->abc, a, sc);

  /* Score all the M,I state emissions that appear in the trace.
   */
   score = 0;
   for (tpos = 0; tpos < tr->tlen; tpos++)
	 if (tr->statetype[tpos] == CSTM || tr->statetype[tpos] == CSTI) score += sc[dsq[tr->pos[tpos]]];

   /* Apply an ad hoc 8 bit fudge factor penalty;
	* interpreted as a prior, saying that the second null model is
	* 1/2^8 (1/256) as likely as the standard null model
	*/
   score += ((int) (sreLOG2(omega))) * INTSCALE;

   /* Return the correction to the bit score.
	*/
   printf("CP9TraceScoreCorrectionNull2() returning %.3f bits\n", Scorify(ILogsum(0, score)));
   *ret_sc = Scorify(ILogsum(0, score));
   return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "CP9TraceScoreCorrectionNull2(): memory allocation error.");
  return status; /* NEVERREACHED*/
}

/*** End of inlined file: cp9_trace.c ***/


/*** Start of inlined file: alphabet.c ***/

#include <string.h>
#include <ctype.h>
#include <math.h>


/* Function: PairCount()
 * Date:     SRE, Tue Aug  1 10:34:20 2000 [St. Louis]
 *
 * Purpose:  Given a possibly degenerate symbol code for left
 *           and right symbols in a pair, increment a symbol
 *           counter array appropriately.
 *
 * Args:     abc      - pointer to the internal alphabet
 *           counters - vector to count into [0..abc->K^2-1]
 *           syml     - index of left symbol  [0..abc->sym_iupac-1]
 *           symr     - index of right symbol [0..abc->sym_iupac-1]
 *           wt       - weight to use for the count (often 1.0).
 *
 * Returns:  void
 */
void
PairCount(const ESL_ALPHABET *abc, float *counters, ESL_DSQ syml, ESL_DSQ symr, float wt)
{
  if (syml < abc->K && symr < abc->K)
	counters[(int) (syml * abc->K + symr)] += wt;
  else {
	int status;
	float *left = NULL;
	float *right = NULL;
	int   l,r;
	ESL_ALLOC(left,  (sizeof(float) * abc->K));
	ESL_ALLOC(right, (sizeof(float) * abc->K));

	/* Be careful to set weights as 1.0 for the FCount calls (not <wt>),
	 * because what we want to know is the fraction of all possible
	 * residues that agree with the degenerate for each residue, i.e.:
	 *
	 * if  syml == 'N': left[A]  == left[C] == left[G] == left[U] == 0.25
	 * and symr == 'R': right[A] == right[G] == 0.5
	 *
	 * Then when we increment counters by left[l] * left[r] * <wt>.
	 * That way if <wt> = 0.8, counters is set as follows:
	 *
	 * if syml == 'N' && symr == 'R':
	 * counters['AA'] == counters['CA'] == counters ['GA'] == counters['UA'] ==
	 * counters['AG'] == counters['CG'] == counters ['GG'] == counters['UG'] == 0.1
	 * and all others are = 0.0.
	 *
	 * Previously (Infernal versions 0.55 (maybe even earlier) until
	 * 1.0.2) this was done incorrectly by passing <wt> to the
	 * FCount() calls and setting counters[] = left[l] *
	 * right[r]. Somehow, Stefan Janssen tracked this down. Thanks
	 * Stefan!  The bug is i23, logged in Bugs/BUGTRAX.
	 * EPN, Mon Dec 6 13:09:52 2010
	 */
	esl_vec_FSet(left, abc->K, 0.);
	esl_vec_FSet(right, abc->K, 0.);
	esl_abc_FCount(abc, left,  syml, 1.0);
	esl_abc_FCount(abc, right, symr, 1.0);

	for (l = 0; l < abc->K; l++)
	  for (r = 0; r < abc->K; r++)
	counters[l*abc->K +r] += left[l] * right[r] * wt;

	free(left);
	free(right);
  }
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
  return; /* never reached */
}

float
DegeneratePairScore(const ESL_ALPHABET *abc, float *esc, ESL_DSQ syml, ESL_DSQ symr)
{
  float *left = NULL;
  float *right = NULL;
  int status;
  ESL_ALLOC(left,  (sizeof(float) * abc->K));
  ESL_ALLOC(right, (sizeof(float) * abc->K));
  int l,r;
  float sc;

  if (syml < abc->K && symr < abc->K) /* canonical pair */
  {
	free(left);
	free(right);
	return esc[(int) (syml*abc->K+symr)];
  }

  if (syml == abc->K || symr == abc->K)  /* gap, this gets an IMPOSSIBLE sc */
  {
	free(left);
	free(right);
	return IMPOSSIBLE;
  }

  if (syml == (abc->Kp-1) || symr == (abc->Kp-1))  /* missing data, this gets an IMPOSSIBLE sc */
  {
	free(left);
	free(right);
	return IMPOSSIBLE;
  }

  esl_vec_FSet(left, abc->K, 0.);
  esl_vec_FSet(right, abc->K, 0.);
  esl_abc_FCount(abc, left,  syml, 1.);
  esl_abc_FCount(abc, right, symr, 1.);

  sc = 0.;
  for (l = 0; l < abc->K; l++)
	for (r = 0; r < abc->K; r++)
	  sc += esc[l*abc->K+r] * left[l] * right[r];

  free(left);
  free(right);

  return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.0; /* never reached */
}
int
iDegeneratePairScore(const ESL_ALPHABET *abc, int *iesc, ESL_DSQ syml, ESL_DSQ symr)
{
  float *left = NULL;
  float *right = NULL;
  int status;
  ESL_ALLOC(left,  (sizeof(float) * abc->K));
  ESL_ALLOC(right, (sizeof(float) * abc->K));
  int l,r;
  float sc;

  if (syml < abc->K && symr < abc->K)
	return iesc[(int) (syml*abc->K+symr)];

  if (syml == abc->K || symr == abc->K)  /* gap, this gets an -INFTY sc */
	return -INFTY;

  if (syml == (abc->Kp-1) || symr == (abc->Kp-1))  /* missing data, this gets an -INFTY sc */
	return -INFTY;

  esl_vec_FSet(left, abc->K, 0.);
  esl_vec_FSet(right, abc->K, 0.);
  esl_abc_FCount(abc, left,  syml, 1.);
  esl_abc_FCount(abc, right, symr, 1.);

  sc = 0.;
  for (l = 0; l < abc->K; l++)
	for (r = 0; r < abc->K; r++)
	  sc += iesc[l*abc->K+r] * left[l] * right[r];

  free(left);
  free(right);

  return (int) sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return status; /* never reached */
}
/* EPN, Wed Aug 20 13:44:16 2008
 * FastPairScore*() functions:
 * Written to calculate base pairs scores involving 1 or 2 canonical
 * residues as efficiently as I know how.
 * Calculating 'optimized' emission scores, which calculates all possible
 * base pair scores (including non-canonicals) in cm_mx.c:{F,I}CalcOptimizedEmitScores()
 * was a time bottleneck in alignment with P7 and CP9 bands during sub CM construction.
 * sub CMs are created for each target seq, and optimized scores must be
 * calc'ed for each sub CM.
 */

/* Function:  FastPairScoreBothDegenerate() (float version)
 *           iFastPairScoreBothDegenerate() (int   version)
 * Incept:    EPN, Wed Aug 20 13:18:15 2008
 *
 * Purpose:   Score a base pair given left and right vectors denoting
 *            fractional weight of each canonical for left residue
 *            and right residue. This function should only be called if
 *            at least 2 values in both left and right are non-zero,
 *            that is, if both left and right correspond to non-canonical
 *            residues.
 *
 *            Example: if we're calculating for left char 'S' (C or G),
 *                     and right char 'N' (A,C,G,U), then we'd have:
 *                     left  = [0.00, 0.50, 0.50, 0.00]
 *                     right = [0.25, 0.25, 0.25, 0.25]
 *
 *            K     - alphabet size, abc->K
 *            esc   - emission vector, canonical pair scores are used to calc <sc>
 *            left  - [0..l..K-1] fraction of each canonical residue
 *            right - [0..r..K-1] fraction of each canonical residue
 *
 * Returns:   <sc> the score of the pair
 */

float
FastPairScoreBothDegenerate(int K, float *esc, float *left, float *right)
{
  int l,r;
  float sc;

  sc = 0.;
  for (l = 0; l < K; l++)
	for (r = 0; r < K; r++)
	  sc += esc[l*K+r] * left[l] * right[r];
  return sc;
}
int
iFastPairScoreBothDegenerate(int K, int *iesc, float *left, float *right)
{
  int l,r;
  float sc;

  sc = 0.;
  for (l = 0; l < K; l++)
	for (r = 0; r < K; r++)
	  sc += iesc[l*K+r] * left[l] * right[r];
  return (int) sc;
}
/* Function:  FastPairScoreLeftOnlyDegenerate() (float version)
 *           iFastPairScoreLeftOnlyDegenerate() (int   version)
 * Incept:    EPN, Wed Aug 20 13:18:15 2008
 *
 * Purpose:   Score a base pair with left residue non-canonical and
 *            right residue canonical, given a <left> vector denoting
 *            fractional weight of each canonical for left residue.
 *            This function should only be called if at least 2 values
 *            left are non-zero, that is, if left corresponds to a
 *            non-canonical residue.
 *
 *            Example: if we're calculating for left char 'S' (C or G),
 *                     left  = [0.00, 0.50, 0.50, 0.00]
 *
 *            K     - alphabet size, abc->K
 *            esc   - emission vector, canonical pair scores are used to calc <sc>
 *            left  - [0..l..K-1] fraction of each canonical residue
 *            symr  - canonical right residue must be in range 0..K-1
 *
 * Returns:   <sc> the score of the pair
 */
float
FastPairScoreLeftOnlyDegenerate(int K, float *esc, float *left, ESL_DSQ symr)
{
  int l;
  float sc;

  sc = 0.;
  for (l = 0; l < K; l++) sc += esc[l*K+symr] * left[l];
  return sc;
}
int
iFastPairScoreLeftOnlyDegenerate(int K, int *iesc, float *left, ESL_DSQ symr)
{
  int l;
  float sc;

  sc = 0.;
  for (l = 0; l < K; l++) sc += iesc[l*K+symr] * left[l];
  return (int) sc;
}
/* Function:  FastPairScoreRightOnlyDegenerate() (float version)
 *           iFastPairScoreRightOnlyDegenerate() (int   version)
 * Incept:    EPN, Wed Aug 20 13:18:15 2008
 *
 * Purpose:   Score a base pair with right residue non-canonical and
 *            right residue canonical, given a <right> vector denoting
 *            fractional weight of each canonical for right residue.
 *            This function should only be called if at least 2 values
 *            left are non-zero, that is, if right corresponds to a
 *            non-canonical residue.
 *
 *            Example: if we're calculating for right char 'M' (A or C),
 *                     right  = [0.50, 0.50, 0.00, 0.00]
 *
 *            K     - alphabet size, abc->K
 *            esc   - emission vector, canonical pair scores are used to calc <sc>
 *            right - [0..l..K-1] fraction of each canonical residue
 *            syml  - canonical left residue, must be in range 0..K-1
 *
 * Returns:   <sc> the score of the pair
 */
float
FastPairScoreRightOnlyDegenerate(int K, float *esc, float *right, ESL_DSQ syml)
{
  int r;
  float sc;

  sc = 0.;
  for (r = 0; r < K; r++) sc += esc[syml*K+r] * right[r];
  return sc;
}
float
iFastPairScoreRightOnlyDegenerate(int K, int *iesc, float *right, ESL_DSQ syml)
{
  int r;
  float sc;

  sc = 0.;
  for (r = 0; r < K; r++) sc += iesc[syml*K+r] * right[r];
  return (int) sc;
}

/* Following funcs from RSEARCH, only used by RSEARCH code */

static char random_from_string (ESL_RANDOMNESS *r, char *s);
/* Function: resolve_degenerate
 * Date:     September, 1998 (from hmmgcc)
 * This function resolves "degnerate" nucleotides by selecting a random
 * A, C, G, or T as appropriate by the code present there.  Returns
 * the character passed in if that character does not represent a
 * non-degnerate nucleotide (either A, C, G, or T or not representative
 * at all of a nucleotide.
 *
 * The degenerate code used here is:
 * (taken from http://www.neb.com/neb/products/REs/RE_code.html
 *
 *                         R = G or A
 *                         K = G or T
 *                         B = not A (C or G or T)
 *                         V = not T (A or C or G)
 *                         Y = C or T
 *                         S = G or C
 *                         D = not C (A or G or T)
 *                         N = A or C or G or T
 *                         M = A or C
 *                         W = A or T
 *                         H = not G (A or C or T)
 *
 * This function assumes all letters are already uppercased via toupper
 * before calling.  In other words, it will return a "n" if passed an "n"
 * because it will assume that the symbol for all nucleotides will be passed
 * in as "N".
 */
char resolve_degenerate (ESL_RANDOMNESS *r, char c) {
  c = toupper(c);
  switch (c) {
	case 'A' : return(c);
	case 'C' : return(c);
	case 'G' : return(c);
	case 'T' : return(c);
	case 'R' : return(random_from_string(r, "GA"));
	case 'K' : return(random_from_string(r, "GT"));
	case 'B' : return(random_from_string(r, "CGT"));
	case 'V' : return(random_from_string(r, "ACG"));
	case 'Y' : return(random_from_string(r, "CT"));
	case 'S' : return(random_from_string(r, "GC"));
	case 'D' : return(random_from_string(r, "AGT"));
	case 'N' : return(random_from_string(r, "ACGT"));
	case 'M' : return(random_from_string(r, "AC"));
	case 'W' : return(random_from_string(r, "AT"));
	case 'H' : return(random_from_string(r, "ACT"));
  }
  return(c);
}

/*
 * Function: random_from_string
 * Date:     September, 1998 (approx.) -- from hmmgcc
 * This function returns a character randomly chosen from the string.
 * Used in conjunction with the function below that resolves degenerate code
 * nucleotides.
 */
char random_from_string (ESL_RANDOMNESS *r, char *s) {
  int i;
  do
	{
	  /*i = (int) ((float)(strlen(s)-1)*esl_random(r)/(RAND_MAX+1.0));*/
	  i = (int) ((float)(strlen(s)) * esl_random(r));
	} while (i<0 || i>=strlen(s));
  return(s[i]);
}

/* Function: revcomp()
 * Incept:   EPN, Tue Aug  7 10:05:14 2007
 *           based on Squid's revcomp()
 *
 * Purpose:  Reverse complement ESL_SQ seq; store in comp.
 *           Can revcomp "in place" (revcomp(seq, seq)).
 *           sq can be in digital or text form.
 *
 * Args:     comp  - destination for reverse complement of sq
 *           seq   - sequence to reverse complement
 *
 * Returns:  eslOK on success;
 *           Dies immediately if any error occurs.
 */
int
revcomp(const ESL_ALPHABET *abc, ESL_SQ *comp, ESL_SQ *sq)
{
  int status;
  int do_digital = FALSE;
  int i;

  /* contract checks */
  if (comp == NULL)
	cm_Fail("ERROR in revcomp, comp is NULL.");
  if(sq == NULL)
	cm_Fail("ERROR in revcomp, sq is NULL.");
  if(sq->dsq != NULL && comp->dsq == NULL)
	cm_Fail("ERROR in revcomp, sq is digital, comp is not.");
  if(sq->dsq == NULL && comp->dsq != NULL)
	cm_Fail("ERROR in revcomp, comp is digital, sq is not.");
  if(abc->type != eslRNA && abc->type != eslDNA)
	cm_Fail("ERROR in revcomp, alphabet type must be RNA or DNA.");
  if(comp->n < sq->n)
	cm_Fail("ERROR in revcomp, comp->n is smaller than sq->n.");

  if(sq->dsq != NULL) do_digital = TRUE;

  if(do_digital) {
	if((status = esl_rsq_XReverse(sq->dsq, sq->n, comp->dsq)) != eslOK)
	  goto ERROR;
  }
  else {
	if((status = esl_rsq_CReverse(sq->seq, comp->seq) != eslOK))
	  goto ERROR;
  }

  if(do_digital)
	{
	  for(i = 1; i <= sq->n; i++)
	{
	  if(sq->dsq[i] >= abc->Kp) { status = eslEINVAL; goto ERROR; }
	  switch (abc->sym[sq->dsq[i]]) {
	  case 'A':
	    if(abc->type == eslRNA)
	      comp->dsq[i] = abc->inmap[(int) 'U'];
	    else
	      comp->dsq[i] = abc->inmap[(int) 'T'];
	    break;
	  case 'C': comp->dsq[i] = abc->inmap[(int) 'G']; break;
	  case 'G': comp->dsq[i] = abc->inmap[(int) 'C']; break;
	  case 'T': comp->dsq[i] = abc->inmap[(int) 'A']; break;
	  case 'U': comp->dsq[i] = abc->inmap[(int) 'A']; break;
	  case 'R': comp->dsq[i] = abc->inmap[(int) 'Y']; break;
	  case 'Y': comp->dsq[i] = abc->inmap[(int) 'R']; break;
	  case 'M': comp->dsq[i] = abc->inmap[(int) 'K']; break;
	  case 'K': comp->dsq[i] = abc->inmap[(int) 'M']; break;
	  case 'S': comp->dsq[i] = abc->inmap[(int) 'S']; break;
	  case 'W': comp->dsq[i] = abc->inmap[(int) 'W']; break;
	  case 'H': comp->dsq[i] = abc->inmap[(int) 'D']; break;
	  case 'D': comp->dsq[i] = abc->inmap[(int) 'H']; break;
	  case 'B': comp->dsq[i] = abc->inmap[(int) 'V']; break;
	  case 'V': comp->dsq[i] = abc->inmap[(int) 'B']; break;
	  default:  break;		/* anything else? leave it; it's prob a gap or an X */
	  }
	}
	}
  else
	{
	  for(i = 0; i < sq->n; i++)
	{
	  if(islower(sq->seq[i])) { status = eslEINVAL; goto ERROR; }
	     switch (sq->seq[i]) {
	     case 'A':
	       if(abc->type == eslRNA)
		 comp->seq[i] = 'U';
	       else
		 comp->seq[i] = 'T';
	       break;
	     case 'C': comp->seq[i] = 'G'; break;
	     case 'G': comp->seq[i] = 'C'; break;
	     case 'T': comp->seq[i] = 'A'; break;
	     case 'U': comp->seq[i] = 'A'; break;
	     case 'R': comp->seq[i] = 'Y'; break;
	     case 'Y': comp->seq[i] = 'R'; break;
	     case 'M': comp->seq[i] = 'K'; break;
	     case 'K': comp->seq[i] = 'M'; break;
	     case 'S': comp->seq[i] = 'S'; break;
	     case 'W': comp->seq[i] = 'W'; break;
	     case 'H': comp->seq[i] = 'D'; break;
	     case 'D': comp->seq[i] = 'H'; break;
	     case 'B': comp->seq[i] = 'V'; break;
	     case 'V': comp->seq[i] = 'B'; break;
	     default:  break;		/* anything else? leave it; it's prob a gap or an X */
	     }
	}
	}
  return eslOK;

 ERROR:
  cm_Fail("Unexpected error code: %d in revcomp().", status);
  return status; /* NOTREACHED */
}

/*** End of inlined file: alphabet.c ***/


/*** Start of inlined file: display.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <time.h>


static int *createMultifurcationOrderChart(CM_t *cm);
static int  bp_is_canonical(char lseq, char rseq);
static void createFaceCharts(CM_t *cm, int **ret_inface, int **ret_outface);

/* Function:  CreateFancyAli()
 * Incept:    SRE, Thu May 23 13:46:09 2002 [St. Louis]
 *
 * Purpose:   Given a trace (and the model and sequence it corresponds
 *            to), create a pairwise alignment for display; return in a Fancyali_t
 *            structure.
 *
 * Args:      abc   - alphabet to create alignment with (often cm->abc)
 *            tr    - parsetree for cm aligned to dsq
 *            cm    - model
 *            cons  - consensus information for cm; see CreateCMConsensus()
 *            dsq   - digitized sequence
 *            do_noncanonical - mark half-bps and negative scoring bps that are non-canonicals in top line with 'v'
 *                              (by default, all negative scoring and half-bps are marked with 'x')
 *            pcode - posterior code
 *
 *
 * Returns:   fancy alignment structure.
 *            Caller frees, with FreeFancyAli(ali).
 *
 * Xref:      STL6 p.58
 */
Fancyali_t *
CreateFancyAli(const ESL_ALPHABET *abc, Parsetree_t *tr, CM_t *cm, CMConsensus_t *cons, ESL_DSQ *dsq, int do_noncanonical, char *pcode)
{
  int         status;
  Fancyali_t *ali;              /* alignment structure we're building        */
  ESL_STACK  *pda;              /* pushdown automaton used to traverse trace */
  int         type;		/* type of pda move: PDA_RESIDUE, PDA_STATE  */
  int         v;		/* state index       */
  int         nd;		/* node index        */
  int         ti;		/* position in trace */
  int         qinset, tinset;	/* # consensus nt skipped by an EL, or in an EL */
  int         ninset;		/* max # nt in an EL     */
  int         pos;		/* position in growing ali */
  int         lc, rc;		/* indices for left, right pos in consensus */
  int         symi, symj;
  int         d;
  char        mode;
  int         lrf, rrf;         /* chars in reference line; left, right     */
  int         lstr, rstr;	/* chars in structure line; left, right      */
  int         lcons, rcons;	/* chars in consensus line; left, right      */
  int         lmid, rmid;	/* chars in ali quality line; left, right    */
  int         ltop, rtop;	/* chars in optional noncompensatory line; left, right */
  int         lnegnc, rnegnc;	/* chars in optional noncanonical line; left, right */
  int         lseq, rseq;	/* chars in aligned target line; left, right */
  int         lpost, rpost;	/* chars in aligned posteriors, left, right  */
  int         do_left, do_right;/* flags to generate left, right             */
  int cpos_l, cpos_r;   	/* positions in consensus (1..clen)          */
  int spos_l, spos_r;		/* positions in dsq (1..L)                   */
  int have_pcodes;

  /* Contract check. We allow the caller to specify the alphabet they want the
   * resulting MSA in, but it has to make sense (see next few lines). */
  if(cm->abc->type == eslRNA)
	{
	  if(abc->type != eslRNA && abc->type != eslDNA)
	cm_Fail("ERROR in CreateFancyAli(), cm alphabet is RNA, but requested output alphabet is neither DNA nor RNA.");
	}
  else if(cm->abc->K != abc->K)
	cm_Fail("ERROR in CreateFancyAli(), cm alphabet size is %d, but requested output alphabet size is %d.", cm->abc->K, abc->K);

  ESL_ALLOC(ali, sizeof(Fancyali_t));
  have_pcodes = (pcode != NULL) ? TRUE : FALSE;

  /* Calculate length of the alignment display.
   *   MATP node        : +2
   *   MATL, MATR node  : +1
   *   IL, IR state     : +1
   *   EL:              : 4 + width of length display : "*[nn]*"
   *   anything else    : 0.
   */
  ali->len = 0;
  for (ti = 0; ti < tr->n; ti++)
	{
	  v  = tr->state[ti];
	  if (v == cm->M) {  /* special case: local exit into EL */
	nd = cm->ndidx[tr->state[ti-1]]; /* calculate node that EL replaced */
	qinset     = cons->rpos[nd] - cons->lpos[nd] + 1;
	tinset     = tr->emitr[ti]  - tr->emitl[ti]  + 1;
	ninset     = ESL_MAX(qinset,tinset);
	ali->len += 4;
	do { ali->len++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	continue;
	  } else {
	nd = cm->ndidx[v];
	if      (cm->sttype[v]  == IL_st   || cm->sttype[v]  == IR_st)
	  ali->len += 1;
	else if (cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATR_nd)
	  ali->len += 1;
	else if (cm->ndtype[nd] == MATP_nd)
	  ali->len += 2;
	  }
	  /* Catch marginal-type local ends and treat them like EL for output */
	  if ((tr->nxtl[ti] == -1) && (cm->sttype[v] != E_st)) {
	nd = cm->ndidx[tr->state[ti]];
	qinset     = cons->rpos[nd] - cons->lpos[nd] + 1;
	tinset     = tr->emitr[ti]  - tr->emitl[ti]  + 1;
		if (tinset > 0) tinset--;
	ninset     = ESL_MAX(qinset,tinset);
	ali->len += 4;
	do { ali->len++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	  }
	}

  /* Allocate and initialize.
   * Blank the reference lines (memset calls) - only needed
   * because of the way we deal w/ EL.
   */
  if (cm->rf != NULL )
	ESL_ALLOC(ali->rf, sizeof(char) * (ali->len+1));
  else
	ali->rf = NULL;
  ESL_ALLOC(ali->cstr, sizeof(char) * (ali->len+1));
  ESL_ALLOC(ali->cseq, sizeof(char) * (ali->len+1));
  ESL_ALLOC(ali->mid,  sizeof(char) * (ali->len+1));
  ESL_ALLOC(ali->top,  sizeof(char) * (ali->len+1));
  ESL_ALLOC(ali->aseq, sizeof(char) * (ali->len+1));
  if(have_pcodes) {
	ESL_ALLOC(ali->pcode, sizeof(char) * (ali->len+1));
  }
  else {
	ali->pcode = NULL;
  }
  ESL_ALLOC(ali->scoord, sizeof(int)  * ali->len);
  ESL_ALLOC(ali->ccoord, sizeof(int)  * ali->len);

  if (cm->rf != NULL) memset(ali->rf, ' ', ali->len);
  memset(ali->cstr, ' ', ali->len);
  memset(ali->cseq, ' ', ali->len);
  memset(ali->mid,  ' ', ali->len);
  memset(ali->top,  ' ', ali->len);
  memset(ali->aseq, ' ', ali->len);
  if(have_pcodes) {
	memset(ali->pcode, ' ', ali->len);
  }
  for (pos = 0; pos < ali->len; pos++)
	ali->ccoord[pos] = ali->scoord[pos] = 0;

  /* Fill in the lines: traverse the traceback.
   */
  pos = 0;
  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  if((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
  if((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;

  while (esl_stack_IPop(pda, &type) != eslEOD)
	{
	  if (type == PDA_RESIDUE) {
	if (cm->rf != NULL) {
	  esl_stack_IPop(pda, &rrf);
	  ali->rf[pos] = rrf;
	}
	esl_stack_IPop(pda, &rstr); 	  ali->cstr[pos]   = rstr;
	esl_stack_IPop(pda, &rcons);	  ali->cseq[pos]   = rcons;
	esl_stack_IPop(pda, &rmid);	  ali->mid[pos]    = rmid;
	esl_stack_IPop(pda, &rtop);	  ali->top[pos]    = rtop;
	esl_stack_IPop(pda, &rseq);       ali->aseq[pos]   = rseq;
	if(have_pcodes) {
	  esl_stack_IPop(pda, &rpost);    ali->pcode[pos] = rpost;
	}
	esl_stack_IPop(pda, &cpos_r);     ali->ccoord[pos] = cpos_r;
	esl_stack_IPop(pda, &spos_r);     ali->scoord[pos] = spos_r;
	pos++;
	continue;
	  }

	  /* Else, we're PDA_STATE - e.g. dealing with a trace node.
	   */
	  esl_stack_IPop(pda, &ti);
	  v = tr->state[ti];

	  /* Deal with EL (local ends, state M) as a special case.
	   * We get away with only writing into aseq because we've
	   * memset() the display strings to blank.
	   */
	  if (v == cm->M) {
	int numwidth;		/* number of chars to leave for displaying width numbers */

	nd = 1 + cm->ndidx[tr->state[ti-1]]; /* calculate node that EL replaced */
	qinset     = cons->rpos[nd] - cons->lpos[nd] + 1;
	tinset     = tr->emitr[ti]  - tr->emitl[ti]  + 1;
	ninset     = ESL_MAX(qinset,tinset);
	numwidth = 0; do { numwidth++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	memset(ali->cstr+pos,  '~', numwidth+4);
	sprintf(ali->cseq+pos, "*[%*d]*", numwidth, qinset);
	sprintf(ali->aseq+pos, "*[%*d]*", numwidth, tinset);
	/* do nothing for posteriors here, they'll stay as they were init'ed, as ' ' */
	pos += 4 + numwidth;
	continue;
	  }

	  /* Fetch some info into tmp variables, for "clarity"
	   */
	  nd = cm->ndidx[v];	  /* what CM node we're in */
	  lc   = cons->lpos[nd];	  /* where CM node aligns to in consensus */
	  rc   = cons->rpos[nd];
	  symi = dsq[tr->emitl[ti]];  /* residue indices that node is aligned to */
	  symj = dsq[tr->emitr[ti]];
	  if(have_pcodes) { /* posterior codes are indexed 0..alen-1, off-by-one w.r.t dsq */
	lpost = '.'; /* init to gap, if it corresponds to a residue, we'll reset it below */
	rpost = '.'; /* init to gap, if it corresponds to a residue, we'll reset it below */
	  }
	  d = tr->emitr[ti] - tr->emitl[ti] + 1;
	  mode = tr->mode[ti];

	  /* Calculate four of the five lines: rf, str, cons, and seq.
	   */
	  do_left = do_right = FALSE;
	  if (cm->sttype[v] == IL_st) {
	do_left = TRUE;
	if (cm->rf != NULL) lrf = '.';
	lstr    = '.';
	lcons   = '.';
	if (mode == TRMODE_J || mode == TRMODE_L) lseq = tolower((int) abc->sym[symi]);
		else                        lseq = '~';
	cpos_l  = 0;
	spos_l  = tr->emitl[ti];
	if(pcode != NULL) { lpost = pcode[tr->emitl[ti]-1]; } /* watch off-by-one w.r.t. dsq */
	  } else if (cm->sttype[v] == IR_st) {
	do_right = TRUE;
	if (cm->rf != NULL) rrf = '.';
	rstr    = '.';
	rcons   = '.';
	if (mode == TRMODE_J || TRMODE_R) rseq = tolower((int) abc->sym[symj]);
		else                        rseq = '~';
	cpos_r  = 0;
	spos_r  = tr->emitr[ti];
	if(pcode != NULL) { rpost = pcode[tr->emitr[ti]-1]; } /* watch off-by-one w.r.t. dsq */
	  } else {
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) {
	  do_left = TRUE;
	  if (cm->rf != NULL) lrf = cm->rf[lc];
	  lstr   = cons->cstr[lc];
	  lcons  = cons->cseq[lc];
	  cpos_l = lc+1;
	  if (cm->sttype[v] == MP_st || cm->sttype[v] == ML_st) {
	    if      (mode == TRMODE_J)         lseq = abc->sym[symi];
			else if (mode == TRMODE_L && d>0 ) lseq = abc->sym[symi];
			else                        lseq = '~';
	    spos_l = tr->emitl[ti];
	    if(pcode != NULL) { lpost = pcode[tr->emitl[ti]-1]; } /* watch off-by-one w.r.t. dsq */
	  } else {
	    if (mode == TRMODE_J || mode == TRMODE_L) lseq = '-';
			else                        lseq = '~';
	    spos_l = 0;
	    /* lpost remains as it was init'ed as a gap '.' */
	  }
	}
	if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) {
	  do_right = TRUE;
	  if (cm->rf != NULL) rrf = cm->rf[rc];
	  rstr   = cons->cstr[rc];
	  rcons  = cons->cseq[rc];
	  cpos_r = rc+1;
	  if (cm->sttype[v] == MP_st || cm->sttype[v] == MR_st) {
	    if      (mode == TRMODE_J)         rseq = abc->sym[symj];
			else if (TRMODE_R && d>0 ) rseq = abc->sym[symj];
			else                        rseq = '~';
	    spos_r = tr->emitr[ti];
	    if(pcode != NULL) { rpost = pcode[tr->emitr[ti]-1]; } /* watch off-by-one w.r.t. dsq */
	  } else {
	    if (mode == TRMODE_J || TRMODE_R) rseq = '-';
			else                        rseq = '~';
	    spos_r = 0;
	    /* rpost remains as it was init'ed as a gap '.' */
	  }
	}
	  }

	  /* Use emission p and score to set lmid, rmid line for emitting states.
	   */
	  lmid = rmid = ' ';
	  ltop = rtop = ' ';
	  lnegnc = rnegnc = ' ';
	  if (cm->sttype[v] == MP_st) {
	if (lseq == toupper(lcons) && rseq == toupper(rcons))
	  {
	    lmid = lseq;
	    rmid = rseq;
	  }
		else if (mode != 3)
		  {
			if (mode == TRMODE_L && lseq == toupper(lcons)) lmid = lseq;
			if (TRMODE_R && rseq == toupper(rcons)) rmid = rseq;
		  }
	else if (DegeneratePairScore(cm->abc, cm->esc[v], symi, symj) >= 0)
	  lmid = rmid = ':';

	/* determine ltop, rtop for optional noncompensatory annotation, they are 'x' if lmid, rmid are ' ', and ' ' otherwise */
	if (lmid == ' ' && rmid == ' ')
	  ltop = rtop = 'x';

	/* determine lnegnc, rnegnc for optional negative scoring non-canonical annotation, they are 'v' if lseq and rseq are a negative scoring non-canonical (not a AU,UA,GC,CG,GU,UG) pair */
	if ((mode == TRMODE_J) && (DegeneratePairScore(cm->abc, cm->esc[v], symi, symj) < 0) && (! bp_is_canonical(lseq, rseq))) {
	  lnegnc = rnegnc = 'v';
	}
	  } else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st) {
	if (lseq == toupper(lcons))
	  lmid = lseq;
		else if ( (mode != 3) && (mode != 2) )
		  ;
	else if(esl_abc_FAvgScore(cm->abc, symi, cm->esc[v]) > 0)
	  lmid = '+';
	  } else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st) {
	if (rseq == toupper(rcons))
	  rmid = rseq;
		else if ( (mode != 3) && (mode != 1) )
		  ;
	else if(esl_abc_FAvgScore(cm->abc, symj, cm->esc[v]) > 0)
	  rmid = '+';
	  }
	  if(cm->stid[v] == MATP_ML || cm->stid[v] == MATP_MR) {
	if(mode == TRMODE_J) {
	  ltop = rtop = 'x';     /* mark non-truncated half base-pairs (MATP_ML or MATP_MR) with 'x' */
	  lnegnc = rnegnc = 'v'; /* mark non-truncated half base-pairs (MATP_ML or MATP_MR) with 'v' */
	}
	  }
	  /* If we're storing a residue leftwise - just do it.
	   * If rightwise - push it onto stack.
	   */
	  if (do_left) {
	if (cm->rf != NULL) ali->rf[pos] = lrf;
	ali->cstr[pos]   = lstr;
	ali->cseq[pos]   = lcons;
	ali->mid[pos]    = lmid;
	ali->top[pos]    = (do_noncanonical) ? lnegnc : ltop;
	ali->aseq[pos]   = lseq;
	if(have_pcodes) {
	  ali->pcode[pos] = lpost;
	}
	ali->ccoord[pos] = cpos_l;
	ali->scoord[pos] = spos_l;
	pos++;
	  }
	  if (do_right) {
	if ((status = esl_stack_IPush(pda, spos_r)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, cpos_r)) != eslOK) goto ERROR;
	if(have_pcodes) {
	  if ((status = esl_stack_IPush(pda, (int) rpost)) != eslOK) goto ERROR;
	}
	if ((status = esl_stack_IPush(pda, (int) rseq)) != eslOK) goto ERROR;
	if (do_noncanonical) { if ((status = esl_stack_IPush(pda, (int) rnegnc)) != eslOK) goto ERROR; }
	else                 { if ((status = esl_stack_IPush(pda, (int) rtop))   != eslOK) goto ERROR; }
	if ((status = esl_stack_IPush(pda, (int) rmid)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rcons)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, (int) rstr)) != eslOK) goto ERROR;
	if (cm->rf != NULL) if ((status = esl_stack_IPush(pda, (int) rrf)) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_RESIDUE)) != eslOK) goto ERROR;
	  }

	  /* Push the child trace nodes onto the PDA;
	   * right first, so it pops last.
	   */
	  if (tr->nxtr[ti] != -1) {
	if ((status = esl_stack_IPush(pda, tr->nxtr[ti])) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	  }
	  if (tr->nxtl[ti] != -1) {
	if ((status = esl_stack_IPush(pda, tr->nxtl[ti])) != eslOK) goto ERROR;
	if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	  }
	  else if (cm->sttype[v] != E_st) {
		/* Catch marginal-type local ends, treat like EL for output */
	int numwidth;		/* number of chars to leave for displaying width numbers */

	nd = 1 + cm->ndidx[tr->state[ti]]; /* calculate node that EL replaced */
	qinset     = cons->rpos[nd] - cons->lpos[nd] + 1;
	tinset     = tr->emitr[ti]  - tr->emitl[ti]  + 1;
		if (tinset > 0) tinset--;
	ninset     = ESL_MAX(qinset,tinset);
	numwidth = 0; do { numwidth++; ninset/=10; } while (ninset); /* poor man's (int)log_10(ninset)+1 */
	memset(ali->cstr+pos,  '~', numwidth+4);
	sprintf(ali->cseq+pos, "*[%*d]*", numwidth, qinset);
	sprintf(ali->aseq+pos, "*[%*d]*", numwidth, tinset);
	/* do nothing for posteriors here, they'll stay as they were init'ed, as ' ' */
	pos += 4 + numwidth;
	  }
	} /* end loop over the PDA; PDA now empty */

  if (cm->rf != NULL) ali->rf[ali->len] = '\0';
  ali->cstr[ali->len] = '\0';
  ali->cseq[ali->len] = '\0';
  ali->mid[ali->len]  = '\0';
  ali->top[ali->len]  = '\0';
  ali->aseq[ali->len] = '\0';
  if(have_pcodes) {
	ali->pcode[ali->len] = '\0';
  }
  /* Laboriously determine the maximum bounds.
   */
  ali->sqfrom = 0;
  for (pos = 0; pos < ali->len; pos++)
	if (ali->scoord[pos] != 0) {
	  ali->sqfrom = ali->scoord[pos];
	  break;
	}
  ali->sqto = 0;
  for (pos = 0; pos < ali->len; pos++)
	if (ali->scoord[pos] != 0) ali->sqto = ali->scoord[pos];
  ali->cfrom = 0;
  for (pos = 0; pos < ali->len; pos++)
	if (ali->ccoord[pos] != 0) {
	  ali->cfrom = ali->ccoord[pos];
	  break;
	}
  ali->cto = 0;
  for (pos = 0; pos < ali->len; pos++)
	if (ali->ccoord[pos] != 0) ali->cto = ali->ccoord[pos];

  esl_stack_Destroy(pda);
  return ali;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return NULL; /* not reached */
}

/* Function: PrintFancyAli()
 * Date:     SRE, Thu Jun 13 02:23:18 2002 [Aula Magna, Stockholm]
 *
 * Purpose:  Write a CM/sequence alignment to a stream, from a
 *           Fancyali_t structure. Line length currently hardcoded
 *           but this could be changed. Modeled on HMMER's
 *           eponymous function.
 *
 *            Put at least <min_aliwidth> alignment characters per
 *            line; try to make lines no longer than <linewidth>
 *            characters, including name, coords, and spacing.  The
 *            width of lines may exceed <linewidth>, if that's what it
 *            takes to put a name, coords, and <min_aliwidth>
 *            characters of alignment on a line.
 *
 *            As a special case, if <linewidth> is negative or 0, then
 *            alignments are formatted in a single block of unlimited
 *            line length.
 *
 *
 * Args:     fp              - where to print it (stdout or open FILE)
 *           ali             - alignment structure to print.
 *           offset          - number of residues to add to target seq index,
 *                             to ease MPI search, all target hits start at posn 1
 *           in_revcomp      - TRUE if hit we're printing an alignment for a
 *                             cmsearch hit on reverse complement strand.
 *           do_top          - TRUE to turn on optional 'top-line' annotation.
 *                             This was set in CreateFancyAli() as marking either:
 *                             negative scoring (non-compensatories) and half-bps:
 *                             negative scoring *non-canonical* bps and half bps
 *                             (in this 2nd case negative scoring canonicals are unmarked)
 *           min_aliwidth    - min length for alignment block (see Purpose above)
 *           linewidth       - preferred line length (see Purpose above)
 *           show_accessions - TRUE to print seq/query accessions (if avail.), not names
 * Returns:  (void)
 */
void
PrintFancyAli(FILE *fp, Fancyali_t *ali, int64_t offset, int in_revcomp, int do_top, int linewidth)
{
  int   status;
  char *buf;
  int   pos;
  int   ci,  cj;		/* positions in CM consensus 1..clen */
  int   sqi, sqj;		/* positions in target seq 1..L      */
  int   i;
  int   i2print, j2print; /* i,j indices we'll print, used to deal with case of reverse complement */
  int   have_pcodes;      /* TRUE if posterior codes are valid */

  printf("in PrintFancyAli sqfrom..sqto %d..%d in_revcomp: %d offset: %" PRId64 "\n", ali->sqfrom, ali->sqto, in_revcomp, offset);

  have_pcodes = (ali->pcode != NULL) ? TRUE : FALSE;

  ESL_ALLOC(buf, sizeof(char) * (linewidth + 1));
  buf[linewidth] = '\0';
  for (pos = 0; pos < ali->len; pos += linewidth)
	{
	  /* Laboriously determine our coord bounds on dsq
	   * and consensus line for this alignment section.
	   */
	  sqi = 0;
	  for (i = pos; ali->aseq[i] != '\0' && i < pos + linewidth; i++) {
	if (ali->scoord[i] != 0) {
	  sqi = ali->scoord[i];
	  break;
	}
	  }
	  sqj = 0;
	  for (i = pos; ali->aseq[i] != '\0' && i < pos + linewidth; i++) {
	if (ali->scoord[i] != 0) sqj = ali->scoord[i];
	  }
	  ci = 0;
	  for (i = pos; ali->aseq[i] != '\0' && i < pos + linewidth; i++) {
	if (ali->ccoord[i] != 0) {
	  ci = ali->ccoord[i];
	  break;
	}
	  }
	  cj = 0;
	  for (i = pos; ali->aseq[i] != '\0' && i < pos + linewidth; i++) {
	if (ali->ccoord[i] != 0) cj = ali->ccoord[i];
	  }

	  /* Formats and print the alignment section.
	   */
	  if (ali->rf != NULL) {
	strncpy(buf, ali->rf+pos, linewidth);
	fprintf(fp, "  %8s %s\n", " ", buf);
	  }
	  if (do_top && ali->top != NULL) {
	strncpy(buf, ali->top+pos, linewidth);
	fprintf(fp, "  %8s %s\n", " ", buf);
	  }
	  if (ali->cstr != NULL) {
	strncpy(buf, ali->cstr+pos, linewidth);
	fprintf(fp, "  %8s %s\n", " ", buf);
	  }
	  if (ali->cseq != NULL) {
	strncpy(buf, ali->cseq+pos, linewidth);
	if (ci && cj)
	  fprintf(fp, "  %8d %s %-8d\n", ci, buf, cj);
	else
	  fprintf(fp, "  %8s %s %-8s\n", "-", buf, "-");
	  }
	  if (ali->mid != NULL) {
	strncpy(buf, ali->mid+pos,  linewidth);
	fprintf(fp, "  %8s %s\n", " ", buf);
	  }
	  if (ali->aseq != NULL) {
	strncpy(buf, ali->aseq+pos, linewidth);
	if (sqj && sqi) {
	  if(in_revcomp) {
	    i2print = offset - (sqi-1)    + 1;
	    j2print = i2print - (sqj-sqi);
	  }
	  else {
	    i2print = sqi + offset;
	    j2print = sqj + offset;
	  }
	  fprintf(fp, "  %8d %s %-8d\n", i2print, buf, j2print);
	}
	else {
	  fprintf(fp, "  %8s %s %-8s\n", "-", buf, "-");
	}
	  }
	  if (have_pcodes && ali->pcode != NULL) {
	strncpy(buf, ali->pcode+pos, linewidth);
	fprintf(fp, "  %8s %s\n", "PP", buf);
	  }
	  fprintf(fp, "\n");
	}
  free(buf);
  fflush(fp);
  return;

 ERROR:
  cm_Fail("Memory allocation error.\n");
}

/* Function:  FreeFancyAli()
 * Incept:    SRE, Fri May 24 15:37:30 2002 [St. Louis]
 */
void
FreeFancyAli(Fancyali_t *ali)
{
  if (ali->rf != NULL) free(ali->rf);
  if (ali->cstr   != NULL) free(ali->cstr);
  if (ali->cseq   != NULL) free(ali->cseq);
  if (ali->mid    != NULL) free(ali->mid);
  if (ali->top    != NULL) free(ali->top);
  if (ali->aseq   != NULL) free(ali->aseq);
  if (ali->pcode  != NULL) free(ali->pcode);
  if (ali->ccoord != NULL) free(ali->ccoord);
  if (ali->scoord != NULL) free(ali->scoord);
  free(ali);
}

/* Function:  CreateCMConsensus()
 * Incept:    SRE, Thu May 23 10:39:39 2002 [St. Louis]
 *
 * Purpose:   Create displayable strings for consensus sequence
 *            and consensus structure; also create map of
 *            nodes -> right and left consensus positions.
 *
 *            Consensus sequence shows maximum scoring residue(s)
 *            for each emitting node. If score < pthresh (for pairs)
 *            or < sthresh (for singlets), the residue is shown
 *            in lower case. (That is, "strong" consensus residues
 *            are in upper case.)
 *
 *            Currently, pthresh is hard-coded as 3.0 and sthresh as
 *            1.0 (previously v1.0.2 and earlier had these passed in,
 *            but they were always set as 3.0/1.0 so I modified the
 *            function prototype - feel free to change it back if you
 *            want different values, or want to let caller (user) set
 *            them)).
 *
 *            Consensus structure annotates
 *            base pairs according to "multifurcation order" (how
 *            many multifurcation loops are beneath this pair).
 *               terminal stems:  <>
 *               order 1:         ()
 *               order 2:         []
 *               order >2:        {}
 *            Singlets are annotated : if external, _ if hairpin,
 *            - if bulge or interior loop, and , for multifurcation loop.
 *
 *            Example:
 *                ::(((,,<<<__>>>,<<<__>>->,,)))::
 *                AAGGGAACCCTTGGGTGGGTTCCACAACCCAA
 *
 * Args:      cm  - the model
 *            abc - alphabet to create con->cseq with (often cm->abc)
 *
 * Returns:   Newly created CMConsensus_t.
 *            Caller frees w/ FreeCMConsensus().
 *            Returns NULL on any error.
 *
 * Xref:      STL6 p.58.
 */
CMConsensus_t *
CreateCMConsensus(CM_t *cm, const ESL_ALPHABET *abc)
{
  int       status;
  CMConsensus_t *con = NULL;    /* growing consensus info */
  char     *cseq = NULL;        /* growing consensus sequence display string   */
  char     *cstr = NULL;        /* growing consensus structure display string  */
  int      *ct;			/* growing ct Zuker pairing partnet string     */
  int      *lpos = NULL;        /* maps node->left consensus position, [0..nodes-1] */
  int      *rpos = NULL;        /* maps node->right consensus position, [0..nodes-1] */
  int       cpos;		/* current position in cseq, cstr              */
  int       nalloc;		/* current allocated length of cseq, cstr      */
  ESL_STACK *pda;               /* pushdown automaton used to traverse model   */
  int      *multiorder;         /* "height" of each node (multifurcation order), [0..nodes-1] */
  int      *inface;             /* face count for each node, inside */
  int      *outface;            /* face count for each node, outside */
  int       v, nd;
  int       type;
  char      lchar, rchar;
  char      lstruc, rstruc;
  int       x;
  int       pairpartner;	/* coord of left pairing partner of a right base */
  void     *tmp;                /* for ESL_RALLOC */
  /* bit score thresholds for base pairs (pthresh) and singlets
   * (sthresh) to be lowercased. These are hard-coded. If you want
   * to change them, consider changing the function prototype so they're
   * chosen by caller and passed in.
   */
  float     pthresh = 3.0;
  float     sthresh = 1.0;

  /* Contract check. CM must have log odds scores. Alphabet must make sense. */
  if(! (cm->flags & CMH_BITS)) return NULL;
  if(cm->abc->type == eslRNA) {
	if(abc->type != eslRNA && abc->type != eslDNA) return NULL;
  }
  else if(cm->abc->K != abc->K) return NULL;

  ESL_ALLOC(lpos, sizeof(int) * cm->nodes);
  ESL_ALLOC(rpos, sizeof(int) * cm->nodes);
  ESL_ALLOC(cseq, sizeof(char) * 100);
  ESL_ALLOC(cstr, sizeof(char) * 100);
  ESL_ALLOC(ct,   sizeof(int)  * 100);
  nalloc  = 100;
  cpos    = 0;

  for (nd = 0; nd < cm->nodes; nd++)
	lpos[nd] = rpos[nd] = -1;

  multiorder = createMultifurcationOrderChart(cm);
  createFaceCharts(cm, &inface, &outface);

  if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
  if ((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
  if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
  while (esl_stack_IPop(pda, &type) != eslEOD) {
	if (type == PDA_RESIDUE)
	  {
	esl_stack_IPop(pda, &x); rchar  = (char) x;
	esl_stack_IPop(pda, &x); rstruc = (char) x;
	esl_stack_IPop(pda, &pairpartner);
	esl_stack_IPop(pda, &nd);
	rpos[nd]   = cpos;
	cseq[cpos] = rchar;
	cstr[cpos] = rstruc;
	ct[cpos]   = pairpartner;
	if (pairpartner != -1) ct[pairpartner] = cpos;
	cpos++;
	  }
	else if (type == PDA_MARKER)
	  {
	esl_stack_IPop(pda, &nd);
	rpos[nd]   = cpos-1;
	  }
	else if (type == PDA_STATE)
	  {
	esl_stack_IPop(pda, &v);
	nd    = cm->ndidx[v];
	lchar = rchar = lstruc = rstruc = 0;

	/* Determine what we emit:
	 * MATP, MATL, MATR consensus states only.
	 */
	if (cm->stid[v] == MATP_MP)
	  {
	    x = esl_vec_FArgMax(cm->esc[v], abc->K*abc->K);
	    lchar = abc->sym[x / abc->K];
	    rchar = abc->sym[x % abc->K];
	    if (cm->esc[v][x] < pthresh) {
	      lchar = tolower((int) lchar);
	      rchar = tolower((int) rchar);
	    }
	    switch (multiorder[nd]) {
	    case 0:  lstruc = '<'; rstruc = '>'; break;
	    case 1:  lstruc = '('; rstruc = ')'; break;
	    case 2:  lstruc = '['; rstruc = ']'; break;
	    default: lstruc = '{'; rstruc = '}'; break;
	    }
	} else if (cm->stid[v] == MATL_ML) {
	  x = esl_vec_FArgMax(cm->esc[v], cm->abc->K);
	  lchar = abc->sym[x];
	  if (cm->esc[v][x] < sthresh) lchar = tolower((int) lchar);
	  if      (outface[nd] == 0)                    lstruc = ':'; /* external ss */
	  else if (inface[nd] == 0 && outface[nd] == 1) lstruc = '_'; /* hairpin loop */
	  else if (inface[nd] == 1 && outface[nd] == 1) lstruc = '-'; /* bulge/interior */
	  else                                          lstruc = ','; /* multiloop */
	  rstruc = ' ';
	} else if (cm->stid[v] == MATR_MR) {
	  x = esl_vec_FArgMax(cm->esc[v], cm->abc->K);
	  rchar = abc->sym[x];
	  if (cm->esc[v][x] < sthresh) rchar = tolower((int) rchar);
	  if      (outface[nd] == 0)                    rstruc = ':'; /* external ss */
	  else if (inface[nd] == 0 && outface[nd] == 1) rstruc = '?'; /* doesn't happen */
	  else if (inface[nd] == 1 && outface[nd] == 1) rstruc = '-'; /* bulge/interior */
	  else                                          rstruc = ','; /* multiloop */
	  lstruc = ' ';
	}

	/* Emit. A left base, we can do now;
	 * a right base, we defer onto PDA.
	 */
	lpos[nd]   = cpos;	/* we always set lpos, rpos even for nonemitters */
	if (lchar) {
	  cseq[cpos] = lchar;
	  cstr[cpos] = lstruc;
	  ct[cpos]   = -1;	/* will be overwritten, if needed, when right guy is processed */
	  cpos++;
	}
	if (rchar) {
	  if ((status = esl_stack_IPush(pda, nd)) != eslOK) goto ERROR;
	  if (lchar) { if ((status = esl_stack_IPush(pda, cpos-1)) != eslOK) goto ERROR; }
	  else       { if ((status = esl_stack_IPush(pda, -1)) != eslOK) goto ERROR; }
	  if ((status = esl_stack_IPush(pda, rstruc)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(pda, rchar)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(pda, PDA_RESIDUE)) != eslOK) goto ERROR;
	} else {
	  if ((status = esl_stack_IPush(pda, nd)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(pda, PDA_MARKER)) != eslOK) goto ERROR;
	}

	/* Transit - to consensus states only.
	 * The obfuscated idiom finds the index of the next consensus
	 * state without making assumptions about numbering or connectivity.
	 */
	if (cm->sttype[v] == B_st) {
	  if ((status = esl_stack_IPush(pda, cm->cnum[v])) != eslOK) goto ERROR;     /* right S  */
	  if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(pda, cm->cfirst[v])) != eslOK) goto ERROR;   /* left S */
	  if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	} else if (cm->sttype[v] != E_st) {
	  v = cm->nodemap[cm->ndidx[cm->cfirst[v] + cm->cnum[v] - 1]];
	  if ((status = esl_stack_IPush(pda, v)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(pda, PDA_STATE)) != eslOK) goto ERROR;
	}
	  } /*end PDA_STATE block*/

	if (cpos == nalloc) {
	  nalloc += 100;
	  ESL_RALLOC(cseq, tmp, sizeof(char) * nalloc);
	  ESL_RALLOC(cstr, tmp, sizeof(char) * nalloc);
	  ESL_RALLOC(ct,   tmp, sizeof(int)  * nalloc);
	}
  }/* PDA now empty... done generating cseq, cstr, and node->consensus residue map */
  cseq[cpos] = '\0';
  cstr[cpos] = '\0';

  esl_stack_Destroy(pda);
  free(multiorder);
  free(inface);
  free(outface);

  ESL_ALLOC(con, sizeof(CMConsensus_t));
  con->cseq = cseq;
  con->cstr = cstr;
  con->ct   = ct;
  con->lpos = lpos;
  con->rpos = rpos;
  con->clen = cpos;
  return con;

 ERROR:
  if(cseq != NULL) free(cseq);
  if(cstr != NULL) free(cstr);
  if(ct   != NULL) free(ct);
  if(lpos != NULL) free(lpos);
  if(rpos != NULL) free(rpos);
  if(con  != NULL) free(con);
  return NULL;
}

void
FreeCMConsensus(CMConsensus_t *con)
{
  if (con->cseq != NULL) free(con->cseq);
  if (con->cstr != NULL) free(con->cstr);
  if (con->ct   != NULL) free(con->ct);
  if (con->lpos != NULL) free(con->lpos);
  if (con->rpos != NULL) free(con->rpos);
  free(con);
}

/* Function:  createMultifurcationOrderChart()
 * Incept:    SRE, Thu May 23 09:48:33 2002 [St. Louis]
 *
 * Purpose:   Calculates the degree of multifurcation beneath
 *            the master subtree rooted at every node n.
 *            Returns [0..nodes-1] array of these values.
 *
 *            Terminal stems have value 0. All nodes n starting with
 *            the BEG node for a terminal stem have height[n] = 0.
 *
 *            A stem "above" a multifurcation into all terminal stems
 *            has value 1; all nodes n starting with BEG and ending
 *            with BIF have height[n] = 1.
 *
 *            And so on, for "higher order" (deeper) multifurcations.
 *
 *            Used for figuring out what characters we'll display a
 *            consensus pair with.
 *
 *            THIS FUNCTION IS BUGGY (Sat Jun  1 12:24:23 2002)
 *
 * Args:      cm - the model.
 *
 * Returns:   [0..cm->nodes-1] array of multifurcation orders, for each node.
 *            This array is allocated here; caller free's w/ free().
 *
 * xref:     STL6 p.58.
 */
static int *
createMultifurcationOrderChart(CM_t *cm)
{
  int status;
  int  v, nd, left, right;
  int *height;
  int *seg_has_pairs;

  ESL_ALLOC(height,        sizeof(int) * cm->nodes);
  ESL_ALLOC(seg_has_pairs, sizeof(int) * cm->nodes);
  for (nd = cm->nodes-1; nd >= 0; nd--)
	{
	  v = cm->nodemap[nd];

	  if       (cm->stid[v] == MATP_MP) seg_has_pairs[nd] = TRUE;
	  else if  (cm->stid[v] == END_E)   seg_has_pairs[nd] = FALSE;
	  else if  (cm->stid[v] == BIF_B)   seg_has_pairs[nd] = FALSE;
	  else                              seg_has_pairs[nd] = seg_has_pairs[nd+1];

	  if (cm->stid[v] == END_E)
	height[nd]        = 0;
	  else if (cm->stid[v] == BIF_B)
	{
	  left  = cm->ndidx[cm->cfirst[v]];
	  right = cm->ndidx[cm->cnum[v]];
	  height[nd] = ESL_MAX(height[left] + seg_has_pairs[left],
			       height[right] + seg_has_pairs[right]);
	}
	  else
	height[nd] = height[nd+1];
	}
  free(seg_has_pairs);
  return height;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return 0; /* never reached */
}

/* Function:  createFaceCharts()
 * Incept:    SRE, Thu May 23 12:40:04 2002 [St. Louis]
 *
 * Purpose:   Calculate "inface" and "outface" for each node
 *            in the consensus (master) structure of the CM.
 *            These can be used to label nodes:
 *                                inface       outface
 *                             ------------   ----------
 *             external ss         any           0
 *             hairpin loop         0            1
 *             bulge/interior       1            1
 *             multifurc           >1            1
 *             multifurc            1           >1
 *             doesn't happen       0           >1
 *
 *             hairpin closing bp   0            1
 *             extern closing bp    1            0
 *             stem bp              1            1
 *             multifurc close bp  >1            1
 *             multifurc close bp   1           >1
 *             doesn't happen       0           >1
 *
 * Args:       cm          - the model
 *             ret_inface  - RETURN: inface[0..nodes-1]
 *             ret_outface - RETURN: outface[0..nodes-1]
 *
 * Returns:    inface, outface;
 *             they're alloc'ed here. Caller free's with free()
 *
 * Xref:       STL6 p.58
 */
static void
createFaceCharts(CM_t *cm, int **ret_inface, int **ret_outface)
{
  int  status;
  int *inface;
  int *outface;
  int  nd, left, right, parent;
  int  v,w,y;

  ESL_ALLOC(inface,  sizeof(int) * cm->nodes);
  ESL_ALLOC(outface, sizeof(int) * cm->nodes);

  /* inface - the number of faces below us in descendant
   *          subtrees. if 0, we're either external, or
   *          a closing basepair, or we're in a hairpin loop.
   *          inface is exclusive of current pair - so we
   *          can easily detect closing base pairs.
   */
  for (nd = cm->nodes-1; nd >= 0; nd--)
	{
	  v = cm->nodemap[nd];
	  if      (cm->ndtype[nd] == END_nd) inface[nd] = 0;
	  else if (cm->ndtype[nd] == BIF_nd) {
	left  = cm->ndidx[cm->cfirst[v]];
	right = cm->ndidx[cm->cnum[v]];
	inface[nd] = inface[left] + inface[right];
	  } else {
	if (cm->ndtype[nd+1] == MATP_nd) inface[nd] = 1;
	else                             inface[nd] = inface[nd+1];
	  }
	}

  /* outface - the number of faces above us in the tree
   *           excluding our subtree. if 0, we're external.
   *           Like inface, outface is exclusive of current
   *           pair.
   */
  for (nd = 0; nd < cm->nodes; nd++)
	{
	  v = cm->nodemap[nd];
	  if      (cm->ndtype[nd] == ROOT_nd) outface[nd] = 0;
	  else if (cm->ndtype[nd] == BEGL_nd)
	{
	  parent = cm->ndidx[cm->plast[v]];
	  y      = cm->nodemap[parent];
	  right  = cm->ndidx[cm->cnum[y]];
	  outface[nd] = outface[parent] + inface[right];
	}
	  else if (cm->ndtype[nd] == BEGR_nd)
	{
	  parent = cm->ndidx[cm->plast[v]];
	  w      = cm->nodemap[parent];
	  left   = cm->ndidx[cm->cfirst[y]];
	  outface[nd] = outface[parent] + inface[left];
	}
	  else
	{
	  parent = nd-1;
	  if (cm->ndtype[parent] == MATP_nd) outface[nd] = 1;
	  else                               outface[nd] = outface[parent];
	}
	}

  *ret_inface  = inface;
  *ret_outface = outface;
  return;

 ERROR:
  cm_Fail("Memory allocation error.\n");
}

/* Function: IsCompensatory()
 * Date:     SRE, Sun Jun  2 10:16:59 2002 [Madison]
 *
 * Purpose:  Returns TRUE if log[pij/(pi*pj)] is >= 0,
 *           where pij is the probability of a base pair,
 *           pi and pj are the marginal probabilities
 *           for the symbols at i and j.
 *
 *           Currently returns FALSE if symi or symj
 *           are ambiguous IUPAC nucs. Could do a more
 *           sophisticated marginalization - prob not
 *           worth it right now.
 *
 * Args:     pij  - joint emission probability vector [0..15]
 *                  indexed symi*4 + symj.
 *           symi - symbol index at i [0..3], equiv to [a..u]
 *           symj - symbol index at j [0..3], equiv to [a..u]
 *
 * Returns:  TRUE or FALSE.
 */
int
IsCompensatory(const ESL_ALPHABET *abc, float *pij, int symi, int symj)
{
  int   x;
  float pi, pj;

  if (symi >= abc->K || symj >= abc->K)
	return FALSE;

  pi = pj = 0.;
  for (x = 0; x < abc->K; x++)
	{
	  pi += pij[symi*abc->K + x];
	  pj += pij[x*abc->K    + symi];
	}
  if (log(pij[symi*abc->K+symj]) - log(pi) - log(pj) >= 0)
	return TRUE;
  else
	return FALSE;
}

/* Implementation of CMEmitMap_t structure:
 * map of a CM's nodes onto consensus sequence positions.
 * Structure is declared in infernal.h.
 *
 * Used for constructing multiple alignments.
 *
 *   clen              : consensus length.
 *       clen is 2* n(MATP) + n(MATL) + n(MATR).
 *       The consensus sequence is indexed 1..clen.
 *       0 and clen+1 are also used, as boundary conditions.
 *
 *   lpos[0..nodes-1]  : has values 0 to clen+1.
 *       Any left match emission from node nd is placed in lpos[nd].
 *       Any left insert emission from node nd *follows* lpos[nd].
 *
 *   rpos[0..nodes-1]  : has values 0..clen+1
 *       Any right match emission from node nd is placed in rpos[nd].
 *       Any right insert emission from node nd *precedes* rpos[nd]
 *
 *   epos[0..nodes-1]  : has values 0..clen+1.
 *       Any EL insertion from a nd->EL transition *follows* epos[nd].
 *
 * There are no dummy values; all lpos, rpos, epos are valid coords
 * 0..clen+1, as described above, even for END_nd's.
 *
 * For nonemitting nodes, rpos and lpos give a noninclusive bound:
 * for example, lpos[0] = 0 and rpos[0] = clen+1 by definition.
 *
 * Insertions occur between consensus positions. An inter-consensus-position
 * space may contain more than one type of insertion: an IL insertion and
 * an EL insertion, an IR insertion and an EL insertion; or (in
 * a single absurd case of a model with a consensus length of 0)
 * all three insertion types. Insertions are placed in order IL/EL/IR.
 *
 */

/* Function: CreateEmitMap()
 * Date:     ? (SRE pre Infernal version 0.55).
 *
 * Purpose:  Create and fill an emit map for a given CM <cm>
 *           and return it.
 *           If we run out of memory or we have a problem creating
 *           the map, we return NULL.
 *
 */

CMEmitMap_t *
CreateEmitMap(CM_t *cm)
{
  int          status;
  CMEmitMap_t *map = NULL;
  ESL_STACK   *pda;
  int          cpos;
  int          nd;
  int          on_right;

  ESL_ALLOC(map,       sizeof(CMEmitMap_t));
  ESL_ALLOC(map->lpos, sizeof(int) * cm->nodes);
  ESL_ALLOC(map->rpos, sizeof(int) * cm->nodes);
  ESL_ALLOC(map->epos, sizeof(int) * cm->nodes);

  for (nd = 0; nd < cm->nodes; nd++)
	map->lpos[nd] = map->rpos[nd] = map->epos[nd] = -1;

  cpos = 0;
  nd   = 0;
  if ((pda  = esl_stack_ICreate()) == NULL) goto ERROR;
  if ((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;		/* 0 = left side. 1 would = right side. */
  if ((status = esl_stack_IPush(pda, nd)) != eslOK) goto ERROR;
  while (esl_stack_IPop(pda, &nd) != eslEOD)
	{
	  esl_stack_IPop(pda, &on_right);

	  if (on_right)
	{
	  map->rpos[nd] = cpos+1;
	  if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) cpos++;
	}
	  else
	{
	  if (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) cpos++;
	  map->lpos[nd] = cpos;

	  if (cm->ndtype[nd] == BIF_nd)
	    {
				/* push the BIF back on for its right side  */
	      if ((status = esl_stack_IPush(pda, 1)) != eslOK) goto ERROR;
	      if ((status = esl_stack_IPush(pda, nd)) != eslOK) goto ERROR;
							/* push node index for right child */
	      if ((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
	      if ((status = esl_stack_IPush(pda, cm->ndidx[cm->cnum[cm->nodemap[nd]]])) != eslOK) goto ERROR;
							/* push node index for left child */
	      if ((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
	      if ((status = esl_stack_IPush(pda, cm->ndidx[cm->cfirst[cm->nodemap[nd]]])) != eslOK) goto ERROR;
	    }
	  else
	    {
				/* push the node back on for right side */
	      if ((status = esl_stack_IPush(pda, 1)) != eslOK) goto ERROR;
	      if ((status = esl_stack_IPush(pda, nd)) != eslOK) goto ERROR;
				/* push child node on */
	      if (cm->ndtype[nd] != END_nd) {
		if ((status = esl_stack_IPush(pda, 0)) != eslOK) goto ERROR;
		if ((status = esl_stack_IPush(pda, nd+1)) != eslOK) goto ERROR;
	      }
	    }
	}
	}

  /* Construct the epos map: if we do a v->EL transition,
   * the EL follows what consensus position (and its IL insertions,
   * if any)
   */
  for (nd = cm->nodes-1; nd >= 0; nd--) {
	if (cm->ndtype[nd] == END_nd)
	  cpos = map->lpos[nd];
	else if (cm->ndtype[nd] == BIF_nd) /* propagate epos for *right* branch. */
	  cpos = map->epos[cm->ndidx[cm->cnum[cm->nodemap[nd]]]];

	map->epos[nd] = cpos;
  }

  map->clen = map->rpos[0]-1;
  esl_stack_Destroy(pda);

  /* ensure we've filled in the map correctly */
  for (nd = 0; nd < cm->nodes; nd++) {
	if(map->lpos[nd] == -1) goto ERROR;
	if(map->rpos[nd] == -1) goto ERROR;
	if(map->epos[nd] == -1) goto ERROR;
  }

  return map;

 ERROR:
  if(map != NULL) FreeEmitMap(map);
  return NULL;
}

/* Function: SizeofEmitMap()
 * Date:     EPN, Wed Jan 18 10:15:46 2012
 *
 * Purpose:  Calculate and return the size of an emit map
 *           in Mb.
 */

float
SizeofEmitMap(CM_t *cm, CMEmitMap_t *emap)
{
  float bytes = 0.;

  if(emap == NULL) return 0.;

  bytes = sizeof(CMEmitMap_t);
  bytes += sizeof(int) * cm->nodes; /* lpos */
  bytes += sizeof(int) * cm->nodes; /* rpos */
  bytes += sizeof(int) * cm->nodes; /* epos */

  return bytes / 1000000.;
}

void
DumpEmitMap(FILE *fp, CMEmitMap_t *map, CM_t *cm)
{
  int nd;

  fprintf(fp, "CM to consensus emit map; consensus length = %d \n",
	  map->clen);
  fprintf(fp, "%4s %7s %9s %4s %4s %4s\n",
	  "Node", "State 1", "Node type", "lpos", "rpos", "epos");
  fprintf(fp, "%4s %7s %9s %4s %4s %4s\n",
	  "----", "-------", "---------", "----", "----", "----");
  for (nd = 0; nd < cm->nodes; nd++)
	fprintf(fp, "%4d %7d %9s %4d %4d %4d\n",
	    nd, cm->nodemap[nd], Nodetype(cm->ndtype[nd]),
	    map->lpos[nd], map->rpos[nd], map->epos[nd]);
}

void
FreeEmitMap(CMEmitMap_t *map)
{
  free(map->lpos);
  free(map->rpos);
  free(map->epos);
  free(map);
}

/* format_time_string()
 * Date:     SRE, Fri Nov 26 15:06:28 1999 [St. Louis]
 *
 * Purpose:  Given a number of seconds, format into
 *           hh:mm:ss.xx in a provided buffer.
 *
 * Args:     buf     - allocated space (128 is plenty!)
 *           sec     - number of seconds
 *           do_frac - TRUE (1) to include hundredths of a sec
 */
void
FormatTimeString(char *buf, double sec, int do_frac)
{
  int h, m, s, hs;

  h  = (int) (sec / 3600.);
  m  = (int) (sec / 60.) - h * 60;
  s  = (int) (sec) - h * 3600 - m * 60;
  if (do_frac) {
	hs = (int) (sec * 100.) - h * 360000 - m * 6000 - s * 100;
	sprintf(buf, "%02d:%02d:%02d.%02d", h,m,s,hs);
  } else {
	sprintf(buf, "%02d:%02d:%02d", h,m,s);
  }
}

/* Function: GetCommand
 * Date:     EPN, Fri Jan 25 13:56:10 2008
 *
 * Purpose:  Return the command used to call an infernal executable
 *           in <ret_command>.
 *
 * Returns:  eslOK on success; eslEMEM on allocation failure.
 */
int
GetCommand(const ESL_GETOPTS *go, char *errbuf, char **ret_command)
{
  int status;
  int i;
  char *command = NULL;

  for (i = 0; i < go->argc; i++) { /* copy all command line options and args */
	if((status = esl_strcat(&(command),  -1, go->argv[i], -1)) != eslOK) goto ERROR;
	if(i < (go->argc-1)) if((status = esl_strcat(&(command), -1, " ", 1)) != eslOK) goto ERROR;
  }
  *ret_command = command;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "GetCommand(): memory allocation error.");
  return status;
}

/* Function: GetDate
 * Date:     EPN, Fri Jan 25 13:59:22 2008
 *
 * Purpose:  Return a string that gives the current date.
 *
 * Returns:  eslOK on success; eslEMEM on allocation failure.
 */
int
GetDate(char *errbuf, char **ret_date)
{
  int    status;
  time_t date = time(NULL);
  char  *sdate = NULL;

  if((status = esl_strdup(ctime(&date), -1, &sdate)) != eslOK) goto ERROR;
  esl_strchop(sdate, -1); /* doesn't return anything but eslOK */

  *ret_date = sdate;
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "get_date() error status: %d, probably out of memory.", status);
  return status;
}

/*** End of inlined file: display.c ***/


/*** Start of inlined file: errors.c ***/

#include <stdlib.h>
#include <stdio.h>


/* Function:  cm_Die()
 * Incept:    EPN, Fri Jul 27 14:35:44 2007
 *
 * Purpose:   Handle a fatal exception (something that's the system's fault,
 *            including memory allocation failures; or possibly our fault).
 */
void
cm_Die(char *format, ...)
{
  va_list  argp;
								/* format the error mesg */
  fprintf(stderr, "\nFATAL: ");
  va_start(argp, format);
  vfprintf(stderr, format, argp);
  va_end(argp);
  fprintf(stderr, "\n");
  fflush(stderr);
  exit(1);
}

/* Function:  cm_Fail()
 * Incept:    EPN, Fri Jul 27 14:35:58 2007
 *
 * Purpose:   Handle a user error (something that's the user's fault).
 */
void
cm_Fail(char *format, ...)
{
  va_list  argp;
								/* format the error mesg */
  fprintf(stderr, "\nError: ");
  va_start(argp, format);
  vfprintf(stderr, format, argp);
  va_end(argp);
  fprintf(stderr, "\n");
  fflush(stderr);
  exit(1);
}

/*** End of inlined file: errors.c ***/


/*** Start of inlined file: eweight.c ***/
/* eweight.c [EPN 11.07.05]
 * based on: HMMER 2.4devl's lsj_eweight.c
 * Most original comments from lsj_eweight.c untouched.
 *
 * LSJ, Wed Feb  4 15:03:58 CST 2004
 *
 * entropy targeting:
 * Code for setting effective sequence number (in cmbuild) by
 * achieving a certain target entropy loss, relative to background
 * null distribution.
 *
 * SVN $Id$
 */


#include <stdio.h>
#include <string.h>
#include <math.h>


struct ew_param_s {
  CM_t      *cm;		/* ptr to the original count-based CM, cm->t and cm->e be changed, but we have a copy of the original data in t_orig and e_orig */
  const Prior_t *pri;		/* Dirichlet prior used to parameterize from counts */
  float           **t_orig;     /* copy of initial (when this object was created) CM transitions in counts form */
  float           **e_orig;     /* copy of initial (when this object was created) CM emissions   in counts form */
  float           *begin_orig;  /* copy of initial (when this object was created) CM begin transitions in counts form */
  float           *end_orig;    /* copy of initial (when this object was created) CM end transitions in counts form */
  double           etarget;	/* information content target, in bits */
};

/* Evaluate fx = cm rel entropy - etarget, which we want to be = 0,
 * for effective sequence number <Neff>.
 */
static int
cm_eweight_target_f(double Neff, void *params, double *ret_fx)
{
  struct ew_param_s *p = (struct ew_param_s *) params;
  int v, i;
  /*printf("cm_eweight_target_f() Neff:  %f\n", Neff); */

  /* copy parameters from to p->*_orig to CM arrays */
  for (v = 0; v < p->cm->M; v++) {
	for (i = 0; i < MAXCONNECT; i++)                    p->cm->t[v][i] = p->t_orig[v][i];
	for (i = 0; i < p->cm->abc->K * p->cm->abc->K; i++) p->cm->e[v][i] = p->e_orig[v][i];
	p->cm->begin[v] = p->begin_orig[v];
	p->cm->end[v]   = p->end_orig[v];
  }
  cm_Rescale(p->cm, Neff / (double) p->cm->nseq);
  PriorifyCM(p->cm, p->pri);
  *ret_fx = cm_MeanMatchRelativeEntropy(p->cm) - p->etarget; /* only diff with hmm_eweight_target_f */
  return eslOK;
}

/* Evaluate fx = hmm rel entropy - etarget, which we want to be = 0,
 * for effective sequence number <x>. Differs from cm_eweight_target_f
 * in that emissions from MATP_MP pair emitting states are marginalized
 * out, effectively treating the CM like an HMM. This is done with
 * a cm_MeanMatchRelativeEntropyHMM() instead of cm_MeanMatchRelativeEntropy().
 *
 */
static int
hmm_eweight_target_f(double Neff, void *params, double *ret_fx)
{
  struct ew_param_s *p = (struct ew_param_s *) params;
  int v, i;
  /*printf("hmm_eweight_target_f() Neff: %f\n", Neff); */

  /* copy parameters from CM to p->*_orig arrays */
  for (v = 0; v < p->cm->M; v++) {
	for (i = 0; i < MAXCONNECT; i++)                    p->cm->t[v][i] = p->t_orig[v][i];
	for (i = 0; i < p->cm->abc->K * p->cm->abc->K; i++) p->cm->e[v][i] = p->e_orig[v][i];
	p->cm->begin[v] = p->begin_orig[v];
	p->cm->end[v]   = p->end_orig[v];
  }
  cm_Rescale(p->cm, Neff / (double) p->cm->nseq);
  PriorifyCM(p->cm, p->pri);
  *ret_fx = cm_MeanMatchRelativeEntropyHMM(p->cm) - p->etarget; /* only diff with cm_eweight_target_f */
  return eslOK;
}

/* Function:  cm_EntropyWeight()
 * Incept:    EPN, Mon Jan  7 07:19:46 2008
 *            based on HMMER3's p7_EntropyWeight()
 *            SRE, Fri May  4 15:32:59 2007 [Janelia]
 *
 * Purpose:   Use the "entropy weighting" algorithm to determine
 *            what effective sequence number we should use, and
 *            return it in <ret_Neff>.
 *
 *            Caller provides a count-based <cm>, and the
 *            Dirichlet prior <pri> that's to be used to parameterize
 *            models; neither of these will be modified.
 *            Caller also provides the relative entropy
 *            target in bits in <etarget>.
 *
 *            <ret_Neff> will range from min_Neff to the true number of
 *            sequences counted into the model, <hmm->nseq>.
 *
 *            If <pretend_cm_is_hmm> is TRUE the CM's MATP_MP pair
 *            emissions are marginalized, treating pair emitting states
 *            effectively as a pair of singlet emitting states.
 *
 *
 * Returns:   <eslOK> on success.
 *
 * Throws:    <eslEMEM> on allocation failure.
 */
int
cm_EntropyWeight(CM_t *cm, const Prior_t *pri, double etarget, double min_Neff, int pretend_cm_is_hmm, double *ret_hmm_re, double *ret_Neff)
{
  int status;
  ESL_ROOTFINDER *R = NULL;
  struct ew_param_s p;
  double Neff;
  double fx;
  double hmm_re;
  int v, i;

  /* Store parameters in the structure we'll pass to the rootfinder
   */
  p.cm = cm;
  /* copy parameters of the CM that will be changed by cm_Rescale() */
  ESL_ALLOC(p.t_orig,     (cm->M) * sizeof(float *));
  ESL_ALLOC(p.e_orig,     (cm->M) * sizeof(float *));
  ESL_ALLOC(p.begin_orig, (cm->M) * sizeof(float));
  ESL_ALLOC(p.end_orig,   (cm->M) * sizeof(float));

  p.t_orig[0]   = NULL;
  p.e_orig[0]   = NULL;
  ESL_ALLOC(p.t_orig[0], MAXCONNECT * cm->M * sizeof(float));
  ESL_ALLOC(p.e_orig[0], cm->abc->K * cm->abc->K * cm->M * sizeof(float));
  for (v = 0; v < cm->M; v++) {
	p.t_orig[v]    = p.t_orig[0]    + v * MAXCONNECT;
	p.e_orig[v]    = p.e_orig[0]    + v * (cm->abc->K * cm->abc->K);
  }
  for (v = 0; v < p.cm->M; v++) {
	for (i = 0; i < MAXCONNECT; i++)              p.t_orig[v][i] = cm->t[v][i];
	for (i = 0; i < cm->abc->K * cm->abc->K; i++) p.e_orig[v][i] = cm->e[v][i];
	p.begin_orig[v] = cm->begin[v];
	p.end_orig[v]   = cm->end[v];
  }
  p.pri = pri;
  p.etarget = etarget;

  /* First, check if min_Neff gives a rel entropy >= e.target, if so
   * set Neff to min_Neff.  In this case its impossible to get a Neff
   * < min_Neff that a relent == etarget, so we use min_Neff;
   */
  Neff = min_Neff;
  if(pretend_cm_is_hmm) { if ((status = hmm_eweight_target_f(Neff, &p, &fx)) != eslOK)    goto ERROR; }
  else                  { if ((status = cm_eweight_target_f(Neff, &p, &fx)) != eslOK)     goto ERROR; }
  if(fx < 0.) { /* an Neff > min_Neff that gives a rel entropy of p.etarget is achievable, find it */
	Neff = (double) cm->nseq;
	if(pretend_cm_is_hmm) { if ((status = hmm_eweight_target_f(Neff, &p, &fx)) != eslOK)    goto ERROR; }
	else                  { if ((status = cm_eweight_target_f(Neff, &p, &fx)) != eslOK)     goto ERROR; }

	if (fx > 0.) {
	  if(pretend_cm_is_hmm) { if ((R = esl_rootfinder_Create(hmm_eweight_target_f, &p))    == NULL) {status = eslEMEM; goto ERROR;} }
	  else                  { if ((R = esl_rootfinder_Create(cm_eweight_target_f, &p))     == NULL) {status = eslEMEM; goto ERROR;} }
	  esl_rootfinder_SetAbsoluteTolerance(R, 0.01); /* getting Neff to ~2 sig digits is fine */
	  if ((status = esl_root_Bisection(R, 0., (double) cm->nseq, &Neff)) != eslOK) goto ERROR;

	  esl_rootfinder_Destroy(R);
	}
  }
  /* we've found Neff, determine the relative entropy of the CM if we marginalize the MP pair emissions,
   * this is (ALMOST) the relative entropy of the CP9 HMM we'll eventually construct from it,
   * (it's only ALMOST b/c the CP9 will have marginalized emissions from the MATP_MP PLUS the MATP_ML
   * state weighted by the expected number of times each state is visited).
   */
  hmm_re = cm_MeanMatchRelativeEntropyHMM(p.cm);

  /* reset CM params to their original values */
  for (v = 0; v < cm->M; v++) {
	for (i = 0; i < MAXCONNECT; i++)              cm->t[v][i] = p.t_orig[v][i];
	for (i = 0; i < cm->abc->K * cm->abc->K; i++) cm->e[v][i] = p.e_orig[v][i];
	cm->begin[v] = p.begin_orig[v];
	cm->end[v]   = p.end_orig[v];
  }
  /* free params p */
  free(p.t_orig[0]);
  free(p.t_orig);
  free(p.e_orig[0]);
  free(p.e_orig);
  free(p.begin_orig);
  free(p.end_orig);

  *ret_hmm_re = hmm_re;
  *ret_Neff = Neff;
  return eslOK;

 ERROR:
  if (R    != NULL)   esl_rootfinder_Destroy(R);
  *ret_Neff = (double) cm->nseq;
  return status;
}

/* Function:  cm_Rescale()
 *
 * Incept:    EPN 11.07.05
 * based on:  HMMER's plan7.c's Plan7Rescale() (Steve Johnson)
 *
 * Purpose:   Scale a counts-based CM by some factor, for
 *            adjusting counts to a new effective sequence number.
 *
 * Args:      cm         - counts based CM.
 *            scale      - scaling factor (e.g. eff_nseq/nseq); 1.0= no scaling.
 *
 * Returns:   (void)
 */
void
cm_Rescale(CM_t *cm, float scale)
{
  int v;

  for (v = 0; v < cm->M; v++)
	{
	  /* Scale transition counts vector if not a BIF or E state */
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	{
	  /* Number of transitions is cm->cnum[v] */
	  esl_vec_FScale(cm->t[v], cm->cnum[v], scale);
	}
	  /* Scale emission counts vectors */
	  if (cm->sttype[v] == MP_st)
	{       /* Consensus base pairs */
	  esl_vec_FScale(cm->e[v], (cm->abc->K*cm->abc->K), scale);
	}
	  else if ((cm->sttype[v] == ML_st) ||
	       (cm->sttype[v] == MR_st) ||
	       (cm->sttype[v] == IL_st) ||
	       (cm->sttype[v] == IR_st))
	{      /* singlets (some consensus, some not)*/
	  esl_vec_FScale(cm->e[v], cm->abc->K, scale);
	}
	}/* end loop over states v */

  /* begin, end transitions; only valid [0..M-1] */
  esl_vec_FScale(cm->begin, cm->M, scale);
  esl_vec_FScale(cm->end,   cm->M, scale);

  return;
}

/* Function:  cp9_Rescale()
 *            EPN based on Steve Johnsons plan 7 version
 *
 * Purpose:   Scale a counts-based HMM by some factor, for
 *            adjusting counts to a new effective sequence number.
 *
 * Args:      hmm        - counts based HMM.
 *            scale      - scaling factor (e.g. eff_nseq/nseq); 1.0= no scaling.
 *
 * Returns:   (void)
 */
void
cp9_Rescale(CP9_t *hmm, float scale)
{
  int k;

  /* emissions and transitions in the main model.
   * Note that match states are 1..M, insert states are 0..M,
   * and deletes are 0..M-1
   */
  for(k = 1; k <= hmm->M; k++)
	esl_vec_FScale(hmm->mat[k], hmm->abc->K, scale);
  for(k = 0; k <=  hmm->M; k++)
	esl_vec_FScale(hmm->ins[k], hmm->abc->K, scale);
  for(k = 0; k <  hmm->M; k++)
	esl_vec_FScale(hmm->t[k],   cp9_NTRANS,             scale);

  /* begin, end transitions; only valid [1..M] */
  esl_vec_FScale(hmm->begin+1, hmm->M, scale);
  esl_vec_FScale(hmm->end+1,   hmm->M, scale);

  return;
}

/* Function:  cm_MeanMatchInfo()
 * Incept:    SRE, Fri May  4 11:43:56 2007 [Janelia]
 *
 * Purpose:   Calculate the mean information content per match state
 *            emission distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{k=1}^{M}
 *                \left[
 *                   - \sum_x p_k(x) \log_2 p_k(x)
 *                   + \sum_x f(x) \log_2 f(x)
 *                \right]
 *            \]
 *
 *            where $p_k(x)$ is emission probability for symbol $x$
 *            from match state $k$, and $f(x)$ is the null model's
 *            background emission probability for $x$.
 *
 */
double
cm_MeanMatchInfo(const CM_t *cm)
{
  return esl_vec_FEntropy(cm->null, cm->abc->K) - cm_MeanMatchEntropy(cm);
}

/*
 * Function: cm_MeanMatchEntropy
 * Incept:   EPN, Tue May  1 14:06:37 2007
 *           Updated to match Sean's analogous p7_MeanMatchEntropy() in
 *           HMMER3's hmmstat.c, EPN, Sat Jan  5 14:48:27 2008.
 *
 * Purpose:   Calculate the mean entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{clen} \sum_{v=0}^{M-1} -\sum_x p_v(x) \log_2 p_v(x)
 *            \]
 *
 *            where $p_v(x)$ is emission probability for symbol $x$
 *            from MATL\_ML, MATR\_MR or MATP\_MP state $v$. For MATP\_MP
 *            states symbols $x$ are base pairs.
 */
double
cm_MeanMatchEntropy(const CM_t *cm)
{
  int    v;
  double H = 0.;

  for (v = 0; v < cm->M; v++)
	{
	  if(cm->stid[v] == MATP_MP)
	   H += esl_vec_FEntropy(cm->e[v], (cm->abc->K * cm->abc->K));
	  else if(cm->stid[v] == MATL_ML ||
	      cm->stid[v] == MATR_MR)
	H += esl_vec_FEntropy(cm->e[v], cm->abc->K);
	}
  H /= (double) cm->clen;
  return H;
}

/* Function:  cm_MeanMatchRelativeEntropy()
 * Incept:    SRE, Fri May 11 09:25:01 2007 [Janelia]
 *
 * Purpose:   Calculate the mean relative entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{v=0}^{M-1} \sum_x p_v(x) \log_2 \frac{p_v(x)}{f(x)}
 *            \]
 *
 *            where $p_v(x)$ is emission probability for symbol $x$
 *            from MATL\_ML, MATR\_MR, or MATP\_MP state state $v$,
 *            and $f(x)$ is the null model's background emission
 *            probability for $x$. For MATP\_MP states, $x$ is a
 *            base pair.
 */
double
cm_MeanMatchRelativeEntropy(const CM_t *cm)
{
  int    status;
  int    v;
  double KL = 0.;
  float *pair_null;
  int i,j;
  int KL_pair_denom = 0;
  int KL_singlet_denom = 0;
  float left_e[cm->abc->K];
  float right_e[cm->abc->K];
  double KL_pair = 0.;
  double KL_pair_marg = 0.;
  double KL_singlet = 0.;

  ESL_ALLOC(pair_null, (sizeof(float) * cm->abc->K * cm->abc->K));
  for(i = 0; i < cm->abc->K; i++)
	for(j = 0; j < cm->abc->K; j++)
	  pair_null[(i * cm->abc->K) + j] = cm->null[i] * cm->null[j];

  for (v = 0; v < cm->M; v++) {
	if(cm->stid[v] == MATP_MP) {
	  KL += esl_vec_FRelEntropy(cm->e[v], pair_null, (cm->abc->K * cm->abc->K));
	  KL_pair += esl_vec_FRelEntropy(cm->e[v], pair_null, (cm->abc->K * cm->abc->K));
	  KL_pair_denom += 2;
	  /*printf("MP    (%5d) %6.3f\n", v, esl_vec_FRelEntropy(cm->e[v], pair_null, (cm->abc->K * cm->abc->K)));*/

	  /* calculate marginals */
	  /* left half */
	  esl_vec_FSet(left_e, cm->abc->K, 0.);
	  for(i = 0; i < cm->abc->K; i++) {
	for(j = (i*cm->abc->K); j < ((i+1)*cm->abc->K); j++) {
	  left_e[i] += cm->e[v][j];
	}
	  }
	  esl_vec_FNorm(left_e, cm->abc->K);
	  KL_pair_marg += esl_vec_FRelEntropy(left_e, cm->null, cm->abc->K);
	  /*printf("cm       L %4d (%4s) v: %5d KL: %10.5f (added: %10.5f)\n", cm->ndidx[v], "MATP", v, KL, esl_vec_FRelEntropy(left_e, cm->null, cm->abc->K));*/
	  /* right half */
	  esl_vec_FSet(right_e, cm->abc->K, 0.);
	  for(i = 0; i < cm->abc->K; i++) {
	for(j = i; j < cm->abc->K * cm->abc->K; j += cm->abc->K) {
	  right_e[i] += cm->e[v][j];
	}
	  }
	  KL_pair_marg += esl_vec_FRelEntropy(right_e, cm->null, cm->abc->K);
	}
	else if(cm->stid[v] == MATL_ML ||
	    cm->stid[v] == MATR_MR) {
	  KL += esl_vec_FRelEntropy(cm->e[v], cm->null, cm->abc->K);
	  KL_singlet += esl_vec_FRelEntropy(cm->e[v], cm->null, cm->abc->K);
	  KL_singlet_denom += 1;
	  /*printf("ML/MR (%5d) %6.3f\n", v, esl_vec_FRelEntropy(cm->e[v], cm->null, cm->abc->K));*/
	}
  }
  free(pair_null);

  /*printf("\n%s KL total   %8.3f  %8.3f per          cpos\n", cm->name, KL, KL / (double) cm->clen);
	printf("%s KL pair    %8.3f  %8.3f per   paired cpos\n", cm->name, KL_pair, KL_pair / (double) KL_pair_denom);
	printf("%s KL pair(m) %8.3f  %8.3f per   paired cpos\n", cm->name, KL_pair_marg, KL_pair_marg / (double) KL_pair_denom);
	printf("%s KL singlet %8.3f  %8.3f per unpaired cpos\n", cm->name, KL_singlet, KL_singlet / (double) KL_singlet_denom);*/

  KL /= (double) cm->clen;
  return KL;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.; /* NOTREACHED */
}

/* Function:  cm_MeanMatchInfoHMM()
 * Incept:    EPN, Mon Feb 18 07:43:01 2008
 *
 * Purpose:   Calculate the mean information content per match state
 *            emission distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{k=1}^{M}
 *                \left[
 *                   - \sum_x p_k(x) \log_2 p_k(x)
 *                   + \sum_x f(x) \log_2 f(x)
 *                \right]
 *            \]
 *
 *            where $p_k(x)$ is emission probability for symbol $x$
 *            from match state $k$, and $f(x)$ is the null model's
 *            background emission probability for $x$.
 *
 *            Differs from cm_MeanMatchInfo() in that base pair emissions
 *            are marginalized, in effect treating the CM like an HMM that
 *            can only emit 1 residue at a time.
 *
 */
double
cm_MeanMatchInfoHMM(const CM_t *cm)
{
  return esl_vec_FEntropy(cm->null, cm->abc->K) - cm_MeanMatchEntropyHMM(cm);
}

/* Function: cm_MeanMatchEntropyHMM
 * Incept:   EPN, Mon Feb 18 08:06:20 2008
 *           Updated to match Sean's analogous p7_MeanMatchEntropy() in
 *           HMMER3's hmmstat.c, EPN, Sat Jan  5 14:48:27 2008.
 *
 * Purpose:   Calculate the mean entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{clen} \sum_{v=0}^{M-1} -\sum_x p_v(x) \log_2 p_v(x)
 *            \]
 *
 *            where $p_v(x)$ is emission probability for symbol $x$
 *            from MATL\_ML, MATR\_MR or MATP\_MP state $v$. For MATP\_MP
 *            states symbols $x$ are base pairs.
 *
 *            Differs from cm_MeanMatchEntropy() in that base pair emissions
 *            are marginalized, in effect treating the CM like an HMM that
 *            can only emit 1 residue at a time.
 */
double
cm_MeanMatchEntropyHMM(const CM_t *cm)
{
  int    v;
  double H = 0.;
  float left_e[cm->abc->K];
  float right_e[cm->abc->K];
  int i,j;

  for (v = 0; v < cm->M; v++) {
	  if(cm->stid[v] == MATP_MP) {
	/* calculate marginals */
	/* left half */
	esl_vec_FSet(left_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++) {
	  for(j = (i*cm->abc->K); j < ((i+1)*cm->abc->K); j++) {
	    left_e[i] += cm->e[v][j];
	  }
	  H += esl_vec_FEntropy(left_e, cm->abc->K);
	}
	/* right half */
	esl_vec_FSet(right_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++) {
	  for(j = i; j < cm->abc->K * cm->abc->K; j += cm->abc->K) {
	    right_e[i] += cm->e[v][j];
	  }
	  H += esl_vec_FEntropy(right_e, cm->abc->K);
	}
	  }
	  else if(cm->stid[v] == MATL_ML ||
	      cm->stid[v] == MATR_MR) {
	H += esl_vec_FEntropy(cm->e[v], cm->abc->K);
	  }
  }
  H /= (double) cm->clen;
  return H;
}

/* Function:  cm_MeanMatchRelativeEntropyHMM()
 * Incept:    EPN, Mon Feb 18 08:06:24 2008
 *
 * Purpose:   Calculate the mean relative entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{v=0}^{M-1} \sum_x p_v(x) \log_2 \frac{p_v(x)}{f(x)}
 *            \]
 *
 *            where $p_v(x)$ is emission probability for symbol $x$
 *            from MATL\_ML, MATR\_MR, or MATP\_MP state state $v$,
 *            and $f(x)$ is the null model's background emission
 *            probability for $x$. For MATP\_MP states, $x$ is a
 *            base pair.
 *
 *            Differs from cm_MeanMatchRelativeEntropy() in that base pair
 *            emissions are marginalized, in effect treating the CM like an
 *            HMM that can only emit 1 residue at a time.
 */
double
cm_MeanMatchRelativeEntropyHMM(const CM_t *cm)
{
  int    v;
  double KL = 0.;
  float left_e[cm->abc->K];
  float right_e[cm->abc->K];
  int i,j;

  for (v = 0; v < cm->M; v++) {
	  if(cm->stid[v] == MATP_MP) {
	/* calculate marginals */
	/* left half */
	esl_vec_FSet(left_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++) {
	  for(j = (i*cm->abc->K); j < ((i+1)*cm->abc->K); j++) {
	    left_e[i] += cm->e[v][j];
	  }
	}
	esl_vec_FNorm(left_e, cm->abc->K);
	KL += esl_vec_FRelEntropy(left_e, cm->null, cm->abc->K);
	/*printf("cm       L %4d (%4s) v: %5d KL: %10.5f (added: %10.5f)\n", cm->ndidx[v], "MATP", v, KL, esl_vec_FRelEntropy(left_e, cm->null, cm->abc->K));*/
	/* right half */
	esl_vec_FSet(right_e, cm->abc->K, 0.);
	for(i = 0; i < cm->abc->K; i++) {
	  for(j = i; j < cm->abc->K * cm->abc->K; j += cm->abc->K) {
	    right_e[i] += cm->e[v][j];
	  }
	}
	KL += esl_vec_FRelEntropy(right_e, cm->null, cm->abc->K);
	/*printf("cm       R %4d (%4s) v: %5d KL: %10.5f (added: %10.5f)\n", cm->ndidx[v], "MATP", v, KL, esl_vec_FRelEntropy(right_e, cm->null, cm->abc->K));*/
	  }
	  else if(cm->stid[v] == MATL_ML ||
	      cm->stid[v] == MATR_MR) {
	KL += esl_vec_FRelEntropy(cm->e[v], cm->null, cm->abc->K);
	/*printf("cm         %4d (%4s) v: %5d KL: %10.5f (added %10.5f)\n", cm->ndidx[v], Nodetype(cm->ndtype[cm->ndidx[v]]), v, KL, esl_vec_FRelEntropy(cm->e[v], cm->null, cm->abc->K));*/
	  }
  }

  KL /= (double) cm->clen;
  return KL;
}

/* Function:  cp9_MeanMatchInfo()
 * Incept:    SRE, Fri May  4 11:43:56 2007 [Janelia]
 *
 * Purpose:   Calculate the mean information content per match state
 *            emission distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{k=1}^{M}
 *                \left[
 *                   - \sum_x p_k(x) \log_2 p_k(x)
 *                   + \sum_x f(x) \log_2 f(x)
 *                \right]
 *            \]
 *
 *            where $p_k(x)$ is emission probability for symbol $x$
 *            from match state $k$, and $f(x)$ is the null model's
 *            background emission probability for $x$.
 *
 *            This statistic is used in "entropy weighting" to set the
 *            total sequence weight when model building.
 */
double
cp9_MeanMatchInfo(const CP9_t *cp9)
{
  return esl_vec_FEntropy(cp9->null, cp9->abc->K) - cp9_MeanMatchEntropy(cp9);
}

/* Function:  cp9_MeanMatchEntropy()
 * Incept:    SRE, Fri May  4 13:37:15 2007 [Janelia]
 *
 * Purpose:   Calculate the mean entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{k=1}^{M} -\sum_x p_k(x) \log_2 p_k(x)
 *            \]
 *
 *            where $p_k(x)$ is emission probability for symbol $x$
 *            from match state $k$.
 */
double
cp9_MeanMatchEntropy(const CP9_t *cp9)
{
  int    k;
  double H = 0.;

  for (k = 1; k <= cp9->M; k++)
	H += esl_vec_FEntropy(cp9->mat[k], cp9->abc->K);
  H /= (double) cp9->M;
  return H;
}

/* Function:  cp9_MeanMatchRelativeEntropy()
 * Incept:    SRE, Fri May 11 09:25:01 2007 [Janelia]
 *
 * Purpose:   Calculate the mean relative entropy per match state emission
 *            distribution, in bits:
 *
 *            \[
 *              \frac{1}{M} \sum_{k=1}^{M} \sum_x p_k(x) \log_2 \frac{p_k(x)}{f(x)}
 *            \]
 *
 *            where $p_k(x)$ is emission probability for symbol $x$
 *            from match state $k$, and $f(x)$ is the null model's
 *            background emission probability for $x$.
 */
double
cp9_MeanMatchRelativeEntropy(const CP9_t *cp9)
{
  int    k;
  double KL = 0.;

  for (k = 1; k <= cp9->M; k++) {
	KL += esl_vec_FRelEntropy(cp9->mat[k], cp9->null, cp9->abc->K);
  }
  KL /= (double) cp9->M;
  return KL;
}

/*** End of inlined file: eweight.c ***/


/*** Start of inlined file: hmmband.c ***/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <math.h>


static int          cp9_FB2HMMBands        (CP9_t *hmm, char *errbuf, ESL_DSQ *dsq, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, CP9Bands_t *cp9b,
				            int i0, int j0, int M, double p_thresh, int did_fwd_scan, int did_bck_scan, int do_old_hmm2ij, int debug_level);
static int          cp9_FB2HMMBandsWithSums(CP9_t *hmm, char *errbuf, ESL_DSQ *dsq, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, CP9Bands_t *cp9b,
					    int i0, int j0, int M, double p_thresh, int did_fwd_scan, int did_bck_scan, int do_old_hmm2ij, int debug_level);
static void         cp9_Posterior(ESL_DSQ *dsq, int i0, int j0, CP9_t *hmm, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *mx, int did_fwd_scan);
static void         cp9_IFillPostSums(CP9_MX *post, CP9Bands_t *cp9, int i0, int j0);
static int          HMMBandsEnforceValidParse(CP9_t *cp9, CP9Bands_t *cp9b, CP9Map_t *cp9map, char *errbuf, int i0, int j0, int doing_search, int *ret_did_expand,
					      int **ret_r_mn, int **ret_r_mx, int **ret_r_in,  int **ret_r_ix, int **ret_r_dn, int **ret_r_dx,
					      int **ret_r_nn_i, int **ret_r_nx_i, int **ret_r_nn_j, int **ret_r_nx_j);
static int          HMMBandsFixUnreachable(CP9Bands_t *cp9b, char *errbuf, int k, int r_prv_min, int r_prv_max, int r_insert_prv_min);
static int          HMMBandsFillGap(CP9Bands_t *cp9b, char *errbuf, int k, int min1, int max1, int min2, int max2, int prv_nd_r_mn, int prv_nd_r_dn);
#if eslDEBUGLEVEL >= 1
static int          CMBandsCheckValidParse(CM_t *cm, CP9Bands_t *cp9b, char *errbuf, int i0, int j0, int doing_search);
#endif

/* EPN 10.28.06
 * Function: AllocCP9Bands()
 *
 * Purpose:  Allocate the arrays needed for creating i and j
 *           bands on a CM based on a CP9 parse. See infernal.h
 *           for description of this structure.
 *
 * Args:
 * cm_M                - number of states in the CM
 * hmm_M               - number of nodes in the CP9 HMM for the CM
 * Returns: (void)
 *
 */

CP9Bands_t *
AllocCP9Bands(int cm_M, int hmm_M)
{
  int status;
  CP9Bands_t  *cp9bands;

  ESL_ALLOC(cp9bands, sizeof(CP9Bands_t));

  cp9bands->cm_M  = cm_M;
  cp9bands->hmm_M = hmm_M;

  cp9bands->sp1 = cp9bands->sp2 = cp9bands->ep1 = cp9bands->ep2 = -1;
  cp9bands->thresh1          = DEFAULT_CP9BANDS_THRESH1;    /* 0.01 */
  cp9bands->thresh2          = DEFAULT_CP9BANDS_THRESH2;    /* 0.98 */
  cp9bands->Rmarg_imin = cp9bands->Lmarg_jmin = -1;
  cp9bands->Rmarg_imax = cp9bands->Lmarg_jmax = -2;

  ESL_ALLOC(cp9bands->Jvalid, sizeof(int) * (cm_M+1));
  ESL_ALLOC(cp9bands->Lvalid, sizeof(int) * (cm_M+1));
  ESL_ALLOC(cp9bands->Rvalid, sizeof(int) * (cm_M+1));
  ESL_ALLOC(cp9bands->Tvalid, sizeof(int) * (cm_M+1));
  esl_vec_ISet(cp9bands->Jvalid, cm_M+1, TRUE);
  esl_vec_ISet(cp9bands->Lvalid, cm_M+1, TRUE);
  esl_vec_ISet(cp9bands->Rvalid, cm_M+1, TRUE);
  esl_vec_ISet(cp9bands->Tvalid, cm_M, TRUE);
  cp9bands->Tvalid[cm_M] = FALSE;

  ESL_ALLOC(cp9bands->pn_min_m, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->pn_max_m, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->pn_min_i, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->pn_max_i, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->pn_min_d, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->pn_max_d, sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->isum_pn_m,sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->isum_pn_i,sizeof(int) * (cp9bands->hmm_M+1));
  ESL_ALLOC(cp9bands->isum_pn_d,sizeof(int) * (cp9bands->hmm_M+1));

  ESL_ALLOC(cp9bands->imin,       sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->imax,       sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->jmin,       sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->jmax,       sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->safe_hdmin, sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->safe_hdmax, sizeof(int)   * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->hdmin,      sizeof(int *) * cp9bands->cm_M);
  ESL_ALLOC(cp9bands->hdmax,      sizeof(int *) * cp9bands->cm_M);
  cp9bands->hdmin_mem = NULL;
  cp9bands->hdmax_mem = NULL;
  /* NOTE: cp9bands->hdmin and hdmax are 2D arrays, the ptrs are
   * alloc'ed here, but the actually memory is alloc'ed by
   * hmmband.c:cp9_Seq2Bands() with a call to hmmband.c:cp9_GrowHDBands().
   */
  cp9bands->hd_needed  = 0;
  cp9bands->hd_alloced = 0;

  cp9bands->tau        = -1.; /* invalid, reset each time bands are calculated */
  return cp9bands;

 ERROR:
  cm_Fail("Memory allocation error.\n");
  return NULL; /* never reached */
}

/* Function: SizeofCP9Bands()
 * Returns:  Size (Mb) of cp9b.
 */
float
SizeofCP9Bands(CP9Bands_t *cp9b)
{
  float bytes = 0.;

  bytes += sizeof(CP9Bands_t);

  /* following from AllocCP9Bands() */
  bytes += sizeof(int) * (cp9b->cm_M+1); /* Jvalid */
  bytes += sizeof(int) * (cp9b->cm_M+1); /* Lvalid */
  bytes += sizeof(int) * (cp9b->cm_M+1); /* Rvalid */
  bytes += sizeof(int) * (cp9b->cm_M+1); /* Tvalid */

  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_min_m */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_max_m */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_min_i */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_max_i */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_min_d */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* pn_max_d */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* isum_pn_m */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* isum_pn_i */
  bytes += sizeof(int) * (cp9b->hmm_M+1); /* isum_pn_d */

  bytes += sizeof(int) *  cp9b->cm_M; /* imin */
  bytes += sizeof(int) *  cp9b->cm_M; /* imax */
  bytes += sizeof(int) *  cp9b->cm_M; /* jmin */
  bytes += sizeof(int) *  cp9b->cm_M; /* jmax */
  bytes += sizeof(int) *  cp9b->cm_M; /* safe_hdmin */
  bytes += sizeof(int) *  cp9b->cm_M; /* safe_hdmax */
  bytes += sizeof(int *) *  cp9b->cm_M; /* hdmin */
  bytes += sizeof(int *) *  cp9b->cm_M; /* hdmax */

  bytes += sizeof(int) * cp9b->hd_alloced; /* hdmin */
  bytes += sizeof(int) * cp9b->hd_alloced; /* hdmax */

  return bytes / 1000000.;
}

/* Function: FreeCP9Bands()
 * Returns: (void)
 */
void
FreeCP9Bands(CP9Bands_t *cp9bands)
{
  free(cp9bands->imin);
  free(cp9bands->imax);
  free(cp9bands->jmin);
  free(cp9bands->jmax);
  free(cp9bands->safe_hdmin);
  free(cp9bands->safe_hdmax);
  if(cp9bands->hdmin_mem != NULL)
	free(cp9bands->hdmin_mem); /* all v were malloc'ed as a block */
  if(cp9bands->hdmax_mem != NULL)
	free(cp9bands->hdmax_mem); /* all v were malloc'ed as a block */
  free(cp9bands->hdmin);
  free(cp9bands->hdmax);

  free(cp9bands->pn_min_m);
  free(cp9bands->pn_max_m);
  free(cp9bands->pn_min_i);
  free(cp9bands->pn_max_i);
  free(cp9bands->pn_min_d);
  free(cp9bands->pn_max_d);
  free(cp9bands->isum_pn_m);
  free(cp9bands->isum_pn_i);
  free(cp9bands->isum_pn_d);

  free(cp9bands->Jvalid);
  free(cp9bands->Lvalid);
  free(cp9bands->Rvalid);
  free(cp9bands->Tvalid);

  free(cp9bands);
}

/* Function: cp9_Seq2Bands
 * Date    : EPN, Mon Jan  8 07:23:34 2007
 *           EPN, Wed Oct 17 04:53:58 2007  [updated/optimized]
 *
 * Purpose:  Given a CM with precalc'ed CP9 HMM and CP9Map, a sequence and
 *           a CP9Bands_t structure, calculate the HMM bands and store them
 *           in the CP9Bands_t structure.
 *
 * Args:     cm           - the covariance model
 *           errbuf       - char buffer for reporting errors
 *           fmx          - CP9 dp matrix for Forward()
 *           bmx          - CP9 dp matrix for Backward()
 *           pmx          - CP9 dp matrix to fill with posteriors, can == bmx
 *           dsq          - sequence in digitized form
 *           i0           - start of target subsequence (often 1, beginning of sq)
 *           j0           - end of target subsequence (often L, end of sq)
 *           cp9b         - PRE-ALLOCATED, the HMM bands for this sequence, filled here.
 *           doing_search - TRUE if we're going to use these HMM bands for search, not alignment
 *           pass_idx     - pipeline pass index, tells us which truncation modes to allow, if any
 *           debug_level  - verbosity level for debugging printf()s
 *
 * Return:  eslOK on success;
 *
 */
int
cp9_Seq2Bands(CM_t *cm, char *errbuf, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, ESL_DSQ *dsq, int i0, int j0, CP9Bands_t *cp9b, int doing_search, int pass_idx, int debug_level)
{
  int   status;
  int   use_sums;     /* TRUE to fill and use posterior sums during HMM band calc, yields wider bands  */
  float sc;
  int do_old_hmm2ij;
  int do_trunc;       /* are we allowing truncated alignments (either L or R)? */
  int do_fwd_scan;    /* run Forward  in scanning mode? (see long comment on this below by assignment of do_fwd_scan) */
  int do_bck_scan;    /* run Backward in scanning mode? (see long comment on this below by assignment of do_fwd_scan) */
  CP9_t *cp9 = NULL;  /* ptr to cp9 HMM (cm->cp9, cm->Lcp9, cm->Rcp9, or cm->Tcp9) we'll use for deriving bands */

  /* Contract checks */
  if(cm->cp9map == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Bands, but cm->cp9map is NULL.\n");
  if(dsq == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Bands, dsq is NULL.");
  if(i0 > j0)            ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Bands, i0: %d > j0: %d\n", i0, j0);
  if(cm->tau > 0.5)      ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Bands, cm->tau (%f) > 0.5, we can't deal.", cm->tau);

  use_sums      = ((cm->align_opts & CM_ALIGN_SUMS)      || (cm->search_opts & CM_SEARCH_SUMS))      ? TRUE : FALSE;
  do_old_hmm2ij = ((cm->align_opts & CM_ALIGN_HMM2IJOLD) || (cm->search_opts & CM_SEARCH_HMM2IJOLD)) ? TRUE : FALSE;

  /* Determine which cp9 HMM to use and whether or not we're doing
   * truncated alignment, based on value of pass_idx.
   */
  switch(pass_idx) {
  case PLI_PASS_5P_ONLY_FORCE:   do_trunc = TRUE;  cp9 = cm->Rcp9; break;
  case PLI_PASS_3P_ONLY_FORCE:   do_trunc = TRUE;  cp9 = cm->Lcp9; break;
  case PLI_PASS_5P_AND_3P_FORCE: do_trunc = TRUE;  cp9 = cm->Tcp9; break;
  case PLI_PASS_5P_AND_3P_ANY:   do_trunc = TRUE;  cp9 = cm->Tcp9; break;
  default:                       do_trunc = FALSE; cp9 = cm->cp9;  break;
  }
  if(cp9 == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Bands, relevant cp9 is NULL.\n");

  /* Determine if we should do Forward and Backward in scan mode.
   * When in scan mode, Forward will allow parses to start at any
   * position, else they must start at i0 (first res).
   * When in scan mode, Backward will allow parses to end at any
   * position, else they must end at j0 (final res).
   *
   * We should only scan in Forward if i0 does not need to be in any
   * eventual CM parsetree we derive using these bands. This is only
   * true if we'll use these bands for a CM search
   * (doing_search==TRUE) and that search won't be a special truncated
   * search where i0 must be in any valid parsetree. We will be doing
   * a truncated search enforcing i0 inclusion if pass_idx is either
   * PLI_PASS_5P_AND_3P or PLI_PASS_5P_ONLY.
   *
   * Likewise, we should only scan in Backward if j0 does not need to
   * be in any eventual CM parsetree we derive using these bands.
   * This is only true if we'll use these bands for a CM search
   * (doing_search==TRUE) and that search won't be a special truncated
   * search where j0 must be in any valid parsetree. We will be doing
   * a truncated search enforcing j0 inclusion if pass_idx is either
   * PLI_PASS_5P_AND_3P or PLI_PASS_3P_ONLY.
   */
  if((! doing_search) || (cm->search_opts & CM_SEARCH_HMMALNBANDS)) {
	do_fwd_scan = do_bck_scan = FALSE;
  }
  else {
	do_fwd_scan = cm_pli_PassEnforcesFirstRes(pass_idx) ? FALSE : TRUE;
	do_bck_scan = cm_pli_PassEnforcesFinalRes(pass_idx) ? FALSE : TRUE;
  }

  /* Step 1: Get HMM Forward/Backward DP matrices.
   * Step 2: F/B -> HMM bands.
   * Step 3: Calculate candidate states for truncated alignments
   * Step 4: HMM bands -> CM bands.
   */

  /* Step 1: Get HMM Forward/Backward DP matrices. */
  if((status = cp9_Forward(cp9, errbuf, fmx, dsq, i0, j0,
			   do_fwd_scan,      /* allow parses to start at any posn? */
			   (! doing_search), /* are we going to use bands to align? */
			   FALSE,            /* don't be memory efficient */
			   NULL, NULL,
			   &sc)) != eslOK) return status;

  if((status = cp9_Backward(cp9, errbuf, bmx, dsq, i0, j0,
			    do_bck_scan,       /* allow parses to end at any posn? */
			    (! doing_search),  /* are we going to use posteriors to align? */
			    FALSE,             /* don't be memory efficient */
			    NULL, NULL,
			    &sc)) != eslOK) return status;

  if(cm->align_opts & CM_ALIGN_CHECKFB) {
	if((status = cp9_CheckFB(fmx, bmx, cp9, errbuf, sc, i0, j0, dsq)) != eslOK) return status;
	printf("Forward/Backward matrices checked.\n");
  }

  /* Step 2: F/B -> HMM bands. */
  if(use_sums){
	if((status = cp9_FB2HMMBandsWithSums(cp9, errbuf, dsq, fmx, bmx, pmx, cp9b, i0, j0, cp9b->hmm_M,
					 (1.-cm->tau), do_fwd_scan, do_bck_scan, do_old_hmm2ij, debug_level)) != eslOK) return status;
  }
  else {
	if((status = cp9_FB2HMMBands(cp9, errbuf, dsq, fmx, bmx, pmx, cp9b, i0, j0, cp9b->hmm_M,
				 (1.-cm->tau), do_fwd_scan, do_bck_scan, do_old_hmm2ij, debug_level)) != eslOK) return status;
  }
  if(debug_level > 0) cp9_DebugPrintHMMBands(stdout, j0, cp9b, cm->tau, 1);
  cp9b->tau = cm->tau;

  /* Step 3: (only if truncated alignments are possible)
   * Calculate occupancy and candidate states for marginal alignments
   */
  if(do_trunc) {
	cp9_PredictStartAndEndPositions(pmx, cp9b, i0, j0);
	if((status = cp9_MarginalCandidatesFromStartEndPositions(cm, cp9b, pass_idx, errbuf)) != eslOK) return status;
	/* xref: ELN2 notebook, p.146-147; ~nawrockie/notebook/11_0816_inf_banded_trcyk/00LOG */
  }
  else {
	/* reset all Jvalid values to TRUE */
	esl_vec_ISet(cp9b->Jvalid, cm->M+1, TRUE);
	/* and all {L,R,T}valid values to FALSE */
	esl_vec_ISet(cp9b->Lvalid, cm->M+1, FALSE);
	esl_vec_ISet(cp9b->Rvalid, cm->M+1, FALSE);
	esl_vec_ISet(cp9b->Tvalid, cm->M+1, FALSE);
  }

  /* Step 4: HMM bands -> CM bands. */
  if(do_old_hmm2ij) {
	if((status = cp9_HMM2ijBands_OLD(cm, errbuf, cp9b, cm->cp9map, i0, j0, doing_search, debug_level)) != eslOK) return status;
  }
  else {
	if((status = cp9_HMM2ijBands(cm, errbuf, cp9, cp9b, cm->cp9map, i0, j0, doing_search, do_trunc, debug_level)) != eslOK) return status;
  }

  /* Use the CM bands on i and j to get bands on d, specific to j. */
  /* cp9_GrowHDBands() must be called before ij2d_bands() so hdmin, hdmax are adjusted for new seq */
  if((status = cp9_GrowHDBands(cp9b, errbuf)) != eslOK) return status;
  ij2d_bands(cm, (j0-i0+1), cp9b->imin, cp9b->imax, cp9b->jmin, cp9b->jmax, cp9b->hdmin, cp9b->hdmax, do_trunc, debug_level);

#if eslDEBUGLEVEL >= 1
  if((status = cp9_ValidateBands(cm, errbuf, cp9b, i0, j0, do_trunc)) != eslOK) return status;
  ESL_DPRINTF1(("bands validated.\n"));
#endif
  if(debug_level > 0) debug_print_ij_bands(cm);
  if(debug_level > 0) PrintDPCellsSaved_jd(cm, cp9b->jmin, cp9b->jmax, cp9b->hdmin, cp9b->hdmax, (j0-i0+1));

  return eslOK;
}

/* Function:  cp9_IterateSeq2Bands()
 * Incept:    EPN, Thu Mar  1 17:56:42 2012
 *
 * Purpose:   Increase cm->tau (tighten HMM bands) by multiplying it
 *            by TAU_MULTIPLIER (2.0) until required HMM banded matrix
 *            size is below <size_limit> Mb, or cm->tau is greater than
 *            <maxtau>.
 *
 *            If we're doing a truncated alignment (which we can figure
 *            out based on the value of <pass_idx>) then we also increase
 *            cp9b->thresh1 and decrease cp9b->thresh2 by a hard-coded
 *            value into the maximum/minimum is reached for them as
 *            wel..
 *
 *            Since we can't determine the required size of a HB
 *            matrix unless we have filled a CP9Bands_t object
 *            (cm->cp9b), we need to recalculate bands each time tau,
 *            (and possibly thresh1 and thresh2) are modified and then
 *            check size of resulting matrix given the bands.
 *
 *            Upon returning cm->tau, cm->cp9b->tau, cm->cp9b->thresh1
 *            and cm->cp9b->thresh2 may have been changed.
 *
 * Args       cm           - the CM
 *            errbuf       - for error messages
 *            dsq          - sequence we're aligning
 *            i0           - first position in dsq to align (usually 1)
 *            j0           - final position in dsq to align (usually sq->n)
 *            pass_idx     - pipeline pass index
 *            size_limit   - max allowed size of an HB mx, in Mb
 *            doing_search - TRUE if we're going to use these HMM bands for search, not alignment
 *            do_sample    - TRUE if bands will eventually be used for sampling a parsetree
 *            do_post      - TRUE if bands will eventually be used for posterior alignment
 *            maxtau       - max value allowed for cm->tau
 *            xtau         - we multiply tau by this at each iteration (must be > 1.1)
 *            ret_Mb       - RETURN: required Mb for HB mx for cm->tau upon exit.
 *
 * Returns:   <eslOK> on success.
 *            <eslERANGE> if required matrix size is > <size_limit>,
 *            for cm->tau = maxtau.
 *            A different error code upon an error, errbuf is filled.
 */
int
cp9_IterateSeq2Bands(CM_t *cm, char *errbuf, ESL_DSQ *dsq, int64_t i0, int64_t j0, int pass_idx, float size_limit, int doing_search, int do_sample, int do_post, double maxtau, float *ret_Mb)
{
  int   status;
  int   do_trunc = cm_pli_PassAllowsTruncation(pass_idx);
  float hbmx_Mb;  /* approximate size in Mb required for HMM banded matrix */
  int   tau_at_limit     = FALSE;
  int   thresh1_at_limit = (do_trunc) ? FALSE : TRUE;
  int   thresh2_at_limit = (do_trunc) ? FALSE : TRUE;

  while(1) {
	if((status = cp9_Seq2Bands(cm, errbuf, cm->cp9_mx, cm->cp9_bmx, cm->cp9_bmx, dsq, i0, j0, cm->cp9b, doing_search, pass_idx, 0)) != eslOK) goto ERROR;
	if(doing_search) {
	  if(do_trunc) { if((status = cm_tr_hb_mx_SizeNeeded(cm, errbuf, cm->cp9b, j0-i0+1, NULL, NULL, NULL, NULL, &hbmx_Mb)) != eslOK) goto ERROR; }
	  else         { if((status = cm_hb_mx_SizeNeeded   (cm, errbuf, cm->cp9b, j0-i0+1, NULL, &hbmx_Mb)) != eslOK) goto ERROR; }
	}
	else {
	  if(do_trunc) { status = cm_TrAlignSizeNeededHB(cm, errbuf, j0-i0+1, size_limit, do_sample, do_post, NULL, NULL, NULL, &hbmx_Mb); }
	  else         { status = cm_AlignSizeNeededHB  (cm, errbuf, j0-i0+1, size_limit, do_sample, do_post, NULL, NULL, NULL, &hbmx_Mb); }
	  if(status != eslOK && status != eslERANGE) return status;
	}
	/*printf("cm->tau: %10.2g thresh1: %4.2f thresh2: %4.2f mxsize: %.2f\n", cm->tau, cm->cp9b->thresh1, cm->cp9b->thresh2, hbmx_Mb);*/
	/* check if we can stop iterating, three ways we can
	 * case 1: matrix is now smaller than our limit.
	 * case 2: do_trunc == FALSE && tau has reached its limit
	 * case 3: do_trunc == TRUE  && tau, thresh1 and thresh have all reached their limits
	 */
	if(hbmx_Mb <  size_limit) {
	  break; /* our matrix will be small enough, break out of while(1) */
	}
	if(tau_at_limit && thresh1_at_limit && thresh2_at_limit) { /* if do_trunc is FALSE, thresh{1,2}_at_limit were init'ed as TRUE */
	  break; /* tau, thresh1 and thresh2 have all reached their limits, break out of while (1) */
	}
	if(! tau_at_limit) {
	  cm->tau *= TAU_MULTIPLIER;
	  if(cm->tau >= maxtau) { cm->tau = maxtau; tau_at_limit = TRUE; }
	}
	if(! thresh1_at_limit) {
	  cm->cp9b->thresh1 += DELTA_CP9BANDS_THRESH1;
	  if(cm->cp9b->thresh1 >= MAX_CP9BANDS_THRESH1) { cm->cp9b->thresh1 = MAX_CP9BANDS_THRESH1; thresh1_at_limit = TRUE; }
	}
	if(! thresh2_at_limit) {
	  cm->cp9b->thresh2 -= DELTA_CP9BANDS_THRESH2;
	  if(cm->cp9b->thresh2 <= MIN_CP9BANDS_THRESH2) { cm->cp9b->thresh2 = MIN_CP9BANDS_THRESH2; thresh2_at_limit = TRUE; }
	}
  }

  if(ret_Mb != NULL) *ret_Mb = hbmx_Mb;

  if(hbmx_Mb > size_limit) return eslERANGE;

  return eslOK;

 ERROR:
  if(ret_Mb != NULL) *ret_Mb = 0.;
  return status;
}

/* Function: cp9_Seq2Posteriors
 * Date    : EPN, Mon Jan  8 07:27:21 2007
 *
 * Purpose:  Given a CM with precalc'ed CP9 HMM and CP9Map, and a sequence,
 *           run HMM Forward and Backward algorithms, and return a CP9 posterior
 *           matrix.
 *
 *           Note: this function was never updated to handle
 *           truncated alignment (b/c it's no longer hooked up
 *           to any of the Infernal applications).
 *
 * Args:     cm           - the covariance model
 *           errbuf       - char buffer for error messages
 *           fmx          - CP9 dp matrix for Forward()
 *           bmx          - CP9 dp matrix for Backward()
 *           pmx          - CP9 dp matrix to fill with posteriors, can == bmx
 *           dsq          - sequence in digitized form
 *           i0           - start of target subsequence (often 1, beginning of dsq)
 *           j0           - end of target subsequence (often L, end of dsq)
 *           debug_level  - verbosity level for debugging printf()s
 *
 * Return:  eslOK on success
 */
int
cp9_Seq2Posteriors(CM_t *cm, char *errbuf, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, ESL_DSQ *dsq, int i0, int j0, int debug_level)
{
  int status;
  float sc;
  CP9_t *cp9 = NULL;  /* ptr to cp9 HMM (this could be Lcp9, Rcp9, Tcp9 if we update this function to possibly handle truncated alignment) */

  /* Contract checks */
  if(dsq == NULL)        ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors(), dsq is NULL.");
  if(cm->cp9    == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, but cm->cp9 is NULL.\n");
  if(cm->cp9map == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, but cm->cp9map is NULL.\n");
  if((cm->search_opts & CM_SEARCH_HMMALNBANDS) && (! (cm->search_opts & CM_SEARCH_HBANDED)))
	ESL_FAIL(eslEINCOMPAT, errbuf, "in cp9_Seq2Posteriors, CM_SEARCH_HMMALNBANDS flag raised, but not CM_SEARCH_HBANDED flag, this doesn't make sense\n");

  cp9 = cm->cp9;
  if(cp9 == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_Seq2Posteriors, relevant cp9 is NULL.\n");

  /* Step 1: Get HMM posteriors.*/
  if((status = cp9_Forward(cp9, errbuf, fmx, dsq, i0, j0,
			   FALSE,     /* don't use scanning Forward/Backward */
			   TRUE,      /* we are going to use posteriors to align */
			   FALSE,     /* don't be memory efficient */
			   NULL, NULL,
			   &sc)) != eslOK) return status;
  if(debug_level > 0) printf("CP9 Forward  score : %.4f\n", sc);
  if((status = cp9_Backward(cp9, errbuf, bmx, dsq, i0, j0,
			    FALSE, /* don't use scanning Forward/Backward */
			    TRUE,  /* we are going to use posteriors to align */
			    FALSE, /* don't be memory efficient */
			    NULL, NULL,
			    &sc)) != eslOK) return status;
  if(debug_level > 0) printf("CP9 Backward  score : %.4f\n", sc);

  if(cm->align_opts & CM_ALIGN_CHECKFB) {
	if((status = cp9_CheckFB(fmx, bmx, cp9, errbuf, sc, i0, j0, dsq)) != eslOK) return status;
	printf("Forward/Backward matrices checked.\n");
  }

  /* Get posteriors */
  cp9_Posterior(dsq, i0, j0, cp9, fmx, bmx, pmx, FALSE);

  return eslOK;
}

/* Function: cp9_FB2HMMBands()
 * Date:     EPN, 04.03.06
 *           EPN, Mon Oct 15 18:20:42 2007 [updated/optimized]
 *
 * Purpose: Determine the band on all HMM states given a Forward and
 *          Backward matrix. Do this by calculating and summing log posterior
 *          probabilities that each state emitted/was visited at each posn,
 *          starting at the sequence ends, and creeping in, until the half the
 *          maximum allowable probability excluded is reached on each side.
 *
 * Args:
 *
 * CP9_t hmm        the HMM
 * errbuf           char buffer for error messages
 * CP9_MX fmx:      forward DP matrix, already calc'ed
 * CP9_MX bmx:      backward DP matrix, already calc'ed
 * CP9_MX pmx:      DP matrix for posteriors, filled here, can == bmx
 * dsq              the digitized sequence
 * CP9Bands_t cp9b  CP9 bands data structure
 * int i0           start of target subsequence (often 1, beginning of dsq)
 * int j0           end of target subsequence (often L, end of dsq)
 * int   M          number of nodes in HMM (num columns of pmx matrix)
 * double p_thresh  the probability mass we're requiring is within each band
 * int did_fwd_scan  TRUE if Forward was run in 'scan mode' (parses could start anywhere)
 * int did_bck_scan  TRUE if Backward was run in 'scan mode' (parses could end anywhere)
 * int do_old_hmm2ij TRUE if we'll use old cp9_HMM2ijBands_OLD() function downstream
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 *
 * Returns: eslOK on success;
 */
int
cp9_FB2HMMBands(CP9_t *hmm, char *errbuf, ESL_DSQ *dsq, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, CP9Bands_t *cp9b,
		int i0, int j0, int M, double p_thresh, int did_fwd_scan, int did_bck_scan, int do_old_hmm2ij, int debug_level)
{
  int status;
  int k;                                  /* counter over nodes of the model */
  int L = j0-i0+1;                        /* length of sequence */
  int thresh = Prob2Score(((1. - p_thresh)/2.), 1.); /* allowable prob mass excluded on each side */
  int max;                                /* temporary max value */
  int pnmax;                              /* position that gives max */

  /* *_m = match, *_i = insert, *_d = delete */
  int *kthresh_m, *kthresh_i, *kthresh_d; /* [0..k..hmm->M], individual thresholds for each state */
  int *nset_m, *nset_i, *nset_d;          /* [0..k..hmm->M], has minimum been set for this state? */
  int *xset_m, *xset_i, *xset_d;          /* [0..k..hmm->M], has maximum been set for this state? */
  int *mass_m, *mass_i, *mass_d;          /* [0..k..hmm->M], summed log prob of pmx->mx[i][k] from 0..k or k..L */
  int i, ip;                              /* actual position and relative position in sequence, ip = i-i0+1 */
  int sc;                                 /* summed score of all parses (derived from backward matrix)
					   * if(cm->search_opts & CM_SEARCH_HMMALNBANDS) Forward and Backward
					   * were run in 'scan mode' where each residue can be begin/end of a parse,
					   * so we have to sum up parses that end at each posn,
					   * if ! (cm->search_opts & CM_SEARCH_HMMALNBANDS) we know we have
					   * to start at residue i0 and end at residue j0, so sc is simply bmx->mmx[0][0]
					   */
  int hmm_is_localized;                   /* TRUE if HMM has local begins, ends or ELs on */
  hmm_is_localized = ((hmm->flags & CPLAN9_LOCAL_BEGIN) || (hmm->flags & CPLAN9_LOCAL_END) || (hmm->flags & CPLAN9_EL)) ? TRUE : FALSE;

  if(bmx != pmx) GrowCP9Matrix(pmx, errbuf, L, M, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  /* allocations and initializations */
  ESL_ALLOC(nset_m, sizeof(int) * (M+1));
  ESL_ALLOC(nset_i, sizeof(int) * (M+1));
  ESL_ALLOC(nset_d, sizeof(int) * (M+1));
  ESL_ALLOC(xset_m, sizeof(int) * (M+1));
  ESL_ALLOC(xset_i, sizeof(int) * (M+1));
  ESL_ALLOC(xset_d, sizeof(int) * (M+1));
  ESL_ALLOC(mass_m, sizeof(int) * (M+1));
  ESL_ALLOC(mass_i, sizeof(int) * (M+1));
  ESL_ALLOC(mass_d, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_m, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_i, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_d, sizeof(int) * (M+1));

  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  esl_vec_ISet(nset_m, M+1, FALSE);
  esl_vec_ISet(nset_i, M+1, FALSE);
  esl_vec_ISet(nset_d, M+1, FALSE);
  esl_vec_ISet(xset_m, M+1, FALSE);
  esl_vec_ISet(xset_i, M+1, FALSE);
  esl_vec_ISet(xset_d, M+1, FALSE);

  if(did_fwd_scan) { /* parses were allowed to begin anywhere */
	sc = -INFTY;
	for (ip = 0; ip <= L; ip++) {
	  /*printf("bmx->mmx[i:%d][0]: %d\n", ip+i0-1, bmx->mmx[ip][0]); */
	  sc = ILogsum(sc, (bmx->mmx[ip][0]));
	}
  }
  else sc = bmx->mmx[0][0]; /* Forward/Backward run in 'align mode' parses must start at i0, end at j0 */
  /* sc is summed log prob of all possible parses of seq i0..j0 */

  /* note boundary conditions, ip = 0, i = i0-1 */
  pmx->mmx[0][0] = fmx->mmx[0][0] + bmx->mmx[0][0] - sc; /* fmx->mmx[0][0] is 0, bmx->mmx[0][0] is overall score */
  pmx->imx[0][0] = -INFTY; /*need seq to get here*/
  pmx->dmx[0][0] = -INFTY; /*D_0 does not exist*/
  if((mass_m[0] = pmx->mmx[0][0]) > thresh) {
	cp9b->pn_min_m[0] = ESL_MAX(i0-1, 0);
	nset_m[0] = TRUE;
  }
  mass_i[0] = -INFTY; /* b/c pmx->imx[0][0] is -INFTY, set above */
  mass_d[0] = -INFTY; /* b/c pmx->dmx[0][0] is -INFTY, set above */

  for (k = 1; k <= M; k++) {
	pmx->mmx[0][k] = -INFTY; /*need seq to get here*/
	pmx->imx[0][k] = -INFTY; /*need seq to get here*/
	pmx->dmx[0][k] = fmx->dmx[0][k] + bmx->dmx[0][k] - sc;
	/* mass_m[k] doesn't change b/c pmx->mmx[0][k] is -INFTY */
	/* mass_i[k] doesn't change b/c pmx->imx[0][k] is -INFTY */
	if((mass_d[k] = pmx->dmx[0][k]) > thresh) {
	  cp9b->pn_min_d[k] = ESL_MAX(i0-1, 0);
	  nset_d[k] = TRUE;
	}
  }

  /* Find minimum position in band for each state (M,I,D) of each node (0..M) */
  for (ip = 1; ip <= L; ip++) /* ip is the relative position in the seq */
	{
	  i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	  k = 0;
	  /* new block EPN, Wed Feb 13 11:58:52 2008 */
	  pmx->mmx[ip][0] = ESL_MAX(fmx->mmx[ip][0] + bmx->mmx[ip][0] - sc, -INFTY); /* M_0 doesn't emit */
	  if(! nset_m[0]) {
	if((mass_m[0] = ILogsum(mass_m[0], pmx->mmx[ip][0])) > thresh) {
	  cp9b->pn_min_m[0] = i;
	  nset_m[0] = TRUE;
	}
	  }
	  /* end of new block, old line used to be: pmx->mmx[ip][0] = -INFTY; */

	  pmx->imx[ip][0] = ESL_MAX(fmx->imx[ip][0] + bmx->imx[ip][0] - hmm->isc[dsq[i]][0] - sc, -INFTY);
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  if(! nset_i[0]) {
	if((mass_i[0] = ILogsum(mass_i[0], pmx->imx[ip][0])) > thresh) {
	  cp9b->pn_min_i[0] = i;
	  nset_i[0] = TRUE;
	}
	  }
	  pmx->dmx[ip][0] = -INFTY; /* D_0 doesn't exist */

	  for(k = 1; k <= M; k++)
	{
	  pmx->mmx[ip][k] = ESL_MAX(fmx->mmx[ip][k] + bmx->mmx[ip][k] - hmm->msc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->imx[ip][k] = ESL_MAX(fmx->imx[ip][k] + bmx->imx[ip][k] - hmm->isc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  pmx->dmx[ip][k] = ESL_MAX(fmx->dmx[ip][k] + bmx->dmx[ip][k] - sc, -INFTY);

	  if(! nset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[ip][k])) > thresh) {
	      cp9b->pn_min_m[k] = i;
	      nset_m[k] = TRUE;
	    }
	  }
	  if(! nset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[ip][k])) > thresh) {
	      cp9b->pn_min_i[k] = i;
	      nset_i[k] = TRUE;
	    }
	  }
	  if(! nset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[ip][k])) > thresh) {
	      cp9b->pn_min_d[k] = i;
	      nset_d[k] = TRUE;
	    }
	  }
	}
	}
  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  /* Find maximum position in band for each state (M,I,D) of each node (0..M)
   * by moving from L down to 1 */
  for (ip = L; ip >= 1; ip--) /* ip is the relative position in the seq */
	{
	  i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	  for(k = 0; k <= M; k++)
	{
	  if(! xset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[ip][k])) > thresh) {
	      cp9b->pn_max_m[k] = i;
	      xset_m[k] = TRUE;
	    }
	  }
	  if(! xset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[ip][k])) > thresh) {
	      cp9b->pn_max_i[k] = i;
	      xset_i[k] = TRUE;
	    }
	  }
	  if(! xset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[ip][k])) > thresh) {
	      cp9b->pn_max_d[k] = i;
	      xset_d[k] = TRUE;
	    }
	  }
	}
	}
  ip = 0;
  i  = i0-1;
  /* note boundary conditions, ip = 0, i = i0-1 */
  if(! xset_m[0]) {
	if((mass_m[0] = ILogsum(mass_m[0], pmx->mmx[0][0])) > thresh) {
	  cp9b->pn_max_m[0] = ESL_MAX(i0-1, 0);
	  xset_m[0] = TRUE;
	}
  }
  /* mass_i[0] is unchanged because b/c pmx->imx[0][0] is -INFTY, set above */
  /* mass_d[0] is unchanged because b/c pmx->dmx[0][0] is -INFTY, set above */
  for (k = 1; k <= M; k++) {
	/* mass_m[k] doesn't change b/c pmx->mmx[0][k] is -INFTY */
	/* mass_i[k] doesn't change b/c pmx->mmx[0][k] is -INFTY */
	if(!xset_d[k]) {
	  if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[0][k])) > thresh) {
	cp9b->pn_max_d[k] = ESL_MAX(i0-1, 0);
	xset_d[k] = TRUE;
	  }
	}
  }

  if(! do_old_hmm2ij) {
	/* new way as of EPN, Sun Jan 27 08:48:34 2008 */
	/* Some states may not have had their min/max set. This occurs if the entire
	 * state is outside the band (i.e. the summed probablity the state is entered for ANY i
	 * is less than our threshold. Current strategy in this situation is to set the
	 * pn_min_* and pn_max_* values as special flags, (-2) so the function that
	 * uses them to derive i and j bands knows this is the case and handles it
	 * accordingly.
	 */
	int mset;
	int dset;
	for(k = 0; k <= M; k++)
	  {
	mset = dset = TRUE;
	/* theoretically either nset_*[k] and xset_*[k] should be either both TRUE or both
	 * FALSE, but I'm slightly worried about rare precision issues, so we check if one
	 * or the other is unset, and if so, we set both to argmax position */
	if(((! nset_m[k])) || (! xset_m[k]) || (cp9b->pn_max_m[k] < cp9b->pn_min_m[k])) {
	  cp9b->pn_min_m[k] = cp9b->pn_max_m[k] = -1;
	  mset = FALSE;
	}
	if(((! nset_i[k])) || (! xset_i[k]) || (cp9b->pn_max_i[k] < cp9b->pn_min_i[k])) {
	  cp9b->pn_min_i[k] = cp9b->pn_max_i[k] = -1;
	}
	if(((! nset_d[k])) || (! xset_d[k]) || (cp9b->pn_max_d[k] < cp9b->pn_min_d[k])) {
	  cp9b->pn_min_d[k] = cp9b->pn_max_d[k] = -1;
	  dset = FALSE;
	}
	if((!hmm_is_localized && !did_fwd_scan && !did_bck_scan) && (mset == FALSE && dset == FALSE)) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "node: %d match nor delete HMM state bands were set in non-localized, non-scanning HMM, lower tau (should be << 0.5).\n", k);
	  }
  }
  else {
	/* old way, prior to Sun Jan 27 08:46:16 2008 */
	/* Some states may not have had their min/max set. This occurs if the entire
	 * state is outside the band (i.e. the summed probablity the state is entered for ANY i
	 * is less than our threshold. Current strategy in this situation is to set the
	 * band to width 1 of the most likely position for that state, but to do that we
	 * need to find what the most likely posn is, we could do this in the loop above,
	 * but this is a rare situation, and so that turns out to be wasteful.
	 *
	 * Note: the off-by-one issue mentioned below is dealt with differently with the
	 * new code, when we're setting i and j CM bands using the HMM bands.
	 */
	for(k = 0; k <= M; k++)
	  {
	/* comment *: off-by-one issue with non-emitters (includes all D states and M_0):
	 * pn_min_d[k] = i, means posn i was last residue emitted
	 * prior to entering node k's delete state. However, for a CM,
	 * if a delete states sub-parsetree is bounded by i' and j', then
	 * positions i' and j' HAVE YET TO BE EMITTED.
	 * For M_0, so we don't have to check each node to see if k == 0, we
	 * do the off-by-one correction at the end of the function.
	 */
	if(k != 0) {
	  if(cp9b->pn_min_d[k] != -1) cp9b->pn_min_d[k]++;
	  if(cp9b->pn_min_d[k] != -1) cp9b->pn_max_d[k]++;
	}
	/* theoretically either nset_*[k] and xset_*[k] should be either both TRUE or both
	 * FALSE, but I'm slightly worried about rare precision issues, so we check if one
	 * or the other is unset, and if so, we set both to argmax position */
	if((! nset_m[k]) || (! xset_m[k])) {
	  max = pmx->mmx[0][k];
	  for(ip = 1; ip <= L; ip++)
	    if(pmx->mmx[ip][k] > max) { pnmax = i0+ip-1; max = pmx->mmx[ip][k]; } /* i = i0+ip-1 */
	  cp9b->pn_min_m[k] = cp9b->pn_max_m[k] = pnmax;
	}
	if((! nset_i[k]) || (! xset_i[k])) {
	  max = pmx->imx[0][k];
	  for(ip = 1; ip <= L; ip++)
	    if(pmx->imx[ip][k] > max) { pnmax = i0+ip-1; max = pmx->imx[ip][k]; } /* i = i0+ip-1 */
	  cp9b->pn_min_i[k] = cp9b->pn_max_i[k] = pnmax;
	}
	if((! nset_d[k]) || (! xset_d[k])) {
	  max = pmx->dmx[0][k];
	  for(ip = 1; ip <= L; ip++)
	    if(pmx->dmx[ip][k] > max) { pnmax = i0+ip-1; max = pmx->dmx[ip][k]; } /* i = i0+ip-1 */
	  cp9b->pn_min_d[k] = cp9b->pn_max_d[k] = pnmax;
	}
	  }
	cp9b->pn_min_m[0]++; /* non emitter */
	cp9b->pn_max_m[0]++; /* non emitter */
  }

  cp9b->pn_min_d[0] = -1; /* D_0 doesn't exist */
  cp9b->pn_max_d[0] = -1; /* D_0 doesn't exist */

  if(debug_level > 0) cp9_DebugPrintHMMBands(stdout, j0, cp9b, (1.-p_thresh), 1);

  free(mass_m);
  free(mass_i);
  free(mass_d);
  free(nset_m);
  free(nset_i);
  free(nset_d);
  free(xset_m);
  free(xset_i);
  free(xset_d);
  free(kthresh_m);
  free(kthresh_i);
  free(kthresh_d);

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cp9_FB2HMMBandsWithSums()
 * Date:     EPN, Wed Oct 17 10:22:44 2007
 *
 * Purpose: Determine the band on all HMM states given a Forward and
 *          Backward matrix. Do this by calculating and summing log posterior
 *          probabilities that each state emitted/was visited at each posn,
 *          starting at the sequence ends, and creeping in, until the half the
 *          maximum allowable probability excluded is reached on each side.
 *
 * CP9_t hmm        the HMM
 * errbuf           char buffer for error messages
 * CP9_MX fmx:      forward DP matrix, already calc'ed
 * CP9_MX bmx:      backward DP matrix, already calc'ed
 * CP9_MX pmx:      DP matrix for posteriors, filled here, can == bmx
 * dsq              the digitized sequence
 * CP9Bands_t cp9b  CP9 bands data structure
 * int i0           start of target subsequence (often 1, beginning of dsq)
 * int j0           end of target subsequence (often L, end of dsq)
 * int   M          number of nodes in HMM (num columns of post matrix)
 * double p_thresh  the probability mass we're requiring is within each band
 * int did_fwd_scan TRUE if Forward was run in 'scan mode'  (parses could start at any posn)
 * int did_bck_scan TRUE if Backward was run in 'scan mode' (parses could end  at any posn)
 * int do_old_hmm2ij TRUE if we'll use old cp9_HMM2ijBands_OLD() function downstream
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 *
 * Returns: eslOK on success;
 */
int
cp9_FB2HMMBandsWithSums(CP9_t *hmm, char *errbuf, ESL_DSQ *dsq, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *pmx, CP9Bands_t *cp9b,
			int i0, int j0, int M, double p_thresh, int did_fwd_scan, int did_bck_scan, int do_old_hmm2ij, int debug_level)
{
  int status;
  int k;                                  /* counter over nodes of the model */
  int L = j0-i0+1;                        /* length of sequence */
  int thresh = Prob2Score(((1. - p_thresh)/2.), 1.); /* allowable prob mass excluded on each side */

  /* *_m = match, *_i = insert, *_d = delete */
  int i, ip;                              /* actual position and relative position in sequence, ip = i-i0+1 */
  int *kthresh_m, *kthresh_i, *kthresh_d; /* [0..k..hmm->M], individual thresholds for each state */
  int *nset_m, *nset_i, *nset_d;          /* [0..k..hmm->M], has minimum been set for this state? */
  int *xset_m, *xset_i, *xset_d;          /* [0..k..hmm->M], has maximum been set for this state? */
  int *mass_m, *mass_i, *mass_d;          /* [0..k..hmm->M], summed log prob of pmx->mx[i][k] from 0..k or k..L */

  if(bmx != pmx) GrowCP9Matrix(pmx, errbuf, L, M, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  /* allocations and initializations */
  ESL_ALLOC(nset_m, sizeof(int) * (M+1));
  ESL_ALLOC(nset_i, sizeof(int) * (M+1));
  ESL_ALLOC(nset_d, sizeof(int) * (M+1));
  ESL_ALLOC(xset_m, sizeof(int) * (M+1));
  ESL_ALLOC(xset_i, sizeof(int) * (M+1));
  ESL_ALLOC(xset_d, sizeof(int) * (M+1));
  ESL_ALLOC(mass_m, sizeof(int) * (M+1));
  ESL_ALLOC(mass_i, sizeof(int) * (M+1));
  ESL_ALLOC(mass_d, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_m, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_i, sizeof(int) * (M+1));
  ESL_ALLOC(kthresh_d, sizeof(int) * (M+1));

  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  esl_vec_ISet(nset_m, M+1, FALSE);
  esl_vec_ISet(nset_i, M+1, FALSE);
  esl_vec_ISet(nset_d, M+1, FALSE);
  esl_vec_ISet(xset_m, M+1, FALSE);
  esl_vec_ISet(xset_i, M+1, FALSE);
  esl_vec_ISet(xset_d, M+1, FALSE);

  /* get the posterior matrix first, we need it b/c each state will have a different log prob threshold */
  cp9_Posterior(dsq, i0, j0, hmm, fmx, bmx, pmx, did_fwd_scan);

  /* fill ipost_sums in cp9bands data structure */
  cp9_IFillPostSums(pmx, cp9b, i0, j0);

  /* set state dependent cutoff thresholds for log prob mass we need on each side (this is unique to
   * WithSums() function */
  for(k = 0; k <= M; k++) {
	kthresh_m[k] = thresh + cp9b->isum_pn_m[k];
	kthresh_i[k] = thresh + cp9b->isum_pn_i[k];
	kthresh_d[k] = thresh + cp9b->isum_pn_d[k];
  }

  /* Find minimum position in band for each state (M,I,D) of each node (0..M) */
  for (ip = 0; ip <= L; ip++) /* ip is the relative position in the seq */
	{
	  i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	  for(k = 0; k <= M; k++)
	{
	  if(! nset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[ip][k])) > kthresh_m[k]) {
	      cp9b->pn_min_m[k] = i;
	      nset_m[k] = TRUE;
	    }
	  }
	  if(! nset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[ip][k])) > kthresh_i[k]) {
	      cp9b->pn_min_i[k] = i;
	      nset_i[k] = TRUE;
	    }
	  }
	  if(! nset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[ip][k])) > kthresh_d[k]) {
	      cp9b->pn_min_d[k] = i;
	      nset_d[k] = TRUE;
	    }
	  }
	}
	}
  /* Find maximum position in band for each state (M,I,D) of each node (0..M)
   * by moving from L down to 0 */
  /* reset mass_* arrays */
  esl_vec_ISet(mass_m, M+1, -INFTY);
  esl_vec_ISet(mass_i, M+1, -INFTY);
  esl_vec_ISet(mass_d, M+1, -INFTY);
  for (ip = L; ip >= 0; ip--) /* ip is the relative position in the seq */
	{
	  i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	  for(k = 0; k <= M; k++)
	{
	  if(! xset_m[k]) {
	    if((mass_m[k] = ILogsum(mass_m[k], pmx->mmx[ip][k])) > kthresh_m[k]) {
	      cp9b->pn_max_m[k] = i;
	      xset_m[k] = TRUE;
	    }
	  }
	  if(! xset_i[k]) {
	    if((mass_i[k] = ILogsum(mass_i[k], pmx->imx[ip][k])) > kthresh_i[k]) {
	      cp9b->pn_max_i[k] = i;
	      xset_i[k] = TRUE;
	    }
	  }
	  if(! xset_d[k]) {
	    if((mass_d[k] = ILogsum(mass_d[k], pmx->dmx[ip][k])) > kthresh_d[k]) {
	      cp9b->pn_max_d[k] = i;
	      xset_d[k] = TRUE;
	    }
	  }
	}
	}

  if(do_old_hmm2ij) { /* we have to correct for an off-by-one to be consistent with the 'old' way code */
	for(k = 1; k <= M; k++)
	  {
	/* comment *: off-by-one issue with non-emitters (includes all D states and M_0):
	 * pn_min_d[k] = i, means posn i was last residue emitted
	 * prior to entering node k's delete state. However, for a CM,
	 * if a delete states sub-parsetree is bounded by i' and j', then
	 * positions i' and j' HAVE YET TO BE EMITTED.
	 * For M_0, so we don't have to check each node to see if k == 0, we
	 * do the off-by-one correction at the end of the function.
	 */
	  if(cp9b->pn_min_d[k] != -1) cp9b->pn_min_d[k]++;
	  if(cp9b->pn_min_d[k] != -1) cp9b->pn_max_d[k]++;
	  }
	cp9b->pn_min_m[0]++; /* non-emitter */
	cp9b->pn_max_m[0]++; /* non-emitter */
  }

#if eslDEBUGLEVEL >= 1
  /* all states should have their min/max set because we've normalized the probability
   * of entering each state to 1.0, so we assert this to be true */
  ESL_DASSERT1((nset_m[0]));
  ESL_DASSERT1((nset_i[0]));
  ESL_DASSERT1((xset_m[0]));
  ESL_DASSERT1((xset_i[0]));
  /* D_0 state does not exist */
  for(k = 1; k <= M; k++)
	{
	  ESL_DASSERT1((nset_m[k]));
	  ESL_DASSERT1((nset_i[k]));
	  ESL_DASSERT1((nset_d[k]));
	  ESL_DASSERT1((xset_m[k]));
	  ESL_DASSERT1((xset_i[k]));
	  ESL_DASSERT1((xset_d[k]));
	}
#endif

  cp9b->pn_min_d[0] = -1; /* D_0 doesn't exist */
  cp9b->pn_max_d[0] = -1; /* D_0 doesn't exist */

  if(debug_level > 0) cp9_DebugPrintHMMBands(stdout, j0, cp9b, (1.-p_thresh), 1);

  free(mass_m);
  free(mass_i);
  free(mass_d);
  free(nset_m);
  free(nset_i);
  free(nset_d);
  free(xset_m);
  free(xset_i);
  free(xset_d);
  free(kthresh_m);
  free(kthresh_i);
  free(kthresh_d);

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: cp9_Posterior()
 * based on Ian Holmes' hmmer/src/postprob.c::P7EmitterPosterior()
 *
 * Purpose:  Combines Forward and Backward matrices into a posterior
 *           probability matrix. For emitters (match and inserts) the
 *           entries in row i of this matrix are the logs of the posterior
 *           probabilities of each state emitting symbol i of the sequence.
 *           For non-emitters the entries in row i of this matrix are the
 *           logs of the posterior probabilities of each state being 'visited'
 *           when the last emitted residue in the parse was symbol i of the
 *           sequence.
 *           The last point distinguishes this function from P7EmitterPosterior()
 *           which set all posterior values for for non-emitting states to -INFTY.
 *           The caller must allocate space for the matrix, although the
 *           backward matrix can be used instead (overwriting it will not
 *           compromise the algorithm).
 *
 *           if(did_fwd_scan == TRUE) forward was run in scan mode, which allowed
 *           parses to start at any position of sequence, this changes how
 *           we calculate summed prob of all parses (calculation of 'sc', see code).
 *
 * Args:     dsq      - sequence in digitized form
 *           i0       - start of target subsequence (often 1, beginning of dsq)
 *           j0       - end of target subsequence (often L, end of dsq)
 *           hmm      - the model
 *           forward  - pre-calculated forward matrix
 *           backward - pre-calculated backward matrix
 *           mx       - pre-allocated dynamic programming matrix
 *           did_fwd_scan - TRUE if Forward was run in 'scan' mode, which means
 *                          parses can start at any position of the sequence
 *
 * Return:   void
 */
void
cp9_Posterior(ESL_DSQ *dsq, int i0, int j0, CP9_t *hmm, CP9_MX *fmx, CP9_MX *bmx, CP9_MX *mx, int did_fwd_scan)
{
  if(dsq == NULL) cm_Fail("in cp9_posterior(), dsq is NULL.");

  int i;
  int k;
  int sc;
  int L;		/* subsequence length */
  int ip;		/* i': relative position in the subsequence  */
  /*float temp_sc;*/

  L  = j0-i0+1;		/* the length of the subsequence */

  if(did_fwd_scan) { /* parses could start/stop anywhere */
	sc = -INFTY;
	for (ip = 0; ip <= L; ip++) {
	  /*printf("bmx->mmx[i:%d][0]: %d\n", i, bmx->mmx[ip][0]);*/
	  sc = ILogsum(sc, (bmx->mmx[ip][0]));
	}
  } /* parses must start/stop at (i = i0)/(j = j0) */
  else sc = bmx->mmx[0][0];

  /* note boundary conditions, case by case by case... */
  mx->mmx[0][0] = fmx->mmx[0][0] + bmx->mmx[0][0] - sc; /* fmx->mmx[0][0] is 0, bmx->mmx[1][0] is overall score */
  mx->imx[0][0] = -INFTY; /*need seq to get here*/
  mx->dmx[0][0] = -INFTY; /*D_0 does not exist*/
  for (k = 1; k <= hmm->M; k++) {
	  mx->mmx[0][k] = -INFTY; /*need seq to get here*/
	  mx->imx[0][k] = -INFTY; /*need seq to get here*/
	  mx->dmx[0][k] = fmx->dmx[0][k] + bmx->dmx[0][k] - sc;
  }

  for (ip = 1; ip <= L; ip++) /* ip is the relative position in the seq */
	{
	  i = i0+ip-1;		/* e.g. i is actual index in dsq, runs from i0 to j0 */
	  mx->mmx[ip][0] = -INFTY; /*M_0 does not emit*/
	  mx->imx[ip][0] = fmx->imx[ip][0] + bmx->imx[ip][0] - hmm->isc[dsq[i]][0] - sc;
	  /*hmm->isc[dsq[i]][0] will have been counted in both fmx->imx and bmx->imx*/
	  mx->dmx[ip][0] = -INFTY; /*D_0 does not exist*/

	  /*printf("fmx->mmx[ip:%d][0]: %d\n bmx->mmx[ip:%d][0]: %d\n", ip, fmx->mmx[ip][0], ip, bmx->mmx[ip][0]);
	printf("fmx->imx[ip:%d][0]: %d\n bmx->imx[ip:%d][0]: %d\n", ip, fmx->imx[ip][0], ip, bmx->imx[ip][0]);
	printf("fmx->dmx[ip:%d][0]: %d\n bmx->dmx[ip:%d][0]: %d\n", ip, fmx->dmx[ip][0], ip, bmx->dmx[ip][0]);*/
	  for (k = 1; k <= hmm->M; k++)
	{
	  mx->mmx[ip][k] = ESL_MAX(fmx->mmx[ip][k] + bmx->mmx[ip][k] - hmm->msc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->msc[dsq[i]][k] will have been counted in both fmx->mmx and bmx->mmx*/
	  mx->imx[ip][k] = ESL_MAX(fmx->imx[ip][k] + bmx->imx[ip][k] - hmm->isc[dsq[i]][k] - sc, -INFTY);
	  /*hmm->isc[dsq[i]][k] will have been counted in both fmx->imx and bmx->imx*/
	  mx->dmx[ip][k] = ESL_MAX(fmx->dmx[ip][k] + bmx->dmx[ip][k] - sc, -INFTY);
	  /*printf("fmx->mmx[ip:%d][%d]: %d\n bmx->mmx[ip:%d][%d]: %d\n", ip, k, fmx->mmx[ip][k], ip, k, bmx->mmx[ip][k]);
	  printf("fmx->imx[ip:%d][%d]: %d\n bmx->imx[ip:%d][%d]: %d\n", ip, k, fmx->imx[ip][k], ip, k, bmx->imx[ip][k]);
	  printf("fmx->dmx[ip:%d][%d]: %d\n bmx->dmx[ip:%d][%d]: %d\n\n", ip, k, fmx->dmx[ip][k], ip, k, bmx->dmx[ip][k]);*/
	}
	}

  /*
	float temp_sc;
	for(i = 0; i <= L; i++)
	{
	for(k = 0; k <= hmm->M; k++)
	{
	temp_sc = Score2Prob(mx->mmx[i][k], 1.);
	if(temp_sc > .0001)
	printf("mx->mmx[%3d][%3d]: %9d | %8f\n", i, k, mx->mmx[i][k], temp_sc);
	temp_sc = Score2Prob(mx->imx[i][k], 1.);
	if(temp_sc > .0001)
	printf("mx->imx[%3d][%3d]: %9d | %8f\n", i, k, mx->imx[i][k], temp_sc);
	temp_sc = Score2Prob(mx->dmx[i][k], 1.);
	if(temp_sc > .0001)
	printf("mx->dmx[%3d][%3d]: %9d | %8f\n", i, k, mx->dmx[i][k], temp_sc);
	}
	}*/
}

/*****************************************************************************
 * EPN 03.23.06
 * Function: cp9_IFillPostSums()
 * based on: ifill_post_sums_del() (deprecated) 11.23.05
 *
 * Purpose:  Given a posterior matrix post, where post->mmx[i][k]
 *           is the log odds score of the probability that
 *           match state k emitted position i of the sequence,
 *           sum the log probabilities that each state emitted
 *           each position. Do this for inserts, matches, and
 *           and deletes.
 *
 * arguments:
 * cp9_dpmatrix_s *post  dpmatrix_s posterior matrix, xmx, mmx, imx, dmx
 *                       2D int arrays. [0.1..N][0.1..M]
 * CP9Bands_t *cp9b - the cp9 bands data structure
 * int  i0          start of target subsequence (often 1, beginning of dsq)
 * int  j0          end of target subsequence (often L, end of dsq)
 *****************************************************************************/
void
cp9_IFillPostSums(CP9_MX *post, CP9Bands_t *cp9b, int i0, int j0)
{
  int i;            /* counter over positions of the sequence */
  int k;            /* counter over nodes of the model */
  int L;	    /* subsequence length */
  int M;            /* consensus length of cp9 */
  M = cp9b->hmm_M;
  L  = j0-i0+1;		/* the length of the subsequence */

  /* step through each node, fill the post sum structures */
  for(k = 0; k <= M; k++)
	{
	  cp9b->isum_pn_m[k] = -INFTY;
	  cp9b->isum_pn_i[k] = -INFTY;
	  cp9b->isum_pn_d[k] = -INFTY;
	  for(i = 0; i <= L; i++) {
	cp9b->isum_pn_m[k] = ILogsum(cp9b->isum_pn_m[k], post->mmx[i][k]);
	cp9b->isum_pn_i[k] = ILogsum(cp9b->isum_pn_i[k], post->imx[i][k]);
	cp9b->isum_pn_d[k] = ILogsum(cp9b->isum_pn_d[k], post->dmx[i][k]);
	  }
	}
}

/* Function: cp9_ValidateBands()
 * Incept:   EPN, Wed Nov 14 15:49:08 2007
 * Purpose:  Validate the info in CP9Bands_t data structure is internally
 *           consistent.
 *
 * Args:     cm     the cm
 *           errbuf char buffer for error message
 *           cp9b   the CP9 bands object
 *           i0     first residue we can possibly allow as valid j
 *           j0     final residue we can possibly allow as valid j
 *
 * Returns: eslOK, or, if error, other status code and filled errbuf
 */
int
cp9_ValidateBands(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, int i0, int j0, int do_trunc)
{
  int v;            /* counter over states of the CM */
  int jp;           /* counter over valid j's, but offset. jp+jmin[v] = actual j */
  int sd;           /* minimum d allowed for a state, ex: MP_st = 2, ML_st = 1. etc. */
  int max_sdl_sdr;  /* maximum of StateLeftDelta, StateRightDelta for a state */
  int dn;           /* max_sdl_sdr if do_trunc, else sd */
  int hd_needed;
  int j;

  if(cm->M    != cp9b->cm_M)  ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cm->M != cp9b->cm_M\n");
  if(cm->clen != cp9b->hmm_M) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cm->clen != cp9b->hmm_M\n");

  hd_needed = 0;
  for(v = 0; v < cp9b->cm_M; v++) {
	hd_needed += cp9b->jmax[v] - cp9b->jmin[v] + 1;
  }
  if(hd_needed != cp9b->hd_needed) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hd_needed inconsistent.");

  for(v = 0; v < cm->M; v++) {
	sd          = StateDelta(cm->sttype[v]);
	max_sdl_sdr = ESL_MAX(StateLeftDelta(cm->sttype[v]), StateRightDelta(cm->sttype[v]));
	dn          = do_trunc ? max_sdl_sdr : sd;
	/* if (do_trunc) d can be 1 for MP states, this is why we use dn
	 * here.  Note: d can't be 0 for ML/IL in R mode, MR/IR in L
	 * mode even though you might think it could be. We'll always do
	 * a truncated begin with d=1 for L,R marginal alignments. */
	if(cp9b->jmin[v] != -1) {
	  if(cp9b->jmin[v] < dn) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->jmin[v:%d]: %d < StateDelta[v]: %d.\n", v, cp9b->jmin[v], dn);
	  if(cp9b->jmax[v] < dn) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->jmax[v:%d]: %d < StateDelta[v]: %d.\n", v, cp9b->jmax[v], dn);
	}
  }

  for(v = 0; v < cm->M; v++) {
	sd          = StateDelta(cm->sttype[v]);
	max_sdl_sdr = ESL_MAX(StateLeftDelta(cm->sttype[v]), StateRightDelta(cm->sttype[v]));
	dn          = do_trunc ? max_sdl_sdr : sd;
	/* if (do_trunc) d can be 1 for MP states, this is why we use dn
	 * here.  Note: d can't be 0 for ML/IL in R mode, MR/IR in L
	 * mode even though you might think it could be. We'll always do
	 * a truncated begin with d=1 for L,R marginal alignments. */
	if(cm->sttype[v] == E_st) {
	  for(jp = 0; jp <= (cp9b->jmax[v]-cp9b->jmin[v]); jp++) {
	if(cp9b->hdmin[v][jp] != 0) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hdmin for E state is inconsistent.");
	if(cp9b->hdmax[v][jp] != 0) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hdmin for E state is inconsistent.");
	  }
	}
	else {
	  if(cp9b->jmin[v] != -1) {
	for(jp = 0; jp <= (cp9b->jmax[v]-cp9b->jmin[v]); jp++) {
	  j = jp+cp9b->jmin[v];
		  if(cp9b->hdmin[v][jp] == -1) {
			if(cp9b->hdmax[v][jp] != -2) { ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hdmin is -1 for state %d, j: %d, but hdmax is not -2 (it's %d).",  v, j, cp9b->hdmax[v][jp]); }
		  }
		  else {
			if(cp9b->hdmin[v][jp] != ESL_MAX((j - cp9b->imax[v] + 1), dn)) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hdmin %d (dn: %d) for state %d, j: %d imax[v]: %d is inconsistent.", cp9b->hdmin[v][jp], dn, v, j, cp9b->imax[v]);
			if(cp9b->hdmax[v][jp] != ESL_MAX((j - cp9b->imin[v] + 1), dn)) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), cp9b->hdmax %d (dn: %d) for state %d, j: %d imin[v]: %d is inconsistent.", cp9b->hdmax[v][jp], dn, v, j, cp9b->imin[v]);
		  }
		}
	  }
	}
	/* get rid of StateIsDetached once old band construction method is deprecated */
	if(cp9b->imin[v] == -1 && !StateIsDetached(cm, v)) { /* ensure all unreachable states have 0 width bands */
	  if(cp9b->imax[v] != -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] == -1, but imax[v] != -2 but rather %d\n", v, cp9b->imax[v]);
	  if(cp9b->jmin[v] != -1) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] == -1, but jmin[v] != -1 but rather %d\n", v, cp9b->jmin[v]);
	  if(cp9b->jmax[v] != -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] == -1, but jmax[v] != -2 but rather %d\n", v, cp9b->jmax[v]);
	}
	else if(!StateIsDetached(cm, v)){
	  if(cp9b->imax[v] == -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] != -1, but imax[v] == -2!\n", v);
	  if(cp9b->jmin[v] == -1) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] != -1, but jmin[v] == -1!\n", v);
	  if(cp9b->jmax[v] == -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d imin[v] != -1, but jmax[v] == -2!\n", v);
	}

	if(i0 == j0 && cm->sttype[v] == MP_st) { /* special case, MPs are impossible in this case */
	  if(cp9b->imin[v] != -1) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), exceedingly rare case, i0==j0==%d v: %d is MP but imin[v]: %d != -1\n", i0, v, cp9b->imin[v]);
	  if(cp9b->imax[v] != -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), exceedingly rare case, i0==j0==%d v: %d is MP but imax[v]: %d != -2\n", i0, v, cp9b->imax[v]);
	  if(cp9b->jmin[v] != -1) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), exceedingly rare case, i0==j0==%d v: %d is MP but jmin[v]: %d != -1\n", i0, v, cp9b->jmin[v]);
	  if(cp9b->jmax[v] != -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), exceedingly rare case, i0==j0==%d v: %d is MP but jmax[v]: %d != -2\n", i0, v, cp9b->jmax[v]);
	}
	else {
	  if(cp9b->jmin[v] != -1) {
	for(j = cp9b->jmin[v]; j <= cp9b->jmax[v]; j++) {
	  if(j < (i0-1)) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), j: %d outside i0-1:%d..j0:%d is within v's j band: jmin[%d]: %d jmax[%d]: %d\n", j, i0-1, j0, v, cp9b->jmin[v], v, cp9b->jmax[v]);
	  if(j > j0)     ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), j: %d outside i0-1:%d..j0:%d is within v's j band: jmin[%d]: %d jmax[%d]: %d\n", j, i0-1, j0, v, cp9b->jmin[v], v, cp9b->jmax[v]);
		  if(cp9b->hdmin[v][(j-cp9b->jmin[v])] == -1) {
			if(cp9b->hdmax[v][(j-cp9b->jmin[v])] != -2) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d j: %d hdmin[v][jp_v:%d] == -1, but hdmax[v][jp_v:%d] != -2 (it's %d)\n", v, j, (j-cp9b->jmin[v]), (j-cp9b->jmin[v]), cp9b->hdmax[v][(j-cp9b->jmin[v])]);
		  }
		  else {
			if(cp9b->hdmin[v][(j-cp9b->jmin[v])] < dn) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d j: %d hdmin[v][jp_v:%d] : %d less than StateDelta for v: %d\n", v, j, (j-cp9b->jmin[v]), cp9b->hdmin[v][(j-cp9b->jmin[v])], dn);
			if(cp9b->hdmax[v][(j-cp9b->jmin[v])] < dn) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), v: %d j: %d hdmax[v][jp_v:%d] : %d less than StateDelta for v: %d\n", v, j, (j-cp9b->jmin[v]), cp9b->hdmax[v][(j-cp9b->jmin[v])], dn);
		  }
		}
	if(cp9b->jmax[v] > cp9b->jmax[0]) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), jmax[v:%d]:%d > jmax[0]:%d.", v, cp9b->jmax[v], cp9b->jmax[0]);
	if(cp9b->imin[v] < cp9b->imin[0]) ESL_FAIL(eslEINVAL, errbuf, "cp9_ValidateBands(), imin[v:%d]:%d < imin[0]:%d, i0:%d j0:%d jmin[v]:%d jmax[v]:%d jmin[0]:%d jmax[0]:%d imax[v]:%d", v, cp9b->imin[v], cp9b->imin[0], i0, j0, cp9b->jmin[v], cp9b->jmax[v], cp9b->jmin[0], cp9b->jmax[0], cp9b->imax[v]);
	  }
	}
  }
  return eslOK;
}

/*
 * Function: cp9_GrowHDBands()
 *
 * Incept:   EPN, Thu Oct 25 13:24:29 2007
 * Purpose:  Rearrange CP9 hdmin and hdmax pointers for a new sequence
 *           based on j bands (jmin and jmax). If the currently allocated
 *           size for hdmin, hdmax is not big enough, reallocate them.
 *
 * Args:
 * CP9Bands_t cp9b    the CP9 Bands object.
 * errbuf   char buffer for error messages
 *
 * Returns: eslOK on success, eslEMEM if memory allocation error
 */
int
cp9_GrowHDBands(CP9Bands_t *cp9b, char *errbuf)
{
  int status;
  int v;
  int cur_size = 0;
  int jbw;

  /* count size we need for hdmin/hdmax given current jmin, jmax */
  cp9b->hd_needed = 0; /* we'll rewrite this */
  for(v = 0; v < cp9b->cm_M; v++) {
	cp9b->hd_needed += cp9b->jmax[v] - cp9b->jmin[v] + 1;
	/* printf("hd needed v: %4d bw: %4d total: %5d\n", v, cp9b->jmax[v] - cp9b->jmin[v] + 1, cp9b->hd_needed);  */
  }
  if(cp9b->hd_alloced < cp9b->hd_needed) {
	void *tmp;
	if(cp9b->hdmin_mem == NULL) ESL_ALLOC(cp9b->hdmin_mem, sizeof(int) * cp9b->hd_needed);
	else                        ESL_RALLOC(cp9b->hdmin_mem, tmp, sizeof(int) * cp9b->hd_needed);
	if(cp9b->hdmax_mem == NULL) ESL_ALLOC(cp9b->hdmax_mem, sizeof(int) * cp9b->hd_needed);
	else                        ESL_RALLOC(cp9b->hdmax_mem, tmp, sizeof(int) * cp9b->hd_needed);
  }

  /* set pointers */
  cur_size = 0;
  for(v = 0; v < cp9b->cm_M; v++) {
	cp9b->hdmin[v] = cp9b->hdmin_mem + cur_size;
	cp9b->hdmax[v] = cp9b->hdmax_mem + cur_size;
	jbw = cp9b->jmax[v] - cp9b->jmin[v] + 1;
	assert(jbw >= 0);
	ESL_DASSERT1((jbw >= 0));
	cur_size += jbw;
  }
  cp9b->hd_alloced = cur_size;
  ESL_DASSERT1((cp9b->hd_alloced == cp9b->hd_needed));
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.");
}

/*****************************************************************************
 * EPN 11.03.05
 * Function: ij2d_bands()
 *
 * Purpose:  Determine the band for each cm state v on d (the band on the
 *           length of the subsequence emitted from the subtree rooted
 *           at state v). These are easily calculated given the bands on i
 *           and j.
 *
 * arguments:
 *
 * CM_t *cm         the CM
 * int  W           length of sequence we're aligning
 * int *imin        imin[v] = first position in band on i for state v
 * int *imax        imax[v] = last position in band on i for state v
 * int *jmin        jmin[v] = first position in band on j for state v
 * int *jmax        jmax[v] = last position in band on j for state v
 * int **hdmin      hdmin[v][jp] = first position in band on d for state v
 *                                 and j position: j = jp+jmin[v].
 *                  Filled in this function.
 * int **hdmax      hdmax[v][jp] = last position in band on d for state v
 *                                 and j position: j = jp+jmin[v].
 *                  Filled in this function.
 * int do_trunc     TRUE if we'll use these bands in a truncated version of CYK/Inside/Outside
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 *****************************************************************************/
void
ij2d_bands(CM_t *cm, int W, int *imin, int *imax, int *jmin, int *jmax,
	   int **hdmin, int **hdmax, int do_trunc, int debug_level)
{
  int v;            /* counter over states of the CM */
  int jp;           /* counter over valid j's, but offset. jp+jmin[v] = actual j */
  int j;            /* actual j */
  int sd;           /* minimum d allowed for a state, ex: MP_st = 2, ML_st = 1. etc. */
  int max_sdl_sdr;  /* maximum of StateLeftDelta, StateRightDelta for a state */
  int dn;           /* max_sdl_sdr if do_trunc, else sd */
  int hdn, hdx;     /* temporary hdmin/hdmax */
  for(v = 0; v < cm->M; v++) {
	if(cm->sttype[v] == E_st) {
	  for(jp = 0; jp <= (jmax[v]-jmin[v]); jp++) {
	hdmin[v][jp] = 0;
	hdmax[v][jp] = 0;
	  }
	}
	else {
	  sd          = StateDelta(cm->sttype[v]);
	  max_sdl_sdr = ESL_MAX(StateLeftDelta(cm->sttype[v]), StateRightDelta(cm->sttype[v]));
	  dn          = do_trunc ? max_sdl_sdr : sd;
	  /* if (do_trunc) d can be 1 for MP states, this is why we use dn
	   * here.  Note: d can't be 0 for ML/IL in R mode, MR/IR in L
	   * mode even though you might think it could be. We'll always do
	   * a truncated begin with d=1 for L,R marginal alignments. */

	  for(jp = 0; jp <= (jmax[v]-jmin[v]); jp++) {
	j   = jp+jmin[v];
	hdn = j-imax[v]+1;
	hdx = j-imin[v]+1;
	if(hdx < dn) {
	  hdmin[v][jp] = -1;
	  hdmax[v][jp] = -2;
	}
	else {
	  hdmin[v][jp] = ESL_MAX(hdn, dn);
	  hdmax[v][jp] = hdx;
	}
	/* printf("hd[%d][j=%d]: min: %d | max: %d\n", v, (jp+jmin[v]), hdmin[v][jp], hdmax[v][jp]); */
	  }
	}
  }
}

/* Function: cp9_HMM2ijBands()
 * Synopsis: Derive bands on i and j for all CM states given HMM bands.
 * Incept:   EPN, Thu Feb  7 12:05:01 2008
 *
 * Purpose:  Given HMM bands, determine the corresponding bands on the
 *           CM. Both for i: the left border of the subsequence emitted
 *           from the subtree rooted at v, the band is imin[v]..imax[v]
 *           inclusive. And also for j: the right border of the subseq
 *           emitted from the subtree rooted at v, the band is
 *           jmin[v]..jmax[v] inclusive.
 *
 *           This is done by first enforcing that the HMM bands allow
 *           at least 1 possible HMM parse. A valid parse given the
 *           HMM bands is not guaranteed, although it's nearly always
 *           likely even for relatively high values of tau (the
 *           probability mass allowed outside the band for each state,
 *           relatively high is 0.01). With very tight bands, for
 *           example from a tau of 0.49, the chance that all parses
 *           are impossible given the bands is much more likely (especially
 *           with non-homologous sequences). *If* the HMM bands exclude
 *           all possible HMM parses, they are expanded in a greedy,
 *           stupid way to allow at least 1 parse (we could be smarter,
 *           but this case only arises for impractical tau values, in
 *           fact I only implemented it to verify the rest of the HMM
 *           banding implementation is robust, and will always work
 *           for tau values up to 0.5).
 *
 *           Once we know an HMM parse is possible given the HMM bands,
 *           we also know if we impose those exact bands on the CM
 *           we will also have a valid CM parse, b/c there is a 1:1
 *           mapping between HMM parses and CM parsetrees. So, we
 *           impose the HMM bands onto the CM to get the i and j
 *           bands using a stack and mapping 'explicit' bands,
 *           the i or j bands of CM states that map to an HMM
 *            state (for example the i band of MATL_ML states,
 *            or the j bands of MATR_MR states). The other bands
 *           that are not explicitly set (ex: the j band of a
 *           MATL_ML state and the i band of a MATR_MR state), are
 *           implicitly set based on the explicit ones.
 *
 *           Note: This code is ugly, even more than usual for me.
 *           There's a plethora of special cases, which are maddening
 *           during development/debugging. The code starts out simple
 *           and balloons as you add code to handle the special cases.
 *           [EPN, Thu Feb  7 12:17:53 2008].
 *
 * Args:     <cm>     - the model
 *           <errbuf> - for returning error messages
 *           <cp9>    - the CP9 HMM used to determine the bands
 *           <cp9b>   - the bands data structure
 *           <cp9map> - map between the CM and HMM
 *           <i0>     - first position in the sequence we're considering
 *           <j0>     - final position in the sequence we're considering
 *           <doing_search> - TRUE if we're searching the target sequence, not aligning it,
 *                            relevant b/c iff we're aligning the parsetree *must* span i0..j0
 *           <do_trunc>     - TRUE if we're going to use these bands for truncated CYK/Inside/Outside
 *           <debug_level>  - verbosity level for debuggint printf() statements
 *
 * Returns:  <eslOK> on success.
 *
 * Throws:   <eslEINCOMPAT> on contract violation
 *           <eslEMEM> on memory error
 */
int
cp9_HMM2ijBands(CM_t *cm, char *errbuf, CP9_t *cp9, CP9Bands_t *cp9b, CP9Map_t *cp9map, int i0, int j0, int doing_search, int do_trunc, int debug_level)
{

  int status;
  int v;

  /* ptrs to cp9b data, for convenience */
  int *imin;          /* imin[v] = first position in band on i for state v to be filled in this function. [1..M] */
  int *imax;          /* imax[v] = last position in band on i for state v to be filled in this function. [1..M] */
  int *jmin;          /* jmin[v] = first position in band on j for state v to be filled in this function. [1..M] */
  int *jmax;          /* jmax[v] = last position in band on j for state v to be filled in this function. [1..M] */

  int nd;                  /* counter over CM nodes. */
  int y;                   /* counters over children states */
  int hmm_M;               /* number of nodes in the HMM */
  ESL_STACK   *nd_pda;     /* used to traverse the CM from left to right in consensus positions, cpos = 0..clen */
  ESL_STACK   *lpos_pda;   /* used to store lpos for BIF nodes */
  int          on_right;   /* TRUE if we're on the right for current node during our CM traversal */
  int          w;          /* a state index */
  int          lpos, rpos; /* left/right border of subtree for current node */
  /*int          k;*/          /* counter of HMM nodes, for debugging print statements, currently not used */
  int hmm_is_localized;      /* TRUE if HMM has local begins, ends or ELs on */
  int cm_is_fully_localized; /* TRUE if CM has local begins and ends on */

  /* r_* arrays, these are filled in HMMBandsEnforceValidParse(), they are the band on 'reachable'
   * residues for each HMM state as we move from left to right through the HMM.
   * For example, r_mn[k] = 3, r_mx[k] = 5, means that for all possible HMM parses within the bands
   * in the cp9b pn_* arrays that reach the match state of node k, the residue emitted by that match
   * must be either 3, 4, or 5.
   */
  int *r_mn;   /* [0..k..hmm_M] minimal residue position for which we can reach M_k (match state of node k) */
  int *r_mx;   /* [0..k..hmm_M] maximal residue position for which we can reach M_k */
  int *r_in;   /* [0..k..hmm_M] minimal residue position for which we can reach I_k (insert state of node k) */
  int *r_ix;   /* [0..k..hmm_M] maximal residue position for which we can reach I_k */
  int *r_dn;   /* [0..k..hmm_M] minimal residue position for which we can reach D_k (delete state of node k) */
  int *r_dx;   /* [0..k..hmm_M] maximal residue position for which we can reach D_k */
  int *r_nn_i; /* [0..k..hmm_M] minimal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nx_i; /* [0..k..hmm_M] maximal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nn_j; /* [0..k..hmm_M] minimal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nx_j; /* [0..k..hmm_M] maximal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  /* r_nn_i and r_nx_i are used when setting i bands, and r_nn_j and r_nx_j are used when setting j bands .
   * the values can differ vecause of an off-by-one issue with the non-emitting (delete and M_0) states of the HMM:
   * pn_min_d[k] = i, means posn i was last residue emitted prior to entering node k's delete state. However, for a CM,
   * if a delete states sub-parsetree is bounded by i' and j', this means positions i' and j' HAVE YET TO BE EMITTED.
   * For i states this means we have to add 1 to the delete band positions, but for j states we do not, the off-by-one
   * is taken care of because the HMM is moving left to right, while j positions move right to left (confusing as hell,
   * bad explanation, i know... write out an example, its the only way to get it).
   */

  /* Contract checks */
  if (cp9b == NULL)                                                                   ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands(), cp9b is NULL.\n");
  if(i0 < 1) ESL_FAIL(eslEINCOMPAT,  errbuf, "cp9_HMM2ijBands(), i0 < 1: %d\n", i0);
  if(j0 < 1) ESL_FAIL(eslEINCOMPAT,  errbuf, "cp9_HMM2ijBands(), j0 < 1: %d\n", j0);
  if(j0 < i0) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands(), i0 (%d) < j0 (%d)\n", i0, j0);
  hmm_is_localized      = ((cp9->flags & CPLAN9_LOCAL_BEGIN) || (cp9->flags & CPLAN9_LOCAL_END) || (cp9->flags & CPLAN9_EL)) ? TRUE : FALSE;
  cm_is_fully_localized = ((cm->flags & CMH_LOCAL_BEGIN) && (cm->flags & CMH_LOCAL_END)) ? TRUE : FALSE;

  /* ptrs to cp9b arrays, for convenience */
  imin     = cp9b->imin;
  imax     = cp9b->imax;
  jmin     = cp9b->jmin;
  jmax     = cp9b->jmax;
  hmm_M    = cp9b->hmm_M;
  /* Initialize all bands to -1 */
  esl_vec_ISet(imin, cm->M, -1);
  esl_vec_ISet(imax, cm->M, -2);
  esl_vec_ISet(jmin, cm->M, -1);
  esl_vec_ISet(jmax, cm->M, -2);

  /* Step 1: Check for valid HMM parse within the HMM bands, if there isn't one messily expand the bands so that there is one */
  if((status = HMMBandsEnforceValidParse(cp9, cp9b, cp9map, errbuf, i0, j0, doing_search, NULL,
					 &r_mn, &r_mx, &r_in, &r_ix, &r_dn, &r_dx, &r_nn_i, &r_nx_i, &r_nn_j, &r_nx_j)) != eslOK) return status;

  /* debugging printf block */
  /*
	for(k = 0; k <= cp9b->hmm_M;k ++) {
	printf("k: %4d  %4d %4d  %4d %4d  %4d %4d  %4d %4d  %4d  %4d\n", k, r_mn[k], r_mx[k], r_in[k], r_ix[k], r_dn[k], r_dx[k], r_nn_i[k], r_nx_i[k], r_nn_j[k], r_nx_j[k]);
	}
	cp9_DebugPrintHMMBands(stdout, j0, cp9b, cm->tau, 1);
  */

  /* Step 2: Traverse the CM from left to right in consensus position coordinates. Fill in the
   *         i and j bands (imin, imax, jmin, jmax) for all states as we go. The CM is traversed
   *         using a stack, each node is visited twice (this is based on Sean's cleaner:
   *         display.c::CreateEmitMap(). The first time a node <nd> is visited we're 'on the left'
   *         and then we push it back to the stack, and visit it again 'on the right' later. We
   *         are moving around the perimeter of the guide tree, stepping one position at a time
   *         in the consensus sequence coordinates, from left to right. We mainly set bands
   *         when we're 'on the right', with the exception of Left emitting states, which are
   *         set when we're on the HMM. All emitting states and delete states v have either
   *         i, or j or both bands that can be set 'explicitly' based on the HMM bands for
   *         the HMM state that maps to v. For example we can set the i bands for MATL_ML
   *         states, and the j bands for MATR_MR states. All other bands (and both i
   *         and j bands for S states, B states, E states) are set 'implicitly based on the
   *         explicit bands, and the r_* data structures we filled in HMMBandsEnforceValidParse().
   *         The goal was to make this function as clean and simple as possible, and although
   *         it doesn't look it, this is as good as I can get it. There are many special
   *         cases that make an elegant implementation beyond me.
   */
  if(! doing_search) {
	assert(r_mn[0] == (i0-1));
	if(!hmm_is_localized) assert(r_mx[hmm_M] == j0 || r_ix[hmm_M] == j0 || r_dx[hmm_M] == j0);
  }
  nd   = 0;
  lpos = 0;
  rpos = 0;

  if ((nd_pda    = esl_stack_ICreate())      == NULL)  goto ERROR;
  if ((lpos_pda  = esl_stack_ICreate())      == NULL)  goto ERROR;
  if ((status = esl_stack_IPush(nd_pda, 0))  != eslOK) goto ERROR;		/* 0 = left side. 1 would = right side. */
  if ((status = esl_stack_IPush(nd_pda, nd)) != eslOK) goto ERROR;
  while (esl_stack_IPop(nd_pda, &nd) != eslEOD)
	{
	  esl_stack_IPop(nd_pda, &on_right);
	  if (on_right) {
	switch(cm->ndtype[nd]) { /* this is a massive switch, we set i and j bands for almost all
				  * states here when we're on the right (sole exceptions are i bands for
				  * MATP_nd states (except MATP_IR), and MATL_nd states) */

	case BIF_nd: /* special case, set i bands based on left child, j bands based on right child */
	  v = cm->nodemap[nd];
	  w = cm->cfirst[v]; /* BEGL_S */
	  y = cm->cnum[v];   /* BEGR_S */

	  /* set v's i band based on left child w, and v's j band based on right child y */
	  imin[v] = (imin[w] != -1) ? imin[w] : imin[y]; /* if imin[w] == imin[y] == -1, then imin[v] will be set as -1 */
	  imax[v] = (imax[w] != -2) ? imax[w] : imax[y]; /* if imax[w] == imax[y] == -2, then imax[v] will be set as -2 */
	  jmin[v] = (jmin[y] != -1) ? jmin[y] : jmin[w]; /* if jmin[y] == jmin[w] == -1, then jmin[v] will be set as -1 */
	  jmax[v] = (jmax[y] != -2) ? jmax[y] : jmax[w]; /* if jmax[y] == jmax[w] == -2, then jmax[v] will be set as -2 */

	  if(! do_trunc) {
	    /* check for possibility that either child is not reachable, will only possibly happen with local on */
	    if(imin[w] == -1 || jmin[w] == -1 || imin[y] == -1 || jmin[y] == -1 ||
	       imax[w] == -2 || imax[w] == -2 || jmax[y] == -2 || jmax[y] == -2) {
	      /* either the left child, or right child is not reachable, make them both unreachable as well as the BIF state */
	      imin[v] = imin[w] = imin[y] = jmin[v] = jmin[w] = jmin[y] = -1;
	      imax[v] = imax[w] = imax[y] = jmax[v] = jmax[w] = jmax[y] = -2;
	      /* also make the BEGR_IL unreachable */
	      imin[y+1] = jmin[y+1] = -1;
	      imax[y+1] = jmax[y+1] = -2;
	    }
	  }
	  break;

	case MATP_nd:
	  lpos = cp9map->nd2lpos[nd];
	  rpos = cp9map->nd2rpos[nd];

	  v = cm->nodemap[nd]; /* v is MATP_MP */
	  jmin[v] = r_mn[rpos];
	  jmax[v] = r_mx[rpos];

	  v++; /* v is MATP_ML */
	  jmin[v] = r_dn[rpos];
	  jmax[v] = r_dx[rpos];

	  v++; /* v is MATP_MR */
	  jmin[v] = r_mn[rpos];
	  jmax[v] = r_mx[rpos];

	  v++; /* v is MATP_D */
	  jmin[v] = r_dn[rpos];
	  jmax[v] = r_dx[rpos];

	  v++; /* v is MATP_IL */
	  jmin[v] = r_nn_j[rpos-1];
	  jmax[v] = r_nx_j[rpos-1];

	  v++; /* v is MATP_IR */
	  jmin[v] = r_in[rpos-1];
	  jmax[v] = r_ix[rpos-1];
	  imin[v] = r_nn_i[lpos+1]; /* look at band on lpos *+1* b/c we enter MATP_IR AFTER the MATP_MP, MATP_MR, MATP_ML, or MATP_IL insert (if any) */
	  imax[v] = r_nx_i[lpos+1]; /* look at band on lpos *+1* b/c we enter MATP_IR AFTER the MATP_MP, MATP_MR, MATP_ML, or MATP_IL insert (if any) */
	  ESL_DASSERT1(((lpos+1) <= cm->clen)); /* note: we know lpos+1 <= cm->clen b/c we're in a MATP node, and the ccol the right half of the node maps to
						 *       must be to the right of the ccol the left half of the node maps to */
	  if(imin[v] == 0) { cm_Fail("v: %d lpos: %d\n", v, lpos); }
	  break; /* case MATP_nd */

	   	case MATL_nd: /* i bands were set when we were on the left, non-right emitter, set implicit j bands */
	  lpos = cp9map->nd2lpos[nd];

	  v = cm->nodemap[nd]; /* v is MATL_ML */
	  jmin[v] = r_nn_j[rpos];
	  jmax[v] = r_nx_j[rpos];

	  v++; /* v is MATL_D, the MATL_ML and MATL_IL concerns don't apply, D's don't emit */
	  jmin[v] = r_nn_j[rpos];
	  jmax[v] = r_nx_j[rpos];

	  v++; /* v is MATL_IL */
	  jmin[v] = r_nn_j[rpos];
	  jmax[v] = r_nx_j[rpos];
	  break;

	case MATR_nd: /* set j bands explicitly from HMM bands, i bands implicitly */
	  rpos = cp9map->nd2rpos[nd];
	  v = cm->nodemap[nd]; /* v is MATR_MR */
	  jmin[v] = r_mn[rpos];
	  jmax[v] = r_mx[rpos];
	  imin[v] = r_nn_i[lpos];
	  imax[v] = r_nx_i[lpos];

	  v++; /* v is MATR_D */
	  jmin[v] = r_dn[rpos];
	  jmax[v] = r_dx[rpos];
	  imin[v] = r_nn_i[lpos];
	  imax[v] = r_nx_i[lpos];

	  v++; /* v is MATR_IR */
	  jmin[v] = r_in[rpos-1];
	  jmax[v] = r_ix[rpos-1];
	  imin[v] = r_nn_i[lpos];
	  imax[v] = r_nx_i[lpos];
	  break;

	case BEGL_nd:
	case BEGR_nd: /* set i and j bands implicitly, except for BEGR_IL, whose i bands are set explicitly based on HMM */
	  v = cm->nodemap[nd]; /* set i and j band for BEG{L,R}_S based on children */
	  imin[v] = jmin[v] = INT_MAX;
	  imax[v] = jmax[v] = INT_MIN;
	  for(y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++) {
	    /* if y is reachable, make sure we can get there from v */
	    if(imin[y] != -1) {
	      imin[v] = ESL_MIN(imin[v], imin[y]);
	      imax[v] = ESL_MAX(imax[v], imax[y]);
	    }
	    if(jmin[y] != -1) {
	      jmin[v] = ESL_MIN(jmin[v], jmin[y]);
	      jmax[v] = ESL_MAX(jmax[v], jmax[y]);
	    }
	  }
	  if(imin[v] == INT_MAX) {
	    imin[v] = -1;
	    imax[v] = -2;
	  }
	  if(jmin[v] == INT_MAX) {
	    jmin[v] = -1;
	    jmax[v] = -2;
	  }

	  /* set BEGR_IL's i and j band */
	  if(cm->ndtype[nd] == BEGR_nd) {
	    v++;
	    imin[v] = r_in[lpos-1]; /* BEGR_IL emits before lpos */
	    imax[v] = r_ix[lpos-1];
	    if(imin[v-1] != -1 && imin[v] != -1) { /* if BEGR_S and BEGR_IL is reachable */
	      imin[v-1] = ESL_MIN(imin[v-1], imin[v]); /* expand BEGR_S so it can reach BEGR_IL */
	      jmin[v] = (jmin[v-1] == -1) ? -1 : ESL_MAX(jmin[v-1], i0); /* can't get to a BEGR_IL without emitting at least i0 */
	      jmax[v] = jmax[v-1];
	    }
	    else {
	      imin[v] = jmin[v] = -1;
	      imax[v] = jmax[v] = -2;
	    }
	    esl_stack_IPop(lpos_pda, &lpos); /* pop the remembered lpos from our sister BEGL_nd to use for parent BIF_nd and above */
	  }
	  else { /* BEGL_nd */
	    if ((status = esl_stack_IPush(lpos_pda, lpos)) != eslOK) goto ERROR;
	    lpos = rpos+1; /* next node we pop from stack will be our BEGR sister, on the right, switch lpos to rpos+1 */
	  }
	  break;

	case END_nd:
	  v = cm->nodemap[nd]; /* v is END_E */
	  imin[v] = r_nn_i[lpos];
	  imax[v] = (r_nx_i[lpos] == -2) ? r_nx_i[lpos] : ESL_MIN(r_nx_i[lpos]+1, j0+1); /* +1 is for StateDelta */
	  if(r_in[lpos] != -1) { /* we could come from an IR above us (tricky case) */
	    imin[v] = ESL_MIN(imin[v], ESL_MAX(r_in[lpos] - 1, i0));
	    imax[v] = ESL_MAX(imax[v], ESL_MAX(r_ix[lpos] - 1, i0));
	  }
	  rpos = lpos;
	  if(imin[v] != -1) {
	    jmin[v] = imin[v]-1; /* E must emit d = 0 residues, so j ==i-1 */
	    jmax[v] = imax[v]-1; /* E must emit d = 0 residues, so j ==i-1 */
	  }
	  break;

	case ROOT_nd: /* ROOT is a special case, set i and j bands */
	  /* lpos == 1 and rpos == hmm_M */
	  assert(lpos == 1);
	  assert(rpos == hmm_M);
	  v = cm->nodemap[nd]; /* v is ROOT_S */
	  imin[v] = r_nn_i[1];
	  imax[v] = r_nx_i[1];
	  jmin[v] = r_nn_j[hmm_M];
	  jmax[v] = r_nx_j[hmm_M];

	  v++; /* v is ROOT_IL */
	  imin[v] = r_in[0]; /* ROOT_IL maps to HMM insert state of HMM node 0 */
	  imax[v] = r_ix[0]; /* ROOT_IL maps to HMM insert state of HMM node 0 */
	  /* ROOT_IL's j bands will be same as ROOT_S's, after ensuring state delta of 1 is respected */
	  jmin[v] = (r_nn_j[hmm_M] == -1) ? -1 : ESL_MAX(r_nn_j[hmm_M], i0); /* can't get to ROOT_IL without emitting at least i0 */
	  jmax[v] = r_nx_j[hmm_M];
	  if(r_in[hmm_M] != -1) {
	    jmin[v] = ESL_MIN(jmin[v], r_in[hmm_M]);
	    jmax[v] = ESL_MIN(jmax[v], r_ix[hmm_M]);
	  }

	  v++; /* v is ROOT_IR */
	  if(r_in[hmm_M] != -1) { /* if r_in[hmm_M] == -1, this state is unreachable */
	    imin[v] = r_nn_i[1]; /* HMM state M_0 is silent */
	    imax[v] = r_nx_i[1]; /* HMM state M_0 is silent */
	    if(imin[v-1] != -1) {
	      imin[v] = ESL_MIN(imin[v], imin[v-1]+1);
	      imax[v] = ESL_MAX(imax[v], imax[v-1]+1);
	    }
	    jmin[v] = r_in[hmm_M]; /* ROOT_IR maps to HMM insert state of HMM node hmm_M */
	    jmax[v] = r_ix[hmm_M]; /* ROOT_IR maps to HMM insert state of HMM node hmm_M */
	  }
	  break;
	} /* end of switch(cm->ndtype[nd]) */
	  } /* end of if(on_right) */

	  else { /* on left */
	/* set i bands for MATP_nd, MATL_nd only */
	switch(cm->ndtype[nd]) {
	case MATP_nd:
	  lpos = cp9map->nd2lpos[nd];
	  v = cm->nodemap[nd]; /* v is MATP_MP */
	  imin[v] = r_mn[lpos];
	  imax[v] = r_mx[lpos];
	  v++; /* v is MATP_ML */
	  imin[v] = r_mn[lpos];
	  imax[v] = r_mx[lpos];
	  v++; /* v is MATP_MR */
	  imin[v] = r_dn[lpos] == -1 ? -1 : r_dn[lpos]+1;
	  imax[v] = r_dx[lpos] == -2 ? -2 : r_dx[lpos]+1;
	  v++; /* v is MATP_D */
	  imin[v] = r_dn[lpos] == -1 ? -1 : r_dn[lpos]+1;
	  imax[v] = r_dx[lpos] == -2 ? -2 : r_dx[lpos]+1;
	  v++; /* v is MATP_IL */
	  imin[v] = r_in[lpos];
	  imax[v] = r_ix[lpos];
	  /* we deal with setting imin/imax for MATP_IR when we're on the right */
	  break;

	case MATL_nd:
	  lpos = cp9map->nd2lpos[nd];
	  v = cm->nodemap[nd]; /* v is MATL_ML */
	  imin[v] = r_mn[lpos];
	  imax[v] = r_mx[lpos];
	  v++; /* v is MATL_D */
	  imin[v] = r_dn[lpos] == -1 ? -1 : r_dn[lpos]+1;
	  imax[v] = r_dx[lpos] == -2 ? -2 : r_dx[lpos]+1;
	  v++; /* v is MATL_IL */
	  imin[v] = r_in[lpos];
	  imax[v] = r_ix[lpos];
	  break;
	} /* end of switch(cm->ndtype[nd]) */

	if(cm->ndtype[nd] == BIF_nd) {
	  /* push the BIF back on for its right side  */
	  if ((status = esl_stack_IPush(nd_pda, 1)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(nd_pda, nd)) != eslOK) goto ERROR;
	  /* push node index for right child */
	  if ((status = esl_stack_IPush(nd_pda, 0)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(nd_pda, cm->ndidx[cm->cnum[cm->nodemap[nd]]])) != eslOK) goto ERROR;
	  /* push node index for left child */
	  if ((status = esl_stack_IPush(nd_pda, 0)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(nd_pda, cm->ndidx[cm->cfirst[cm->nodemap[nd]]])) != eslOK) goto ERROR;
	}
	else {
	  /* push the node back on for right side */
	  if ((status = esl_stack_IPush(nd_pda, 1)) != eslOK) goto ERROR;
	  if ((status = esl_stack_IPush(nd_pda, nd)) != eslOK) goto ERROR;
	  /* push child node on */
	  if (cm->ndtype[nd] != END_nd) {
	    if ((status = esl_stack_IPush(nd_pda, 0)) != eslOK) goto ERROR;
	    if ((status = esl_stack_IPush(nd_pda, nd+1)) != eslOK) goto ERROR;
	  }
	}
	  }
	}

  /* If we're allowing truncated alignments, do a final pass through all states, expanding bands to allow for
   * L and/or R and/or T marginal alignments, as necessary,
   * cp9b->{L,R}marg_{i,j}{min,max} were defined in cp9_PredictStartAndEndPositions().
   */
  if(do_trunc) {
	for(v = 0; v < cm->M; v++) {
	  if(cp9b->Lvalid[v] || cp9b->Tvalid[v]) { /* allow for left marginal alignment by expanding j band */
	jmin[v] = (jmin[v] == -1) ? cp9b->Lmarg_jmin : ESL_MIN(jmin[v], cp9b->Lmarg_jmin);
	jmax[v] = (jmax[v] == -2) ? cp9b->Lmarg_jmax : ESL_MAX(jmax[v], cp9b->Lmarg_jmax);
	  }
	  if(cp9b->Rvalid[v] || cp9b->Tvalid[v]) { /* allow for right marginal alignment by expanding i band */
	imin[v] = (imin[v] == -1) ? cp9b->Rmarg_imin : ESL_MIN(imin[v], cp9b->Rmarg_imin);
	imax[v] = (imax[v] == -2) ? cp9b->Rmarg_imax : ESL_MAX(imax[v], cp9b->Rmarg_imax);
	  }
	}
  }

  if(! doing_search) { /* if we're aligning the full seq must be aligned at the root state */
	imin[0] = i0;                   /* first residue must be in subtree of ROOT_S */
	if(imin[1] != -1) imin[1] = i0; /* first residue must be in subtree of ROOT_IL, if it is used */
	jmax[0] = j0;                   /* final residue must be in subtree of ROOT_S */
	if(jmin[1] != -1) jmax[1] = j0; /* final residue must be in subtree of ROOT_IL if it is used */
	if(jmin[2] != -1) jmax[2] = j0; /* final residue must be in subtree of ROOT_IR if it is used */
  }

  /* Final pass through all states:
   * 1. if any band value implies a state is unreachable, make it so by setting imin[v]=jmin[v]=-1, imax[v]=jmax[v]=-2;
   * 2. set detached inserts unreachable.
   * 3. if(!do_trunc) for left emitters enforce jmin/jmax allow at least 1 residue to be emitted
   * 4. if(!do_trunc) for MP states, enforce jmin/jmax allow at least 2 residues to be emitted
   */
  for(v = 0; v < cm->M; v++) {
	assert((imin[v] == -1 && imax[v] == -2) || (imin[v] >= 0 && imax[v] >= 0));
	assert((jmin[v] == -1 && jmax[v] == -2) || (jmin[v] >= 0 && jmax[v] >= 0));
	ESL_DASSERT1(((imin[v] == -1 && imax[v] == -2) || (imin[v] >= 0 && imax[v] >= 0)));
	ESL_DASSERT1(((jmin[v] == -1 && jmax[v] == -2) || (jmin[v] >= 0 && jmax[v] >= 0)));
	if(imin[v] == -1 || jmin[v] == -1) {
	  imin[v] = jmin[v] = -1;
	  imax[v] = jmax[v] = -2;
	}
	if(StateIsDetached(cm, v)) {
	  imin[v] = jmin[v] = -1;
	  imax[v] = jmax[v] = -2;
	}
	if(! do_trunc) {
	  if(cm->sttype[v] == MP_st) {
	if(jmax[v] == i0) { /* HMM tells us right half of MP state must emit first residue in the sequence, we know better, make state unreachable */
	  ESL_DASSERT1((jmin[v] == i0));
	  imin[v] = jmin[v] = -1; /* ignore hmm */
	  imax[v] = jmax[v] = -2; /* ignore hmm */
	}
	else if (jmin[v] == i0) { /* HMM tells us right half of MP state could possibly first residue (i0), but we know it can't (see comment above). */
	  jmin[v]++;              /* pad 1 onto what the hmm thought, make first emittable residue i0+1 */
	  /* leave jmax[v] alone, we konw it's not == i0, we checked for that case above */
	}
	  }
	  /* if a left emitter, enforce jmin/jmax require at least 1 residue is emitted */
	  if((StateLeftDelta(cm->sttype[v]) == 1) && imin[v] != -1) {
	if(jmax[v] == (i0-1)) { /* HMM bands implied state must be entered after emitting exactly 0 residues, we know better, make it unreachable */
	  ESL_DASSERT1((jmin[v] == (i0-1)));
	  imin[v] = jmin[v] = -1; /* ignore hmm */
	  imax[v] = jmax[v] = -2; /* ignore hmm */
	}
	else if (jmin[v] == (i0-1)) {
	  jmin[v] = i0; /* pad 1 onto what the hmm thought */
	  /* leave jmax[v] alone, we know it's not == i0-1, we checked for that case above */
	}
	  }
	}
  }

  #if 0
  if(do_trunc) {
	for(v = 0; v < cm->M; v++) {
	  printf("dotrunc: %d ijband v: %4d nd: %4d  %4s  %2s  i: %5d - %5d  j: %5d - %5d\n", do_trunc, v, cm->ndidx[v],
	     Nodetype(cm->ndtype[cm->ndidx[v]]),
	     Statetype(cm->sttype[v]),
	     imin[v], imax[v], jmin[v], jmax[v]);
	}
  }
  #endif

  /* A final, brutal hack. If the hmm used to derive bands has local
   * begins, ends and ELs on, it's possible (but extremely rare
   * empirically, even with very high tau values (0.49!)) that no
   * valid CM parse exists within the i and j bands. To avoid this, if
   * the CM has local begins and ends on then we use a brutal hack
   * here to enable at least one valid parse from the ROOT_S to a
   * state from which the EL can be reached and able to emit all
   * residues.
   *
   * There's 2 relevant cases.
   *
   * Case 1: node 1 is a MATP, MATR, or MATL node (this is the easier case)
   * Case 2: node 1 is a BIF node
   *
   * Case 1: node 1 is a MATP, MATR, or MATL node (this is the easier case)
   * A. assert CM local begins and ends are on (they should be if we're using a localized HMM to get bands).
   *    and we can do a local begin into and a local end out of node 1. This will be TRUE unless there
   *    are only 3 nodes in the CM (which is impossible, cmbuild won't build a 3 node CM - the reason is that
   *    such a CM would suck at local alignment b/c no local ends are possible (not to mention they're too small
   *    to be useful, and that if node 1 == MATL the CM can only emit/align 1 residue in local mode b/c the
   *    ROOT_IL, ROOT_IR are unreachable and the MATL_IL is detached!).
   *
   * B. if we're doing alignment (full target must be accounted for):
   *    v = cm->nodemap[nd]
   *    set imin[v] = ESL_MIN(imin[v], i0)
   *        imax[v] = ESL_MAX(imax[v], i0)
   *        jmin[v] = ESL_MIN(jmin[v], j0)
   *        jmax[v] = ESL_MAX(jmax[v], j0)
   *    else if we're doing search and v is unreachable, make it reachable by setting
   *        imin[v] = imin[0];
   *        imax[v] = imax[0];
   *        jmin[v] = jmin[0];
   *        jmax[v] = jmax[0];
   *    then we'll be able to emit some residues from v, (so we're guaranteed a valid parse.)
   *
   * Case 2: node 1 is a BIF node
   * v = cm->nodemap[nd] (the BIF_B state)
   * if v is reachable and we're doing alignment, expand it's bands so that it can
   * account for the full seq:
   *    set imin[v] = ESL_MIN(imin[v], i0)
   *        imax[v] = ESL_MAX(imax[v], i0)
   *        jmin[v] = ESL_MIN(jmin[v], j0)
   *        jmax[v] = ESL_MAX(jmax[v], j0)
   * else if v is reachable and we're doing search, ensure that one contiguous chunk of
   * seq can be emitted by BIF's children (see code)
   *
   * if v is not reachable (if we're doing search or not), we enforce 1 valid parse,
   * the BIF must emit the full target, residues i0..j0-1 from its' BEGL_S's EL state, and
   * residue j0 from it's BEGR_S EL state.
   */
  if(hmm_is_localized && cm_is_fully_localized) {
	if(do_trunc) cp9b->Jvalid[0] = TRUE;
	if(imin[0] == -1) { /* ROOT_S is unreachable, uhh... */
	  imin[0] = imax[0] = i0;
	  jmin[0] = jmax[0] = j0;
	}
	if(cm->nodes == 3) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "cp9_HMM2ijBands(), cm/hmm are locally configured, only 3 nodes in the CM, this is an illegal CM b/c local ENDs are impossible.");
	nd = 1;
	if(i0 == j0) {
	  while((nd < cm->nodes) && (cm->ndtype[nd] == MATP_nd)) nd++; /* a local begin into a MATP_MP state can't happen when the target is 1 residue, it must emit 2 residues */
	  if(cm->ndtype[nd] == END_nd) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "cp9_HMM2ijBands(), CM has no MATL, MATR or BIF nodes, this shouldn't happen (cmbuild forbids it)!\n");
	}
	if(cm->ndtype[nd] == BIF_nd) {
	  v = cm->nodemap[nd];
	  w = cm->cfirst[v]; /* BEGL_S */
	  y = cm->cnum[v];   /* BEGR_S */
	  if(do_trunc) {
	cp9b->Jvalid[v] = TRUE;
	cp9b->Jvalid[w] = TRUE;
	cp9b->Jvalid[y] = TRUE;
	  }
	  if(imin[v] != -1 && imin[w] != -1 && imin[y] != -1) { /* v and its children w and y are all reachable */
	if(!doing_search) { /* we need to be able to account for the full sequence */
	  imin[v] = ESL_MIN(imin[v], i0);
	  imax[v] = ESL_MAX(imax[v], i0);
	  jmin[v] = ESL_MIN(jmin[v], j0);
	  jmax[v] = ESL_MAX(jmax[v], j0);
	  imin[w] = imin[v];
	  imax[w] = imax[v];
	  jmax[w] = ESL_MAX(jmax[w], ESL_MIN(j0, imax[w]));
	  jmin[y] = jmin[v];
	  jmax[y] = jmax[v];
	  imin[y] = ESL_MIN(imin[y], ESL_MAX(i0, jmin[y]));
	  /* now ensure that imin[y] <= jmax[w]+1, so we can definitely emit the full seq */
	  imin[y] = ESL_MIN(imin[y], ESL_MAX(i0, jmax[w]+1));
	  imax[y] = ESL_MAX(imin[y], imax[y]);
	}
	else { /* doing search, we only need to be able to emit some range of residues from BEGL and BEGR's EL states */
	  imin[y] = ESL_MIN(imin[y], ESL_MAX(i0, jmax[w]+1));
	  imax[y] = ESL_MAX(imin[y], imax[y]);
	}
	  } /* end of if(imin[v] != -1) */
	  else { /* v, w or y are unreachable, make them reachable */
	if(! doing_search) {
	  /* if we're doing alignment, we enforce that the full seq must be emittable
	   * by BIF and it's children's (BEGL_S and BEGR_S) EL states */
	  imin[v] = i0;
	  imax[v] = i0;
	  jmin[v] = j0;
	  jmax[v] = j0;
	  imin[w] = i0; /* w will emit i0..j0-1 (which may be 0 residues if i0==j0) */
	  imax[w] = i0;
	  jmin[w] = j0-1;
	  jmax[w] = j0-1;
	  imin[y] = j0; /* y will emit only j0 */
	  imax[y] = j0;
	  jmin[y] = j0;
	  jmax[y] = j0;
	}
	else {
	  /* if we're doing search we enforce that the residues from imin[0]..jmax[0] are emittable
	   * by BIF and it's children's (BEGL_S and BEGR_S) EL states */
	  imin[v] = imin[0];
	  imax[v] = imin[0];
	  jmin[v] = jmax[0];
	  jmax[v] = jmax[0];
	  imin[w] = imin[0]; /* w will emit imin[0]..jmax[0]-1 (which may be 0 residues if imin[0]==jmax[0]) */
	  imax[w] = imin[0];
	  jmin[w] = jmax[0]-1;
	  jmax[w] = jmax[0]-1;
	  imin[y] = jmax[0]; /* y will emit only jmax[0] */
	  imax[y] = jmax[0]; /* y will emit only jmax[0] */
	  jmin[y] = jmax[0];
	  jmax[y] = jmax[0];
	}
	  }
	} /* end of if(cm->ndtype[nd] == BIF_nd) */
	else {
	  /* node nd is a MATL, MATR or MATP */
	  ESL_DASSERT1((cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd));
	  assert(cm->ndtype[nd] == MATL_nd || cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd);
	  v = cm->nodemap[nd];
	  if(do_trunc) cp9b->Jvalid[v] = TRUE;
	  /* we can do a local begin into and local end out of v */
	  ESL_DASSERT1((NOT_IMPOSSIBLE(cm->beginsc[v])));
	  ESL_DASSERT1((NOT_IMPOSSIBLE(cm->endsc[v])));
	  assert(NOT_IMPOSSIBLE(cm->beginsc[v]));
	  assert(NOT_IMPOSSIBLE(cm->endsc[v]));
	  if(!doing_search) { /* we need to be able to account for the full sequence */
	if(imin[v] == -1) { /* v is unreachable, make it reachable only for emitting the full seq */
	  imin[v] = imax[v] = i0;
	  jmin[v] = jmax[v] = j0;
	}
	else { /* v is reachable, expand it's band so it can emit the full seq */
	  imin[v] = ESL_MIN(imin[v], i0);
	  imax[v] = ESL_MAX(imax[v], i0);
	  jmin[v] = ESL_MIN(jmin[v], j0);
	  jmax[v] = ESL_MAX(jmax[v], j0);
	}
	  }
	  else { /* doing search, do not need to account for full target sequence, make it so we can reach v for some i and j (this will guarantee >= 1 valid parse) */
	if(imin[v] == -1) { /* v is unreachable */
	  imin[v] = imin[0];
	  imax[v] = imax[0];
	  jmin[v] = jmin[0];
	  jmax[v] = jmax[0];
	}
	else { /* v is reachable, make sure it's reachable from the ROOT_S state, expand the ROOT_S band */
	  imin[0] = ESL_MIN(imin[0], imin[v]);
	  imax[0] = ESL_MAX(imax[0], imax[v]);
	  jmin[0] = ESL_MIN(jmin[0], jmin[v]);
	  jmax[0] = ESL_MAX(jmax[0], jmax[v]);
	}
	  }
	}
  }
  /* end of brutal hack */
#if eslDEBUGLEVEL >= 1
  /* check for valid CM parse, there should be one, unless do_trunc is true, then we may not... */
  if((status = CMBandsCheckValidParse(cm, cp9b, errbuf, i0, j0, doing_search)) != eslOK) return status;
#endif

  esl_stack_Destroy(nd_pda);
  esl_stack_Destroy(lpos_pda);
  free(r_mn);
  free(r_mx);
  free(r_dn);
  free(r_dx);
  free(r_in);
  free(r_ix);
  free(r_nn_i);
  free(r_nx_i);
  free(r_nn_j);
  free(r_nx_j);

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/* Function: HMMBandsEnforceValidParse()
 * Incept:   EPN, Fri Feb  1 16:46:50 2008
 *
 * Purpose:  Given bands on HMM states for a target sequence,
 *           check for a valid HMM parse within those bands.
 *           If no valid parse exists, expand the bands such that
 *           one does exist, in a greedy manner.
 *
 *           Bands are expanded using the HMMBandsFixUnreachable()
 *           function. These take a node that is unreachable
 *           and modify bands on current node and nearby nodes
 *           to make it reachable. This is awful hack number 1.
 *           (see HMMBandsFixUnreachable() for details.
 *           Note: the technique used for expanding the bands was
 *           selected for it's relative simplicity. It does not
 *           expand the bands in any smart way that is aware of
 *           probability mass or score of the newly possible parses
 *           during the band expansion. You could try to do that,
 *           but it's not likely to be worth it, when the default
 *           bands before expansion do not allow a single parse,
 *           the real solution is to lower tau, the tail loss parameter
 *           used during band calculation. This function is really
 *           only nec so the HMM banding technique is robust to
 *           high values of tau, higher than any reasonable application
 *           should use.
 *
 *           Awful hack #2 occurs when two different transitions to the
 *           same state imply reachable bands that have a 'gap' in the
 *           middle. For example if node D_3 can reach node M_4 with
 *           i = 3 or 4, and node M_3 can reach node M_4 with i equal
 *           to 6 or 7. This means that node M_4 cannot be reached for
 *           i == 5, but this implementation is much easier if we can
 *           just set the reachable band for M_4 to 3..7. So, that's
 *           what we do, and we doctor the band of I_3 so that M_4 *can*
 *           be reached for i == 5. This is done in HMMBandsFillGap().
 *           See that function for details. This hack is only performed
 *           for models NOT in local mode. If we are in local mode,
 *           this 'gap' situation comes up much more often, but when
 *           we're in local mode, we can use an EL state in the CM
 *           to basically always get a valid parse, so we're not
 *           so worried about enforcing a valid parse and we skip
 *           this hack.
 *
 * Args:     cp9    - the HMM the bands were derived from
 *           cp9b   - the CP9 bands object
 *           cp9map - map from CM to cp9
 *           errbuf - for error messages
 *           i0     - first residue of sequence we're using bands for
 *           j0     - final residue of sequence we're using bands for
 *
 * Returns:  eslOK on success
 *           eslEINCONCEIVABLE if we can't expand the bands to make a valid parse (shouldn't happen)
 *           eslEMEM if a memory allocation error occurs
 *           <ret_did_expand> set to TRUE if we had to expand the HMM bands, FALSE if not
 */
int
HMMBandsEnforceValidParse(CP9_t *cp9, CP9Bands_t *cp9b, CP9Map_t *cp9map, char *errbuf, int i0, int j0, int doing_search, int *ret_did_expand,
			  int **ret_r_mn, int **ret_r_mx, int **ret_r_in,  int **ret_r_ix, int **ret_r_dn, int **ret_r_dx,
			  int **ret_r_nn_i, int **ret_r_nx_i, int **ret_r_nn_j, int **ret_r_nx_j)
{
  int status;
  /* r_* arrays, these are the bands on 'reachable' residues for each HMM state as we move
   * from left to right through the HMM.
   * For example, r_mn[k] = 3, r_mx[k] = 5, means that for all possible HMM parses within the bands
   * in the cp9b pn_* arrays that reach the match state of node k, the residue emitted by that match
   * must be either 3, 4, or 5.
   */
  int *r_mn;   /* [0..k..hmm_M] minimal residue position for which we can reach M_k (match state of node k) */
  int *r_mx;   /* [0..k..hmm_M] maximal residue position for which we can reach M_k */
  int *r_in;   /* [0..k..hmm_M] minimal residue position for which we can reach I_k (insert state of node k) */
  int *r_ix;   /* [0..k..hmm_M] maximal residue position for which we can reach I_k */
  int *r_dn;   /* [0..k..hmm_M] minimal residue position for which we can reach D_k (delete state of node k) */
  int *r_dx;   /* [0..k..hmm_M] maximal residue position for which we can reach D_k */
  int r_begn;  /*  minimal first residue position for which we can exit the BEGIN state */
  int r_begx;  /*  minimal first residue position for which we can exit the BEGIN state */
  int r_endn;  /*  minimal final residue position for which we can reach the END state */
  int r_endx;  /*  maximal final residue position for which we can reach the END state */
  int *r_nn_i; /* [0..k..hmm_M] minimal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nx_i; /* [0..k..hmm_M] maximal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nn_j; /* [0..k..hmm_M] minimal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  int *r_nx_j; /* [0..k..hmm_M] maximal residue position for which we can reach node k (any of M_k, I_k, D_k) */
  /* r_nn_i and r_nx_i are used when setting i bands, and r_nn_j and r_nx_j are used when setting j bands .
   * The values can differ vecause of an off-by-one issue with the non-emitting (delete and M_0) states of the HMM:
   * pn_min_d[k] = i, means posn i was last residue emitted prior to entering node k's delete state. However, for a CM,
   * if a delete states sub-parsetree is bounded by i' and j', this means positions i' and j' HAVE YET TO BE EMITTED.
   * For i states this means we have to add 1 to the delete band positions, but for j states we do not, the off-by-one
   * is taken care of because the HMM is moving left to right, while j positions move right to left (confusing as hell,
   * bad explanation, i know... write out an example, it's the only way to get it).
   */
  int *r_nn_hmm;   /* [0..k..hmm_M] min reachable position i in HMM node k from the HMM's perspective */
  int *r_nx_hmm;   /* [0..k..hmm_M] max reachable position i in HMM node k from the HMM's perspective  */
  int *was_unr;    /* [0..k..hmm_M] TRUE if node k was unreachable, then we expanded bands, now it should be reachable */
  int *filled_gap; /* [0..k..hmm_M] TRUE if we filled a gap in the reachable bands for node k */
  int  just_filled_gap; /* TRUE if we filled a gap for the current node */
  int  hmm_M = cp9b->hmm_M; /* number of nodes in the model */
  int  k, kp;      /* node counters */
  int  n;          /* a temporary minimum residue position */
  int  x;          /* a temporary maximum residue position */
  int  c;          /* counter */
  int sd;          /* state delta, number of emissions for each state */
  int local_begins_ends_on; /* TRUE if HMM has local begins (M_0(B) -> M_k for k = 1..M and local ends (M_k -> E) for k = 1..M-1 */
  /*int j0_is_reachable = FALSE; */ /* TRUE if we can reach j0 for some node */
  /* ptrs to cp9b data, for convenience */
  int *pn_min_m;      /* pn_min_m[k] = first position in HMM band for match state of HMM node k */
  int *pn_max_m;      /* pn_max_m[k] = final position in HMM band for match state of HMM node k */
  int *pn_min_i;      /* pn_min_i[k] = first position in HMM band for insert state of HMM node k */
  int *pn_max_i;      /* pn_max_i[k] = final position in HMM band for insert state of HMM node k */
  int *pn_min_d;      /* pn_min_d[k] = first position in HMM band for delete state of HMM node k */
  int *pn_max_d;      /* pn_max_d[k] = final position in HMM band for delete state of HMM node k */

  if((cp9->flags & CPLAN9_LOCAL_BEGIN) && (! (cp9->flags & CPLAN9_LOCAL_END))) ESL_FAIL(eslEINCOMPAT, errbuf, "HMMBandsEnforceValidParse(), HMM has local begins ON but local ends OFF. Both must be on, or both must be off.");
  local_begins_ends_on = ((cp9->flags & CPLAN9_LOCAL_BEGIN) && (cp9->flags & CPLAN9_LOCAL_END)) ? TRUE : FALSE;

  pn_min_m = cp9b->pn_min_m;
  pn_max_m = cp9b->pn_max_m;
  pn_min_i = cp9b->pn_min_i;
  pn_max_i = cp9b->pn_max_i;
  pn_min_d = cp9b->pn_min_d;
  pn_max_d = cp9b->pn_max_d;

  /* allocate and initialize */
  ESL_ALLOC(r_mn, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_mx, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_in, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_ix, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_dn, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_dx, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nn_i, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nx_i, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nn_j, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nx_j, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nn_hmm, sizeof(int) * (hmm_M+1));
  ESL_ALLOC(r_nx_hmm, sizeof(int) * (hmm_M+1));

  for(k = 0; k <= hmm_M; k++) {
	r_mn[k] = r_in[k] = r_dn[k] = r_nn_i[k] = r_nn_j[k] = r_nn_hmm[k] = INT_MAX;
	r_mx[k] = r_ix[k] = r_dx[k] = r_nx_i[k] = r_nx_j[k] = r_nx_hmm[k] = INT_MIN;
  }
  r_begn = INT_MAX;
  r_begx = INT_MIN;
  r_endn = INT_MAX;
  r_endx = INT_MIN;

  ESL_ALLOC(was_unr,    sizeof(int) * (hmm_M+1));
  ESL_ALLOC(filled_gap, sizeof(int) * (hmm_M+1));
  esl_vec_ISet(was_unr,    (hmm_M+1), FALSE);
  esl_vec_ISet(filled_gap, (hmm_M+1), FALSE);

  /* Note on comment nomenclature:
   * M_k: match  state of node k
   * I_k: insert state of node k
   * D_k: detele state of node k
   */

  if(! doing_search) assert(pn_min_m[0] == (i0-1));
  if(pn_min_m[0] != -1) {
	r_mn[0] = pn_min_m[0]; /* initialize min reachable residue for M_0 as pn_min_m[0] */
	r_mx[0] = pn_max_m[0]; /* initialize min reachable residue for M_0 as pn_max_m[0] */
  }

  /* The main loop: for each node, for each state, determine which residues are reachable given
   * the reachable residues for the states in the previous node and current node.
   * The order is important: first we account for all transitions to the insert state of the same
   * node, as the reachable band on the insert will affect later transitions.
   * Then we do all transitions to the match of the next node, and finally to the delete of the
   * next node.
   */
  for(k = 0; k <= hmm_M; k++) {
	if(pn_min_m[k] == -1) ESL_DASSERT1((pn_max_m[k] == -1));
	if(pn_min_i[k] == -1) ESL_DASSERT1((pn_max_i[k] == -1));
	if(pn_min_d[k] == -1) ESL_DASSERT1((pn_max_d[k] == -1));
	just_filled_gap = FALSE;

	/* transitions to insert of node k (I_k) */
	if(r_mn[k] <= r_mx[k]) { /* M_k is reachable */
	  /* M_k->I_k transition */
	  if(pn_min_i[k] != -1) {
	n = r_mn[k]+1;
	x = r_mx[k]+1;
	if((ESL_MIN(x, pn_max_i[k]) - ESL_MAX(n, pn_min_i[k])) >= 0) { /* TRUE if n..x overlaps with pn_min_i[k]..pn_max_i[k] by at least 1 residue */
	  n = ESL_MAX(n, pn_min_i[k]); /* n can't be less than pn_min_i[k] */
	  n = ESL_MIN(n, pn_max_i[k]); /* n can't be more than pn_max_i[k] */
	  x = ESL_MIN(x, pn_max_i[k]); /* x can't be more than pn_max_i[k] */
	  /* no need to check if we need to fill a gap, not an issue for inserts which can self-transit and fill their own gaps */
	  r_in[k] = ESL_MIN(r_in[k], n);
	  r_ix[k] = ESL_MAX(r_ix[k], x);
	  ESL_DASSERT1((r_in[k] <= r_ix[k]));
	}
	  }
	}
	if(r_dn[k] <= r_dx[k]) {
	  /* D_k->I_k transition */
	  if(pn_min_i[k] != -1) {
	n = r_dn[k]+1;
	x = r_dx[k]+1;
	if((ESL_MIN(x, pn_max_i[k]) - ESL_MAX(n, pn_min_i[k])) >= 0) { /* TRUE if n..x overlaps with pn_min_i[k]..pn_max_i[k] by at least 1 residue */
	  n = ESL_MAX(n, pn_min_i[k]); /* n can't be less than pn_min_i[k] */
	  n = ESL_MIN(n, pn_max_i[k]); /* n can't be more than pn_max_i[k] */
	  x = ESL_MIN(x, pn_max_i[k]); /* x can't be more than pn_max_i[k] */
	  /* no need to check if we need to fill a gap, not an issue for inserts which can self-transit and fill their own gaps */
	  r_in[k] = ESL_MIN(r_in[k], n);
	  r_ix[k] = ESL_MAX(r_ix[k], x);
	  ESL_DASSERT1((r_in[k] <= r_ix[k]));
	}
	  }
	}
	if(r_in[k] <= r_ix[k]) {
	  /* I_k -> I_k transition */
	  ESL_DASSERT1((r_ix[k] <= pn_max_i[k]));
	  /* I_k->I_k   transition (first b/c self transitions are possible) */
	  if(pn_min_i[k] != -1) { /* special case, self emitter, if we can enter this INSERT state, for any valid residue, we can emit residues until we reach pn_max_i[k] */
	if(r_in[k] <= pn_max_i[k]) { /* we can reach this insert for i == r_in[k], then emit until pn_max_i[k] */
	  r_ix[k] = pn_max_i[k];
	}
	else {
	  r_in[k] = INT_MAX;
	  r_ix[k] = INT_MIN;
	}
	  }
	}
	/* done with transitions to I_k */

	/* transitions to match of node k+1 (M_k+1) */
	if(k < hmm_M) { /* state M_M+1 is special, it's the END state, we deal with that below */
	  if(r_mn[k] <= r_mx[k]) {
	/* M_k->M_k+1 transition */
	if(pn_min_m[k+1] != -1) {
	  n = r_mn[k]+1;
	  x = r_mx[k]+1;
	  if((ESL_MIN(x, pn_max_m[k+1]) - ESL_MAX(n, pn_min_m[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_m[k+1]..pn_max_m[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_m[k+1]); /* n can't be less than pn_min_m[k+1] */
	    n = ESL_MIN(n, pn_max_m[k+1]); /* n can't be more than pn_max_m[k+1] */
	    x = ESL_MIN(x, pn_max_m[k+1]); /* x can't be more than pn_max_m[k+1] */
	    if(r_mn[k+1] != INT_MAX) {
	      if(!local_begins_ends_on && ESL_MIN(x, r_mx[k+1]) - ESL_MAX(n, r_mn[k+1]) < -1) {
		/* there's a 'gap' of >= 1 residue between n..x and r_mn[k+1].._r_mx[k+1], fill the gap by expanding band of I_k */
		if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_mn[k+1], r_mx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		just_filled_gap = TRUE;
	      }
	    }
	    r_mn[k+1] = ESL_MIN(r_mn[k+1], n);
	    r_mx[k+1] = ESL_MAX(r_mx[k+1], x);
	    ESL_DASSERT1((r_mn[k+1] <= r_mx[k+1]));
	  }
	}
	  }
	  /* D_k->M_k+1 transition */
	  if(r_dn[k] <= r_dx[k]) {
	if(pn_min_m[k+1] != -1) {
	  n = r_dn[k]+1;
	  x = r_dx[k]+1;
	  if((ESL_MIN(x, pn_max_m[k+1]) - ESL_MAX(n, pn_min_m[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_m[k+1]..pn_max_m[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_m[k+1]); /* n can't be less than pn_min_m[k+1] */
	    n = ESL_MIN(n, pn_max_m[k+1]); /* n can't be more than pn_max_m[k+1] */
	    x = ESL_MIN(x, pn_max_m[k+1]); /* x can't be more than pn_max_m[k+1] */
	    if(r_mn[k+1] != INT_MAX) {
	      if(!local_begins_ends_on && ESL_MIN(x, r_mx[k+1]) - ESL_MAX(n, r_mn[k+1]) < -1) {
		/* there's a 'gap' of >= 1 residue between n..x and r_mn[k+1].._r_mx[k+1], fill the gap by expanding band of I_k */
		ESL_DASSERT1((k != 0));
		if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_mn[k+1], r_mx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		just_filled_gap = TRUE;
	      }
	    }
	    r_mn[k+1] = ESL_MIN(r_mn[k+1], n);
	    r_mx[k+1] = ESL_MAX(r_mx[k+1], x);
	    ESL_DASSERT1((r_mn[k+1] <= r_mx[k+1]));
	  }
	}
	  }
	  /* I_k->M_k+1transition */
	  if(r_in[k] <= r_ix[k]) {
	if(pn_min_m[k+1] != -1) {
	  n = r_in[k]+1;
	  x = r_ix[k]+1;
	  if((ESL_MIN(x, pn_max_m[k+1]) - ESL_MAX(n, pn_min_m[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_m[k+1]..pn_max_m[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_m[k+1]); /* n can't be less than pn_min_m[k+1] */
	    n = ESL_MIN(n, pn_max_m[k+1]); /* n can't be more than pn_max_m[k+1] */
	    x = ESL_MIN(x, pn_max_m[k+1]); /* x can't be more than pn_max_m[k+1] */
	    if(!local_begins_ends_on && ESL_MIN(x, r_mx[k+1]) - ESL_MAX(n, r_mn[k+1]) < -1) {
	      /* there's a 'gap' of >= 1 residue between n..x and r_mn[k+1].._r_mx[k+1], fill the gap by expanding band of I_k */
	      ESL_DASSERT1((k != 0));
	      if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_mn[k+1], r_mx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
	      just_filled_gap = TRUE;
	    }
	    r_mn[k+1] = ESL_MIN(r_mn[k+1], n);
	    r_mx[k+1] = ESL_MAX(r_mx[k+1], x);
	    ESL_DASSERT1((r_mn[k+1] <= r_mx[k+1]));
	  }
	}
	  }
	  /* EL_kp->M_k+1 transition, we could have come from 1 or more EL states */
	  if(cp9->flags & CPLAN9_EL) {
	if(pn_min_m[k+1] != -1) {
	  for(c = 0; c < cp9->el_from_ct[k+1]; c++) { /* el_from_ct[k+1] holds # ELs that can go to k+1 */
	    kp = cp9->el_from_idx[k+1][c];
	    if(r_mn[kp] <= r_mx[kp]) {
	      n = r_mn[kp]; /* EL's can emit 0 or more residues */
	      x = j0;       /* EL's can emit 0 or more residues */
	      if((ESL_MIN(x, pn_max_m[k+1]) - ESL_MAX(n, pn_min_m[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_m[k+1]..pn_max_m[k+1] by at least 1 residue */
		n = ESL_MAX(n, pn_min_m[k+1]); /* n can't be less than pn_min_m[k+1] */
		n = ESL_MIN(n, pn_max_m[k+1]); /* n can't be more than pn_max_m[k+1] */
		x = ESL_MIN(x, pn_max_m[k+1]); /* x can't be more than pn_max_m[k+1] */
		if(r_mn[k+1] != INT_MAX) {
		  if(!local_begins_ends_on && ESL_MIN(x, r_mx[k+1]) - ESL_MAX(n, r_mn[k+1]) < -1) {
		    /* there's a 'gap' of >= 1 residue between n..x and r_mn[k+1].._r_mx[k+1], fill the gap by expanding band of I_k */
		    ESL_DASSERT1((k != 0));
		    if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_mn[k+1], r_mx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		    just_filled_gap = TRUE;
		  }
		}
		r_mn[k+1] = ESL_MIN(r_mn[k+1], n);
		r_mx[k+1] = ESL_MAX(r_mx[k+1], x);
		ESL_DASSERT1((r_mn[k+1] <= r_mx[k+1]));
	      }
	    }
	  }
	}
	  }
	  /* Begin ->M_k+1 transition, if local begins are on, we could go B->M_k+1, this is always true if M_k+1 is reachbale and (doing_search),
	   * if we're doing alignment this is true only if the first residue is within the band on M_k+1
	   */
	  if(local_begins_ends_on) {
	if(pn_min_m[k+1] != -1) {
	  if(doing_search) {
	    n = pn_min_m[k+1];
	    x = pn_max_m[k+1];
	    r_mn[k+1] = ESL_MIN(r_mn[k+1], n);
	    r_mx[k+1] = ESL_MAX(r_mx[k+1], x);
	  }
	  else { /* doing alignment, we can only do a local begin into M_k+1 if the first residue is within it's band */
	    if(pn_min_m[k+1] == r_mn[0]+1) {
	      r_mn[k+1] = ESL_MIN(r_mn[k+1], r_mn[0]+1);
	      r_mx[k+1] = ESL_MAX(r_mx[k+1], r_mn[0]+1); /* not a typo, r_mx[0] == r_mn[0] (it's the begin state) */
	    }
	  }
	}
	  }
	} /* end of if(k < hmm_M) */
	/* transitions to END state */
	if(k == hmm_M || local_begins_ends_on) { /* handle transitions from M_k to END */
	  if(r_mn[k] <= r_mx[k] && cp9->esc[k] != -INFTY) { /* if M_k is reachable and we're allowed to transit to E */
	/* M_k->E transition */
	n = r_mn[k];
	x = r_mx[k];
	/* note: we don't have to worry about filling gaps here (that is if gap of >= 1 residue between [n..x] and [r_endn..r_endx]
	 *       because end state is last state we care about, if we can reach it for residue in n..x or r_endn..r_endx, set band to
	 *       include all those residues (min(n, r_end_n)..max(x, r_endx)) is harmless, a CM parse WILL exist for some residue in that range
	 *       and the CM will be able to find it */
	r_endn = ESL_MIN(r_endn, n);
	r_endx = ESL_MAX(r_endx, x);
	/*////printf("0 r_endn,x: %d..%d (k: %d) \n", r_endn, r_endx, k);*/
	ESL_DASSERT1((r_endn <= r_endx));
	  }
	}
	if(k == hmm_M) { /* if we're at the last node, we could also get to END from D_k, or I_k */
	  if(r_dn[k] <= r_dx[k] && cp9->tsc[CTDM][k] != -INFTY) { /* if D_k is reachable and we're allowed to transit to E */
	/* D_M->E transition */
	n = r_dn[k];
	x = r_dx[k];
	/* note: we don't have to worry about filling gaps here (see more verbose comment above for M_k->E transition) */
	r_endn = ESL_MIN(r_endn, n);
	r_endx = ESL_MAX(r_endx, x);
	/*////printf("1 r_endn,x: %d..%d\n", r_endn, r_endx);*/
	ESL_DASSERT1((r_endn <= r_endx));
	  }
	  if(r_in[k] <= r_ix[k] && cp9->tsc[CTIM][k] != -INFTY) { /* if I_k is reachable and we're allowed to transit to E */
	/* I_M->E transition */
	n = r_in[k];
	x = r_in[k];
	/* note: we don't have to worry about filling gaps here (see more verbose comment above for M_k->E transition) */
	r_endn = ESL_MIN(r_endn, n);
	r_endx = ESL_MAX(r_endx, x);
	/*////printf("2 r_endn,x: %d..%d\n", r_endn, r_endx);*/
	ESL_DASSERT1((r_endn <= r_endx));
	  }
	  /* finally, deal with the possibility that we go to E from an EL state */
	  if(cp9->flags & CMH_LOCAL_END) {
	for(c = 0; c < cp9->el_from_ct[k+1]; c++) { /* el_from_ct[k+1] holds # ELs that can go to k+1 */
	  kp = cp9->el_from_idx[k+1][c];
	  if(r_mn[kp] <= r_mx[kp]) {
	    n = r_mn[kp]; /* EL's can emit 0 or more residues */
	    x = j0;
	    r_endn = ESL_MIN(r_endn, n);
	    r_endx = ESL_MAX(r_endx, x);
	    /*////printf("3 c: %d..%d r_endn: %d\n", c, r_endn, r_endx);*/
	    ESL_DASSERT1((r_endn <= r_endx));
	  }
	}
	  }
	} /* end of if k == hmm_M, done with transitions to match of node k+1 */

	/* transitions to delete of node k+1 (D_k+1)*/
	if(k < hmm_M) {
	  /* M_k -> D_k+1 transition */
	  if(r_mn[k] <= r_mx[k]) {
	if(pn_min_d[k+1] != -1) {
	  n = r_mn[k];
	  x = r_mx[k];
	  if((ESL_MIN(x, pn_max_d[k+1]) - ESL_MAX(n, pn_min_d[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_d[k+1]..pn_max_d[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_d[k+1]); /* n can't be less than pn_min_d[k+1] */
	    n = ESL_MIN(n, pn_max_d[k+1]); /* n can't be more than pn_max_d[k+1] */
	    x = ESL_MIN(x, pn_max_d[k+1]); /* x can't be more than pn_max_d[k+1] */
	    if(r_dn[k+1] != INT_MAX) {
	      if(!local_begins_ends_on && ESL_MIN(x, r_dx[k+1]) - ESL_MAX(n, r_dn[k+1]) < -1) {
		/* there's a 'gap' of >= 1 residue between n..x and r_dn[k+1].._r_dx[k+1], fill the gap by expanding band of I_k */
		ESL_DASSERT1((k != 0));
		if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_dn[k+1], r_dx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		just_filled_gap = TRUE;
	      }
	    }
	    r_dn[k+1] = ESL_MIN(r_dn[k+1], n);
	    r_dx[k+1] = ESL_MAX(r_dx[k+1], x);
	    ESL_DASSERT1((r_dn[k+1] <= r_dx[k+1]));
	  }
	}
	  }
	  /* I_k -> D_k+1 transition */
	  if(r_in[k] <= r_ix[k]) {
	/* I_k->D_k+1 transition */
	if(pn_min_d[k+1] != -1) {
	  n = r_in[k];
	  x = r_ix[k];
	  if((ESL_MIN(x, pn_max_d[k+1]) - ESL_MAX(n, pn_min_d[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_d[k+1]..pn_max_d[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_d[k+1]); /* n can't be less than pn_min_d[k+1] */
	    n = ESL_MIN(n, pn_max_d[k+1]); /* n can't be more than pn_max_d[k+1] */
	    x = ESL_MIN(x, pn_max_d[k+1]); /* x can't be more than pn_max_d[k+1] */
	    if(r_dn[k+1] != INT_MAX) {
	      if(!local_begins_ends_on && ESL_MIN(x, r_dx[k+1]) - ESL_MAX(n, r_dn[k+1]) < -1) {
		/* there's a 'gap' of >= 1 residue between n..x and r_dn[k+1].._r_dx[k+1], fill the gap by expanding band of I_k */
		ESL_DASSERT1((k != 0));
		if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_dn[k+1], r_dx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		just_filled_gap = TRUE;
	      }
	    }
	    r_dn[k+1] = ESL_MIN(r_dn[k+1], n);
	    r_dx[k+1] = ESL_MAX(r_dx[k+1], x);
	    ESL_DASSERT1((r_dn[k+1] <= r_dx[k+1]));
	  }
	}
	  }
	  /* D_k -> D_k+1 */
	  if(r_dn[k] <= r_dx[k]) {
	if(pn_min_d[k+1] != -1) {
	  n = r_dn[k];
	  x = r_dx[k];
	  if((ESL_MIN(x, pn_max_d[k+1]) - ESL_MAX(n, pn_min_d[k+1])) >= 0) { /* TRUE if n..x overlaps with pn_min_d[k+1]..pn_max_d[k+1] by at least 1 residue */
	    n = ESL_MAX(n, pn_min_d[k+1]); /* n can't be less than pn_min_d[k+1] */
	    n = ESL_MIN(n, pn_max_d[k+1]); /* n can't be more than pn_max_d[k+1] */
	    x = ESL_MIN(x, pn_max_d[k+1]); /* x can't be more than pn_max_d[k+1] */
	    if(r_dn[k+1] != INT_MAX) {
	      if(!local_begins_ends_on && ESL_MIN(x, r_dx[k+1]) - ESL_MAX(n, r_dn[k+1]) < -1) { /* FALSE if n..x overlaps with r_mn[k+1].._r_mx[k+1] by at least 1 residue, if FAILs we have to pick to either NOT change r_mn, r_mx, or change them to n and x */
		ESL_DASSERT1((k != 0));
		if((status = HMMBandsFillGap(cp9b, errbuf, k, n, x, r_dn[k+1], r_dx[k+1], r_mn[k-1], r_dn[k-1])) != eslOK) return status;
		just_filled_gap = TRUE;
	      }
	    }
	    r_dn[k+1] = ESL_MIN(r_dn[k+1], n);
	    r_dx[k+1] = ESL_MAX(r_dx[k+1], x);
	    ESL_DASSERT1((r_dn[k+1] <= r_dx[k+1]));
	  }
	}
	  }
	}

	/* update the reachable-by-node bands, which residues can we reach this node for?
	 * inside the following if's we don't have to check if r_*n[k], r_*x[k] == INT_MAX or
	 * INT_MIN, b/c we only enter the ifs if r_*n[k] <= r_*x[k]
	 */
	if(r_mn[k] <= r_mx[k]) { /* M_k is reachable for i = r_mn[k]..r_mx[k] */
	  r_nn_hmm[k] = ESL_MIN(r_nn_hmm[k], r_mn[k]);
	  r_nx_hmm[k] = ESL_MAX(r_nx_hmm[k], r_mx[k]);

	  sd = 1;
	  if(k != hmm_M) {
	r_nn_i[k+1] = ESL_MIN(r_nn_i[k+1], r_mn[k]+sd);
	r_nx_i[k+1] = ESL_MAX(r_nx_i[k+1], r_mx[k]+sd);
	  }
	  if(k != 0) {
	r_nn_j[k-1] = ESL_MIN(r_nn_j[k-1], r_mn[k]-sd);
	r_nx_j[k-1] = ESL_MAX(r_nx_j[k-1], r_mx[k]-sd);
	  }
	  if((local_begins_ends_on && k > 0) || k == hmm_M) { /* we can go to end from M_k with i from r_mn[k]..r_mx[k] */
	if(doing_search) {
	  r_nn_j[k] = ESL_MIN(r_nn_j[k], r_mn[k]);
	  r_nx_j[k] = ESL_MAX(r_nx_j[k], r_mx[k]);
	}
	else { /* have to emit j0 from last match state visited */
	  if(r_mx[k] == j0) {
	    r_nn_j[k] = ESL_MIN(r_nn_j[k], j0);
	    r_nx_j[k] = ESL_MAX(r_nx_j[k], j0);
	  }
	}
	  }
	  if((local_begins_ends_on && k > 0) || k == 1) { /* we can go from begin to M_k with i to r_mn[k]..r_mx[k] */
	if(doing_search) {
	  r_nn_i[k] = ESL_MIN(r_nn_i[k], r_mn[k]);
	  r_nx_i[k] = ESL_MAX(r_nx_i[k], r_mx[k]);
	  /* superfluous */
	  r_begn = ESL_MIN(r_begn, r_mn[k]);
	  r_begx = ESL_MAX(r_begx, r_mx[k]);
	}
	else { /* have to emit i0 from first match state entered */
	  if(r_mn[k] == i0) {
	    r_nn_i[k] = ESL_MIN(r_nn_i[k], i0);
	    r_nx_i[k] = ESL_MAX(r_nx_i[k], i0);
	  }
	}
	  }
	}
	if(r_in[k] <= r_ix[k]) { /* I_k is reachable for i = r_in[k]..r_ix[k] */
	  r_nn_hmm[k] = ESL_MIN(r_nn_hmm[k], r_in[k]);
	  r_nx_hmm[k] = ESL_MAX(r_nx_hmm[k], r_ix[k]);

	  sd = 1;
	  if(k != hmm_M) {
	r_nn_i[k+1] = ESL_MIN(r_nn_i[k+1], r_in[k]+sd);
	r_nx_i[k+1] = ESL_MAX(r_nx_i[k+1], r_ix[k]+sd);
	  }
	  r_nn_j[k] = ESL_MIN(r_nn_j[k], r_in[k]-sd);
	  r_nx_j[k] = ESL_MAX(r_nx_j[k], r_ix[k]-sd);

	  /* superfluous */
	  if(k == 0) {
	r_begn = ESL_MIN(r_begn, r_in[k]);
	r_begx = ESL_MAX(r_begx, r_ix[k]);
	  }
	}
	if(r_dn[k] <= r_dx[k]) { /* D_k is reachable for i = r_dn[k]..r_dx[k] */
	  r_nn_hmm[k] = ESL_MIN(r_nn_hmm[k], r_dn[k]);
	  r_nx_hmm[k] = ESL_MAX(r_nx_hmm[k], r_dx[k]);

	  sd = 0;
	  if(k != hmm_M) {
	r_nn_i[k+1] = ESL_MIN(r_nn_i[k+1], r_dn[k]+1); /* off-by-one */
	r_nx_i[k+1] = ESL_MAX(r_nx_i[k+1], r_dx[k]+1); /* off-by-one */
	  }
	  if(k != 0) {
	r_nn_j[k-1] = ESL_MIN(r_nn_j[k-1], r_dn[k]);
	r_nx_j[k-1] = ESL_MAX(r_nx_j[k-1], r_dx[k]);
	  }
	  if(k == 1) {
	r_begn = ESL_MIN(r_begn, r_dn[k]+1);
	r_begx = ESL_MAX(r_begx, r_dx[k]+1);
	  }
	}
	/* is the node reachable? (it doesn't matter if we're in local mode) */
	if((!local_begins_ends_on) && (r_mn[k] > r_mx[k]) && (r_dn[k] > r_dx[k])) {
	  assert(k != 0);
	  ESL_DASSERT1((just_filled_gap == FALSE));
	  ESL_DPRINTF1(("! HMM node %d is unreachable hmm!\n", k));
	  if(was_unr[k]) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "HMMBandsEnforceValidParse() node k %d was determined unreachable in second pass! Shouldn't happen (coding error).\n", k);
	  was_unr[k] = TRUE;
	  /* expand the bands so k becomes reachable, using a greedy technique */
	  if((status = HMMBandsFixUnreachable(cp9b, errbuf, k, r_nn_hmm[k-1], r_nx_hmm[k-1], r_in[k-1])) != eslOK) return status;
	  /* to ensure we can now reach node k, we simply decrement k by 2, then
	   * we'll reenter the loop above for k=k-1, and check if k is reachable with
	   * new band on I_k-1. This is unnecessary if the code is right, used here just
	   * to check.
	   */
	  k -= 2;
	}
	else if(just_filled_gap == TRUE) {
	  ESL_DPRINTF1(("! HMM node %d filled a gap!\n", k));
	  if(filled_gap[k] == TRUE) ESL_FAIL(eslEINCONCEIVABLE, errbuf, "HMMBandsEnforceValidParse() node k %d needed a gap filled in second pass! Shouldn't happen (coding error).\n", k);
	  filled_gap[k] = TRUE;
	  /* to ensure we can now reach node k, we simply decrement k by 2, then
	   * we'll reenter the loop above for k=k, and check if k is reachable with
	   * new band on I_k. This is unnecessary if the code is right, used here just
	   * to check.
	   */
	  k -= 1;
	}
	/*else if(r_nx_hmm[k] == j0) j0_is_reachable = TRUE;*/
  }
  /* final check, if we're doing alignment, the first residue i0, must be first emitted
   * residue, and the final residue, j0 must be final emittable residue. Enforce it.
   */
  if(! doing_search) {
	r_begn = i0;
	r_begx = i0;
	r_endn = j0;
	r_endx = j0;
  }

  /* A hack! set r_nn_j[hmm_M] to rend_n and r_nx_j[hmm_M] to rend_x, b/c we
   * only use r_nn_j[hmm_M] and r_nx_j[hmm_M] to set j bands on states of non-right
   * emitting CM nodes (non-MATR MATP nodes) and we need the ones above all non
   * emitters (where rpos == hmm_M) to have the j bands equal to the band on the
   * HMM END state. This is a hack b/c there should be a band on the E state itself,
   * which should map to right half of ROOT_S, but I didn't implement it that way.
   */
  r_nn_i[1]     = ESL_MIN(r_nn_i[1], r_begn);
  r_nx_i[1]     = ESL_MAX(r_nx_i[1], r_begx);
  r_nn_j[hmm_M] = ESL_MIN(r_nn_j[hmm_M], r_endn);
  r_nx_j[hmm_M] = ESL_MAX(r_nx_j[hmm_M], r_endx);

  for(k = 0; k <= hmm_M; k++) {
	if(r_mn[k]  == INT_MAX) r_mn[k] = -1;
	if(r_mx[k]  == INT_MIN) r_mx[k] = -2;
	if(r_in[k]  == INT_MAX) r_in[k] = -1;
	if(r_ix[k]  == INT_MIN) r_ix[k] = -2;
	if(r_dn[k]  == INT_MAX) r_dn[k] = -1;
	if(r_dx[k]  == INT_MIN) r_dx[k] = -2;

	if(!local_begins_ends_on) {
	  ESL_DASSERT1((r_nn_i[k]  != INT_MAX || k == 0));
	  ESL_DASSERT1((r_nx_i[k]  != INT_MIN || k == 0));
	  ESL_DASSERT1((r_nn_j[k]  != INT_MAX));
	  ESL_DASSERT1((r_nx_j[k]  != INT_MIN));
	}
	else {
	  if(r_nn_i[k]  == INT_MAX) r_nn_i[k] = -1;
	  if(r_nx_i[k]  == INT_MIN) r_nx_i[k] = -2;
	  if(r_nn_j[k]  == INT_MAX) r_nn_j[k] = -1;
	  if(r_nx_j[k]  == INT_MIN) r_nx_j[k] = -2;
	}
  }

  *ret_r_mn = r_mn;
  *ret_r_mx = r_mx;
  *ret_r_in = r_in;
  *ret_r_ix = r_ix;
  *ret_r_dn = r_dn;
  *ret_r_dx = r_dx;
  *ret_r_nn_i = r_nn_i;
  *ret_r_nx_i = r_nx_i;
  *ret_r_nn_j = r_nn_j;
  *ret_r_nx_j = r_nx_j;
  free(was_unr);
  free(filled_gap);
  free(r_nn_hmm);
  free(r_nx_hmm);

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "HMMBandsEnforceValidParse(): memory allocation error.");
  return eslOK; /* neverreached */
}

/* Function: HMMBandsFixUnreachable()
 * Incept:   EPN, Fri Feb  1 17:12:55 2008
 *
 * Purpose:  Expand the HMM bands such that a parse becomes
 *           possible up through node <k>. We know that a parse
 *           is possible up through node <k-1>, the reachable
 *           range of residues for all possible parses up to
 *           node <k-1> is from <r_prv_min> to <r_prv_max>.
 *
 *           Note: The technique used for expanding the bands was
 *           selected for it's *relative* simplicity. It does not
 *           expand the bands in any smart way that is aware of
 *           probability mass or score of the newly possible parses
 *           during the band expansion. You could try to do that,
 *           but I don't think it's worth it. This function is only
 *           entered if the default bands (prior to expansion)
 *           do not allow a single parse, in which case the bands are
 *           too tight, and the smart solution is to lower tau,
 *           the tail loss parameter. In other words this function is
 *           only very rarely used for reasonable values of tau
 *           ('reasonable' determined from empirical expts, and
 *             enforced by getopts). This function is necessary
 *           for the HMM banding technique to be robust though,
 *           otherwise it's possible that the HMM bands make all
 *           parses impossible, which is bad, because that means
 *           all CM parses are impossible too.
 *
 *           There are two possible scenarios for why node k
 *           is unreachable, each with a different solution
 *           this function determines which scenario node k is
 *           in and then fixes it. The scenarios are described
 *           in comments in the code below.a
 *
 * Args:     cp9b      - the CP9 bands object
 *           errbuf    - for error messages
 *           k         - the node we want to make reachable
 *           r_prv_min - minimal possible residue index accounted for in any parse up to and including node k-1
 *           r_prv_max - maximal possible residue index accounted for in any parse up to and including node k-1
 *           r_insert_prv_min - minimal possible residue index accounted for in any parse up to and state I_k-1
 *
 * Returns:  eslOK on success
 *           eslEMEM if a memory allocation error occurs
 */
int
HMMBandsFixUnreachable(CP9Bands_t *cp9b, char *errbuf, int k, int r_prv_min, int r_prv_max, int r_insert_prv_min)
{

  int kp;    /* k prime, a node counter */
  int nxt_m; /* minimal possible residue index we must account for before entering M_k */
  int nxt_d; /* minimal possible residue index we must account for before entering D_k */
  int nxt_n; /* minimal possible residue index we must account for before entering either M_k or D_k */

  ESL_DASSERT1((k != 0));
  ESL_DASSERT1((r_prv_min !=  INT_MAX));
  ESL_DASSERT1((r_prv_max != INT_MIN));
  ESL_DASSERT1((r_prv_min <= r_prv_max));

  /* scenario 1: there's a 'hole' of at least 1 residue between the residue posns that can be reached
   *             for node k-1 (these are r_prv_min..r_prv_max) and by node k's match or delete state.
   *             our solution is to allow the I_k-1 (node k-1 insert state) to emit the residues in
   *             the 'hole', then we know we can reach either node k's match or delete.
   */
  /* check if we're in scenario 1 */

  /* initialize, if neither nxt_m nor nxt_d doesn't change, we know we're not in scenario 1 */
  nxt_m = -1;
  nxt_d = -1;
  if(cp9b->pn_min_m[k] != -1 && cp9b->pn_max_m[k] != -1) {
	ESL_DASSERT1((cp9b->pn_max_m[k] >= cp9b->pn_min_m[k]));
	if(cp9b->pn_max_m[k]-1 > r_prv_min) { /* if we go from I_k-1 to M_k, we have to emit 1 residue from M_k, that's
				     * why we have cp9b->pn_max_m[k]-1 (i.e. the -1 is for the StateDelta) */
	  nxt_m = ESL_MAX(cp9b->pn_min_m[k]-1, r_prv_min); /* we could get from node k-1 to node k's match state by using I_k-1 to fill the 'hole' */
	}
  }
  if(cp9b->pn_min_d[k] != -1 && cp9b->pn_max_d[k] != -1) {
	ESL_DASSERT1((cp9b->pn_max_d[k] >= cp9b->pn_min_d[k]));
	if(cp9b->pn_max_d[k] > r_prv_min) { /* if we go from I_k-1 to D_k, we don't emit from D_k so there's no -1 as above with M_k */
	  nxt_d = ESL_MAX(cp9b->pn_min_d[k], r_prv_min);/* we could get from node k-1 to node k's delete state by using I_k-1 to fill the 'hole' */
	}
  }
  if(nxt_m != -1 || nxt_d != -1) {
	/* we're in scenario 1, there's a 'hole' of missing residues we have to account for before entering node k,
	 * determine the easier route, to M_k or D_k?  (pick route with less required I_k-1 emissions)  */
	if      (nxt_m == -1) nxt_n = nxt_d;
	else if (nxt_d == -1) nxt_n = nxt_m;
	else                  nxt_n = ESL_MIN(nxt_m, nxt_d);

	/* now doctor I_k-1's bands so that:
	 * (a) I_k-1 is reachable from at least one of M_k-1, D_k-1
	 * (b) I_k-1 can transit to M_k or D_k
	 */
	if(cp9b->pn_min_i[k-1] != -1) cp9b->pn_min_i[k-1] = ESL_MIN(cp9b->pn_min_i[k-1], r_prv_min+1);
	else                          cp9b->pn_min_i[k-1] = r_prv_min+1;
	if(cp9b->pn_max_i[k-1] != -1) cp9b->pn_max_i[k-1] = ESL_MAX(cp9b->pn_max_i[k-1], nxt_n);
	else                          cp9b->pn_max_i[k-1] = nxt_n;
	ESL_DASSERT1((cp9b->pn_max_i[k-1] >= cp9b->pn_min_i[k-1]));
	ESL_DPRINTF1(("scenario 1 reset k from %d to %d\n", k+2, k));
  }
  else {
	/* scenario 2: the opposite of scenario 1. All possible parses that reach node k-1 have already emitted too many
	 *             residues to reach node k. In other words, the maximal residue in the HMM band on node k's match
	 *             and delete states has been already been emitted by all possible parses that end at node k-1.
	 *             We have to use the delete states of nodes k...kp, where kp is the leftmost node that we can reach
	 *             M_kp and emit residue i==r_prv_min+1 or visit D_kp with i == r_prv_min.
	 */
	kp = k;
	while(kp <= cp9b->hmm_M && ((cp9b->pn_max_m[kp] < (r_prv_min+1)) && (cp9b->pn_max_d[kp] < (r_prv_min)))) { /* note cp9b->pn_max_{m,d}[kp] may be == -1, that's okay */
	  cp9b->pn_min_d[kp] = cp9b->pn_max_d[kp] = r_prv_min; /* enforce this delete state is used */
	  kp++;
	}
	ESL_DPRINTF1(("scenario 2 reset k from %d to %d (kp: %d r_prv_min: %d (+1=%d for match))\n", k, k-2, kp, r_prv_min, r_prv_min+1));
  }
  return eslOK;
}

/* Function: HMMBandsFillGap()
 * Incept:   EPN, Fri Feb  1 17:12:55 2008
 *
 * Purpose:  In HMMBandsEnforceValidParse() it's possible (but rare) that two
 *           different transitions to the same state imply reachable bands that have
 *           a 'gap' in the middle. For example if node D_3 can reach node M_4 with
 *           i = 3 or 4, and node M_3 can reach node M_4 with i equal to 6 or 7.
 *           This means that node M_4 cannot be reached for
 *           i == 5, but the HMMBandsEnforceValidParse() implementation is
 *           much easier if we can just set the reachable band for M_4 to
 *           3..7. So, that's what we do, and we doctor the band of I_3 so
 *           that M_4 *can* be reached for i == 5. This band doctoring is
 *           done in this function.
 *
 * Args:     cp9b - the CP9 bands object
 *           errbuf - for error messages
 *           k    - the node we want to make reachable
 *           min1 - min in the reachable band for first of the two relevant transitions
 *           max1 - max in the reachable band for first of the two relevant transitions
 *           min2 - min in the reachable band for second of the two relevant transitions
 *           max2 - max in the reachable band for second of the two relevant transitions
 *           prv_nd_r_mn - min residue posn in reachable band of M_k-1, -1 if M_k-1 is unreachable
 *           prv_nd_r_dn - min residue posn in reachable band of D_k-1, -1 if D_k-1 is unreachable
 *
 * Returns:  eslOK on success
 */
int
HMMBandsFillGap(CP9Bands_t *cp9b, char *errbuf, int k, int min1, int max1, int min2, int max2, int prv_nd_r_mn, int prv_nd_r_dn)
{
  int left_min, left_max;    /* min1/max1 if min1 <= min2, else min2/max2 */
  int right_min, right_max;  /* min2/max2 if min1 <= min2, else min1/max1 */
  int in, ix;                /* min/max residue for I_k, calc'ed here */

  ESL_DASSERT1((k != 0));
  ESL_DASSERT1((max1 >= min1));
  ESL_DASSERT1((max2 >= min2));

  if(min1 <= min2) {
	left_min = min1;
	left_max = max1;
	right_min = min2;
	right_max = max2;
  }
  else {
	left_min = min2;
	left_max = max2;
	right_min = min1;
	right_max = max1;
  }
  ESL_DASSERT1((right_min - left_max > 1));

  /* determine in and ix */
  in = INT_MAX;
  if(prv_nd_r_mn != INT_MAX) in = ESL_MIN(in, prv_nd_r_mn+1);
  if(prv_nd_r_dn != INT_MAX) in = ESL_MIN(in, prv_nd_r_dn);
  ESL_DASSERT1((in != INT_MAX));
  assert(in != INT_MAX);
  ix = right_min-1;

  /* doctor I_k's bands so that it:
   * (a) I_k is reachable from at M_k or D_k (whichever has leftmost reachable band)
   * (b) I_k can transit to M_k+1 or D_k+1   (whichever has rightmost reachable band)
   */
  if(cp9b->pn_min_i[k] != -1) cp9b->pn_min_i[k] = ESL_MIN(cp9b->pn_min_i[k], in);
  else                        cp9b->pn_min_i[k] = in;
  if(cp9b->pn_max_i[k] != -1) cp9b->pn_max_i[k] = ESL_MAX(cp9b->pn_max_i[k], ix);
  else                        cp9b->pn_max_i[k] = ix;
  assert(cp9b->pn_min_i[k] <= cp9b->pn_max_i[k]);
  ESL_DASSERT1((cp9b->pn_min_i[k] <= cp9b->pn_max_i[k]));

  return eslOK;
}

#if eslDEBUGLEVEL >= 1
/* Function: CMBandsCheckValidParse()
 * Incept:   EPN, Tue Feb  5 07:59:48 2008
 *
 * Purpose:  Given bands on CM states for a target sequence,
 *           check for a valid CM parse within those bands.
 *           Return eslFAIL if there is no valid parse.
 *
 * Args:     cm     - the model
 *           cp9b   - the CP9 bands object
 *           errbuf - for error messages
 *           i0     - first residue we're concerned with in target sequence
 *           j0     - final residue we're concerned with in target sequence
 *           doing_search - TRUE if we're searching, and a local hit is okay,
 *                          if FALSE, the full sequence i0..j0 must be in the subtree of ROOT_S
 *
 * Returns:  eslOK on success
 *           eslEINCOMPAT if contract is violated
 *           eslFAIL if no valid parse exists within the i and j bands
 *           eslEMEM if a memory allocation error occurs
 */
int
CMBandsCheckValidParse(CM_t *cm, CP9Bands_t *cp9b, char *errbuf, int i0, int j0, int doing_search)
{
  int status;                 /* easel status code */
  int v, w, y;                /* state indices */
  int nd;                     /* nd counter */
  int sd, sdl, sdr;           /* state deltas, number of residues emitted by current state, total, to the left, and to the right */
  int *imin, *imax;           /* [0..v..M-1] i band for state v, min/max i position allowed for state v */
  int *jmin, *jmax;           /* [0..v..M-1] j band for state v, min/max j position allowed for state v */
  int child_imin, child_imax; /* imin, imax for child of current state, after accouting for emissions (state deltas) */
  int child_jmin, child_jmax; /* jmin, jmax for child of current state, after accouting for emissions (state deltas) */
  int *v_is_r;                /* [0..v..M-1] TRUE if state v is reachable for at least one i,j pair */
  int *nd_is_r;               /* [0..nd..cm->nodes-1] TRUE if any state (incl. insert) in node nd is reachable for at least one i,j pair */
  int *r_imin, *r_imax;       /* [0..v..M-1] reachable i bands, for which i positions can we reach state v */
  int *r_jmin, *r_jmax;       /* [0..v..M-1] reachable j bands, for which j positions can we reach state v */
  int *nd_r_imin, *nd_r_imax; /* [0..nd..M-1] reachable i bands, for which i positions can we reach at least 1 state (incl. insert) in nd */
  int *nd_r_jmin, *nd_r_jmax; /* [0..nd..M-1] reachable j bands, for which j positions can we reach at least 1 state (incl. insert) in nd */
  int y_nd, w_nd;             /* node index */
  int cm_is_localized;        /* TRUE if local begins and ends are on, if we can reach a state v with a non-impossible endsc[v], we can finish the parse for any i,j reachable for v */

  /*printf("TEMP in CMBandsCheckValidParse() i0: %d j0: %d\n", i0, j0);*/

  if((cm->flags & CMH_LOCAL_BEGIN) && (! (cm->flags & CMH_LOCAL_END))) ESL_FAIL(eslEINCOMPAT, errbuf, "CMBandsCheckValidParse(), cm flag CMH_LOCAL_BEGIN is up and cm flag CMH_LOCAL_END is down. This is unexpected, we can't deal.");
  if((! (cm->flags & CMH_LOCAL_BEGIN)) && ((cm->flags & CMH_LOCAL_END))) ESL_FAIL(eslEINCOMPAT, errbuf, "CMBandsCheckValidParse(), cm flag CMH_LOCAL_BEGIN is down and cm flag CMH_LOCAL_END is up. This is unexpected, we can't deal.");

  cm_is_localized = ((cm->flags & CMH_LOCAL_BEGIN) && (cm->flags & CMH_LOCAL_END)) ? TRUE : FALSE;

  /* pointers to cp9b arrays, for convenience */
  imin     = cp9b->imin;
  imax     = cp9b->imax;
  jmin     = cp9b->jmin;
  jmax     = cp9b->jmax;

  /* allocate and initialize */
  ESL_ALLOC(v_is_r,    sizeof(int) * cm->M);
  ESL_ALLOC(r_imin,    sizeof(int) * cm->M);
  ESL_ALLOC(r_imax,    sizeof(int) * cm->M);
  ESL_ALLOC(r_jmin,    sizeof(int) * cm->M);
  ESL_ALLOC(r_jmax,    sizeof(int) * cm->M);
  ESL_ALLOC(nd_is_r,   sizeof(int) * cm->nodes);
  ESL_ALLOC(nd_r_imin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nd_r_imax, sizeof(int) * cm->nodes);
  ESL_ALLOC(nd_r_jmin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nd_r_jmax, sizeof(int) * cm->nodes);

  esl_vec_ISet(v_is_r, cm->M, FALSE);
  esl_vec_ISet(nd_is_r, cm->nodes, FALSE);

  for (v = 0; v < cm->M; v++) {
	r_imin[v] = INT_MAX;
	r_imax[v] = INT_MIN;
	r_jmin[v] = INT_MAX;
	r_jmax[v] = INT_MIN;
  }
  for (nd = 0; nd < cm->nodes; nd++) {
	nd_r_imin[nd] = INT_MAX;
	nd_r_imax[nd] = INT_MIN;
	nd_r_jmin[nd] = INT_MAX;
	nd_r_jmax[nd] = INT_MIN;
  }

  nd_is_r[0] = TRUE;
  v_is_r[0]  = TRUE;
  r_imin[0] = nd_r_imin[0] = imin[0];
  r_imax[0] = nd_r_imax[0] = imax[0];
  r_jmin[0] = nd_r_jmin[0] = jmin[0];
  r_jmax[0] = nd_r_jmax[0] = jmax[0];

  if(! doing_search) { /* we're aligning the full sequence from i0..j0, that means imin[0] must == i0 and jmax[0] must == j0, if not we can't align the full seq */
	if(imin[0] != i0) ESL_FAIL(eslFAIL, errbuf, "CMBandsCheckValidParse(), doing_search is FALSE, but imin[0] == %d, it should be i0 (%d)\n", imin[0], i0);
	if(jmax[0] != j0) ESL_FAIL(eslFAIL, errbuf, "CMBandsCheckValidParse(), doing_search is FALSE, but jmax[0] == %d, it should be j0 (%d)\n", jmax[0], j0);
  }

  /* deal with local begins, if they're active, we can jump into any local begin state with:
   * i within imin[0]..imax[0] and j within jmin[0]..jmax[0], as long as i,j are within
   * imin[v]..imax[v] and jmin[v]..jmax[v].
   */
  if(cm->flags & CMH_LOCAL_BEGIN) {
	for(v = 0; v < cm->M; v++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[v])) {
	if(imin[v] != -1 && jmin[v] != -1) {
	  if(((ESL_MIN(imax[v], imax[0]) - ESL_MAX(imin[v], imin[0])) >= 0) && /* TRUE if imin[v]..imax[v] overlaps with imin[0]..imax[0] by at least 1 residue */
	     ((ESL_MIN(jmax[v], jmax[0]) - ESL_MAX(jmin[v], jmin[0])) >= 0)) {  /* TRUE if jmin[v]..jmax[v] overlaps with jmin[0]..jmax[0] by at least 1 residue */
	    r_imin[v] = ESL_MAX(imin[v], imin[0]);
	    r_imax[v] = ESL_MIN(imax[v], imax[0]);
	    r_jmin[v] = ESL_MAX(jmin[v], jmin[0]);
	    r_jmax[v] = ESL_MIN(jmax[v], jmax[0]);
	    v_is_r[v]  = TRUE;
	    nd_is_r[cm->ndidx[v]] = TRUE;
	  }
	}
	ESL_DASSERT1(((cm->stid[v] == MATP_MP) || (cm->stid[v] == MATR_MR) || (cm->stid[v] == MATL_ML) || (cm->stid[v] == BIF_B)));
	assert((cm->stid[v] == MATP_MP) || (cm->stid[v] == MATR_MR) || (cm->stid[v] == MATL_ML) || (cm->stid[v] == BIF_B));
	  }
	}
  }

  /* The main loop: step through the CM, node by node, state by state,
   * for reachable-states v, determine which i,j residues are reachable for each child state of v
   */
  for (nd = 0; nd < cm->nodes; nd++) {
	for (v = cm->nodemap[nd]; v < (cm->nodemap[nd] + TotalStatesInNode(cm->ndtype[nd])); v++) {
	  if(! StateIsDetached(cm, v)) {
	if(cm->sttype[v] == E_st) {
	  if((r_imin[v] <= r_imax[v] && r_jmin[v] <= r_jmax[v]) && ((r_imax[v] - r_jmin[v] - 1) >= 0)) {
	    /* END state v is reachable for some i, j such that j-i+1 = d = 0 (which is required for E states) */
	    v_is_r[v] = TRUE;
	    nd_is_r[nd] = TRUE;
	  }
	}
	else if (cm->sttype[v] == B_st) {
	  /* same loop as if v != B_st, (the else case below) but we know sdl = sdr = 0, and we have two children BEGL_S and BEGR_S */
	  if((r_imin[v] <= r_imax[v] && r_jmin[v] <= r_jmax[v]) && ((r_jmax[v] - r_imin[v] + 1) >= sd)) {
	    /* v is reachable for some i, j */
	    v_is_r[v] = TRUE;
	    nd_is_r[nd] = TRUE;
	    w = cm->cfirst[v]; /* BEGL_S */
	    y = cm->cnum[v];   /* BEGR_S */

	    /* only way to get to a BEGL_S is through it's BIF parent, even with local begins (no local begin in BEGL_S) */
	    r_imin[w] = ESL_MAX(imin[w], imin[v]);
	    r_imax[w] = ESL_MIN(imax[w], imax[v]);
	    r_jmin[w] = jmin[w];
	    r_jmax[w] = jmax[w];
	    w_nd = cm->ndidx[w];
	    nd_r_imin[w_nd] = r_imin[w];
	    nd_r_imax[w_nd] = r_imax[w];
	    nd_r_jmin[w_nd] = r_jmin[w];
	    nd_r_jmax[w_nd] = r_jmax[w];

	    /* only way to get to a BEGR_S is through it's BIF parent, even with local begins (no local begin in BEGR_S) */
	    r_imin[y] = imin[y];
	    r_imax[y] = imax[y];
	    r_jmin[y] = ESL_MAX(jmin[y], jmin[v]);
	    r_jmax[y] = ESL_MIN(jmax[y], jmax[v]);
	    y_nd = cm->ndidx[y];
	    nd_r_imin[y_nd] = r_imin[y];
	    nd_r_imax[y_nd] = r_imax[y];
	    nd_r_jmin[y_nd] = r_jmin[y];
	    nd_r_jmax[y_nd] = r_jmax[y];
	  }
	}
	else { /* state is not a B_st nor an E_st */
	  sdl = StateLeftDelta(cm->sttype[v]);
	  sdr = StateRightDelta(cm->sttype[v]);
	  sd  = sdl + sdr;

	  if((r_imin[v] <= r_imax[v] && r_jmin[v] <= r_jmax[v]) && ((r_jmax[v] - r_imin[v] + 1) >= sd)) {
	    /* v is reachable for some i, j */
	    ///if(NOT_IMPOSSIBLE(cm->endsc[v])) {

	    v_is_r[v] = TRUE;
	    nd_is_r[nd] = TRUE;
	    child_imin = r_imin[v] + sdl;
	    child_imax = r_imax[v] + sdl;
	    child_jmin = r_jmin[v] - sdr;
	    child_jmax = r_jmax[v] - sdr;
	    if(cm->sttype[v] == IL_st) child_imax = ESL_MAX(child_imax, (imax[v]+1));
	    if(cm->sttype[v] == IR_st) child_jmin = ESL_MIN(child_jmin, (jmin[v]-1));
	    ///printf("\nv: %4d %4s %2s (%4d %4d    %4d %4d)\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]), r_imin[v], r_imax[v], r_jmin[v], r_jmax[v]);
	    for(y = cm->cfirst[v]; y < (cm->cfirst[v] + cm->cnum[v]); y++) {
	      if(imin[y] != -1) {
		r_imin[y] = ESL_MIN(r_imin[y], ESL_MAX(imin[y], child_imin));
		r_imax[y] = ESL_MAX(r_imax[y], ESL_MIN(imax[y], child_imax));
		r_jmin[y] = ESL_MIN(r_jmin[y], ESL_MAX(jmin[y], child_jmin));
		r_jmax[y] = ESL_MAX(r_jmax[y], ESL_MIN(jmax[y], child_jmax));

		if((r_imin[y] <= r_imax[y] && r_jmin[y] <= r_jmax[y]) && ((r_jmax[y] - r_imin[y] + 1) >= StateDelta(cm->sttype[y]))) {
		  ///printf("y: %4d %4s %2s (%4d %4d    %4d %4d)\n", y, Nodetype(cm->ndtype[cm->ndidx[y]]), Statetype(cm->sttype[y]), r_imin[y], r_imax[y], r_jmin[y], r_jmax[y]);
		  y_nd = cm->ndidx[y];
		  nd_r_imin[y_nd] = ESL_MIN(nd_r_imin[y_nd], r_imin[y]);
		  nd_r_imax[y_nd] = ESL_MAX(nd_r_imax[y_nd], r_imax[y]);
		  nd_r_jmin[y_nd] = ESL_MIN(nd_r_jmin[y_nd], r_jmin[y]);
		  nd_r_jmax[y_nd] = ESL_MAX(nd_r_jmax[y_nd], r_jmax[y]);
		}
		else {
		  r_imin[y] =  INT_MAX;
		  r_imax[y] = INT_MIN;
		  r_jmin[y] =  INT_MAX;
		  r_jmax[y] = INT_MIN;
		}
	      }
	    }
	  }
	} /* end of else that's entered if v != E_st nor B_st */
	  } /* end of if(!StateIsDetached) */
	/*////if(v_is_r[v]) printf("ck v  %4s %2s %4d R %d (%11d %11d  %11d %11d) (HMM nd: %4d %4d)\n", Nodetype(cm->ndtype[nd]), Statetype(cm->sttype[v]), v, v_is_r[v], r_imin[v], r_imax[v], r_jmin[v], r_jmax[v], cm->cp9map->cs2hn[v][0], cm->cp9map->cs2hn[v][1]);*/
	} /* end of for (v) loop */

	/*////printf("ck nd %4s    %4d R %d (%11d %11d  %11d %11d)\n\n", Nodetype(cm->ndtype[nd]), nd, nd_is_r[nd], nd_r_imin[nd], nd_r_imax[nd], nd_r_jmin[nd], nd_r_jmax[nd]); */
  }
  /* now we know what states are reachable for what i and j,  check if a valid parse exists */
  if(! cm_is_localized) { /* local begins/ends are off, all nodes must be reachable to get a valid parse */
	for(nd = 0; nd < cm->nodes; nd++) {
	  if(nd_is_r[nd] == FALSE) ESL_FAIL(eslFAIL, errbuf, "CMBandsCheckValidParse(), CM is not locally configured and node %d (%4s) is unreachable\n", nd, Nodetype(cm->ndtype[nd]));
	  if(cm->ndtype[nd] == BIF_nd) {
	v = cm->nodemap[nd];
	w = cm->cfirst[v]; /* BEGL_S */
	y = cm->cnum[v];   /* BEGR_S */
	if(r_jmax[w] < (r_imin[y]-1)) {
	  ESL_FAIL(eslFAIL, errbuf, "CMBandsCheckValidParse(), CM not local, BEGL_S w:%d nd:%d & BEGR_S y:%d nd:%d bands don't touch, res %d..%d unemittable!\n", w, w_nd, y, y_nd, r_jmax[w]+1, r_imin[y]-1);
	}
	  }
	}
  }
  else if(doing_search && cm_is_localized) { /* we're doing a local search, we have a valid parse if any state from which a local end is possible is reachable */
	v = 0;
	while(v < cm->M && !(v_is_r[v] && NOT_IMPOSSIBLE(cm->endsc[v]))) v++; /* increment v until we come to a state that is reachable and can go to EL, or we run out of states */
	if(v == cm->M && i0 != j0) ESL_FAIL(eslFAIL, errbuf, "CMBandsCheckValidParse(), doing_search=TRUE, CM is local, i0 != j0, but no CM state is reachable from which an EL is possible.\n");
  }

  free(v_is_r);
  free(r_imin);
  free(r_imax);
  free(r_jmin);
  free(r_jmax);
  free(nd_is_r);
  free(nd_r_imin);
  free(nd_r_imax);
  free(nd_r_jmin);
  free(nd_r_jmax);
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "CMBandsCheckValidParse(), memory allocation error.");
  return status; /* NEVER REACHED */
}
#endif

/**************************************************************************
 * cp9_HMM2ijBands_OLD() and helper functions.
 * This was how bands were calculated up until revision 2318 (02.07.2008)
 *
 */
/* helper functions for cp9_HMM2ijBands_OLD() */
static void hmm2ij_prestate_step0_initialize(int n, int *nss_max_imin, int *nss_min_jmax, int i0, int j0);
static void hmm2ij_prestate_step1_set_node_inserts(int n, int *nis_imin, int *nis_imax,
						   int *nis_jmin, int *nis_jmax,
						   int *nss_imin, int *nss_imax,
						   int *nss_jmin, int *nss_jmax,
						   int *pn_min_i, int *pn_max_i,
						   CP9Map_t *cp9map);
static void hmm2ij_prestate_step2_determine_safe(int n,
						 int nss_max_imin_np1, int nss_min_jmax_np1,
						 int nis_imin_n,
						 int nis_jmax_n,
						 int *safe_imax, int *safe_jmin);
static void hmm2ij_prestate_step3_preset_node_splits(int n, int *nis_imin, int *nis_imax,
						     int *nis_jmin, int *nis_jmax,
						     int *nss_imin, int *nss_imax,
						     int *nss_jmin, int *nss_jmax,
						     int *pn_min_m, int *pn_max_m,
						     int *pn_min_d, int *pn_max_d,
						     CP9Map_t *cp9map);
static void hmm2ij_split_state_step1_set_state_bands(int v, int n,
						     int tmp_imin, int tmp_imax,
						     int tmp_jmin, int tmp_jmax,
						     int *imin, int *imax, int *jmin, int *jmax,
						     int *nss_imin, int *nss_imax,
						     int *nss_jmin, int *nss_jmax);
static void hmm2ij_insert_state_step1_set_state_bands(int v,
						      int tmp_imin, int tmp_imax,
						      int tmp_jmin, int tmp_jmax,
						      int *imin, int *imax, int *jmin, int *jmax);
static void hmm2ij_state_step2_enforce_safe_trans(CM_t *cm, int v, int n, int *imax, int *jmin,
						  int *nss_imax, int *nss_jmin,
						  int safe_imax, int safe_jmin);
static void hmm2ij_state_step3_enforce_state_delta(CM_t *cm, int v, int *jmin, int *jmax);
static void hmm2ij_state_step4_update_safe_holders(int v, int n, int imin_v, int jmax_v, int *nss_max_imin,
						   int *nss_min_jmax);
static void hmm2ij_state_step5_non_emitter_d0_hack(int v, int imax_v, int *jmin);

/*****************************************************************************
 * Functions to go from HMM bands to i and j bands on a CM
 * cp9_HMM2ijBands_OLD()
 */
/*
 * Function: cp9_HMM2ijBands_OLD()
 *           EPN 12.21.05
 *
 * Purpose:  Determine the band for each cm state v on i (the band on the
 *           starting index in the subsequence emitted from the subtree rooted
 *           at state v), and on j (the band on the ending index in the
 *           subsequence emitted from the subtree rooted at state v).
 *
 *           Some i and d bands are calculated from HMM bands on match and insert
 *           and delete states from each node of the HMM that maps to a left emitting
 *           node of the CM (including MATP nodes). The HMM bands were
 *           calculated previously from the posterior matrices for mmx,
 *           imx and dmx from a CP9 HMM.
 *
 *           Some j bands are calculated from HMM bands on match and insert and
 *           delete states from each node of the HMM that maps to a right emitting
 *           node of the CM (including MATP nodes).
 *
 *           i and j bands that cannot be directly determined from the
 *           HMM bands are inferred based on the constraints imposed
 *           on them by the i and j bands that CAN be determined from
 *           the HMM bands.
 *
 *           Our strategy is to set i and j bands for each state v
 *           such that at least one state y (y \in C_v (y is reachable
 *           from v)) can be reached from v while staying within the i
 *           and j bands for v and y.  This constraint is enforced by
 *           determining the min and max i and j bands across all
 *           states y (into safe* data structures) for a given v, and
 *           then enforcing that at least one cell in the i and j
 *           bands of v can transit to at least one cell in a band for
 *           a y state after accounting for the direction specific
 *           StateDelta() values for v.
 *
 *           This function needs to be called only once, it determines
 *           bands for ALL states. Its unclear the best way to handle
 *           any states that don't have an explicit mapping to an HMM
 *           state that we have a band on (i.e. all delete states, and
 *           ROOT_IR, ROOT_IL, BEGR_IL, BIF_B, and start states).
 *           (11.02.05) I take a simple approach, and set the bands on i
 *           for such states to the same as those for states in a close
 *           proximity. (see code for exact definitions)
 *
 *           This function uses HMM derived bands on delete states.
 *
 * arguments:
 *
 * CM_t *cm         the CM, must have valid cp9b (CP9 bands object)
 * errbuf           char buffer for error messages
 * CP9Bands_t *cp9b the CP9 bands object, usually cm->cp9b
 * CP9Map_t *cp9map map from CM to CP9 HMM and vice versa
 * int i0           start of target subsequence (often 1, beginning of dsq)
 * int j0           end of target subsequence (often L, end of dsq)
 * int doing_search TRUE if the bands will be used for a scanning CYK/Inside
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 *
 * Returns: eslOK on success;
 */
int
cp9_HMM2ijBands_OLD(CM_t *cm, char *errbuf, CP9Bands_t *cp9b, CP9Map_t *cp9map, int i0, int j0, int doing_search, int debug_level)
{
  int v;              /* counter over states of the CM */

  int status;
  int safe_imax;
  int safe_jmin;

  int tmp_imin;
  int tmp_imax;
  int tmp_jmin;
  int tmp_jmax;

  /* ptrs to cp9b data, for convenience */
  int *pn_min_m;      /* pn_min_m[k] = first position in HMM band for match state of HMM node k */
  int *pn_max_m;      /* pn_max_m[k] = last position in HMM band for match state of HMM node k */
  int *pn_min_i;      /* pn_min_i[k] = first position in HMM band for insert state of HMM node k */
  int *pn_max_i;      /* pn_max_i[k] = last position in HMM band for insert state of HMM node k */
  int *pn_min_d;      /* pn_min_d[k] = first position in HMM band for delete state of HMM node k */
  int *pn_max_d;      /* pn_max_d[k] = last position in HMM band for delete state of HMM node k */
  int *imin;          /* imin[v] = first position in band on i for state v to be filled in this function. [1..M] */
  int *imax;          /* imax[v] = last position in band on i for state v to be filled in this function. [1..M] */
  int *jmin;          /* jmin[v] = first position in band on j for state v to be filled in this function. [1..M] */
  int *jmax;          /* jmax[v] = last position in band on j for state v to be filled in this function. [1..M] */

  int *nss_imin;      /* nss_imin[n] = imin of each split set state in node n*/
  int *nss_imax;      /* nss_imax[n] = imax of each split set state in node n*/
  int *nss_jmin;      /* nss_jmin[n] = jmin of each split set state in node n*/
  int *nss_jmax;      /* nss_jmax[n] = jmax of each split set state in node n*/

  int *nis_imin;      /* nss_imin[n] = imin of each insert set state in node n*/
  int *nis_imax;      /* nss_imax[n] = imax of each insert set state in node n*/
  int *nis_jmin;      /* nss_jmin[n] = jmin of each insert set state in node n*/
  int *nis_jmax;      /* nss_jmax[n] = jmax of each insert set state in node n*/

  int *nss_max_imin;  /* nss_max_imin[n] = max imin over split set states in node n*/
  int *nss_min_jmax;  /* nss_min_jmax[n] = min jmax over split set states in node n*/

  int n;            /* counter over CM nodes. */
  int y, yoffset;   /* counters over children states */

  /* Contract checks */
  if (cp9b == NULL)                                                                   ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands_OLD(), cp9b is NULL.\n");
  if(i0 < 1) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands_OLD(), i0 < 1: %d\n", i0);
  if(j0 < 1) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands_OLD(), j0 < 1: %d\n", j0);
  if(j0 < i0) ESL_FAIL(eslEINCOMPAT, errbuf, "cp9_HMM2ijBands_OLD(), i0 (%d) < j0 (%d)\n", i0, j0);

  /* set pointers to cp9b data
   * note: these arrays used to be allocated here, but that was wasteful, now it's allocated
   * once per model (instead of once per sequence) in AllocCP9Bands()
   */

  pn_min_m = cp9b->pn_min_m;
  pn_max_m = cp9b->pn_max_m;
  pn_min_i = cp9b->pn_min_i;
  pn_max_i = cp9b->pn_max_i;
  pn_min_d = cp9b->pn_min_d;
  pn_max_d = cp9b->pn_max_d;
  imin     = cp9b->imin;
  imax     = cp9b->imax;
  jmin     = cp9b->jmin;
  jmax     = cp9b->jmax;

  ESL_ALLOC(nss_imin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nss_imax, sizeof(int) * cm->nodes);
  ESL_ALLOC(nss_jmin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nss_jmax, sizeof(int) * cm->nodes);

  ESL_ALLOC(nis_imin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nis_imax, sizeof(int) * cm->nodes);
  ESL_ALLOC(nis_jmin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nis_jmax, sizeof(int) * cm->nodes);

  ESL_ALLOC(nss_max_imin, sizeof(int) * cm->nodes);
  ESL_ALLOC(nss_min_jmax, sizeof(int) * cm->nodes);

  esl_vec_ISet(nss_imin, cm->nodes, -1);
  esl_vec_ISet(nss_imax, cm->nodes, -1);
  esl_vec_ISet(nss_jmin, cm->nodes, -1);
  esl_vec_ISet(nss_jmax, cm->nodes, -1);

  esl_vec_ISet(nis_imin, cm->nodes, -1);
  esl_vec_ISet(nis_imax, cm->nodes, -1);
  esl_vec_ISet(nis_jmin, cm->nodes, -1);
  esl_vec_ISet(nis_jmax, cm->nodes, -1);

  esl_vec_ISet(nss_max_imin, cm->nodes, -1);
  esl_vec_ISet(nss_min_jmax, cm->nodes, -1);

  /* Initialize all bands to -1. */
  esl_vec_ISet(imin, cm->M, -1);
  esl_vec_ISet(imax, cm->M, -1);
  esl_vec_ISet(jmin, cm->M, -1);
  esl_vec_ISet(jmax, cm->M, -1);

  /* We go node by node, bottom up, and fill in the bands on each
   * state for each node. Keeping track of the node split set min and max i's
   * and j's, as well as the node insert set's
   * also because they influence all nodes above (until a BEGL or BEGR at least).
   */

  /* For match nodes (MATP, MATL, MATR):
   * First calc the split set node mins and maxes, then impose these
   * on each state v in the split set of the node, requiring that any valid
   * d resulting from the i and j bands on state v
   * is least dv = StateDelta(v).
   * This is done by ensuring that jmin[v] >= dv & jmax[v] >= dv.
   * (We don't have to worry about i as we check again when we create
   *  the d bands from the i and j bands in ij2d_bands()).
   * We really only have to enforce the StateDelta issue here so we
   * don't run into d band on j that is 0 cells in ij2d_bands().
   * Alternatively, we could ignore the StateDelta() issue here, and
   * allow ij2d_bands() to modify j bands when it enforces the StateDelta()
   * issue.
   */

   for(n = (cm->nodes-1); n >= 0; n--) {
	 switch (cm->ndtype[n]) {
	 case END_nd:
	   /* Special case, we need to know the bands on the states
	* in the node ABOVE this one. Node above MUST be MATP, MATL
	* or MATR. For END states, the band on i = the band on j,
	* this is because d must be 0, so i must be (j+1), so its pointless
	* to allow an i value that (j+1) is not allowed to be or vice versa.
	* If the node above is MATL, we use the HMM band that maps
	* to the ML state - these correspond to bands on i. If its a MATR,
	* we use the HMM band that maps to the MR state - these correspond
	* to bands on j. If its a MATP, we get fancy (see below).
	*/
	   v = cm->nodemap[n];
	   if(cm->ndtype[n-1] == MATL_nd) {
	 /* tricky. we keep the n_*m** structures ignorant of the fact that we're in
	  * an end state, i.e. we don't force a d=0 (j-i+1=0). This way when
	  * the node immediately above the end (the MATL) looks at it when its determining
	  * the correct bands on i, it doesn't get screwed up (as it would if j < i).
	  */

	 /*minimum of delete and match states of node above*/
	 nss_imin[n] = (pn_min_m[cp9map->nd2lpos[n-1]] <= (pn_min_d[cp9map->nd2lpos[n-1]])) ?
	   pn_min_m[cp9map->nd2lpos[n-1]] : (pn_min_d[cp9map->nd2lpos[n-1]]);
	 /*for the max, we must allow possibility of inserts and deletes.*/
	 nss_imax[n] = (pn_max_m[cp9map->nd2lpos[n-1]] >= pn_max_i[cp9map->nd2lpos[n-1]]) ?
	   pn_max_m[cp9map->nd2lpos[n-1]] : pn_max_i[cp9map->nd2lpos[n-1]];
	 /* deletes max bands may always be less than match max bands...(not sure)*/
	 if(nss_imax[n] < (pn_max_d[cp9map->nd2lpos[n-1]]))
	   nss_imax[n] = (pn_max_d[cp9map->nd2lpos[n-1]]);

	 nss_jmin[n] = nss_imin[n];
	 nss_jmax[n] = nss_imax[n];

	 imin[v] = nss_imin[n];
	 imax[v] = nss_imax[n] + 1; /* we add 1 because we have to figure in the emission
				     * of the MATL_ML (or final MATL_IL), which would increase
				     * i by 1 potentially relative to the imax of that state.
				     */
	 jmin[v] = imin[v] - 1; /* d must be 0 for end states. */
	 jmax[v] = imax[v] - 1; /* d must be 0 for end states. */

	 nss_max_imin[n] = imin[v];
	 nss_min_jmax[n] = jmax[v];
	   }
	   else if(cm->ndtype[n-1] == MATR_nd) {
	 /* tricky. we keep the nss_*m** structures ignorant of the fact that we're in
	  * an end state, i.e. we don't force a d=0 (j-i+1=0). This way when
	  * the node immediately above the end (the MATR) looks at it when its determining
	  * the correct bands on i, it doesn't get screwed up (as it would if j < i).
	  */

	 /*minimum of delete and match states of node above */
	 nss_jmin[n] = (pn_min_m[cp9map->nd2rpos[n-1]] <= pn_min_d[cp9map->nd2rpos[n-1]]) ?
	   pn_min_m[cp9map->nd2rpos[n-1]] : pn_min_d[cp9map->nd2rpos[n-1]];
	 /*for the max, we must allow possibility of inserts.*/
	 nss_jmax[n] = (pn_max_m[cp9map->nd2rpos[n-1]] >= pn_max_i[cp9map->nd2rpos[n-1]]) ?
	   pn_max_m[cp9map->nd2rpos[n-1]] : pn_max_i[cp9map->nd2rpos[n-1]];
	 /* deletes max bands may always be less than match max bands...(not sure)*/
	 if(nss_jmax[n] < pn_max_d[cp9map->nd2rpos[n-1]])
	   nss_jmax[n] = pn_max_d[cp9map->nd2rpos[n-1]];
	 nss_imin[n] = nss_jmin[n];
	 nss_imax[n] = nss_jmax[n];

	 jmin[v] = nss_jmin[v] - 1; /* we subtract 1 because of we have to figure
				     * in the emission of the MATR_MR (or final MATR_IR), which would
				     * decrease j by 1 potentially relative to jmin of that state.
				     */
	 jmax[v] = nss_jmax[n];
	 imin[v] = jmin[v] + 1; /*d (j-i+1) must be 0 for end states*/
	 imax[v] = jmax[v] + 1; /*d (j-i+1) must be 0 for end states*/

	 nss_max_imin[n] = imin[v];
	 nss_min_jmax[n] = jmax[v];
	   }
	   else if(cm->ndtype[n-1] == MATP_nd) {
	 /* Very rare case, only if the last bp in a stem is the last left consensus
	  * column (respecting gap_thresh) in that alignment. Does happen though,
	  * (at least in RFAM 6.1) because the training counts for transition priors
	  * had counts for MATP_* state -> END_nd transition sets.
	  */

	 /* tricky. we keep the nss_*m** structures ignorant of the fact that we're in
	  * an end state, i.e. we don't force a d=0 (j-i+1=0). This way when
	  * the node immediately above the end (the MATP) looks at it when its determining
	  * the correct bands on j, it doesn't get screwed up (as it would if j < i).
	  */
	 /*minimum of delete and match states of node above*/
	 nss_imin[n] = (pn_min_m[cp9map->nd2lpos[n-1]] <= (pn_min_d[cp9map->nd2lpos[n-1]])) ?
	   pn_min_m[cp9map->nd2lpos[n-1]] : (pn_min_d[cp9map->nd2lpos[n-1]]);
	 /*for the max, we must allow possibility of inserts and deletes.*/
	 nss_imax[n] = (pn_max_m[cp9map->nd2lpos[n-1]] >= pn_max_i[cp9map->nd2lpos[n-1]]) ?
	   pn_max_m[cp9map->nd2lpos[n-1]] : pn_max_i[cp9map->nd2lpos[n-1]];
	 /* deletes max bands may always be less than match max bands...(not sure)*/
	 if(nss_imax[n] < (pn_max_d[cp9map->nd2lpos[n-1]]))
	   nss_imax[n] = (pn_max_d[cp9map->nd2lpos[n-1]]);

	 /*minimum of delete and match states of node above*/
	 nss_jmin[n] = (pn_min_m[cp9map->nd2rpos[n-1]] <= pn_min_d[cp9map->nd2rpos[n-1]]) ?
	   pn_min_m[cp9map->nd2rpos[n-1]] : pn_min_d[cp9map->nd2rpos[n-1]];
	 /*for the max, we must allow possibility of inserts.*/
	 nss_jmax[n] = (pn_max_m[cp9map->nd2rpos[n-1]] >= pn_max_i[cp9map->nd2rpos[n-1]]) ?
	   pn_max_m[cp9map->nd2rpos[n-1]] : pn_max_i[cp9map->nd2rpos[n-1]];
	 /* deletes max bands may always be less than match max bands...(not sure)*/
	 if(nss_jmax[n] < pn_max_d[cp9map->nd2rpos[n-1]])
	   nss_jmax[n] = pn_max_d[cp9map->nd2rpos[n-1]];

	 /* unique situation. end's d must be 0, so we are constrained on what
	  * i can be relative to j, and j can be relative to i, but what we want
	  * are the constraints on what i can be, and j can be.
	  * because d=0 => j-i+1 = 0. then imin should equal = jmin + 1 and imax = jmax + 1.
	  * so we really just want to know a min over i and j, and a max over i and j.
	  * below we take min of imin and jmin (should always be imin i think) as the min,
	  * and max of imax and jmax (should always be jmax i think) after accounting for
	  * the possibility that a single base was just emitted left and/or right.
	  */
	 imax[v] = ((nss_imax[n] + 1) > nss_jmax[n]) ?
	   (nss_imax[n] + 1) : nss_jmax[n];
	 imin[v] = ((nss_imin[n]) < (nss_jmin[n] - 1)) ?
	   (nss_imin[n]) : (nss_jmin[n] - 1);
	 /* we can't have an i < i0 */
	 imin[v] = ESL_MAX(imin[v], i0);
	 imax[v] = ESL_MAX(imax[v], i0);
	 jmin[v] = imin[v] - 1; /* d must be 0 for end states. */
	 jmax[v] = imax[v] - 1; /* d must be 0 for end states. */

	 nss_max_imin[n] = imin[v];
	 nss_min_jmax[n] = jmax[v];
	   }
	   break;

	case MATP_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);
	  /* 6 states MATP_MP, MATP_ML, MATP_MR, MATP_D, MATP_IL, MATP_IR */
	  v = cm->nodemap[n]; /* MATP_MP */
	  /* Determine implied v bands using hmm for mapped 'direction(s)' and
	   * next node's bands for non-mapped direction(s).
	   */
	  tmp_imin = pn_min_m[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_m[cp9map->nd2lpos[n]];
	  tmp_jmin = pn_min_m[cp9map->nd2rpos[n]];
	  tmp_jmax = pn_max_m[cp9map->nd2rpos[n]];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*MATP_ML*/
	  /* Determine implied v bands using hmm for mapped 'direction(s)' and
	   * next node's bands for non-mapped direction(s).
	   */
	  tmp_imin = pn_min_m[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_m[cp9map->nd2lpos[n]];
	  /* 12.19.05 - trying to deal with the right delete off-by-one
	   * inverted relative to left delete issue.
	   */
	  tmp_jmin = (pn_min_d[cp9map->nd2rpos[n]] < nss_jmin[n+1]) ?
	    pn_min_d[cp9map->nd2rpos[n]] : nss_jmin[n+1];
	  tmp_jmax = (pn_max_d[cp9map->nd2rpos[n]] > nss_jmax[n+1]) ?
	    pn_max_d[cp9map->nd2rpos[n]] : nss_jmax[n+1];

	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*MATP_MR*/
	  /* this D-left state gets the delete band from the HMM node
	   * that maps to the left side.
	   */
	  tmp_imin = pn_min_d[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_d[cp9map->nd2lpos[n]];
	  tmp_jmin = pn_min_m[cp9map->nd2rpos[n]];
	  tmp_jmax = pn_max_m[cp9map->nd2rpos[n]];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*MATP_D*/
	  tmp_imin = pn_min_d[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_d[cp9map->nd2lpos[n]];
	  /* 12.19.05 - trying to deal with the right delete off-by-one
	   * inverted relative to left delete issue.
	   */
	  tmp_jmin = (pn_min_d[cp9map->nd2rpos[n]] < nss_jmin[n+1]) ?
	    pn_min_d[cp9map->nd2rpos[n]] : nss_jmin[n+1];
	  tmp_jmax = (pn_max_d[cp9map->nd2rpos[n]] > nss_jmax[n+1]) ?
	    pn_max_d[cp9map->nd2rpos[n]] : nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);

	  v++; /*MATP_IL*/
	  /* This state maps to the insert state of HMM node cp9map->cs2hn[v][0]*/
	  tmp_imin = pn_min_i[cp9map->cs2hn[v][0]]; /* insert states can only map to 1 HMM node */
	  tmp_imax = pn_max_i[cp9map->cs2hn[v][0]]; /* insert states can only map to 1 HMM node */
	  tmp_jmin = nss_jmin[n];
	  tmp_jmax = nss_jmax[n];
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);

	  v++; /*MATP_IR*/
	  /* skip detached inserts */
	  if(cp9map->cs2hn[v][0] == -1)
	    continue;
	  /* Special case, one of only two situations (other is ROOT_IR)
	   * we could have come where v is an insert, and a possible
	   * state x that we came from is an insert, but x != y (x can be the MATP_IL).
	   * So we have to determine imin and imax carefully.
	   */
	  tmp_imin = (nss_imin[n] < imin[v-1]) ?
	    nss_imin[n] : imin[v-1];
	  tmp_imax = (nss_imax[n] > imax[v-1]) ?
	    nss_imax[n] : imax[v-1];
	  /* This state maps to the insert state of HMM node cp9map->cs2hn[v][0]*/
	  tmp_jmin = pn_min_i[cp9map->cs2hn[v][0]];
	  tmp_jmax = pn_max_i[cp9map->cs2hn[v][0]];
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  break;

	case MATL_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);

	  /* 3 states MATL_ML, MATL_D, MATL_IL */
	  v = cm->nodemap[n]; /* MATL_ML */
	  tmp_imin = pn_min_m[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_m[cp9map->nd2lpos[n]];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*MATL_D*/
	  /* this D-left state gets the delete band from the HMM node
	   * that maps to the left side.
	   */
	  tmp_imin = pn_min_d[cp9map->nd2lpos[n]];
	  tmp_imax = pn_max_d[cp9map->nd2lpos[n]];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);

	  v++; /*MATL_IL*/
	  /* skip detached inserts */
	  if(cp9map->cs2hn[v][0] == -1)
	    continue;
	  /* This state maps to the insert state of HMM node cp9map->cs2hn[v][0]*/
	  tmp_imin = pn_min_i[cp9map->cs2hn[v][0]];
	  tmp_imax = pn_max_i[cp9map->cs2hn[v][0]];
	  tmp_jmin = nss_jmin[n];
	  tmp_jmax = nss_jmax[n];

	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  break;

	case MATR_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);

	  /* 3 states MATR_MR, MATR_D, MATR_IR */
	  v = cm->nodemap[n]; /* MATR_MR */
	  tmp_imin = nss_imin[n+1];
	  tmp_imax = nss_imax[n+1];
	  tmp_jmin = pn_min_m[cp9map->nd2rpos[n]];
	  tmp_jmax = pn_max_m[cp9map->nd2rpos[n]];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*MATR_D*/
	  /* this D-left state gets the delete band from the HMM node
	   * that maps to the left side.
	   */
	  tmp_imin = nss_imin[n+1];
	  tmp_imax = nss_imax[n+1];
	  /* 12.19.05 - trying to deal with the right delete off-by-one
	   * inverted relative to left delete issue.
	   */
	  tmp_jmin = (pn_min_d[cp9map->nd2rpos[n]] < nss_jmin[n+1]) ?
	    pn_min_d[cp9map->nd2rpos[n]] : nss_jmin[n+1];
	  tmp_jmax = (pn_max_d[cp9map->nd2rpos[n]] > nss_jmax[n+1]) ?
	    pn_max_d[cp9map->nd2rpos[n]] : nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);

	  v++; /*MATR_IR*/
	  /* skip detached inserts */
	  if(cp9map->cs2hn[v][0] == -1)
	    continue;
	  tmp_imin = nss_imin[n];
	  tmp_imax = nss_imax[n];
	  /* This state maps to the insert state of HMM node cshn_map[v]*/
	  tmp_jmin = pn_min_i[cp9map->cs2hn[v][0]];
	  tmp_jmax = pn_max_i[cp9map->cs2hn[v][0]];
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  break;

	case ROOT_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);
	  /* 3 states, ROOT_S, ROOT_IL, and ROOT_IR*/
	  v = cm->nodemap[n]; /* ROOT_S SPECIAL CASE */
	  if(doing_search) { /* we're doing search, ROOT_S doesn't necessarily emit full sequence */
	    tmp_imin = nss_imin[n+1];
	    tmp_imax = nss_imax[n+1];
	    tmp_jmin = nss_jmin[n+1];
	    tmp_jmax = nss_jmax[n+1];
	  }
	  else { /* we're doing alignment, enforce ROOT_S emits full sequence */
	    /* for now, enforce ROOT_S emits full sequence at end of the function, we'll relax this if doing_search==TRUE */
	    tmp_imin = i0;
	    tmp_imax = i0;
	    tmp_jmin = j0;
	    tmp_jmax = j0;
	  }
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);

	  v++; /*ROOT_IL SPECIAL CASE*/
	  /* This state maps to the insert state of HMM node cp9map->cs2hn[v][0], which is HMM node 0*/
	  if(doing_search)
	  tmp_imin =  pn_min_i[cp9map->cs2hn[v][0]]; /* should this be imin[0]? */
	  else
	    tmp_imin =  i0; /* Have to be able to transit here from ROOT_S */
	  tmp_imax = nss_imax[n+1];
	  if(doing_search) {
	    tmp_jmin = nss_jmin[n+1];
	    tmp_jmax = nss_jmax[n+1];
	  }
	  else {
	    tmp_jmin = j0; /* we never emit to the right in this state */
	    tmp_jmax = j0; /* we never emit to the right in this state */
	  }
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);

	  v++; /*ROOT_IR SPECIAL CASE analagous to ROOT_IL*/
	  if(doing_search)
	    tmp_imin = nss_imin[n+1]; /* same tmp_imin as ROOT_S */
	  else
	    tmp_imin = i0; /* we never emit to the left in this state */
	  tmp_imax = nss_imax[n+1];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = j0; /* Have to be able to transit here from ROOT_S */
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  break;

	case BEGL_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);
	  /* 1 state BEGL_S */
	  v = cm->nodemap[n];
	  /* The next node MUST be a match node (MATP
	   * specifically due to model building
	   * algorithm) or a BIF node. We derive imin, imax,
	   * jmin and jmax from that node.
	   */
	  /* Use the next nodes split set band, which
	   * will be wider of match and delete states bands
	   * for split set states in next node.
	   */
	  tmp_imin = nss_imin[n+1];
	  tmp_imax = nss_imax[n+1];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);
	  break;

	case BEGR_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);
	  hmm2ij_prestate_step1_set_node_inserts(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						 nss_imin, nss_imax, nss_jmin, nss_jmax,
						 pn_min_i, pn_max_i, cp9map);

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  hmm2ij_prestate_step3_preset_node_splits(n, nis_imin, nis_imax, nis_jmin, nis_jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax,
						   pn_min_m, pn_max_m, pn_min_d, pn_max_d,
						   cp9map);
	  /* 2 states BEGR_S and BEGR_IL */
	  v = cm->nodemap[n]; /*BEGR_S*/
	  /* Use either the next nodes split set band, which
	   * will be wider of match and delete states bands
	   * for split set states in next node OR
	   * the band on the insert state that maps to the
	   * BEGR_IL, erring on the safe side (wider band).
	   */
	  tmp_imin = nss_imin[n+1];
	  tmp_imax = nss_imax[n+1];
	  if(pn_min_i[cp9map->cs2hn[v+1][0]] < tmp_imin)
	    tmp_imin = pn_min_i[cp9map->cs2hn[v+1][0]];
	  if(pn_max_i[cp9map->cs2hn[v+1][0]] > tmp_imax)
	    tmp_imax = pn_max_i[cp9map->cs2hn[v+1][0]];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = nss_jmax[n+1];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);

	  v++; /*BEGR_IL*/
	  /* This state maps to the insert state of HMM node cp9map->cs2hn[v][0]*/
	  tmp_imin = pn_min_i[cp9map->cs2hn[v][0]];
	  tmp_imax = pn_max_i[cp9map->cs2hn[v][0]];
	  tmp_jmin = nss_jmin[n+1];
	  tmp_jmax = nss_jmax[n+1];
	  hmm2ij_insert_state_step1_set_state_bands(v, tmp_imin, tmp_imax, tmp_jmin,
						    tmp_jmax, imin, imax, jmin, jmax);
	  /* Enforce safe transitions, this makes sure that at least one state
	   * y \in C_v is reachable from v. And further (special case for inserts)
	   * make sure that we don't consider v as a possible y.  IF we did, we might
	   * be faced with a situation where v could only transit to itself, and then
	   * we'd be in the same situation, but we may no longer be able to transit ANYWHERE
	   * including to itself.
	   */
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, (nss_max_imin[n+1]), nss_min_jmax[n+1]);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  break;

	case BIF_nd:
	  hmm2ij_prestate_step0_initialize(n, nss_max_imin, nss_min_jmax, i0, j0);

	  /* 1 state BIF_B */
	  v = cm->nodemap[n]; /*BIF_B*/
	  /* The only two connected states are BEGL_S and BEGR_S.
	   * We can derive our imin, imax, jmin, and jmax from
	   * those two states.
	   * cm->cfirst[v] is the state index of the left child.
	   * cm->cnum[v] is the state index of the right child.
	   */
	  nis_imin[n] = imin[cm->cfirst[v]];
	  nis_imax[n] = imax[cm->cfirst[v]];
	  nis_jmin[n] = jmin[cm->cnum[v]];
	  nis_jmax[n] = jmax[cm->cnum[v]];

	  nss_imin[n] = imin[cm->cfirst[v]];
	  nss_imax[n] = imax[cm->cfirst[v]];
	  nss_jmin[n] = jmin[cm->cnum[v]];
	  nss_jmax[n] = jmax[cm->cnum[v]];

	  hmm2ij_prestate_step2_determine_safe(n, nss_max_imin[n+1], nss_min_jmax[n+1],
					       nis_imin[n], nis_jmax[n],
					       &safe_imax, &safe_jmin);
	  tmp_imin = imin[cm->cfirst[v]];
	  tmp_imax = imax[cm->cfirst[v]];
	  tmp_jmin = jmin[cm->cnum[v]];
	  tmp_jmax = jmax[cm->cnum[v]];
	  hmm2ij_split_state_step1_set_state_bands(v, n, tmp_imin, tmp_imax, tmp_jmin,
						   tmp_jmax, imin, imax, jmin, jmax,
						   nss_imin, nss_imax, nss_jmin, nss_jmax);
	  hmm2ij_state_step2_enforce_safe_trans(cm, v, n, imax, jmin, nss_imax, nss_jmin, safe_imax,
	  					safe_jmin);
	  hmm2ij_state_step3_enforce_state_delta(cm, v, jmin, jmax);
	  hmm2ij_state_step4_update_safe_holders(v, n, imin[v], jmax[v], nss_max_imin, nss_min_jmax);
	  hmm2ij_state_step5_non_emitter_d0_hack(v, imax[v], jmin);
	  break;
	}
	}

   /* Tie up some loose ends:
	* 1. Ensure that all valid i are >= i0 and all valid j are <= j0
	* 2. Ensure all bands have bandwidth >= 0 (see code)
	* 3. Set detached inserts states to imin=imax=jmin=jmax=i0 to avoid
	*    problems in downstream functions. These states WILL NEVER BE ENTERED
	* 4. Do a quick check to make sure we've assigned the bands
	*    on i and j for all states to positive values (none were
	*    left as -1 EXCEPT for end states which should have i bands left as -1).
	* 5. Ensure imin[0] <= imin[v] for all v and jmax[0] >= jmax[v] for all v.
	* 6. If doing_search==TRUE, rewrite the bands on the
	*    ROOT_S state so they allow any possible transition to a child
	*    that the child's bands would allow.
	*/

   /* 1. Ensure that all valid i are >= i0 and all valid j are <= j0 */
   for(v = 0; v < cm->M; v++) {
	 imin[v] = ESL_MAX(imin[v], i0); /* imin[v] can't be less than i0 */
	 imax[v] = ESL_MAX(imax[v], i0); /* imax[v] can't be less than i0 */

	 imin[v] = ESL_MIN(imin[v], j0); /* imin[v] can't be more than j0 */
	 imax[v] = ESL_MIN(imax[v], j0); /* imax[v] can't be more than j0 */

	 imax[v] = ESL_MIN(imax[v], j0); /* imax[v] can't be more than j0 */

	 jmin[v] = ESL_MIN(jmin[v], j0); /* jmin[v] can't be more than j0 */
	 jmax[v] = ESL_MIN(jmax[v], j0); /* jmax[v] can't be more than j0 */

	 jmin[v] = ESL_MAX(jmin[v], i0); /* jmin[v] can't be less than i0 */
	 jmax[v] = ESL_MAX(jmax[v], i0); /* jmax[v] can't be less than i0 */

	 /* 2. Ensure all bands have bandwidth >= 0
	  * Ensure: jmax[v] - jmin[v] + 1 >= 0
	  *         imax[v] - imin[v] + 1 >= 0
	  * jmax[v] - jmin[v] + 1 == 0 means there are no valid j's for state v,
	  * so state v is not allowed to be in the parse, we allow this (maybe we shouldn't)
	  */
	 imax[v] = ESL_MAX(imax[v], imin[v]-1);
	 jmin[v] = ESL_MIN(jmin[v], jmax[v]+1);

	 /* 3. Set detached inserts states to imin=imax=jmin=jmax=i0 to avoid
	  *    problems in downstream functions. These states WILL NEVER BE ENTERED
	  */
	 if(cm->sttype[v+1] == E_st) imin[v] = imax[v] = jmin[v] = jmax[v] = i0;

	 /* 4. Do a quick check to make sure we've assigned the bands
	  *    on i and j for all states to positive values (none were
	  *    left as -1 EXCEPT for end states which should have i bands left as -1).
	  */
	 ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (imin[v] == -1))));
	 ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (imax[v] == -1))));
	 ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (jmin[v] == -1))));
	 ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (jmax[v] == -1))));

	 /* 5. Ensure imin[0] <= imin[v] for all v and jmax[0] >= jmax[v] for all v. */
	 imin[0] = ESL_MIN(imin[0], imin[v]);
	 jmax[0] = ESL_MAX(jmax[0], jmax[v]);
   }

   /* 6. If doing_search==TRUE, rewrite the bands on the
	*    ROOT_S state so they allow any possible transition to a child
	*    that the child's bands would allow.
	*/
   if(doing_search) {
	 /* First look at children of 0 (these probs will be 0. if local begins on, but it doesn't matter for our purposes here) */
	 for (yoffset = 0; yoffset < cm->cnum[0]; yoffset++) {
	   y = cm->cnum[0] + yoffset;
	   imin[0] = ESL_MIN(imin[0], imin[y]);
	   imax[0] = ESL_MAX(imax[0], imax[y]);
	   jmin[0] = ESL_MIN(jmin[0], jmin[y]);
	   jmax[0] = ESL_MAX(jmax[0], jmax[y]);
	 }
	 /* now for possible local begins */
	 if(cm->flags & CMH_LOCAL_BEGIN) {
	   for (y = 1; y < cm->M; y++) {
	 if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	   imin[0] = ESL_MIN(imin[0], imin[y]);
	   imax[0] = ESL_MAX(imax[0], imax[y]);
	   jmin[0] = ESL_MIN(jmin[0], jmin[y]);
	   jmax[0] = ESL_MAX(jmax[0], jmax[y]);
	 }
	   }
	 }
   }
  /* Final, exceedingly rare, special case */
  if(i0 == j0) { /* special case that breaks DP recursion for MP states
		  * b/c target seq is length 1, and all MPs are impossible,
		  * yet above code just forced jmin[v] <= j0 and jmax[v] <= j0,
		  * which says that MPs are possible.
		  */
	for(v = 0; v < cm->M; v++) {
	  if(cm->sttype[v] == MP_st) {
	jmin[v] = j0+1;
	jmax[v] = j0;
	/* now 'for (j = jmin[v]; j <= jmax[v]; j++)' { loops will never be entered, b/c jmin[v] == 2, jmax[v] == 1 */
	  }
	}
  }

#if 0
  /* OLD CODE EPN, Fri Dec 21 09:14:32 2007 */
   /* Tie up some loose ends:
	* 1. Set detached inserts states to imin=imax=jmin=jmax=i0 to avoid
	*    problems in downstream functions. These states WILL NEVER BE ENTERED
	* 2. Do a quick check to make sure we've assigned the bands
	*    on i and j for all states to positive values (none were
	*    left as -1 EXCEPT for end states which should have i bands left as -1).
	* 3. Ensure that all *max[v] and *min[v] values are <= L, values greater
	*    than this don't make sense.
	*/

  for(v = 0; v < cm->M; v++) {
	/* set bands for detached inserts */
	if(cm->sttype[v+1] == E_st) imin[v] = imax[v] = jmin[v] = jmax[v] = i0;

	/* Ensure: for all i imin[v]..i..imax[v]
	 *             i0 <= i <= j0+1
	 *         for all j jmin[v]..j..jmax[v]
	 *             i0 <= j <= j0
	 * Note: i can be j0+1 to allow delete states to be entered with
	 * d = 0, after the entire seq has been emitted.
	 */
	imin[v] = ESL_MAX(imin[v], i0);
	imin[v] = ESL_MIN(imin[v], j0+1);
	imax[v] = ESL_MAX(imax[v], i0);
	imax[v] = ESL_MIN(imax[v], j0+1);
	jmin[v] = ESL_MAX(jmin[v], i0);
	jmin[v] = ESL_MIN(jmin[v], j0);
	jmax[v] = ESL_MAX(jmax[v], i0);
	jmax[v] = ESL_MIN(jmax[v], j0);

	/* Ensure: for all v imin[v] >= imin[0],
	 *                   jmax[v] <= jmax[0].
	 */
	imin[v] = ESL_MAX(imin[v], imin[0]);
	imax[v] = ESL_MAX(imax[v], imin[0]);
	jmax[v] = ESL_MIN(jmax[v], jmax[0]);
	jmin[v] = ESL_MIN(jmin[v], jmax[0]);

	/* Ensure: jmax[v] - jmin[v] + 1 >= 0
	 *         imax[v] - imin[v] + 1 >= 0
	 * jmax[v] - jmin[v] + 1 == 0 means there are no valid j's for state v,
	 * so state v is not allowed to be in the parse, we allow this (maybe we shouldn't)
	 */
	imin[v] = ESL_MIN(imin[v], imax[v]+1);
	jmin[v] = ESL_MIN(jmin[v], jmax[v]+1);

	ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (imin[v] == -1))));
	ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (imax[v] == -1))));
	ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (jmin[v] == -1))));
	ESL_DASSERT1((! ((cm->sttype[v] != E_st) && (jmax[v] == -1))));
  }
#endif

  /* debug_print_ij_bands(cm); */

  free(nss_imin);
  free(nss_imax);
  free(nss_jmin);
  free(nss_jmax);
  free(nis_imin);
  free(nis_imax);
  free(nis_jmin);
  free(nis_jmax);
  free(nss_max_imin);
  free(nss_min_jmax);
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error.\n");
}

/**************************************************************************
 * Helper functions for *_cp9_HMM2ijBands_OLD()
 *  hmm2ij_prestate_step0_initialize()
 *  hmm2ij_prestate_step1_set_node_inserts()
 *  hmm2ij_prestate_step2_determine_safe()
 *  hmm2ij_prestate_step3_preset_node_splits()
 *  hmm2ij_split_state_step1_set_state_bands()
 *  hmm2ij_insert_state_step1_set_state_bands()
 *  hmm2ij_state_step2_enforce_safe_trans()
 *  hmm2ij_state_step5_non_emitter_d0_hack()
 */

/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_prestate_step0_initialize
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_prestate_step0_initialize(int n, int *nss_max_imin, int *nss_min_jmax, int i0, int j0)
{
  nss_max_imin[n] = i0-1;
  nss_min_jmax[n] = j0;
}

/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_prestate_step1_set_node_inserts
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_prestate_step1_set_node_inserts(int n, int *nis_imin, int *nis_imax,
				       int *nis_jmin, int *nis_jmax,
				       int *nss_imin, int *nss_imax,
				       int *nss_jmin, int *nss_jmax,
				       int *pn_min_i, int *pn_max_i,
				       CP9Map_t *cp9map)

{
  if(cp9map->nd2lpos[n] != -1)
	{
	  nis_imin[n] = pn_min_i[cp9map->nd2lpos[n]];
	  nis_imax[n] = pn_max_i[cp9map->nd2lpos[n]];
	}
  else
	{
	  nis_imin[n] = nss_imin[n+1];
	  nis_imax[n] = nss_imax[n+1];
	}
  if(cp9map->nd2rpos[n] != -1)
	{
	  nis_jmin[n] = pn_min_i[cp9map->nd2rpos[n]];
	  nis_jmax[n] = pn_max_i[cp9map->nd2rpos[n]];
	}
  else
	{
	  nis_jmin[n] = nss_jmin[n+1];
	  nis_jmax[n] = nss_jmax[n+1];
	}
}
/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_prestate_step1_set_node_inserts
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_prestate_step2_determine_safe(int n,
				     int nss_max_imin_np1, int nss_min_jmax_np1,
				     int nis_imin_n,
				     int nis_jmax_n,
				     int *safe_imax, int *safe_jmin)
{
  *safe_imax = (nss_max_imin_np1 < nis_imin_n) ?
	nss_max_imin_np1 : nis_imin_n;
  *safe_jmin = (nss_min_jmax_np1 > nis_jmax_n) ?
	nss_min_jmax_np1 : nis_jmax_n;
}
/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_prestate_step1_set_node_inserts
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_prestate_step3_preset_node_splits(int n, int *nis_imin, int *nis_imax,
					 int *nis_jmin, int *nis_jmax,
					 int *nss_imin, int *nss_imax,
					 int *nss_jmin, int *nss_jmax,
					 int *pn_min_m, int *pn_max_m,
					 int *pn_min_d, int *pn_max_d,
					 CP9Map_t *cp9map)
{
  if(cp9map->nd2lpos[n] != -1)
	{
	  nss_imin[n] = (pn_min_m[cp9map->nd2lpos[n]] < (pn_min_d[cp9map->nd2lpos[n]])) ?
	pn_min_m[cp9map->nd2lpos[n]] : (pn_min_d[cp9map->nd2lpos[n]]);
	  nss_imax[n] = (pn_max_m[cp9map->nd2lpos[n]] > (pn_max_d[cp9map->nd2lpos[n]])) ?
	pn_max_m[cp9map->nd2lpos[n]] : (pn_max_d[cp9map->nd2lpos[n]]);
	}
  else
	{
	  nss_imin[n] = nss_imin[n+1];
	  nss_imax[n] = nss_imax[n+1];
	}
  if(cp9map->nd2rpos[n] != -1)
	{
	  nss_jmin[n] = (pn_min_m[cp9map->nd2rpos[n]] < pn_min_d[cp9map->nd2rpos[n]]) ?
	pn_min_m[cp9map->nd2rpos[n]] : pn_min_d[cp9map->nd2rpos[n]];
	  nss_jmax[n] = (pn_max_m[cp9map->nd2rpos[n]] > pn_max_d[cp9map->nd2rpos[n]]) ?
	pn_max_m[cp9map->nd2rpos[n]] : pn_max_d[cp9map->nd2rpos[n]];
	}
  else
	{
	  nss_jmin[n] = nss_jmin[n+1];
	  nss_jmax[n] = nss_jmax[n+1];
	}
}

/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_split_state_step1_set_state_bands
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_split_state_step1_set_state_bands(int v, int n,
					 int tmp_imin, int tmp_imax,
					 int tmp_jmin, int tmp_jmax,
					 int *imin, int *imax, int *jmin, int *jmax,
					 int *nss_imin, int *nss_imax,
					 int *nss_jmin, int *nss_jmax)
{
  imin[v] = tmp_imin;
  imax[v] = tmp_imax;
  jmin[v] = tmp_jmin;
  jmax[v] = tmp_jmax;
  if(imin[v] < nss_imin[n])
	nss_imin[n] = imin[v];
  if(imax[v] > nss_imax[n])
	nss_imax[n] = imax[v];
  if(jmin[v] < nss_jmin[n])
	nss_jmin[n] = jmin[v];
  if(jmax[v] > nss_jmax[n])
	nss_jmax[n] = jmax[v];

}
/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_prestate_step1_set_node_inserts
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void hmm2ij_insert_state_step1_set_state_bands(int v,
					       int tmp_imin, int tmp_imax,
					       int tmp_jmin, int tmp_jmax,
					       int *imin, int *imax, int *jmin, int *jmax)
{
  imin[v] = tmp_imin;
  imax[v] = tmp_imax;
  jmin[v] = tmp_jmin;
  jmax[v] = tmp_jmax;
}
/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_state_step2_enforce_safe_trans
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_state_step2_enforce_safe_trans(CM_t *cm, int v, int n, int *imax, int *jmin,
				      int *nss_imax, int *nss_jmin,
				      int safe_imax, int safe_jmin)
{
  int dv_l;
  int dv_r;
  if((cm->sttype[v] == ML_st) ||
	 (cm->sttype[v] == IL_st) ||
	 (cm->sttype[v] == MP_st))
	dv_l = 1;
  else
	dv_l = 0;
  if((cm->sttype[v] == MR_st) ||
	 (cm->sttype[v] == IR_st) ||
	 (cm->sttype[v] == MP_st))
	dv_r = 1;
  else
	dv_r = 0;
  if(imax[v] < safe_imax - dv_l)
	{
	  imax[v] = safe_imax - dv_l;
	  if(imax[v] > nss_imax[n])
	nss_imax[n] = imax[v];
	}
  if(jmin[v] > safe_jmin + dv_r)
	{
	  jmin[v] = safe_jmin + dv_r;
	  if(jmin[v] < nss_jmin[n])
	nss_jmin[n] = jmin[v];
	}
}

/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_state_step3_enforce_state_delta
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_state_step3_enforce_state_delta(CM_t *cm, int v, int *jmin, int *jmax)
{
  int dv_l;
  int dv_r;
  if((cm->sttype[v] == ML_st) ||
	 (cm->sttype[v] == IL_st) ||
	 (cm->sttype[v] == MP_st))
	dv_l = 1;
  else
	dv_l = 0;
  if((cm->sttype[v] == MR_st) ||
	 (cm->sttype[v] == IR_st) ||
	 (cm->sttype[v] == MP_st))
	dv_r = 1;
  else
	dv_r = 0;
  if(jmin[v] < (dv_l + dv_r))
	 jmin[v] = dv_l + dv_r;
  if(jmax[v] < (dv_l + dv_r))
	jmax[v] = dv_l + dv_r;
}
/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_state_step4_update_safe_holders
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_state_step4_update_safe_holders(int v, int n, int imin_v, int jmax_v, int *nss_max_imin,
				       int *nss_min_jmax)
{
  if(imin_v > nss_max_imin[n])
	nss_max_imin[n] = imin_v;
  if(jmax_v < nss_min_jmax[n])
	nss_min_jmax[n] = jmax_v;
}

/*****************************************************************************
 * EPN 12.21.05
 * Function: hmm2ij_state_step5_non_emitter_d0_hack
 *
 * Purpose:  cp9_HMM2ijBands_OLD*() function helper function.
 *
 *****************************************************************************/
void
hmm2ij_state_step5_non_emitter_d0_hack(int v, int imax_v, int *jmin)
{
  /* allow for possibility that d=0 for delete states*/
  if(jmin[v] <= imax_v && jmin[v] > 0)
	jmin[v]--;
  /* if imax = L, allow possibility for
  if(imax[v] == Limax_v && jmin[v] > 0)
  jmin[v]--;*/
}

/* Function: cp9_ShiftCMBands()
 *
 * Description: Given a CM with a valid cm->cp9b CP9 bands object
 *              calculated for a sequence in coordinates 1..i..j..L,
 *              subtract a fixed offset (i-1) from all CM positions
 *              in cp9b (cp9b->imin, cp9b->imax, cp9b->jmin, cp9b->jmax)
 *              so the bands will now pertain to the same hit if
 *              its coordinates were shifted to 1..j-i+1. This is used
 *              prior to alignment of a pre-defined hit from i..j
 *              using bands calculated when i..j was within its larger
 *              context of 1..i..j..L. During alignment hits always
 *              start at position 1.
 *
 *              Because only positions i..j are possible in the subsequent
 *              alignment, bands that allow residues before i or after
 *              j are tightened to only include within i..j. This will
 *              make states that were possible to reach only with residues
 *              before i or after j now impossible to reach.
 *
 *              Once all i and j bands are updated, ij2d_bands()
 *              is used to update the d bands.
 *
 *              NOTE: after calling this function cp9b will fail
 *              a cp9_ValidateBands() function call.
 *
 * Args:        CM - the CM, with a valid cm->cp9b CP9Bands_t object
 *              i  - first position of hit, this is the offset
 *              j  - final position of hit, used only to determine hit length
 * Returns: (void)
 */
void
cp9_ShiftCMBands(CM_t *cm, int i, int j, int do_trunc)
{
  int v;
  int ip = i-1;
  int Lp = j-i+1;
  int sd, sdl, sdr;
  int min_i, max_i, min_j, max_j;

#if eslDEBUGLEVEL >= 1
  printf("cp9_ShiftCMBands(), i: %d j: %d Lp: %d\n", i, j, Lp);
#endif

  for(v = 0; v < cm->M; v++) {
	sd  = StateDelta(cm->sttype[v]);
	sdl = StateLeftDelta(cm->sttype[v]);
	sdr = StateRightDelta(cm->sttype[v]);
	if(cm->cp9b->imin[v] > 0) { /* state is currently possible to reach */
	  min_i = 1;
	  max_i = do_trunc ? Lp+1-ESL_MAX(sdl, sdr) : Lp+1-sd;
	  /* careful! if do_trunc, d can be 1 for MP states, so i can be
	   * at most Lp. Note: d can't be 0 for ML/IL in R mode, MR/IR in
	   * L mode even though you might think it could be. We'll always
	   * do a truncated begin with d=1 for L,R marginal alignments.
	   *
	   * If ! do_trunc, then d must be at least sd for all states, hence
	   * the max i of Lp+1-sd.
	   *
	   * This is bug i37, one of the two bugs in 1.1rc2, which previously
	   * had this as 'max_i = Lp'.
	   */

	  min_j = do_trunc ? ESL_MAX(sdl, sdr) : sd;
	  max_j = ESL_MAX(Lp, min_j);
	  /* if (do_trunc) d can be 1 for MP states, this is why we use
	   * ESL_MAX() call for min_j above.  Note: d can't be 0 for ML/IL
	   * in R mode, MR/IR in L mode even though you might think it
	   * could be. We'll always do a truncated begin with d=1 for L,R
	   * marginal alignments. */

	  cm->cp9b->imin[v] = ESL_MAX(cm->cp9b->imin[v] - ip, min_i);
	  cm->cp9b->imax[v] = ESL_MIN(cm->cp9b->imax[v] - ip, max_i);

	  cm->cp9b->jmin[v] = ESL_MAX(cm->cp9b->jmin[v] - ip, min_j);
	  cm->cp9b->jmax[v] = ESL_MIN(cm->cp9b->jmax[v] - ip, max_j);

	  if(cm->cp9b->imax[v] <  min_i || cm->cp9b->jmax[v] < min_j ||
	 cm->cp9b->imin[v] >  max_i || cm->cp9b->jmin[v] > max_j) {
	/* this state is now impossible to reach */
	cm->cp9b->imin[v] = cm->cp9b->jmin[v] = -1;
	cm->cp9b->imax[v] = cm->cp9b->jmax[v] = -2;
	  }
	}
  }
  ij2d_bands(cm, Lp, cm->cp9b->imin, cm->cp9b->imax, cm->cp9b->jmin, cm->cp9b->jmax, cm->cp9b->hdmin, cm->cp9b->hdmax, do_trunc, 0);
  /* Note that this will not update hdmin bands that are no longer within jmin..jmax, that's okay */

  return;
}

/* Function: cp9_CloneBands()
 *
 * Description: Clone a CP9Bands_t *cp9b object and return it.
 *
 * Args:    cp9b - the CP9Bands_t object to clone
 *
 * Returns: the clone CP9Bands_t object.
 */
CP9Bands_t *
cp9_CloneBands(CP9Bands_t *src_cp9b, char *errbuf)
{
  int status;
  CP9Bands_t *dest_cp9b = NULL;
  dest_cp9b = AllocCP9Bands(src_cp9b->cm_M, src_cp9b->hmm_M);

  esl_vec_ICopy(src_cp9b->pn_min_m,  src_cp9b->hmm_M+1, dest_cp9b->pn_min_m);
  esl_vec_ICopy(src_cp9b->pn_max_m,  src_cp9b->hmm_M+1, dest_cp9b->pn_max_m);
  esl_vec_ICopy(src_cp9b->pn_min_i,  src_cp9b->hmm_M+1, dest_cp9b->pn_min_i);
  esl_vec_ICopy(src_cp9b->pn_max_i,  src_cp9b->hmm_M+1, dest_cp9b->pn_max_i);
  esl_vec_ICopy(src_cp9b->pn_min_d,  src_cp9b->hmm_M+1, dest_cp9b->pn_min_d);
  esl_vec_ICopy(src_cp9b->pn_max_d,  src_cp9b->hmm_M+1, dest_cp9b->pn_max_d);
  esl_vec_ICopy(src_cp9b->isum_pn_m, src_cp9b->hmm_M+1, dest_cp9b->isum_pn_m);
  esl_vec_ICopy(src_cp9b->isum_pn_i, src_cp9b->hmm_M+1, dest_cp9b->isum_pn_i);
  esl_vec_ICopy(src_cp9b->isum_pn_d, src_cp9b->hmm_M+1, dest_cp9b->isum_pn_d);

  dest_cp9b->sp1 = src_cp9b->sp1;
  dest_cp9b->ep1 = src_cp9b->ep1;
  dest_cp9b->sp2 = src_cp9b->sp2;
  dest_cp9b->ep2 = src_cp9b->ep2;

  dest_cp9b->thresh1 = src_cp9b->thresh1;
  dest_cp9b->thresh2 = src_cp9b->thresh2;

  dest_cp9b->Rmarg_imin = src_cp9b->Rmarg_imin;
  dest_cp9b->Rmarg_imax = src_cp9b->Rmarg_imax;
  dest_cp9b->Lmarg_jmin = src_cp9b->Lmarg_jmin;
  dest_cp9b->Lmarg_jmax = src_cp9b->Lmarg_jmax;

  esl_vec_ICopy(src_cp9b->Jvalid, (src_cp9b->cm_M+1), dest_cp9b->Jvalid);
  esl_vec_ICopy(src_cp9b->Lvalid, (src_cp9b->cm_M+1), dest_cp9b->Lvalid);
  esl_vec_ICopy(src_cp9b->Rvalid, (src_cp9b->cm_M+1), dest_cp9b->Rvalid);
  esl_vec_ICopy(src_cp9b->Tvalid, (src_cp9b->cm_M+1), dest_cp9b->Tvalid);

  esl_vec_ICopy(src_cp9b->imin, src_cp9b->cm_M, dest_cp9b->imin);
  esl_vec_ICopy(src_cp9b->imax, src_cp9b->cm_M, dest_cp9b->imax);
  esl_vec_ICopy(src_cp9b->jmin, src_cp9b->cm_M, dest_cp9b->jmin);
  esl_vec_ICopy(src_cp9b->jmax, src_cp9b->cm_M, dest_cp9b->jmax);

  if(src_cp9b->hd_alloced > 0) {
	/* set hdmin, hdmax ptrs and hd_needed and hd_alloced (all set in cp9GrowHDBands()) */
	if((status = cp9_GrowHDBands(dest_cp9b, errbuf)) != eslOK) goto ERROR;
	esl_vec_ICopy(src_cp9b->hdmin_mem, dest_cp9b->hd_alloced, dest_cp9b->hdmin_mem);
	esl_vec_ICopy(src_cp9b->hdmax_mem, dest_cp9b->hd_alloced, dest_cp9b->hdmax_mem);
  }

  esl_vec_ICopy(src_cp9b->safe_hdmin, src_cp9b->cm_M, dest_cp9b->safe_hdmin);
  esl_vec_ICopy(src_cp9b->safe_hdmax, src_cp9b->cm_M, dest_cp9b->safe_hdmax);

  dest_cp9b->tau = src_cp9b->tau;

  return dest_cp9b;

 ERROR:
  if(dest_cp9b != NULL) FreeCP9Bands(dest_cp9b);
  return NULL;
}

/* Function: cp9_PredictStartAndEndPositions()
 * Date:     EPN, Tue Sep  6 11:43:18 2011
 *
 * Purpose: Given a filled HMM posterior matrix and a CP9Bands_t
 *          object with valid pn_{min,max}{m,i,d} bands, determine the
 *          first and final HMM nodes that have a probability of being
 *          occupied that exceeds <cp9b->thresh1> and <cp9b->thresh2>.
 *          Store these four values in:
 *          <cp9b->sp1>: minimum position that might be used       (p > cp9b->thresh1, typically 0.01)
 *          <cp9b->sp2>: minimum position that will likely be used (p > cp9b->thresh2, typically 0.98)
 *          <cp9b->ep1>: maximum position that might be used       (p > cp9b->thresh1, typically 0.01)
 *          <cp9b->ep2>: maximum position that will likely be used (p > cp9b->thresh2, typically 0.98)
 *
 *          If no HMM node has an occupancy probability that exceeds
 *          <cp9b->thresh2> then sp2 and ep2 are set as out-of-bounds
 *          values M+1 and 0 respectively.
 *
 *          If no HMM node has an occupancy probability that exceeds
 *          <cp9b->thresh1> then sp1 and ep1 are set as out-of-bounds
 *          values M+1 and 0 respectively, though this should be
 *          very rare.
 *
 *          Using out-of-bounds values means we can't get any
 *          information about where the alignment starts and ends from
 *          the HMM. This has the effect that in a downstream call to
 *          cp9_MarginalCandidatesFromStartEndPositions() all marginal
 *          modes will be possible for all states and the eventual
 *          alignment will essentially mimic a non-banded one.
 *
 *          Also determine the CM bands on i and j that
 *          will be used to allow for marginal alignments,
 *          store these in <cp9b->{L,R}marg{i,j}_{min,max}.
 *
 * CP9_MX pmx:      DP matrix for posteriors, already calc'ed
 * CP9Bands_t cp9b: the cp9 bands
 * int i0           start of target subsequence (often 1, beginning of dsq)
 * int j0           end of target subsequence (often L, end of dsq)
 *
 * Returns: void
 *
 * xref: ELN2 notebook, p.146-147; ~nawrockie/notebook/11_0816_inf_banded_trcyk/00LOG
 */
void
cp9_PredictStartAndEndPositions(CP9_MX *pmx, CP9Bands_t *cp9b, int i0, int j0)
{
  int i;
  int k;                                  /* counter over nodes of the model */
  int L = j0-i0+1;                        /* length of sequence */
  int   iocc;       /* occupancy probability, scaled int form */
  float pocc;       /* occupancy probability, probability form */

  /* Calculate minimum start positions: */
  k = 1;
  cp9b->sp1 = cp9b->sp2 = -1;
  while(k <= cp9b->hmm_M && (cp9b->sp1 == -1 || cp9b->sp2 == -1)) {
	if(cp9b->pn_min_m[k] == -1 && cp9b->pn_min_i[k] == -1 && cp9b->pn_min_d[k] == -1) {
	  /*printf("k: %4d pocc IRRELEVANT (k unreachable, skipping)\n", k);*/
	  k++;
	  /* M, I, D states in node k are unreachable (no posterior cells had more than
	   * cm->tau probability mass), k won't be our sp1 or sp2 */
	}
	else {
	  iocc = -INFTY;
	  for(i = 0; i <= L; i++) {
	iocc = ILogsum(iocc, ILogsum(pmx->mmx[i][k], pmx->dmx[i][k]));
	  }
	  pocc = Score2Prob(iocc, 1.);
	  /*printf("k: %4d pocc: %.4f\n", k, pocc);*/
	  if((cp9b->sp1 == -1) && (pocc > cp9b->thresh1)) cp9b->sp1 = k;
	  if((cp9b->sp2 == -1) && (pocc > cp9b->thresh2)) cp9b->sp2 = k;
	  k++;
	}
  }
  if(k == cp9b->hmm_M+1) {
	if(cp9b->sp1 == -1) { cp9b->sp1 = cp9b->hmm_M+1; } /* no node k has occupancy > thresh1, set as out-of-bounds value M+1 */
	if(cp9b->sp2 == -1) { cp9b->sp2 = cp9b->hmm_M+1; } /* no node k has occupancy > thresh2,  set as out-of-bounds value M+1 */
  }

  /* Calculate maximum end positions: */
  if((cp9b->sp1 == cp9b->hmm_M+1) &&
	 (cp9b->sp2 == cp9b->hmm_M+1)) {
	/* we already know that there's no nodes that satisfy either thresh1 or thresh2, we can save time here */
	cp9b->ep1 = 0;
	cp9b->ep2 = 0;
  }
  else {
	cp9b->ep1 = cp9b->ep2 = -1;
	k = cp9b->hmm_M;
	while(k >= 1 && (cp9b->ep1 == -1 || cp9b->ep2 == -1)) {
	  if(cp9b->pn_min_m[k] == -1 && cp9b->pn_min_i[k] == -1 && cp9b->pn_min_d[k] == -1) {
	/*printf("k: %4d pocc IRRELEVANT (k unreachable, skipping)\n", k);*/
	k--;
	/* M, I, D states in node k are unreachable (no posterior cells had more than
	 * cm->tau probability mass), k won't be our ep1 or ep2 */
	  }
	  else {
	iocc = -INFTY;
	for(i = 0; i <= L; i++) {
	  iocc = ILogsum(iocc, ILogsum(pmx->mmx[i][k], pmx->dmx[i][k]));
	}
	pocc = Score2Prob(iocc, 1.);
	/*printf("k: %4d pocc: %.4f\n", k, pocc);*/
	if((cp9b->ep1 == -1) && (pocc > cp9b->thresh1)) cp9b->ep1 = k;
	if((cp9b->ep2 == -1) && (pocc > cp9b->thresh2)) cp9b->ep2 = k;
	k--;
	  }
	}
	if(k == 0) {
	  if(cp9b->ep1 == -1) { cp9b->ep1 = 0; } /* no node k has occupancy > thresh1, set as out-of-bounds value 0 */
	  if(cp9b->ep2 == -1) { cp9b->ep2 = 0; } /* no node k has occupancy > thresh2, set as out-of-bounds value 0 */
	}
  }

  /* determine cp9b->{R,L}marg_{i,j}{min,max}, the i and j bands that will be used to allow for marginal left (Lmarg_j{min,max}
   * and marginal right (Rmarg_i{min,max} alignment. */
   /* set cp9b->Rmarg_imin */
  if(cp9b->sp1 == cp9b->hmm_M+1) { cp9b->Rmarg_imin = i0; }
  else {
	cp9b->Rmarg_imin = INT_MAX;
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_min_m[cp9b->sp1] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_m[cp9b->sp1]);
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_min_i[cp9b->sp1] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_i[cp9b->sp1]);
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_min_d[cp9b->sp1] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_d[cp9b->sp1]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_min_m[cp9b->sp2] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_m[cp9b->sp2]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_min_i[cp9b->sp2] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_i[cp9b->sp2]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_min_d[cp9b->sp2] >= 0) cp9b->Rmarg_imin = ESL_MIN(cp9b->Rmarg_imin, cp9b->pn_min_d[cp9b->sp2]);
	if(cp9b->Rmarg_imin == INT_MAX || cp9b->sp1 == (cp9b->hmm_M+1) || cp9b->sp2 == (cp9b->hmm_M+1)) cp9b->Rmarg_imin = i0;
	cp9b->Rmarg_imin = ESL_MAX(i0,   cp9b->Rmarg_imin); /* i can't be less than i0 */
	cp9b->Rmarg_imin = ESL_MIN(j0+1, cp9b->Rmarg_imin); /* i can't be more than j0+1 */
  }

  /* set cp9b->Rmarg_imax */
  if(cp9b->sp1 == cp9b->hmm_M+1) { cp9b->Rmarg_imax = j0; }
  else {
	cp9b->Rmarg_imax = INT_MIN;
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_max_m[cp9b->sp1] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_m[cp9b->sp1]);
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_max_i[cp9b->sp1] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_i[cp9b->sp1]);
	if(cp9b->sp1 != (cp9b->hmm_M+1) && cp9b->pn_max_d[cp9b->sp1] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_d[cp9b->sp1]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_max_m[cp9b->sp2] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_m[cp9b->sp2]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_max_i[cp9b->sp2] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_i[cp9b->sp2]);
	if(cp9b->sp2 != (cp9b->hmm_M+1) && cp9b->pn_max_d[cp9b->sp2] >= 0) cp9b->Rmarg_imax = ESL_MAX(cp9b->Rmarg_imax, cp9b->pn_max_d[cp9b->sp2]);
	if(cp9b->Rmarg_imax == INT_MIN || cp9b->sp1 == (cp9b->hmm_M+1) || cp9b->sp2 == (cp9b->hmm_M+1)) cp9b->Rmarg_imax = j0+1;
	cp9b->Rmarg_imax = ESL_MAX(i0,   cp9b->Rmarg_imax); /* i can't be less than i0 */
	cp9b->Rmarg_imax = ESL_MIN(j0+1, cp9b->Rmarg_imax); /* i can't be more than j0+1 */
  }

  /* set cp9b->Lmarg_jmin */
  if(cp9b->ep1 == 0) { cp9b->Lmarg_jmin = i0-1; }
  else {
	cp9b->Lmarg_jmin = INT_MAX;
	if(cp9b->ep1 != 0 && cp9b->pn_min_m[cp9b->ep1] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_m[cp9b->ep1]);
	if(cp9b->ep1 != 0 && cp9b->pn_min_i[cp9b->ep1] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_i[cp9b->ep1]);
	if(cp9b->ep1 != 0 && cp9b->pn_min_d[cp9b->ep1] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_d[cp9b->ep1]-1); /* off-by-one with deletes in HMM vs CM */
	if(cp9b->ep2 != 0 && cp9b->pn_min_m[cp9b->ep2] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_m[cp9b->ep2]);
	if(cp9b->ep2 != 0 && cp9b->pn_min_i[cp9b->ep2] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_i[cp9b->ep2]);
	if(cp9b->ep2 != 0 && cp9b->pn_min_d[cp9b->ep2] >= 0) cp9b->Lmarg_jmin = ESL_MIN(cp9b->Lmarg_jmin, cp9b->pn_min_d[cp9b->ep2]-1); /* off-by-one with deletes in HMM vs CM */
	if(cp9b->Lmarg_jmin == INT_MAX || cp9b->ep1 == 0 || cp9b->ep2 == 0) cp9b->Lmarg_jmin = i0-1;
	cp9b->Lmarg_jmin = ESL_MAX(i0-1, cp9b->Lmarg_jmin); /* j can't be less than i0-1 */
	cp9b->Lmarg_jmin = ESL_MIN(j0,   cp9b->Lmarg_jmin); /* j can't be more than j0 */
  }

  /* set cp9b->Lmarg_jmax */
  if(cp9b->ep1 == 0) { cp9b->Lmarg_jmax = j0; }
  else {
	cp9b->Lmarg_jmax = INT_MIN;
	if(cp9b->ep1 != 0 && cp9b->pn_max_m[cp9b->ep1] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_m[cp9b->ep1]);
	if(cp9b->ep1 != 0 && cp9b->pn_max_i[cp9b->ep1] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_i[cp9b->ep1]);
	if(cp9b->ep1 != 0 && cp9b->pn_max_d[cp9b->ep1] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_d[cp9b->ep1]-1); /* off-by-one with deletes in HMM vs CM */
	if(cp9b->ep2 != 0 && cp9b->pn_max_m[cp9b->ep2] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_m[cp9b->ep2]);
	if(cp9b->ep2 != 0 && cp9b->pn_max_i[cp9b->ep2] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_i[cp9b->ep2]);
	if(cp9b->ep2 != 0 && cp9b->pn_max_d[cp9b->ep2] >= 0) cp9b->Lmarg_jmax = ESL_MAX(cp9b->Lmarg_jmax, cp9b->pn_max_d[cp9b->ep2]-1); /* off-by-one with deletes in HMM vs CM */
	if(cp9b->Lmarg_jmax == INT_MIN || cp9b->ep1 == 0 || cp9b->ep2 == 0) cp9b->Lmarg_jmax = j0;
	cp9b->Lmarg_jmax = ESL_MAX(i0-1, cp9b->Lmarg_jmax); /* j can't be less than i0-1 */
	cp9b->Lmarg_jmax = ESL_MIN(j0,   cp9b->Lmarg_jmax); /* j can't be more than j0 */
  }

#if 0
  printf("HEYA Returning from cp9_PredictStartAndEndPositions():\n\t");
	printf("sp1: %4d\n\t", cp9b->sp1);
	printf("sp2: %4d\n\t", cp9b->sp2);
	printf("ep2: %4d\n\t", cp9b->ep2);
	printf("ep1: %4d\n\t", cp9b->ep1);
	printf("Ljn: %4d\n\t", cp9b->Lmarg_jmin);
	printf("Ljx: %4d\n\t", cp9b->Lmarg_jmax);
	printf("Rin: %4d\n\t", cp9b->Rmarg_imin);
	printf("Rix: %4d\n\n", cp9b->Rmarg_imax);
#endif

  return;
}

/* Function: cp9_MarginalCandidatesFromStartEndPositions()
 * Date:     EPN, Tue Sep  6 14:50:16 2011
 *
 * Purpose: Given a CP9Bands_t object with valid sp1, sp2, ep1, and
 *          ep2 values from cp9_PredictStartAndEndPositions(),
 *          determine for each CM state v, whether a joint (J), left
 *          marginal (L) right marginal (R), or terminal marginal
 *          alignment that includes v should be allowed. For any
 *          disallowed type of alignment we will be able to skip the
 *          corresponding calculations in a trCYK/trInside/trOutside
 *          DP recursion.  And we won't have to allocate memory for
 *          that state in the corresponding (J,L,R,T) DP matrix.
 *
 *          We can determine from passed-in <pass_idx>, which type of
 *          marginal alignments will be allowed. If L alignments
 *          are not allowed, Lvalid[] will be FALSE for all v.
 *          Likewise for R alignments and Rvalid[] and T alignments
 *          and Tvalid[].
 *
 * Args:      cm       - the model
 *            cp9b     - the cp9 bands
 *            pass_idx - the pipeline pass index we're on, dictates
 *                       which modes of marginal alns to allow
 *            errbuf   - for error messages
 *
 * Returns: eslOK on success; eslEINVAL if pass_idx is invalid (errbuf filled).
 *
 * xref: ELN2 notebook, p.146-147; ~nawrockie/notebook/11_0816_inf_banded_trcyk/00LOG
 */
int
cp9_MarginalCandidatesFromStartEndPositions(CM_t *cm, CP9Bands_t *cp9b, int pass_idx, char *errbuf)
{
  int status;
  int v;
  int nd;
  int lpos = 1;
  int rpos = cm->clen;
  int allow_L, allow_R, allow_T; /* will we allow L, R, and T alignments? */

  if((status = cm_TrFillFromPassIdx(pass_idx, &allow_L, &allow_R, &allow_T)) != eslOK) ESL_FAIL(status, errbuf, "cp9_MarginalCandidatesFromStartEndPositions(), unexpected pass idx: %d", pass_idx);

  for(v = 0; v < cp9b->cm_M; v++) {
	nd = cm->ndidx[v];
	/* Careful, emitmap is off-by-one for our purposes for lpos if v is not MATP_MP or MATL_ML, and rpos if v is not MATP_MP or MATR_MR */
	lpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATL_nd) ? cm->emap->lpos[nd] : cm->emap->lpos[nd]+1;
	rpos = (cm->ndtype[nd] == MATP_nd || cm->ndtype[nd] == MATR_nd) ? cm->emap->rpos[nd] : cm->emap->rpos[nd]-1;

	/* below: 'possibly' means probability > cp9b->thresh1 (typically 0.01) */
	/*        'probably' means probability > cp9b->thresh2 (typically 0.98) */

	/* Jvalid if both lpos and rpos are possibly used */
	cp9b->Jvalid[v] = ((lpos >= cp9b->sp1) && (rpos <= cp9b->ep1)) ? TRUE : FALSE;

	/* Lvalid if lpos is possibly used and rpos is possibly not used */
	cp9b->Lvalid[v] = (allow_L && (lpos >= cp9b->sp1 && lpos <= cp9b->ep1) && (rpos > cp9b->ep2)) ? TRUE : FALSE;

	/* Rvalid if rpos is possibly used and lpos is possibly not used */
	cp9b->Rvalid[v] = (allow_R && (rpos <= cp9b->ep1 && rpos >= cp9b->sp1) && (lpos < cp9b->sp2)) ? TRUE : FALSE;

	if(cm->sttype[v] == B_st) {
	  /* Tvalid if lpos and rpos are possibly not used */
	  cp9b->Tvalid[v] = (allow_T && (lpos < cp9b->sp2) && (rpos > cp9b->ep2)) ? TRUE : FALSE;
	}
	else {
	  cp9b->Tvalid[v] = FALSE;
	}
#if eslDEBUGLEVEL >= 1
	printf("v: %4d [%4d..%4d] %4s %2s %d%d%d%d\n", v, lpos, rpos, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]),
	   cp9b->Jvalid[v], cp9b->Lvalid[v], cp9b->Rvalid[v], cp9b->Tvalid[v]);
#endif
  }

  /* The ROOT_S state is special, all hits are rooted there, if we can do a
   * truncated {J,L,R,T} begin into v, we need to set do_{J,L,R,T}[0] to TRUE.
   */
  for(v = 0; v < cp9b->cm_M; v++) {
	switch(cm->sttype[v]) {
	case B_st:
	  if(cp9b->Jvalid[v]) cp9b->Jvalid[0] = TRUE;
	  if(cp9b->Lvalid[v]) cp9b->Lvalid[0] = TRUE;
	  if(cp9b->Rvalid[v]) cp9b->Rvalid[0] = TRUE;
	  if(cp9b->Tvalid[v]) cp9b->Tvalid[0] = TRUE;
	  break;
	case MP_st:
	  if(cp9b->Jvalid[v]) cp9b->Jvalid[0] = TRUE;
	  if(cp9b->Lvalid[v]) cp9b->Lvalid[0] = TRUE;
	  if(cp9b->Rvalid[v]) cp9b->Rvalid[0] = TRUE;
	  break;
	case ML_st:
	case IL_st:
	  if(cp9b->Jvalid[v]) cp9b->Jvalid[0] = TRUE;
	  if(cp9b->Lvalid[v]) cp9b->Lvalid[0] = TRUE;
	  break;
	case MR_st:
	case IR_st:
	  if(cp9b->Jvalid[v]) cp9b->Jvalid[0] = TRUE;
	  if(cp9b->Rvalid[v]) cp9b->Rvalid[0] = TRUE;
	  break;
	}
	if(cp9b->Jvalid[0] &&
	   cp9b->Lvalid[0] &&
	   cp9b->Rvalid[0] &&
	   cp9b->Tvalid[0]) {
	  v = cp9b->cm_M;
	}
  }

  /* The EL state is special, if local ends are on, make J, L and R
   * modes all valid. (We could only make those modes valid for
   * which there's a local end possible (e.g. make cm->M invalid for
   * R if R is not valid for any states), but empirically this is
   * rare, so I've opted to always allow all types to avoid allowing
   * the possibility that we turn {J,L,R}valid[cm->M] on and off
   * as we process seqs, thus avoiding all the possible complications
   * of doing that.
   */
  if(cm->flags & CMH_LOCAL_END) {
	cp9b->Jvalid[cm->M] = TRUE;
	cp9b->Lvalid[cm->M] = TRUE;
	cp9b->Rvalid[cm->M] = TRUE;
  }

  return eslOK;
}

/****************************************************************************
 * Debugging print functions
 *
 * cp9_DebugPrintHMMBands()
 * PrintDPCellsSaved_jd()
 *
 * Currently not compiled (#if 0'ed out) but saved for ref:
 * ijBandedTraceInfoDump()
 * ijdBandedTraceInfoDump()
 * debug_print_hd_bands()
 * debug_print_ij_bands()
 * debug_print_parsetree_and_ij_bands()
 *
 */
#if 0
static void         ijBandedTraceInfoDump(CM_t *cm, Parsetree_t *tr, int *imin, int *imax,
					  int *jmin, int *jmax, int debug_level);
static void         ijdBandedTraceInfoDump(CM_t *cm, Parsetree_t *tr, int *imin, int *imax,
					   int *jmin, int *jmax, int **hdmin, int **hdmax,
					   int debug_level);
static void         debug_print_hd_bands(CM_t *cm, int **hdmin, int **hdmax, int *jmin, int *jmax);
static void         debug_print_parsetree_and_ij_bands(FILE *fp, Parsetree_t *tr, CM_t *cm, ESL_DSQ *dsq, CP9Bands_t *cp9b);
static void         cp9_RelaxRootBandsForSearch(CM_t *cm, int i0, int j0, int *imin, int *imax, int *jmin, int *jmax);
#endif

/* EPN 12.18.05
 * cp9_DebugPrintHMMBands()
 * based loosely on: cmbuild.c's
 * Function: model_trace_info_dump
 *
 * Purpose:  Print out the bands derived from the posteriors for the
 *           insert and match states of each HMM node.
 *
 * Args:
 * FILE *ofp      - filehandle to print to (can by STDOUT)
 * int L          - length of sequence
 * CP9Bands_t     - the CP9 bands data structure
 * double hmm_bandp - fraction of probability mass allowed outside each band.
 * int debug_level  [0..3] tells the function what level of debugging print
 *                  statements to print.
 * Returns: (void)
 */

void
cp9_DebugPrintHMMBands(FILE *ofp, int L, CP9Bands_t *cp9b, double hmm_bandp, int debug_level)
{
  int M;
  int k;
  int cells_in_bands_m; /* number of cells within all the bands for match states*/
  int cells_in_bands_i; /* number of cells within all the bands for insert states*/
  int cells_in_bands_d; /* number of cells within all the bands for delete states*/
  int cells_in_bands_all; /* number of cells within all the bands for match and insert states*/
  int bw;               /* band width of current band */

  M = cp9b->hmm_M;
  cells_in_bands_m = cells_in_bands_i = cells_in_bands_d = cells_in_bands_all = 0;

  /* first print the bands on the match states */
  fprintf(ofp, "***********************************************************\n");
  if(debug_level > 0)
	fprintf(ofp, "printing hmm bands\n");
  fprintf(ofp, "hmm_bandp: %f\n", hmm_bandp);
  if(debug_level > 0)
	{
	  fprintf(ofp, "\n");
	  fprintf(ofp, "match states\n");
	}
  for(k = 0; k <= cp9b->hmm_M; k++)
	{
	  bw = (cp9b->pn_min_m[k] == -1) ? 0 : cp9b->pn_max_m[k] - cp9b->pn_min_m[k] + 1;
	  if(debug_level > 0 || debug_level == -1)
	fprintf(ofp, "M node: %3d | min %3d | max %3d | w %3d \n", k, cp9b->pn_min_m[k], cp9b->pn_max_m[k], bw);
	  cells_in_bands_m += bw;
	}
  if(debug_level > 0)
	fprintf(ofp, "\n");
  if(debug_level > 0)
	fprintf(ofp, "insert states\n");
  for(k = 0; k <= cp9b->hmm_M; k++)
	{
	  bw = (cp9b->pn_min_i[k] == -1) ? 0 : cp9b->pn_max_i[k] - cp9b->pn_min_i[k] + 1;
	  if(debug_level > 0 || debug_level == -1)
	fprintf(ofp, "I node: %3d | min %3d | max %3d | w %3d\n", k, cp9b->pn_min_i[k], cp9b->pn_max_i[k], bw);
	  cells_in_bands_i += bw;
	}
  if(debug_level > 0)
	fprintf(ofp, "\n");
  if(debug_level > 0)
	fprintf(ofp, "delete states\n");
  for(k = 1; k <= cp9b->hmm_M; k++)
	{
	  bw = (cp9b->pn_min_d[k] == -1) ? 0 : cp9b->pn_max_d[k] - cp9b->pn_min_d[k] + 1;
	  if(debug_level > 0 || debug_level == -1)
	fprintf(ofp, "D node: %3d | min %3d | max %3d | w %3d\n", k, cp9b->pn_min_d[k], cp9b->pn_max_d[k], bw);
	  cells_in_bands_d += bw;
	}
  if(debug_level > 0)
	{
	  fprintf(ofp, "\n");
	  printf("cells_in_bands_m : %d\n", cells_in_bands_m);
	  printf("cells_in_bands_i : %d\n", cells_in_bands_i);
	  printf("cells_in_bands_d : %d\n", cells_in_bands_d);
	}

  cells_in_bands_all = cells_in_bands_m + cells_in_bands_i + cells_in_bands_d;
  printf("fraction match excluded  : %f\n", (1 - ((float) cells_in_bands_m / (M * L))));
  printf("fraction insert excluded : %f\n", (1 - ((float) cells_in_bands_i / ((M-1) * L))));
  printf("fraction delete excluded : %f\n", (1 - ((float) cells_in_bands_d / ((M-1) * L))));
  printf("fraction total excluded  : %f\n", (1 - ((float) (cells_in_bands_all) / (((M-1) * L) + ((M-1) * L) + (M *L)))));
  fprintf(ofp, "***********************************************************\n");

}

/* Function: PrintDPCellsSaved_jd()
 * Prints out an estimate of the speed up due to j and d bands */
void
PrintDPCellsSaved_jd(CM_t *cm, int *jmin, int *jmax, int **hdmin, int **hdmax,
		     int W)
{
  int v;
  int j;
  int max;
  int64_t after, before;

  printf("Printing DP cells saved using j and d bands:\n");
  before = after = 0;
  for (v = 0; v < cm->M; v++)
	{
	  for(j = 0; j <= W; j++)
	if (cm->sttype[v] != E_st)
	  before += j + 1;
	  for(j = jmin[v]; j <= jmax[v]; j++)
	if (cm->sttype[v] != E_st)
	  {
	    max = (j < hdmax[v][j-jmin[v]]) ? j : hdmax[v][j-jmin[v]];
	    after += max - hdmin[v][j-jmin[v]] + 1;
	  }
	}
  printf("Before:  something like %" PRId64 "\n", before);
  printf("After:   something like %" PRId64 "\n", after);
  printf("Speedup: maybe %.2f fold\n\n", (double) before / (double) after);
}

/* Function: debug_print_ij_bands
 *
 * Purpose:  Print out i and j bands for all states v.
 *
 */
void
debug_print_ij_bands(CM_t *cm)
{
  int v;
  printf("%5s  %-7s    %5s  %5s    %5s  %5s  %4s\n", "v",     "type",    "imin",  "imax",  "jmin",  "jmax", "JLRT");
  printf("%5s  %-7s    %5s  %5s    %5s  %5s  %4s\n", "-----", "-------", "-----", "-----", "-----", "-----", "----");
  for(v = 0; v < cm->M; v++)
	printf("%5d  %-7s    %5d  %5d    %5d  %5d  %d%d%d%d\n", v, CMStateid(cm->stid[v]), cm->cp9b->imin[v], cm->cp9b->imax[v], cm->cp9b->jmin[v], cm->cp9b->jmax[v],
	   cm->cp9b->Jvalid[v], cm->cp9b->Lvalid[v], cm->cp9b->Rvalid[v], cm->cp9b->Tvalid[v]);
  return;
}

#if 0
/* EPN 11.03.05
 * Function: ijBandedTraceInfoDump()
 *
 * Purpose:  Experimental HMMERNAL function used in development.
 *           This function determines how close the
 *           trace was to the bands for i and j at each state in the trace,
 *           and prints out that information in differing levels
 *           of verbosity depending on an input parameter
 *           (debug_level).
 *
 * Args:    cm       - the CM (useful for determining which states are E states)
 *          tr       - the parsetree (trace)
 *          imin     - minimum i bound for each state v; [0..v..M-1]
 *          imax     - maximum i bound for each state v; [0..v..M-1]
 *          jmin     - minimum j bound for each state v; [0..v..M-1]
 *          jmax     - maximum j bound for each state v; [0..v..M-1]
 *          debug_level - level of verbosity
 * Returns: (void)
 */

void
ijBandedTraceInfoDump(CM_t *cm, Parsetree_t *tr, int *imin, int *imax,
		      int *jmin, int *jmax, int debug_level)
{
  int v, i, j, d, tpos;
  int imindiff;            /* i - imin[v] */
  int imaxdiff;            /* imax[v] - i */
  int jmindiff;            /* j - jmin[v] */
  int jmaxdiff;            /* jmax[v] - j */
  int imin_out;
  int imax_out;
  int jmin_out;
  int jmax_out;

  imin_out = 0;
  imax_out = 0;
  jmin_out = 0;
  jmax_out = 0;

  debug_level = 2;

  for (tpos = 0; tpos < tr->n; tpos++)
	{
	  v  = tr->state[tpos];
	  i = tr->emitl[tpos];
	  j = tr->emitr[tpos];
	  d = j-i+1;
	  imindiff = i-imin[v];
	  imaxdiff = imax[v]-i;
	  jmindiff = j-jmin[v];
	  jmaxdiff = jmax[v]-j;
	  if(cm->sttype[v] != E_st)
	{
	  if(imindiff < 0)
	    imin_out++;
	  if(imaxdiff < 0)
	    imax_out++;
	  if(jmindiff < 0)
	    jmin_out++;
	  if(jmaxdiff < 0)
	    jmax_out++;

	  if(debug_level > 1 || ((imindiff < 0) || (imaxdiff < 0) || (jmindiff < 0) || (jmaxdiff < 0)))
	    {
	      printf("v: %4d %-4s %-2s | d: %4d | i: %4d | in: %4d | ix: %4d | %3d | %3d |\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]), d, i, imin[v], imax[v], imindiff, imaxdiff);
	      printf("                          | j: %4d | jn: %4d | jx: %4d | %3d | %3d |\n", j, jmin[v], jmax[v], jmindiff, jmaxdiff);

	    }
	}
	  else if(cm->sttype[v] == E_st)
	{
	  if(debug_level > 1)
	    {
	      printf("v: %4d %-4s %-2s | d: %4d | i: %4d | in: %4d | ix: %4d | %3d | %3d |\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]), d, i, imin[v], imax[v], imindiff, imaxdiff);
	      printf("                          | j: %4d | jn: %4d | jx: %4d | %3d | %3d |\n", j, jmin[v], jmax[v], jmindiff, jmaxdiff);
	    }
	}
	}
  printf("\nimin out: %d\n", imin_out);
  printf("imax out: %d\n", imax_out);
  printf("jmin out: %d\n", jmin_out);
  printf("jmax out: %d\n", jmax_out);

  if((imin_out + imax_out + jmin_out + jmax_out) > 0)
	{
	  printf("ERROR, some of the i and j bands are going to prevent optimal alignment. Sorry.\n");
	}

  return;
}

/* EPN 11.03.05
 * Function: ijdBandedTraceInfoDump()
 *
 * Purpose:  Experimental HMMERNAL function used in development.
 *           This function determines how close the
 *           trace was to the bands for i and j and d at each state in the trace,
 *           and prints out that information in differing levels
 *           of verbosity depending on an input parameter
 *           (debug_level).
 *
 * Args:    cm       - the CM (useful for determining which states are E states)
 *          tr       - the parsetree (trace)
 *          imin     - minimum i bound for each state v; [0..v..M-1]
 *          imax     - maximum i bound for each state v; [0..v..M-1]
 *          jmin     - minimum j bound for each state v; [0..v..M-1]
 *          jmax     - maximum j bound for each state v; [0..v..M-1]
 *          hdmin    - minimum d bound for each state v and offset j;
 *                     [0..v..M-1][0..(jmax[v]-jmin[v])]
 *          hdmax    - maximum d bound for each state v and offset j;
 *                     [0..v..M-1][0..(jmax[v]-jmin[v])]
 *          debug_level - level of verbosity
 * Returns: (void)
 */

void
ijdBandedTraceInfoDump(CM_t *cm, Parsetree_t *tr, int *imin, int *imax,
		       int *jmin, int *jmax, int **hdmin, int **hdmax, int debug_level)
{
  int v, i, j, d, tpos;
  int imindiff;            /* i - imin[v] */
  int imaxdiff;            /* imax[v] - i */
  int jmindiff;            /* j - jmin[v] */
  int jmaxdiff;            /* jmax[v] - j */
  int hdmindiff;           /* d - hdmin[v][j] */
  int hdmaxdiff;           /* hdmax[v][j] - d */

  int imin_out;
  int imax_out;
  int jmin_out;
  int jmax_out;
  int hdmin_out;
  int hdmax_out;
  int local_used;

  imin_out = 0;
  imax_out = 0;
  jmin_out = 0;
  jmax_out = 0;
  hdmin_out = 0;
  hdmax_out = 0;
  local_used = 0;

  debug_level = 2;

  for (tpos = 0; tpos < tr->n; tpos++)
	{
	  v  = tr->state[tpos];
	  i = tr->emitl[tpos];
	  j = tr->emitr[tpos];
	  d = j-i+1;
	  if(cm->sttype[v] == EL_st) /*END LOCAL state*/
	{
	  if(debug_level > 1)
	    {
	      printf("v: %4d NA   %-2s (  NA) | d: %4d | i: %4d | in: NA    | ix: NA   | NA  | NA  |\n", v, Statetype(cm->sttype[v]), d, i);
	      printf("                                 | j: %4d | jn: NA   | jx: NA  | NA  | NA  |\n", j);
	      printf("                                 | d: %4d | dn: NA   | dx: NA   | NA  | NA  |\n", d);

	      local_used++;
	    }
	}
	  else
	{
	  imindiff = i-imin[v];
	  imaxdiff = imax[v]-i;
	  jmindiff = j-jmin[v];
	  jmaxdiff = jmax[v]-j;
	  if(j >= jmin[v] && j <= jmax[v])
	    {
	      hdmindiff = d - hdmin[v][j-jmin[v]];
	      hdmaxdiff = hdmax[v][j-jmin[v]] - d;
	    }
	  else
	    {
	      hdmindiff = -1000;
	      hdmaxdiff = -1000;
	    }
	  if(imindiff < 0)
	    imin_out++;
	  if(imaxdiff < 0)
	    imax_out++;
	  if(jmindiff < 0)
	    jmin_out++;
	  if(jmaxdiff < 0)
	    jmax_out++;
	  if(hdmindiff < 0)
	    hdmin_out++;
	  if(hdmaxdiff < 0)
	    hdmax_out++;

	  if(debug_level > 1 || ((imindiff < 0) || (imaxdiff < 0) || (jmindiff < 0) || (jmaxdiff < 0) ||
				 (hdmindiff < 0) || (hdmaxdiff < 0)))
	    {
	      printf("v: %4d %-4s %-2s (%4d) | d: %4d | i: %4d | in: %4d | ix: %4d | %3d | %3d |\n", v, Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]), cm->ndidx[v], d, i, imin[v], imax[v], imindiff, imaxdiff);
	      printf("                                 | j: %4d | jn: %4d | jx: %4d | %3d | %3d |\n", j, jmin[v], jmax[v], jmindiff, jmaxdiff);
	      if(j >= jmin[v] && j <= jmax[v])
		{
		  printf("                                 | d: %4d | dn: %4d | dx: %4d | %3d | %3d |\n", d, hdmin[v][j-jmin[v]], hdmax[v][j-jmin[v]], hdmindiff, hdmaxdiff);
		}
	      else
		{
		  printf("                                 | d: %4d | dn: jout | dx: jout | %3d | %3d |\n", d, hdmindiff, hdmaxdiff);
		}
	    }
	}
	}
  printf("\nimin out  : %d\n", imin_out);
  printf("imax out  : %d\n", imax_out);
  printf("jmin out  : %d\n", jmin_out);
  printf("jmax out  : %d\n", jmax_out);
  printf("hdmin out : %d\n", hdmin_out);
  printf("hdmax out : %d\n", hdmax_out);
  printf("local used: %d\n", local_used);

  if((imin_out + imax_out + jmin_out + jmax_out) > 0)
	{
	  printf("ERROR, some of the i and j bands are going to prevent optimal alignment. Sorry.\n");
	}

  return;
}

/* EPN 01.18.06
 * Function: debug_print_hd_bands
 *
 * Purpose:  Print out the v and j dependent hd bands.
 */
void
debug_print_hd_bands(CM_t *cm, int **hdmin, int **hdmax, int *jmin, int *jmax)
{
  int v, j;

  printf("\nPrinting hd bands :\n");
  printf("****************\n");
  for(v = 0; v < cm->M; v++)
   {
	 for(j = jmin[v]; j <= jmax[v]; j++)
	   {
	 printf("band v:%d j:%d n:%d %-4s %-2s min:%d max:%d\n", v, j, cm->ndidx[v], Nodetype(cm->ndtype[cm->ndidx[v]]), Statetype(cm->sttype[v]), hdmin[v][j-jmin[v]], hdmax[v][j-jmin[v]]);
	   }
	 printf("\n");
   }
  printf("****************\n\n");

  return;
}

/* Function: debug_print_parsetree_and_ij_bands()
 * Date:     EPN, Sun Jan 27 16:38:14 2008
 *
 * Purpose:  Print a parsetree a la ParseTreeDump() but supplement it
 *           with details on where the parsetree violates i and j bands
 *           (if at all) from a cp9bands data structure.
 *
 * Args:    fp    - FILE to write output to.
 *          tr    - parsetree to examine.
 *          cm    - model that was aligned to dsq to generate the parsetree
 *          dsq   - digitized sequence that was aligned to cm to generate the parsetree
 *          gamma - cumulative subsequence length probability distributions
 *                  used to generate the bands; from BandDistribution(); [0..v..M-1][0..W]
 *          W     - maximum window length W (gamma distributions range up to this)
 *          cp9b  - CP9 bands object with i and j bands
 *
 * Returns:  (void)
 */
void
debug_print_parsetree_and_ij_bands(FILE *fp, Parsetree_t *tr, CM_t *cm, ESL_DSQ *dsq, CP9Bands_t *cp9b)
{
  int   x;
  char  syml, symr;
  float tsc;
  float esc;
  int   v,y;
  char  mode;

  /* Contract check */
  if(dsq == NULL)  cm_Fail("In debug_print_parsetree_and_ij_bands(), dsq is NULL");

  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s   %5s %5s %5s    %5s %5s %5s\n",
	  " idx ", "emitl", "emitr", "state", " nxtl", " nxtr", " prv ", " tsc ", " esc ",
	  " imin", " imax", "idiff", "jmin", "jmax", "jdiff");
  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s   %5s %5s %5s    %5s %5s %5s\n",
	  "-----", "------", "------", "-------", "-----","-----", "-----","-----", "-----",
	  "-----", "-----", "-----", "-----", "-----", "-----");
  for (x = 0; x < tr->n; x++)
	{
	  v = tr->state[x];
	  mode = tr->mode[x];

	  /* Set syml, symr: one char representation of what we emit, or ' '.
	   * Set esc:        emission score, or 0.
	   * Only P, L, R states have emissions.
	   */
	  syml = symr = ' ';
	  esc = 0.;
	  if (cm->sttype[v] == MP_st) {
	if (mode == TRMODE_J || mode == TRMODE_L) syml = cm->abc->sym[dsq[tr->emitl[x]]];
	if (mode == TRMODE_J || mode == TRMODE_R) symr = cm->abc->sym[dsq[tr->emitr[x]]];
	if      (mode == TRMODE_J) esc = DegeneratePairScore(cm->abc, cm->esc[v], dsq[tr->emitl[x]], dsq[tr->emitr[x]]);
		else if (mode == TRMODE_L) esc = cm->lmesc[v][dsq[tr->emitl[x]]];
		else if (mode == TRMODE_R) esc = cm->rmesc[v][dsq[tr->emitr[x]]];
	  } else if ( (cm->sttype[v] == IL_st || cm->sttype[v] == ML_st) && (mode == TRMODE_J || mode == TRMODE_L) ) {
	syml = cm->abc->sym[dsq[tr->emitl[x]]];
	esc  = esl_abc_FAvgScore(cm->abc, dsq[tr->emitl[x]], cm->esc[v]);
	  } else if ( (cm->sttype[v] == IR_st || cm->sttype[v] == MR_st) && (mode == TRMODE_J || mode == TRMODE_R) ) {
	symr = cm->abc->sym[dsq[tr->emitr[x]]];
	esc  = esl_abc_FAvgScore(cm->abc, dsq[tr->emitr[x]], cm->esc[v]);
	  }

	  /* Set tsc: transition score, or 0.
	   * B, E, and the special EL state (M, local end) have no transitions.
	   */
	  tsc = 0.;
	  if (v != cm->M && cm->sttype[v] != B_st && cm->sttype[v] != E_st) {
	y = tr->state[tr->nxtl[x]];

		if (tr->nxtl[x] == -1)
		  ;
	else if (v == 0 && (cm->flags & CMH_LOCAL_BEGIN))
	  tsc = cm->beginsc[y];
	else if (y == cm->M) /* CMH_LOCAL_END is presumably set, else this wouldn't happen */
	  tsc = cm->endsc[v] + (cm->el_selfsc * (tr->emitr[x] - tr->emitl[x] + 1 - StateDelta(cm->sttype[v])));
	else 		/* y - cm->first[v] gives us the offset in the transition vector */
	  tsc = cm->tsc[v][y - cm->cfirst[v]];
	  }

	  /* Print the info line for this state
	   */
	  fprintf(fp, "%5d %5d%c %5d%c %5d%-2s %5d %5d %5d %5.2f %5.2f ",
	      x, tr->emitl[x], syml, tr->emitr[x], symr, tr->state[x],
	      Statetype(cm->sttype[v]), tr->nxtl[x], tr->nxtr[x], tr->prv[x], tsc, esc);
	  if(tr->emitl[x] < cp9b->imin[tr->state[x]]) {
	fprintf(fp, "%5d %5d %5d   ",
		cp9b->imin[tr->state[x]], cp9b->imax[tr->state[x]], (tr->emitl[x] - cp9b->imin[tr->state[x]]));
	  }
	  else if(tr->emitl[x] > cp9b->imax[tr->state[x]]) {
	fprintf(fp, "%5d %5d %5d   ",
		cp9b->imin[tr->state[x]], cp9b->imax[tr->state[x]], (tr->emitl[x] - cp9b->imax[tr->state[x]]));
	  }
	  else {
	fprintf(fp, "%5d %5d %5s   ",
		cp9b->imin[tr->state[x]], cp9b->imax[tr->state[x]], "");
	  }
	  if(tr->emitr[x] < cp9b->jmin[tr->state[x]]) {
	fprintf(fp, "%5d %5d %5d\n",
		cp9b->jmin[tr->state[x]], cp9b->jmax[tr->state[x]], (tr->emitr[x] - cp9b->jmin[tr->state[x]]));
	  }
	  else if(tr->emitr[x] > cp9b->jmax[tr->state[x]]) {
	fprintf(fp, "%5d %5d %5d\n",
		cp9b->jmin[tr->state[x]], cp9b->jmax[tr->state[x]], (tr->emitr[x] - cp9b->jmax[tr->state[x]]));
	  }
	  else {
	fprintf(fp, "%5d %5d %5s\n",
		cp9b->jmin[tr->state[x]], cp9b->jmax[tr->state[x]], "");
	  }
	}

  fprintf(fp, "%5s %6s %6s %7s %5s %5s %5s %5s %5s %5s %5s %5s %5s    %5s %5s %5s\n",
	  "-----", "------", "------", "-------", "-----","-----", "-----","-----", "-----",
	  "-----", "-----", "-----", "-----", "-----", "-----", "-----");

  fflush(fp);
}

/*********************************************************************
 * Function: cp9_RelaxRootBandsForSearch()
 *
 * Purpose:  In cp9_HMM2ijBands_OLD(), ROOT_S (state 0) sets imin[0]=imax[0]=i0,
 *           and jmin[0]=jmax[0]=j0, which is important for alignment,
 *           but during search enforces that the optimal alignment start
 *           at i0 and end at j0, but when searching we want to relax this
 *           requirement in case a higher scoring parse has different endpoints.
 *           See code for details.
 *
 * Args:
 * cm               the cm
 * i0               first position of seq
 * j0               last position of seq
 * int *imin        imin[v] = first position in band on i for state v
 * int *imax        imax[v] = last position in band on i for state v
 * int *jmin        jmin[v] = first position in band on j for state v
 * int *jmax        jmax[v] = last position in band on j for state v
 */
void
cp9_RelaxRootBandsForSearch(CM_t *cm, int i0, int j0, int *imin, int *imax, int *jmin, int *jmax)
{
  int y, yoffset;

  if(i0 == j0) return; /* this is a special vanishingly rare case, we've set otherwise illegal jmin, jmax values for MP states
			* b/c all MPs are impossible for a length 1 seq, do nothing in this case.
			*/
  /* look at all children y of ROOT_S (v == 0) and set:
   * imin[0] = min_y imin[y];
   * imax[0] = max_y imax[y];
   * jmin[0] = min_y jmin[y];
   * jmax[0] = max_y jmax[y];
   */
  /* First look at children of 0 (these probs will be 0. if local begins on, but it doesn't matter for our purposes here) */
  for (yoffset = 0; yoffset < cm->cnum[0]; yoffset++) {
	y = cm->cnum[0] + yoffset;
	imin[0] = ESL_MIN(imin[0], imin[y]);
	imax[0] = ESL_MAX(imax[0], imax[y]);
	jmin[0] = ESL_MIN(jmin[0], jmin[y]);
	jmax[0] = ESL_MAX(jmax[0], jmax[y]);
  }
  /* now for possible local begins */
  if(cm->flags & CMH_LOCAL_BEGIN) {
	for (y = 1; y < cm->M; y++) {
	  if(NOT_IMPOSSIBLE(cm->beginsc[y])) {
	imin[0] = ESL_MIN(imin[0], imin[y]);
	imax[0] = ESL_MAX(imax[0], imax[y]);
	jmin[0] = ESL_MIN(jmin[0], jmin[y]);
	jmax[0] = ESL_MAX(jmax[0], jmax[y]);
	  }
	}
  }
}

#endif

/*** End of inlined file: hmmband.c ***/


/*** Start of inlined file: logsum.c ***/
#include <math.h>
#include <assert.h>

static int   ilogsum_lookup[LOGSUM_TBL];
void
init_ilogsum(void)
{
  static int firsttime = TRUE;
  if (!firsttime)  return;
  firsttime = FALSE;

  int i;
  for (i = 0; i < LOGSUM_TBL; i++)
	ilogsum_lookup[i] = rint(INTSCALE * (sreLOG2(1.+sreEXP2((double) -i/INTSCALE))));
}

int
ILogsum(int s1, int s2)
{
  const int max = ESL_MAX(-INFTY, ESL_MAX(s1, s2));
  const int min = ESL_MIN(s1, s2);
  return  (min <= -INFTY || (max-min) >= LOGSUM_TBL) ? max : max + ilogsum_lookup[max-min];
}

/* guaranteed s1 >= -INFTY, s2 >= -INFTY */
int
ILogsumNI(int s1, int s2)
{
  ESL_DASSERT1((s1 > -INFTY));
  ESL_DASSERT1((s2 > -INFTY));
  /*assert(s1 > -INFTY);
	assert(s2 > -INFTY);*/

  const int max = ESL_MAX(s1, s2);
  const int min = ESL_MIN(s1, s2);
  return  ((max-min) >= LOGSUM_TBL) ? max : max + ilogsum_lookup[max-min];
  /* about 10% slower
	 if(s1 > s2)
	return  ((s1-s2) >= LOGSUM_TBL) ? s1 : s1 + ilogsum_lookup[s1-s2];
	else
	return  ((s2-s1) >= LOGSUM_TBL) ? s2 : s2 + ilogsum_lookup[s2-s1];
  */
}

/* guaranteed s1 >= -INFTY, s2 >= -INFTY */
int
ILogsumNI_diff(int s1a, int s1b, int s2a, int s2b, int db)
{
  /* db = s1b - s2b */
  ESL_DASSERT1((s1a > -INFTY));
  ESL_DASSERT1((s1b > -INFTY));
  ESL_DASSERT1((s2a > -INFTY));
  ESL_DASSERT1((s2b > -INFTY));
  /*const int d = s1a-s2a+db;
  if      (d >=  LOGSUM_TBL) return s1a + s1b;
  else if (d > 0)            return s1a + s1b + ilogsum_lookup[d];
  else if (d <= -LOGSUM_TBL) return s2a + s2b;
  else                       return s2a + s2b + ilogsum_lookup[-d];*/
  const int d = s1a-s2a+db;
  if(d > 0)
	return  (d >= LOGSUM_TBL) ? s1a + s1b : s1a + s1b + ilogsum_lookup[d];
  else
	return  (d <= LOGSUM_TBL) ? s2a + s2b : s2a + s2b + ilogsum_lookup[-d];
}

static float flogsum_lookup[LOGSUM_TBL];

void
FLogsumInit(void)
{
  static int firsttime = TRUE;
  if (!firsttime) return;
  firsttime = FALSE;

  int i;
  for (i = 0; i < LOGSUM_TBL; i++)
	flogsum_lookup[i] = sreLOG2(1. + sreEXP2((double) -i / INTSCALE));
  return;
}

float
LogSum2(float s1, float s2)
{
  const float max = ESL_MAX(s1, s2);
  const float min = ESL_MIN(s1, s2);
  return  (min == -eslINFINITY || (max-min) >= 23.f) ? max : max + flogsum_lookup[(int)((max-min)*INTSCALE)];
}

/* yes LogSum2 and FLogsum are identical, this is for backwards compatibility */
float
FLogsum(float s1, float s2)
{
  const float max = ESL_MAX(s1, s2);
  const float min = ESL_MIN(s1, s2);
#if 0
  return (min == -eslINFINITY || (max-min) >= 23.f) ? max : max + sreLOG2(1.0 + sreEXP2(min-max));  /* EPN: While debugging. Replaces logsum table with analytical calculation. Remember to remove! */
#endif
  return  (min == -eslINFINITY || (max-min) >= 23.f) ? max : max + flogsum_lookup[(int)((max-min)*INTSCALE)];
}

#if 0
/**********************************************************************************
 *                              OLD LOG SUM FUNCTIONS                             *
 **********************************************************************************/
/* Function: ILogsum()
 *
 * Purpose:  Return the scaled integer log probability of
 *           the sum of two probabilities p1 and p2, where
 *           p1 and p2 are also given as scaled log probabilities.
 *
 *           log(exp(p1)+exp(p2)) = p1 + log(1 + exp(p2-p1)) for p1 > p2
 *
 *           For speed, builds a lookup table the first time it's called.
 *           LOGSUM_TBL is set to 20000 by default, in config.h.
 *
 *           Because of the one-time initialization, we have to
 *           be careful in a multithreaded implementation... hence
 *           the use of pthread_once(), which forces us to put
 *           the initialization routine and the lookup table outside
 *           ILogsum(). (Thanks to Henry Gabb at Intel for pointing
 *           out this problem.)
 *
 * Args:     p1,p2 -- scaled integer log_2 probabilities to be summed
 *                    in probability space.
 *
 * Return:   scaled integer log_2 probability of the sum.
 */

static int ilogsum_lookup[LOGSUM_TBL];
static void
init_ilogsum(void)
{
  static int firsttime = 1;
  if (firsttime) return;
  firsttime = FALSE;

  int i;
  for (i = 0; i < LOGSUM_TBL; i++)
	ilogsum_lookup[i] = (int) (INTSCALE * 1.44269504 *
			       (log(1.+exp(0.69314718 * (float) -i/INTSCALE))));
}
int
ILogsum(int s1, int s2)
{
  if(s1 == -INFTY) return s2; /* EPN */
  if(s2 == -INFTY) return s1; /* EPN */

  const int diff = s1-s2;
  if      (diff >=  LOGSUM_TBL) return s1;
  else if (diff > 0)            return s1 + ilogsum_lookup[diff];
  else if (diff <= -LOGSUM_TBL) return s2;
  else                          return s2 + ilogsum_lookup[-diff];
}

/* guaranteed s1 >= -INFTY, p2 >= -INFTY */
int
ILogsumNI(int s1, int s2)
{
  ESL_DASSERT1((s1 >= -INFTY));
  ESL_DASSERT1((s2 >= -INFTY));
  const int diff = s1-s2;
  if      (diff >=  LOGSUM_TBL) return s1;
  else if (diff <= -LOGSUM_TBL) return s2;
  else if (diff > 0)            return s1 + ilogsum_lookup[diff];
  else                          return s2 + ilogsum_lookup[-diff];
}

/* Function: LogSum2()
 *
 * Purpose:  Returns the log_2 of the sum of two log_2 probabilities.
 *           log(exp(p1)+exp(p2)) = p1 + log(1 + exp(p2-p1)) for p1 > p2
 *           Note that this is in log_2 space.
 */
float
LogSum2(float p1, float p2)
{
  if (p1 > p2)
	return (p1-p2 > 50.) ? p1 : p1 + sreLOG2(1. + pow(2.,(p2-p1)));
  else
	return (p2-p1 > 50.) ? p2 : p2 + sreLOG2(1. + pow(2.,(p1-p2)));
}

#endif  /* #if 0 */

/*** End of inlined file: logsum.c ***/


/*** Start of inlined file: mpisupport.c ***/
#ifdef HAVE_MPI

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <mpi.h>


static int expinfo_MPIPackSize(ExpInfo_t *exp, MPI_Comm comm, int *ret_n);
static int expinfo_MPIPack(ExpInfo_t *exp, char *buf, int n, int *position, MPI_Comm comm);
static int expinfo_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, ExpInfo_t **ret_exp);

static int cm_hit_MPISend(CM_HIT *hit, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
static int cm_hit_MPIPackSize(CM_HIT *hit, MPI_Comm comm, int *ret_n);
static int cm_hit_MPIPack(CM_HIT *hit, char *buf, int n, int *pos, MPI_Comm comm);
static int cm_hit_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, CM_HIT *hit);
static int cm_hit_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, CM_HIT *hit);

/*****************************************************************
 * 1. Communicating a CM.
 *****************************************************************/

/* Function:  cm_master_MPIBcast()
 * Incept:    EPN, Wed May  9 17:24:53 2007
 *
 * Purpose:   Broadcasts CM <cm> from a master.
 *
 *            If <cm> is NULL, broadcasts a end-of-data signal, to
 *            tell workers to shut down.
 *
 */
int
cm_master_MPIBcast(CM_t *cm, char *errbuf, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   code;
  int   sz, n, pos;

  /* Figure out size */
  if (MPI_Pack_size(1, MPI_INT, comm, &n) != 0) ESL_XEXCEPTION(eslESYS, "mpi pack size failed");
  if (cm != NULL) {
	if ((status = cm_nonconfigured_MPIPackSize(cm, comm, &sz)) != eslOK) return status;
	n += sz;
  }

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Pack the status code and CM into the buffer */
  pos  = 0;
  code = (cm == NULL) ? eslEOD : eslOK;
  if (MPI_Pack(&code, 1, MPI_INT, *buf, n, &pos, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi pack failed");
  if (cm != NULL) {
	if ((status = cm_nonconfigured_MPIPack(cm, errbuf, *buf, n, &pos, comm)) != eslOK) return status;
  }

  /* Broadcast the size of the packed CM */
  if (MPI_Bcast(&n, 1, MPI_INT, 0, MPI_COMM_WORLD) != 0) ESL_EXCEPTION(eslESYS, "mpi broadcast failed");
  /* Broadcast the packed CM */
  if (MPI_Bcast (*buf, n, MPI_PACKED, 0, MPI_COMM_WORLD) != 0) ESL_EXCEPTION(eslESYS, "mpi broadcast failed");
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_worker_MPIBcast()
 * Incept:    EPN, Mon Aug 27 14:44:11 2007
 *
 * Purpose:   Receives a broadcasted buffer size and then a
 *            broadcasted work unit of that size that consists
 *            of a single CM <cm> tagged as <tag> from
 *            communicator <comm> (usually 0, a master).
 *
 *            Work units are prefixed by a status code. If the unit's
 *            code is <eslOK> and no errors are encountered, this
 *            routine will return <eslOK> and a non-<NULL> <*ret_cm>.
 *            If the unit's code is <eslEOD> (a shutdown signal),
 *            this routine returns <eslEOD> and <*ret_cm> is <NULL>.
 *
 *            If the packed CM is an end-of-data signal, return
 *            <eslEOD>, and <*ret_cm> is <NULL>.
 *
 * Returns:   <eslOK> on success. <*ret_cm> contains the new CM; it
 *            is allocated here, and the caller is responsible for
 *            free'ing it.  <*buf> may have been reallocated to a
 *            larger size, and <*nalloc> may have been increased.
 *
 *
 * Throws:    <eslESYS> if an MPI call fails; <eslEMEM> if an allocation fails.
 *            In either case, <*ret_msa> is NULL, and the <buf> and its size
 *            <*nalloc> remain valid.
 * Xref:      J1/72.
 *
 */
int
cm_worker_MPIBcast(char *errbuf, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_ALPHABET **abc, CM_t **ret_cm)
{
  int         status, code;
  int         n;
  int         pos;

  /* Receive the buffer size broadcast */
  if (MPI_Bcast(&n, 1, MPI_INT, 0, MPI_COMM_WORLD) != 0) ESL_EXCEPTION(eslESYS, "mpi broadcast failed.");

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Receive the CM broadcast */
  if (MPI_Bcast (*buf, n, MPI_PACKED, 0, MPI_COMM_WORLD) != 0) ESL_EXCEPTION(eslESYS, "mpi broadcast failed.");

  /* Unpack it - where the first integer is a status code, OK or EOD */
  pos = 0;
  if (MPI_Unpack       (*buf, n, &pos, &code, 1, MPI_INT, comm) != 0)  ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (code == eslEOD) { status = eslEOD; goto ERROR; }

  return cm_nonconfigured_MPIUnpack(abc, errbuf, *buf, *nalloc, &pos, comm, ret_cm);

 ERROR:
  *ret_cm = NULL;
  return status;
}

/* Function:  cm_nonconfigured_MPIUnpack()
 * Synopsis:  Unpacks a CM <cm> (packed by cm_nonconfigured_MPIPack()) from an MPI buffer.
 * Incept:    EPN, Mon Aug 27 14:44:11 2007
 *
 * Purpose:   Unpack a newly allocated CM from MPI packed buffer
 *            <buf>, starting from position <*pos>, where the total length
 *            of the buffer in bytes is <n>. Note that
 *            the full CM data structure was not packed, only
 *            the parts that could have been changed from their initial
 *            (default) values in CMFileRead() are packed. In this
 *            case it's safe to 'fill-in' the 'rest' of the CM with a ConfigCM()
 *            call, which saves us from broadcasting the 'rest' of the CM.
 *
 * Returns:   <eslOK> on success. <*pos> is updated to the position of
 *            the next element in <buf> to unpack (if any). <*ret_cm>
 *            contains a newly allocated CM, which the caller is
 *            responsible for free'ing.
 *
 * Throws:    <eslESYS> on an MPI call failure. <eslEMEM> on allocation failure.
 *            In either case, <*ret_cm> is <NULL>, and the state of <buf>
 *            and <*pos> is undefined and should be considered to be corrupted.
 */
int
cm_nonconfigured_MPIUnpack(ESL_ALPHABET **abc, char *errbuf, char *buf, int n, int *pos, MPI_Comm comm, CM_t **ret_cm)
{
  int    status;
  CM_t  *cm                = NULL;
  P7_HMM *hmm              = NULL;
  ESL_ALPHABET *aabc       = NULL;
  int    atype, i, K, M, nnodes;
  float  tmp_fp7_gfmu;
  float  tmp_fp7_gflambda;

  cm = CreateCMShell();
  if (cm == NULL) { status = eslEMEM; goto ERROR; }
  if (MPI_Unpack(buf, n, pos, &(cm->M),     1, MPI_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->nodes), 1, MPI_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->clen),  1, MPI_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &atype,       1, MPI_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->flags), 1, MPI_INT, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi unpack failed");
  /* note: it's important cm->flags is set prior to CreateCMBody() call below, to properly allocate
   * cm->rf, cm->consensus, cm->map, or not */

  /* Set or verify the alphabet */
  if (*abc == NULL)	{	/* still unknown: set it, pass control of it back to caller */
	if ((*abc = esl_alphabet_Create(atype)) == NULL)       { status = eslEMEM;      goto ERROR; }
  } else {			/* already known: check it */
	if ((*abc)->type != atype)                             { status = eslEINCOMPAT; goto ERROR; }
  }

  CreateCMBody(cm, cm->nodes, cm->M, cm->clen, (*abc));

  /* For convenience below */
  K      = cm->abc->K;
  M      = cm->M;
  nnodes = cm->nodes;

  /* Unpack the rest of the CM */
  /* note cm->flags is how it was immediately after CM is read from file, so the only flags that can possibly be raised are:
   * CMH_ACC, CMH_DESC, CM_RF, CMH_GA, CMH_TC, CMH_NC, CMH_CHKSUM, CMH_MAP, CMH_CONS, CMH_EXPTAIL_STATS, CMH_FILTER_STATS,
   * CMH_QDB, CMH_QDB_LOCAL, CMH_FP7, CM_IS_RSEARCH, CM_RSEARCHTRANS, CM_RSEARCH_EMIT */

  if (MPI_Unpack(buf, n, pos, cm->e[0],              M*K*K, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->t[0],       M*MAXCONNECT, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->sttype,              M+1,  MPI_CHAR, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->stid,                M+1,  MPI_CHAR, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->ndidx,                 M,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->cfirst,                M,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->cnum,                  M,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->plast,                 M,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->pnum,                  M,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->nodemap,          nnodes,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->ndtype,           nnodes,  MPI_CHAR, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if (MPI_Unpack(buf, n, pos, &(cm->nseq),               1,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->eff_nseq),           1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->el_selfsc),          1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->null2_omega),        1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->null3_omega),        1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->checksum),           1,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, cm->null,                  K, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if (MPI_Unpack(buf, n, pos, &(cm->W),                  1,   MPI_INT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->beta_W),             1,MPI_DOUBLE, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->tau),                1,MPI_DOUBLE, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->maxtau),             1,MPI_DOUBLE, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->ga),                 1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->nc),                 1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &(cm->tc),                 1, MPI_FLOAT, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  /* name and all the optional stuff */
  if ((status = esl_mpi_UnpackOpt(buf, n, pos, (void**)&(cm->name),    NULL, MPI_CHAR, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if ((status = esl_mpi_UnpackOpt(buf, n, pos, (void**)&(cm->acc),     NULL, MPI_CHAR, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if ((status = esl_mpi_UnpackOpt(buf, n, pos, (void**)&(cm->desc),    NULL, MPI_CHAR, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if ((status = esl_mpi_UnpackOpt(buf, n, pos, (void**)&(cm->comlog),  NULL, MPI_CHAR, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if ((status = esl_mpi_UnpackOpt(buf, n, pos, (void**)&(cm->ctime),   NULL, MPI_CHAR, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if (cm->flags & CMH_RF)   { if (MPI_Unpack(buf, n, pos, cm->rf,        cm->clen+2, MPI_CHAR, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed"); }
  if (cm->flags & CMH_CONS) { if (MPI_Unpack(buf, n, pos, cm->consensus, cm->clen+2, MPI_CHAR, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed"); }
  if (cm->flags & CMH_MAP)  { if (MPI_Unpack(buf, n, pos, cm->map,       cm->clen+1, MPI_INT,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed"); }

  /* the E-value stats */
  if (cm->flags & CMH_EXPTAIL_STATS) {
	ESL_ALLOC(cm->expA, sizeof(ExpInfo_t *) * EXP_NMODES);
	for(i = 0; i < EXP_NMODES; i++) {
	  if((status = expinfo_MPIUnpack(buf, n, pos, comm, &(cm->expA[i]))) != eslOK) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
	}
  }

  /* Finally unpack any additional p7 filter stats, and the p7 models themselves */
  if (cm->flags & CMH_FP7) {
	if (MPI_Unpack(buf, n, pos, &tmp_fp7_gfmu,     1, MPI_FLOAT, comm)  != 0)      ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
	if (MPI_Unpack(buf, n, pos, &tmp_fp7_gflambda, 1, MPI_FLOAT, comm)  != 0)      ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
	if((status = p7_hmm_MPIUnpack(buf, n, pos, comm, &aabc, &hmm)) != eslOK) ESL_XEXCEPTION(status, "mpi unpack failed");
	if((status = cm_SetFilterHMM(cm, hmm, tmp_fp7_gfmu, tmp_fp7_gflambda)) != eslOK) ESL_XEXCEPTION(eslESYS, "Unable to set filter HMM for CM");
  }

  /* Verify we're not configured */
  if((status = cm_nonconfigured_Verify(cm, errbuf)) != eslOK) ESL_XEXCEPTION(status, errbuf);

  *ret_cm = cm;
  return eslOK;

  ERROR:
  if(cm   != NULL) FreeCM(cm);
  return status;
}

/* Function:  cm_nonconfigured_MPIPack()
 * Incept:    EPN, Mon Aug 27 14:24:57 2007
 *
 * Purpose:   Packs CM <cm> into an MPI packed message buffer <buf>
 *            of length <n> bytes, starting at byte position <*position>,
 *            for MPI communicator <comm>. Note that
 *            the full CM data structure is not packed, only
 *            the parts that could have been changed from their initial
 *            (default) values in CMFileRead() are packed. In this
 *            case it's safe to 'fill-in' the 'rest' of the CM with a ConfigCM()
 *            call, which saves us from broadcasting the 'rest' of the CM.
 *
 *            The caller must know that <buf>'s allocation of <n>
 *            bytes is large enough to append the packed CM at
 *            position <*pos>. This typically requires a call to
 *            <cm_nonconfigured_MPIPackSize()> first, and reallocation if
 *            needed.
 *
 * Returns:   <eslOK> on success; <buf> now contains the
 *            packed <cm>, and <*position> is set to the byte
 *            immediately following the last byte of the CM
 *            in <buf>.
 *
 * Throws:    <eslFAIL> if <cm> is configured.
 *            <eslESYS> if an MPI call fails; or <eslEMEM> if the
 *            buffer's length <n> was overflowed in trying to pack
 *            <cm> into <buf>. In either case, the state of
 *            <buf> and <*position> is undefined, and both should
 *            be considered to be corrupted.
 */
int
cm_nonconfigured_MPIPack(CM_t *cm, char *errbuf, char *buf, int n, int *pos, MPI_Comm comm)
{
  int   status;
  int   i;
  int   K      = cm->abc->K;
  int   M      = cm->M;
  int   nnodes = cm->nodes;
  int   clen   = cm->clen;

  /* Verify we're not configured */
  if((status = cm_nonconfigured_Verify(cm, errbuf)) != eslOK) ESL_XEXCEPTION(status, errbuf);

  if (MPI_Pack(&M,                        1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&nnodes,                   1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&clen,                     1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack((void *) &(cm->abc->type), 1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->flags),              1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");

  /* note cm->flags is how it was immediately after CM is read from file, so the only flags that can possibly be raised are:
   * CMH_ACC, CMH_DESC, CM_RF, CMH_GA, CMH_TC, CMH_NC, CMH_CHKSUM, CMH_MAP, CMH_CONS, CMH_EXPTAIL_STATS, CMH_FILTER_STATS,
   * CMH_QDB, CMH_QDB_LOCAL, CMH_MLP7_STATS, CMH_AP7_STATS, CM_IS_RSEARCH, CM_RSEARCHTRANS, CM_RSEARCH_EMIT */

  if (MPI_Pack(cm->e[0],              M*K*K, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->t[0],       M*MAXCONNECT, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->sttype,              M+1,  MPI_CHAR, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->stid,                M+1,  MPI_CHAR, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->ndidx,                 M,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->cfirst,                M,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->cnum,                  M,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->plast,                 M,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->pnum,                  M,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->nodemap,          nnodes,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->ndtype,           nnodes,  MPI_CHAR, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");

  if (MPI_Pack(&(cm->nseq),               1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->eff_nseq),           1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->el_selfsc),          1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->null2_omega),        1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->null3_omega),        1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->checksum),           1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(cm->null,                  K, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");

  if (MPI_Pack(&(cm->W),                  1,   MPI_INT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->beta_W),             1,MPI_DOUBLE, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->tau),                1,MPI_DOUBLE, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->maxtau),             1,MPI_DOUBLE, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->ga),                 1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->nc),                 1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&(cm->tc),                 1, MPI_FLOAT, buf, n, pos, comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");

  /* name and all the optional stuff */
  if ((status = esl_mpi_PackOpt(cm->name,      -1, MPI_CHAR, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");
  if ((status = esl_mpi_PackOpt(cm->acc,       -1, MPI_CHAR, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");
  if ((status = esl_mpi_PackOpt(cm->desc,      -1, MPI_CHAR, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");
  if ((status = esl_mpi_PackOpt(cm->comlog,    -1, MPI_CHAR, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");
  if ((status = esl_mpi_PackOpt(cm->ctime,     -1, MPI_CHAR, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");

  if (cm->flags & CMH_RF)   { if (MPI_Pack(cm->rf,        cm->clen+2, MPI_CHAR, buf, n, pos, comm)  != 0) ESL_XEXCEPTION(eslESYS, "pack failed"); }
  if (cm->flags & CMH_CONS) { if (MPI_Pack(cm->consensus, cm->clen+2, MPI_CHAR, buf, n, pos, comm)  != 0) ESL_XEXCEPTION(eslESYS, "pack failed"); }
  if (cm->flags & CMH_MAP)  { if (MPI_Pack(cm->map,       cm->clen+1, MPI_INT,  buf, n, pos, comm)  != 0) ESL_XEXCEPTION(eslESYS, "pack failed"); }

  /* the E-value stats */
  if (cm->flags & CMH_EXPTAIL_STATS) {
	for(i = 0; i < EXP_NMODES; i++) {
	  if ((status = expinfo_MPIPack(cm->expA[i], buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack failed");
	}
  }
  if ((cm->flags & CMH_FP7) && (cm->fp7 != NULL)) {
	if (MPI_Pack(&(cm->fp7_evparam[CM_p7_GFMU]),     1, MPI_FLOAT, buf, n, pos, comm)  != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(cm->fp7_evparam[CM_p7_GFLAMBDA]), 1, MPI_FLOAT, buf, n, pos, comm)  != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if((status = p7_hmm_MPIPack(cm->fp7, buf, n, pos, comm)) != eslOK) ESL_XEXCEPTION(status, "pack failed");
  }

  if (*pos > n) ESL_XEXCEPTION(eslEMEM, "buffer overflow");
  return eslOK;

  ERROR:
  return status;
}

/* Function:  cm_nonconfigured_MPIPackSize()
 *
 * Synopsis:  Calculates size needed to pack a CM that has
 *            just been read from a CM file by a CMFileRead()
 *            call, we'll need to pack far less than a fully
 *            configure CM in this case.
 *
 * Incept:    EPN, Mon Aug 27 10:34:15 2007
 *            based on p7_hmm_MPIPackSize() from HMMER3.
 *
 * Purpose:   Calculate an upper bound on the number of bytes
 *            that <cm_nonconfigured_MPIPack()> will need to pack a CM
 *            <cm> in a packed MPI message for MPI communicator
 *            <comm>; return that number of bytes in <*ret_n>.
 *
 * Returns:   <eslOK> on success, and <*ret_n> contains the answer.
 *
 * Throws:    <eslESYS> if an MPI call fails, and <*ret_n> is 0.
 */
int
cm_nonconfigured_MPIPackSize(CM_t *cm, MPI_Comm comm, int *ret_n)
{
  int   status;
  int   i;
  int   n = 0;
  int   K = cm->abc->K;
  int   M = cm->M;
  int   nnodes = cm->nodes;
  int   sz;

  if (MPI_Pack_size(1,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 5*sz; /* M, nodes, clen, abc->type, flags */
  if (MPI_Pack_size(M*K*K,        MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* e */
  if (MPI_Pack_size(M*MAXCONNECT, MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* t */
  if (MPI_Pack_size(M+1,          MPI_CHAR,   comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 2*sz; /* sttype, stid */
  if (MPI_Pack_size(M,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 5*sz; /* ndidx, cfirst, cnum, plast, pnum */
  if (MPI_Pack_size(nnodes,       MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* nodemap */
  if (MPI_Pack_size(nnodes,       MPI_CHAR,   comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* ndtype */
  if (MPI_Pack_size(1,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* nseq */
  if (MPI_Pack_size(1,            MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 4*sz; /* eff_nseq, el_selfsc, null2_omega, null3_omega */
  if (MPI_Pack_size(1,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* checksum */
  if (MPI_Pack_size(K,            MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* null */
  if (MPI_Pack_size(M,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 2*sz; /* dmin/dmax */
  if (MPI_Pack_size(1,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* W */
  if (MPI_Pack_size(1,            MPI_DOUBLE, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 4*sz; /* beta_W, beta_qdb, tau, maxtau */
  if (MPI_Pack_size(1,            MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += 3*sz; /* ga, tc, nc */

  if ((status = esl_mpi_PackOptSize(cm->name,    -1, MPI_CHAR, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* name */
  if ((status = esl_mpi_PackOptSize(cm->acc,     -1, MPI_CHAR, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* acc */
  if ((status = esl_mpi_PackOptSize(cm->desc,    -1, MPI_CHAR, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* desc */
  if ((status = esl_mpi_PackOptSize(cm->comlog,  -1, MPI_CHAR, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* comlog */
  if ((status = esl_mpi_PackOptSize(cm->ctime,   -1, MPI_CHAR, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* ctime */

  if (cm->flags & CMH_RF)   if (MPI_Pack_size(cm->clen+2,  MPI_CHAR, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* rf */
  if (cm->flags & CMH_CONS) if (MPI_Pack_size(cm->clen+2,  MPI_CHAR, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* consensus */
  if (cm->flags & CMH_MAP)  if (MPI_Pack_size(cm->clen+1,   MPI_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n += sz; /* map */

  if (cm->flags & CMH_EXPTAIL_STATS) {
	for(i = 0; i < EXP_NMODES; i++) {
	  if ((status = expinfo_MPIPackSize(cm->expA[i], comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed");
	  n += sz;
	}
  }

  /* Finally, compute size for additional p7 filters */
  if((cm->flags & CMH_FP7) && (cm->fp7 != NULL)) {
	if (MPI_Pack_size(1, MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
	n += 2*sz; /* tmp_fp7_gfmu and tmp_fp7_gflambda */
	if ((status = p7_hmm_MPIPackSize(cm->fp7, comm, &sz)) != eslOK) ESL_XEXCEPTION(status, "p7_hmm_MPIPackSize() failed");
	n += sz; /* cm->ap7A[i] p7 HMM */
  }

  *ret_n = n;
  return eslOK;

 ERROR:
  *ret_n = 0;
  return status;

}

/* Function:  expinfo_MPIPackSize()
 * Synopsis:  Calculates number of bytes needed to pack a
 *            ExpInfo_t object. Follows 'Purpose'
 *            of other *_MPIPackSize() functions above.
 *
 * Incept:    EPN, Wed Dec 12 05:00:01 2007
 *
 * Returns:   <eslOK> on success, and <*ret_n> contains the answer.
 *
 * Throws:    <eslESYS> if an MPI call fails, and <*ret_n> is set to 0.
 *
 * Note:      The sizing calls here need to stay matched up with
 *            the calls in <expinfo_MPIPack()>.
 */
int
expinfo_MPIPackSize(ExpInfo_t *exp, MPI_Comm comm, int *ret_n)
{
  int status;
  int sz;
  int n = 0;

  status = MPI_Pack_size(1, MPI_INT, comm, &sz);    n += 2*sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  /* nrandhits, is_valid */
  status = MPI_Pack_size(1, MPI_DOUBLE, comm, &sz); n += 6*sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  /* mu_orig, mu_extrap, lambda, tailp, cur_eff_dbsize, dbsize */

  *ret_n = n;
  return eslOK;

 ERROR:
  *ret_n = 0;
  return status;
}

/* Function:  expinfo_MPIPack()
 * Synopsis:  Packs ExpInfo_t <exp> into MPI buffer.
 *            See 'Purpose','Returns' and 'Throws'
 *            of other *_MPIPack()'s for more info.
 *
 * Incept:    EPN, Wed Dec 12 05:03:40 2007
 */
int
expinfo_MPIPack(ExpInfo_t *exp, char *buf, int n, int *position, MPI_Comm comm)
{
  int status;

  ESL_DPRINTF2(("expinfo_MPIPack(): ready.\n"));

  status = MPI_Pack((double *) &(exp->cur_eff_dbsize), 1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((double *) &(exp->lambda),         1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((double *) &(exp->mu_extrap),      1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((double *) &(exp->mu_orig),        1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((double *) &(exp->dbsize),         1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((int *)    &(exp->nrandhits),      1, MPI_INT,    buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((double *) &(exp->tailp),          1, MPI_DOUBLE, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack((int *)    &(exp->is_valid),       1, MPI_INT,    buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  ESL_DPRINTF2(("expinfo_results_MPIPack(): done. Packed %d bytes into buffer of size %d\n", *position, n));

  if (*position > n) ESL_EXCEPTION(eslEMEM, "buffer overflow");
  return eslOK;
}

/* Function:  expinfo_MPIUnpack()
 * Synopsis:  Unpacks ExpInfo_t <exp> from an MPI buffer.
 *            Follows 'Purpose', 'Returns', 'Throws' of other
 *            *_MPIUnpack() functions above.
 *
 * Incept:    EPN, Wed Dec 12 05:29:19 2007
 */
int
expinfo_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, ExpInfo_t **ret_exp)
{
  int status;
  ExpInfo_t *exp;

  ESL_ALLOC(exp, sizeof(ExpInfo_t));
  status = MPI_Unpack (buf, n, pos, &(exp->cur_eff_dbsize),  1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->lambda),          1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->mu_extrap),       1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->mu_orig),         1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->dbsize),          1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->nrandhits),       1, MPI_INT,    comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->tailp),           1, MPI_DOUBLE, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &(exp->is_valid),        1, MPI_INT,    comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  *ret_exp = exp;
  return eslOK;

 ERROR:
  if(exp != NULL) free(exp);
  *ret_exp = NULL;
  return status;
}

/* Function:  cm_dsq_MPISend()
 *
 * Incept:    EPN, Tue Aug 28 15:20:16 2007
 *            EPN, Fri Jan 13 05:25:13 2012 [updated]
 *
 * Purpose:   Sends a digitized sequence, its length and a sequence index
 *            as a work unit to MPI process <dest> (<dest> ranges from <0..nproc-1>),
 *            tagging the message with MPI tag <tag> for MPI communicator
 *            <comm>. The receiver uses <cm_dsq_MPIRecv()> to receive the dsq.
 *
 *            Work units are prefixed by a status code. If <dsq> is
 *            <non-NULL>, the work unit is an <eslOK> code followed by
 *            the packed MSA. If <dsq> is NULL, the work unit is an
 *            <eslEOD> code, which <cm_dsq_MPIRecv()> knows how
 *            to interpret; this is typically used for an end-of-data
 *            signal to cleanly shut down worker processes.
 *
 *            In order to minimize alloc/free cycles, caller passes a
 *            pointer to a working buffer <*buf> of size <*nalloc>
 *            characters. If necessary (i.e. if <dsq> is too big to
 *            fit), <*dsq> will be reallocated and <*nalloc> increased
 *            to the new size. As a special case, if <*dsq> is <NULL>
 *            and <*nalloc> is 0, the buffer will be allocated
 *            appropriately, but the caller is still responsible for
 *            free'ing it.
 *
 * Args:      dsq    - digitized seq to send
 *            L      - length of dsq we're sending (dsq could extend further)
 *            idx    - sequence index (serves as unique id) for the dsq we're sending
 *            dest   - MPI destination (0..nproc-1)
 *            tag    - MPI tag
 *            buf    - pointer to a working buffer
 *            nalloc - current allocated size of <*buf>, in characters
 *
 * Returns:   <eslOK> on success; <*buf> may have been reallocated and
 *            <*nalloc> may have been increased.
 *
 * Throws:    <eslESYS> if an MPI call fails; <eslEMEM> if a malloc/realloc
 *            fails. In either case, <*buf> and <*nalloc> remain valid and useful
 *            memory (though the contents of <*buf> are undefined).
 */
int
cm_dsq_MPISend(ESL_DSQ *dsq, int64_t L, int64_t idx, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   code;
  int   sz, n, pos;

  /* First, figure out the size of the work unit */
  if (MPI_Pack_size(1,     MPI_INT,           comm, &n) != 0) ESL_EXCEPTION(eslESYS, "mpi pack size failed"); /* status code */
  if (dsq != NULL) {
	if (MPI_Pack_size(1,   MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_EXCEPTION(eslESYS, "mpi pack size failed"); /* L */
	n += sz;
	if (MPI_Pack_size(1,   MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_EXCEPTION(eslESYS, "mpi pack size failed"); /* idx */
	n += sz;
	if (MPI_Pack_size(L+2, MPI_BYTE,          comm, &sz) != 0) ESL_EXCEPTION(eslESYS, "mpi pack size failed"); /* dsq */
	n += sz;
  }
  ESL_DPRINTF2(("cm_dsq_MPISend(): dsq has size %d\n", n));

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	ESL_REALLOC(*buf, sizeof(char) * n);
	*nalloc = n;
  }
  ESL_DPRINTF2(("cm_dsq_MPISend(): buffer is ready\n"));

  /* Pack the status code, L, idx, and dsq into the buffer */
  pos  = 0;
  code = (dsq == NULL) ? eslEOD : eslOK;
  if (MPI_Pack(&code, 1, MPI_INT, *buf, n, &pos, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi pack failed");
  if (dsq != NULL) {
	if (MPI_Pack(&L,   1,   MPI_LONG_LONG_INT,  *buf, n, &pos, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi pack failed");
	if (MPI_Pack(&idx, 1,   MPI_LONG_LONG_INT,  *buf, n, &pos, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi pack failed");
	if (MPI_Pack(dsq,  L+2, MPI_BYTE,           *buf, n, &pos, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi pack failed");
  }
  ESL_DPRINTF2(("cm_dsq_MPISend(): dsq is packed into %d bytes\n", pos));

  /* Send the packed profile to destination  */
  if (MPI_Send(*buf, n, MPI_PACKED, dest, tag, comm) != 0) ESL_EXCEPTION(eslESYS, "mpi send failed");
  ESL_DPRINTF2(("cm_dsq_MPISend(): dsq is sent.\n"));
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_dsq_MPIRecv()
 *
 * Incept:    EPN, Tue Aug 28 15:29:34 2007
 *            EPN, Fri Jan 13 05:25:29 2012 [updated]
 *
 * Purpose:   Receives a work unit that consists of a digitized sequence
 *            its length and an index from <source> (<0..nproc-1>, or
 *            <MPI_ANY_SOURCE>) tagged as <tag> from communicator <comm>.
 *
 *            Work units are prefixed by a status code. If the unit's
 *            code is <eslOK> and no errors are encountered, this
 *            routine will return <eslOK> a non-<NULL> <*ret_dsq> and
 *            a valid <*ret_L> and <*ret_idx> (equal to whatever was
 *            received (could be -1)). If the unit's code is <eslEOD>
 *            (a shutdown signal), this routine returns <eslEOD>,
 *            <*ret_dsq> is <NULL> and <*ret_L> and <*ret_idx> are -1.
 *
 *            To minimize alloc/free cycles in this routine, caller
 *            passes a pointer to a buffer <*buf> of size <*nalloc>
 *            characters. These are passed by reference, because when
 *            necessary, <*buf> will be reallocated and <*nalloc>
 *            increased to the new size. As a special case, if <*buf>
 *            is <NULL> and <*nalloc> is 0, the buffer will be
 *            allocated appropriately, but the caller is still
 *            responsible for free'ing it.
 *
 *            If the packed dsq is an end-of-data signal, return
 *            <eslEOD>, and <*ret_dsq> is <NULL>.
 *
 * Returns:   <eslOK> on success. <*ret_dsq> contains the new dsq; it
 *            is allocated here, and the caller is responsible for
 *            free'ing it.  <*buf> may have been reallocated to a
 *            larger size, and <*nalloc> may have been increased.
 *
 *
 * Throws:    <eslESYS> if an MPI call fails; <eslEMEM> if an allocation fails.
 *            In either case, <*ret_dsq> is NULL, and the <buf> and its size
 *            <*nalloc> remain valid.
 */
int
cm_dsq_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_DSQ **ret_dsq, int64_t *ret_L, int64_t *ret_idx)
{
  int         status, code;
  ESL_DSQ    *dsq  = NULL;
  int64_t     L    = -1;
  int64_t     idx  = -1;
  int         n;
  int         pos;
  MPI_Status  mpistatus;

  /* Probe first, because we need to know if our buffer is big enough. */
  if (MPI_Probe(source, tag, comm, &mpistatus)  != 0) ESL_XEXCEPTION(eslESYS, "mpi probe failed");
  if (MPI_Get_count(&mpistatus, MPI_PACKED, &n) != 0) ESL_XEXCEPTION(eslESYS, "mpi get count failed");

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Receive the packed work unit */
  ESL_DPRINTF2(("cm_dsq_MPIRecv(): about to receive dsq.\n"));
  if (MPI_Recv(*buf, n, MPI_PACKED, source, tag, comm, &mpistatus) != 0) ESL_XEXCEPTION(eslESYS, "mpi recv failed");
  ESL_DPRINTF2(("cm_dsq_MPIRecv(): dsq has been received.\n"));

  /* Unpack it - where the first integer is a status code, OK or EOD */
  ESL_DPRINTF2(("cm_dsq_MPIRecv(): about to unpack dsq.\n"));
  pos = 0;
  if (MPI_Unpack       (*buf, n, &pos, &code, 1,   MPI_INT,           comm) != 0)  ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (code == eslEOD) { status = eslEOD; goto ERROR; }
  if (MPI_Unpack       (*buf, n, &pos, &L,    1,   MPI_LONG_LONG_INT, comm) != 0)  ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack       (*buf, n, &pos, &idx,  1,   MPI_LONG_LONG_INT, comm) != 0)  ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  ESL_ALLOC(dsq, sizeof(ESL_DSQ) * (L+2));
  if (MPI_Unpack       (*buf, n, &pos, dsq,   L+2, MPI_BYTE,          comm) != 0)  ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  dsq[0] = dsq[(L+1)] = eslDSQ_SENTINEL; /* overwrite */
  ESL_DPRINTF2(("cm_dsq_MPIRecv(): dsq has been unpacked.\n"));

  *ret_L   = L;
  *ret_idx = idx;
  *ret_dsq = dsq;

  return eslOK;

 ERROR:
  if (dsq != NULL) free(dsq);
  *ret_dsq = NULL;
  *ret_L   = -1;
  *ret_idx = -1;
  return status;
}

/* Function:  cm_parsetree_MPIPackSize()
 * Synopsis:  Calculates number of bytes needed to pack a
 *            parsetree.
 * Incept:    EPN, Wed Aug 29 05:44:28 2007
 *
 * Purpose:   Calculate an upper bound on the number of bytes
 *            that <cm_parsetree_MPIPack()> will need to pack
 *            a parsetree in a packed MPI message in
 *            communicator <comm>; return that number of bytes
 *            in <*ret_n>.
 *
 *            Caller will generally use this result to determine how
 *            to allocate a buffer before starting to pack into it.
 *
 * Returns:   <eslOK> on success, and <*ret_n> contains the answer.
 *
 * Throws:    <eslESYS> if an MPI call fails, and <*ret_n> is set to 0.
 *
 * Note:      The sizing calls here need to stay matched up with
 *            the calls in <cm_parsetree_MPIPack()>.
 */
int
cm_parsetree_MPIPackSize(Parsetree_t *tr, MPI_Comm comm, int *ret_n)
{
  int status;
  int sz;
  int n = 0;

  status = MPI_Pack_size(1,     MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->n */
  /* don't send tr->nalloc, it'll be set is as tr->n when this is unpacked */
  status = MPI_Pack_size(1,     MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->memblock */
  status = MPI_Pack_size(1,     MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->is_std */
  status = MPI_Pack_size(1,     MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->pass_idx */
  status = MPI_Pack_size(1,     MPI_FLOAT,comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->trpenalty */

  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->emitl[] */
  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->emitr[] */
  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->state[] */
  status = MPI_Pack_size(tr->n, MPI_CHAR, comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->mode[] */
  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->nxtl[] */
  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->nxtr[] */
  status = MPI_Pack_size(tr->n, MPI_INT,  comm, &sz); n += sz; if (status != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); /* tr->prv[] */

  *ret_n = n;
  return eslOK;

 ERROR:
  *ret_n = 0;
  return status;
}

/* Function:  cm_parsetree_MPIPack()
 * Synopsis:  Packs parsetree into MPI buffer.
 * Incept:    EPN, Wed Aug 29 05:22:32 2007
 *
 * Purpose:   Packs parsetree <tr> into an
 *            MPI packed message buffer <buf> of length <n> bytes,
 *            starting at byte position
 *            <*position>, for MPI communicator <comm>.
 *
 * Returns:   <eslOK> on success; <buf> now contains the
 *            packed <tr>, and <*position> is set to the byte
 *            immediately following the last byte of the results
 *            in <buf>.
 *
 * Throws:    <eslESYS> if an MPI call fails; or <eslEMEM> if the
 *            buffer's length <n> is overflowed by trying to pack
 *            <rnode> into <buf>. In either case, the state of
 *            <buf> and <*position> is undefined, and both should
 *            be considered to be corrupted.
 *
 */
int
cm_parsetree_MPIPack(Parsetree_t *tr, char *buf, int n, int *position, MPI_Comm comm)
{
  int status;

  ESL_DPRINTF2(("cm_parsetree_MPIPack(): ready.\n"));

  status = MPI_Pack(&tr->n,                  1, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(&tr->memblock,           1, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(&tr->is_std,             1, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(&tr->pass_idx,           1, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(&tr->trpenalty,          1, MPI_FLOAT,buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->emitl,           tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->emitr,           tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->state,           tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->mode,            tr->n, MPI_CHAR, buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->nxtl,            tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->nxtr,            tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");
  status = MPI_Pack(tr->prv,             tr->n, MPI_INT,  buf, n, position,  comm); if (status != 0) ESL_EXCEPTION(eslESYS, "pack failed");

  ESL_DPRINTF2(("cm_parsetree_MPIPack(): done. Packed %d bytes into buffer of size %d\n", *position, n));

  if (*position > n) ESL_EXCEPTION(eslEMEM, "buffer overflow");
  return eslOK;
}

/* Function:  cm_parsetree_MPIUnpack()
 * Synopsis:  Unpacks parsetree from an MPI buffer.
 * Incept:    EPN, Wed Aug 29 05:10:20 2007
 *
 * Purpose:   Unpack a newly allocated parsetree node from MPI packed buffer
 *            <buf>, starting from position <*pos>, where the total length
 *            of the buffer in bytes is <n>.
 *
 * Returns:   <eslOK> on success. <*pos> is updated to the position of
 *            the next element in <buf> to unpack (if any). <*ret_tr>
 *            contains a newly allocated parsetree, which the caller is
 *            responsible for free'ing.
 *
 * Throws:    <eslESYS> on an MPI call failure. <eslEMEM> on allocation failure.
 *            In either case, <*ret_tr> is <NULL>, and the state of <buf>
 *            and <*pos> is undefined and should be considered to be corrupted.
 */
int
cm_parsetree_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, Parsetree_t **ret_tr)
{
  int status;
  Parsetree_t *tr = NULL;
  int tr_n;

  status = MPI_Unpack (buf, n, pos, &tr_n,         1, MPI_INT,   comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  tr = CreateParsetree(tr_n);
  tr->n      = tr_n;
  tr->nalloc = tr_n;
  status = MPI_Unpack (buf, n, pos, &tr->memblock,  1, MPI_INT,   comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &tr->is_std,    1, MPI_INT,   comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &tr->pass_idx,  1, MPI_INT,   comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, &tr->trpenalty, 1, MPI_FLOAT, comm); if (status != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  status = MPI_Unpack (buf, n, pos, tr->emitl, tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->emitr, tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->state, tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->mode,  tr_n, MPI_CHAR, comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->nxtl,  tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->nxtr,  tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  status = MPI_Unpack (buf, n, pos, tr->prv,   tr_n, MPI_INT,  comm); if (status != 0)     ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  *ret_tr = tr;
  return eslOK;

 ERROR:
  if (tr != NULL)
	FreeParsetree(tr);
  *ret_tr = NULL;
  return status;
}

/*****************************************************************
 * Communicating CM_PIPELINE
 *****************************************************************/

/* Function:  cm_pipeline_MPISend()
 * Synopsis:  Send pipeline data as an MPI message.
 * Incept:    EPN, Thu Jun  2 14:36:01 2011
 *            MSF, Wed Sep 09 09:09:47 2009 [Janelia] (p7_pipeline_MPISend())
 *
 * Purpose:   Sends pipeline statistics <pli> to MPI process <dest>
 *            (where <dest> ranges from 0..<nproc-1>), with MPI tag
 *            <tag> for MPI communicator <comm>.
 *
 *            In order to minimize alloc/free cycles in this routine,
 *            caller passes a pointer to a working buffer <*buf> of
 *            size <*nalloc> characters. If necessary (i.e. if <pli> is
 *            too big to fit), <*buf> will be reallocated and <*nalloc>
 *            increased to the new size. As a special case, if <*buf>
 *            is <NULL> and <*nalloc> is 0, the buffer will be
 *            allocated appropriately, but the caller is still
 *            responsible for free'ing it.
 *
 *            If <pli> is NULL, the pipeline statistics are initialized
 *            to zeros.
 *
 * Returns:   <eslOK> on success.
 */
int
cm_pipeline_MPISend(CM_PIPELINE *pli, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   sz, n, pos;
  int   pass_idx;

  CM_PIPELINE bogus;

  /* This will look wasteful, but the MPI spec doesn't guarantee that
   * MPI_Pack_size(x, ...) + MPI_Pack_size(x, ... ) == MPI_Pack_size(2x, ...).
   * Indeed there are some hints in the spec that that's *not* true.
   * So we assume we must match our Pack_size calls exactly to our Pack calls.
   */
  n = 0;
  if (MPI_Pack_size(1, MPI_LONG_INT,      comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* mode */
  if (MPI_Pack_size(1, MPI_LONG_INT,      comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* Z_setby */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nseqs */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nmodels */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nnodes */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nmodels_hmmonly */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nnodes_hmmonly */
  if (MPI_Pack_size(1, MPI_DOUBLE,        comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* Z */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* cur_cm_idx */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* cur_clan_idx */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* cur_seq_idx */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* cur_pass_idx */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* cur_hit_idx */

  for(pass_idx = 0; pass_idx < NPLI_PASSES; pass_idx++) {
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* npli_top */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* npli_bot */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nres_top */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* nres_bot */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_msv */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_vit */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_fwd */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_gfwd */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_edef */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_cyk */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_ins */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_output */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_msvbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_vitbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_fwdbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_gfwdbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_past_edefbias */

	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_msv */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_vit */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_fwd */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_gfwd */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_edef */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_cyk */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_ins */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_output */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_msvbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_vitbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_fwdbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_gfwdbias */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pos_past_edefbias */

	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_overflow_fcyk  */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_overflow_final */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_aln_hb         */
	if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* n_aln_dccyk      */
  }
  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* if no pipeline was defined, return zeros for the stats */
  if (pli == NULL)
	{
	  bogus.mode              = CM_SEARCH_SEQS;    /* that's 0. (some compilers complain if you set 0 directly. */
	  bogus.Z_setby           = CM_ZSETBY_SSIINFO; /* ditto. */
	  bogus.nseqs             = 0;
	  bogus.nmodels           = 0;
	  bogus.nnodes            = 0;
	  bogus.nmodels_hmmonly   = 0;
	  bogus.nnodes_hmmonly    = 0;
	  bogus.Z                 = 0.0;
	  bogus.cur_cm_idx        = -1;
	  bogus.cur_clan_idx      = -1;
	  bogus.cur_seq_idx       = -1;
	  bogus.cur_pass_idx      = -1;
	  for(pass_idx = 0; pass_idx < NPLI_PASSES; pass_idx++) {
	cm_pli_ZeroAccounting(&(bogus.acct[pass_idx]));
	  }
	  pli = &bogus;
   }

  /* Pack the pipeline into the buffer */
  pos = 0;
  if (MPI_Pack(&pli->mode,            1, MPI_LONG_INT,      *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->Z_setby,         1, MPI_LONG_INT,      *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->nseqs,           1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->nmodels,         1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->nnodes,          1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->nmodels_hmmonly, 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->nnodes_hmmonly,  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->Z,               1, MPI_DOUBLE,        *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->cur_cm_idx,      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->cur_clan_idx,    1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->cur_seq_idx,     1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&pli->cur_pass_idx,    1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  for(pass_idx = 0; pass_idx < NPLI_PASSES; pass_idx++) {
	if (MPI_Pack(&(pli->acct[pass_idx].npli_top),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].npli_bot),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].nres_top),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].nres_bot),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_msv),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_vit),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_fwd),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_gfwd),     1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_edef),     1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_cyk),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_ins),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_output),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_msvbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_vitbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_fwdbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_gfwdbias), 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_past_edefbias), 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_msv),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_vit),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_fwd),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_gfwd),     1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_edef),     1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_cyk),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_ins),      1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_output),        1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_msvbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_vitbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_fwdbias),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_gfwdbias), 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].pos_past_edefbias), 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

	if (MPI_Pack(&(pli->acct[pass_idx].n_overflow_fcyk),   1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_overflow_final),  1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_aln_hb),          1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(&(pli->acct[pass_idx].n_aln_dccyk),       1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  }

  /* Send the packed pipeline to destination  */
  MPI_Send(*buf, n, MPI_PACKED, dest, tag, comm);
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_pipeline_MPIRecv()
 * Synopsis:  Receive pipeline data as an MPI message.
 * Incept:    EPN, Thu Jun  2 14:41:46 2011
 *            MSF, Wed Sep 09 09:09:47 2009 [Janelia] (p7_pipeline_MPIRecv()
 *
 * Purpose:   Receive a pipeline from <source> (where <source> is usually
 *            process 0, the master) with tag <tag> from communicator <comm>,
 *            and return it in <*ret_pli>.
 *
 *            To minimize alloc/free cycles in this routine, caller
 *            passes a pointer to a buffer <*buf> of size <*nalloc>
 *            characters. These are passed by reference because if
 *            necessary, <buf> will be reallocated and <nalloc>
 *            increased to the new size. As a special case, if <buf>
 *            is <NULL> and <nalloc> is 0, the buffer will be
 *            allocated appropriately, but the caller is still
 *            responsible for free'ing it.
 *
 * Returns:   <eslOK> on success. <*ret_pli> contains the new pipeline;
 *            it is allocated here, and the caller is responsible for
 *            free'ing it.  <*buf> may have been reallocated to a
 *            larger size, and <*nalloc> may have been increased.
 *
 */
int
cm_pipeline_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_GETOPTS *go, CM_PIPELINE **ret_pli)
{
  int          status;
  CM_PIPELINE *pli    = NULL;
  int          n;
  int          pos;
  int          pass_idx;
  MPI_Status   mpistatus;

  /* Probe first, because we need to know if our buffer is big enough.
   */
  MPI_Probe(source, tag, comm, &mpistatus);
  MPI_Get_count(&mpistatus, MPI_PACKED, &n);

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Receive the packed pipeline */
  MPI_Recv(*buf, n, MPI_PACKED, source, tag, comm, &mpistatus);

  /* Unpack it - watching out for the EOD signal of M = -1. */
  pos = 0;                                /* irrelevant, these are overwritten below */
  if ((pli = cm_pipeline_Create(go, NULL, 1, 1, 0, CM_ZSETBY_SSIINFO, CM_SEARCH_SEQS)) == NULL) { status = eslEMEM; goto ERROR; } /* mode will be immediately overwritten */
  if (MPI_Unpack(*buf, n, &pos, &(pli->mode),            1, MPI_LONG_INT,      comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->Z_setby),         1, MPI_LONG_INT,      comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->nseqs),           1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->nmodels),         1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->nnodes),          1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->nmodels_hmmonly), 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->nnodes_hmmonly),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->Z),               1, MPI_DOUBLE,        comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->cur_cm_idx),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->cur_clan_idx),    1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->cur_seq_idx),     1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &(pli->cur_pass_idx),    1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");

  for(pass_idx = 0; pass_idx < NPLI_PASSES; pass_idx++) {
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].npli_top),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].npli_bot),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].nres_top),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].nres_bot),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_msv),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_vit),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_fwd),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_gfwd),     1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_edef),     1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_cyk),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_ins),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_output),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_msvbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_vitbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_fwdbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_gfwdbias), 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_past_edefbias), 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");

	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_msv),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_vit),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_fwd),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_gfwd),     1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_edef),     1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_cyk),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_ins),      1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_output),        1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_msvbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_vitbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_fwdbias),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_gfwdbias), 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].pos_past_edefbias), 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");

	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_overflow_fcyk),   1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_overflow_final),  1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_aln_hb),          1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	if (MPI_Unpack(*buf, n, &pos, &(pli->acct[pass_idx].n_aln_dccyk),       1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  }
  *ret_pli = pli;
  return eslOK;

 ERROR:
  if (pli != NULL) cm_pipeline_Destroy(pli, NULL);
  *ret_pli = NULL;
  return status;
}

/*****************************************************************
 * Communicating CM_TOPHITS
 *****************************************************************/

/* Function:  cm_tophits_MPISend()
 * Synopsis:  Send the TOPHITS as an MPI work unit.
 * Incept:    EPN, Thu Jun  2 08:45:05 2011
 *            MSF, Mon Sep  21 22:22:00 2009 [Janelia] (p7_tophits_MPISend()
 *
 * Purpose:   Sends the TOPHITS <th> as a work unit to MPI process
 *            <dest> (where <dest> ranges from 0..<nproc-1>), tagged
 *            with MPI tag <tag>, for MPI communicator <comm>, as
 *            the sole workunit or result.
 *
 *            After the TOPHITS <th> information has been sent, send
 *            the each hit as an indepentant message.
 *
 * Returns:   <eslOK> on success; <*buf> may have been reallocated and
 *            <*nalloc> may have been increased.
 *
 * Throws:    <eslESYS> if an MPI call fails; <eslEMEM> if a malloc/realloc
 *            fails. In either case, <*buf> and <*nalloc> remain valid and useful
 *            memory (though the contents of <*buf> are undefined).
 */
int
cm_tophits_MPISend(CM_TOPHITS *th, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   sz, n, pos;
  int   i;

  CM_HIT    *hit = NULL;

  sz = 0;
  n  = 0;

  /* calculate the buffer size needed to hold the largest hit */
  hit = th->unsrt;
  for (i = 0; i < th->N; i++) {
	if ((status = cm_hit_MPIPackSize(hit, comm, &sz)) != eslOK) goto ERROR;
	n = ESL_MAX(n, sz);
	hit++;
  }
  if (MPI_Pack_size(3, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");
  n = ESL_MAX(n, sz);

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  pos = 0;
  if (MPI_Pack(&th->N,         1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&th->nreported, 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&th->nincluded, 1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  /* Send the packed tophits information */
  if (MPI_Send(*buf, n, MPI_PACKED, dest, tag, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi send failed");
  if (th->N == 0) return eslOK;

  /* loop through the hit list sending to dest */
  hit = th->unsrt;
  for (i = 0; i < th->N; i++) {
	if ((status = cm_hit_MPISend(hit, dest, tag, comm, buf, nalloc)) != eslOK) goto ERROR;
	hit++;
  }

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_tophits_MPIRecv()
 * Synopsis:  Receives an TOPHITS as a work unit from an MPI sender.
 * Incept:    EPN, Thu Jun  2 14:07:19 2011
 *            MSF, Mon Sep  21 22:22:00 2009 [Janelia] (p7_tophits_MPIRecv())
 *
 * Purpose:   Sends the TOPHITS <th> as a work unit to MPI process
 *            <dest> (where <dest> ranges from 0..<nproc-1>), tagged
 *            with MPI tag <tag>, for MPI communicator <comm>, as
 *            the sole workunit or result.
 *
 *            After the TOPHITS <th> information has been sent, send
 *            the each hit as an indepentant message.
 *
 * Returns:   <eslOK> on success; <*buf> may have been reallocated and
 *            <*nalloc> may have been increased.
 *
 * Throws:    <eslESYS> if an MPI call fails; <eslEMEM> if a malloc/realloc
 *            fails. In either case, <*buf> and <*nalloc> remain valid and useful
 *            memory (though the contents of <*buf> are undefined).
 */
int
cm_tophits_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, CM_TOPHITS **ret_th)
{
  int         n;
  int         status;
  int         pos;
  CM_TOPHITS *th    = NULL;
  CM_HIT     *hit   = NULL;
  MPI_Status  mpistatus;

  uint64_t    nhits;
  uint64_t    inx;

  /* Probe first, because we need to know if our buffer is big enough.
   */
  MPI_Probe(source, tag, comm, &mpistatus);
  MPI_Get_count(&mpistatus, MPI_PACKED, &n);

  /* make sure we are getting the tag we expect and from whom we expect if from */
  if (tag    != MPI_ANY_TAG    && mpistatus.MPI_TAG    != tag) {
	status = eslFAIL;
	goto ERROR;
  }
  if (source != MPI_ANY_SOURCE && mpistatus.MPI_SOURCE != source) {
	status = eslFAIL;
	goto ERROR;
  }

  /* set the source and tag */
  tag = mpistatus.MPI_TAG;
  source = mpistatus.MPI_SOURCE;

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Receive the packed top hits */
  MPI_Recv(*buf, n, MPI_PACKED, source, tag, comm, &mpistatus);

  /* Unpack it - watching out for the EOD signal of M = -1. */
  pos = 0;
  if ((th = cm_tophits_Create()) == NULL) { status = eslEMEM; goto ERROR; }
  if (MPI_Unpack(*buf, n, &pos, &nhits,         1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &th->nreported, 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(*buf, n, &pos, &th->nincluded, 1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");

  /* loop through all of the hits sent */
  for (inx = 0; inx < nhits; inx++) {
	if ((status = cm_tophits_CreateNextHit(th, &hit))                  != eslOK) goto ERROR;
	if ((status = cm_hit_MPIRecv(source, tag, comm, buf, nalloc, hit)) != eslOK) goto ERROR;
  }

  *ret_th = th;
  return eslOK;

 ERROR:
  if (th  != NULL) cm_tophits_Destroy(th);
  *ret_th = NULL;
  return status;
}

/* Function:  cm_hit_MPISend()
 */
int
cm_hit_MPISend(CM_HIT *hit, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   pos;
  int   n = *nalloc;

  /* Pack the HIT into the buffer */
  pos  = 0;
  if ((status = cm_hit_MPIPack(hit, *buf, n, &pos, comm)) != eslOK) goto ERROR;

  /* Send the packed HIT to the destination. */
  if (MPI_Send(*buf, n, MPI_PACKED, dest, tag, comm) != 0)  ESL_EXCEPTION(eslESYS, "mpi send failed");

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hit_MPIRecv()
 */
int
cm_hit_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, CM_HIT *hit)
{
  int         n;
  int         status;
  int         pos;
  MPI_Status  mpistatus;

  /* Probe first, because we need to know if our buffer is big enough.
   */
  MPI_Probe(source, tag, comm, &mpistatus);
  MPI_Get_count(&mpistatus, MPI_PACKED, &n);

  /* make sure we are getting the tag we expect and from whom we expect if from */
  if (tag    != MPI_ANY_TAG    && mpistatus.MPI_TAG    != tag) {
	status = eslFAIL;
	goto ERROR;
  }
  if (source != MPI_ANY_SOURCE && mpistatus.MPI_SOURCE != source) {
	status = eslFAIL;
	goto ERROR;
  }

  /* set the source and tag */
  tag = mpistatus.MPI_TAG;
  source = mpistatus.MPI_SOURCE;

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Receive the packed top hits */
  MPI_Recv(*buf, n, MPI_PACKED, source, tag, comm, &mpistatus);

  /* Unpack it - watching out for the EOD signal of M = -1. */
  pos = 0;
  if ((status = cm_hit_MPIUnpack(*buf, n, &pos, comm, hit)) != eslOK) goto ERROR;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hit_MPIPackSize()
 * Synopsis:  Calculates size needed to pack a HIT.
 * Incept:    MSF, Mon Sep  21 22:22:00 2009 [Janelia]
 *
 * Purpose:   Calculate an upper bound on the number of bytes
 *            that <cm_hit_MPIPack()> will need to pack an CM_HIT
 *            <hit> in a packed MPI message for MPI communicator
 *            <comm>; return that number of bytes in <*ret_n>.
 *
 * Returns:   <eslOK> on success, and <*ret_n> contains the answer.
 *
 * Throws:    <eslESYS> if an MPI call fails, and <*ret_n> is 0.
 */
int
cm_hit_MPIPackSize(CM_HIT *hit, MPI_Comm comm, int *ret_n)
{
  int   status;
  int   n = 0;
  int   sz;

  CM_ALIDISPLAY *ad = hit->ad;

  /* CM_HIT data */
  if (MPI_Pack_size(8,            MPI_LONG,   comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* start, stop, seq_idx, cm_idx, hit_idx, srcL, any_oidx, win_oidx */
  if (MPI_Pack_size(8,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* in_rc, root, mode, clan_idx, pass_idx, hmmonly, glocal, has_evalue */
  if (MPI_Pack_size(2,            MPI_FLOAT,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* score, bias             */
  if (MPI_Pack_size(4,            MPI_DOUBLE, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* pvalue, evalue, any_bitE, win_bitE */
  if (MPI_Pack_size(1,            MPI_INT,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* flags                              */

  if ((status = esl_mpi_PackOptSize(hit->name, -1, MPI_CHAR, comm, &sz)) != eslOK) goto ERROR;  n += sz;
  if ((status = esl_mpi_PackOptSize(hit->acc,  -1, MPI_CHAR, comm, &sz)) != eslOK) goto ERROR;  n += sz;
  if ((status = esl_mpi_PackOptSize(hit->desc, -1, MPI_CHAR, comm, &sz)) != eslOK) goto ERROR;  n += sz;

  /* CM_ALIDISPLAY data */
  if (MPI_Pack_size(16,          MPI_INT,     comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* offset info              */
  if (MPI_Pack_size(7,           MPI_INT,     comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* N, N_el, cfrom_emit, cto_emit, cfrom_span, cto_span, clen */
  if (MPI_Pack_size(2,           MPI_LONG,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* sequence info            */
  if (MPI_Pack_size(1,           MPI_DOUBLE,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* tau                      */
  if (MPI_Pack_size(4,           MPI_FLOAT,   comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* sc, avgpp, gc, matrix_Mb */
  if (MPI_Pack_size(1,           MPI_DOUBLE,  comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* elapsed_secs             */
  if (MPI_Pack_size(1,           MPI_INT,     comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* hmmonly                  */
  if (MPI_Pack_size(1,           MPI_INT,     comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* memsize                  */
  if (MPI_Pack_size(ad->memsize, MPI_CHAR,    comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz;  /* mem                      */

  *ret_n = n;
  return eslOK;

 ERROR:
  *ret_n = 0;
  return status;

}

/* Function:  cm_hit_MPIPack()
 * Synopsis:  Packs the HIT into MPI buffer.
 * Incept:    MSF, Mon Sep  21 22:22:00 2009 [Janelia]
 *
 * Purpose:   Packs HIT <hit> into an MPI packed message buffer <buf>
 *            of length <n> bytes, starting at byte position <*position>,
 *            for MPI communicator <comm>.
 *
 *            The caller must know that <buf>'s allocation of <n>
 *            bytes is large enough to append the packed HIT at
 *            position <*pos>. This typically requires a call to
 *            <cm_hit_MPIPackSize()> first, and reallocation if
 *            needed.
 *
 * Returns:   <eslOK> on success; <buf> now contains the
 *            packed <hit>, and <*position> is set to the byte
 *            immediately following the last byte of the HIT
 *            in <buf>.
 *
 * Throws:    <eslESYS> if an MPI call fails; or <eslEMEM> if the
 *            buffer's length <n> was overflowed in trying to pack
 *            <msa> into <buf>. In either case, the state of
 *            <buf> and <*position> is undefined, and both should
 *            be considered to be corrupted.
 */
int
cm_hit_MPIPack(CM_HIT *hit, char *buf, int n, int *pos, MPI_Comm comm)
{
  int             status;
  int             offset;

  CM_ALIDISPLAY *ad = hit->ad;

  if (MPI_Pack(&hit->start,          1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->stop,           1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->in_rc,          1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->root,           1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->mode,           1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->cm_idx,         1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->clan_idx,       1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->seq_idx,        1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->pass_idx,       1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->hit_idx,        1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->score,          1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->bias,           1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->pvalue,         1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->evalue,         1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->has_evalue,     1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->flags,          1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->srcL,           1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->hmmonly,        1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->glocal,         1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->any_oidx,       1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->win_oidx,       1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->any_bitE,       1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&hit->win_bitE,       1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  if ((status = esl_mpi_PackOpt(hit->name,        -1,      MPI_CHAR,  buf, n, pos, comm)) != eslOK) return status;
  if ((status = esl_mpi_PackOpt(hit->acc,         -1,      MPI_CHAR,  buf, n, pos, comm)) != eslOK) return status;
  if ((status = esl_mpi_PackOpt(hit->desc,        -1,      MPI_CHAR,  buf, n, pos, comm)) != eslOK) return status;

  offset = (ad->rfline    == NULL) ? -1 : ad->rfline - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->ncline    == NULL) ? -1 : ad->ncline - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->csline    == NULL) ? -1 : ad->csline - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->model     == NULL) ? -1 : ad->model - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->mline     == NULL) ? -1 : ad->mline - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->aseq      == NULL) ? -1 : ad->aseq - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->ppline    == NULL) ? -1 : ad->ppline - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->aseq_el   == NULL) ? -1 : ad->aseq_el - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->rfline_el == NULL) ? -1 : ad->rfline_el - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->ppline_el == NULL) ? -1 : ad->ppline_el - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->N,               1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->N_el,            1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->cmname    == NULL) ? -1 : ad->cmname - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->cmacc     == NULL) ? -1 : ad->cmacc - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->cmdesc    == NULL) ? -1 : ad->cmdesc - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  if (MPI_Pack(&ad->cfrom_emit,      1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->cto_emit,        1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->cfrom_span,      1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->cto_span,        1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->clen,            1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->sqname  == NULL)  ? -1 : ad->sqname - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->sqacc   == NULL)  ? -1 : ad->sqacc - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  offset = (ad->sqdesc  == NULL)  ? -1 : ad->sqdesc - ad->mem;
  if (MPI_Pack(&offset,              1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->sqfrom,          1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->sqto,            1, MPI_LONG,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  if (MPI_Pack(&ad->sc,              1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->avgpp,           1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->gc,              1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->tau,             1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->matrix_Mb,       1, MPI_FLOAT,    buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->elapsed_secs,    1, MPI_DOUBLE,   buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&ad->hmmonly,         1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  if (MPI_Pack(&ad->memsize,         1, MPI_INT,      buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack( ad->mem,   ad->memsize, MPI_CHAR,     buf, n, pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");

  if (*pos > n) ESL_EXCEPTION(eslEMEM, "buffer overflow");
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_hit_MPIUnpack()
 * Synopsis:  Unpacks an HIT from an MPI buffer.
 * Incept:    EPN, Thu Jun  2 14:29:20 2011
 *            MSF, Mon Sep  21 22:22:00 2009 [Janelia] (p7_hit_MPIUnpack())
 *
 * Purpose:   Unpack a newly allocated HIT from MPI packed buffer
 *            <buf>, starting from position <*pos>, where the total length
 *            of the buffer in bytes is <n>.
 *
 * Returns:   <eslOK> on success. <*pos> is updated to the position of
 *            the next element in <buf> to unpack (if any). <*ret_hit>
 *            contains a newly allocated HIT, which the caller is
 *            responsible for free'ing.
 *
 * Throws:    <eslESYS> on an MPI call failure. <eslEMEM> on allocation failure.
 *            In either case, <*ret_hit> is <NULL>, and the state of <buf>
 *            and <*pos> is undefined and should be considered to be corrupted.
 */
int
cm_hit_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, CM_HIT *hit)
{
  int  status;
  int  rfline, ncline, csline, model, mline, aseq, ppline, aseq_el, rfline_el, ppline_el;
  int  cmname, cmacc, cmdesc;
  int  sqname, sqacc, sqdesc;

  CM_ALIDISPLAY *ad;
  ESL_ALLOC(ad, sizeof(CM_ALIDISPLAY));

  if (MPI_Unpack(buf, n, pos, &hit->start,       1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->stop,        1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->in_rc,       1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->root,        1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->mode,        1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->cm_idx,      1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->clan_idx,    1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->seq_idx,     1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->pass_idx,    1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->hit_idx,     1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->score,       1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->bias,        1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->pvalue,      1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->evalue,      1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->has_evalue,  1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->flags,       1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->srcL,        1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->hmmonly,     1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->glocal,      1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->any_oidx,    1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->win_oidx,    1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->any_bitE,    1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &hit->win_bitE,    1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if ((status = esl_mpi_UnpackOpt(buf, n, pos,   (void**)&(hit->name),        NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;
  if ((status = esl_mpi_UnpackOpt(buf, n, pos,   (void**)&(hit->acc),         NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;
  if ((status = esl_mpi_UnpackOpt(buf, n, pos,   (void**)&(hit->desc),        NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;

  if (MPI_Unpack(buf, n, pos, &rfline,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ncline,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &csline,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &model,              1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &mline,              1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &aseq,               1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ppline,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &aseq_el,            1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &rfline_el,          1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ppline_el,          1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->N,              1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->N_el,           1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &cmname,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &cmacc,              1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &cmdesc,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->cfrom_emit,     1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->cto_emit,       1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->cfrom_span,     1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->cto_span,       1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->clen,           1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &sqname,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &sqacc,              1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &sqdesc,             1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->sqfrom,         1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->sqto,           1, MPI_LONG,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if (MPI_Unpack(buf, n, pos, &ad->sc,             1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->avgpp,          1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->gc,             1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->tau,            1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->matrix_Mb,      1, MPI_FLOAT,  comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->elapsed_secs,   1, MPI_DOUBLE, comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");
  if (MPI_Unpack(buf, n, pos, &ad->hmmonly,        1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  if (MPI_Unpack(buf, n, pos, &ad->memsize,        1, MPI_INT,    comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  /* allocate the string pools for the alignments */
  ESL_ALLOC(ad->mem, ad->memsize);
  if (MPI_Unpack(buf, n, pos,  ad->mem,  ad->memsize, MPI_CHAR,   comm) != 0) ESL_XEXCEPTION(eslESYS, "mpi unpack failed");

  ad->rfline    = (rfline    == -1)  ? NULL : ad->mem + rfline;
  ad->ncline    = (ncline    == -1)  ? NULL : ad->mem + ncline;
  ad->csline    = (csline    == -1)  ? NULL : ad->mem + csline;
  ad->model     = (model     == -1)  ? NULL : ad->mem + model;
  ad->mline     = (mline     == -1)  ? NULL : ad->mem + mline;
  ad->aseq      = (aseq      == -1)  ? NULL : ad->mem + aseq;
  ad->ppline    = (ppline    == -1)  ? NULL : ad->mem + ppline;
  ad->aseq_el   = (aseq_el   == -1)  ? NULL : ad->mem + aseq_el;
  ad->rfline_el = (rfline_el == -1)  ? NULL : ad->mem + rfline_el;
  ad->ppline_el = (ppline_el == -1)  ? NULL : ad->mem + ppline_el;

  ad->cmname  = (cmname == -1)  ? NULL : ad->mem + cmname;
  ad->cmacc   = (cmacc == -1)   ? NULL : ad->mem + cmacc;
  ad->cmdesc  = (cmdesc == -1)  ? NULL : ad->mem + cmdesc;

  ad->sqname  = (sqname == -1)  ? NULL : ad->mem + sqname;
  ad->sqacc   = (sqacc == -1)   ? NULL : ad->mem + sqacc;
  ad->sqdesc  = (sqdesc == -1)  ? NULL : ad->mem + sqdesc;

  hit->ad = ad;

  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_alndata_MPISend()
 * Synopsis:  Send alignment data as an MPI message.
 * Incept:    EPN, Fri Jan 13 09:19:54 2012
 *
 * Purpose:   Sends alignment data <data> to MPI process <dest>
 *            (where <dest> ranges from 0..<nproc-1>), with MPI tag
 *            <tag> for MPI communicator <comm>.
 *
 *            In order to minimize alloc/free cycles in this routine,
 *            caller passes a pointer to a working buffer <*buf> of
 *            size <*nalloc> characters. If necessary (i.e. if <data> is
 *            too big to fit), <*buf> will be reallocated and <*nalloc>
 *            increased to the new size. As a special case, if <*buf>
 *            is <NULL> and <*nalloc> is 0, the buffer will be
 *            allocated appropriately, but the caller is still
 *            responsible for free'ing it.
 *
 *            If <include_sq> is TRUE, we pack up and include
 *            <data->sq>, else we don't.
 *
 * Returns:   <eslOK> on success.
 *            <eslEINCOMPAT> if data is NULL, errbuf is filled.
 *
 * Throws:    <eslESYS> on a MPI error, errbuf not filled.
 */
int
cm_alndata_MPISend(CM_ALNDATA *data, int include_sq, char *errbuf, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc)
{
  int   status;
  int   sz, n, pos;
  int   has_ppstr;
  int   has_tr;
  int64_t pplen; /* length of ppstr */

  if(data == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "cm_alndata_MPISend(), data is NULL");
  has_ppstr = (data->ppstr == NULL) ? FALSE : TRUE;
  has_tr    = (data->tr    == NULL) ? FALSE : TRUE;
  pplen = has_ppstr? data->sq->L+1 : 0;

  /* This will look wasteful, but the MPI spec doesn't guarantee that
   * MPI_Pack_size(x, ...) + MPI_Pack_size(x, ... ) == MPI_Pack_size(2x, ...).
   * Indeed there are some hints in the spec that that's *not* true.
   * So we assume we must match our Pack_size calls exactly to our Pack calls.
   */
  n = 0;
  /* first tally up size of everything that's mandatory */
  if (MPI_Pack_size(1, MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* idx */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* sc */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pp */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* spos */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* epos */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* secs_band */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* secs_aln */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* secs_tot */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* mb_tot */
  if (MPI_Pack_size(1, MPI_DOUBLE,        comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* tau */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* thresh1 */
  if (MPI_Pack_size(1, MPI_FLOAT,         comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* thresh2 */
  /* now the optional info */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* include_sq */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* has_tr */
  if (MPI_Pack_size(1, MPI_INT,           comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* has_ppstr */
  if (include_sq) {
	if ((status = esl_sq_MPIPackSize(data->sq, comm, &sz))       != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz; /* sq */
  }
  if (has_tr) {
	if ((status = cm_parsetree_MPIPackSize(data->tr, comm, &sz)) != eslOK) ESL_XEXCEPTION(eslESYS, "pack size failed"); n += sz; /* tr */
  }
  if (has_ppstr) {
	if (MPI_Pack_size(1,     MPI_LONG_LONG_INT, comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* pplen */
	if (MPI_Pack_size(pplen, MPI_CHAR,          comm, &sz) != 0) ESL_XEXCEPTION(eslESYS, "pack size failed");  n += sz; /* ppstr */
  }

  /* Make sure the buffer is allocated appropriately */
  if (*buf == NULL || n > *nalloc) {
	void *tmp;
	ESL_RALLOC(*buf, tmp, sizeof(char) * n);
	*nalloc = n;
  }

  /* Pack it, in same order as above */
  pos = 0;
  /* mandatory values */
  if (MPI_Pack(&data->idx,            1, MPI_LONG_LONG_INT, *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->sc,             1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->pp,             1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->spos,           1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->epos,           1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->secs_bands,     1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->secs_aln,       1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->secs_tot,       1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->mb_tot,         1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->tau,            1, MPI_DOUBLE,        *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->thresh1,        1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&data->thresh2,        1, MPI_FLOAT,         *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  /* optional info */
  if (MPI_Pack(&include_sq,           1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&has_tr,               1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (MPI_Pack(&has_ppstr,            1, MPI_INT,           *buf, n, &pos, comm) != 0) ESL_XEXCEPTION(eslESYS, "pack failed");
  if (include_sq) {
	if ((status = esl_sq_MPIPack(data->sq, *buf, n, &pos, comm)) != eslOK)             ESL_XEXCEPTION(eslESYS, "pack failed");
  }
  if (has_tr) {
	if ((status = cm_parsetree_MPIPack(data->tr, *buf, n, &pos, comm) != eslOK))       ESL_XEXCEPTION(eslESYS, "pack failed");
  }
  if (has_ppstr) {
	if (MPI_Pack(&pplen,          1, MPI_LONG_LONG_INT,  *buf, n, &pos, comm) != 0)    ESL_XEXCEPTION(eslESYS, "pack failed");
	if (MPI_Pack(data->ppstr, pplen, MPI_CHAR,           *buf, n, &pos, comm) != 0)    ESL_XEXCEPTION(eslESYS, "pack failed");
  }

  /* Send the packed data to destination  */
  MPI_Send(*buf, n, MPI_PACKED, dest, tag, comm);
  return eslOK;

 ERROR:
  return status;
}

/* Function:  cm_alndata_MPIUnpack()
 * Synopsis:  Unpacks a CM_ALNDATA from an MPI buffer.
 * Incept:    EPN, Fri Jan 13 10:30:05 2012
 *
 * Purpose:   Allocate for and fill a new CM_ALNDATA object
 *            from MPI packed buffer <buf>, starting from
 *            position <*pos>, where the total length of the
 *            buffer in bytes is <n>. Return it in
 *            <*ret_data>. Caller is responsible for free'ing
 *            it.
 *
 * Returns:   <eslOK> on success. <*pos> is updated to the position of
 *            the next element in <buf> to unpack (if any). <*ret_alndata>
 *            contains a newly allocated HIT, which the caller is
 *            responsible for free'ing.
 *
 * Throws:    <eslESYS> on an MPI call failure. <eslEMEM> on allocation failure.
 *            In either case, <*ret_data> is <NULL>, and the state of <buf>
 *            and <*pos> is undefined and should be considered to be corrupted.
 */
int
cm_alndata_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, ESL_ALPHABET *abc, CM_ALNDATA **ret_data)
{
  int          status;
  CM_ALNDATA  *data = NULL;
  int          has_sq;
  int          has_tr;
  int          has_ppstr;
  int64_t      pplen; /* length of ppstr */

  if ((data = cm_alndata_Create()) == NULL) { status = eslEMEM; goto ERROR; }

  /* mandatory stuff */
  if (MPI_Unpack(buf, n, pos, &(data->idx),            1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->sc),             1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->pp),             1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->spos),           1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->epos),           1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->secs_bands),     1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->secs_aln),       1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->secs_tot),       1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->mb_tot),         1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->tau),            1, MPI_DOUBLE,        comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->thresh1),        1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &(data->thresh2),        1, MPI_FLOAT,         comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  /* optional stuff */
  if (MPI_Unpack(buf, n, pos, &has_sq,                 1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &has_tr,                 1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (MPI_Unpack(buf, n, pos, &has_ppstr,              1, MPI_INT,           comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  if (has_sq) {
	if ((status = esl_sq_MPIUnpack(abc, buf, n, pos, comm, &(data->sq)))  != eslOK)      ESL_XEXCEPTION(eslESYS, "unpack failed");

  }
  if (has_tr) {
	if ((status = cm_parsetree_MPIUnpack(buf, n, pos, comm, &(data->tr))) != eslOK)      ESL_XEXCEPTION(eslESYS, "unpack failed");
  }
  if (has_ppstr) {
	if (MPI_Unpack(buf, n, pos, &pplen,                1, MPI_LONG_LONG_INT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
	ESL_ALLOC(data->ppstr, sizeof(char) * pplen);
	if (MPI_Unpack(buf, n, pos, data->ppstr,       pplen, MPI_CHAR,          comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
  }
  *ret_data = data;
  return eslOK;

 ERROR:
  if (data != NULL) cm_alndata_Destroy(data, TRUE);
  *ret_data = NULL;
  return status;
}

#endif

/*** End of inlined file: mpisupport.c ***/


/*** Start of inlined file: prior.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>


Prior_t *
Prior_Create(void)
{
  int      status;
  Prior_t *pri;
  int      a, b;

  ESL_ALLOC(pri, sizeof(Prior_t));
  pri->tsetnum   = 0;
  pri->t         = NULL;
  pri->mbp       = NULL;
  pri->mnt       = NULL;
  pri->i         = NULL;
  pri->maxnq     = 0;
  pri->maxnalpha = 0;

  for(a = 0; a < UNIQUESTATES; a++)
	for(b = 0; b < NODETYPES; b++)
	  pri->tsetmap[a][b] = -1;

  return pri;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function:  Prior_Destroy()
 * Incept:    SRE, Mon Apr 11 10:06:34 2005 [St. Louis]
 *
 * Purpose:   Free's a prior.
 */
void
Prior_Destroy(Prior_t *pri)
{
  int i;
  if (pri == NULL) return;
  if (pri->t != NULL)
	{
	  for (i = 0; i < pri->tsetnum; i++)
	esl_mixdchlet_Destroy(pri->t[i]);
	  free(pri->t);
	}
  esl_mixdchlet_Destroy(pri->mbp);
  esl_mixdchlet_Destroy(pri->mnt);
  esl_mixdchlet_Destroy(pri->i);
  free(pri);
}

/* Function: Prior_Read()
 *
 * Purpose:  Input a transition prior from an open stream
 *           (probably an open file).
 */
Prior_t *
Prior_Read(FILE *fp)
{
  Prior_t         *pri;
  ESL_FILEPARSER  *efp;
  char            *tok;
  int              toklen;
  int              status;

  int              i;       /*counter over transition sets*/
  int              curr_state_id;
  int              curr_next_node_id;

  pri = Prior_Create();

  if ((efp = esl_fileparser_Create(fp)) == NULL)
	cm_Fail("Failed to associate open prior file stream with fileparser");
  esl_fileparser_SetCommentChar(efp, '#');

  /* First entry is the strategy: "Dirichlet" is the only possibility now. */
  if ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) != eslOK)
	cm_Fail("%s\nPrior file parse failed, on first (Dirichlet) field", efp->errbuf);
  if (strcasecmp(tok, "Dirichlet") != 0)
	cm_Fail("No such prior strategy %s\n", tok);

  /* Second entry is NTRANSSETS, which ought to be 74 */
  if ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) != eslOK)
	cm_Fail("%s\nPrior file parse failed reading NTRANSSETS", efp->errbuf);
  pri->tsetnum = atoi(tok);
  ESL_ALLOC(pri->t, sizeof(ESL_MIXDCHLET *) * pri->tsetnum);

  /* Transition section: a whole bunch of mixture Dirichlets.
   */
  for (i = 0; i < pri->tsetnum; i++)
	{
	  if ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) != eslOK)
	cm_Fail("%s\nPrior file parse failed at line %d reading unique statetype",
	    efp->errbuf, efp->linenumber);
	  if ((curr_state_id = UniqueStateCode(tok)) == -1)
	cm_Fail("%s is not a uniq state;\nPrior file parse failed, line %d\n",
	    tok, efp->linenumber);

	  if ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) != eslOK)
	cm_Fail("%s\nPrior file parse failed reading node code", efp->errbuf);
	  if ((curr_next_node_id = NodeCode(tok)) == -1)
	cm_Fail("%s is not a node code;\nPrior file parse failed, line %d\n",
	    tok, efp->linenumber);

	  pri->tsetmap[curr_state_id][curr_next_node_id] = i;

	  if (esl_mixdchlet_Read(efp, &(pri->t[i])) != eslOK)
	cm_Fail("%s\nPrior file parse failed, reading transition prior %d at line %d.",
	    efp->errbuf, i, efp->linenumber);
	  if (pri->t[i]->N > pri->maxnq)     pri->maxnq     = pri->t[i]->N;
	  if (pri->t[i]->K > pri->maxnalpha) pri->maxnalpha = pri->t[i]->K;
	}

  /* Consensus base pair emission prior section.
   */
  if (esl_mixdchlet_Read(efp, &(pri->mbp)) != eslOK)
	cm_Fail("%s\nPrior file parse failed in base pair priors at line %d\n",
	efp->errbuf, efp->linenumber);
  if (pri->mbp->N > pri->maxnq)     pri->maxnq     = pri->mbp->N;
  if (pri->mbp->K > pri->maxnalpha) pri->maxnalpha = pri->mbp->K;

  /* Consensus singlet emission prior section.
   */
  if (esl_mixdchlet_Read(efp, &(pri->mnt)) != eslOK)
	cm_Fail("%s\nPrior file parse failed in consensus singlet priors at line %d\n",
	efp->errbuf, efp->linenumber);
  if (pri->mnt->N > pri->maxnq)     pri->maxnq     = pri->mnt->N;
  if (pri->mnt->K > pri->maxnalpha) pri->maxnalpha = pri->mnt->K;

  /* Nonconsensus singlet emission prior section.
   */
  if (esl_mixdchlet_Read(efp, &(pri->i)) != eslOK)
	cm_Fail("%s\nPrior file parse failed in nonconsensus singlet priors at line %d\n",
	efp->errbuf, efp->linenumber);
  if (pri->i->N > pri->maxnq)     pri->maxnq     = pri->i->N;
  if (pri->i->K > pri->maxnalpha) pri->maxnalpha = pri->i->K;

  esl_fileparser_Destroy(efp);
  return pri;

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/* Function: PriorifyCM()
 *
 * Purpose:  Given a CM containing counts; add pseudocounts to a CM
 *           using Dirichlet priors, and renormalize the CM.
 *
 *           The Easel Dirichlet routines are in double-precision,
 *           whereas the CM is in floats, so we have some internal vector
 *           conversion going on here.
 *
 * Args:     CM -- the CM to add counts to (counts form)
 *           pri -- the Dirichlet prior to use
 *
 * Return:   (void)
 *           CM is changed from counts to probability form.
 */
void
PriorifyCM(CM_t *cm, const Prior_t *pri)
{
  int status;
  int v;		/* counter for model position   */
  int setnum;           /* number of set to use */
  int nxtndtype;        /* type of next node */
  double *counts;	/* double copy of floating-pt counts in the CM */
  double *probs;	/* double copy of new probability parameters */
  double *mixq;		/* posterior probs of mixture components, P(q | c) */
  int      i;

  /* Create our temporary buffers; counts, probs, and mixq.
   */
  ESL_ALLOC(counts, sizeof(double) * pri->maxnalpha);
  ESL_ALLOC(probs,  sizeof(double) * pri->maxnalpha);
  ESL_ALLOC(mixq,   sizeof(double) * pri->maxnq);

  for (v = 0; v < cm->M; v++)
	{
	  /* Priorify transition vector if not a BIF or E state */
	  if (cm->sttype[v] != B_st && cm->sttype[v] != E_st)
	{
	  /* Determine which transition set to use.
	   * Current unique state id is easy (cm->stid[v]).
		   * Type of next node is a little trickier. The trick is
		   * to use the ndidx of the *last* state this state v
		   * connects to. This is guaranteed to be in the next node,
		   * cannot be an insert state of the current node.
	   */
	  nxtndtype = cm->ndtype[cm->ndidx[cm->cfirst[v] + cm->cnum[v] - 1]];
	  setnum = pri->tsetmap[(int) cm->stid[v]][nxtndtype];
	  for (i = 0; i < cm->cnum[v]; i++)
	    counts[i] = (double) cm->t[v][i];

	  esl_mixdchlet_MPParameters(counts, cm->cnum[v],
				     pri->t[setnum],
				     mixq, probs);

	  for (i = 0; i < cm->cnum[v]; i++)
	    cm->t[v][i] = (float) probs[i];
	}

	  if(!(cm->flags & CM_RSEARCHEMIT)) /* in rsearch emit mode, do not priorify emissions */
	{
	  /* Emission priors
	   */
	  if (cm->sttype[v] == MP_st)
	    {       /* Consensus base pairs */
	      for (i = 0; i < cm->abc->K*cm->abc->K; i++)
		counts[i] = (double) cm->e[v][i];

	      esl_mixdchlet_MPParameters(counts, cm->abc->K*cm->abc->K,
					 pri->mbp,
					 mixq, probs);

	      for (i = 0; i < cm->abc->K*cm->abc->K; i++)
		cm->e[v][i] = (float) probs[i];
	    }
	  else if (cm->stid[v] == MATL_ML || cm->stid[v] == MATR_MR)
	    {      /* Consensus singlets */
	      for (i = 0; i < cm->abc->K; i++)
		counts[i] = (double) cm->e[v][i];

	      esl_mixdchlet_MPParameters(counts, cm->abc->K,
					 pri->mnt,
					 mixq, probs);

	      for (i = 0; i < cm->abc->K; i++)
		cm->e[v][i] = (float) probs[i];
	    }
	  else if (cm->sttype[v] == IL_st || cm->sttype[v] == IR_st ||
		   cm->stid[v] == MATP_ML || cm->stid[v] == MATP_MR)
	    {	/* nonconsensus singlets */
	      for (i = 0; i < cm->abc->K; i++)
		counts[i] = (double) cm->e[v][i];

	      esl_mixdchlet_MPParameters(counts, cm->abc->K,
					 pri->i,
					 mixq, probs);

	      for (i = 0; i < cm->abc->K; i++)
		cm->e[v][i] = (float) probs[i];
	    }
	}
	}/* end loop over states v */

  free(mixq);
  free(counts);
  free(probs);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/* Function:  Prior_Default()
 * Incept:    EPN, Thu Sep 16 11:27:09 2010
 *
 * Purpose:   Creates and returns the default mixture Dirichlet prior.
 *            Updated post-version 1.0.2.
 *
 *            This prior was trained on 82 seed alignments from
 *            Rfam 10.0. This set was suggested by Paul Gardner as
 *            the 'best' seeds in Rfam. Each alignment was used
 *            to build a model, then the model was used to realign
 *            all the seed sequences. Residues with posterior
 *            probabilities < 0.95 were removed. See
 *            ~nawrockie/notebook/10_0722_inf_prior_reestimation/
 *            for details.
 *            This prior is the A3.O3.c10.t1 prior in notes in the
 *            OOLOG in that directory. It is the 'p33' prior referred
 *            to in ~nawrockie/notebook/10_0913_lm/ lab meeting
 *            slides.
 *
 *            The decision to make this a new prior was based on
 *            improved performance on the rmark3 benchmark (especially
 *            for HMMs and HMM filtering (fewer hits were missed
 *            with fixed survival fraction (S=0.02) filtering)).
 *
 *            If <mimic_h3> is TRUE, different priors are used for the
 *            singlet emissions and insert emissions and transitions
 *            out of MATL nodes. The priors used are the the default
 *            nhmmer (H3 nucleotide) emission and transition.
 *            <mimic_h3> should normally only be TRUE if the prior
 *            will be used to parameterize models with 0 basepairs
 *            (i.e. a ROOT, an END and all MATL nodes). This allows
 *            those models without structure to use different priors
 *            than those with structure.
 *
 *            Most of the code in this function is autogenerated
 *            by a Perl script, prifile2code.pl, which converts a prior
 *            file to C code. xref 2005/0415-infernal-defaultprior.
 *            However, the code within the if(mimic_h3) block
 *            was not created by that script, it was manually added
 *            to the script's output.
 *
 * Returns:   ptr to the new prior structure.
 *
 * Xref:      ~nawrockie/notebook/10_0722_inf_prior_reestimation/
 *            ~nawrockie/notebook/10_0830_inf_rmark3_again/
 *            ~nawrockie/notebook/10_0913_lm/
 *            ~nawrockie/notebook/12_0403_inf_hmmonly/ [mimic_h3]
 */
Prior_t *
Prior_Default(int mimic_h3)
{
  int status;
  Prior_t *pri;

  pri = Prior_Create();

  pri->tsetnum = 74;
  ESL_ALLOC(pri->t, sizeof(ESL_MIXDCHLET *) * pri->tsetnum);

  /*****************************************************************
   * The code block below is autogenerated:
   *  ./prifile2code.pl mixture.pri > foo
   * xref 0415-infernal-defaultprior
   */
   pri->tsetmap[MATP_MP][BIF_nd] = 0;
   pri->t[0] = esl_mixdchlet_Create(1, 3);
   pri->t[0]->pq[0] = 1.0;
   pri->t[0]->alpha[0][0] = 0.067710091654;
   pri->t[0]->alpha[0][1] = 0.000047753225;
   pri->t[0]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[MATP_MP][END_nd] = 1;
   pri->t[1] = esl_mixdchlet_Create(1, 3);
   pri->t[1]->pq[0] = 1.0;
   pri->t[1]->alpha[0][0] = 0.067710091654;
   pri->t[1]->alpha[0][1] = 0.000047753225;
   pri->t[1]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[MATP_MP][MATL_nd] = 2;
   pri->t[2] = esl_mixdchlet_Create(1, 4);
   pri->t[2]->pq[0] = 1.0;
   pri->t[2]->alpha[0][0] = 0.028518011579;
   pri->t[2]->alpha[0][1] = 0.024705844026;
   pri->t[2]->alpha[0][2] = 1.464047470747;
   pri->t[2]->alpha[0][3] = 0.074164509948;

   pri->tsetmap[MATP_MP][MATP_nd] = 3;
   pri->t[3] = esl_mixdchlet_Create(1, 6);
   pri->t[3]->pq[0] = 1.0;
   pri->t[3]->alpha[0][0] = 0.016729608598;
   pri->t[3]->alpha[0][1] = 0.017449035307;
   pri->t[3]->alpha[0][2] = 7.164604225972;
   pri->t[3]->alpha[0][3] = 0.040744980202;
   pri->t[3]->alpha[0][4] = 0.033562178957;
   pri->t[3]->alpha[0][5] = 0.025523202345;

   pri->tsetmap[MATP_MP][MATR_nd] = 4;
   pri->t[4] = esl_mixdchlet_Create(1, 4);
   pri->t[4]->pq[0] = 1.0;
   pri->t[4]->alpha[0][0] = 0.032901537296;
   pri->t[4]->alpha[0][1] = 0.013876834787;
   pri->t[4]->alpha[0][2] = 1.694917068307;
   pri->t[4]->alpha[0][3] = 0.162141225286;

   pri->tsetmap[MATP_ML][BIF_nd] = 5;
   pri->t[5] = esl_mixdchlet_Create(1, 3);
   pri->t[5]->pq[0] = 1.0;
   pri->t[5]->alpha[0][0] = 1.0;
   pri->t[5]->alpha[0][1] = 1.0;
   pri->t[5]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_ML][END_nd] = 6;
   pri->t[6] = esl_mixdchlet_Create(1, 3);
   pri->t[6]->pq[0] = 1.0;
   pri->t[6]->alpha[0][0] = 1.0;
   pri->t[6]->alpha[0][1] = 1.0;
   pri->t[6]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_ML][MATL_nd] = 7;
   pri->t[7] = esl_mixdchlet_Create(1, 4);
   pri->t[7]->pq[0] = 1.0;
   pri->t[7]->alpha[0][0] = 0.068859974656;
   pri->t[7]->alpha[0][1] = 0.060683472648;
   pri->t[7]->alpha[0][2] = 0.655691547663;
   pri->t[7]->alpha[0][3] = 0.146392271070;

   pri->tsetmap[MATP_ML][MATP_nd] = 8;
   pri->t[8] = esl_mixdchlet_Create(1, 6);
   pri->t[8]->pq[0] = 1.0;
   pri->t[8]->alpha[0][0] = 0.009119452604;
   pri->t[8]->alpha[0][1] = 0.007174198989;
   pri->t[8]->alpha[0][2] = 0.279841652851;
   pri->t[8]->alpha[0][3] = 0.345855381430;
   pri->t[8]->alpha[0][4] = 0.007961193216;
   pri->t[8]->alpha[0][5] = 0.044123881735;

   pri->tsetmap[MATP_ML][MATR_nd] = 9;
   pri->t[9] = esl_mixdchlet_Create(1, 4);
   pri->t[9]->pq[0] = 1.0;
   pri->t[9]->alpha[0][0] = 0.061640259819;
   pri->t[9]->alpha[0][1] = 0.014142411829;
   pri->t[9]->alpha[0][2] = 0.133564345209;
   pri->t[9]->alpha[0][3] = 0.117860328247;

   pri->tsetmap[MATP_MR][BIF_nd] = 10;
   pri->t[10] = esl_mixdchlet_Create(1, 3);
   pri->t[10]->pq[0] = 1.0;
   pri->t[10]->alpha[0][0] = 1.0;
   pri->t[10]->alpha[0][1] = 1.0;
   pri->t[10]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_MR][END_nd] = 11;
   pri->t[11] = esl_mixdchlet_Create(1, 3);
   pri->t[11]->pq[0] = 1.0;
   pri->t[11]->alpha[0][0] = 1.0;
   pri->t[11]->alpha[0][1] = 1.0;
   pri->t[11]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_MR][MATL_nd] = 12;
   pri->t[12] = esl_mixdchlet_Create(1, 4);
   pri->t[12]->pq[0] = 1.0;
   pri->t[12]->alpha[0][0] = 0.024723293475;
   pri->t[12]->alpha[0][1] = 0.048463880304;
   pri->t[12]->alpha[0][2] = 0.212532685951;
   pri->t[12]->alpha[0][3] = 0.407547325080;

   pri->tsetmap[MATP_MR][MATP_nd] = 13;
   pri->t[13] = esl_mixdchlet_Create(1, 6);
   pri->t[13]->pq[0] = 1.0;
   pri->t[13]->alpha[0][0] = 0.006294030132;
   pri->t[13]->alpha[0][1] = 0.015189408169;
   pri->t[13]->alpha[0][2] = 0.258896467198;
   pri->t[13]->alpha[0][3] = 0.015420910305;
   pri->t[13]->alpha[0][4] = 0.449746529026;
   pri->t[13]->alpha[0][5] = 0.053194553636;

   pri->tsetmap[MATP_MR][MATR_nd] = 14;
   pri->t[14] = esl_mixdchlet_Create(1, 4);
   pri->t[14]->pq[0] = 1.0;
   pri->t[14]->alpha[0][0] = 0.020819322736;
   pri->t[14]->alpha[0][1] = 0.000060497356;
   pri->t[14]->alpha[0][2] = 0.272689176849;
   pri->t[14]->alpha[0][3] = 0.063856784928;

   pri->tsetmap[MATP_D][BIF_nd] = 15;
   pri->t[15] = esl_mixdchlet_Create(1, 3);
   pri->t[15]->pq[0] = 1.0;
   pri->t[15]->alpha[0][0] = 1.0;
   pri->t[15]->alpha[0][1] = 1.0;
   pri->t[15]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_D][END_nd] = 16;
   pri->t[16] = esl_mixdchlet_Create(1, 3);
   pri->t[16]->pq[0] = 1.0;
   pri->t[16]->alpha[0][0] = 1.0;
   pri->t[16]->alpha[0][1] = 1.0;
   pri->t[16]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_D][MATL_nd] = 17;
   pri->t[17] = esl_mixdchlet_Create(1, 4);
   pri->t[17]->pq[0] = 1.0;
   pri->t[17]->alpha[0][0] = 0.024577940691;
   pri->t[17]->alpha[0][1] = 0.030655567559;
   pri->t[17]->alpha[0][2] = 0.121290355765;
   pri->t[17]->alpha[0][3] = 0.406621701238;

   pri->tsetmap[MATP_D][MATP_nd] = 18;
   pri->t[18] = esl_mixdchlet_Create(1, 6);
   pri->t[18]->pq[0] = 1.0;
   pri->t[18]->alpha[0][0] = 0.001029025955;
   pri->t[18]->alpha[0][1] = 0.002536729756;
   pri->t[18]->alpha[0][2] = 0.046719556839;
   pri->t[18]->alpha[0][3] = 0.029117903291;
   pri->t[18]->alpha[0][4] = 0.028767509361;
   pri->t[18]->alpha[0][5] = 0.436842892057;

   pri->tsetmap[MATP_D][MATR_nd] = 19;
   pri->t[19] = esl_mixdchlet_Create(1, 4);
   pri->t[19]->pq[0] = 1.0;
   pri->t[19]->alpha[0][0] = 0.000017041108;
   pri->t[19]->alpha[0][1] = 0.000007069171;
   pri->t[19]->alpha[0][2] = 0.028384306256;
   pri->t[19]->alpha[0][3] = 0.087965488640;

   pri->tsetmap[MATP_IL][BIF_nd] = 20;
   pri->t[20] = esl_mixdchlet_Create(1, 3);
   pri->t[20]->pq[0] = 1.0;
   pri->t[20]->alpha[0][0] = 0.943443048986;
   pri->t[20]->alpha[0][1] = 0.064001237265;
   pri->t[20]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[MATP_IL][END_nd] = 21;
   pri->t[21] = esl_mixdchlet_Create(1, 3);
   pri->t[21]->pq[0] = 1.0;
   pri->t[21]->alpha[0][0] = 0.943443048986;
   pri->t[21]->alpha[0][1] = 0.064001237265;
   pri->t[21]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[MATP_IL][MATL_nd] = 22;
   pri->t[22] = esl_mixdchlet_Create(1, 4);
   pri->t[22]->pq[0] = 1.0;
   pri->t[22]->alpha[0][0] = 0.250101882938;
   pri->t[22]->alpha[0][1] = 0.155728904821;
   pri->t[22]->alpha[0][2] = 0.370945030932;
   pri->t[22]->alpha[0][3] = 0.027811408475;

   pri->tsetmap[MATP_IL][MATP_nd] = 23;
   pri->t[23] = esl_mixdchlet_Create(1, 6);
   pri->t[23]->pq[0] = 1.0;
   pri->t[23]->alpha[0][0] = 0.157307265492;
   pri->t[23]->alpha[0][1] = 0.131105492208;
   pri->t[23]->alpha[0][2] = 0.555106727689;
   pri->t[23]->alpha[0][3] = 0.041624804903;
   pri->t[23]->alpha[0][4] = 0.024305424386;
   pri->t[23]->alpha[0][5] = 0.030756705205;

   pri->tsetmap[MATP_IL][MATR_nd] = 24;
   pri->t[24] = esl_mixdchlet_Create(1, 4);
   pri->t[24]->pq[0] = 1.0;
   pri->t[24]->alpha[0][0] = 0.155093374292;
   pri->t[24]->alpha[0][1] = 0.054734614999;
   pri->t[24]->alpha[0][2] = 0.714409186001;
   pri->t[24]->alpha[0][3] = 0.168407110635;

   pri->tsetmap[MATP_IR][BIF_nd] = 25;
   pri->t[25] = esl_mixdchlet_Create(1, 2);
   pri->t[25]->pq[0] = 1.0;
   pri->t[25]->alpha[0][0] = 0.264643213319;
   pri->t[25]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATP_IR][END_nd] = 26;
   pri->t[26] = esl_mixdchlet_Create(1, 2);
   pri->t[26]->pq[0] = 1.0;
   pri->t[26]->alpha[0][0] = 0.264643213319;
   pri->t[26]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATP_IR][MATL_nd] = 27;
   pri->t[27] = esl_mixdchlet_Create(1, 3);
   pri->t[27]->pq[0] = 1.0;
   pri->t[27]->alpha[0][0] = 0.601223387577;
   pri->t[27]->alpha[0][1] = 0.939499051719;
   pri->t[27]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[MATP_IR][MATP_nd] = 28;
   pri->t[28] = esl_mixdchlet_Create(1, 5);
   pri->t[28]->pq[0] = 1.0;
   pri->t[28]->alpha[0][0] = 0.291829430523;
   pri->t[28]->alpha[0][1] = 1.098441427679;
   pri->t[28]->alpha[0][2] = 0.025595408318;
   pri->t[28]->alpha[0][3] = 0.091146313822;
   pri->t[28]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATP_IR][MATR_nd] = 29;
   pri->t[29] = esl_mixdchlet_Create(1, 3);
   pri->t[29]->pq[0] = 1.0;
   pri->t[29]->alpha[0][0] = 0.327208719748;
   pri->t[29]->alpha[0][1] = 0.846283302435;
   pri->t[29]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[MATL_ML][BIF_nd] = 30;
   pri->t[30] = esl_mixdchlet_Create(1, 2);
   pri->t[30]->pq[0] = 1.0;
   pri->t[30]->alpha[0][0] = 0.009635966745;
   pri->t[30]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATL_ML][END_nd] = 31;
   pri->t[31] = esl_mixdchlet_Create(1, 2);
   pri->t[31]->pq[0] = 1.0;
   pri->t[31]->alpha[0][0] = 0.009635966745;
   pri->t[31]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATL_ML][MATL_nd] = 32;
   pri->t[32] = esl_mixdchlet_Create(1, 3);
   pri->t[32]->pq[0] = 1.0;
   pri->t[32]->alpha[0][0] = 0.015185708311;
   pri->t[32]->alpha[0][1] = 1.809432933023;
   pri->t[32]->alpha[0][2] = 0.038601480352;

   pri->tsetmap[MATL_ML][MATP_nd] = 33;
   pri->t[33] = esl_mixdchlet_Create(1, 5);
   pri->t[33]->pq[0] = 1.0;
   pri->t[33]->alpha[0][0] = 0.031820644019;
   pri->t[33]->alpha[0][1] = 2.300193431878;
   pri->t[33]->alpha[0][2] = 0.036163737927;
   pri->t[33]->alpha[0][3] = 0.031218244200;
   pri->t[33]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[MATL_ML][MATR_nd] = 34;
   pri->t[34] = esl_mixdchlet_Create(1, 3);
   pri->t[34]->pq[0] = 1.0;
   pri->t[34]->alpha[0][0] = 0.012395245929;
   pri->t[34]->alpha[0][1] = 2.076134487839;
   pri->t[34]->alpha[0][2] = 0.039781067793;

   pri->tsetmap[MATL_D][BIF_nd] = 35;
   pri->t[35] = esl_mixdchlet_Create(1, 2);
   pri->t[35]->pq[0] = 1.0;
   pri->t[35]->alpha[0][0] = 0.019509171372;
   pri->t[35]->alpha[0][1] = 6.781321301695;

   pri->tsetmap[MATL_D][END_nd] = 36;
   pri->t[36] = esl_mixdchlet_Create(1, 2);
   pri->t[36]->pq[0] = 1.0;
   pri->t[36]->alpha[0][0] = 0.019509171372;
   pri->t[36]->alpha[0][1] = 6.781321301695;

   pri->tsetmap[MATL_D][MATL_nd] = 37;
   pri->t[37] = esl_mixdchlet_Create(1, 3);
   pri->t[37]->pq[0] = 1.0;
   pri->t[37]->alpha[0][0] = 0.005679808868;
   pri->t[37]->alpha[0][1] = 0.127365862719;
   pri->t[37]->alpha[0][2] = 0.277086556814;

   pri->tsetmap[MATL_D][MATP_nd] = 38;
   pri->t[38] = esl_mixdchlet_Create(1, 5);
   pri->t[38]->pq[0] = 1.0;
   pri->t[38]->alpha[0][0] = 0.023424968753;
   pri->t[38]->alpha[0][1] = 0.417640407951;
   pri->t[38]->alpha[0][2] = 0.039088991906;
   pri->t[38]->alpha[0][3] = 0.120577442402;
   pri->t[38]->alpha[0][4] = 0.128103786646;

   pri->tsetmap[MATL_D][MATR_nd] = 39;
   pri->t[39] = esl_mixdchlet_Create(1, 3);
   pri->t[39]->pq[0] = 1.0;
   pri->t[39]->alpha[0][0] = 0.013699691994;
   pri->t[39]->alpha[0][1] = 0.405128575339;
   pri->t[39]->alpha[0][2] = 0.254775565405;

   pri->tsetmap[MATL_IL][BIF_nd] = 40;
   pri->t[40] = esl_mixdchlet_Create(1, 2);
   pri->t[40]->pq[0] = 1.0;
   pri->t[40]->alpha[0][0] = 0.264643213319;
   pri->t[40]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATL_IL][END_nd] = 41;
   pri->t[41] = esl_mixdchlet_Create(1, 2);
   pri->t[41]->pq[0] = 1.0;
   pri->t[41]->alpha[0][0] = 0.264643213319;
   pri->t[41]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATL_IL][MATL_nd] = 42;
   pri->t[42] = esl_mixdchlet_Create(1, 3);
   pri->t[42]->pq[0] = 1.0;
   pri->t[42]->alpha[0][0] = 0.601223387577;
   pri->t[42]->alpha[0][1] = 0.939499051719;
   pri->t[42]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[MATL_IL][MATP_nd] = 43;
   pri->t[43] = esl_mixdchlet_Create(1, 5);
   pri->t[43]->pq[0] = 1.0;
   pri->t[43]->alpha[0][0] = 0.291829430523;
   pri->t[43]->alpha[0][1] = 1.098441427679;
   pri->t[43]->alpha[0][2] = 0.091146313822;
   pri->t[43]->alpha[0][3] = 0.025595408318;
   pri->t[43]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATL_IL][MATR_nd] = 44;
   pri->t[44] = esl_mixdchlet_Create(1, 3);
   pri->t[44]->pq[0] = 1.0;
   pri->t[44]->alpha[0][0] = 0.327208719748;
   pri->t[44]->alpha[0][1] = 0.846283302435;
   pri->t[44]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[MATR_MR][BIF_nd] = 45;
   pri->t[45] = esl_mixdchlet_Create(1, 2);
   pri->t[45]->pq[0] = 1.0;
   pri->t[45]->alpha[0][0] = 0.009635966745;
   pri->t[45]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATR_MR][MATP_nd] = 46;
   pri->t[46] = esl_mixdchlet_Create(1, 5);
   pri->t[46]->pq[0] = 1.0;
   pri->t[46]->alpha[0][0] = 0.031820644019;
   pri->t[46]->alpha[0][1] = 2.300193431878;
   pri->t[46]->alpha[0][2] = 0.036163737927;
   pri->t[46]->alpha[0][3] = 0.031218244200;
   pri->t[46]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[MATR_MR][MATR_nd] = 47;
   pri->t[47] = esl_mixdchlet_Create(1, 3);
   pri->t[47]->pq[0] = 1.0;
   pri->t[47]->alpha[0][0] = 0.012395245929;
   pri->t[47]->alpha[0][1] = 2.076134487839;
   pri->t[47]->alpha[0][2] = 0.039781067793;

   pri->tsetmap[MATR_D][BIF_nd] = 48;
   pri->t[48] = esl_mixdchlet_Create(1, 2);
   pri->t[48]->pq[0] = 1.0;
   pri->t[48]->alpha[0][0] = 0.021604946951;
   pri->t[48]->alpha[0][1] = 0.444765555211;

   pri->tsetmap[MATR_D][MATP_nd] = 49;
   pri->t[49] = esl_mixdchlet_Create(1, 5);
   pri->t[49]->pq[0] = 1.0;
   pri->t[49]->alpha[0][0] = 0.021273745319;
   pri->t[49]->alpha[0][1] = 0.532292228853;
   pri->t[49]->alpha[0][2] = 0.110249350652;
   pri->t[49]->alpha[0][3] = 0.040890357850;
   pri->t[49]->alpha[0][4] = 0.164194410420;

   pri->tsetmap[MATR_D][MATR_nd] = 50;
   pri->t[50] = esl_mixdchlet_Create(1, 3);
   pri->t[50]->pq[0] = 1.0;
   pri->t[50]->alpha[0][0] = 0.005806440507;
   pri->t[50]->alpha[0][1] = 0.164264844267;
   pri->t[50]->alpha[0][2] = 0.316876127883;

   pri->tsetmap[MATR_IR][BIF_nd] = 51;
   pri->t[51] = esl_mixdchlet_Create(1, 2);
   pri->t[51]->pq[0] = 1.0;
   pri->t[51]->alpha[0][0] = 0.264643213319;
   pri->t[51]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATR_IR][MATP_nd] = 52;
   pri->t[52] = esl_mixdchlet_Create(1, 5);
   pri->t[52]->pq[0] = 1.0;
   pri->t[52]->alpha[0][0] = 0.291829430523;
   pri->t[52]->alpha[0][1] = 1.098441427679;
   pri->t[52]->alpha[0][2] = 0.025595408318;
   pri->t[52]->alpha[0][3] = 0.091146313822;
   pri->t[52]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATR_IR][MATR_nd] = 53;
   pri->t[53] = esl_mixdchlet_Create(1, 3);
   pri->t[53]->pq[0] = 1.0;
   pri->t[53]->alpha[0][0] = 0.327208719748;
   pri->t[53]->alpha[0][1] = 0.846283302435;
   pri->t[53]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[BEGL_S][BIF_nd] = 54;
   pri->t[54] = esl_mixdchlet_Create(1, 1);
   pri->t[54]->pq[0] = 1.0;
   pri->t[54]->alpha[0][0] = 1.0;

   pri->tsetmap[BEGL_S][MATP_nd] = 55;
   pri->t[55] = esl_mixdchlet_Create(1, 4);
   pri->t[55]->pq[0] = 1.0;
   pri->t[55]->alpha[0][0] = 4.829712747509;
   pri->t[55]->alpha[0][1] = 0.061131109227;
   pri->t[55]->alpha[0][2] = 0.092185242101;
   pri->t[55]->alpha[0][3] = 0.059154827887;

   pri->tsetmap[BEGR_S][BIF_nd] = 56;
   pri->t[56] = esl_mixdchlet_Create(1, 2);
   pri->t[56]->pq[0] = 1.0;
   pri->t[56]->alpha[0][0] = 0.009635966745;
   pri->t[56]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[BEGR_S][MATL_nd] = 57;
   pri->t[57] = esl_mixdchlet_Create(1, 3);
   pri->t[57]->pq[0] = 1.0;
   pri->t[57]->alpha[0][0] = 0.015185708311;
   pri->t[57]->alpha[0][1] = 1.809432933023;
   pri->t[57]->alpha[0][2] = 0.038601480352;

   pri->tsetmap[BEGR_S][MATP_nd] = 58;
   pri->t[58] = esl_mixdchlet_Create(1, 5);
   pri->t[58]->pq[0] = 1.0;
   pri->t[58]->alpha[0][0] = 0.031820644019;
   pri->t[58]->alpha[0][1] = 2.300193431878;
   pri->t[58]->alpha[0][2] = 0.036163737927;
   pri->t[58]->alpha[0][3] = 0.031218244200;
   pri->t[58]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[BEGR_IL][BIF_nd] = 59;
   pri->t[59] = esl_mixdchlet_Create(1, 2);
   pri->t[59]->pq[0] = 1.0;
   pri->t[59]->alpha[0][0] = 0.264643213319;
   pri->t[59]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[BEGR_IL][MATL_nd] = 60;
   pri->t[60] = esl_mixdchlet_Create(1, 3);
   pri->t[60]->pq[0] = 1.0;
   pri->t[60]->alpha[0][0] = 0.601223387577;
   pri->t[60]->alpha[0][1] = 0.939499051719;
   pri->t[60]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[BEGR_IL][MATP_nd] = 61;
   pri->t[61] = esl_mixdchlet_Create(1, 5);
   pri->t[61]->pq[0] = 1.0;
   pri->t[61]->alpha[0][0] = 0.291829430523;
   pri->t[61]->alpha[0][1] = 1.098441427679;
   pri->t[61]->alpha[0][2] = 0.091146313822;
   pri->t[61]->alpha[0][3] = 0.025595408318;
   pri->t[61]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[ROOT_S][BIF_nd] = 62;
   pri->t[62] = esl_mixdchlet_Create(1, 3);
   pri->t[62]->pq[0] = 1.0;
   pri->t[62]->alpha[0][0] = 0.067710091654;
   pri->t[62]->alpha[0][1] = 0.000047753225;
   pri->t[62]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[ROOT_S][MATL_nd] = 63;
   pri->t[63] = esl_mixdchlet_Create(1, 4);
   pri->t[63]->pq[0] = 1.0;
   pri->t[63]->alpha[0][0] = 0.028518011579;
   pri->t[63]->alpha[0][1] = 0.024705844026;
   pri->t[63]->alpha[0][2] = 1.464047470747;
   pri->t[63]->alpha[0][3] = 0.074164509948;

   pri->tsetmap[ROOT_S][MATP_nd] = 64;
   pri->t[64] = esl_mixdchlet_Create(1, 6);
   pri->t[64]->pq[0] = 1.0;
   pri->t[64]->alpha[0][0] = 0.016729608598;
   pri->t[64]->alpha[0][1] = 0.017449035307;
   pri->t[64]->alpha[0][2] = 7.164604225972;
   pri->t[64]->alpha[0][3] = 0.040744980202;
   pri->t[64]->alpha[0][4] = 0.033562178957;
   pri->t[64]->alpha[0][5] = 0.025523202345;

   pri->tsetmap[ROOT_S][MATR_nd] = 65;
   pri->t[65] = esl_mixdchlet_Create(1, 4);
   pri->t[65]->pq[0] = 1.0;
   pri->t[65]->alpha[0][0] = 0.032901537296;
   pri->t[65]->alpha[0][1] = 0.013876834787;
   pri->t[65]->alpha[0][2] = 1.694917068307;
   pri->t[65]->alpha[0][3] = 0.162141225286;

   pri->tsetmap[ROOT_IL][BIF_nd] = 66;
   pri->t[66] = esl_mixdchlet_Create(1, 3);
   pri->t[66]->pq[0] = 1.0;
   pri->t[66]->alpha[0][0] = 0.943443048986;
   pri->t[66]->alpha[0][1] = 0.064001237265;
   pri->t[66]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[ROOT_IL][MATL_nd] = 67;
   pri->t[67] = esl_mixdchlet_Create(1, 4);
   pri->t[67]->pq[0] = 1.0;
   pri->t[67]->alpha[0][0] = 0.250101882938;
   pri->t[67]->alpha[0][1] = 0.155728904821;
   pri->t[67]->alpha[0][2] = 0.370945030932;
   pri->t[67]->alpha[0][3] = 0.027811408475;

   pri->tsetmap[ROOT_IL][MATP_nd] = 68;
   pri->t[68] = esl_mixdchlet_Create(1, 6);
   pri->t[68]->pq[0] = 1.0;
   pri->t[68]->alpha[0][0] = 0.157307265492;
   pri->t[68]->alpha[0][1] = 0.131105492208;
   pri->t[68]->alpha[0][2] = 0.555106727689;
   pri->t[68]->alpha[0][3] = 0.041624804903;
   pri->t[68]->alpha[0][4] = 0.024305424386;
   pri->t[68]->alpha[0][5] = 0.030756705205;

   pri->tsetmap[ROOT_IL][MATR_nd] = 69;
   pri->t[69] = esl_mixdchlet_Create(1, 4);
   pri->t[69]->pq[0] = 1.0;
   pri->t[69]->alpha[0][0] = 0.155093374292;
   pri->t[69]->alpha[0][1] = 0.054734614999;
   pri->t[69]->alpha[0][2] = 0.714409186001;
   pri->t[69]->alpha[0][3] = 0.168407110635;

   pri->tsetmap[ROOT_IR][BIF_nd] = 70;
   pri->t[70] = esl_mixdchlet_Create(1, 2);
   pri->t[70]->pq[0] = 1.0;
   pri->t[70]->alpha[0][0] = 0.264643213319;
   pri->t[70]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[ROOT_IR][MATL_nd] = 71;
   pri->t[71] = esl_mixdchlet_Create(1, 3);
   pri->t[71]->pq[0] = 1.0;
   pri->t[71]->alpha[0][0] = 0.601223387577;
   pri->t[71]->alpha[0][1] = 0.939499051719;
   pri->t[71]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[ROOT_IR][MATP_nd] = 72;
   pri->t[72] = esl_mixdchlet_Create(1, 5);
   pri->t[72]->pq[0] = 1.0;
   pri->t[72]->alpha[0][0] = 0.291829430523;
   pri->t[72]->alpha[0][1] = 1.098441427679;
   pri->t[72]->alpha[0][2] = 0.025595408318;
   pri->t[72]->alpha[0][3] = 0.091146313822;
   pri->t[72]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[ROOT_IR][MATR_nd] = 73;
   pri->t[73] = esl_mixdchlet_Create(1, 3);
   pri->t[73]->pq[0] = 1.0;
   pri->t[73]->alpha[0][0] = 0.327208719748;
   pri->t[73]->alpha[0][1] = 0.846283302435;
   pri->t[73]->alpha[0][2] = 0.069337439204;

   pri->mbp = esl_mixdchlet_Create(10, 16);
   pri->mbp->pq[0] = 0.016584;
   pri->mbp->alpha[0][0] = 0.142252;
   pri->mbp->alpha[0][1] = 0.180113;
   pri->mbp->alpha[0][2] = 0.153776;
   pri->mbp->alpha[0][3] = 0.222524;
   pri->mbp->alpha[0][4] = 0.539721;
   pri->mbp->alpha[0][5] = 0.170380;
   pri->mbp->alpha[0][6] = 0.230123;
   pri->mbp->alpha[0][7] = 0.190004;
   pri->mbp->alpha[0][8] = 0.583682;
   pri->mbp->alpha[0][9] = 0.222992;
   pri->mbp->alpha[0][10] = 0.134277;
   pri->mbp->alpha[0][11] = 0.187596;
   pri->mbp->alpha[0][12] = 12172.002267;
   pri->mbp->alpha[0][13] = 0.546735;
   pri->mbp->alpha[0][14] = 14.841962;
   pri->mbp->alpha[0][15] = 17.271555;

   pri->mbp->pq[1] = 0.000948;
   pri->mbp->alpha[1][0] = 2.547410;
   pri->mbp->alpha[1][1] = 14.293143;
   pri->mbp->alpha[1][2] = 0.015263;
   pri->mbp->alpha[1][3] = 7.761130;
   pri->mbp->alpha[1][4] = 0.029915;
   pri->mbp->alpha[1][5] = 3.493007;
   pri->mbp->alpha[1][6] = 14.049507;
   pri->mbp->alpha[1][7] = 1.480341;
   pri->mbp->alpha[1][8] = 3.754643;
   pri->mbp->alpha[1][9] = 7.140983;
   pri->mbp->alpha[1][10] = 4.733217;
   pri->mbp->alpha[1][11] = 44.190624;
   pri->mbp->alpha[1][12] = 2.758417;
   pri->mbp->alpha[1][13] = 1.687945;
   pri->mbp->alpha[1][14] = 2.421882;
   pri->mbp->alpha[1][15] = 2.724272;

   pri->mbp->pq[2] = 0.185395;
   pri->mbp->alpha[2][0] = 0.054512;
   pri->mbp->alpha[2][1] = 0.067070;
   pri->mbp->alpha[2][2] = 0.054506;
   pri->mbp->alpha[2][3] = 1.210822;
   pri->mbp->alpha[2][4] = 0.119647;
   pri->mbp->alpha[2][5] = 0.030366;
   pri->mbp->alpha[2][6] = 3.188992;
   pri->mbp->alpha[2][7] = 0.076098;
   pri->mbp->alpha[2][8] = 0.060153;
   pri->mbp->alpha[2][9] = 1.426299;
   pri->mbp->alpha[2][10] = 0.042134;
   pri->mbp->alpha[2][11] = 0.362385;
   pri->mbp->alpha[2][12] = 2.308941;
   pri->mbp->alpha[2][13] = 0.048026;
   pri->mbp->alpha[2][14] = 0.695604;
   pri->mbp->alpha[2][15] = 0.146166;

   pri->mbp->pq[3] = 0.082929;
   pri->mbp->alpha[3][0] = 0.481661;
   pri->mbp->alpha[3][1] = 0.414811;
   pri->mbp->alpha[3][2] = 0.419836;
   pri->mbp->alpha[3][3] = 3.024237;
   pri->mbp->alpha[3][4] = 0.421853;
   pri->mbp->alpha[3][5] = 0.232594;
   pri->mbp->alpha[3][6] = 3.637964;
   pri->mbp->alpha[3][7] = 0.328914;
   pri->mbp->alpha[3][8] = 0.400575;
   pri->mbp->alpha[3][9] = 2.647559;
   pri->mbp->alpha[3][10] = 0.269173;
   pri->mbp->alpha[3][11] = 1.022533;
   pri->mbp->alpha[3][12] = 3.376215;
   pri->mbp->alpha[3][13] = 0.380735;
   pri->mbp->alpha[3][14] = 1.397263;
   pri->mbp->alpha[3][15] = 0.695235;

   pri->mbp->pq[4] = 0.039651;
   pri->mbp->alpha[4][0] = 0.145102;
   pri->mbp->alpha[4][1] = 0.122876;
   pri->mbp->alpha[4][2] = 3.107999;
   pri->mbp->alpha[4][3] = 0.099093;
   pri->mbp->alpha[4][4] = 10.564395;
   pri->mbp->alpha[4][5] = 4.450523;
   pri->mbp->alpha[4][6] = 15500.159054;
   pri->mbp->alpha[4][7] = 0.049506;
   pri->mbp->alpha[4][8] = 0.032312;
   pri->mbp->alpha[4][9] = 0.368096;
   pri->mbp->alpha[4][10] = 4.375012;
   pri->mbp->alpha[4][11] = 0.111267;
   pri->mbp->alpha[4][12] = 0.904329;
   pri->mbp->alpha[4][13] = 0.074819;
   pri->mbp->alpha[4][14] = 0.376995;
   pri->mbp->alpha[4][15] = 0.093335;

   pri->mbp->pq[5] = 0.141227;
   pri->mbp->alpha[5][0] = 0.016163;
   pri->mbp->alpha[5][1] = 0.040913;
   pri->mbp->alpha[5][2] = 0.014116;
   pri->mbp->alpha[5][3] = 0.527169;
   pri->mbp->alpha[5][4] = 0.003200;
   pri->mbp->alpha[5][5] = 0.001437;
   pri->mbp->alpha[5][6] = 0.074551;
   pri->mbp->alpha[5][7] = 0.013706;
   pri->mbp->alpha[5][8] = 0.019149;
   pri->mbp->alpha[5][9] = 0.413953;
   pri->mbp->alpha[5][10] = 0.012037;
   pri->mbp->alpha[5][11] = 0.268400;
   pri->mbp->alpha[5][12] = 0.078554;
   pri->mbp->alpha[5][13] = 0.005712;
   pri->mbp->alpha[5][14] = 0.020960;
   pri->mbp->alpha[5][15] = 0.037299;

   pri->mbp->pq[6] = 0.132571;
   pri->mbp->alpha[6][0] = 0.004230;
   pri->mbp->alpha[6][1] = 0.045568;
   pri->mbp->alpha[6][2] = 0.000699;
   pri->mbp->alpha[6][3] = 0.258190;
   pri->mbp->alpha[6][4] = 0.001391;
   pri->mbp->alpha[6][5] = 0.020574;
   pri->mbp->alpha[6][6] = 0.073793;
   pri->mbp->alpha[6][7] = 0.001111;
   pri->mbp->alpha[6][8] = 0.017598;
   pri->mbp->alpha[6][9] = 7.014687;
   pri->mbp->alpha[6][10] = 0.015465;
   pri->mbp->alpha[6][11] = 0.189706;
   pri->mbp->alpha[6][12] = 0.057044;
   pri->mbp->alpha[6][13] = 0.014820;
   pri->mbp->alpha[6][14] = 0.013400;
   pri->mbp->alpha[6][15] = 0.001169;

   pri->mbp->pq[7] = 0.249417;
   pri->mbp->alpha[7][0] = 0.008027;
   pri->mbp->alpha[7][1] = 0.006602;
   pri->mbp->alpha[7][2] = 0.012884;
   pri->mbp->alpha[7][3] = 0.089652;
   pri->mbp->alpha[7][4] = 0.040423;
   pri->mbp->alpha[7][5] = 0.011659;
   pri->mbp->alpha[7][6] = 0.789524;
   pri->mbp->alpha[7][7] = 0.021433;
   pri->mbp->alpha[7][8] = 0.011990;
   pri->mbp->alpha[7][9] = 0.091424;
   pri->mbp->alpha[7][10] = 0.011034;
   pri->mbp->alpha[7][11] = 0.019953;
   pri->mbp->alpha[7][12] = 0.389278;
   pri->mbp->alpha[7][13] = 0.009006;
   pri->mbp->alpha[7][14] = 0.198688;
   pri->mbp->alpha[7][15] = 0.027512;

   pri->mbp->pq[8] = 0.140727;
   pri->mbp->alpha[8][0] = 0.068663;
   pri->mbp->alpha[8][1] = 0.176455;
   pri->mbp->alpha[8][2] = 0.077881;
   pri->mbp->alpha[8][3] = 2.165192;
   pri->mbp->alpha[8][4] = 0.035566;
   pri->mbp->alpha[8][5] = 0.051544;
   pri->mbp->alpha[8][6] = 1.087382;
   pri->mbp->alpha[8][7] = 0.048265;
   pri->mbp->alpha[8][8] = 0.057469;
   pri->mbp->alpha[8][9] = 5.631915;
   pri->mbp->alpha[8][10] = 0.048459;
   pri->mbp->alpha[8][11] = 0.906756;
   pri->mbp->alpha[8][12] = 0.904423;
   pri->mbp->alpha[8][13] = 0.086167;
   pri->mbp->alpha[8][14] = 0.270333;
   pri->mbp->alpha[8][15] = 0.159528;

   pri->mbp->pq[9] = 0.010551;
   pri->mbp->alpha[9][0] = 0.478576;
   pri->mbp->alpha[9][1] = 0.402540;
   pri->mbp->alpha[9][2] = 18.466281;
   pri->mbp->alpha[9][3] = 16947.982248;
   pri->mbp->alpha[9][4] = 0.389092;
   pri->mbp->alpha[9][5] = 0.386664;
   pri->mbp->alpha[9][6] = 0.619656;
   pri->mbp->alpha[9][7] = 20.908826;
   pri->mbp->alpha[9][8] = 0.375696;
   pri->mbp->alpha[9][9] = 4.605442;
   pri->mbp->alpha[9][10] = 0.396373;
   pri->mbp->alpha[9][11] = 13.623423;
   pri->mbp->alpha[9][12] = 0.513956;
   pri->mbp->alpha[9][13] = 0.363145;
   pri->mbp->alpha[9][14] = 0.606193;
   pri->mbp->alpha[9][15] = 18.301915;

   if(! mimic_h3) { /* normal case (this line not autogenerated) */
	 pri->mnt = esl_mixdchlet_Create(10, 4);
	 pri->mnt->pq[0] = 0.081706;
	 pri->mnt->alpha[0][0] = 0.963855;
	 pri->mnt->alpha[0][1] = 3.273863;
	 pri->mnt->alpha[0][2] = 0.444739;
	 pri->mnt->alpha[0][3] = 1.958731;

	 pri->mnt->pq[1] = 0.104534;
	 pri->mnt->alpha[1][0] = 0.589011;
	 pri->mnt->alpha[1][1] = 0.648423;
	 pri->mnt->alpha[1][2] = 0.360672;
	 pri->mnt->alpha[1][3] = 5.771004;

	 pri->mnt->pq[2] = 0.048944;
	 pri->mnt->alpha[2][0] = 2.609834;
	 pri->mnt->alpha[2][1] = 0.127100;
	 pri->mnt->alpha[2][2] = 1.180559;
	 pri->mnt->alpha[2][3] = 0.134264;

	 pri->mnt->pq[3] = 0.064111;
	 pri->mnt->alpha[3][0] = 1.259286;
	 pri->mnt->alpha[3][1] = 0.659029;
	 pri->mnt->alpha[3][2] = 4.874613;
	 pri->mnt->alpha[3][3] = 0.882126;

	 pri->mnt->pq[4] = 0.085266;
	 pri->mnt->alpha[4][0] = 4.664219;
	 pri->mnt->alpha[4][1] = 0.628128;
	 pri->mnt->alpha[4][2] = 0.448894;
	 pri->mnt->alpha[4][3] = 0.661556;

	 pri->mnt->pq[5] = 0.045348;
	 pri->mnt->alpha[5][0] = 0.250974;
	 pri->mnt->alpha[5][1] = 9.700414;
	 pri->mnt->alpha[5][2] = 0.206184;
	 pri->mnt->alpha[5][3] = 0.338607;

	 pri->mnt->pq[6] = 0.100949;
	 pri->mnt->alpha[6][0] = 0.178455;
	 pri->mnt->alpha[6][1] = 0.049385;
	 pri->mnt->alpha[6][2] = 7.914643;
	 pri->mnt->alpha[6][3] = 0.100802;

	 pri->mnt->pq[7] = 0.108835;
	 pri->mnt->alpha[7][0] = 23.818220;
	 pri->mnt->alpha[7][1] = 0.064454;
	 pri->mnt->alpha[7][2] = 0.119891;
	 pri->mnt->alpha[7][3] = 0.101866;

	 pri->mnt->pq[8] = 0.234814;
	 pri->mnt->alpha[8][0] = 2.980233;
	 pri->mnt->alpha[8][1] = 1.817786;
	 pri->mnt->alpha[8][2] = 1.818483;
	 pri->mnt->alpha[8][3] = 3.042635;

	 pri->mnt->pq[9] = 0.125493;
	 pri->mnt->alpha[9][0] = 0.024428;
	 pri->mnt->alpha[9][1] = 0.064315;
	 pri->mnt->alpha[9][2] = 0.008054;
	 pri->mnt->alpha[9][3] = 0.107062;

	 pri->i = esl_mixdchlet_Create(10, 4);
	 pri->i->pq[0] = 0.081706;
	 pri->i->alpha[0][0] = 0.963855;
	 pri->i->alpha[0][1] = 3.273863;
	 pri->i->alpha[0][2] = 0.444739;
	 pri->i->alpha[0][3] = 1.958731;

	 pri->i->pq[1] = 0.104534;
	 pri->i->alpha[1][0] = 0.589011;
	 pri->i->alpha[1][1] = 0.648423;
	 pri->i->alpha[1][2] = 0.360672;
	 pri->i->alpha[1][3] = 5.771004;

	 pri->i->pq[2] = 0.048944;
	 pri->i->alpha[2][0] = 2.609834;
	 pri->i->alpha[2][1] = 0.127100;
	 pri->i->alpha[2][2] = 1.180559;
	 pri->i->alpha[2][3] = 0.134264;

	 pri->i->pq[3] = 0.064111;
	 pri->i->alpha[3][0] = 1.259286;
	 pri->i->alpha[3][1] = 0.659029;
	 pri->i->alpha[3][2] = 4.874613;
	 pri->i->alpha[3][3] = 0.882126;

	 pri->i->pq[4] = 0.085266;
	 pri->i->alpha[4][0] = 4.664219;
	 pri->i->alpha[4][1] = 0.628128;
	 pri->i->alpha[4][2] = 0.448894;
	 pri->i->alpha[4][3] = 0.661556;

	 pri->i->pq[5] = 0.045348;
	 pri->i->alpha[5][0] = 0.250974;
	 pri->i->alpha[5][1] = 9.700414;
	 pri->i->alpha[5][2] = 0.206184;
	 pri->i->alpha[5][3] = 0.338607;

	 pri->i->pq[6] = 0.100949;
	 pri->i->alpha[6][0] = 0.178455;
	 pri->i->alpha[6][1] = 0.049385;
	 pri->i->alpha[6][2] = 7.914643;
	 pri->i->alpha[6][3] = 0.100802;

	 pri->i->pq[7] = 0.108835;
	 pri->i->alpha[7][0] = 23.818220;
	 pri->i->alpha[7][1] = 0.064454;
	 pri->i->alpha[7][2] = 0.119891;
	 pri->i->alpha[7][3] = 0.101866;

	 pri->i->pq[8] = 0.234814;
	 pri->i->alpha[8][0] = 2.980233;
	 pri->i->alpha[8][1] = 1.817786;
	 pri->i->alpha[8][2] = 1.818483;
	 pri->i->alpha[8][3] = 3.042635;

	 pri->i->pq[9] = 0.125493;
	 pri->i->alpha[9][0] = 0.024428;
	 pri->i->alpha[9][1] = 0.064315;
	 pri->i->alpha[9][2] = 0.008054;
	 pri->i->alpha[9][3] = 0.107062;
   } /* end of 'if(! mimic_h3)' (this line not autogenerated) */
   /* end of autogenerated code block
	*****************************************************************/
   else { /* mimic_h3 is TRUE, this prior will be used for models with 0 basepairs */
	 /* these parameters were copied from
	  * hmmer/src/p7_prior.c:p7_prior_CreateNucleic() as or svn r3984,
	  * originally derived by EPN in
	  * ~nawrockie/notebook/10_1116_hmmer_dinuc_priors/00LOG
	  * (A3.O2.ss.c4.t4.dump) sent to Travis 01.26.12 via email
	  * tarball.
	  */

	 /* MATL->MATL transitions, overwrite previously set values for relevant transitions */
	 pri->tsetmap[MATL_ML][MATL_nd] = 32;
	 pri->t[32]->pq[0] = 1.0;
	 pri->t[32]->alpha[0][0] = 0.1; /* ML->IL */
	 pri->t[32]->alpha[0][1] = 2.0; /* ML->ML */
	 pri->t[32]->alpha[0][2] = 0.1; /* ML->D  */

	 pri->tsetmap[MATL_D][MATL_nd] = 37;
	 pri->t[37]->pq[0] = 1.0;
	 pri->t[37]->alpha[0][0] = 0.0001; /* D->IL (this is irrelevant, D->I transitions are set to IMPOSSIBLE later) */
	 pri->t[37]->alpha[0][1] = 0.1;    /* D->ML */
	 pri->t[37]->alpha[0][2] = 0.2;    /* D->D  */

	 pri->tsetmap[MATL_IL][MATL_nd] = 42;
	 pri->t[42]->pq[0] = 1.0;
	 pri->t[42]->alpha[0][0] = 0.02;   /* IL->IL */
	 pri->t[42]->alpha[0][1] = 0.006;  /* IL->ML */
	 pri->t[42]->alpha[0][2] = 0.0001; /* IL->D  (this is irrelevant, D->I transitions are set to IMPOSSIBLE later) */

	 /* singlet emissions */
	 pri->mnt = esl_mixdchlet_Create(4, 4);
	 pri->mnt->pq[0] = 0.24;
	 pri->mnt->alpha[0][0] = 0.16;
	 pri->mnt->alpha[0][1] = 0.45;
	 pri->mnt->alpha[0][2] = 0.12;
	 pri->mnt->alpha[0][3] = 0.39;

	 pri->mnt->pq[1] = 0.26;
	 pri->mnt->alpha[1][0] = 0.09;
	 pri->mnt->alpha[1][1] = 0.03;
	 pri->mnt->alpha[1][2] = 0.09;
	 pri->mnt->alpha[1][3] = 0.04;

	 pri->mnt->pq[2] = 0.08;
	 pri->mnt->alpha[2][0] = 1.29;
	 pri->mnt->alpha[2][1] = 0.40;
	 pri->mnt->alpha[2][2] = 6.58;
	 pri->mnt->alpha[2][3] = 0.51;

	 pri->mnt->pq[3] = 0.42;
	 pri->mnt->alpha[3][0] = 1.74;
	 pri->mnt->alpha[3][1] = 1.49;
	 pri->mnt->alpha[3][2] = 1.57;
	 pri->mnt->alpha[3][3] = 1.95;

	 /* insert, uninformative (the emission scores get flattened to 0.0 anyway) */
	 pri->i = esl_mixdchlet_Create(1, 4);
	 pri->i->pq[0] = 1.0;
	 pri->i->alpha[0][0] = 1.0;
	 pri->i->alpha[0][1] = 1.0;
	 pri->i->alpha[0][2] = 1.0;
	 pri->i->alpha[0][3] = 1.0;

   }
   pri->maxnq = 10;		/* 10-component bp and singlet mixture was the most */
   pri->maxnalpha = 16;		/* bp priors were the most w/ 16 alphas */
   return pri;

 ERROR:
   cm_Fail("Memory allocation error.");
   return NULL;
}

/* Function:  Prior_Default_v0p56_through_v1p02()
 * Incept:    SRE, Fri Apr 15 10:51:16 2005 [St. Louis]
 *
 * Purpose:   Creates and returns the default mixture Dirichlet prior
 *            from versions 0.56 through version 1.0.2.
 *
 *            Most of the code in this function is autogenerated
 *            by a Perl script, prifile2code.pl, which converts a prior
 *            file to C code. xref 2005/0415-infernal-defaultprior.
 *
 * Returns:   ptr to the new prior structure.
 *
 * Xref:      2005/0415-infernal-defaultprior; STL9/65-69.
 */
Prior_t *
Prior_Default_v0p56_through_v1p02(void)
{
  int status;
  Prior_t *pri;

  pri = Prior_Create();

  pri->tsetnum = 74;
  ESL_ALLOC(pri->t, sizeof(ESL_MIXDCHLET *) * pri->tsetnum);

  /*****************************************************************
   * The code block below is autogenerated:
   *  ./prifile2code.pl mixture.pri > foo
   * xref 0415-infernal-defaultprior
   */
   pri->tsetmap[MATP_MP][BIF_nd] = 0;
   pri->t[0] = esl_mixdchlet_Create(1, 3);
   pri->t[0]->pq[0] = 1.0;
   pri->t[0]->alpha[0][0] = 0.067710091654;
   pri->t[0]->alpha[0][1] = 0.000047753225;
   pri->t[0]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[MATP_MP][END_nd] = 1;
   pri->t[1] = esl_mixdchlet_Create(1, 3);
   pri->t[1]->pq[0] = 1.0;
   pri->t[1]->alpha[0][0] = 0.067710091654;
   pri->t[1]->alpha[0][1] = 0.000047753225;
   pri->t[1]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[MATP_MP][MATL_nd] = 2;
   pri->t[2] = esl_mixdchlet_Create(1, 4);
   pri->t[2]->pq[0] = 1.0;
   pri->t[2]->alpha[0][0] = 0.028518011579;
   pri->t[2]->alpha[0][1] = 0.024705844026;
   pri->t[2]->alpha[0][2] = 1.464047470747;
   pri->t[2]->alpha[0][3] = 0.074164509948;

   pri->tsetmap[MATP_MP][MATP_nd] = 3;
   pri->t[3] = esl_mixdchlet_Create(1, 6);
   pri->t[3]->pq[0] = 1.0;
   pri->t[3]->alpha[0][0] = 0.016729608598;
   pri->t[3]->alpha[0][1] = 0.017449035307;
   pri->t[3]->alpha[0][2] = 7.164604225972;
   pri->t[3]->alpha[0][3] = 0.040744980202;
   pri->t[3]->alpha[0][4] = 0.033562178957;
   pri->t[3]->alpha[0][5] = 0.025523202345;

   pri->tsetmap[MATP_MP][MATR_nd] = 4;
   pri->t[4] = esl_mixdchlet_Create(1, 4);
   pri->t[4]->pq[0] = 1.0;
   pri->t[4]->alpha[0][0] = 0.032901537296;
   pri->t[4]->alpha[0][1] = 0.013876834787;
   pri->t[4]->alpha[0][2] = 1.694917068307;
   pri->t[4]->alpha[0][3] = 0.162141225286;

   pri->tsetmap[MATP_ML][BIF_nd] = 5;
   pri->t[5] = esl_mixdchlet_Create(1, 3);
   pri->t[5]->pq[0] = 1.0;
   pri->t[5]->alpha[0][0] = 1.0;
   pri->t[5]->alpha[0][1] = 1.0;
   pri->t[5]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_ML][END_nd] = 6;
   pri->t[6] = esl_mixdchlet_Create(1, 3);
   pri->t[6]->pq[0] = 1.0;
   pri->t[6]->alpha[0][0] = 1.0;
   pri->t[6]->alpha[0][1] = 1.0;
   pri->t[6]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_ML][MATL_nd] = 7;
   pri->t[7] = esl_mixdchlet_Create(1, 4);
   pri->t[7]->pq[0] = 1.0;
   pri->t[7]->alpha[0][0] = 0.068859974656;
   pri->t[7]->alpha[0][1] = 0.060683472648;
   pri->t[7]->alpha[0][2] = 0.655691547663;
   pri->t[7]->alpha[0][3] = 0.146392271070;

   pri->tsetmap[MATP_ML][MATP_nd] = 8;
   pri->t[8] = esl_mixdchlet_Create(1, 6);
   pri->t[8]->pq[0] = 1.0;
   pri->t[8]->alpha[0][0] = 0.009119452604;
   pri->t[8]->alpha[0][1] = 0.007174198989;
   pri->t[8]->alpha[0][2] = 0.279841652851;
   pri->t[8]->alpha[0][3] = 0.345855381430;
   pri->t[8]->alpha[0][4] = 0.007961193216;
   pri->t[8]->alpha[0][5] = 0.044123881735;

   pri->tsetmap[MATP_ML][MATR_nd] = 9;
   pri->t[9] = esl_mixdchlet_Create(1, 4);
   pri->t[9]->pq[0] = 1.0;
   pri->t[9]->alpha[0][0] = 0.061640259819;
   pri->t[9]->alpha[0][1] = 0.014142411829;
   pri->t[9]->alpha[0][2] = 0.133564345209;
   pri->t[9]->alpha[0][3] = 0.117860328247;

   pri->tsetmap[MATP_MR][BIF_nd] = 10;
   pri->t[10] = esl_mixdchlet_Create(1, 3);
   pri->t[10]->pq[0] = 1.0;
   pri->t[10]->alpha[0][0] = 1.0;
   pri->t[10]->alpha[0][1] = 1.0;
   pri->t[10]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_MR][END_nd] = 11;
   pri->t[11] = esl_mixdchlet_Create(1, 3);
   pri->t[11]->pq[0] = 1.0;
   pri->t[11]->alpha[0][0] = 1.0;
   pri->t[11]->alpha[0][1] = 1.0;
   pri->t[11]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_MR][MATL_nd] = 12;
   pri->t[12] = esl_mixdchlet_Create(1, 4);
   pri->t[12]->pq[0] = 1.0;
   pri->t[12]->alpha[0][0] = 0.024723293475;
   pri->t[12]->alpha[0][1] = 0.048463880304;
   pri->t[12]->alpha[0][2] = 0.212532685951;
   pri->t[12]->alpha[0][3] = 0.407547325080;

   pri->tsetmap[MATP_MR][MATP_nd] = 13;
   pri->t[13] = esl_mixdchlet_Create(1, 6);
   pri->t[13]->pq[0] = 1.0;
   pri->t[13]->alpha[0][0] = 0.006294030132;
   pri->t[13]->alpha[0][1] = 0.015189408169;
   pri->t[13]->alpha[0][2] = 0.258896467198;
   pri->t[13]->alpha[0][3] = 0.015420910305;
   pri->t[13]->alpha[0][4] = 0.449746529026;
   pri->t[13]->alpha[0][5] = 0.053194553636;

   pri->tsetmap[MATP_MR][MATR_nd] = 14;
   pri->t[14] = esl_mixdchlet_Create(1, 4);
   pri->t[14]->pq[0] = 1.0;
   pri->t[14]->alpha[0][0] = 0.020819322736;
   pri->t[14]->alpha[0][1] = 0.000060497356;
   pri->t[14]->alpha[0][2] = 0.272689176849;
   pri->t[14]->alpha[0][3] = 0.063856784928;

   pri->tsetmap[MATP_D][BIF_nd] = 15;
   pri->t[15] = esl_mixdchlet_Create(1, 3);
   pri->t[15]->pq[0] = 1.0;
   pri->t[15]->alpha[0][0] = 1.0;
   pri->t[15]->alpha[0][1] = 1.0;
   pri->t[15]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_D][END_nd] = 16;
   pri->t[16] = esl_mixdchlet_Create(1, 3);
   pri->t[16]->pq[0] = 1.0;
   pri->t[16]->alpha[0][0] = 1.0;
   pri->t[16]->alpha[0][1] = 1.0;
   pri->t[16]->alpha[0][2] = 1.0;

   pri->tsetmap[MATP_D][MATL_nd] = 17;
   pri->t[17] = esl_mixdchlet_Create(1, 4);
   pri->t[17]->pq[0] = 1.0;
   pri->t[17]->alpha[0][0] = 0.024577940691;
   pri->t[17]->alpha[0][1] = 0.030655567559;
   pri->t[17]->alpha[0][2] = 0.121290355765;
   pri->t[17]->alpha[0][3] = 0.406621701238;

   pri->tsetmap[MATP_D][MATP_nd] = 18;
   pri->t[18] = esl_mixdchlet_Create(1, 6);
   pri->t[18]->pq[0] = 1.0;
   pri->t[18]->alpha[0][0] = 0.001029025955;
   pri->t[18]->alpha[0][1] = 0.002536729756;
   pri->t[18]->alpha[0][2] = 0.046719556839;
   pri->t[18]->alpha[0][3] = 0.029117903291;
   pri->t[18]->alpha[0][4] = 0.028767509361;
   pri->t[18]->alpha[0][5] = 0.436842892057;

   pri->tsetmap[MATP_D][MATR_nd] = 19;
   pri->t[19] = esl_mixdchlet_Create(1, 4);
   pri->t[19]->pq[0] = 1.0;
   pri->t[19]->alpha[0][0] = 0.000017041108;
   pri->t[19]->alpha[0][1] = 0.000007069171;
   pri->t[19]->alpha[0][2] = 0.028384306256;
   pri->t[19]->alpha[0][3] = 0.087965488640;

   pri->tsetmap[MATP_IL][BIF_nd] = 20;
   pri->t[20] = esl_mixdchlet_Create(1, 3);
   pri->t[20]->pq[0] = 1.0;
   pri->t[20]->alpha[0][0] = 0.943443048986;
   pri->t[20]->alpha[0][1] = 0.064001237265;
   pri->t[20]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[MATP_IL][END_nd] = 21;
   pri->t[21] = esl_mixdchlet_Create(1, 3);
   pri->t[21]->pq[0] = 1.0;
   pri->t[21]->alpha[0][0] = 0.943443048986;
   pri->t[21]->alpha[0][1] = 0.064001237265;
   pri->t[21]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[MATP_IL][MATL_nd] = 22;
   pri->t[22] = esl_mixdchlet_Create(1, 4);
   pri->t[22]->pq[0] = 1.0;
   pri->t[22]->alpha[0][0] = 0.250101882938;
   pri->t[22]->alpha[0][1] = 0.155728904821;
   pri->t[22]->alpha[0][2] = 0.370945030932;
   pri->t[22]->alpha[0][3] = 0.027811408475;

   pri->tsetmap[MATP_IL][MATP_nd] = 23;
   pri->t[23] = esl_mixdchlet_Create(1, 6);
   pri->t[23]->pq[0] = 1.0;
   pri->t[23]->alpha[0][0] = 0.157307265492;
   pri->t[23]->alpha[0][1] = 0.131105492208;
   pri->t[23]->alpha[0][2] = 0.555106727689;
   pri->t[23]->alpha[0][3] = 0.041624804903;
   pri->t[23]->alpha[0][4] = 0.024305424386;
   pri->t[23]->alpha[0][5] = 0.030756705205;

   pri->tsetmap[MATP_IL][MATR_nd] = 24;
   pri->t[24] = esl_mixdchlet_Create(1, 4);
   pri->t[24]->pq[0] = 1.0;
   pri->t[24]->alpha[0][0] = 0.155093374292;
   pri->t[24]->alpha[0][1] = 0.054734614999;
   pri->t[24]->alpha[0][2] = 0.714409186001;
   pri->t[24]->alpha[0][3] = 0.168407110635;

   pri->tsetmap[MATP_IR][BIF_nd] = 25;
   pri->t[25] = esl_mixdchlet_Create(1, 2);
   pri->t[25]->pq[0] = 1.0;
   pri->t[25]->alpha[0][0] = 0.264643213319;
   pri->t[25]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATP_IR][END_nd] = 26;
   pri->t[26] = esl_mixdchlet_Create(1, 2);
   pri->t[26]->pq[0] = 1.0;
   pri->t[26]->alpha[0][0] = 0.264643213319;
   pri->t[26]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATP_IR][MATL_nd] = 27;
   pri->t[27] = esl_mixdchlet_Create(1, 3);
   pri->t[27]->pq[0] = 1.0;
   pri->t[27]->alpha[0][0] = 0.601223387577;
   pri->t[27]->alpha[0][1] = 0.939499051719;
   pri->t[27]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[MATP_IR][MATP_nd] = 28;
   pri->t[28] = esl_mixdchlet_Create(1, 5);
   pri->t[28]->pq[0] = 1.0;
   pri->t[28]->alpha[0][0] = 0.291829430523;
   pri->t[28]->alpha[0][1] = 1.098441427679;
   pri->t[28]->alpha[0][2] = 0.025595408318;
   pri->t[28]->alpha[0][3] = 0.091146313822;
   pri->t[28]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATP_IR][MATR_nd] = 29;
   pri->t[29] = esl_mixdchlet_Create(1, 3);
   pri->t[29]->pq[0] = 1.0;
   pri->t[29]->alpha[0][0] = 0.327208719748;
   pri->t[29]->alpha[0][1] = 0.846283302435;
   pri->t[29]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[MATL_ML][BIF_nd] = 30;
   pri->t[30] = esl_mixdchlet_Create(1, 2);
   pri->t[30]->pq[0] = 1.0;
   pri->t[30]->alpha[0][0] = 0.009635966745;
   pri->t[30]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATL_ML][END_nd] = 31;
   pri->t[31] = esl_mixdchlet_Create(1, 2);
   pri->t[31]->pq[0] = 1.0;
   pri->t[31]->alpha[0][0] = 0.009635966745;
   pri->t[31]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATL_ML][MATL_nd] = 32;
   pri->t[32] = esl_mixdchlet_Create(1, 3);
   pri->t[32]->pq[0] = 1.0;
   pri->t[32]->alpha[0][0] = 0.015185708311;
   pri->t[32]->alpha[0][1] = 1.809432933023;
   pri->t[32]->alpha[0][2] = 0.038601480352;

   pri->tsetmap[MATL_ML][MATP_nd] = 33;
   pri->t[33] = esl_mixdchlet_Create(1, 5);
   pri->t[33]->pq[0] = 1.0;
   pri->t[33]->alpha[0][0] = 0.031820644019;
   pri->t[33]->alpha[0][1] = 2.300193431878;
   pri->t[33]->alpha[0][2] = 0.036163737927;
   pri->t[33]->alpha[0][3] = 0.031218244200;
   pri->t[33]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[MATL_ML][MATR_nd] = 34;
   pri->t[34] = esl_mixdchlet_Create(1, 3);
   pri->t[34]->pq[0] = 1.0;
   pri->t[34]->alpha[0][0] = 0.012395245929;
   pri->t[34]->alpha[0][1] = 2.076134487839;
   pri->t[34]->alpha[0][2] = 0.039781067793;

   pri->tsetmap[MATL_D][BIF_nd] = 35;
   pri->t[35] = esl_mixdchlet_Create(1, 2);
   pri->t[35]->pq[0] = 1.0;
   pri->t[35]->alpha[0][0] = 0.019509171372;
   pri->t[35]->alpha[0][1] = 6.781321301695;

   pri->tsetmap[MATL_D][END_nd] = 36;
   pri->t[36] = esl_mixdchlet_Create(1, 2);
   pri->t[36]->pq[0] = 1.0;
   pri->t[36]->alpha[0][0] = 0.019509171372;
   pri->t[36]->alpha[0][1] = 6.781321301695;

   pri->tsetmap[MATL_D][MATL_nd] = 37;
   pri->t[37] = esl_mixdchlet_Create(1, 3);
   pri->t[37]->pq[0] = 1.0;
   pri->t[37]->alpha[0][0] = 0.005679808868;
   pri->t[37]->alpha[0][1] = 0.127365862719;
   pri->t[37]->alpha[0][2] = 0.277086556814;

   pri->tsetmap[MATL_D][MATP_nd] = 38;
   pri->t[38] = esl_mixdchlet_Create(1, 5);
   pri->t[38]->pq[0] = 1.0;
   pri->t[38]->alpha[0][0] = 0.023424968753;
   pri->t[38]->alpha[0][1] = 0.417640407951;
   pri->t[38]->alpha[0][2] = 0.039088991906;
   pri->t[38]->alpha[0][3] = 0.120577442402;
   pri->t[38]->alpha[0][4] = 0.128103786646;

   pri->tsetmap[MATL_D][MATR_nd] = 39;
   pri->t[39] = esl_mixdchlet_Create(1, 3);
   pri->t[39]->pq[0] = 1.0;
   pri->t[39]->alpha[0][0] = 0.013699691994;
   pri->t[39]->alpha[0][1] = 0.405128575339;
   pri->t[39]->alpha[0][2] = 0.254775565405;

   pri->tsetmap[MATL_IL][BIF_nd] = 40;
   pri->t[40] = esl_mixdchlet_Create(1, 2);
   pri->t[40]->pq[0] = 1.0;
   pri->t[40]->alpha[0][0] = 0.264643213319;
   pri->t[40]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATL_IL][END_nd] = 41;
   pri->t[41] = esl_mixdchlet_Create(1, 2);
   pri->t[41]->pq[0] = 1.0;
   pri->t[41]->alpha[0][0] = 0.264643213319;
   pri->t[41]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATL_IL][MATL_nd] = 42;
   pri->t[42] = esl_mixdchlet_Create(1, 3);
   pri->t[42]->pq[0] = 1.0;
   pri->t[42]->alpha[0][0] = 0.601223387577;
   pri->t[42]->alpha[0][1] = 0.939499051719;
   pri->t[42]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[MATL_IL][MATP_nd] = 43;
   pri->t[43] = esl_mixdchlet_Create(1, 5);
   pri->t[43]->pq[0] = 1.0;
   pri->t[43]->alpha[0][0] = 0.291829430523;
   pri->t[43]->alpha[0][1] = 1.098441427679;
   pri->t[43]->alpha[0][2] = 0.091146313822;
   pri->t[43]->alpha[0][3] = 0.025595408318;
   pri->t[43]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATL_IL][MATR_nd] = 44;
   pri->t[44] = esl_mixdchlet_Create(1, 3);
   pri->t[44]->pq[0] = 1.0;
   pri->t[44]->alpha[0][0] = 0.327208719748;
   pri->t[44]->alpha[0][1] = 0.846283302435;
   pri->t[44]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[MATR_MR][BIF_nd] = 45;
   pri->t[45] = esl_mixdchlet_Create(1, 2);
   pri->t[45]->pq[0] = 1.0;
   pri->t[45]->alpha[0][0] = 0.009635966745;
   pri->t[45]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[MATR_MR][MATP_nd] = 46;
   pri->t[46] = esl_mixdchlet_Create(1, 5);
   pri->t[46]->pq[0] = 1.0;
   pri->t[46]->alpha[0][0] = 0.031820644019;
   pri->t[46]->alpha[0][1] = 2.300193431878;
   pri->t[46]->alpha[0][2] = 0.036163737927;
   pri->t[46]->alpha[0][3] = 0.031218244200;
   pri->t[46]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[MATR_MR][MATR_nd] = 47;
   pri->t[47] = esl_mixdchlet_Create(1, 3);
   pri->t[47]->pq[0] = 1.0;
   pri->t[47]->alpha[0][0] = 0.012395245929;
   pri->t[47]->alpha[0][1] = 2.076134487839;
   pri->t[47]->alpha[0][2] = 0.039781067793;

   pri->tsetmap[MATR_D][BIF_nd] = 48;
   pri->t[48] = esl_mixdchlet_Create(1, 2);
   pri->t[48]->pq[0] = 1.0;
   pri->t[48]->alpha[0][0] = 0.021604946951;
   pri->t[48]->alpha[0][1] = 0.444765555211;

   pri->tsetmap[MATR_D][MATP_nd] = 49;
   pri->t[49] = esl_mixdchlet_Create(1, 5);
   pri->t[49]->pq[0] = 1.0;
   pri->t[49]->alpha[0][0] = 0.021273745319;
   pri->t[49]->alpha[0][1] = 0.532292228853;
   pri->t[49]->alpha[0][2] = 0.110249350652;
   pri->t[49]->alpha[0][3] = 0.040890357850;
   pri->t[49]->alpha[0][4] = 0.164194410420;

   pri->tsetmap[MATR_D][MATR_nd] = 50;
   pri->t[50] = esl_mixdchlet_Create(1, 3);
   pri->t[50]->pq[0] = 1.0;
   pri->t[50]->alpha[0][0] = 0.005806440507;
   pri->t[50]->alpha[0][1] = 0.164264844267;
   pri->t[50]->alpha[0][2] = 0.316876127883;

   pri->tsetmap[MATR_IR][BIF_nd] = 51;
   pri->t[51] = esl_mixdchlet_Create(1, 2);
   pri->t[51]->pq[0] = 1.0;
   pri->t[51]->alpha[0][0] = 0.264643213319;
   pri->t[51]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[MATR_IR][MATP_nd] = 52;
   pri->t[52] = esl_mixdchlet_Create(1, 5);
   pri->t[52]->pq[0] = 1.0;
   pri->t[52]->alpha[0][0] = 0.291829430523;
   pri->t[52]->alpha[0][1] = 1.098441427679;
   pri->t[52]->alpha[0][2] = 0.025595408318;
   pri->t[52]->alpha[0][3] = 0.091146313822;
   pri->t[52]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[MATR_IR][MATR_nd] = 53;
   pri->t[53] = esl_mixdchlet_Create(1, 3);
   pri->t[53]->pq[0] = 1.0;
   pri->t[53]->alpha[0][0] = 0.327208719748;
   pri->t[53]->alpha[0][1] = 0.846283302435;
   pri->t[53]->alpha[0][2] = 0.069337439204;

   pri->tsetmap[BEGL_S][BIF_nd] = 54;
   pri->t[54] = esl_mixdchlet_Create(1, 1);
   pri->t[54]->pq[0] = 1.0;
   pri->t[54]->alpha[0][0] = 1.0;

   pri->tsetmap[BEGL_S][MATP_nd] = 55;
   pri->t[55] = esl_mixdchlet_Create(1, 4);
   pri->t[55]->pq[0] = 1.0;
   pri->t[55]->alpha[0][0] = 4.829712747509;
   pri->t[55]->alpha[0][1] = 0.061131109227;
   pri->t[55]->alpha[0][2] = 0.092185242101;
   pri->t[55]->alpha[0][3] = 0.059154827887;

   pri->tsetmap[BEGR_S][BIF_nd] = 56;
   pri->t[56] = esl_mixdchlet_Create(1, 2);
   pri->t[56]->pq[0] = 1.0;
   pri->t[56]->alpha[0][0] = 0.009635966745;
   pri->t[56]->alpha[0][1] = 1.220143960207;

   pri->tsetmap[BEGR_S][MATL_nd] = 57;
   pri->t[57] = esl_mixdchlet_Create(1, 3);
   pri->t[57]->pq[0] = 1.0;
   pri->t[57]->alpha[0][0] = 0.015185708311;
   pri->t[57]->alpha[0][1] = 1.809432933023;
   pri->t[57]->alpha[0][2] = 0.038601480352;

   pri->tsetmap[BEGR_S][MATP_nd] = 58;
   pri->t[58] = esl_mixdchlet_Create(1, 5);
   pri->t[58]->pq[0] = 1.0;
   pri->t[58]->alpha[0][0] = 0.031820644019;
   pri->t[58]->alpha[0][1] = 2.300193431878;
   pri->t[58]->alpha[0][2] = 0.036163737927;
   pri->t[58]->alpha[0][3] = 0.031218244200;
   pri->t[58]->alpha[0][4] = 0.016826710214;

   pri->tsetmap[BEGR_IL][BIF_nd] = 59;
   pri->t[59] = esl_mixdchlet_Create(1, 2);
   pri->t[59]->pq[0] = 1.0;
   pri->t[59]->alpha[0][0] = 0.264643213319;
   pri->t[59]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[BEGR_IL][MATL_nd] = 60;
   pri->t[60] = esl_mixdchlet_Create(1, 3);
   pri->t[60]->pq[0] = 1.0;
   pri->t[60]->alpha[0][0] = 0.601223387577;
   pri->t[60]->alpha[0][1] = 0.939499051719;
   pri->t[60]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[BEGR_IL][MATP_nd] = 61;
   pri->t[61] = esl_mixdchlet_Create(1, 5);
   pri->t[61]->pq[0] = 1.0;
   pri->t[61]->alpha[0][0] = 0.291829430523;
   pri->t[61]->alpha[0][1] = 1.098441427679;
   pri->t[61]->alpha[0][2] = 0.091146313822;
   pri->t[61]->alpha[0][3] = 0.025595408318;
   pri->t[61]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[ROOT_S][BIF_nd] = 62;
   pri->t[62] = esl_mixdchlet_Create(1, 3);
   pri->t[62]->pq[0] = 1.0;
   pri->t[62]->alpha[0][0] = 0.067710091654;
   pri->t[62]->alpha[0][1] = 0.000047753225;
   pri->t[62]->alpha[0][2] = 0.483183211040;

   pri->tsetmap[ROOT_S][MATL_nd] = 63;
   pri->t[63] = esl_mixdchlet_Create(1, 4);
   pri->t[63]->pq[0] = 1.0;
   pri->t[63]->alpha[0][0] = 0.028518011579;
   pri->t[63]->alpha[0][1] = 0.024705844026;
   pri->t[63]->alpha[0][2] = 1.464047470747;
   pri->t[63]->alpha[0][3] = 0.074164509948;

   pri->tsetmap[ROOT_S][MATP_nd] = 64;
   pri->t[64] = esl_mixdchlet_Create(1, 6);
   pri->t[64]->pq[0] = 1.0;
   pri->t[64]->alpha[0][0] = 0.016729608598;
   pri->t[64]->alpha[0][1] = 0.017449035307;
   pri->t[64]->alpha[0][2] = 7.164604225972;
   pri->t[64]->alpha[0][3] = 0.040744980202;
   pri->t[64]->alpha[0][4] = 0.033562178957;
   pri->t[64]->alpha[0][5] = 0.025523202345;

   pri->tsetmap[ROOT_S][MATR_nd] = 65;
   pri->t[65] = esl_mixdchlet_Create(1, 4);
   pri->t[65]->pq[0] = 1.0;
   pri->t[65]->alpha[0][0] = 0.032901537296;
   pri->t[65]->alpha[0][1] = 0.013876834787;
   pri->t[65]->alpha[0][2] = 1.694917068307;
   pri->t[65]->alpha[0][3] = 0.162141225286;

   pri->tsetmap[ROOT_IL][BIF_nd] = 66;
   pri->t[66] = esl_mixdchlet_Create(1, 3);
   pri->t[66]->pq[0] = 1.0;
   pri->t[66]->alpha[0][0] = 0.943443048986;
   pri->t[66]->alpha[0][1] = 0.064001237265;
   pri->t[66]->alpha[0][2] = 0.432230812455;

   pri->tsetmap[ROOT_IL][MATL_nd] = 67;
   pri->t[67] = esl_mixdchlet_Create(1, 4);
   pri->t[67]->pq[0] = 1.0;
   pri->t[67]->alpha[0][0] = 0.250101882938;
   pri->t[67]->alpha[0][1] = 0.155728904821;
   pri->t[67]->alpha[0][2] = 0.370945030932;
   pri->t[67]->alpha[0][3] = 0.027811408475;

   pri->tsetmap[ROOT_IL][MATP_nd] = 68;
   pri->t[68] = esl_mixdchlet_Create(1, 6);
   pri->t[68]->pq[0] = 1.0;
   pri->t[68]->alpha[0][0] = 0.157307265492;
   pri->t[68]->alpha[0][1] = 0.131105492208;
   pri->t[68]->alpha[0][2] = 0.555106727689;
   pri->t[68]->alpha[0][3] = 0.041624804903;
   pri->t[68]->alpha[0][4] = 0.024305424386;
   pri->t[68]->alpha[0][5] = 0.030756705205;

   pri->tsetmap[ROOT_IL][MATR_nd] = 69;
   pri->t[69] = esl_mixdchlet_Create(1, 4);
   pri->t[69]->pq[0] = 1.0;
   pri->t[69]->alpha[0][0] = 0.155093374292;
   pri->t[69]->alpha[0][1] = 0.054734614999;
   pri->t[69]->alpha[0][2] = 0.714409186001;
   pri->t[69]->alpha[0][3] = 0.168407110635;

   pri->tsetmap[ROOT_IR][BIF_nd] = 70;
   pri->t[70] = esl_mixdchlet_Create(1, 2);
   pri->t[70]->pq[0] = 1.0;
   pri->t[70]->alpha[0][0] = 0.264643213319;
   pri->t[70]->alpha[0][1] = 0.671462565227;

   pri->tsetmap[ROOT_IR][MATL_nd] = 71;
   pri->t[71] = esl_mixdchlet_Create(1, 3);
   pri->t[71]->pq[0] = 1.0;
   pri->t[71]->alpha[0][0] = 0.601223387577;
   pri->t[71]->alpha[0][1] = 0.939499051719;
   pri->t[71]->alpha[0][2] = 0.092516097691;

   pri->tsetmap[ROOT_IR][MATP_nd] = 72;
   pri->t[72] = esl_mixdchlet_Create(1, 5);
   pri->t[72]->pq[0] = 1.0;
   pri->t[72]->alpha[0][0] = 0.291829430523;
   pri->t[72]->alpha[0][1] = 1.098441427679;
   pri->t[72]->alpha[0][2] = 0.025595408318;
   pri->t[72]->alpha[0][3] = 0.091146313822;
   pri->t[72]->alpha[0][4] = 0.042349119486;

   pri->tsetmap[ROOT_IR][MATR_nd] = 73;
   pri->t[73] = esl_mixdchlet_Create(1, 3);
   pri->t[73]->pq[0] = 1.0;
   pri->t[73]->alpha[0][0] = 0.327208719748;
   pri->t[73]->alpha[0][1] = 0.846283302435;
   pri->t[73]->alpha[0][2] = 0.069337439204;

   pri->mbp = esl_mixdchlet_Create(9, 16);
   pri->mbp->pq[0] = 0.030512242264;
   pri->mbp->alpha[0][0] = 0.571860339721;
   pri->mbp->alpha[0][1] = 0.605642194896;
   pri->mbp->alpha[0][2] = 0.548004739487;
   pri->mbp->alpha[0][3] = 1.570353271532;
   pri->mbp->alpha[0][4] = 0.591611867703;
   pri->mbp->alpha[0][5] = 0.469713257214;
   pri->mbp->alpha[0][6] = 1.447411319683;
   pri->mbp->alpha[0][7] = 0.600381079228;
   pri->mbp->alpha[0][8] = 0.520096937350;
   pri->mbp->alpha[0][9] = 1.867142019076;
   pri->mbp->alpha[0][10] = 0.470428282443;
   pri->mbp->alpha[0][11] = 1.165356324744;
   pri->mbp->alpha[0][12] = 1.528348208160;
   pri->mbp->alpha[0][13] = 0.686072963473;
   pri->mbp->alpha[0][14] = 1.072148274499;
   pri->mbp->alpha[0][15] = 0.659833749087;

   pri->mbp->pq[1] = 0.070312169889;
   pri->mbp->alpha[1][0] = 0.116757286812;
   pri->mbp->alpha[1][1] = 0.052661180881;
   pri->mbp->alpha[1][2] = 0.067541712113;
   pri->mbp->alpha[1][3] = 0.258482314714;
   pri->mbp->alpha[1][4] = 0.152527972588;
   pri->mbp->alpha[1][5] = 0.034460232010;
   pri->mbp->alpha[1][6] = 0.416430364713;
   pri->mbp->alpha[1][7] = 0.051541326273;
   pri->mbp->alpha[1][8] = 0.079542103337;
   pri->mbp->alpha[1][9] = 0.162883420833;
   pri->mbp->alpha[1][10] = 0.042615616796;
   pri->mbp->alpha[1][11] = 0.123363759874;
   pri->mbp->alpha[1][12] = 0.922897266376;
   pri->mbp->alpha[1][13] = 0.078567729294;
   pri->mbp->alpha[1][14] = 0.315242459757;
   pri->mbp->alpha[1][15] = 0.116457644231;

   pri->mbp->pq[2] = 0.118499696300;
   pri->mbp->alpha[2][0] = 0.028961414077;
   pri->mbp->alpha[2][1] = 0.022849036260;
   pri->mbp->alpha[2][2] = 0.120089637379;
   pri->mbp->alpha[2][3] = 0.509884713979;
   pri->mbp->alpha[2][4] = 0.142464495045;
   pri->mbp->alpha[2][5] = 0.079507804767;
   pri->mbp->alpha[2][6] = 21.835608089779;
   pri->mbp->alpha[2][7] = 0.070200164694;
   pri->mbp->alpha[2][8] = 0.005189494879;
   pri->mbp->alpha[2][9] = 0.540651647339;
   pri->mbp->alpha[2][10] = 0.117833357497;
   pri->mbp->alpha[2][11] = 0.128182594376;
   pri->mbp->alpha[2][12] = 1.766866842025;
   pri->mbp->alpha[2][13] = 0.016341625779;
   pri->mbp->alpha[2][14] = 0.832665494899;
   pri->mbp->alpha[2][15] = 0.058379188171;

   pri->mbp->pq[3] = 0.181025557995;
   pri->mbp->alpha[3][0] = 0.000926960236;
   pri->mbp->alpha[3][1] = 0.008100076237;
   pri->mbp->alpha[3][2] = 0.001794303710;
   pri->mbp->alpha[3][3] = 0.114209483231;
   pri->mbp->alpha[3][4] = 0.001459159085;
   pri->mbp->alpha[3][5] = 0.000053878201;
   pri->mbp->alpha[3][6] = 0.072605927746;
   pri->mbp->alpha[3][7] = 0.005533021345;
   pri->mbp->alpha[3][8] = 0.003941720307;
   pri->mbp->alpha[3][9] = 0.095421675098;
   pri->mbp->alpha[3][10] = 0.004844990769;
   pri->mbp->alpha[3][11] = 0.072393572779;
   pri->mbp->alpha[3][12] = 0.099144450569;
   pri->mbp->alpha[3][13] = 0.002561491533;
   pri->mbp->alpha[3][14] = 0.043103588084;
   pri->mbp->alpha[3][15] = 0.008080970629;

   pri->mbp->pq[4] = 0.188791659665;
   pri->mbp->alpha[4][0] = 0.002163861165;
   pri->mbp->alpha[4][1] = 0.007785521817;
   pri->mbp->alpha[4][2] = 0.003483930554;
   pri->mbp->alpha[4][3] = 0.625515668281;
   pri->mbp->alpha[4][4] = 0.018621932500;
   pri->mbp->alpha[4][5] = 0.001352139642;
   pri->mbp->alpha[4][6] = 1.371471086809;
   pri->mbp->alpha[4][7] = 0.007920737783;
   pri->mbp->alpha[4][8] = 0.000946403264;
   pri->mbp->alpha[4][9] = 0.688821384972;
   pri->mbp->alpha[4][10] = 0.002203762108;
   pri->mbp->alpha[4][11] = 0.192533693864;
   pri->mbp->alpha[4][12] = 0.979473608513;
   pri->mbp->alpha[4][13] = 0.000916007398;
   pri->mbp->alpha[4][14] = 0.347662973488;
   pri->mbp->alpha[4][15] = 0.020677924150;

   pri->mbp->pq[5] = 0.157630937531;
   pri->mbp->alpha[5][0] = 0.083035113547;
   pri->mbp->alpha[5][1] = 0.166815168558;
   pri->mbp->alpha[5][2] = 0.042669979127;
   pri->mbp->alpha[5][3] = 3.415107328082;
   pri->mbp->alpha[5][4] = 0.023530116520;
   pri->mbp->alpha[5][5] = 0.047677945396;
   pri->mbp->alpha[5][6] = 1.183956650707;
   pri->mbp->alpha[5][7] = 0.059920099115;
   pri->mbp->alpha[5][8] = 0.076614058723;
   pri->mbp->alpha[5][9] = 5.434261851985;
   pri->mbp->alpha[5][10] = 0.095284240991;
   pri->mbp->alpha[5][11] = 0.889915882997;
   pri->mbp->alpha[5][12] = 1.201576769946;
   pri->mbp->alpha[5][13] = 0.074453244946;
   pri->mbp->alpha[5][14] = 0.397879304331;
   pri->mbp->alpha[5][15] = 0.130525904952;

   pri->mbp->pq[6] = 0.041708924031;
   pri->mbp->alpha[6][0] = 0.217001113139;
   pri->mbp->alpha[6][1] = 0.388746098242;
   pri->mbp->alpha[6][2] = 0.134680826556;
   pri->mbp->alpha[6][3] = 24.923110155367;
   pri->mbp->alpha[6][4] = 0.102582693868;
   pri->mbp->alpha[6][5] = 0.131678864943;
   pri->mbp->alpha[6][6] = 1.150978162882;
   pri->mbp->alpha[6][7] = 0.256720461728;
   pri->mbp->alpha[6][8] = 0.150993730345;
   pri->mbp->alpha[6][9] = 3.200824712363;
   pri->mbp->alpha[6][10] = 0.077595421397;
   pri->mbp->alpha[6][11] = 1.025428618792;
   pri->mbp->alpha[6][12] = 1.228870901327;
   pri->mbp->alpha[6][13] = 0.143610901605;
   pri->mbp->alpha[6][14] = 0.406308970402;
   pri->mbp->alpha[6][15] = 0.322809888354;

   pri->mbp->pq[7] = 0.095930656547;
   pri->mbp->alpha[7][0] = 0.129043208355;
   pri->mbp->alpha[7][1] = 0.112308496092;
   pri->mbp->alpha[7][2] = 0.116841517642;
   pri->mbp->alpha[7][3] = 2.878927926806;
   pri->mbp->alpha[7][4] = 0.306789207829;
   pri->mbp->alpha[7][5] = 0.078411064993;
   pri->mbp->alpha[7][6] = 6.377836578660;
   pri->mbp->alpha[7][7] = 0.114524370807;
   pri->mbp->alpha[7][8] = 0.094192610036;
   pri->mbp->alpha[7][9] = 2.566493997218;
   pri->mbp->alpha[7][10] = 0.096694574300;
   pri->mbp->alpha[7][11] = 0.791295335090;
   pri->mbp->alpha[7][12] = 6.907854285192;
   pri->mbp->alpha[7][13] = 0.132657156809;
   pri->mbp->alpha[7][14] = 1.225349985791;
   pri->mbp->alpha[7][15] = 0.296596767798;

   pri->mbp->pq[8] = 0.115588155778;
   pri->mbp->alpha[8][0] = 0.005830777296;
   pri->mbp->alpha[8][1] = 0.153807106950;
   pri->mbp->alpha[8][2] = 0.003131256711;
   pri->mbp->alpha[8][3] = 1.340589241710;
   pri->mbp->alpha[8][4] = 0.006802639527;
   pri->mbp->alpha[8][5] = 0.135277067812;
   pri->mbp->alpha[8][6] = 0.487492640368;
   pri->mbp->alpha[8][7] = 0.009160116179;
   pri->mbp->alpha[8][8] = 0.068942867388;
   pri->mbp->alpha[8][9] = 29.409376576276;
   pri->mbp->alpha[8][10] = 0.099733235653;
   pri->mbp->alpha[8][11] = 0.722700985558;
   pri->mbp->alpha[8][12] = 0.500134122079;
   pri->mbp->alpha[8][13] = 0.124671165331;
   pri->mbp->alpha[8][14] = 0.105694456385;
   pri->mbp->alpha[8][15] = 0.025741311658;

   pri->mnt = esl_mixdchlet_Create(8, 4);
   pri->mnt->pq[0] = 0.085091850427;
   pri->mnt->alpha[0][0] = 0.575686380127;
   pri->mnt->alpha[0][1] = 0.756214632926;
   pri->mnt->alpha[0][2] = 0.340269621276;
   pri->mnt->alpha[0][3] = 13.774558068728;

   pri->mnt->pq[1] = 0.015935406086;
   pri->mnt->alpha[1][0] = 153.865583955384;
   pri->mnt->alpha[1][1] = 0.235000107300;
   pri->mnt->alpha[1][2] = 0.356622653787;
   pri->mnt->alpha[1][3] = 0.006812718667;

   pri->mnt->pq[2] = 0.102013232739;
   pri->mnt->alpha[2][0] = 176.440373997567;
   pri->mnt->alpha[2][1] = 0.935905951648;
   pri->mnt->alpha[2][2] = 1.292808081312;
   pri->mnt->alpha[2][3] = 1.617069444109;

   pri->mnt->pq[3] = 0.415954530541;
   pri->mnt->alpha[3][0] = 1.696250324914;
   pri->mnt->alpha[3][1] = 1.128033754503;
   pri->mnt->alpha[3][2] = 0.955462899400;
   pri->mnt->alpha[3][3] = 1.676465850057;

   pri->mnt->pq[4] = 0.074470557341;
   pri->mnt->alpha[4][0] = 0.074365531036;
   pri->mnt->alpha[4][1] = 0.039185613484;
   pri->mnt->alpha[4][2] = 0.063868972113;
   pri->mnt->alpha[4][3] = 0.042432587902;

   pri->mnt->pq[5] = 0.055442639402;
   pri->mnt->alpha[5][0] = 0.615068901818;
   pri->mnt->alpha[5][1] = 14.630712353118;
   pri->mnt->alpha[5][2] = 0.298404817403;
   pri->mnt->alpha[5][3] = 0.864718655041;

   pri->mnt->pq[6] = 0.118379098369;
   pri->mnt->alpha[6][0] = 1.163176461349;
   pri->mnt->alpha[6][1] = 0.408090165233;
   pri->mnt->alpha[6][2] = 11.188793743319;
   pri->mnt->alpha[6][3] = 0.699118301558;

   pri->mnt->pq[7] = 0.132712685095;
   pri->mnt->alpha[7][0] = 16.417200192194;
   pri->mnt->alpha[7][1] = 0.980503286582;
   pri->mnt->alpha[7][2] = 1.132071515554;
   pri->mnt->alpha[7][3] = 1.376129445524;

   pri->i = esl_mixdchlet_Create(8, 4);
   pri->i->pq[0] = 0.085091850427;
   pri->i->alpha[0][0] = 0.575686380127;
   pri->i->alpha[0][1] = 0.756214632926;
   pri->i->alpha[0][2] = 0.340269621276;
   pri->i->alpha[0][3] = 13.774558068728;

   pri->i->pq[1] = 0.015935406086;
   pri->i->alpha[1][0] = 153.865583955384;
   pri->i->alpha[1][1] = 0.235000107300;
   pri->i->alpha[1][2] = 0.356622653787;
   pri->i->alpha[1][3] = 0.006812718667;

   pri->i->pq[2] = 0.102013232739;
   pri->i->alpha[2][0] = 176.440373997567;
   pri->i->alpha[2][1] = 0.935905951648;
   pri->i->alpha[2][2] = 1.292808081312;
   pri->i->alpha[2][3] = 1.617069444109;

   pri->i->pq[3] = 0.415954530541;
   pri->i->alpha[3][0] = 1.696250324914;
   pri->i->alpha[3][1] = 1.128033754503;
   pri->i->alpha[3][2] = 0.955462899400;
   pri->i->alpha[3][3] = 1.676465850057;

   pri->i->pq[4] = 0.074470557341;
   pri->i->alpha[4][0] = 0.074365531036;
   pri->i->alpha[4][1] = 0.039185613484;
   pri->i->alpha[4][2] = 0.063868972113;
   pri->i->alpha[4][3] = 0.042432587902;

   pri->i->pq[5] = 0.055442639402;
   pri->i->alpha[5][0] = 0.615068901818;
   pri->i->alpha[5][1] = 14.630712353118;
   pri->i->alpha[5][2] = 0.298404817403;
   pri->i->alpha[5][3] = 0.864718655041;

   pri->i->pq[6] = 0.118379098369;
   pri->i->alpha[6][0] = 1.163176461349;
   pri->i->alpha[6][1] = 0.408090165233;
   pri->i->alpha[6][2] = 11.188793743319;
   pri->i->alpha[6][3] = 0.699118301558;

   pri->i->pq[7] = 0.132712685095;
   pri->i->alpha[7][0] = 16.417200192194;
   pri->i->alpha[7][1] = 0.980503286582;
   pri->i->alpha[7][2] = 1.132071515554;
   pri->i->alpha[7][3] = 1.376129445524;

   /* end of autogenerated code block
	*****************************************************************/

   pri->maxnq = 9;		/* 9-component bp mixture was the most */
   pri->maxnalpha = 16;		/* bp priors were the most w/ 16 components */
   return pri;

 ERROR:
   cm_Fail("Memory allocation error.");
   return NULL;
}

/* Below are Alex's default prior structures, but they are not consistent
 * with the new prior structure defined in this file, and need to be
 * morphed into the correct structure.  I've kept them here to save the
 * numbers. EPN 01.31.05
 */
/*
struct prior_s *default_single_prior(void) {
  struct prior_s *pri;
  int i, j;
#define numcomponents 8
  assert(numcomponents < MAXDCHLET);
  double q[numcomponents] = {
	0.085091850427, 0.015935406086, 0.102013232739, 0.415954530541,
	0.074470557341, 0.055442639402, 0.118379098369, 0.132712685095
  };
  double m[numcomponents][MAXABET] = {
	{0.575686380127, 0.756214632926, 0.340269621276, 13.774558068728, },
	{153.865583955384, 0.235000107300, 0.356622653787, 0.006812718667, },
	{176.440373997567, 0.935905951648, 1.292808081312, 1.617069444109, },
	{1.696250324914, 1.128033754503, 0.955462899400, 1.676465850057, },
	{0.074365531036, 0.039185613484, 0.063868972113, 0.042432587902, },
	{0.615068901818, 14.630712353118, 0.298404817403, 0.864718655041, },
	{1.163176461349, 0.408090165233, 11.188793743319, 0.699118301558, },
	{16.417200192194, 0.980503286582, 1.132071515554, 1.376129445524, },
  };
  pri = MallocOrDie(sizeof(struct prior_s));
  pri->mntnum = numcomponents;
  pri->mntasize = MAXABET;
  for (i = 0; i < numcomponents; i++) {
	pri->mntq[i] = q[i];
	for (j = 0; j < pri->mntasize; j++) {
	  pri->mnt[i][j] = m[i][j];
	}
  }
#undef numcomponents
  return pri;
}

struct prior_s *default_basepair_prior(void) {
  struct prior_s *pri;
  int i, j;
#define numcomponents 9
  assert(numcomponents < MAXDCHLET);
  double q[numcomponents] = {
	0.030512242264, 0.070312169889, 0.118499696300, 0.181025557995,
	0.188791659665, 0.157630937531, 0.041708924031, 0.095930656547,
	0.115588155778
  };
  double m[numcomponents][MAXABET*MAXABET] = {
	{0.571860339721, 0.605642194896, 0.548004739487, 1.570353271532, 0.591611867703, 0.469713257214, 1.447411319683, 0.600381079228, 0.520096937350, 1.867142019076, 0.470428282443, 1.165356324744, 1.528348208160, 0.686072963473, 1.072148274499, 0.659833749087},
	{0.116757286812, 0.052661180881, 0.067541712113, 0.258482314714, 0.152527972588, 0.034460232010, 0.416430364713, 0.051541326273, 0.079542103337, 0.162883420833, 0.042615616796, 0.123363759874, 0.922897266376, 0.078567729294, 0.315242459757, 0.116457644231},
	{0.028961414077, 0.022849036260, 0.120089637379, 0.509884713979, 0.142464495045, 0.079507804767, 21.835608089779, 0.070200164694, 0.005189494879, 0.540651647339, 0.117833357497, 0.128182594376, 1.766866842025, 0.016341625779, 0.832665494899, 0.058379188171},
	{0.000926960236, 0.008100076237, 0.001794303710, 0.114209483231, 0.001459159085, 0.000053878201, 0.072605927746, 0.005533021345, 0.003941720307, 0.095421675098, 0.004844990769, 0.072393572779, 0.099144450569, 0.002561491533, 0.043103588084, 0.008080970629},
	{0.002163861165, 0.007785521817, 0.003483930554, 0.625515668281, 0.018621932500, 0.001352139642, 1.371471086809, 0.007920737783, 0.000946403264, 0.688821384972, 0.002203762108, 0.192533693864, 0.979473608513, 0.000916007398, 0.347662973488, 0.020677924150},
	{0.083035113547, 0.166815168558, 0.042669979127, 3.415107328082, 0.023530116520, 0.047677945396, 1.183956650707, 0.059920099115, 0.076614058723, 5.434261851985, 0.095284240991, 0.889915882997, 1.201576769946, 0.074453244946, 0.397879304331, 0.130525904952},
	{0.217001113139, 0.388746098242, 0.134680826556, 24.923110155367, 0.102582693868, 0.131678864943, 1.150978162882, 0.256720461728, 0.150993730345, 3.200824712363, 0.077595421397, 1.025428618792, 1.228870901327, 0.143610901605, 0.406308970402, 0.322809888354},
	{0.129043208355, 0.112308496092, 0.116841517642, 2.878927926806, 0.306789207829, 0.078411064993, 6.377836578660, 0.114524370807, 0.094192610036, 2.566493997218, 0.096694574300, 0.791295335090, 6.907854285192, 0.132657156809, 1.225349985791, 0.296596767798},
	{0.005830777296, 0.153807106950, 0.003131256711, 1.340589241710, 0.006802639527, 0.135277067812, 0.487492640368, 0.009160116179, 0.068942867388, 29.409376576276, 0.099733235653, 0.722700985558, 0.500134122079, 0.124671165331, 0.105694456385, 0.025741311658},
  };
  pri = MallocOrDie(sizeof(struct prior_s));
  pri->mbpnum = numcomponents;
  pri->mbpasize = MAXABET*MAXABET;
  for (i = 0; i < pri->mbpnum; i++) {
	pri->mbpq[i] = q[i];
	for (j = 0; j < pri->mbpasize; j++) {
	  pri->mbp[i][j] = m[i][j];
	}
  }
#undef numcomponents
  return pri;
}
*/

/*** End of inlined file: prior.c ***/


/*** Start of inlined file: rnamat.c ***/
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

static matrix_t *setup_matrix (int size);
static float simple_identity(const ESL_ALPHABET *abc, char *s1, char *s2);
/*
  static void print_matrix (FILE *fp, fullmat_t *fullmat);
  static float get_min_alpha_beta_sum (fullmat_t *fullmat);
  static void count_matrix (ESL_MSA *msa, fullmat_t *fullmat, double *background_nt, int cutoff_perc, int product_weights);
  static int unpaired_res (int i);
*/

/*
 * Maps c as follows:
 * A->0
 * C->1
 * G->2
 * T->3
 * U->3
 * else->-1
 */
int numbered_nucleotide (char c) {
  switch (c) {
  case 'A':
  case 'a':
	return (0);
  case 'C':
  case 'c':
	return (1);
  case 'G':
  case 'g':
	return (2);
  case 'T':
  case 't':
  case 'U':
  case 'u':
	return (3);
  }
  return (-1);
}

/*
 * Maps base pair c,d as follows:
 *
 * AA -> 0
 * AC -> 1
 * ....
 * TG -> 14
 * TT -> 15 (T==U)
 * Anything else maps to -1
 */
int numbered_basepair (char c, char d) {
  int c_num, d_num;
  c_num = numbered_nucleotide (c);
  d_num = numbered_nucleotide (d);
  if (c_num < 0 || d_num < 0) {
	return (-1);
  } else {
	return ((c_num << 2) | d_num);
  }
}

/* Function: rjk_KHS2ct()
 * Incept:   SRE 29 Feb 2000 [Seattle]; from COVE 1.0 code
 * Modified: RJK 27 Feb 2002 [St. Louis]; from Infernal code (rna_ops.c)
 * Purpose:  Convert a secondary structure string (0..len-1) to an array of
 *           integers representing what position each position is base-paired
 *           to (0..len-1) or -1 if none.  This is a change from what Sean
 *           did in the Infernal code back towards the original way it was
 *           done in the Squid code (compstruct_main.c).  In this case, the
 *           numbering scheme does not match Zuker's .ct files, but does
 *           match the way the MSA is stored using the SQUID library
 *           functions.
 *
 *           This version does not allow pseudoknots.  Thus ">" and "<" are
 *           used for base pairs, and all other characters, including white
 *           space, are taken to mean unpaired nucleotides.
 *
 * Return:   ret_ct is allocated here and must be free'd by caller.
 *           Returns pointer to ret_ct, or NULL if ss is somehow inconsistent.
 */
int *rjk_KHS2ct(char *ss, int len) {
  ESL_STACK *pda;
  int      *ct;
  int       pos, pair;
  int       status;

 /* Initialization: always initialize the main pda (0),
   */
  pda = esl_stack_ICreate();

  ESL_ALLOC(ct, len * sizeof(int));
  for (pos = 0; pos < len; pos++)
	ct[pos] = -1;

  for (pos = 0; pos < len; pos++) {
	  if (!isprint(ss[pos])) {   /* armor against garbage strings */
	free (ct);
	esl_stack_Destroy(pda);
	return (NULL);
	  } else if (ss[pos] == '>') {  /* left side of a pair: push onto stack */
		if((status = esl_stack_IPush(pda, pos)) != eslOK) goto ERROR;
	  } else if (ss[pos] == '<') { /* right side of a pair; resolve pair */
	if (esl_stack_IPop(pda, &pair) == eslEOD) {
	  free (ct);
	  esl_stack_Destroy(pda);
	  return (NULL);
	} else {
	  if(status != eslOK) goto ERROR;
	  ct[pos]  = pair;
	  ct[pair] = pos;
	}
	  }
  }
								/* nothing should be left on stacks */
  if (esl_stack_ObjectCount(pda) != 0) {
	free (ct);
	esl_stack_Destroy(pda);
	return (NULL);
  }
  esl_stack_Destroy(pda);
  return (ct);

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/*
 * Setup the matrix by allocating matrix in two dimensions as triangle.
 * Initialize to 0.0
 */
matrix_t *setup_matrix (int size) {
  int c;
  matrix_t *mat;
  int status;

  ESL_ALLOC(mat, sizeof(matrix_t));
  mat->edge_size = size;
  mat->full_size = matrix_index((size-1),(size-1)) + 1;
  mat->E = 0.0;
  mat->H = 0.0;
  ESL_ALLOC(mat->matrix, sizeof(double) * mat->full_size);
  for (c=0; c<mat->full_size; c++) {
	mat->matrix[c] = 0.0;
  }
  return(mat);

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/*
 * middle_of_stem
 *
 * Boolean function, returns TRUE if the gap is in the middle of a stem,
 * false if otherwise.
 *
 * Inputs:
 * msa -- the msa
 * i, j -- indices of the two seqs
 * pos -- the position of the gap in question
 * ct -- array of ct arrays
 */
int middle_of_stem (ESL_MSA *msa, int i, int j, int pos, int **ct) {
  int gap_start_pos, gap_stop_pos;

  if (esl_abc_CIsGap(msa->abc, msa->aseq[i][pos]) &&
	  esl_abc_CIsGap(msa->abc, msa->aseq[j][pos]))
	/* Double gap -- exit */
	return (0);

  if (esl_abc_CIsGap(msa->abc, msa->aseq[j][pos])) {
	/* Swap so gap is in i */
	gap_start_pos = i;
	i = j;
	j = gap_start_pos;
  }

  /* Now, find start and end positions of the gap */
  for (gap_start_pos = pos; gap_start_pos >= 0; gap_start_pos--) {
	if (!esl_abc_CIsGap(msa->abc, msa->aseq[i][gap_start_pos]))
	  break;
  }
  for (gap_stop_pos = pos; gap_stop_pos < msa->alen; gap_stop_pos++) {
	if (!esl_abc_CIsGap(msa->abc, msa->aseq[i][gap_stop_pos]))
	  break;
  }
  if (gap_start_pos < 0 || gap_start_pos >= msa->alen)
	/* Gap at end of alignment; can't be internal to stem */
	return (0);

  if (ct[i][gap_start_pos] == 0 || ct[j][gap_start_pos] == 0 ||
	  ct[i][gap_stop_pos] == 0 || ct[j][gap_stop_pos] == 0)
	/* Either of the ends not paired */
	return (0);

  if (ct[i][gap_start_pos] != ct[j][gap_start_pos] ||
	  ct[i][gap_stop_pos] != ct[j][gap_stop_pos])
	/* The ends not paired homologously */
	return (0);

  return (1);
}

/* TAKEN FROM SQUID's weight.c's simple_distance, but rewritten to
 *  be simple_identity
 * Function: simple_identity()
 *
 * Purpose:  For two identical-length null-terminated strings, return
 *           the fractional identity between them. (0..1)
 *           (Gaps don't count toward anything.)
 */
float
simple_identity(const ESL_ALPHABET *abc, char *s1, char *s2)
{
  int diff  = 0;
  int valid = 0;

  for (; *s1 != '\0'; s1++, s2++)
	{
	  if (esl_abc_CIsGap(abc, *s1) || esl_abc_CIsGap(abc, *s2)) continue;
	  if (*s1 == *s2) diff++;
	  valid++;
	}
  return (valid > 0 ? ((float) diff / (float) valid) : 0.0);
}

/*
 * count_matrix
 *
 * Given an MSA and two matrices, counts pairs of column(s) from two sequences
 * at a time into the matrices using the BLOSUM algorithm.
 *
 * Fills in paired matrix (for basepairs), unpaired, background nt count in
 * aligned regions
 *
 * If product weights is false, weight of a pair is average of their weights.
 * If it is true, weight of a pair is product of their weights
 *
 * Each nucleotide at each position can be:
 *    one of gap, unknown character (not ACGTU), known character
 *    one of left bp, right bp, not base paired
 * If both characters are gaps:
 *   Skip
 * If both characters are known:
 *   If both are left bps and match to same right bps
 *     continue
 *   If both are right bps and match to same left bps
 *     add to pairedmat
 *   Otherwise
 *     Add to unpairedmat
 *
 * Note: Never used in current implementation. Here for reference,
 *       in case new RIBOSUM matrices are trained someday.
 *       EPN, Tue Aug  7 15:10:33 2007
 */
void count_matrix (ESL_MSA *msa, fullmat_t *fullmat, double *background_nt,
		   int cutoff_perc, int product_weights) {

  /* contract check */
  if(msa->abc->type != eslRNA) cm_Fail("In count_matrix, MSA's alphabet is not RNA.");
  if(msa->flags & eslMSA_DIGITAL) cm_Fail("In count_matrix, MSA must be text, not digitized.");

  int status;
  int i, j;            /* Seqs we're checking */
  int pos;             /* Column we're counting */
  int prev_pos;        /* Last column we counted */
  float cur_wgt;
  int **ct;            /* ct matrix for all the seqs */
#ifdef REPORT_COUNTED
  int totpair = 0;
  int totsing = 0;
#endif

  /*****************************************
   * 1.  Allocate and fill in ct array
   *****************************************/
  ESL_ALLOC(ct, sizeof(int *)*msa->nseq);
  if (msa->ss_cons != NULL) {
	ct[0] = rjk_KHS2ct (msa->ss_cons, msa->alen);
  } else {
	ct[0] = rjk_KHS2ct (msa->ss[0], msa->alen);
  }
  for (i=1; i<msa->nseq; i++) {
	if (msa->ss_cons != NULL) {
	  ct[i] = ct[0];
	} else {
	  ct[i] = rjk_KHS2ct (msa->ss[i], msa->alen);
	}
  }
  for (i=0; i<msa->nseq; i++) {
	if (ct[i] == NULL) {
	cm_Fail("CT string %d is NULL\n", i);
	}
  }

  /**********************************
   * 2.  Count
   **********************************/
  for (i=0; i<msa->nseq; i++) {
	for (j=0; j<i; j++) {
	  /* First, make sure it's above the cutoff */
	  if (simple_identity(msa->abc, msa->aseq[i], msa->aseq[j]) <
	  0.01*(float)cutoff_perc)
	continue;       /* Not above cutoff */

	  if (product_weights == 1) {
	cur_wgt = msa->wgt[i] * msa->wgt[j];
	  } else {
	cur_wgt = (msa->wgt[i] + msa->wgt[j])/2.;
	  }

	  /* First, skip starting double gaps */
	  for (prev_pos = 0; prev_pos <msa->alen &&
	     is_rna_gap (msa, i, prev_pos) && is_rna_gap (msa, j, prev_pos);
	   prev_pos++);

	  for (pos=prev_pos; pos<msa->alen; pos++) {
	if (is_defined_rna_nucleotide(msa, i, pos) &&
	    is_defined_rna_nucleotide (msa, j, pos)) {
	  /* If both positions are defined nucleotides */
	  /* If both are left bps and match to same right bps, continue
			 If both are right bps and match to same left bps, add to \
	     pairedmat.  Otherwise, add to unpairedmat */
	  if (ct[i][pos] >= 0 && ct[j][pos] >= 0) {        /* Base pairs */
	    if (ct[i][pos] == ct[j][pos]) {              /* Both equal */
	      if (is_defined_rna_nucleotide(msa, i, ct[i][pos]) && \
		  is_defined_rna_nucleotide (msa, j, ct[j][pos])) {
		/* Both are RNA nucleotides */
		if (pos < ct[i][pos] && pos <ct[j][pos]) { /* Both left bps */
		  continue;
		} else {                                   /* Both right bps */
		  fullmat->paired->matrix\
		    [matrix_index(numbered_basepair(msa->aseq[i][ct[i][pos]],
						    msa->aseq[i][pos]),
				  numbered_basepair(msa->aseq[j][ct[j][pos]],
						    msa->aseq[j][pos]))] +=
		    cur_wgt;
		  background_nt[numbered_nucleotide
			       (msa->aseq[i][ct[i][pos]])] += cur_wgt;
		  background_nt[numbered_nucleotide
			       (msa->aseq[i][pos])] += cur_wgt;
		  background_nt[numbered_nucleotide
			       (msa->aseq[j][ct[j][pos]])] += cur_wgt;
		  background_nt[numbered_nucleotide
			       (msa->aseq[j][pos])] += cur_wgt;
#ifdef REPORT_COUNTED
		  totpair++;
#endif
		  continue;
		}
	      }
	    }
	  }

	  fullmat->unpaired->matrix
	    [matrix_index(numbered_nucleotide(msa->aseq[i][pos]),
			  numbered_nucleotide(msa->aseq[j][pos]))] += cur_wgt;
	  background_nt[numbered_nucleotide(msa->aseq[i][pos])] += cur_wgt;
	  background_nt[numbered_nucleotide(msa->aseq[j][pos])] += cur_wgt;
#ifdef REPORT_COUNTED
	  totsing++;
#endif
	}
	  }
#ifdef REPORT_COUNTED
	  printf ("%d pairs counted\n%d singles counted\n", totpair, totsing);
	  totpair = 0;
	  totsing = 0;
#endif
	}
  }

  /* Free ct arrays */
  if (ct[0] == ct[1]) {
	free (ct[0]);
  } else {
	for (i=0; i<msa->nseq; i++) {
	  free (ct[i]);
	}
  }
  free (ct);
  return;

 ERROR:
  cm_Fail("Memory allocation error.");
}

/*
 * print_matrix
 *
 * Dumps the paired and unpaired matrices and gap penalties
 */
void print_matrix (FILE *fp, fullmat_t *fullmat)
{
  int i, j;

  fprintf (fp, "%s\n\n", fullmat->name);

  /* EPN: print background NT frequencies */
  fprintf (fp, "    ");
  for (i=0; i < fullmat->abc->K; i++) {
	fprintf (fp, "%c           ", fullmat->abc->sym[i]);
  }
  fprintf (fp, "\n");

  fprintf (fp, "    ");
  for (i=0; i < fullmat->abc->K; i++) {
	fprintf (fp, "%-11f ", fullmat->g[i]);
  }
  fprintf (fp, "\n\n");

  fprintf (fp, "    ");
  for (i=0; i < fullmat->abc->K; i++) {
	fprintf (fp, "%c           ", fullmat->abc->sym[i]);
  }
  fprintf (fp, "\n");

  for (i=0; i < fullmat->abc->K; i++) {
	fprintf (fp, "%c   ", fullmat->abc->sym[i]);
	for (j=0; j<=i; j++) {
	  fprintf (fp, "%-11f ", fullmat->unpaired->matrix[matrix_index(fullmat->abc->inmap[(int) fullmat->abc->sym[i]], fullmat->abc->inmap[(int)fullmat->abc->sym[j]])]);
	}
	fprintf (fp, "\n");
  }
  if (strstr (fullmat->name, "RIBOPROB") == NULL)    /* Not probability mat */
	fprintf (fp, "H: %.4f\nE: %.4f\n", fullmat->unpaired->H, fullmat->unpaired->E);

  fprintf (fp, "\n    ");
  for (i=0; i < (fullmat->abc->K * fullmat->abc->K); i++) {
	fprintf (fp, "%c%c          ", RNAPAIR_ALPHABET[i], RNAPAIR_ALPHABET2[i]);
  }
  fprintf (fp, "\n");
  for (i=0; i < (fullmat->abc->K * fullmat->abc->K); i++) {
	fprintf (fp, "%c%c  ", RNAPAIR_ALPHABET[i], RNAPAIR_ALPHABET2[i]);
	for (j=0; j<=i; j++) {
	  /* ORIGINAL: fprintf (fp, "%-9.2f ", fullmat->paired->matrix[matrix_index(numbered_basepair(RNAPAIR_ALPHABET[i], RNAPAIR_ALPHABET2[i]), numbered_basepair (RNAPAIR_ALPHABET[j], RNAPAIR_ALPHABET2[j]))]);*/
	  /*EPN: */
	  fprintf (fp, "%-11f ", fullmat->paired->matrix[matrix_index(numbered_basepair(RNAPAIR_ALPHABET[i], RNAPAIR_ALPHABET2[i]), numbered_basepair (RNAPAIR_ALPHABET[j], RNAPAIR_ALPHABET2[j]))]);
	}
	fprintf (fp, "\n");
  }

  if (strstr (fullmat->name, "RIBOPROB") == NULL)    /* Not probability mat */
	fprintf (fp, "H: %.4f\nE: %.4f\n", fullmat->paired->H, fullmat->paired->E);
  fprintf (fp, "\n");
}

/*
 * Read the matrix from a file.
 * New EPN version, expects background freqs in file.
 */
fullmat_t *ReadMatrix(const ESL_ALPHABET *abc, FILE *matfp) {

  /* Contract check */
  if(abc->type != eslRNA)
	cm_Fail("Trying to read RIBOSUM matrix from RSEARCH, but alphabet is not eslRNA.");

  int status;
  char linebuf[256];
  char fullbuf[16384];
  int fullbuf_used = 0;
  fullmat_t *fullmat;
  int i;
  char *cp, *end_mat_pos;

  ESL_ALLOC(fullmat, (sizeof(fullmat_t)));
  fullmat->abc      = abc; /* just a pointer */
  fullmat->unpaired = setup_matrix (fullmat->abc->K);
  fullmat->paired = setup_matrix (fullmat->abc->K * fullmat->abc->K);
  ESL_ALLOC(fullmat->g, sizeof(float) * fullmat->abc->K);

  while (fgets (linebuf, 255, matfp)) {
	strncpy (fullbuf+fullbuf_used, linebuf, 16384-fullbuf_used-1);
	fullbuf_used += strlen(linebuf);
	if (fullbuf_used >= 16384) {
	  cm_Fail ("ERROR: Matrix file bigger than 16kb\n");
	}
  }

  /* First, find RIBO, and copy matrix name to fullmat->name */
  cp = strstr (fullbuf, "RIBO");
  for (i = 0; cp[i] && !isspace(cp[i]); i++);   /* Find space after RIBO */
  ESL_ALLOC(fullmat->name, sizeof(char)*(i+1));
  strncpy (fullmat->name, cp, i);
  fullmat->name[i] = '\0';
  cp = cp + i;
  if(strstr (fullmat->name, "SUM")) { fullmat->scores_flag = TRUE; fullmat->probs_flag = FALSE; }
  else if(strstr (fullmat->name, "PROB")) { fullmat->scores_flag = FALSE; fullmat->probs_flag = TRUE; }
  else cm_Fail("ERROR reading matrix, name does not include SUM or PROB.\n");

  /* Now, find the first A */
  cp = strchr (cp, 'A');
  fullmat->unpaired->edge_size = 0;
  /* And count how edge size of the matrix */
  while (*cp != '\n' && cp-fullbuf < fullbuf_used) {
	if (!isspace (cp[0]) && isspace (cp[1])) {
	  fullmat->unpaired->edge_size++;
	}
	cp++;
  }
  /* EPN added to read background freqs to store in g vector */

  /* Read background freqs until we hit the next A */
  end_mat_pos = strchr (cp, 'A');
  for (i=0; cp - fullbuf < end_mat_pos-fullbuf; i++) {
	while (!isdigit(*cp) && *cp != '-' && *cp != '.' && \
	   cp-fullbuf < fullbuf_used && cp != end_mat_pos) {
	cp++;
	}
	if (cp == end_mat_pos)
	  break;
	if (cp-fullbuf < fullbuf_used) {
	  fullmat->g[i] = atof(cp);
	  while ((isdigit (*cp) || *cp == '-' || *cp == '.') &&\
	     (cp-fullbuf <fullbuf_used)) {
	cp++;
	  }
	}
  }
  /* we've read the background, normalize it */
  esl_vec_FNorm(fullmat->g, fullmat->unpaired->edge_size);

  /* We've already found the next A */
  /* end EPN block */

  /* Take numbers until we hit the H: */
  end_mat_pos = strstr (cp, "H:");
  for (i=0; cp - fullbuf < end_mat_pos-fullbuf; i++) {
	while (!isdigit(*cp) && *cp != '-' && *cp != '.' && \
	   cp-fullbuf < fullbuf_used && cp != end_mat_pos) {
	cp++;
	}
	if (cp == end_mat_pos)
	  break;
	if (cp-fullbuf < fullbuf_used) {
	  fullmat->unpaired->matrix[i] = atof(cp);
	  while ((isdigit (*cp) || *cp == '-' || *cp == '.') &&\
	     (cp-fullbuf <fullbuf_used)) {
	cp++;
	  }
	}
  }
  fullmat->unpaired->full_size = i;

  /* Skip the H: */
  cp += 2;
  fullmat->unpaired->H = atof(cp);

  /* Now, go past the E: */
  cp = strstr (cp, "E:") + 2;
  fullmat->unpaired->E = atof(cp);

  /********* PAIRED MATRIX ************/
  /* Now, find the first A */
  cp = strchr (cp, 'A');
  fullmat->paired->edge_size = 0;
  /* And count how edge size of the matrix */
  while (*cp != '\n') {
	if (!isspace (cp[0]) && isspace (cp[1])) {
	  fullmat->paired->edge_size++;
	}
	cp++;
  }

  /* Find next A */
  while (*cp != 'A' && (cp-fullbuf) < fullbuf_used) cp++;

  /* Take numbers until we hit the H: */
  end_mat_pos = strstr (cp, "H:");
  for (i=0; cp - fullbuf < end_mat_pos-fullbuf; i++) {
	while (!isdigit(*cp) && *cp != '-' && *cp != '.' && \
	   cp-fullbuf < fullbuf_used && cp != end_mat_pos) {
	cp++;
	}
	if (cp == end_mat_pos)
	  break;
	if (cp-fullbuf < fullbuf_used) {
	  fullmat->paired->matrix[i] = atof(cp);
	  while ((isdigit (*cp) || *cp == '-' || *cp == '.') &&\
	     (cp-fullbuf <fullbuf_used)) {
	cp++;
	  }
	}
  }
  fullmat->paired->full_size = i;

  /* Skip the H: */
  cp += 2;
  fullmat->paired->H = atof(cp);

  /* Now, go past the E: */
  cp = strstr (cp, "E:") + 2;
  fullmat->paired->E = atof(cp);

  /*print_matrix(stdout, fullmat);*/
  return (fullmat);

 ERROR:
  cm_Fail("Memory allocation error.");
  return NULL; /* never reached */
}

/*
 * MatFileOpen
 *
 * Given name of matrix file, open it
 *
 */
FILE *MatFileOpen (char *matfile)
{
	 FILE *fp;

	 if (matfile == NULL)
	   return NULL;

	 fp = fopen (matfile, "r");
	 if (fp != NULL) return (fp);

	 return (NULL);
}

/*
 * Function: get_min_alpha_beta_sum()
 * Date:     RJK, Mon Apr 29, 2002 [St. Louis]
 * Purpose:  Given a full matrix, reports minimum sum allowed
 *           for alpha and beta (or alpha' and beta')
 *           The maximum for alpha+beta is found by
 *           min Sp(i,j)(k,l) - max{Su(i,k), Su(j,l)}
 *            for all i,j,k.l
 */
float get_min_alpha_beta_sum (fullmat_t *fullmat) {
  float max_sum = 9999999.9;              /* max allowed value of alpha+beta */
  float cur_dif;
  int i,j,k,l;
  int pair_ij, pair_kl;

  for (i=0; i<fullmat->abc->K; i++)
	for (j=0; j<fullmat->abc->K; j++)
	  for (k=0; k<fullmat->abc->K; k++)
	for (l=0; l<fullmat->abc->K; l++) {
	  pair_ij = numbered_basepair(fullmat->abc->sym[i], fullmat->abc->sym[j]);
	  pair_kl = numbered_basepair(fullmat->abc->sym[k], fullmat->abc->sym[l]);
	  /* First check for i,k paired */
	  cur_dif = fullmat->paired->matrix[matrix_index(pair_ij, pair_kl)] -
	    fullmat->unpaired->matrix[matrix_index(i,k)];
	  if (cur_dif < max_sum)
	    max_sum = cur_dif;
	  /* And repeat for j,l */
	  cur_dif = fullmat->paired->matrix[matrix_index(pair_ij, pair_kl)] -
	    fullmat->unpaired->matrix[matrix_index(j,l)];
	  if (cur_dif < max_sum)
	    max_sum = cur_dif;
	}
  return (-1. * max_sum);
}

/* EPN, Tue Feb  6 15:34:00 2007 */
void FreeMat(fullmat_t *fullmat)
{
  if(fullmat->unpaired != NULL)
	{
	  free(fullmat->unpaired->matrix);
	  free(fullmat->unpaired);
	}
  if(fullmat->paired != NULL)
	{
	  free(fullmat->paired->matrix);
	  free(fullmat->paired);
	}
  if(fullmat->name != NULL)
	free(fullmat->name);
  if(fullmat->g != NULL)
	free(fullmat->g);
  free(fullmat);
}

/* Function: ribosum_calc_targets()
 * Incept:   EPN, Wed Mar 14 06:01:11 2007
 *
 * Purpose:  Given a RIBOSUM score matrix data structure (fullmat_t) with
 *           log odds scores (as read in from a RIBOSUM file) and a background
 *           model (fullmat->g), overwrite the log-odds scores with target
 *           probabilities f_ij that satisfy:
 *
 *           sum_ij f_ij = 1.0
 *
 *           NOTE: these target probs are not the same target probs
 *                 dumped by makernamat -p in RSEARCH, those *off-diagonals*
 *                 are double what I'm calculating here.
 *                 (so that sum_ii f'_ii + sum_j<i f'_ij = 1.0)
 *
 *
 * Returns:   <eslOK> on success.
 *
 */
int ribosum_calc_targets(fullmat_t *fullmat)
{
  int       idx;
  int       a,b,i,j,k,l;

  /* Check the contract. */
  if(!(fullmat->scores_flag)) ESL_EXCEPTION(eslEINVAL, "in ribosum_calc_targets(), matrix is not in log odds mode");
  if(fullmat->probs_flag) ESL_EXCEPTION(eslEINVAL, "in ribosum_calc_targets(), matrix is already in probs mode");

  /*printf("\nbeginning of ribosum_calc_targets, printing mx:\n");
	print_matrix(stdout, fullmat);*/

  /* convert log odds score s_ij, to target (f_ij)
   * using background freqs (g), by:
   * f_ij = g_i * g_j * 2^{s_ij} */

  /* first convert the unpaired (singlet) matrix,
  *  remember matrix is set up as a vector */
  idx = 0;
  for(i = 0; i < fullmat->abc->K; i++)
	for(j = 0; j <= i; j++)
	  {
	fullmat->unpaired->matrix[idx] =
	  fullmat->g[i] * fullmat->g[j] * sreEXP2(fullmat->unpaired->matrix[idx]);
	idx++;
	  }
  /* and the paired matrix, careful about for loops here, we
   * use 4 nested ones just to keep track of which backgrounds to multiply
   * (the g[i] * g[j] * g[k] * g[l] part) */
  idx = 0;
  for(a = 0; a < sizeof(RNAPAIR_ALPHABET)-1; a++)
	for(b = 0; b <= a; b++)
	  {
	i = a / fullmat->abc->K;
	j = a % fullmat->abc->K;
	k = b / fullmat->abc->K;
	l = b % fullmat->abc->K;

	fullmat->paired->matrix[idx] =
	  fullmat->g[i] * fullmat->g[j] * fullmat->g[k] * fullmat->g[l] *
	  sreEXP2(fullmat->paired->matrix[idx]);
	idx++;
	  }

  /* We have to be careful with normalizing the matrices b/c they are
   * symmetric and fullmat_t only stores f_ij i<=j. So we double
   * the f_ij if i!=j, normalize it (it should then sum to 1.)
   * and then halve the f_ij i != j's. */
  /* normalize the unpaired matrix */
  idx = 0;
  for(i = 0; i < fullmat->abc->K; i++)
	for(j = 0; j <= i; j++)
	  {
	if(i != j) fullmat->unpaired->matrix[idx] *= 2.;
	idx++;
	  }
  esl_vec_DNorm(fullmat->unpaired->matrix, fullmat->unpaired->full_size);
  idx = 0;
  for(i = 0; i < fullmat->abc->K; i++)
	for(j = 0; j <= i; j++)
	  {
	if(i != j) fullmat->unpaired->matrix[idx] *= 0.5;
	idx++;
	  }

  /* normalize the paired matrix */
  idx = 0;
  for(a = 0; a < sizeof(RNAPAIR_ALPHABET)-1; a++)
	for(b = 0; b <= a; b++)
	  {
	if(a != b) fullmat->paired->matrix[idx] *= 2.;
	idx++;
	  }
  esl_vec_DNorm(fullmat->paired->matrix,   fullmat->paired->full_size);
  idx = 0;
  for(a = 0; a < sizeof(RNAPAIR_ALPHABET)-1; a++)
	for(b = 0; b <= a; b++)
	  {
	if(a != b) fullmat->paired->matrix[idx] *= 0.5;
	idx++;
	  }

  /* Lower the scores_flag, raise probs_flag */
  fullmat->scores_flag = FALSE;
  fullmat->probs_flag = TRUE;

  /*printf("\nend of ribosum_calc_targets, printing mx:\n");
	print_matrix(stdout, fullmat);*/
  return eslOK;
}

/* Function: ribosum_MSA_resolve_degeneracies
 *
 * Incept:   EPN, Thu Mar 15 05:37:22 2007
 *
 * Purpose:  Given a RIBOSUM score matrix data structure (fullmat_t) with
 *           target probabilites and a MSA with SS markup, remove all
 *           ambiguous bases. Do this by selecting the most likely
 *           singlet or base pair that matches each ambiguity given the
 *           RIBOSUM matrix.
 *           (ex: (G|A) for 'R', or (GG|GC|AG|AC) bp for 'RS' base pair)
 *
 *
 * Returns:   <eslOK> on success.
 *
 * The degenerate code used here is:
 * (taken from http://www.neb.com/neb/products/REs/RE_code.html
 *
 *                         X = A or C or G or T
 *                         R = G or A
 *                         Y = C or T
 *                         M = A or C
 *                         K = G or T
 *                         S = G or C
 *                         W = A or T
 *                         H = not G (A or C or T)
 *                         B = not A (C or G or T)
 *                         V = not T (A or C or G)
 *                         D = not C (A or G or T)
 *                         N = A or C or G or T
 */
int ribosum_MSA_resolve_degeneracies(fullmat_t *fullmat, ESL_MSA *msa)
{
  int       idx;
  int       i,j;
  int      *ct;		  /* 0..alen-1 base pair partners array         */
  int       apos;
  char       c;           /* tmp char for current degeneracy, uppercase */
  char      *cp;          /* tmp char pointer for finding c in degen_string */
  char       c_m;         /* tmp char for current bp mate's degeneracy, uppercase */
  char      *cp_m;        /* tmp char pointer for finding c_m in degen_string */
  char degen_string[13] = "XRYMKSWHBVDN\0";
  char rna_string[5] =    "ACGU\0";
  int  **degen_mx;
  float      *unpaired_marginals;
  float      *paired_marginals;
  float  *cur_unpaired_marginals;
  float  *cur_paired_marginals;
  char      *aseq;
  int        dpos;       /* position of c within degen_string */
  int        dpos_m;     /* position of c_m within degen_string */
  int        argmax;
  int        mate;       /* used as ct[apos-1] */
  int        status;
  ESL_ALPHABET *msa_abc = msa->abc; /* when we textize this, msa->abc will be set to NULL! */

  /* Check the contract. */
  if(!(fullmat->probs_flag))                               ESL_EXCEPTION(eslEINVAL, "in ribosum_MSA_resolve_degeneracies(), matrix is not in probs mode");
  if(fullmat->scores_flag)                                 ESL_EXCEPTION(eslEINVAL, "in ribosum_MSA_resolve_degeneracies(), matrix is in scores mode");
  if(msa->nseq != 1)                                       ESL_EXCEPTION(eslEINVAL, "MSA does not have exactly 1 seq");
  if(fullmat->abc->type != eslRNA)                         ESL_EXCEPTION(eslEINVAL, " matrix alphabet not RNA");
  if(! (msa->flags & eslMSA_DIGITAL))                       ESL_EXCEPTION(eslEINVAL, " MSA is not digitized");
  if(msa->abc->type != eslRNA && msa->abc->type != eslDNA) ESL_EXCEPTION(eslEINVAL, " MSA alphabet not DNA or RNA");

  /*printf("in ribosum_MSA_resolve_degeneracies()\n");*/

  ESL_ALLOC(unpaired_marginals, sizeof(float) * fullmat->abc->K);
  ESL_ALLOC(paired_marginals, sizeof(float) * (fullmat->abc->K * fullmat->abc->K));
  ESL_ALLOC(cur_unpaired_marginals, sizeof(float) * fullmat->abc->K);
  ESL_ALLOC(cur_paired_marginals, sizeof(float) * (fullmat->abc->K * fullmat->abc->K));

  /* Laboriously fill in degen_mx, NOTE: this will fall over if alphabet is not RNA! */
  /* This is somewhat unnec, now that we use esl_alphabet.c, but I didnt' want to redo it, so I left it */
  ESL_ALLOC(degen_mx, sizeof(int *) * 12);
  for(i = 0; i < 12; i++)
	{
	  ESL_ALLOC(degen_mx[i], sizeof(int) * fullmat->abc->K);
	  esl_vec_ISet(degen_mx[i], fullmat->abc->K, 0.);
	}
  /* 'X' = A|C|G|U */
  degen_mx[0][0] = degen_mx[0][1] = degen_mx[0][2] = degen_mx[0][3] = 1;
  /* 'R' = A|G */
  degen_mx[1][0] = degen_mx[1][2] = 1;
  /* 'Y' = C|U */
  degen_mx[2][1] = degen_mx[2][3] = 1;
  /* 'M' = A|C */
  degen_mx[3][0] = degen_mx[3][1] = 1;
  /* 'K' = G|U */
  degen_mx[4][2] = degen_mx[4][3] = 1;
  /* 'S' = C|G */
  degen_mx[5][1] = degen_mx[5][2] = 1;
  /* 'W' = A|U */
  degen_mx[6][0] = degen_mx[6][3] = 1;
  /* 'H' = A|C|U */
  degen_mx[7][0] = degen_mx[7][1] = degen_mx[7][3] = 1;
  /* 'B' = C|G|U */
  degen_mx[8][1] = degen_mx[8][2] = degen_mx[8][3] = 1;
  /* 'V' = A|C|G */
  degen_mx[9][0] = degen_mx[9][1] = degen_mx[9][2] = 1;
  /* 'D' = A|G|U */
  degen_mx[10][0] = degen_mx[10][2] = degen_mx[10][3] = 1;
  /* 'N' = A|C|G|U */
  degen_mx[11][0] = degen_mx[11][1] = degen_mx[11][2] = degen_mx[11][3] = 1;

  /* calculate paired_marginals and unpaired_marginals as:
   * marginal[x] = sum_y P(x,y)
   */
  esl_vec_FSet(unpaired_marginals, fullmat->abc->K, 0.);
  esl_vec_FSet(paired_marginals, fullmat->abc->K * fullmat->abc->K, 0.);

  for(i = 0; i < fullmat->abc->K; i++)
	for(j = 0; j < fullmat->abc->K; j++)
	  unpaired_marginals[i] += fullmat->unpaired->matrix[matrix_index(i,j)];
  idx = 0;
  for(i = 0; i < (fullmat->abc->K*fullmat->abc->K); i++)
	for(j = 0; j < (fullmat->abc->K*fullmat->abc->K); j++)
	  paired_marginals[i] += fullmat->paired->matrix[matrix_index(i,j)];

  /*for(i = 0; i < (fullmat->abc->K); i++)
	printf("unpaired_marginals[i:%d]: %f\n", i, unpaired_marginals[i]);
	for(i = 0; i < (fullmat->abc->K*fullmat->abc->K); i++)
	printf("paired_marginals[i:%d]: %f\n", i, paired_marginals[i]);*/

  esl_vec_FNorm(unpaired_marginals, fullmat->abc->K);
  esl_vec_FNorm(paired_marginals, fullmat->abc->K*fullmat->abc->K);

  /* get ct array, indexed 1..alen while apos is 0..alen-1 */
  ESL_ALLOC(ct, (msa->alen+1) * sizeof(int));
  esl_wuss2ct(msa->ss_cons, msa->alen, ct);

  ESL_ALLOC(aseq, sizeof(char) * (msa->alen+1));
  status = esl_msa_Textize(msa);
  if(status == eslECORRUPT)      cm_Fail("esl_msa_Textize() returned status: %d, the msa must contain invalid digitized chars.", status);
  else if(status != eslOK) goto ERROR;

  /* remember we only have 1 seq in the MSA */
  for(apos = 0; apos < msa->alen; apos++)
	{
	  if (esl_abc_CIsGap(fullmat->abc, msa->aseq[0][apos])) continue; /* we can still have gaps in 1 seq MSA, they'll
								       * be dealt with (ignored) in
								       * modelmaker.c:HandModelmaker() */
	  mate = ct[(apos+1)]; /* apos is 0..alen-1, ct is 1..alen, so mate will be 1..alen now */
	  if(mate != 0 && esl_abc_CIsGap(msa_abc, msa->aseq[0][(mate-1)])) mate = 0;
	  /* apos is a base paired res, but mate is a gap, pretend apos is SS for our purposes here */
	  else if(mate != 0 && ((mate-1) < apos)) continue;
	  /* apos is a base paired res, but we've already changed him to an unambiguous res when we changed his mate (which was not a gap) */

	  c = toupper(msa->aseq[0][apos]);
	  if(c == 'T') c = 'U';
	  cp = strchr(rna_string, c);
	  if(cp == NULL)
	{
	  /* a degeneracy */
	  if((cp = strchr(degen_string, c)) == NULL) ESL_XEXCEPTION(eslEINVAL, "character is not ACGTU or a recognized ambiguity code");
	  dpos = cp-degen_string;
	  if(mate == 0) /* single stranded */
	    {
	      /*printf("\nCASE 1 SS AMBIG\n");
		printf("apos: %d c: %c\n", apos, c);*/
	      /* of possible residues, find the one with the highest marginal
	       * in RIBOSUM: argmax_x sum_Y P(x,y)  */
	      for(i = 0; i < fullmat->abc->K; i++)
		cur_unpaired_marginals[i] = degen_mx[dpos][i] * unpaired_marginals[i];
	      argmax = esl_vec_FArgMax(cur_unpaired_marginals, fullmat->abc->K);
	      msa->aseq[0][apos] = rna_string[argmax];
	      /*printf("c: %c at posn %d argmax: %d msa[apos:%d]: %c\n", c, (int) (cp-degen_string), argmax, apos, msa->aseq[0][apos]);
		printf("new ss: %c\n", rna_string[argmax]);*/
	    }
	  else /* paired */
	    {
	      /* is mate ambiguous? */
	      c_m = toupper(msa->aseq[0][(mate-1)]);
	      if(c_m == 'T') c_m = 'U';
	      cp_m = strchr(rna_string, c_m);
	      if(cp_m == NULL)
		{
		  /* mate is ambiguous */
		  /*printf("\nCASE 4 PAIR, BOTH AMBIG\n");
		    printf("left (apos) %d c: %c mate %d c_m: %c\n", apos, c, (mate-1), c_m);
		  */
		  if((cp_m = strchr(degen_string, c_m)) == NULL) ESL_XEXCEPTION(eslEINVAL, "character is not ACGTU or a recognized ambiguity code");
		  dpos_m = cp_m-degen_string;
		  /* we know that mate != 0 and (mate-1) >= apos, we continued above if that was false */
		  idx = 0;
		  for(i = 0; i < (fullmat->abc->K); i++)
		    for(j = 0; j < (fullmat->abc->K); j++)
		      {
			cur_paired_marginals[idx] = degen_mx[dpos][i] * degen_mx[dpos_m][j] *
			  paired_marginals[idx];
			/*printf("degen_mx[dpos:  %d][i:%d]: %d\n", dpos, i, degen_mx[dpos][i]);
			  printf("degen_mx[dpos_m:%d][j:%d]: %d\n", dpos_m, j, degen_mx[dpos_m][j]);
			  printf("cur_paired_marginals[idx:%d]: %f\n", idx, cur_paired_marginals[idx]);*/
			idx++;
		      }
		  argmax = esl_vec_FArgMax(cur_paired_marginals, (fullmat->abc->K*fullmat->abc->K));
		  msa->aseq[0][apos]     = RNAPAIR_ALPHABET[argmax];
		  msa->aseq[0][(mate-1)] = RNAPAIR_ALPHABET2[argmax];
		  /*printf("new bp: left: %c right: %c\n", RNAPAIR_ALPHABET[argmax], RNAPAIR_ALPHABET2[argmax]);*/

		}
	      else /* mate is unambiguous */
		{
		  /*printf("\nCASE 2 PAIR, LEFT AMBIG, RIGHT NOT\n");
		    printf("left (apos) %d c: %c mate %d c_m: %c\n", apos, c, (mate-1), c_m);*/
		  cp_m = strchr(rna_string, c_m);
		  dpos_m = cp_m - rna_string;
		  /* cp_m is 0 for A, 1 for C, 2 for G, 3 for U in mate-1 */
		  idx = 0;
		  for(i = 0; i < (fullmat->abc->K); i++)
		    for(j = 0; j < (fullmat->abc->K); j++)
		      {
			cur_paired_marginals[idx] = degen_mx[dpos][i] * (j == dpos_m) *
			  paired_marginals[idx];
			/*printf("cur_paired_marginals[idx:%d]: %f\n", idx, cur_paired_marginals[idx]);*/
			idx++;
		      }
		  argmax = esl_vec_FArgMax(cur_paired_marginals, (fullmat->abc->K*fullmat->abc->K));
		  msa->aseq[0][apos]     = RNAPAIR_ALPHABET[argmax];
		  msa->aseq[0][(mate-1)] = RNAPAIR_ALPHABET2[argmax];
		  /*printf("new bp: left: %c right: %c\n", RNAPAIR_ALPHABET[argmax], RNAPAIR_ALPHABET2[argmax]);*/
		}
	    }
	}
	  /* we could still have unambiguous apos, but an ambiguous mate, which we deal
	   * with here: */
	  if(mate != 0)
	{
	  c_m = toupper(msa->aseq[0][(mate-1)]);
	  if(c_m == 'T') c = 'U';
	  cp_m = strchr(rna_string, c_m);
	  if(cp_m == NULL)
	    {
	      /* mate is ambiguous */
	      if((cp_m = strchr(degen_string, c_m)) == NULL) ESL_XEXCEPTION(eslEINVAL, "character is not ACGTU or a recognized ambiguity code");
	      dpos_m = cp_m - degen_string;
	      /*printf("\nCASE 3 PAIR, LEFT NOT, RIGHT AMBIG\n");
		printf("left (apos) %d c: %c mate %d c_m: %c dpos_m\n", apos, c, (mate-1), c_m, dpos);*/
	      cp = strchr(rna_string, c);
	      if(cp == NULL) ESL_XEXCEPTION(eslEINVAL, "character is not ACGTU or a recognized ambiguity code");
	      dpos = cp - rna_string;
	      idx = 0;
	      for(i = 0; i < (fullmat->abc->K); i++)
		for(j = 0; j < (fullmat->abc->K); j++)
		  {
		    cur_paired_marginals[idx] = (i == dpos) * degen_mx[dpos_m][j] *
		      paired_marginals[idx];
		    /*printf("cur_paired_marginals[idx:%d]: %f\n", idx, cur_paired_marginals[idx]);*/
		    idx++;
		  }
	      argmax = esl_vec_FArgMax(cur_paired_marginals, (fullmat->abc->K*fullmat->abc->K));
	      msa->aseq[0][apos]     = RNAPAIR_ALPHABET[argmax];
	      msa->aseq[0][(mate-1)] = RNAPAIR_ALPHABET2[argmax];
	      /*printf("new bp: left: %c right: %c\n", RNAPAIR_ALPHABET[argmax], RNAPAIR_ALPHABET2[argmax]);*/
	    }
	}
	}
  /* go through the sequence again, there should be no ambiguities now */
  for(apos = 0; apos < msa->alen; apos++) {
	if(esl_abc_CIsGap(msa_abc, msa->aseq[0][apos])) continue;
	c = toupper(msa->aseq[0][apos]);
	if(c == 'T') c = 'U';
	cp = strchr(rna_string, c);
	if(cp == NULL) ESL_XEXCEPTION(eslEINVAL, "ribosum_MSA_resolve_degeneracies(), second pass check character %d (%c) is still ambiguous!\n", apos, c);
  }

  if((status = esl_msa_Digitize(msa_abc, msa, NULL)) != eslOK) goto ERROR;
  free(unpaired_marginals);
  free(paired_marginals);
  free(cur_unpaired_marginals);
  free(cur_paired_marginals);
  for(i = 0; i < 12; i++) free(degen_mx[i]);
  free(degen_mx);
  free(ct);
  free(aseq);

  return eslOK;

 ERROR:
  return eslEINVAL;
}

/*
 * Maps i as follows:
 * 0->A
 * 1->C
 * 2->G
 * 3->U
 * else->-1
 */
int unpaired_res (int i)
{
  switch (i) {
  case 0:
	return ('A');
  case 1:
	return ('C');
  case 2:
	return ('G');
  case 3:
	return ('U');
  }
  return (-1);
}

/*** End of inlined file: rnamat.c ***/


/*** Start of inlined file: stats.c ***/

#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <ctype.h>
#include <string.h>


int debug_print_expinfo_array(CM_t *cm, char *errbuf, ExpInfo_t **expA)
{
  int status;
  char *namedashes;
  int ni;
  int namewidth = strlen(cm->name);
  ESL_ALLOC(namedashes, sizeof(char) * namewidth+1);
  namedashes[namewidth] = '\0';
  for(ni = 0; ni < namewidth; ni++) namedashes[ni] = '-';

  if(expA != NULL) {
	printf("cm_lc  exp tail:\t");
	debug_print_expinfo(expA[EXP_CM_LC]);
	printf("cm_gc  exp tail:\t");
	debug_print_expinfo(expA[EXP_CM_GC]);
	printf("cm_li  exp tail:\t");
	debug_print_expinfo(expA[EXP_CM_LI]);
	printf("cm_gi  exp tail:\t");
	debug_print_expinfo(expA[EXP_CM_GI]);
	printf("\n\n");
  }
  free(namedashes);
  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "Memory allocation error in debug_print_expinfo_array().");
  return status; /* NEVERREACHED */
}

/* Function: debug_print_expinfo
 */
int debug_print_expinfo(ExpInfo_t *exp)
{
  if(exp->is_valid) printf("cur_eff_dbsize: %f lambda: %f mu_extrap: %f mu_orig: %f dbsize: %.0f nrandhits: %d tailp: %f (valid)\n", exp->cur_eff_dbsize, exp->lambda, exp->mu_extrap, exp->mu_orig, exp->dbsize, exp->nrandhits, exp->tailp);
  else              printf("invalid (not yet set)\n");
  fflush(stdout);
  return eslOK;
}

/* Function: get_gc_comp
 * Date:     EPN, Tue Aug  7 08:51:06 2007
 * Purpose:  Given a sequence and start and stop coordinates, returns
 *           integerized GC composition of the region. This Easelfied
 *           version replaces RSEARCH's version.
 */
int get_gc_comp(const ESL_ALPHABET *abc, ESL_DSQ *dsq, int start, int stop)
{
  int status;
  int i;
  float *ct = NULL;
  float  gc;

  /* contract check */
  if(abc == NULL) cm_Fail("get_gc_comp alphabet is NULL.");
  if(dsq == NULL) cm_Fail("get_gc_comp dsq is NULL.");
  if(abc->type != eslRNA && abc->type != eslDNA)  cm_Fail("get_gc_comp expects alphabet of RNA or DNA");

  if (start > stop) {
	i = start;
	start = stop;
	stop = i;
  }
  ESL_ALLOC(ct, sizeof(float) * abc->K);
  esl_vec_FSet(ct, abc->K, 0.);
  for (i = start; i <= stop; i++)
  {
	if(esl_abc_XIsGap(abc, dsq[i])) cm_Fail("in get_gc_comp, res %d is a gap!\n", i);
	esl_abc_FCount(abc, ct, dsq[i], 1.);
  }
  gc = ct[abc->inmap[(int) 'G']] + ct[abc->inmap[(int) 'C']];
  gc /= ((float) (stop-start+1));
  gc *= 100.;
  free(ct);
  return (int) (gc + 0.5);

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0; /* never reached */
}

/* Function: get_alphabet_comp
 * Date:     EPN, Wed May  7 18:39:28 2008
 * Purpose:  Given a sequence and start and stop coordinates, allocate and fill
 *           a abc->K sized vector with frequency of each residue.
 */
int get_alphabet_comp(const ESL_ALPHABET *abc, ESL_DSQ *dsq, int start, int stop, float **ret_freq)
{
  int status;
  int i;
  float *freq;

  ESL_ALLOC(freq, sizeof(float) * abc->K);
  esl_vec_FSet(freq, abc->K, 0.0);

  /* contract check */
  if(abc == NULL) cm_Fail("get_alphabet_comp alphabet is NULL.");
  if(dsq == NULL) cm_Fail("get_alphabet_comp dsq is NULL.");
  if(abc->type != eslRNA && abc->type != eslDNA)  cm_Fail("get_alphabet_comp expects alphabet of RNA or DNA");
  if(ret_freq == NULL) cm_Fail("get_alphabet_comp ret_freq is NULL.");

  if (start > stop) {
	i = start;
	start = stop;
	stop = i;
  }
  for (i = start; i <= stop; i++)
  {
	if(esl_abc_XIsGap(abc, dsq[i])) cm_Fail("in get_alphabet_comp, res %d is a gap!\n", i);
	esl_abc_FCount(abc, freq, dsq[i], 1.);
  }
  esl_vec_FNorm(freq, abc->K);
  *ret_freq = freq;
  return eslOK;

 ERROR:
  cm_Fail("get_alphabet_comp() memory allocation error.");
  return 0; /* never reached */
}

/* Function: GetDBSize()
 *
 * Date:     EPN, Wed Apr  2 16:33:19 2008
 *
 * Purpose:  Given a sequence file ptr, determine the number, and summed
 *           size of the seqs in the file.
 *
 * Args:     sqfp          - open sequence file
 *           errbuf        - for writing error messages
 *           ret_N         - RETURN: total length (residues) or all seqs in sqfp
 *           ret_nseq      - RETURN: number of seqs in sqfp
 *           ret_namewidth - RETURN: max length of name in sqfp
 *
 * Returns:  eslOK on success, other status on failure, errbuf filled with error message.
 */
int GetDBSize (ESL_SQFILE *sqfp, char *errbuf, long *ret_N, int *ret_nseq, int *ret_namewidth)
{
  int     status;
  ESL_SQ *sq;
  long    N = 0;
  int     namewidth = 11; /* length of "target name" */
  int     nseq = 0;

  sq = esl_sq_Create();

  while ((status = esl_sqio_ReadInfo(sqfp, sq)) == eslOK) {
	N += sq->L;
	namewidth = ESL_MAX(namewidth, strlen(sq->name));
	esl_sq_Reuse(sq);
	nseq++;
  }
  if (status != eslEOF) {
	ESL_FAIL(status, errbuf, "Parse failed, file %s:\n%s",
	     sqfp->filename, esl_sqfile_GetErrorBuf(sqfp));
  }
  esl_sq_Destroy(sq);
  esl_sqfile_Position(sqfp, (off_t) 0); /* rewind sequence file to beginning */

  if(ret_N != NULL)          *ret_N         = N;
  if(ret_nseq != NULL)       *ret_nseq      = nseq;
  if(ret_namewidth != NULL)  *ret_namewidth = namewidth;
  return eslOK;
}

/* Function: GetDBInfo()
 *
 * Date:     Easelification: EPN, Thu Dec  7 06:07:58 2006
 *           (initial - RSEARCH::get_dbinfo()) RJK, Thu Apr 11, 2002 [St. Louis]
 *
 * Purpose:  Given a sequence file name, determine the total size of the
 *           seqs in the file (DB) and GC content information.
 *
 * Args:     abc       - alphabet for sq file
 *           sqfp      - open sequence file
 *           errbuf    - for error messages
 *           ret_N     - RETURN: total length (residues) or all seqs in seqfile
 *           ret_nseq  - RETURN: number of seqs in seqfile
 *           ret_gc_ct - RETURN: gc_ct[x] observed 100-nt segments with GC% of x [0..100]
 *
 * Returns:  eslOK on success, other status on failure, errbuf filled with error message.
 */
int GetDBInfo (const ESL_ALPHABET *abc, ESL_SQFILE *sqfp, char *errbuf, long *ret_N, int *ret_nseq, double **ret_gc_ct)
{
  int               status;
  ESL_SQ           *sq;
  int               i, j, jp;
  long              N = 0;
  double           *gc_ct;
  int               gc;
  int               nseq = 0;
  int               all_ambig_flag; /* used to check if curr DB chunk is all ambiguous characters
				     * usually Ns, if it is, we don't count it towards the GC content info */
  if (abc       == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "GetDBInfo(), abc is NULL\n");
  if (ret_gc_ct == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "GetDBInfo(), ret_gc_ct is NULL\n");

  ESL_ALLOC(gc_ct, sizeof(double) * GC_SEGMENTS);
  for (i=0; i<GC_SEGMENTS; i++) gc_ct[i] = 0.;

  sq = esl_sq_CreateDigital(abc);
  esl_sqfile_SetDigital(sqfp, abc);

  while ((status = esl_sqio_Read(sqfp, sq)) == eslOK) {
	nseq++;
	N += sq->n;
	/*printf("new N: %d\n", N);*/
	for(i = 1; i <= sq->n; i += 100) {
	  j = (i+99 <= sq->n) ? i+99 : sq->n;
	  gc = get_gc_comp(abc, sq->dsq, i, j);
	  all_ambig_flag = TRUE;
	  for(jp = 0; jp < 100 && (jp+i) < sq->n; jp++) {
	if(sq->dsq[i+jp] < abc->K) {
	  all_ambig_flag = FALSE;
	  break;
	}
	  }
	  /*printf("N: %d i: %d gc: %d\n", N, i, gc);*/
	  /* don't count GC content of chunks < 20 nt, very hacky;
	   * don't count GC content of chunks that are all N, this
	   * will be common in RepeatMasked genomes where poly-Ns could
	   * skew the base composition stats of the genome */
	  if(j > 20 && !all_ambig_flag)
	{
	  /*printf("j: %d i: %d adding 1 to gc_ct[%d]\n", j, i, ((int) gc));*/
	  gc_ct[(int) gc] += 1.;
	}
	}
	esl_sq_Reuse(sq);
  }
  if (status != eslEOF)
	ESL_FAIL(status, errbuf, "Parse failed, file %s:\n%s",
	     sqfp->filename, esl_sqfile_GetErrorBuf(sqfp));
  esl_sq_Destroy(sq);
  esl_sqfile_Position(sqfp, (off_t) 0);

  if(ret_N != NULL)      *ret_N     = N;
  if(ret_nseq != NULL)   *ret_nseq  = nseq;
  *ret_gc_ct = gc_ct;

  return eslOK;

 ERROR:
  ESL_FAIL(status, errbuf, "GetDBInfo(): memory allocation error.");
}

/* Function: E2ScoreGivenExpInfo()
 * Date:     EPN, Thu Apr  3 15:57:34 2008
 *
 * Purpose:  Given an E-value <E> and a exp tail stat structure
 *           determine the bit score that will give an E-value
 *           of <E>.
 *
 * Returns:  eslOK on success, <ret_sc> filled with bit score
 *           error code on failure, errbuf filled with message
 */
int E2ScoreGivenExpInfo(ExpInfo_t *exp, char *errbuf, double E, float *ret_sc)
{
  float sc;
  /* contract checks */
  if(ret_sc == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "E2ScoreGivenExpInfo, ret_sc is NULL");
  sc  = exp->mu_extrap + ((log(E/exp->cur_eff_dbsize)) / (-1 * exp->lambda));
  *ret_sc = sc;
  return eslOK;
}

/* Function: P2ScoreGivenExpInfo()
 * Date:     EPN, Sun Mar 18 10:58:17 2012
 *
 * Purpose:  Given a P-value <P> <E> and a exp tail stat structure
 *           determine the bit score that will give a P-value
 *           of <P>.
 *
 * Returns:  eslOK on success, <ret_sc> filled with bit score
 *           error code on failure, errbuf filled with message
 */
int P2ScoreGivenExpInfo(ExpInfo_t *exp, char *errbuf, double P, float *ret_sc)
{
  float sc;
  /* contract checks */
  if(ret_sc == NULL) ESL_FAIL(eslEINCOMPAT, errbuf, "P2ScoreGivenExpInfo, ret_sc is NULL");
  sc  = exp->mu_extrap + (log(P) / (-1 * exp->lambda));
  *ret_sc = sc;
  return eslOK;
}

/* Function: Score2E()
 * Date:     EPN, Fri Feb 15 12:40:21 2008
 *
 * Purpose:  Given a bit score <x>, a mu and lambda that describe
 *           an exponential tail distribution, and an effective
 *           database size, return the E-value of <sc>.
 *
 * Returns:  E value of <x>
 */
double Score2E (float x, double mu, double lambda, double eff_dbsize)
{
  return esl_exp_surv(x, mu, lambda) * eff_dbsize;
}

/* Function: cm_p7_E2Score()
 * Date:     EPN, Tue Apr 17 14:46:51 2012
 *
 * Purpose:  Given an E-value <E>, a database size in residues <Z>, a
 *           fixed hit length <hitlen>, and a mu and lambda for a
 *           P7_HMM, determine the bit score that will give an E-value
 *           of <E>. This function computes the E-value the same way
 *           nhmmer does, as of svn r3990.
 *
 * Returns:  bit score corresponding to E-value <E>.
 */
float cm_p7_E2Score(double E, double Z, int hitlen, float mu, float lambda)
{
  return mu + ((log(E/(Z / (float) hitlen))) / (-1 * lambda));
}

/* Function: cm_p7_P2Score()
 * Date:     EPN, Tue Apr 17 14:46:51 2012
 *
 * Purpose:  Given a P value and a mu and lambda for a
 *           P7_HMM, determine the bit score that corresponds with
 *           that P value.
 *
 * Returns:  bit score corresponding to P-value <P>.
 */
float cm_p7_P2Score(double P, float mu, float lambda)
{
  return mu + (log(P) / (-1 * lambda));
}

/* Function: ExpModeIsLocal()
 * Date:     EPN, Mon Dec 10 09:07:59 2007
 * Purpose:  Given a exp tail mode, return TRUE if it corresponds to
 *           a local model configuration.
 *
 * Args:     exp_mode     - the mode 0..EXP_NMODES-1
 */
int
ExpModeIsLocal(int exp_mode)
{
  ESL_DASSERT1((exp_mode >= 0 && exp_mode < EXP_NMODES));

  switch (exp_mode) {
  case EXP_CM_LC:
  case EXP_CM_LI:
	return TRUE;
	break;
  case EXP_CM_GC:
  case EXP_CM_GI:
	return FALSE;
	break;
  default:
	cm_Fail("ExpModeIsLocal(): bogus exp_mode: %d\n", exp_mode);
  }
  return FALSE; /* never reached */
}

/* Function: ExpModeIsInside()
 * Date:     EPN, Mon Dec 10 09:11:55 2007
 * Purpose:  Given a exp tail mode, return TRUE if it corresponds to
 *           Inside, false if it corresponds to Inside.
 *
 * Args:     exp_mode  - the mode 0..EXP_NMODES-1
 */
int
ExpModeIsInside(int exp_mode)
{
  ESL_DASSERT1((exp_mode >= 0 && exp_mode < EXP_NMODES));

  switch (exp_mode) {
  case EXP_CM_LI:
  case EXP_CM_GI:
	return TRUE;
	break;

  case EXP_CM_LC:
  case EXP_CM_GC:
	return FALSE;
	break;

  default:
	cm_Fail("ExpModeIsInside(): bogus exp_mode: %d\n", exp_mode);
  }
  return FALSE; /* never reached */
}

/* Function: CreateExpInfo()
 * Date:     EPN, Tue Dec 11 05:25:06 2007
 *
 * Purpose:  Allocate and minimally initialize a exp tail info object.
 *
 * Returns:  Newly allocated ExpInfo_t object on success, NULL if some error occurs
 */
ExpInfo_t *
CreateExpInfo()
{
  int status;

  ExpInfo_t *exp = NULL;
  ESL_ALLOC(exp, sizeof(ExpInfo_t));

  exp->cur_eff_dbsize = 0.;
  exp->lambda         = 0.;
  exp->mu_extrap      = 0.;
  exp->mu_orig        = 0.;
  exp->dbsize         = 0;
  exp->nrandhits      = 0;
  exp->tailp          = 0.;

  exp->is_valid = FALSE;
  return exp;

 ERROR:
  return NULL; /* reached if memory error */
}

/* Function: SetExpInfo()
 * Date:     EPN, Wed Dec 12 13:43:36 2007
 *
 * Purpose:  Set parameters of a exp tail info object and raise it's is_valid 'flag'.
 *
 * Returns:  void
 */
void
SetExpInfo(ExpInfo_t *exp, double lambda, double mu_orig, double dbsize, int nrandhits, double tailp)
{
  exp->lambda    = lambda;
  exp->mu_orig   = mu_orig;
  exp->dbsize    = dbsize;
  exp->nrandhits = nrandhits;
  exp->tailp     = tailp;

  exp->mu_extrap = exp->mu_orig - log(1./exp->tailp) / exp->lambda;

  /* initialize exp->cur_eff_dbsize as effective database size as exp->nrandhits, this is
   * effective database size if we searched a database of size <exp->dbsize>, which we
   * just calibrated for. we'll update this in cmsearch for the target database size. */
  exp->cur_eff_dbsize = (double) exp->nrandhits;

  exp->is_valid  = TRUE; /* we can now write Exp Info to a cm file */
  return;
}

/* Function: DuplicateExpInfo()
 * Date:     EPN, Tue Dec 11 05:28:13 2007
 *
 * Purpose:  Duplicate a exp tail info object.
 *
 * Returns:  Newly allocated ExpInfo_t object on success, NULL if some error occurs
 */
ExpInfo_t *
DuplicateExpInfo(ExpInfo_t *src)
{
  int status;

  ExpInfo_t *dest = NULL;
  ESL_ALLOC(dest, sizeof(ExpInfo_t));

  dest->cur_eff_dbsize = src->cur_eff_dbsize;
  dest->lambda         = src->lambda;
  dest->mu_orig        = src->mu_orig;
  dest->mu_extrap      = src->mu_extrap;
  dest->dbsize         = src->dbsize;
  dest->nrandhits      = src->nrandhits;
  dest->tailp          = src->tailp;
  dest->is_valid       = src->is_valid;
  return dest;

 ERROR:
  return NULL; /* reached if memory error */
}

/* Function:  DescribeExpMode()
 * Incept:    EPN, Mon Jan  7 18:04:31 2008
 *
 * Purpose:   Returns the Exp Tail mode in text.
 *            For example, <DescribeExpMode(EXP_CM_GC)>
 *            returns "glocal CM  CYK".
 */
char *
DescribeExpMode(int exp_mode)
{
  switch (exp_mode) {
  case EXP_CM_GC:  return " cm  glc  cyk";
  case EXP_CM_GI:  return " cm  glc  ins";
  case EXP_CM_LC:  return " cm  loc  cyk";
  case EXP_CM_LI:  return " cm  loc  ins";
  default:     return "?";
  }
}

/* Function: UpdateExpsForDBSize()
 * Date:     EPN, Thu Jan 17 09:38:06 2008
 *
 * Purpose:  Update the <cur_eff_dbsize> parameter of the
 *           ExpInfo_t objects in a CM's cm->expA object
 *           to reflect a database of size <dbsize>.
 *
 * Returns:  eslOK on success, other Easel status code on contract
 *           violation with informative error message in errbuf.
 */
int
UpdateExpsForDBSize(CM_t *cm, char *errbuf, double dbsize)
{
  int i;
  /* contract checks */
  if(! (cm->flags & CMH_EXPTAIL_STATS)) ESL_FAIL(eslEINCOMPAT, errbuf, "UpdateExpsForDBSize(), cm does not have Exp stats.");

  for(i = 0; i < EXP_NMODES; i++) {
	cm->expA[i]->cur_eff_dbsize = (dbsize / cm->expA[i]->dbsize) * ((double) cm->expA[i]->nrandhits);
  }

  return eslOK;
}

/* Function: CreateGenomicHMM()
 * Date:     EPN, Tue May 20 17:40:54 2008
 *
 * Purpose: Create the three arrays that make up the parameters of the
 *          fully connected 5 state HMM that emits 'realistic' genomic
 *          sequence for calculating E-value statistics.
 *
 *          The HMM was trained by EM from 30 Mb of 100 Kb chunks of
 *          real genomes of hand selected GC contents (10 Mb each from
 *          Archaea, Bacteria, Eukarya genomes). See
 *          ~nawrockie/notebook/8_0326_inf_default_gc/ for more info.
 *
 *          There were larger HMMs that 'performed' better, but this 5
 *          state guy was a good balance b/t performance and number of
 *          parameters. Performance was judged by how similar the
 *          generated sequence was to the training 30 Mb genomic
 *          sequence.
 *
 *          abc - alphabet, must be eslRNA | eslDNA
 *          errbuf - for error messages
 *          ret_sA  - RETURN: start probabilities [0..nstates-1]
 *          ret_tAA - RETURN: transition probabilities [0..nstates-1][0..nstates-1]
 *          ret_eAA - RETURN: emission probabilities   [0..nstates-1][0..abc->K-1]
 *          ret_nstates - RETURN: number of states (5)
 */
int
CreateGenomicHMM(const ESL_ALPHABET *abc, char *errbuf, double **ret_sA, double ***ret_tAA, double ***ret_eAA, int *ret_nstates)
{
  int      status;
  int      nstates = 5;
  int      i;

  /* contract check, make sure we're in a valid mode */
  if(abc->type != eslRNA && abc->type != eslDNA) ESL_FAIL(eslEINCOMPAT, errbuf, "get_genomic_sequence_from_hmm(), abc is not eslRNA nor eslDNA");

  /* start probabilities */
  double *sA;
  ESL_ALLOC(sA, sizeof(double) * nstates);

  sA[0] = 0.157377049180328;
  sA[1] = 0.39344262295082;
  sA[2] = 0.265573770491803;
  sA[3] = 0.00327868852459016;
  sA[4] = 0.180327868852459;
  esl_vec_DNorm(sA, nstates);

  /* transition probabilities */
  double **tAA;
  ESL_ALLOC(tAA, sizeof(double *) * nstates);
  for(i = 0; i < nstates; i ++) ESL_ALLOC(tAA[i], sizeof(double) * nstates);

  tAA[0][0] = 0.999483637183643;
  tAA[0][1] = 0.000317942006440604;
  tAA[0][2] = 0.000185401071732768;
  tAA[0][3] = 2.60394763669618e-07;
  tAA[0][4] = 1.27593434198113e-05;
  esl_vec_DNorm(tAA[0], nstates);

  tAA[1][0] = 9.76333640771184e-05;
  tAA[1][1] = 0.99980020511745;
  tAA[1][2] = 9.191359010352e-05;
  tAA[1][3] = 7.94413051888677e-08;
  tAA[1][4] = 1.01684870641751e-05;
  esl_vec_DNorm(tAA[1], nstates);

  tAA[2][0] = 1.3223694798182e-07;
  tAA[2][1] = 0.000155642887774602;
  tAA[2][2] = 0.999700615549769;
  tAA[2][3] = 9.15079680034191e-05;
  tAA[2][4] = 5.21013575048369e-05;
  esl_vec_DNorm(tAA[2], nstates);

  tAA[3][0] = 0.994252873563218;
  tAA[3][1] = 0.0014367816091954;
  tAA[3][2] = 0.0014367816091954;
  tAA[3][3] = 0.0014367816091954;
  tAA[3][4] = 0.0014367816091954;
  esl_vec_DNorm(tAA[3], nstates);

  tAA[4][0] = 8.32138798088677e-06;
  tAA[4][1] = 2.16356087503056e-05;
  tAA[4][2] = 6.42411152124459e-05;
  tAA[4][3] = 1.66427759617735e-07;
  tAA[4][4] = 0.999905635460297;
  esl_vec_DNorm(tAA[4], nstates);

  /* emission probabilities */
  double **eAA;
  ESL_ALLOC(eAA, sizeof(double *) * nstates);
  for(i = 0; i < nstates; i ++) ESL_ALLOC(eAA[i], sizeof(double) * abc->K);

  eAA[0][0] = 0.370906566523225;
  eAA[0][1] = 0.129213995153577;
  eAA[0][2] = 0.130511270043053;
  eAA[0][3] = 0.369368168280145;
  esl_vec_DNorm(eAA[0], abc->K);

  eAA[1][0] = 0.305194882571888;
  eAA[1][1] = 0.194580936415687;
  eAA[1][2] = 0.192343972160245;
  eAA[1][3] = 0.307880208852179;
  esl_vec_DNorm(eAA[1], abc->K);

  eAA[2][0] = 0.238484980800698;
  eAA[2][1] = 0.261262845707113;
  eAA[2][2] = 0.261810301531792;
  eAA[2][3] = 0.238441871960397;
  esl_vec_DNorm(eAA[2], abc->K);

  eAA[3][0] = 0.699280575539568;
  eAA[3][1] = 0.00143884892086331;
  eAA[3][2] = 0.00143884892086331;
  eAA[3][3] = 0.297841726618705;
  esl_vec_DNorm(eAA[3], abc->K);

  eAA[4][0] = 0.169064007664923;
  eAA[4][1] = 0.331718611320207;
  eAA[4][2] = 0.33045427183482;
  eAA[4][3] = 0.16876310918005;
  esl_vec_DNorm(eAA[4], abc->K);

  *ret_sA = sA;
  *ret_tAA = tAA;
  *ret_eAA = eAA;
  *ret_nstates = nstates;

  return eslOK;

 ERROR:
  return status;
}

/* Function: SampleGenomicSequenceFromHMM()
 * Date:     EPN, Tue May 20 17:40:54 2008
 *
 * Purpose: Sample a sequence of length L from an HMM. The HMM defined
 *          by three arrays:
 *
 *          sA  - start probabilities [0..nstates-1]
 *          tAA - transition probabilities [0..nstates-1][0..nstates-1]
 *          eAA - emission probabilities   [0..nstates-1][0..abc->K-1]
 *
 *          ret_dsq - the sampled sequence
 */
int
SampleGenomicSequenceFromHMM(ESL_RANDOMNESS *r, const ESL_ALPHABET *abc, char *errbuf, double *sA, double **tAA, double **eAA, int nstates, int L, ESL_DSQ **ret_dsq)
{
  int status;
  ESL_DSQ *dsq = NULL;
  int      si, x;

  ESL_ALLOC(dsq, sizeof(ESL_DSQ) * (L+2));
  dsq[0] = dsq[L+1] = eslDSQ_SENTINEL;

  /* pick initial state to emit from */
  si = esl_rnd_DChoose(r, sA, nstates);
  for (x = 1; x <= L; x++) {
	dsq[x] = esl_rnd_DChoose(r, eAA[si], abc->K); /* emit residue */
	si = esl_rnd_DChoose(r, tAA[si], nstates);    /* make transition */
  }

  *ret_dsq = dsq;
  return eslOK;

 ERROR:
  return status;
}

/* Function: CopyExpInfo()
 * Date:     EPN, Tue May 24 09:59:14 2011
 *
 * Purpose:  Copy an ExpInfo_t object.
 *
 * Returns:  eslOK on success.
 */
int
CopyExpInfo(ExpInfo_t *src, ExpInfo_t *dest)
{
  dest->cur_eff_dbsize = src->cur_eff_dbsize;
  dest->lambda         = src->lambda;
  dest->mu_extrap      = src->mu_extrap;
  dest->mu_orig        = src->mu_orig;
  dest->dbsize         = src->dbsize;
  dest->nrandhits      = src->nrandhits;
  dest->tailp          = src->tailp;
  dest->is_valid       = src->is_valid;

  return eslOK;
}

/*** End of inlined file: stats.c ***/


/*** Start of inlined file: truncyk.c ***/
/************************************************************
 *
 * truncyk external API:
 *
 * TrCYK_DnC()          - Divide and conquer
 * TrCYK_Inside()       - Inside with or without traceback
 *
 ************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*
struct deckpool_s {
   float ***pool;
   int      n;
   int      nalloc;
   int      block;
};
*/

/* Structure: AlphaMats_t */
typedef struct alphamats_s {
   float ***J;
   float ***L;
   float ***R;
   float ***T;
} AlphaMats_t;

/* structure: BetaMats_t */
typedef struct betamats_s {
   float ***J;
   float  **L;
   float  **R;
   /* no T because T only applies at bifurcations, and beta/outside is only calculated on unbifurcated subgraphs */
} BetaMats_t;

/* Structure: ShadowMats_t */
typedef struct shadowmats_s {
   void ***J;
   void ***L;
   void ***Lmode;
   void ***R;
   void ***Rmode;
   void ***T;
} ShadowMats_t;

/* Divide and conquer */
float tr_generic_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
						  int r, int vend, int i0, int j0,
						  int r_allow_J, int r_allow_L, int r_allow_R);
float   tr_wedge_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
						  int r, int z,    int i0, int j0,
						  int r_allow_J, int r_allow_L, int r_allow_R);
void        tr_v_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
						  int r, int z,    int i0, int i1, int j1, int j0,
						  int useEL, int r_allow_J, int r_allow_L, int r_allow_R,
						  int z_allow_J, int z_allow_L, int z_allow_R);

/* Alignment engines */
/* trinside is legacy, aviod use! */
float trinside (CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
				void ****ret_shadow, void ****ret_L_shadow, void ****ret_R_shadow,
				void ****ret_T_shadow, void ****ret_Lmode_shadow, void ****ret_Rmode_shadow,
				int *ret_mode, int *ret_v, int *ret_i, int *ret_j);
float tr_inside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
				int allow_begin, int r_allow_J, int r_allow_L, int r_allow_R, int lenCORREX,
				AlphaMats_t *arg_alpha, AlphaMats_t *ret_alpha,
				struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
				ShadowMats_t *ret_shadow, int *ret_mode, int *ret_v, int *ret_i, int *ret_j);
float tr_outside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
				 int r_allow_J, int r_allow_L, int r_allow_R,
				 BetaMats_t *arg_beta, BetaMats_t *ret_beta,
				 struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
				 int *ret_mode, int *ret_v, int *ret_j);
float tr_vinside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int z, int i0, int i1, int j1, int j0,
				 int useEL, int do_full, int allow_begin,
				 int r_allow_J, int r_allow_L, int r_allow_R,
				 int z_allow_J, int z_allow_L, int z_allow_R,
				 AlphaMats_t *arg_alpha, AlphaMats_t *ret_alpha,
				 struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
				 ShadowMats_t *ret_shadow, int *ret_mode, int *ret_v, int *ret_i, int *ret_j);
void tr_voutside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int z, int i0, int i1, int j1, int j0,
				 int useEL, int do_full, int r_allow_J, int r_allow_L, int r_allow_R,
				 int z_allow_J, int z_allow_L, int z_allow_R, BetaMats_t *arg_beta,
				 BetaMats_t *ret_beta, struct deckpool_s *dpool, struct deckpool_s **ret_dpool);

/* Traceback routine */
float tr_insideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z, int i0, int j0,
				 int r_allow_J, int r_allow_L, int r_allow_R, int lenCORREX);
float tr_vinsideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z,
				  int i0, int i1, int j1, int j0, int useEL,
				  int r_allow_J, int r_allow_L, int r_allow_R,
				  int z_allow_J, int z_allow_L, int z_allow_R);

/* Function: SetMarginalScores_reproduce_i27()
 * Author:   DLK
 *
 * Purpose:  Given an otherwise initialized CM,
 *           set marginalized emission score vectors.
 *           Requires cm->abc and cm->esc.
 *
 *           EPN, Thu Aug 25 09:21:13 2011
 *           This function contains an unfixed version of bug i27 from
 *           BUGTRAX in that it calls
 *           LeftMarginalScore_reproduce_i27 and
 *           RightMarginalScore_reproduce_i27. See those functions
 *           below for more information.
 *
 * Args:     cm
 *
 * Returns:  none (cm is modified)
 */
void
SetMarginalScores_reproduce_i27(CM_t *cm)
{
   int i,v;

   cm->lmesc  = malloc(sizeof(float *) * (cm->M));
   cm->rmesc  = malloc(sizeof(float *) * (cm->M));
   cm->ilmesc = malloc(sizeof(float *) * (cm->M));
   cm->irmesc = malloc(sizeof(float *) * (cm->M));

   cm->lmesc[0] = malloc(sizeof(float) * (cm->M*cm->abc->Kp));
   cm->rmesc[0] = malloc(sizeof(float) * (cm->M*cm->abc->Kp));

   for (v = 0; v < cm->M; v++)
   {
	  cm->lmesc[v] = cm->lmesc[0] + v*cm->abc->Kp;
	  cm->rmesc[v] = cm->rmesc[0] + v*cm->abc->Kp;

	  if (cm->sttype[v] == MP_st)
		 for (i = 0; i < cm->abc->Kp; i++)
		 {
	   cm->lmesc[v][i] =  LeftMarginalScore_reproduce_i27(cm->abc, cm->esc[v], i);
	   cm->rmesc[v][i] = RightMarginalScore_reproduce_i27(cm->abc, cm->esc[v], i);
		 }
	   else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st)
		 for (i = 0; i < cm->abc->Kp; i++)
		 {
			cm->lmesc[v][i] = cm->esc[v][i];
			cm->rmesc[v][i] = 0.0;
		 }
	   else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)
		 for (i = 0; i < cm->abc->Kp; i++)
		 {
			cm->lmesc[v][i] = 0.0;
			cm->rmesc[v][i] = cm->esc[v][i];
		 }
	   else
		 for (i = 0; i < cm->abc->Kp; i++)
		 {
			cm->lmesc[v][i] = 0.0;
			cm->rmesc[v][i] = 0.0;
		 }
   }

   return;
}

/* Function: LeftMarginalScore_reproduce_i27()
 * Author:   DLK
 *
 * Purpose:  Calculate marginal probability for left half
 *           of an emission pair.  Implicitly assumes
 *           a uniform background distribution
 *
 *           EPN, Thu Aug 25 09:20:32 2011 This function contains an
 *           unfixed version of bug i27 from BUGTRAX. The esc vector
 *           is log_2 odds scores but esl_vec_FLogSum() works in log
 *           base e, therefore the scores returned from this function
 *           were wrong and corresponded to emission probabilities
 *           that do not sum to 1.0 across the canonical residues of
 *           the alphabet (when called successively for
 *           dres=0..abc->K-1).  I left this in to allow reproduction
 *           of the benchmark from Kolbe, Eddy 2009 paper on truncated
 *           CYK, the code for which included this bug. The fixed
 *           version is now incorporated into CMLogoddsify, which now
 *           calculates marginal scores and thus removes the need for
 *           this function.
 */
float
LeftMarginalScore_reproduce_i27(const ESL_ALPHABET *abc, float *esc, ESL_DSQ dres)
{
   float *left = NULL;
   int status;
   ESL_ALLOC(left,  (sizeof(float) * (abc->K+1)));
   int i;
   float sc;

   if (dres < abc->K)
   {
	 sc = esl_vec_FLogSum(&(esc[dres*abc->K]),abc->K);
	 sc -= sreLOG2(abc->K);
   }
   else /* degenerate */
   {
	  esl_vec_FSet(left, abc->K, 0.);
	  esl_abc_FCount(abc, left, dres, 1.);

	  sc = 0.;
	  for (i = 0; i < abc->K; i++)
	  {
	sc += esl_vec_FLogSum(&(esc[i*abc->K]),abc->K)*left[i];
	sc -= sreLOG2(abc->K)*left[i];
	  }
   }

   free(left);

   return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.0; /* never reached */
}

/* Function: RightMarginalScore_reproduce_i27()
 * Author:   DLK
 *
 * Purpose:  Calculate marginal probability for right half
 *           of an emission pair.  Implicitly assumes
 *           a uniform background distribution.
 *
 *           EPN, Thu Aug 25 09:18:43 2011
 *           This contains bug i27 from BUGTRAX. The esc vector is
 *           log_2 odds scores but esl_vec_FLogSum() works in log base
 *           e, therefore the scores returned from this function were
 *           wrong and corresponded to emission probabilities that do
 *           not sum to 1.0 across the canonical residues of the
 *           alphabet (when called successively for dres=0..abc->K-1).
 *           I left this in to allow reproduction of the benchmark
 *           from Kolbe, Eddy 2009 paper on truncated CYK, the code
 *           for which included this bug. The fixed version is now
 *           incorporated into CMLogoddsify, which now calculates
 *           marginal scores and thus removes the need for this
 *           function.
 */
float
RightMarginalScore_reproduce_i27(const ESL_ALPHABET *abc, float *esc, ESL_DSQ dres)
{
   float *right = NULL;
   int status;
   int i,j;
   float sc;
   float row[abc->K];
   ESL_ALLOC(right, (sizeof(float) * (abc->K+1)));

   if (dres < abc->K)
   {
	  for (i=0; i<abc->K; i++)
		 row[i] = esc[i*abc->K+dres];
	  sc = esl_vec_FLogSum(row,abc->K);
	  sc -= sreLOG2(abc->K);
   }
   else /* degenerate */
   {
	  esl_vec_FSet(right, abc->K, 0.);
	  esl_abc_FCount(abc, right, dres, 1.);

	  sc = 0.;
	  for (i=0; i < abc->K; i++)
	  {
		 for (j=0; j<abc->K; j++)
			row[j] = esc[j*abc->K+dres];
		 sc += esl_vec_FLogSum(row,abc->K)*right[i];
		 sc -= sreLOG2(abc->K)*right[i];
	  }
   }

   free(right);

   return sc;

 ERROR:
  cm_Fail("Memory allocation error.");
  return 0.0; /* never reached */
}

/* Function: TrCYK_DnC()
 * Author:   DLK
 *
 * Purpose:  Divide-and-conquer CYK alignment
 *           for truncated sequences with traceback
 *
 * Args:     cm       - the covariance model
 *           dsq      - the sequence, 1..L
 *           L        - length of the sequence
 *           r        - root of subgraph to align to target subseq (usually 0, the model's root)
 *           i0       - start of target subsequence (usually 1, beginning of dsq)
 *           j0       - end of target subsequence (usually L, end of dsq)
 *           pass_idx - pipeline pass index, tr->pass_idx set as this
 *           do_1p0   - TRUE: behave like the 1.0 version;
 *                      FALSE: be consistent with cm_dpalign_trunc.c functions
 *           ret_tr   - RETURN: traceback (pass NULL if trace isn't wanted)
 *
 * Returns:  score of the alignment in bits
 */
float
TrCYK_DnC(CM_t *cm, ESL_DSQ *dsq, int L, int r, int i0, int j0, int pass_idx, int do_1p0, Parsetree_t **ret_tr)
{
   Parsetree_t *tr;
   int          z;
   float        sc, bsc;
   int          pty_idx; /* index for truncation penalty, determined by pass_idx */

   /* Check input parameters */
   if ( cm->stid[r] != ROOT_S )
   {
	  if (! (cm->flags & CMH_LOCAL_BEGIN)) cm_Die("internal error: we're not in local mode, but r is not root");
	  if ( (cm->stid[r] != MATP_MP) &&
		   (cm->stid[r] != MATL_ML) &&
		   (cm->stid[r] != MATR_MR) &&
		   (cm->stid[r] != BIF_B  )    )  cm_Die("internal error: trying to do a local begin at a non-mainline start");
   }

   /* Create parse tree and initialize */
   tr = CreateParsetree(100);
   tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
   tr->pass_idx = pass_idx;

   if(! do_1p0) InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, i0, j0, 0); /* trcyk 1.0 did not add state 0 */
   z = cm->M-1;

   /* If local begin is known */
   if ( r != 0 )
   {
	  InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, i0, j0, r);
	  z = CMSubtreeFindEnd(cm, r);
   }

   /* Solve by calling tr_generic_splitter() */
   sc = tr_generic_splitter(cm, dsq, L, tr, r, z, i0, j0, TRUE, TRUE, TRUE);

   if(! do_1p0) {
	 /* modify mode of initial node(s) now that we know the mode of the full alignment */
	 if(r == 0) {
	   tr->mode[0] = tr->mode[1];
	 }
	 else {
	   tr->mode[0] = tr->mode[2];
	   tr->mode[1] = tr->mode[2];
	 }
   }

   if(do_1p0) {
	 /* 2.0 instead of 2 to force floating point division, not integer division */
	 /* This is the fragment penalty */
	 bsc = sreLOG2(2.0/(cm->clen*(cm->clen+1)));
	 /* printf("Best truncated score: %.4f (%.4f)\n", sc, (sc+bsc)); */
   }
   else {
	 if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) cm_Die("TrCYK_DnC, unexpected pass idx: %d", pass_idx);
	 bsc = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][tr->state[1]] : cm->trp->g_ptyAA[pty_idx][tr->state[1]];
   }
   tr->trpenalty = bsc;
   sc += bsc;

   if ( ret_tr != NULL ) { *ret_tr = tr; }
   else { FreeParsetree(tr); }

   return sc;
}

/* Function: TrCYK_Inside()
 * Author:   DLK
 *
 * Purpose:  Full CYK alignment for truncated sequences
 *           with traceback
 *
 *           Based on CYKInside()
 *
 * Args:     cm       - the covariance model
 *           dsq      - the sequence, 1..L
 *           L        - length of the sequence
 *           r        - root of subgraph to align to target subseq (usually 0, the model's root)
 *           i0       - start of target subsequence (usually 1, beginning of dsq)
 *           j0       - end of target subsequence (usually L, end of dsq)
 *           pass_idx - pipeline pass index, tr->pass_idx set as this
 *           ret_tr   - RETURN: traceback (pass NULL if trace isn't wanted)
 *
 * Returns;  score of the alignment in bits
 */
float
TrCYK_Inside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int i0, int j0, int pass_idx, int do_1p0, int lenCORREX, Parsetree_t **ret_tr)
{
  Parsetree_t *tr = NULL;
  int          z;
  float        sc, bsc, rsc, nullsc;
  int          pty_idx; /* index for truncation penalty, determined by pass_idx */

  /* Check input parameters */
   if ( cm->stid[r] != ROOT_S )
	 {
	   if (! (cm->flags & CMH_LOCAL_BEGIN)) cm_Die("internal error: we're not in local mode, but r is not root");
	   if ( (cm->stid[r] != MATP_MP) &&
	    (cm->stid[r] != MATL_ML) &&
	    (cm->stid[r] != MATR_MR) &&
	    (cm->stid[r] != BIF_B  )    )  cm_Die("internal error: trying to do a local begin at a non-mainline start");
	 }

   if ( ret_tr != NULL)
	 {
	   /* Create parse tree and initialize */
	   tr = CreateParsetree(100);
	   tr->is_std = FALSE; /* lower is_std flag, now we'll know this parsetree was created by a truncated (non-standard) alignment function */
	   tr->pass_idx = pass_idx;

	   if(! do_1p0) InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, i0, j0, 0); /* trcyk 1.0 did not add state 0 */
	   z = cm->M-1;

	   /* If local begin is known */
	   if ( r != 0 )
	 {
	   InsertTraceNode(tr, -1, TRACE_LEFT_CHILD, i0, j0, r);
	   z = CMSubtreeFindEnd(cm, r);
	 }

	   /* Solve by calling tr_insideT() */
	   sc = tr_insideT(cm, dsq, L, tr, r, z, i0, j0, TRUE, TRUE, TRUE, lenCORREX);

	   if(! do_1p0) {
	 /* modify mode of initial node(s) now that we know the mode of the full alignment */
	 if(r == 0) {
	   tr->mode[0] = tr->mode[1]; /* modify mode of first trace node now that we know the mode of the full alignment */
	 }
	 else {
	   tr->mode[0] = tr->mode[2];
	   tr->mode[1] = tr->mode[2];
	 }
	   }
	 }
   else
	 {
	   z = (r == 0) ? cm->M-1 : CMSubtreeFindEnd(cm, r);
	   sc = tr_inside(cm, dsq, L, r, z, i0, j0, BE_EFFICIENT,
		      TRUE, TRUE, TRUE, TRUE, lenCORREX,
		      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	 }

   if(do_1p0) {
	 /* 2.0 instead of 2 to force floating point division, not integer division */
	 /* This is the fragment penalty */
	 bsc = sreLOG2(2.0/(cm->clen*(cm->clen+1)));
	 /* printf("Best truncated score: %.4f (%.4f)\n", sc, (sc+bsc)); */
   }
   else {
	 if((pty_idx = cm_tr_penalties_IdxForPass(pass_idx)) == -1) cm_Die("TrCYK_DnC, unexpected pass idx: %d", pass_idx);
	 bsc = (cm->flags & CMH_LOCAL_BEGIN) ? cm->trp->l_ptyAA[pty_idx][tr->state[1]] : cm->trp->g_ptyAA[pty_idx][tr->state[1]];
   }
   if(tr != NULL) tr->trpenalty = bsc;

   /* null model length correction */
   if (lenCORREX)
   {
	  rsc = (float) L/(float) (L+1);
	  nullsc = L*sreLOG2(rsc) + sreLOG2(1 - rsc);
	  sc -= nullsc;
   }
   sc += bsc;

   if ( ret_tr != NULL ) *ret_tr = tr;
   else if(tr != NULL) { FreeParsetree(tr); }

   return sc;
}

/* Function: tr_generic_splitter()
 * Author:   DLK
 *
 * Purpose:  Generic problem for divide-and-conquer
 *           Based closely on generic_splitter()
 *
 * Args:
 *
 * Returns:
 */
float
tr_generic_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
					int r, int z, int i0, int j0,
					int r_allow_J, int r_allow_L, int r_allow_R)
{
   AlphaMats_t *alpha;
   BetaMats_t  *beta;
   struct deckpool_s *pool;
   int        v,w,y;
   int        wend, yend;
   int        tv;
   int        jp;
   int        W;
   float      sc;
   int        j,d,k;
   float      best_sc;
   int        best_j, best_d, best_k;
   int        v_mode, w_mode, y_mode;
   int        b1_mode, b2_mode, b3_mode;
   int        b1_v, b1_i, b1_j;
   int        b2_v, b2_i, b2_j;
   int        b3_v, b3_j;
   float      b1_sc, b2_sc, b3_sc;
   int        useEL;

   int        v_allow_T = FALSE;

   if (r == 0) v_allow_T = TRUE;
   if (!r_allow_J && !r_allow_L && !r_allow_R) v_allow_T = TRUE;

   /* Case 1: problem size is small; solve with tr_insideT()
	* size calculation is heuristic based on size of insideT() */
   if (5*insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT)
   {
	  sc = tr_insideT(cm, dsq, L, tr, r, z, i0, j0, r_allow_J, r_allow_L, r_allow_R, FALSE);
	  return sc;
   }

   /* Case 2: find a bifurcation */
   for (v = r; v <= z-5; v++)
   {  if (cm->sttype[v] == B_st) break; }

   /* Case 3: no bifurcations -> wedge problem */
   if (cm->sttype[v] != B_st)
   {
	  if (cm->sttype[z] != E_st) cm_Die("z in tr_generic_splitter not E_st - that ain't right");
	  sc = tr_wedge_splitter(cm, dsq, L, tr, r, z, i0, j0, r_allow_J, r_allow_L, r_allow_R);
	  return sc;
   }

   alpha = malloc(sizeof(AlphaMats_t));
   beta  = malloc(sizeof(BetaMats_t));

   /* Unusual cases dispatched, back to case 2 (bifurcation) */
   w = cm->cfirst[v];
   y = cm->cnum[v];
   if (w < y) { wend = y-1; yend = z; }
   else       { yend = w-1; wend = z; }

   /* Calculate alphas for w and y
	* also pick up best local begins in each subtree */
   b1_sc = tr_inside(cm, dsq, L, w, wend, i0, j0, BE_EFFICIENT,
					 (r == 0), TRUE, r_allow_L, r_allow_R, FALSE,
					 NULL, alpha, NULL, &pool, NULL, &b1_mode, &b1_v, &b1_i, &b1_j);
   if (r != 0) b1_sc = IMPOSSIBLE;
   b2_sc = tr_inside(cm, dsq, L, y, yend, i0, j0, BE_EFFICIENT,
					 (r == 0), TRUE, r_allow_L, r_allow_R, FALSE,
					 alpha, alpha, pool,  NULL, NULL, &b2_mode, &b2_v, &b2_i, &b2_j);
   if (r != 0) b2_sc = IMPOSSIBLE;

   /* Calculate beta; release pool */
   b3_sc = tr_outside(cm, dsq, L, r, v, i0, j0, BE_EFFICIENT,
					  r_allow_J, r_allow_L, r_allow_R,
					  NULL, beta, NULL, NULL, &b3_mode, &b3_v, &b3_j);

   /* OK, to the point of actually finding the best split
	* We have a lot more types of splits than the non-truncated
	* version, so we need a better way to keep track of them    */
   W = j0 - i0 + 1;
   best_sc = IMPOSSIBLE;
   for (jp = 0; jp <= W; jp ++)
   {
	  j = i0 - 1 + jp;
	  for (d = 0; d <= jp; d++)
	  {
		 for (k = 0; k <= d; k++)
		 {
			/* Attempted bug fix cases  - these cases have priority */
			if ( v_allow_T && k > 0 && k < d)
			if ( (sc = alpha->J[w][j-k][d-k] + alpha->L[y][j][k]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 0; w_mode = 3; y_mode = 2;
			}
			if ( v_allow_T && k > 0 && k < d)
			if ( (sc = alpha->R[w][j-k][d-k] + alpha->J[y][j][k]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 0; w_mode = 1; y_mode = 3;
			}
			if ( (sc = alpha->J[w][j-k][d-k] + alpha->J[y][j][k] + beta->J[v][j][d]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 3; w_mode = 3; y_mode = 3;
			}
			if ( r_allow_L && k > 0 /* && j-d+1 > i0 */ )
			if ( (sc = alpha->J[w][j-k][d-k] + alpha->L[y][j][k] + beta->L[v][j-d+1]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 2; w_mode = 3; y_mode = 2;
			}
			/* Attempted bug fix case */
			if ( r_allow_L && k > 0 )
			if ( (sc = alpha->J[w][j-k][d-k] + alpha->J[y][j][k] + beta->L[v][j-d+1]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 2; w_mode = 3; y_mode = 3;
			}
			/* j < j0 test causes problems if there are no R emitters between r and v */
			if ( r_allow_R && k < d /* && j < j0*/ )
			if ( (sc = alpha->R[w][j-k][d-k] + alpha->J[y][j][k] + beta->R[v][j]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 1; w_mode = 1; y_mode = 3;
			}
			/* Attempted bug fix case */
			if ( r_allow_R && k < d )
			if ( (sc = alpha->J[w][j-k][d-k] + alpha->J[y][j][k] + beta->R[v][j]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 1; w_mode = 3; y_mode = 3;
			}
			if ( v_allow_T && k > 0 && k < d )
			if ( (sc = alpha->R[w][j-k][d-k] + alpha->L[y][j][k]) > best_sc )
			{
			   best_sc = sc;
			   best_k  = k;
			   best_j  = j;
			   best_d  = d;
			   v_mode = 0; w_mode = 1; y_mode = 2;
			}
		 }

		 if ( r_allow_L )
		 if ( (sc = alpha->L[w][j][d] + beta->L[v][j-d+1]) > best_sc )
		 {
			best_sc = sc;
			best_k  = 0;
			best_j  = j;
			best_d  = d;
			v_mode = 2; w_mode = 2; y_mode = 0;
		 }
		 if ( r_allow_L )
		 if ( (sc = alpha->J[w][j][d] + beta->L[v][j-d+1]) > best_sc )
		 {
			best_sc = sc;
			best_k  = 0;
			best_j  = j;
			best_d  = d;
			v_mode = 2; w_mode = 3; y_mode = 0;
		 }
		 if ( r_allow_R )
		 if ( (sc = alpha->R[y][j][d] + beta->R[v][j]) > best_sc )
		 {
			best_sc = sc;
			best_k  = d;
			best_j  = j;
			best_d  = d;
			v_mode = 1; w_mode = 0; y_mode = 1;
		 }
		 if ( r_allow_R )
		 if ( (sc = alpha->J[y][j][d] + beta->R[v][j]) > best_sc )
		 {
			best_sc = sc;
			best_k  = d;
			best_j  = j;
			best_d  = d;
			v_mode = 1; w_mode = 0; y_mode = 3;
		 }
		 if ( (sc = beta->J[cm->M][j][d]) > best_sc) /* Joint parent to EL */
		 {
			best_sc = sc;
			best_k  = -1;
			best_j  = j;
			best_d  = d;
			v_mode = 3; w_mode = 0; y_mode = 0;
			useEL = TRUE;
		 }
	  }
   }

   /* Check for local entry in one of the child sub-trees */
   if (r == 0)
   {
	  if (b1_sc > best_sc)
	  {
		 best_sc = b1_sc;
		 best_k  = b1_v;
		 best_j  = b1_j;
		 best_d  = b1_j - b1_i + 1;
		 v_mode = 0; w_mode = b1_mode; y_mode = 0;
	  }
	  if (b2_sc > best_sc)
	  {
		 best_sc = b2_sc;
		 best_k  = b2_v;
		 best_j  = b2_j;
		 best_d  = b2_j - b2_i + 1;
		 v_mode = 0; w_mode = 0; y_mode = b2_mode;
	  }
   }

   /* local hit in parent (must be marginal) */
   if (b3_sc > best_sc)
   {
	  best_sc = b3_sc;
	  best_k  = b3_v;
	  best_j  = b3_j;
	  v_mode = b3_mode; w_mode = 0; y_mode = 0;
	  useEL = FALSE;
   }

   /* Free alphas */
   free_vjd_matrix(alpha->J, cm->M, i0, j0);
   free_vjd_matrix(alpha->L, cm->M, i0, j0);
   free_vjd_matrix(alpha->R, cm->M, i0, j0);
   free_vjd_matrix(alpha->T, cm->M, i0, j0);
   free_vjd_matrix( beta->J, cm->M, i0, j0);
   free(beta->L[0]); free(beta->L);
   free(beta->R[0]); free(beta->R);
   free(alpha);
   free(beta);

   /* Found the best path, now to interpret and sub-divide */
   if ( v_mode ) /* parent graph is non-empty */
   {
	  if ( w_mode == TRMODE_T && y_mode == TRMODE_T ) /* local hit in parent (marginal) */
	  {
if (!useEL && b3_v == -1)
cm_Die("1Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, r, (useEL ? v : b3_v), i0, best_j, best_j, j0,
					   useEL, r_allow_J, r_allow_L, r_allow_R, (v_mode == TRMODE_J), (v_mode == TRMODE_L), (v_mode == TRMODE_R));
		 return best_sc;
	  }
	  else
	  {
if (v == -1) cm_Die("2Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, r, v, i0, best_j-best_d+1, best_j, j0,
					   FALSE, r_allow_J, r_allow_L, r_allow_R, (v_mode == TRMODE_J), (v_mode == TRMODE_L), (v_mode == TRMODE_R));
	  }
   }
   else if ( w_mode == TRMODE_T || y_mode == TRMODE_T ) /* local entry to one of the children */
   {
	  if ( b1_sc > b2_sc )
	  {
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, b1_i, b1_j, b1_v, b1_mode);
		 z = CMSubtreeFindEnd(cm, b1_v);
		 tr_generic_splitter(cm, dsq, L, tr, b1_v, z, b1_i, b1_j, (b1_mode == TRMODE_J), (b1_mode == TRMODE_L), (b1_mode == TRMODE_R));
		 return best_sc;
	  }
	  else
	  {
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, b2_i, b2_j, b2_v, b2_mode);
		 z = CMSubtreeFindEnd(cm, b2_v);
		 tr_generic_splitter(cm, dsq, L, tr, b2_v, z, b2_i, b2_j, (b2_mode == TRMODE_J), (b2_mode == TRMODE_L), (b2_mode == TRMODE_R));
		 return best_sc;
	  }
   }
   else /* case T: parent is empty, but both children are non-empty */
   {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, best_j - best_d + 1, best_j, v, 0);
   }

   tv = tr->n - 1;
   if ( w_mode )
   {
	  InsertTraceNodewithMode(tr, tv, TRACE_LEFT_CHILD, best_j - best_d + 1, best_j - best_k, w, w_mode);
	  tr_generic_splitter(cm, dsq, L, tr, w, wend, best_j - best_d + 1, best_j - best_k, (w_mode == TRMODE_J), (w_mode == TRMODE_L), (w_mode == TRMODE_R));   }
   else
   {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, best_j - best_d + 1, best_j - best_d, w, w_mode);
	  /*InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, best_j - best_d + 1, best_j - best_d, cm->M, 3);*/
   }

   if ( y_mode )
   {
	  InsertTraceNodewithMode(tr, tv, TRACE_RIGHT_CHILD, best_j - best_k + 1, best_j, y, y_mode);
	  tr_generic_splitter(cm, dsq, L, tr, y, yend, best_j - best_k + 1, best_j, (y_mode == TRMODE_J), (y_mode == TRMODE_L), (y_mode == TRMODE_R));
   }
   else
   {
	  InsertTraceNodewithMode(tr, tv, TRACE_RIGHT_CHILD, best_j + 1, best_j, y, y_mode);
	  /*InsertTraceNodewithMode(tr, tv, TRACE_RIGHT_CHILD, best_j + 1, best_j, cm->M, 3);*/
   }

   return best_sc;
}

/* Function: tr_wedge_splitter()
 * Author:   DLK
 *
 * Purpose:  Wedge problem for divide-and-conquer
 *           Based closely on wedge_splitter()
 *
 * Args:
 *
 * Returns:
 */
float
tr_wedge_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr,
				  int r, int z, int i0, int j0,
				  int r_allow_J, int r_allow_L, int r_allow_R)
{
   AlphaMats_t *alpha;
   BetaMats_t  *beta;
   float        sc;
   float        best_sc;
   int          v,w,y;
   int          W;
   int          jp, j, d;
   int          best_v, best_j, best_d;
   int          p_mode, c_mode;
   int          midnode;
   float        b1_sc, b2_sc;
   int          b1_mode, b1_v, b1_i, b1_j;
   int          b2_mode, b2_v, b2_j;

   /* Special case: problem is small enough to be solved with traceback */
   if ( (cm->ndidx[z] == cm->ndidx[r] + 1) ||
		(5 * insideT_size(cm, L, r, z, i0, j0) < RAMLIMIT) )
   {
	  sc = tr_insideT(cm, dsq, L, tr, r, z, i0, j0, r_allow_J, r_allow_L, r_allow_R, FALSE);
	  return sc;
   }

   alpha = malloc(sizeof(AlphaMats_t));
   beta  = malloc(sizeof(BetaMats_t));

   /* Calculate a midpoint to split at */
   midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r])/2);
   w = cm->nodemap[midnode];
   y = cm->cfirst[w] - 1;

   /* Get alphas and betas */
   b1_sc = tr_inside(cm, dsq, L, w, z, i0, j0, BE_EFFICIENT,
					 (r == 0), TRUE, r_allow_L, r_allow_R, FALSE,
					 NULL, alpha, NULL, NULL, NULL, &b1_mode, &b1_v, &b1_i, &b1_j);
   if (r != 0) b1_sc = IMPOSSIBLE;
   b2_sc = tr_outside(cm, dsq, L, r, y, i0, j0, BE_EFFICIENT,
			 r_allow_J, r_allow_L, r_allow_R,
			 NULL, beta, NULL, NULL, &b2_mode, &b2_v, &b2_j);
   if ( b2_mode == TRMODE_L && !r_allow_L ) b2_sc = IMPOSSIBLE;
   if ( b2_mode == TRMODE_R && !r_allow_R ) b2_sc = IMPOSSIBLE;

   /* Find the split */
   W = j0 - i0 + 1;
   best_sc = IMPOSSIBLE;

   /* Special case: parent empty, child has local hit */
   if (b1_sc > best_sc)
   {
	  best_sc = b1_sc;
	  best_v  = b1_v;
	  best_j  = b1_j;
	  best_d  = b1_j - b1_i + 1;
	  p_mode = 0; c_mode = b1_mode;
   }

   /* Special case: child empty, parent has local hit */
   /* 1 and 2 are the only appropriate values for b2_mode */
   if (b2_sc > best_sc)
   {
	  best_sc = b2_sc;
	  best_v  = b2_v;
	  best_j  = b2_j;
	  best_d  = 1;
	  p_mode = b2_mode; c_mode = 0;
   }

   /* Standard cases */
   for (v = w; v <= y; v++)
   {
	  for (jp = 0; jp <= W; jp++)
	  {
		 j = i0 - 1 + jp;
		 for (d = 0; d <= jp; d++)
		 {
			if ( (sc = alpha->J[v][j][d] + beta->J[v][j][d]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_d  = d;
			   best_j  = j;
			   p_mode = 3; c_mode = 3;
			}
			if ( r_allow_L )
			if ( (sc = alpha->J[v][j][d] + beta->L[v][j-d+1]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_d  = d;
			   best_j  = j;
			   p_mode = 2; c_mode = 3;
			}
			if ( r_allow_L )
			if ( (sc = alpha->L[v][j][d] + beta->L[v][j-d+1]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_d  = d;
			   best_j  = j;
			   p_mode = 2; c_mode = 2;
			}
			if ( r_allow_R )
			if ( (sc = alpha->J[v][j][d] + beta->R[v][j]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_d  = d;
			   best_j  = j;
			   p_mode = 1; c_mode = 3;
			}
			if ( r_allow_R )
			if ( (sc = alpha->R[v][j][d] + beta->R[v][j]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_d  = d;
			   best_j  = j;
			   p_mode = 1; c_mode = 1;
			}
		 }
	  }
   }

   /* Special case: joint parent to EL */
   for (jp = 0; jp <= W; jp++)
   {
	  j = i0 - 1 + jp;
	  for (d = 0; d <= jp; d++)
	  {
		 if ( (sc = beta->J[cm->M][j][d]) > best_sc )
		 {
			best_sc = sc;
			best_v  = -1;
			best_j  = j;
			best_d  = d;
			p_mode = 3; c_mode = 0;
		 }
	  }
   }

   /* Free alpha and beta */
   free_vjd_matrix(alpha->J, cm->M, i0, j0);
   free_vjd_matrix(alpha->L, cm->M, i0, j0);
   free_vjd_matrix(alpha->R, cm->M, i0, j0);
   free_vjd_matrix(alpha->T, cm->M, i0, j0);
   free_vjd_matrix( beta->J, cm->M, i0, j0);
   free(beta->L[0]); free(beta->L);
   free(beta->R[0]); free(beta->R);
   free(alpha);
   free(beta);

   if ( p_mode )
   {
	  if ( c_mode == TRMODE_T ) /* child empty */
	  {
if ((p_mode == TRMODE_J ? w : b2_v) == -1) cm_Die("3Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, r, (p_mode == TRMODE_J ? w : b2_v), i0, best_j - best_d + 1, best_j, j0,
					   (p_mode == TRMODE_J), r_allow_J, r_allow_L, r_allow_R, (p_mode == TRMODE_J), (p_mode == TRMODE_L), (p_mode == TRMODE_R));
		 return best_sc;
	  }
	  else
	  {
if (best_v == -1) cm_Die("4Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, r, best_v, i0, best_j - best_d + 1, best_j, j0,
					   FALSE, r_allow_J, r_allow_L, r_allow_R, (c_mode == TRMODE_J), (c_mode == TRMODE_L), (c_mode == TRMODE_R));
	  }
   }

   if ( c_mode )
   {
	  if ( p_mode == TRMODE_T )
	  {
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, best_j - best_d + 1, best_j, best_v, c_mode);
	  }
	  tr_wedge_splitter(cm, dsq, L, tr, best_v, z, best_j - best_d + 1, best_j, (c_mode == TRMODE_J), (c_mode == TRMODE_L), (c_mode == TRMODE_R));
   }
   else /* parent and child both empty */
	  cm_Die("Danger, danger! p_mode = %d c_mode = %d\n",p_mode,c_mode);

   return best_sc;
}

/* Function: tr_v_splitter()
 * Author:   DLK
 *
 * Purpose:  'V problem' - closely based on v_splitter()
 *
 * Args:
 *
 * Returns;  none
 */
void
tr_v_splitter(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z, int i0, int i1,
			  int j1, int j0, int useEL, int r_allow_J, int r_allow_L, int r_allow_R,
			  int z_allow_J, int z_allow_L, int z_allow_R)
{
   AlphaMats_t *alpha;
   BetaMats_t  *beta;
   float        sc, best_sc;
   int          v, w, y;
   int          best_v, best_i, best_j;
   int          midnode;
   int          p_mode, c_mode;
   int          jp, ip;
   float        b_sc;
   int          b_mode, b_v, b_i, b_j;

   /* Recommend a special handler for the fully marginal cases (linear alg.)*/
   /*
   if ( force_LM)
   {

   }
   else if ( force_RM )
   {

   }
   */

   /* Special case: solve without splitting for small problems and boundary conditions */
   if (cm->ndidx[z] == cm->ndidx[r] + 1 || r == z ||
	   5*vinsideT_size(cm, r, z, i0, i1, j1, j0) < RAMLIMIT)
   {
	  tr_vinsideT(cm, dsq, L, tr, r, z, i0, i1, j1, j0, useEL,
				  r_allow_J, r_allow_L, r_allow_R, z_allow_J, z_allow_L, z_allow_R);
	  return;
   }

   alpha = malloc(sizeof(AlphaMats_t));
   beta  = malloc(sizeof(BetaMats_t));

   /* Find split set */
   midnode = cm->ndidx[r] + ((cm->ndidx[z] - cm->ndidx[r])/2);
   w = cm->nodemap[midnode];
   y = cm->cfirst[w] - 1;

   /* Calculate alphas and betas */
   b_sc =  tr_vinside(cm, dsq, L, w, z, i0, i1, j1, j0, useEL, BE_EFFICIENT, (r == 0),
					  z_allow_J, r_allow_L, r_allow_R, z_allow_J, z_allow_L, z_allow_R,
					  NULL, alpha, NULL, NULL, NULL, &b_mode, &b_v, &b_i, &b_j);
   if (r != 0) b_sc = IMPOSSIBLE;
   tr_voutside(cm, dsq, L, r, y, i0, i1, j1, j0, useEL, BE_EFFICIENT,
			   r_allow_J, r_allow_L, r_allow_R, z_allow_J, z_allow_L, z_allow_R,
			   NULL, beta, NULL, NULL);

   best_sc = IMPOSSIBLE;

   /* check local begin */
   if (b_sc > best_sc)
   {
	  best_sc = b_sc;
	  best_v  = b_v;
	  best_i  = b_i;
	  best_j  = b_j;
	  p_mode = 0; c_mode = b_mode;
   }

   /* Find our best split */
   for (v = w; v <= y; v++)
   {
	  for (ip = 0; ip <= i1-i0; ip++)
	  {
		 for (jp = 0; jp <= j0-j1; jp++)
		 {
			if ( z_allow_J )
			if ( (sc = alpha->J[v][jp][ip] + beta->J[v][jp][ip]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 3; c_mode = 3;
			}
			if ( z_allow_J && r_allow_L )
			if ( (sc = alpha->J[v][jp][ip] + beta->L[v][ip]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 2; c_mode = 3;
			}
			if ( r_allow_L )
			if ( (sc = alpha->L[v][jp][ip] + beta->L[v][ip]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 2; c_mode = 2;
			}
			if ( z_allow_J && r_allow_R )
			if ( (sc = alpha->J[v][jp][ip] + beta->R[v][jp]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 1; c_mode = 3;
			}
			if ( r_allow_R )
			if ( (sc = alpha->R[v][jp][ip] + beta->R[v][jp]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = v;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 1; c_mode = 1;
			}
		 }
	  }
   }

   /* check EL */
   if ( useEL )
   {
	  for (ip = 0; ip <= i1-i0; ip++)
	  {
		 for (jp = 0; jp <= j0-j1; jp++)
		 {
			if ( (sc = beta->J[cm->M][jp][ip]) > best_sc )
			{
			   best_sc = sc;
			   best_v  = cm->M;
			   best_i  = ip + i0;
			   best_j  = jp + j1;
			   p_mode = 3; c_mode = 0;
			}
		 }
	  }
   }

   /* Free memory */
   free_vji_matrix(alpha->J, cm->M, j1, j0);
   free_vji_matrix(alpha->L, cm->M, j1, j0);
   free_vji_matrix(alpha->R, cm->M, j1, j0);
   free_vji_matrix( beta->J, cm->M, j1, j0);
   free(beta->L[0]); free(beta->L);
   free(beta->R[0]); free(beta->R);
   free(alpha);
   free(beta);

   /* Interpret and subdivide */
   if ( p_mode )
   {
	  if ( c_mode )
	  {
if (best_v == -1) cm_Die("5Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, r, best_v, i0, best_i, best_j, j0,
					   FALSE, r_allow_J, r_allow_L, r_allow_R, (c_mode == TRMODE_J), (c_mode == TRMODE_L), (c_mode == TRMODE_R));
if (z == -1) cm_Die("6Superbad: passing z = -1!\n");
		 tr_v_splitter(cm, dsq, L, tr, best_v, z, best_i, i1, j1, best_j,
					   useEL, (c_mode == TRMODE_J), (c_mode == TRMODE_L), (c_mode == TRMODE_R), z_allow_J, z_allow_L, z_allow_R);
	  }
	  else
	  {
		 tr_v_splitter(cm, dsq, L, tr, r, w, i0, best_i, best_j, j0,
					   TRUE, r_allow_J, r_allow_L, r_allow_R, TRUE, FALSE, FALSE);
	  }
   }
   else
   {
	  if (best_v != z)
	  {
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, best_i, best_j, best_v, c_mode);
	  }
if (z == -1) cm_Die("7Superbad: passing z = -1!\n");
	  tr_v_splitter(cm, dsq, L, tr, best_v, z, best_i, i1, j1, best_j,
					useEL, (c_mode == TRMODE_J), (c_mode == TRMODE_L), (c_mode == TRMODE_R), z_allow_J, z_allow_L, z_allow_R);
   }

   return;
}

/* Legacy wrapper */
float
trinside (CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
		  void ****ret_shadow, void ****ret_L_shadow, void ****ret_R_shadow,
		  void ****ret_T_shadow, void ****ret_Lmode_shadow, void ****ret_Rmode_shadow,
		  int *ret_mode, int *ret_v, int *ret_i, int *ret_j)
{
   float sc;
   ShadowMats_t shadow;

   shadow.J = *ret_shadow;
   shadow.L = *ret_L_shadow;
   shadow.R = *ret_R_shadow;
   shadow.T = *ret_T_shadow;
   shadow.Lmode = *ret_Lmode_shadow;
   shadow.Rmode = *ret_Rmode_shadow;

   sc = tr_inside(cm, dsq, L, vroot, vend, i0, j0, do_full,
				  TRUE, TRUE, TRUE, TRUE, FALSE,
				  NULL, NULL, NULL, NULL, &shadow,
				  ret_mode, ret_v, ret_i, ret_j);
   *ret_shadow = shadow.J;
   *ret_L_shadow = shadow.L;
   *ret_R_shadow = shadow.R;
   *ret_T_shadow = shadow.T;
   *ret_Lmode_shadow = shadow.Lmode;
   *ret_Rmode_shadow = shadow.Rmode;

   return sc;
}

/* Function: tr_inside()
 * Author:   DLK
 *
 * Purpose:  inside phase of CYK on truncated sequence
 *           based on inside()
 *
 *           Score matrices and deckpool are only managed
 *           within this func, not available to caller
 *
 * Args:     cm      - the covariance model
 *           dsq     - the sequence, 1..L
 *           L       - length of the sequence
 *           r       - root of subgraph to align to target subseq (usually 0, the model's root)
 *           z       - last state of the subgraph
 *           i0      - start of target subsequence (usually 1, beginning of dsq)
 *           j0      - end of target subsequence (usually L, end of dsq)
 *           do_full - if TRUE, save all decks rather than re-using
 *
 * Returns:  Score of the optimal alignment
 */
float
tr_inside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
		  int allow_begin, int r_allow_J, int r_allow_L, int r_allow_R, int lenCORREX,
		  AlphaMats_t *arg_alpha, AlphaMats_t *ret_alpha,
		  struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		  ShadowMats_t *ret_shadow, int *ret_mode, int *ret_v, int *ret_i, int *ret_j)
{
   float  **end;
   int      nends;
   int     *touch;
   int      v,y,z;
   int      j,d,i,k;
   float    sc;
   int      yoffset;
   int      W;
   int      jp;
   void  ***shadow;
   void  ***L_shadow;
   void  ***R_shadow;
   void  ***T_shadow;
   int   ***Lmode_shadow;
   int   ***Rmode_shadow;
   int    **kshad;
   char   **yshad;
   int      r_v, r_i, r_j, r_mode;
   float    r_sc;
   float    p1, p2, psc;

   float ***alpha;
   float ***L_alpha;
   float ***R_alpha;
   float ***T_alpha;

   if ( arg_alpha == NULL )
   {
	  alpha = NULL;
	  L_alpha = NULL;
	  R_alpha = NULL;
	  T_alpha = NULL;
   }
   else
   {
		alpha = arg_alpha->J;
	  L_alpha = arg_alpha->L;
	  R_alpha = arg_alpha->R;
	  T_alpha = arg_alpha->T;
   }

   /*Initialization */
   r_v = -1;
   r_i = i0;
   r_j = j0;
   r_mode = 3;
   r_sc = IMPOSSIBLE;
   W = j0-i0+1;
   p1 = (float) L / ((float) L + 2.);
   p2 = sreLOG2(p1);
   p1 = 2*sreLOG2(1.-p1);

   /* Make a deckpool */
   if ( dpool == NULL ) dpool = deckpool_create();
   if (! deckpool_pop(dpool, &end) )
   {  end = alloc_vjd_deck(L, i0, j0); }
   nends = CMSubtreeCountStatetype(cm, vroot, E_st);
   for ( jp=0; jp<=W; jp++ )
   {
	  j = i0+jp-1;
	  end[j][0] = 0.0;
	  for ( d=1; d<=jp; d++ ) { end[j][d] = IMPOSSIBLE; }
   }

   /* Create score matrices */
   if ( alpha == NULL )
   {
	  alpha = malloc(sizeof(float **) * (cm->M+1));
	  for ( v=0; v<=cm->M; v++ ) { alpha[v] = NULL; }
   }
   if ( L_alpha == NULL )
   {
	  L_alpha = malloc(sizeof(float **) * (cm->M+1));
	  for ( v=0; v<=cm->M; v++ ) { L_alpha[v] = NULL; }
   }
   if ( R_alpha == NULL )
   {
	  R_alpha = malloc(sizeof(float **) * (cm->M+1));
	  for ( v=0; v<=cm->M; v++ ) { R_alpha[v] = NULL; }
   }
   if ( T_alpha == NULL )
   {
	  T_alpha = malloc(sizeof(float **) * (cm->M+1));
	  for ( v=0; v<=cm->M; v++ ) { T_alpha[v] = NULL; }
   }

   touch = malloc(sizeof(int) *cm->M);
   for ( v=0;      v<vroot; v++ ) { touch[v] = 0; }
   for ( v=vroot;  v<=vend; v++ ) { touch[v] = cm->pnum[v]; }
   for ( v=vend+1; v<cm->M; v++ ) {touch[v] = 0; }

   /* Create shadow matrices */
   if ( ret_shadow != NULL )
   {
	  shadow = (void ***) malloc(sizeof(void **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { shadow[v] = NULL; }

	  L_shadow = (void ***) malloc(sizeof(void **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { L_shadow[v] = NULL; }

	  R_shadow = (void ***) malloc(sizeof(void **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { R_shadow[v] = NULL; }

	  T_shadow = (void ***) malloc(sizeof(void **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { T_shadow[v] = NULL; }

	  Lmode_shadow = (int ***) malloc(sizeof(int **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { Lmode_shadow[v] = NULL; }

	  Rmode_shadow = (int ***) malloc(sizeof(int **) * cm->M);
	  for ( v=0; v<cm->M; v++ ) { Rmode_shadow[v] = NULL; }
   }

   /* Main recursion */
   for ( v = vend; v >= vroot; v-- )
   {
	  if ( cm->sttype[v] == E_st )
	  {
		 alpha[v] = end;
		 L_alpha[v] = end;
		 R_alpha[v] = end;
		 continue;
	  }
	  /* Assign alpha decks */
	  if (! deckpool_pop(dpool, &(alpha[v])) )
	  {  alpha[v] = alloc_vjd_deck(L, i0, j0); }
	  if (! deckpool_pop(dpool, &(L_alpha[v])) )
	  {  L_alpha[v] = alloc_vjd_deck(L, i0, j0); }
	  if (! deckpool_pop(dpool, &(R_alpha[v])) )
	  {  R_alpha[v] = alloc_vjd_deck(L, i0, j0); }
	  if ( (cm->sttype[v] == B_st) && (! deckpool_pop(dpool, &(T_alpha[v])) ) )
	  {  T_alpha[v] = alloc_vjd_deck(L, i0, j0); }

	  /* Assign shadow decks */
	  if ( ret_shadow != NULL )
	  {
		 if ( cm->sttype[v] == B_st )
		 {
			kshad = alloc_vjd_kshadow_deck(L, i0, j0);
			shadow[v] = (void **) kshad;
		 }
		 else
		 {
			yshad = alloc_vjd_yshadow_deck(L, i0, j0);
			shadow[v] = (void **) yshad;
		 }

		 if ( cm->sttype[v] == B_st )
		 {
			kshad = alloc_vjd_kshadow_deck(L, i0, j0);
			L_shadow[v] = (void **) kshad;
		 }
		 else
		 {
			yshad = alloc_vjd_yshadow_deck(L, i0, j0);
			L_shadow[v] = (void **) yshad;
		 }

		 if ( cm->sttype[v] == B_st )
		 {
			kshad = alloc_vjd_kshadow_deck(L, i0, j0);
			R_shadow[v] = (void **) kshad;
		 }
		 else
		 {
			yshad = alloc_vjd_yshadow_deck(L, i0, j0);
			R_shadow[v] = (void **) yshad;
		 }

		 if ( cm->sttype[v] == B_st )
		 {
			kshad = alloc_vjd_kshadow_deck(L, i0, j0);
			T_shadow[v] = (void **) kshad;
		 }

		 kshad = alloc_vjd_kshadow_deck(L, i0, j0);
		 Lmode_shadow[v] = (int **) kshad;

		 kshad = alloc_vjd_kshadow_deck(L, i0, j0);
		 Rmode_shadow[v] = (int **) kshad;
	  }

	  if ( cm->sttype[v] == D_st || cm->sttype[v] == S_st )
	  {
		 for ( jp=0; jp<=W; jp++ )
		 {
			j = i0-1+jp;
			for ( d=0; d<=jp; d++ )
			{
			   y = cm->cfirst[v];
			   alpha[v][j][d]   = cm->endsc[v] + (cm->el_selfsc * (d));
/*
			   if (cm->sttype[v] == S_st) alpha[v][j][d]   = cm->endsc[v] + (cm->el_selfsc * (d));
			   else                       alpha[v][j][d]   = IMPOSSIBLE;
*/
			   L_alpha[v][j][d] = IMPOSSIBLE;
			   R_alpha[v][j][d] = IMPOSSIBLE;
			   if ( ret_shadow   != NULL )
			   {
				  ((char **)  shadow[v])[j][d] = USED_EL;
				  /* Set USED_EL to prevent a traceback bug */
				  ((char **)L_shadow[v])[j][d] = USED_EL;
				  ((char **)R_shadow[v])[j][d] = USED_EL;
			   }

			   for ( yoffset=0; yoffset<cm->cnum[v]; yoffset++ )
			   {
				  if ( (sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) ((char **)shadow[v])[j][d] = yoffset;
				  }
				  if ( (sc = L_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) ((char **)L_shadow[v])[j][d] = yoffset;
					 if ( ret_shadow != NULL ) Lmode_shadow[v][j][d] = 2;
				  }
				  if ( (sc = R_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) ((char **)R_shadow[v])[j][d] = yoffset;
					 if ( ret_shadow != NULL ) Rmode_shadow[v][j][d] = 1;
				  }
			   }

			   if ( d == 0 )
			   {
				  L_alpha[v][j][d] = IMPOSSIBLE;
				  R_alpha[v][j][d] = IMPOSSIBLE;
			   }

			   if (   alpha[v][j][d] < IMPOSSIBLE ) {   alpha[v][j][d] = IMPOSSIBLE; }
			   if ( L_alpha[v][j][d] < IMPOSSIBLE ) { L_alpha[v][j][d] = IMPOSSIBLE; }
			   if ( R_alpha[v][j][d] < IMPOSSIBLE ) { R_alpha[v][j][d] = IMPOSSIBLE; }
			}
		 }
	  }
	  else if ( cm->sttype[v] == B_st )
	  {
		 for ( jp=0; jp<=W; jp++ )
		 {
			j = i0-1+jp;
			for ( d=0; d<=jp; d++ )
			{
			   int allow_L_exit = 0;
			   int allow_R_exit = 0;
			   int allow_J_exit = 0;
			   y = cm->cfirst[v];
			   z = cm->cnum[v];

			   alpha[v][j][d]   =   alpha[y][j][d] +   alpha[z][j][0];
			   L_alpha[v][j][d] = L_alpha[y][j][d]                   ;
			   R_alpha[v][j][d] =                  + R_alpha[z][j][d];
			   if ( ret_shadow != NULL )
			   {
				  ((int **)  shadow[v])[j][d] = 0;
				  ((int **)L_shadow[v])[j][d] = 0;
				  ((int **)R_shadow[v])[j][d] = d;
				  Lmode_shadow[v][j][d] = 2;
				  Rmode_shadow[v][j][d] = 1;
			   }

			   if  ( (sc = alpha[y][j][d]                   ) > L_alpha[v][j][d] )
			   {
				  L_alpha[v][j][d] = sc;
				  if ( ret_shadow != NULL ) { ((int **)L_shadow[v])[j][d] = 0; }
				  if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }
			   }

			   for ( k=1; k<=d; k++ )
			   {
				  if ( (sc = alpha[y][j-k][d-k] + alpha[z][j][k]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if (ret_shadow != NULL ) { ((int **)shadow[v])[j][d] = k; }
					 if (k == d) allow_J_exit = 0;
					 else        allow_J_exit = 1;
				  }
				  if ( (sc = alpha[y][j-k][d-k] + L_alpha[z][j][k]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((int **)L_shadow[v])[j][d] = k; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }
					 allow_L_exit = 1;
				  }
			   }
			   if ( (sc =                        alpha[z][j][d]) > R_alpha[v][j][d] )
			   {
				  R_alpha[v][j][d] = sc;
				  if ( ret_shadow != NULL ) { ((int **)R_shadow[v])[j][d] = d; }
				  if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }
			   }
			   for ( k=0; k< d; k++ )
			   {
				  if ( (sc = R_alpha[y][j-k][d-k] + alpha[z][j][k]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((int **)R_shadow[v])[j][d] = k; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }
					 allow_R_exit = 1;
				  }
			   }

			   if (d == 0) {
				  L_alpha[v][j][d] = IMPOSSIBLE;
				  R_alpha[v][j][d] = IMPOSSIBLE;
			   }

			   if (d >= 2) {
				 T_alpha[v][j][d] = R_alpha[y][j-1][d-1] + L_alpha[z][j][1];
				 if ( ret_shadow != NULL ) { ((int **)T_shadow[v])[j][d] = 1; }
				 for ( k=2; k<d; k++ )
				 {
					if ( (sc = R_alpha[y][j-k][d-k] + L_alpha[z][j][k]) > T_alpha[v][j][d] )
					{
					   T_alpha[v][j][d] = sc;
					   if ( ret_shadow != NULL) { ((int **)T_shadow[v])[j][d] = k; }
		    }
				 }
			   }
			   else {
				 T_alpha[v][j][d] = IMPOSSIBLE;
			   }

			   if (   alpha[v][j][d] < IMPOSSIBLE ) {   alpha[v][j][d] = IMPOSSIBLE; }
			   if ( L_alpha[v][j][d] < IMPOSSIBLE ) { L_alpha[v][j][d] = IMPOSSIBLE; }
			   if ( R_alpha[v][j][d] < IMPOSSIBLE ) { R_alpha[v][j][d] = IMPOSSIBLE; }

			   if ( allow_begin )
			   {
				  /* Shouldn't allow exit from marginal B if one of the children is NULL, sinee that is covered by the */
				  /* root of the other child, and we haven't added anything above the bifurcation */
				  if (!lenCORREX)
				  {
				  if ((  alpha[v][j][d] > r_sc) && (allow_J_exit) )
				  { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d]; }
				  if ((L_alpha[v][j][d] > r_sc) && (allow_L_exit) )
				  { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d]; }
				  if ((R_alpha[v][j][d] > r_sc) && (allow_R_exit) )
				  { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d]; }
				  if ( T_alpha[v][j][d] > r_sc )
				  { r_mode = 0; r_v = v; r_j = j; r_i = j-d+1; r_sc = T_alpha[v][j][d]; }
				  }
				  else
				  {
				  psc = p1 + (L-d)*p2;
				  if ((  alpha[v][j][d] + psc > r_sc) && (allow_J_exit) )
				  { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d] + psc; }
				  if ((L_alpha[v][j][d] + psc > r_sc) && (allow_L_exit) )
				  { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d] + psc; }
				  if ((R_alpha[v][j][d] + psc > r_sc) && (allow_R_exit) )
				  { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d] + psc; }
				  if ( T_alpha[v][j][d] + psc > r_sc )
				  { r_mode = 0; r_v = v; r_j = j; r_i = j-d+1; r_sc = T_alpha[v][j][d] + psc; }
				  }
			   }
			}
		 }
	  }
	  else if ( cm->sttype[v] == MP_st )
	  {
		 for ( jp=0; jp<=W; jp++ )
		 {
			j = i0-1+jp;
			y = cm->cfirst[v];
			alpha[v][j][0] = IMPOSSIBLE;
			L_alpha[v][j][0] = IMPOSSIBLE;
			R_alpha[v][j][0] = IMPOSSIBLE;
			if ( jp > 0 ) {
			   alpha[v][j][1] = IMPOSSIBLE;
			   L_alpha[v][j][1] = cm->lmesc[v][(int) dsq[j]];
			   R_alpha[v][j][1] = cm->rmesc[v][(int) dsq[j]];
			   if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][1] = USED_EL; }
			   if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][1] = USED_EL; }
			}
			for ( d=2; d<=jp; d++)
			{
			   alpha[v][j][d] = cm->endsc[v] + (cm->el_selfsc * (d-2));
			   L_alpha[v][j][d] = IMPOSSIBLE;
			   R_alpha[v][j][d] = IMPOSSIBLE;
			   if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = USED_EL; }

			   for ( yoffset=0; yoffset<cm->cnum[v]; yoffset++ )
			   {
				  if ( (sc = alpha[y+yoffset][j-1][d-2] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = yoffset; }
				  }

				  if ( (sc = alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > L_alpha[v][j][d])
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }
				  }
				  if ( (sc = L_alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > L_alpha[v][j][d])
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 2; }
				  }

				  if ( (sc = alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > R_alpha[v][j][d])
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }
				  }
				  if ( (sc = R_alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > R_alpha[v][j][d])
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 1; }
				  }
			   }

			   i = j-d+1;
			   if ( dsq[i] < cm->abc->K && dsq[j] < cm->abc->K )
			   {  alpha[v][j][d] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])]; }
			   else
			   {  alpha[v][j][d] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]); }
			   { L_alpha[v][j][d] += cm->lmesc[v][(int) dsq[i]]; }
			   { R_alpha[v][j][d] += cm->rmesc[v][(int) dsq[j]]; }

			   if (   alpha[v][j][d] < IMPOSSIBLE ) {   alpha[v][j][d] = IMPOSSIBLE; }
			   if ( L_alpha[v][j][d] < IMPOSSIBLE ) { L_alpha[v][j][d] = IMPOSSIBLE; }
			   if ( R_alpha[v][j][d] < IMPOSSIBLE ) { R_alpha[v][j][d] = IMPOSSIBLE; }
			}

			for ( d = 1; d <= jp; d++ )
			{
			   if ( allow_begin )
			   {
				  if (!lenCORREX)
				  {
				  if (   alpha[v][j][d] > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d]; }
				  if ( L_alpha[v][j][d] > r_sc ) { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d]; }
				  if ( R_alpha[v][j][d] > r_sc ) { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d]; }
				  }
				  else
				  {
				  psc = p1 + (L-d)*p2;
				  if (   alpha[v][j][d] + psc > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d] + psc; }
				  if ( L_alpha[v][j][d] + psc > r_sc ) { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d] + psc; }
				  if ( R_alpha[v][j][d] + psc > r_sc ) { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d] + psc; }
				  }
			   }
			}
		 }
	  }
	  else if ( cm->sttype[v] == IL_st || cm->sttype[v] == ML_st )
	  {
		 for ( jp = 0; jp <= W; jp++ )
		 {
			j = i0-1+jp;
			y = cm->cfirst[v];

			alpha[v][j][0] = IMPOSSIBLE;
			L_alpha[v][j][0] = IMPOSSIBLE;
			R_alpha[v][j][0] = IMPOSSIBLE;

			for ( d = 1; d <= jp; d++ )
			{
			   alpha[v][j][d]   = cm->endsc[v] + (cm->el_selfsc * (d-1));
			   if (d == 1) L_alpha[v][j][d] = 0.0;
			   else        L_alpha[v][j][d] = IMPOSSIBLE;
			   R_alpha[v][j][d] = IMPOSSIBLE;
			   if ( ret_shadow   != NULL ) { ((char **)  shadow[v])[j][d] = USED_EL; }
			   if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = USED_EL; }
			   if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }

			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
			   {
				  if  ( (sc = alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = yoffset; }
				  }

		  if  ( d > 1 )
				  if  ( (sc = L_alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 2; }
				  }
	       }

	       /* we need a separate 'for(yoffset...' loop for the R matrix
		* because it depends on a fully calculated J matrix cell
		* alpha[v][j][d] in some cases (when v is an IL, and yoffset is 0)
		*/
			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
	       {
		  if  ( (sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
		  {
					  R_alpha[v][j][d] = sc;
					  if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					  if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }
				  }

				  if  ( (sc = R_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					  R_alpha[v][j][d] = sc;
					  if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					  if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 1; }
				  }
			   }
#if 0
			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
			   {
				  if  ( (sc = alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = yoffset; }
				  }

				  if  ( d > 1 )
				  if  ( (sc = L_alpha[y+yoffset][j][d-1] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 2; }
				  }

		  /* EPN, Wed Aug 17 09:34:13 2011
		   * I think this is a minor bug:
		   * If y == v and yoffset is 0, then
		   * 1. alpha[y+yoffset][j][d] == alpha[v][j][d] This
				   *    is a problem because alpha[v][j][d] hasn't
				   *    been fully calculated yet, see line about 12
				   *    lines up: 'alpha[v][j][d] = sc;', it could be
				   *    changed for next yoffset value. This means
				   *    that the if statement below: 'if ( (sc =
				   *    alpha[y+yoffset][j][d] + cm->tsc[v][yoffset])
				   *    > R_alpha[v][j][d] )' is using a
				   *    not-yet-finished alpha[y+yoffset][j][d]
				   *    (remember this equals alpha[v][j][d]) value,
				   *    which is bad. The way to fix this is to
		   *    use separate 'for(yoffset...' loops for each
		   *    alpha and R_alpha.
		   *
		   * 2. R_alpha[y+yoffset][j][d] == R_alpha[v][j][d]
		   *    I think this is okay because R_alpha[v][j][d] is
		   *    init'ed to IMPOSSIBLE and transitions are always
		   *    <= 0, so R_alpha[v][j][d] will stay as IMPOSSIBLE
		   *    below.
		   */
				  if  ( (sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }
				  }

				  if  ( (sc = R_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 1; }
				  }
			   }
#endif
			   i = j-d+1;
			   if ( dsq[i] < cm->abc->K )
			   {
					alpha[v][j][d] += cm->esc[v][(int) dsq[i]];
				  L_alpha[v][j][d] += cm->esc[v][(int) dsq[i]];
			   }
			   else
			   {
					alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
				  L_alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
			   }

			   if (   alpha[v][j][d] < IMPOSSIBLE ) {   alpha[v][j][d] = IMPOSSIBLE; }
			   if ( L_alpha[v][j][d] < IMPOSSIBLE ) { L_alpha[v][j][d] = IMPOSSIBLE; }
			   if ( R_alpha[v][j][d] < IMPOSSIBLE ) { R_alpha[v][j][d] = IMPOSSIBLE; }
			}

			for ( d = 1; d <= jp; d++ )
			{
			   if ( cm->sttype[v] == ML_st && allow_begin )
			   {
				  if (!lenCORREX)
				  {
				  if (   alpha[v][j][d] > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d]; }
				  if ( L_alpha[v][j][d] > r_sc ) { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d]; }
				  }
				  else
				  {
				  psc = p1 + (L-d)*p2;
				  if (   alpha[v][j][d] + psc > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d] + psc; }
				  if ( L_alpha[v][j][d] + psc > r_sc ) { r_mode = 2; r_v = v; r_j = j; r_i = j-d+1; r_sc = L_alpha[v][j][d] + psc; }
				  }
			   }
			}
		 }
	  }
	  else if ( cm->sttype[v] == IR_st || cm->sttype[v] == MR_st )
	  {
		 for ( jp = 0; jp <= W; jp++ )
		 {
			j = i0-1+jp;
			y = cm->cfirst[v];

			alpha[v][j][0] = IMPOSSIBLE;
			L_alpha[v][j][0] = IMPOSSIBLE;
			R_alpha[v][j][0] = IMPOSSIBLE;

			for ( d = 1; d <= jp; d++ )
			{
			   alpha[v][j][d]   = cm->endsc[v] + (cm->el_selfsc * (d-1));
			   L_alpha[v][j][d] = IMPOSSIBLE;
			   if (d == 1) R_alpha[v][j][d] = 0.0;
			   else        R_alpha[v][j][d] = IMPOSSIBLE;
			   if ( ret_shadow   != NULL ) { ((char **)  shadow[v])[j][d] = USED_EL; }
			   if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = USED_EL; }
			   if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 3; }

			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
			   {
				  if  ( (sc = alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = yoffset; }
				  }
				  if  ( d > 1 )
				  if  ( (sc = R_alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 1; }
				  }
	       }

	       /* we need a separate 'for(yoffset...' loop for the L matrix
		* because it depends on a fully calculated J matrix cell
		* alpha[v][j][d] in some cases (when v is an IR, and yoffset is 0)
		*/
			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
			   {
				  if  ( (sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }
				  }

				  if  ( (sc = L_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 2; }
				  }
	       }

#if 0
	       /* EPN, Wed Aug 17 09:34:13 2011 I think this is a
		* minor bug, analogous to the one in the same spot
		* above for IL, ML states, see that comment for more
		* info. (The bug is actually only for self-looping
		* IL/IR states.)
		*/

			   for ( yoffset = 0; yoffset < cm->cnum[v]; yoffset++ )
			   {
				  if  ( (sc = alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > alpha[v][j][d] )
				  {
					 alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)shadow[v])[j][d] = yoffset; }
				  }

				  if  ( (sc = alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 3; }
				  }

				  if  ( (sc = L_alpha[y+yoffset][j][d] + cm->tsc[v][yoffset]) > L_alpha[v][j][d] )
				  {
					 L_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)L_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Lmode_shadow[v][j][d] = 2; }
				  }

				  if  ( d > 1 )
				  if  ( (sc = R_alpha[y+yoffset][j-1][d-1] + cm->tsc[v][yoffset]) > R_alpha[v][j][d] )
				  {
					 R_alpha[v][j][d] = sc;
					 if ( ret_shadow != NULL ) { ((char **)R_shadow[v])[j][d] = yoffset; }
					 if ( ret_shadow != NULL ) { Rmode_shadow[v][j][d] = 1; }
				  }
			   }
#endif

			   if ( dsq[j] < cm->abc->K )
			   {
					alpha[v][j][d] += cm->esc[v][(int) dsq[j]];
				  R_alpha[v][j][d] += cm->esc[v][(int) dsq[j]];
			   }
			   else
			   {
					alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
				  R_alpha[v][j][d] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
			   }

			   if (   alpha[v][j][d] < IMPOSSIBLE ) {   alpha[v][j][d] = IMPOSSIBLE; }
			   if ( L_alpha[v][j][d] < IMPOSSIBLE ) { L_alpha[v][j][d] = IMPOSSIBLE; }
			   if ( R_alpha[v][j][d] < IMPOSSIBLE ) { R_alpha[v][j][d] = IMPOSSIBLE; }
			}

			for ( d = 1; d <= jp; d++ )
			{
			   if ( cm->sttype[v] == MR_st && allow_begin )
			   {
				  if (!lenCORREX)
				  {
				  if (   alpha[v][j][d] > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d]; }
				  if ( R_alpha[v][j][d] > r_sc ) { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d]; }
				  }
				  else
				  {
				  psc = p1 + (L-d)*p2;
				  if (   alpha[v][j][d] + psc > r_sc ) { r_mode = 3; r_v = v; r_j = j; r_i = j-d+1; r_sc =   alpha[v][j][d] + psc; }
				  if ( R_alpha[v][j][d] + psc > r_sc ) { r_mode = 1; r_v = v; r_j = j; r_i = j-d+1; r_sc = R_alpha[v][j][d] + psc; }
				  }
			   }
			}
		 }
	  }
	  else
	  {
		 cm_Die("'Inconceivable!'\n'You keep using that word...'");
	  }

#if 0
	  /* TEMP PRINTING */
	  if(cm->sttype[v] == B_st) {
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  if(j > 0) {
	    for ( d = 0; d <= jp; d++ ) {
	      printf("D j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(  alpha[v][j][d]) ?   alpha[v][j][d] : -9999.9,
		     NOT_IMPOSSIBLE(L_alpha[v][j][d]) ? L_alpha[v][j][d] : -9999.9,
		     NOT_IMPOSSIBLE(R_alpha[v][j][d]) ? R_alpha[v][j][d] : -9999.9,
		     NOT_IMPOSSIBLE(T_alpha[v][j][d]) ? T_alpha[v][j][d] : -9999.9);
	    }
	  }
	}
	  }
	  else {
	for (jp = 0; jp <= W; jp++) {
	  j = i0-1+jp;
	  if(j > 0) {
	    for ( d = 0; d <= jp; d++ ) {
	      printf("D j: %3d  v: %3d  d: %3d   J: %10.4f  L: %10.4f  R: %10.4f  T: %10.4f\n",
		     j, v, d,
		     NOT_IMPOSSIBLE(  alpha[v][j][d]) ?   alpha[v][j][d] : -9999.9,
		     NOT_IMPOSSIBLE(L_alpha[v][j][d]) ? L_alpha[v][j][d] : -9999.9,
		     NOT_IMPOSSIBLE(R_alpha[v][j][d]) ? R_alpha[v][j][d] : -9999.9,
		     -9999.9);
	    }
	  }
	}
	  }

	  printf("\n");
	  /* TEMP PRINTING */
#endif

	  if ( v == vroot )
	  {
		 if  (!lenCORREX)
		 {
		 if  (   alpha[v][j0][W] > r_sc ) { r_mode = 3; r_v = v; r_j = j0; r_i = j0-W+1; r_sc =   alpha[v][j0][W]; }
		 if  ( L_alpha[v][j0][W] > r_sc ) { r_mode = 2; r_v = v; r_j = j0; r_i = j0-W+1; r_sc = L_alpha[v][j0][W]; }
		 if  ( R_alpha[v][j0][W] > r_sc ) { r_mode = 1; r_v = v; r_j = j0; r_i = j0-W+1; r_sc = R_alpha[v][j0][W]; }
		 }
		 else
		 {
		 psc = p1 + (L-W)*p2;
		 if  (   alpha[v][j0][W] + psc > r_sc ) { r_mode = 3; r_v = v; r_j = j0; r_i = j0-W+1; r_sc =   alpha[v][j0][W] + psc; }
		 if  ( L_alpha[v][j0][W] + psc > r_sc ) { r_mode = 2; r_v = v; r_j = j0; r_i = j0-W+1; r_sc = L_alpha[v][j0][W] + psc; }
		 if  ( R_alpha[v][j0][W] + psc > r_sc ) { r_mode = 1; r_v = v; r_j = j0; r_i = j0-W+1; r_sc = R_alpha[v][j0][W] + psc; }
		 }
	  }

	  if ( v==0 )
	  {
		   alpha[0][j0][W] = r_sc;
		 L_alpha[0][j0][W] = r_sc;
		 R_alpha[0][j0][W] = r_sc;
		 if ( ret_shadow   != NULL ) { ((char **)  shadow[0])[j0][W] = USED_LOCAL_BEGIN; }
		 if ( ret_shadow != NULL ) { ((char **)L_shadow[0])[j0][W] = USED_LOCAL_BEGIN; }
		 if ( ret_shadow != NULL ) { ((char **)R_shadow[0])[j0][W] = USED_LOCAL_BEGIN; }
		 if ( ret_shadow != NULL ) { Lmode_shadow[0][j0][W] = r_mode; }
		 if ( ret_shadow != NULL ) { Rmode_shadow[0][j0][W] = r_mode; }
	  }

	  if (! do_full)
	  {
		 if ( cm->sttype[v] == B_st )
		 {
			y = cm->cfirst[v];
			deckpool_push(dpool,   alpha[y]);   alpha[y] = NULL;
			deckpool_push(dpool, L_alpha[y]); L_alpha[y] = NULL;
			deckpool_push(dpool, R_alpha[y]); R_alpha[y] = NULL;
			z = cm->cnum[v];
			deckpool_push(dpool,   alpha[z]);   alpha[z] = NULL;
			deckpool_push(dpool, L_alpha[z]); L_alpha[z] = NULL;
			deckpool_push(dpool, R_alpha[z]); R_alpha[z] = NULL;
		 }
		 else
		 {
			for ( y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++ )
			{
			   touch[y]--;
			   if ( touch[y] == 0 )
			   {
				  if ( cm->sttype[y] == E_st )
				  {
					 nends--;
					 if ( nends == 0 ) { deckpool_push(dpool, end); end = NULL; }
				  }
				  else
				  {
		     deckpool_push(dpool,   alpha[y]);
					 deckpool_push(dpool, L_alpha[y]);
					 deckpool_push(dpool, R_alpha[y]);
					 if ( cm->sttype[y] == B_st ) { deckpool_push(dpool, T_alpha[y]); }
				  }

					alpha[y] = NULL;
				  L_alpha[y] = NULL;
				  R_alpha[y] = NULL;
				  T_alpha[y] = NULL;
			   }
			}
		 }
	  }
   } /* end loop over all v */

   sc = r_sc;
   if ( ret_v     != NULL ) { *ret_v     = r_v; }
   if ( ret_i     != NULL ) { *ret_i     = r_i; }
   if ( ret_j     != NULL ) { *ret_j     = r_j; }
   if ( ret_mode  != NULL ) { *ret_mode  = r_mode; }

   /* Free or return score matrices */
   if ( ret_alpha == NULL )
   {
	  for ( v = vroot; v <= vend; v++ )
	  {
		 if ( alpha[v] != NULL )
		 {
			if ( cm->sttype[v] != E_st )
			{
			   deckpool_push(dpool,   alpha[v]);   alpha[v] = NULL;
			   deckpool_push(dpool, L_alpha[v]); L_alpha[v] = NULL;
			   deckpool_push(dpool, R_alpha[v]); R_alpha[v] = NULL;
			   if ( T_alpha[v] != NULL )
			   {  deckpool_push(dpool, T_alpha[v]); T_alpha[v] = NULL; }
			}
			else
			{  end = alpha[v]; }
		 }
	  }
	  if ( end != NULL) {deckpool_push(dpool, end); end = NULL; }
	  free(  alpha);
	  free(L_alpha);
	  free(R_alpha);
	  free(T_alpha);
   }
   else
   {
	  ret_alpha->J = alpha;
	  ret_alpha->L = L_alpha;
	  ret_alpha->R = R_alpha;
	  ret_alpha->T = T_alpha;
   }

   /* Free or return deckpool */
   if ( ret_dpool == NULL )
   {
	  while ( deckpool_pop(dpool, &end)) free_vjd_deck(end, i0, j0);
	  deckpool_free(dpool);
   }
   else
   {
	  *ret_dpool = dpool;
   }

   free(touch);
   if ( ret_shadow != NULL ) ret_shadow->J = shadow;
   if ( ret_shadow != NULL ) ret_shadow->L = L_shadow;
   if ( ret_shadow != NULL ) ret_shadow->R = R_shadow;
   if ( ret_shadow != NULL ) ret_shadow->T = T_shadow;
   if ( ret_shadow != NULL ) ret_shadow->Lmode = (void ***)Lmode_shadow;
   if ( ret_shadow != NULL ) ret_shadow->Rmode = (void ***)Rmode_shadow;
   return sc;
}

/* Function: tr_outside()
 * Author:   DLK
 *
 * Purpose:  outside version of truncated CYK run on
 *           an unbifurcated model segment vroot..vend
 *           Closely based on outside()
 * Args;
 *
 * Returns:  Score of best local hit (not extending to vend)
 */
float
tr_outside(CM_t *cm, ESL_DSQ *dsq, int L, int vroot, int vend, int i0, int j0, int do_full,
		   int r_allow_J, int r_allow_L, int r_allow_R,
		   BetaMats_t *arg_beta, BetaMats_t *ret_beta,
		   struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		   int *ret_mode, int *ret_v, int *ret_j)
{
   int    v,y;
   int    j,d,i;
   float  sc;
   int   *touch;
   float  esc;
   int    W;
   int    jp;
   int    voffset;
   int    w1, w2;
   int    allow_begin;

   float  b_sc;
   int    b_mode, b_v, b_j;

   BetaMats_t *beta;

   W = j0 - i0 + 1;
   if ( dpool == NULL ) dpool = deckpool_create();

   beta = malloc(sizeof(BetaMats_t));
   if ( arg_beta == NULL )
   {
	  beta->J = malloc(sizeof(float **) * (cm->M+1));
	  beta->L = malloc(sizeof(float  *) * (cm->M+1));
	  beta->R = malloc(sizeof(float  *) * (cm->M+1));
	  beta->L[0] = malloc(sizeof(float) * (cm->M+1)*(L+2));
	  beta->R[0] = malloc(sizeof(float) * (cm->M+1)*(L+2));
	  for ( v = 0; v < cm->M+1; v++ )
	  {
		 beta->J[v] = NULL;
		 beta->L[v] = beta->L[0] + v*(L+2);
		 beta->R[v] = beta->R[0] + v*(L+2);
	  }
   }
   else
   {
	  beta->J = arg_beta->J;
	  beta->L = arg_beta->L;
	  beta->R = arg_beta->R;
	  for ( v = 0; v < cm->M+1; v++ )
	  {
		 beta->J[v] = arg_beta->J[v];
		 beta->L[v] = arg_beta->L[v];
		 beta->R[v] = arg_beta->R[v];
	  }
   }

   /* Initialize the root deck, and its split set if applicable */
   w1 = cm->nodemap[cm->ndidx[vroot]];
   if (cm->sttype[vroot] == B_st)
   {
	  w2 = w1;
	  if (vend != vroot) cm_Die("vroot B but vroot != vend!\n");
   }
   else
	  w2 = cm->cfirst[w1] - 1;

   for (v = w1; v <= w2; v++)
   {
	  allow_begin = TRUE;
	  if ( vroot != 0 ) allow_begin = FALSE;
	  if ( cm->sttype[v] == IL_st ||
		   cm->sttype[v] == IR_st ||
		   cm->sttype[v] ==  S_st ||
		   cm->sttype[v] ==  D_st ||
		   cm->sttype[v] ==  E_st    ) allow_begin = FALSE;
	  if (! deckpool_pop(dpool, &(beta->J[v])) )
		 beta->J[v] = alloc_vjd_deck(L, i0, j0);
	  for (jp = 0; jp <= W; jp++)
	  {
		 j = i0 + jp - 1;
		 for (d = 0; d <= jp; d++)
			if ( allow_begin )
			   beta->J[v][j][d] = 0.0;
			else
			   beta->J[v][j][d] = IMPOSSIBLE;
		 if ( allow_begin )
		 {
			beta->L[v][j] = 0.0;
			beta->R[v][j] = 0.0;
		 }
		 else
		 {
			beta->L[v][j] = IMPOSSIBLE;
			beta->R[v][j] = IMPOSSIBLE;
		 }
	  }
	  if ( allow_begin )
	  {
		 beta->L[v][i0+W] = 0.0;
		 beta->R[v][i0+W] = 0.0;
	  }
	  else
	  {
		 beta->L[v][i0+W] = IMPOSSIBLE;
		 beta->R[v][i0+W] = IMPOSSIBLE;
	  }
   }
   beta->J[vroot][j0][W] = 0.0;
   if (r_allow_L) beta->L[vroot][i0] = 0.0; else beta->L[vroot][i0] = IMPOSSIBLE;
   if (r_allow_R) beta->R[vroot][j0] = 0.0; else beta->R[vroot][j0] = IMPOSSIBLE;

   /* Initialize EL */
   if (! deckpool_pop(dpool, &(beta->J[cm->M])) )
	  beta->J[cm->M] = alloc_vjd_deck(L, i0, j0);
   for (jp = 0; jp <= W; jp++)
   {
	  j = i0 + jp - 1;
	  for (d = 0; d <= jp; d++)
		 beta->J[cm->M][j][d] = IMPOSSIBLE;
	  beta->L[cm->M][j] = IMPOSSIBLE;
	  beta->R[cm->M][j] = IMPOSSIBLE;
   }

   /* deal with vroot->EL */
   /* Marginal modes don't transition to EL,
	* so beta->L and beta->R remain at their
	* initialization values of IMPOSSIBLE */
   if (NOT_IMPOSSIBLE(cm->endsc[vroot]))
   {
	  switch (cm->sttype[vroot])
	  {
		 case MP_st:
			if (W < 2) break;
			if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
			   esc = cm->esc[vroot][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
			else
			   esc = DegeneratePairScore(cm->abc, cm->esc[vroot], dsq[i0], dsq[j0]);
			beta->J[cm->M][j0-1][W-2] = cm->endsc[vroot] + (cm->el_selfsc * (W-2)) + esc;
			if (beta->J[cm->M][j0-1][W-2] < IMPOSSIBLE) beta->J[cm->M][j0-1][W-2] = IMPOSSIBLE;
			break;
		 case ML_st:
		 case IL_st:
			if (W < 1) break;
			if (dsq[i0] < cm->abc->K)
			   esc = cm->esc[vroot][(int) dsq[i0]];
			else
			   esc = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[vroot]);
			beta->J[cm->M][j0][W-1] = cm->endsc[vroot] + (cm->el_selfsc * (W-1)) + esc;
			if (beta->J[cm->M][j0][W-1] < IMPOSSIBLE) beta->J[cm->M][j0][W-1] = IMPOSSIBLE;
			break;
		 case MR_st:
		 case IR_st:
			if (W < 1) break;
			if (dsq[j0] < cm->abc->K)
			   esc = cm->esc[vroot][(int) dsq[j0]];
			else
			   esc = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[vroot]);
			beta->J[cm->M][j0-1][W-1] = cm->endsc[vroot] + (cm->el_selfsc * (W-1)) + esc;
			if (beta->J[cm->M][j0-1][W-1] < IMPOSSIBLE) beta->J[cm->M][j0][W-1] = IMPOSSIBLE;
			break;
		 case  S_st:
		 case  D_st:
			beta->J[cm->M][j0][W] = cm->endsc[vroot] + (cm->el_selfsc * W);
			if (beta->J[cm->M][j0][W] < IMPOSSIBLE) beta->J[cm->M][j0][W] = IMPOSSIBLE;
			break;
		 case  B_st: /* B_st can't go to EL? */
		 default:
			cm_Die("bogus parent state %d\n",cm->sttype[vroot]);
	  }
   }

   /* Initialize touch vector for controlling deck de-allocation */
   touch = malloc(sizeof(int) * cm->M);
   for (v = 0;      v < w1;    v++) touch[v] = 0;
   for (v = vend+1; v < cm->M; v++) touch[v] = 0;
   for (v = w1;     v <= vend; v++)
   {
	  if (cm->sttype[v] == B_st) touch[v] = 2;
	  else                       touch[v] = cm->cnum[v];
   }

   b_sc = IMPOSSIBLE;
   b_v  = -1;
   b_j  = -1;
   b_mode = -1;

   /* Main loop through decks */
   for (v = w2+1; v <= vend; v++)
   {
	  allow_begin = TRUE;
	  if ( vroot != 0 ) allow_begin = FALSE;
	  if ( cm->sttype[v] == IL_st ||
		   cm->sttype[v] == IR_st ||
		   cm->sttype[v] ==  S_st ||
		   cm->sttype[v] ==  D_st ||
		   cm->sttype[v] ==  E_st    ) allow_begin = FALSE;

	  /* Get a deck */
	  if (! deckpool_pop(dpool, &(beta->J[v])) )
		 beta->J[v] = alloc_vjd_deck(L, i0, j0);
	  for (jp = W; jp >= 0; jp--)
	  {
		 j = i0 + jp - 1;
		 for (d = jp; d >= 0; d--)
		 {
			if ( allow_begin )
			   beta->J[v][j][d] = 0.0;
			else
			   beta->J[v][j][d] = IMPOSSIBLE;
		 }
		 if ( allow_begin )
		 {
			beta->L[v][j] = 0.0;
			beta->R[v][j] = 0.0;
		 }
		 else
		 {
			beta->L[v][j] = IMPOSSIBLE;
			beta->R[v][j] = IMPOSSIBLE;
		 }
	  }
	  beta->L[v][i0+W] = IMPOSSIBLE;

	  /* mini-recursion for beta->L */
	  if ( r_allow_L )
	  for (j = i0; j <= j0+1; j++)
	  {
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			if (y < vroot) continue;
			voffset = v - cm->cfirst[y];

			switch (cm->sttype[y])
			{
			   case MP_st:
				  if (j > i0)
				  {
					 esc = cm->lmesc[y][(int) dsq[j-1]];
					 if ( (sc = beta->L[y][j-1] + cm->tsc[y][voffset] + esc) > beta->L[v][j] )
						beta->L[v][j] = sc;
				  }
				  break;
			   case ML_st:
			   case IL_st:
				  if (j > i0)
				  {
					 if (dsq[j-1] < cm->abc->K)
						esc = cm->esc[y][(int) dsq[j-1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[j-1], cm->esc[v]);
					 if ( (sc = beta->L[y][j-1] + cm->tsc[y][voffset] + esc) > beta->L[v][j] )
						beta->L[v][j] = sc;
				  }
				  break;
			   case MR_st:
			   case IR_st:
			   case  S_st:
			   case  E_st:
			   case  D_st:
				  if ( (sc = beta->L[y][j] + cm->tsc[y][voffset]) > beta->L[v][j] )
					 beta->L[v][j] = sc;
				  break;
			   default:
				  cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			}
		 }
		 esc = 0.0;
		 if ( j <= j0 )
		 {
			if (cm->sttype[v] == MP_st)
			{
			   esc = cm->lmesc[v][(int) dsq[j]];
			}
			if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st)
			{
			   if (dsq[j] < cm->abc->K) esc = cm->esc[v][(int) dsq[j]];
			   else                        esc = esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
			}
		 }
		 if (beta->L[v][j] + esc > b_sc)
		 {
			b_sc = beta->L[v][j] + esc;
			b_v  = v;
			b_j  = j;
			b_mode = 2;
		 }
	  }

	  /* mini-recursion for beta->R */
	  if ( r_allow_R )
	  for (j = j0; j >= i0-1; j--)
	  {
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			if (y < vroot) continue;
			voffset = v - cm->cfirst[y];

			switch (cm->sttype[y])
			{
			   case MP_st:
				  if (j < j0)
				  {
					 esc = cm->rmesc[y][(int) dsq[j+1]];
					 if ( (sc = beta->R[y][j+1] + cm->tsc[y][voffset] + esc) > beta->R[v][j] )
						beta->R[v][j] = sc;
				  }
				  break;
			   case MR_st:
			   case IR_st:
				  if (j < j0)
				  {
					 if (dsq[j+1] < cm->abc->K)
						esc = cm->esc[y][(int) dsq[j+1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);
					 if ( (sc = beta->R[y][j+1] + cm->tsc[y][voffset] + esc) > beta->R[v][j] )
						beta->R[v][j] = sc;
				  }
				  break;
			   case ML_st:
			   case IL_st:
			   case  S_st:
			   case  E_st:
			   case  D_st:
				  if ( (sc = beta->R[y][j] + cm->tsc[y][voffset]) > beta->R[v][j] )
					 beta->R[v][j] = sc;
				  break;
			   default:
				  cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			}
		 }
		 esc = 0.0;
		 if ( j >= i0 )
		 {
			if (cm->sttype[v] == MP_st)
			{
			   esc = cm->rmesc[v][(int) dsq[j]];
			}
			if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)
			{
			   if (dsq[j] < cm->abc->K) esc = cm->esc[v][(int) dsq[j]];
			   else                        esc = esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
			}
		 }
		 if (beta->R[v][j] + esc > b_sc)
		 {
			b_sc = beta->R[v][j] + esc;
			b_v  = v;
			b_j  = j;
			b_mode = 1;
		 }
	  }

	  /* main recursion */
	  for (jp = W; jp >= 0; jp--)
	  {
		 j = i0 + jp - 1;
		 for (d = jp; d >= 0; d--)
		 {
			i = j - d + 1;
			for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
			{
			   if (y < vroot) continue;
			   voffset = v - cm->cfirst[y];

			   switch (cm->sttype[y])
			   {
				  case MP_st:
					 if (j != j0 && d != jp)
					 {
						if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
						   esc = cm->esc[y][(int) (dsq[i-1]*cm->abc->K + dsq[j+1])];
						else
						   esc = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);
						if ( (sc = beta->J[y][j+1][d+2] + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->L[y][i-1]      + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->R[y][j+1]      + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
					 }
					 break;
				  case ML_st:
				  case IL_st:
					 if (d != jp)
					 {
						if (dsq[i-1] < cm->abc->K)
						   esc = cm->esc[y][(int) dsq[i-1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);
						if ( (sc = beta->J[y][j][d+1] + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->L[y][i-1]    + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->R[y][j]      + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
					 }
					 break;
				  case MR_st:
				  case IR_st:
					 if (j != j0)
					 {
						if (dsq[j+1] < cm->abc->K)
						   esc = cm->esc[y][(int) dsq[j+1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);
						if ( (sc = beta->J[y][j+1][d+1] + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->L[y][i]        + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
						if ( (sc = beta->R[y][j+1]      + cm->tsc[y][voffset] + esc) > beta->J[v][j][d] )
						   beta->J[v][j][d] = sc;
					 }
					 break;
				  case  S_st:
				  case  E_st:
				  case  D_st:
					 if ( (sc = beta->J[y][j][d] + cm->tsc[y][voffset]) > beta->J[v][j][d] )
						beta->J[v][j][d] = sc;
					 break;
				  default:
					 cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			   } /* End switch over state types */
			} /* End loop over parent states  - cell done */
		 } /* End loop over d - row done */
	  } /* End loop over jp - deck done */

	  /* v->EL transitions (beta->J only */
	  if (NOT_IMPOSSIBLE(cm->endsc[v]))
	  {
		 for (jp = 0; jp <= W; jp++)
		 {
			j = i0-1+jp;
			for (d = 0; d <= jp; d++)
			{
			   i = j-d+1;
			   switch (cm->sttype[v])
			   {
				  case MP_st:
					 if (j == j0 || d == jp) continue; /* boundary condition */
					 if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
						esc = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
					 else
						esc = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
					 if ((sc = beta->J[v][j+1][d+2] + cm->endsc[v] + (cm->el_selfsc * d) + esc) > beta->J[cm->M][j][d])
						beta->J[cm->M][j][d] = sc;
					 break;
				  case ML_st:
				  case IL_st:
					 if (d == jp) continue;
					 if (dsq[i-1] < cm->abc->K)
						esc = cm->esc[v][(int) dsq[i-1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
					 if ((sc = beta->J[v][j][d+1] + cm->endsc[v] + (cm->el_selfsc * d) + esc) > beta->J[cm->M][j][d])
						/*(cm->el_selfsc * (d+1)) + esc) > beta[cm->M][j][d])*/
						beta->J[cm->M][j][d] = sc;
					 break;
				  case MR_st:
				  case IR_st:
					 if (j == j0) continue;
					 if (dsq[j+1] < cm->abc->K)
						esc = cm->esc[v][(int) dsq[j+1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
					 if ((sc = beta->J[v][j+1][d+1] + cm->endsc[v] + (cm->el_selfsc * d) + esc) > beta->J[cm->M][j][d])
						/*(cm->el_selfsc * (d+1)) + esc) > beta[cm->M][j][d])*/
						beta->J[cm->M][j][d] = sc;
					 break;
				  case S_st:
				  case D_st:
				  case E_st:
					 if ((sc = beta->J[v][j][d] + cm->endsc[v] + (cm->el_selfsc * d)) > beta->J[cm->M][j][d])
						beta->J[cm->M][j][d] = sc;
					 break;
				  case B_st:
				  default: cm_Die("bogus parent state %d\n", cm->sttype[v]);
				/* note that although B is a valid vend for a segment we'd do
				   outside on, B->EL is set to be impossible, by the local alignment
				   config. There's no point in having a B->EL because B is a nonemitter
				   (indeed, it would introduce an alignment ambiguity). The same
				   alignment case is handled by the X->EL transition where X is the
				   parent consensus state (S, MP, ML, or MR) above the B. Thus,
				   this code is relying on the NOT_IMPOSSIBLE() test, above,
				   to make sure the sttype[vend]=B case gets into this switch.
				*/
			   } /* end switch over parent state type v */
			} /* end inner loop over d */
		 } /* end outer loop over jp */
	  } /* end conditional section for dealing w/ v->EL local end transitions */

	  /* Recycle memory */
	  if (! do_full)
	  {
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			touch[y]--;
			if (touch[y] == 0) { deckpool_push(dpool, beta->J[y]); beta->J[y] = NULL; }
		 }
	  }
   } /* end loop over decks v */

   /* Clean-up */
   if (ret_beta == NULL)
   {
	  for (v = w1; v <= vend; v++)
		 if (beta->J[v] != NULL) { deckpool_push(dpool, beta->J[v]); beta->J[v] = NULL; }
	  deckpool_push(dpool, beta->J[cm->M]); beta->J[cm->M] = NULL;
	  free(beta->L[0]); free(beta->L);
	  free(beta->R[0]); free(beta->R);
   }
   else
   {
	  ret_beta->J = beta->J;
	  ret_beta->L = beta->L;
	  ret_beta->R = beta->R;
   }
   free(beta);

   if (ret_dpool == NULL)
   {
	  float **a;
	  while (deckpool_pop(dpool,&a)) free_vjd_deck(a, i0, j0);
	  deckpool_free(dpool);
   }
   else
   {
	  *ret_dpool = dpool;
   }
   free(touch);

   if (ret_mode != NULL) *ret_mode = b_mode;
   if (ret_v    != NULL) *ret_v    = b_v;
   if (ret_j    != NULL) *ret_j    = b_j;

   return b_sc;
}

/* Function: tr_vinside()
 * Author:   DLK
 *
 * Purpose:  Inside-type tr-CYK for a v-problem
 *           Closely modeled on vinside() and tr_inside()
 *           Note use of vji coordinates rather than vjd
 * Args:
 *
 * Returns:
 */
float
tr_vinside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int z, int i0, int i1, int j1, int j0,
		   int useEL, int do_full, int allow_begin,
		   int r_allow_J, int r_allow_L, int r_allow_R,
		   int z_allow_J, int z_allow_L, int z_allow_R,
		   AlphaMats_t *arg_alpha, AlphaMats_t *ret_alpha,
		   struct deckpool_s *dpool, struct deckpool_s **ret_dpool,
		   ShadowMats_t *ret_shadow, int *ret_mode, int *ret_v, int *ret_i, int *ret_j)
{
   int v,i,j;
   int w1, w2;
   int jp, ip;
   int *touch;
   int y, yoffset;
   float sc;

   float b_sc;
   int b_v, b_i, b_j, b_mode;

   AlphaMats_t *alpha;
   ShadowMats_t *shadow;

   /* Initialization */
   b_v = -1;
   b_i = i0;
   b_j = j0;
   b_mode = 3;
   b_sc = IMPOSSIBLE;

   if ( dpool == NULL ) dpool = deckpool_create();

   alpha = malloc(sizeof(AlphaMats_t));
   shadow = malloc(sizeof(ShadowMats_t));

   /* Create and initialize score matrices */
   if ( arg_alpha == NULL )
   {
	  alpha->J = NULL; alpha->L = NULL; alpha->R = NULL;
   }
   else
   {
	  alpha->J = arg_alpha->J; alpha->L = arg_alpha->L; alpha->R = arg_alpha->R;
   }

   if ( alpha->J == NULL )
   {
	  alpha->J = malloc(sizeof(float **) * (cm->M+1));
	  for (v = 0; v <= cm->M; v++) { alpha->J[v] = NULL; }
   }
   if ( alpha->L == NULL )
   {
	  alpha->L = malloc(sizeof(float **) * (cm->M+1));
	  for (v = 0; v <= cm->M; v++) { alpha->L[v] = NULL; }
   }
   if ( alpha->R == NULL )
   {
	  alpha->R = malloc(sizeof(float **) * (cm->M+1));
	  for (v = 0; v <= cm->M; v++) { alpha->R[v] = NULL; }
   }

   w1 = cm->nodemap[cm->ndidx[z]];
   w2 = cm->cfirst[w1]-1;
   for (v = w1; v <= w2; v++)
   {
	  if (! deckpool_pop(dpool, &(alpha->J[v])) )
		 alpha->J[v] = alloc_vji_deck(i0, i1, j1, j0);
	  if (! deckpool_pop(dpool, &(alpha->L[v])) )
		 alpha->L[v] = alloc_vji_deck(i0, i1, j1, j0);
	  if (! deckpool_pop(dpool, &(alpha->R[v])) )
		 alpha->R[v] = alloc_vji_deck(i0, i1, j1, j0);
	  for (jp = 0; jp <= j0-j1; jp++)
	  {
		 for (ip = 0; ip <= i1-i0; ip++)
		 {
			alpha->J[v][jp][ip] = IMPOSSIBLE;
			alpha->L[v][jp][ip] = IMPOSSIBLE;
			alpha->R[v][jp][ip] = IMPOSSIBLE;
		 }
	  }
   }

   touch = malloc(sizeof(int) * cm->M);
   for (v = 0;    v < r;     v++) { touch[v] = 0; }
   for (v = r;    v <= w2;   v++) { touch[v] = cm->pnum[v]; }
   for (v = w2+1; v < cm->M; v++) { touch[v] = 0; }

   /* Create shadow matrices */
   if (ret_shadow != NULL)
   {
	  shadow->J     = malloc(sizeof(char **) * cm->M);
	  shadow->L     = malloc(sizeof(char **) * cm->M);
	  shadow->R     = malloc(sizeof(char **) * cm->M);
	  shadow->Lmode = malloc(sizeof(char **) * cm->M);
	  shadow->Rmode = malloc(sizeof(char **) * cm->M);
	  for (v = 0; v < cm->M; v++)
	  {
		 shadow->J[v]      = NULL;
		 shadow->L[v]      = NULL;
		 shadow->R[v]      = NULL;
		 shadow->Lmode[v] = NULL;
		 shadow->Rmode[v] = NULL;
	  }
   }

   /* Initialize our non-IMPOSSIBLE boundary condition */
   /* (Includes an unroll of the main recursion to handle EL) */
   ip = i1 - i0;
   jp = 0;
   if (! useEL)
   {
	  if ( z_allow_J )
		 alpha->J[z][jp][ip] = 0.0;
	  if ( z_allow_L )
		 alpha->L[z][jp][ip] = 0.0;
	  if ( z_allow_R )
		 alpha->R[z][jp][ip] = 0.0;
   }
   else if ( z_allow_J )
   {
	  if (ret_shadow != NULL)
	  {
		 shadow->J[z]     = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->L[z]     = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->R[z]     = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->Lmode[z] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->Rmode[z] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
	  }

	  switch (cm->sttype[z])
	  {
		 case  D_st:
		 case  S_st:
			alpha->J[z][jp][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
			if (ret_shadow != NULL) ((char **)shadow->J[z])[jp][ip] = USED_EL;
			break;
		 case MP_st:
			if (i0 == i1 || j1 == j0) break;
			alpha->J[z][jp+1][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
			if (dsq[i1-1] < cm->abc->K && dsq[j1+1] < cm->abc->K)
			   alpha->J[z][jp+1][ip-1] += cm->esc[z][(int) (dsq[i1-1]*cm->abc->K+dsq[j1+1])];
			else
			   alpha->J[z][jp+1][ip-1] += DegeneratePairScore(cm->abc, cm->esc[z], dsq[i1-1], dsq[j1+1]);
			if (ret_shadow != NULL) ((char **)shadow->J[z])[jp+1][ip-1] = USED_EL;
			if (alpha->J[z][jp+1][ip-1] < IMPOSSIBLE) alpha->J[z][jp+1][ip-1] = IMPOSSIBLE;
			break;
		 case ML_st:
		 case IL_st:
			if (i0 == i1 ) break;
			alpha->J[z][jp][ip-1] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
			if (dsq[i1-1] < cm->abc->K)
			   alpha->J[z][jp][ip-1] += cm->esc[z][(int) dsq[i1-1]];
			else
			   alpha->J[z][jp][ip-1] += esl_abc_FAvgScore(cm->abc, dsq[i1-1], cm->esc[z]);
			if (ret_shadow != NULL) ((char **)shadow->J[z])[jp][ip-1] = USED_EL;
			if (alpha->J[z][jp][ip-1] < IMPOSSIBLE) alpha->J[z][jp][ip-1] = IMPOSSIBLE;
			break;
		 case MR_st:
		 case IR_st:
			if (j1 == j0) break;
			alpha->J[z][jp+1][ip] = cm->endsc[z] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1));
			if (dsq[j1+1] < cm->abc->K)
			   alpha->J[z][jp+1][ip] += cm->esc[z][(int) dsq[j1+1]];
			else
			   alpha->J[z][jp+1][ip] += esl_abc_FAvgScore(cm->abc, dsq[j1+1], cm->esc[z]);
			if (ret_shadow != NULL) ((char **)shadow->J[z])[jp+1][ip] = USED_EL;
			if (alpha->J[z][jp+1][ip] < IMPOSSIBLE) alpha->J[z][jp+1][ip] = IMPOSSIBLE;
			break;
/*
		 default:
			cm_Die("Bad input combination in tr_vinside: useEL TRUE, but cm->sttype[z] = %d\n",cm->sttype[z]);
*/
	  }

	  alpha->L[z][jp][ip] = IMPOSSIBLE;
	  alpha->R[z][jp][ip] = IMPOSSIBLE;
	  if (ret_shadow != NULL)
	  {
		 /* didn't actually use EL, but this prevents a traceback bug */
		 ((char **)shadow->L[z])[jp][ip] = USED_EL;
		 ((char **)shadow->R[z])[jp][ip] = USED_EL;
	  }
   }
   else
	  cm_Die("Bad input combination in tr_vinside: useEL %d z_allow_J %d \n",useEL,z_allow_J);

   /* Special case: empty sequence */
   if (r == 0)
   {
	  b_v = z; b_i = i1; b_j = j1;
	  b_sc = IMPOSSIBLE; b_mode = 0;
	  if (z_allow_J && alpha->J[z][0][i1-i0] > b_sc)
	  {
		 b_sc = alpha->J[z][0][i1-i0];
		 b_mode = 3;
	  }
	  if (z_allow_L && alpha->L[z][0][i1-i0] > b_sc)
	  {
		 b_sc = alpha->L[z][0][i1-i0];
		 b_mode = 2;
	  }
	  if (z_allow_R && alpha->R[z][0][i1-i0] > b_sc)
	  {
		 b_sc = alpha->R[z][0][i1-i0];
		 b_mode = 1;
	  }

	  if (z == 0)
	  {
	/* FIXME */
	/* I don't understand what exactly Sean's doing in this block */
		 cm_Die("Potentially unhandled case!\n");
	  }
   }

   /* Main recursion */
   for (v = w1-1; v >= r; v--)
   {
	  /* Get decks */
	  if (! deckpool_pop(dpool, &(alpha->J[v])) )
		 alpha->J[v] = alloc_vji_deck(i0,i1,j1,j0);
	  if (! deckpool_pop(dpool, &(alpha->L[v])) )
		 alpha->L[v] = alloc_vji_deck(i0,i1,j1,j0);
	  if (! deckpool_pop(dpool, &(alpha->R[v])) )
		 alpha->R[v] = alloc_vji_deck(i0,i1,j1,j0);

	  if (ret_shadow != NULL)
	  {
		 shadow->J[v] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->L[v] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->R[v] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->Lmode[v] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
		 shadow->Rmode[v] = (void **) alloc_vji_shadow_deck(i0,i1,j1,j0);
	  }

	  /* Full initialization of the deck */
	  /* This may be wasteful, since it could be folded into the rest
	   * of the DP */
	  for (jp = 0; jp <= j0-j1; jp++)
		 for (ip = i1-i0; ip >= 0; ip--)
		 {
			alpha->J[v][jp][ip] = IMPOSSIBLE;
			alpha->L[v][jp][ip] = IMPOSSIBLE;
			alpha->R[v][jp][ip] = IMPOSSIBLE;
			if (ret_shadow != NULL)
			{
			   /* Didn't really use EL, but trying to eliminate uninitialized values */
			   ((char **)shadow->J[v])[jp][ip] = USED_EL;
			   ((char **)shadow->L[v])[jp][ip] = USED_EL;
			   ((char **)shadow->R[v])[jp][ip] = USED_EL;
			   ((char **)shadow->Lmode[v])[jp][ip] = 0;
			   ((char **)shadow->Rmode[v])[jp][ip] = 0;
			}
		 }

	  /* Double-check problem type */
	  if (cm->sttype[v] == E_st || cm->sttype[v] == B_st || (cm->sttype[v] == S_st && v > r))
		 cm_Die("Non-V problem in tr_vinside(); cm->sttype[%d] = %d\n",v,cm->sttype[v]);

	  if (cm->sttype[v] == D_st || cm->sttype[v] == S_st)
	  {
		 for (jp = 0; jp <= j0-j1; jp++)
		 {
			for (ip = i1-i0; ip >= 0; ip--)
			{
			   y = cm->cfirst[v];
			   if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) && z_allow_J)
				  if ( (sc = cm->endsc[v] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1))) > alpha->J[v][jp][ip])
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = USED_EL;
				  }

			   for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
			   {
				  if ( z_allow_J )
				  if ( (sc = alpha->J[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->J[v][jp][ip])
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = (char) yoffset;
				  }
				  if ( r_allow_L )
				  if ( (sc = alpha->L[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 2; }
				  }
				  if ( r_allow_R )
				  if ( (sc = alpha->R[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 1; }
				  }
			   }

			   if ( alpha->J[v][jp][ip] < IMPOSSIBLE ) alpha->J[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->L[v][jp][ip] < IMPOSSIBLE ) alpha->L[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->R[v][jp][ip] < IMPOSSIBLE ) alpha->R[v][jp][ip] = IMPOSSIBLE;
			}
		 }
	  }
	  else if (cm->sttype[v] == MP_st)
	  {
		 for  (jp = 0; jp <= j0-j1; jp++)
		 {
			j = jp+j1;
			for (ip = i1-i0; ip >= 0; ip--)
			{
			   i = ip+i0;
			   y = cm->cfirst[v];

			   if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) && z_allow_J && jp > 0 && ip < i1-i0)
				  if ( (sc = cm->endsc[v] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - 2))) > alpha->J[v][jp][ip] )
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = USED_EL;
				  }

			   for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
			   {
				  if (z_allow_J && jp > 0 && ip < i1-i0)
				  if ( (sc = alpha->J[y+yoffset][jp-1][ip+1] + cm->tsc[v][yoffset]) > alpha->J[v][jp][ip])
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = (char) yoffset;
				  }
				  if (r_allow_L && ip < i1-i0)
				  if ( (sc = alpha->J[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 3; }
				  }
				  if (r_allow_L && ip < i1-i0)
				  if ( (sc = alpha->L[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 2; }
				  }
				  if (r_allow_R && jp > 0)
				  if ( (sc = alpha->J[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 3; }
				  }
				  if (r_allow_R && jp > 0)
				  if ( (sc = alpha->R[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 1; }
				  }
			   }

			   if (jp > 0 && ip < i1-i0)
			   {
				  if (dsq[i] < cm->abc->K && dsq[j] < cm->abc->K)
					 alpha->J[v][jp][ip] += cm->esc[v][(int) (dsq[i]*cm->abc->K+dsq[j])];
				  else
					 alpha->J[v][jp][ip] += DegeneratePairScore(cm->abc, cm->esc[v], dsq[i], dsq[j]);
			   }
			   if (ip < i1-i0)
			   {
				  alpha->L[v][jp][ip] += cm->lmesc[v][(int) dsq[i]];
			   }
			   if (jp > 0)
			   {
				  alpha->R[v][jp][ip] += cm->rmesc[v][(int) dsq[j]];
			   }

			   if ( alpha->J[v][jp][ip] < IMPOSSIBLE) alpha->J[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->L[v][jp][ip] < IMPOSSIBLE) alpha->L[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->R[v][jp][ip] < IMPOSSIBLE) alpha->R[v][jp][ip] = IMPOSSIBLE;

			   if ( allow_begin )
			   {
				  if ( r_allow_J )
				  if ( alpha->J[v][jp][ip] > b_sc ) { b_mode = 3; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->J[v][jp][ip]; }
				  if ( r_allow_L )
				  if ( alpha->L[v][jp][ip] > b_sc ) { b_mode = 2; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->L[v][jp][ip]; }
				  if ( r_allow_R )
				  if ( alpha->R[v][jp][ip] > b_sc ) { b_mode = 1; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->R[v][jp][ip]; }
			   }
			}
		 }
	  }
	  else if (cm->sttype[v] == ML_st || cm->sttype[v] == IL_st)
	  {
		 for (jp = 0; jp <= j0-j1; jp++)
		 {
			for (ip = i1-i0; ip >= 0; ip--)
			{
			   i = i0+ip;
			   y = cm->cfirst[v];

			   if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) && z_allow_J && ip < i1-i0)
				  if ( (sc = cm->endsc[v] + (cm->el_selfsc * ((jp+j1)-(ip+i0)+1 - 1))) > alpha->J[v][jp][ip] )
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = USED_EL;
				  }

			   for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
			   {
				  if (z_allow_J && ip < i1-i0)
				  if ( (sc = alpha->J[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) > alpha->J[v][jp][ip])
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = (char) yoffset;
				  }
				  if (r_allow_L && ip < i1-i0)
				  if ( (sc = alpha->L[y+yoffset][jp][ip+1] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 2; }
				  }
				  if ( r_allow_R )
				  if ( (sc = alpha->J[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 3; }
				  }
				  if ( r_allow_R )
				  if ( (sc = alpha->R[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 1; }
				  }
			   }

			   if (ip < i1-i0)
			   {
				  if (dsq[i] < cm->abc->K)
				  {
					 alpha->J[v][jp][ip] += cm->esc[v][(int) dsq[i]];
					 alpha->L[v][jp][ip] += cm->esc[v][(int) dsq[i]];
				  }
				  else
				  {
					 alpha->J[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
					 alpha->L[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[i], cm->esc[v]);
				  }
			   }

			   if ( alpha->J[v][jp][ip] < IMPOSSIBLE) alpha->J[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->L[v][jp][ip] < IMPOSSIBLE) alpha->L[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->R[v][jp][ip] < IMPOSSIBLE) alpha->R[v][jp][ip] = IMPOSSIBLE;

			   if ( cm->sttype[v] == ML_st && allow_begin )
			   {
				  if ( r_allow_J )
				  if ( alpha->J[v][jp][ip] > b_sc ) { b_mode = 3; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->J[v][jp][ip]; }
				  if ( r_allow_L )
				  if ( alpha->L[v][jp][ip] > b_sc ) { b_mode = 2; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->L[v][jp][ip]; }
			   }
			}
		 }
	  }
	  else if (cm->sttype[v] == MR_st || cm->sttype[v] == IR_st)
	  {
		 for (jp = 0; jp <= j0-j1; jp++)
		 {
			j = j1+jp;
			for (ip = i1-i0; ip >= 0; ip--)
			{
			   y = cm->cfirst[v];

			   if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]) && z_allow_J && jp > 0)
				  if ( (sc = cm->endsc[v] + (cm->el_selfsc * ((j1+jp)-(i0+ip)+1 - 1))) > alpha->J[v][jp][ip] )
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = USED_EL;
				  }

			   for (yoffset = 0; yoffset < cm->cnum[v]; yoffset++)
			   {
				  if (z_allow_J && jp > 0)
				  if ( (sc = alpha->J[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) > alpha->J[v][jp][ip])
				  {
					 alpha->J[v][jp][ip] = sc;
					 if (ret_shadow != NULL) ((char **)shadow->J[v])[jp][ip] = (char) yoffset;
				  }
				  if ( r_allow_L )
				  if ( (sc = alpha->J[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 3; }
				  }
				  if ( r_allow_L )
				  if ( (sc = alpha->L[y+yoffset][jp][ip] + cm->tsc[v][yoffset]) > alpha->L[v][jp][ip])
				  {
					 alpha->L[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->L[v])[jp][ip] = (char) yoffset; ((char **)shadow->Lmode[v])[jp][ip] = 2; }
				  }
				  if (r_allow_R && jp > 0)
				  if ( (sc = alpha->R[y+yoffset][jp-1][ip] + cm->tsc[v][yoffset]) > alpha->R[v][jp][ip])
				  {
					 alpha->R[v][jp][ip] = sc;
					 if (ret_shadow != NULL) { ((char **)shadow->R[v])[jp][ip] = (char) yoffset; ((char **)shadow->Rmode[v])[jp][ip] = 1; }
				  }
			   }

			   if (jp > 0)
			   {
				  if (dsq[j] < cm->abc->K)
				  {
					 alpha->J[v][jp][ip] += cm->esc[v][(int) dsq[j]];
					 alpha->R[v][jp][ip] += cm->esc[v][(int) dsq[j]];
				  }
				  else
				  {
					 alpha->J[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
					 alpha->R[v][jp][ip] += esl_abc_FAvgScore(cm->abc, dsq[j], cm->esc[v]);
				  }
			   }

			   if ( alpha->J[v][jp][ip] < IMPOSSIBLE) alpha->J[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->L[v][jp][ip] < IMPOSSIBLE) alpha->L[v][jp][ip] = IMPOSSIBLE;
			   if ( alpha->R[v][jp][ip] < IMPOSSIBLE) alpha->R[v][jp][ip] = IMPOSSIBLE;

			   if ( cm->sttype[v] == MR_st && allow_begin )
			   {
				  if ( r_allow_J )
				  if ( alpha->J[v][jp][ip] > b_sc ) { b_mode = 3; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->J[v][jp][ip]; }
				  if ( r_allow_R )
				  if ( alpha->R[v][jp][ip] > b_sc ) { b_mode = 1; b_v = v; b_j = j1+jp; b_i = i0+ip; b_sc = alpha->R[v][jp][ip]; }
			   }
			}
		 }
	  }
	  else
	  {
		 cm_Die("There's no way we could have gotten here - should have died before now\n");
	  }

	  if (v == r)
	  {
		 if ( r_allow_J )
		 if ( alpha->J[v][j0-j1][0] > b_sc) { b_mode = 3; b_v = v; b_j = j0; b_i = i0; b_sc = alpha->J[v][j0-j1][0]; }
		 if ( r_allow_L )
		 if ( alpha->L[v][j0-j1][0] > b_sc) { b_mode = 2; b_v = v; b_j = j0; b_i = i0; b_sc = alpha->L[v][j0-j1][0]; }
		 if ( r_allow_R )
		 if ( alpha->R[v][j0-j1][0] > b_sc) { b_mode = 1; b_v = v; b_j = j0; b_i = i0; b_sc = alpha->R[v][j0-j1][0]; }
	  }

	  /* If we're at root, give it the best (local) score */
	  if (v == 0)
	  {
		 alpha->J[v][j0-j1][0] = b_sc;
		 alpha->L[v][j0-j1][0] = b_sc;
		 alpha->R[v][j0-j1][0] = b_sc;
		 if (ret_shadow != NULL)
		 {
			((char **)shadow->J[v])[j0-j1][0] = USED_LOCAL_BEGIN;
			((char **)shadow->L[v])[j0-j1][0] = USED_LOCAL_BEGIN;
			((char **)shadow->R[v])[j0-j1][0] = USED_LOCAL_BEGIN;
			((char **)shadow->Lmode[v])[j0-j1][0] = b_mode;
			((char **)shadow->Rmode[v])[j0-j1][0] = b_mode;
		 }
	  }

	  /* Recycle memory */
	  if (! do_full)
	  {
		 for (y = cm->cfirst[v]; y < cm->cfirst[v]+cm->cnum[v]; y++)
		 {
			touch[y]--;
			if (touch[y] == 0)
			{
			   deckpool_push(dpool, alpha->J[y]);
			   deckpool_push(dpool, alpha->L[y]);
			   deckpool_push(dpool, alpha->R[y]);
			   alpha->J[y] = NULL;
			   alpha->L[y] = NULL;
			   alpha->R[y] = NULL;
			}
		 }
	  }
   } /* end loop over v */

   sc = b_sc;
   if (ret_v    != NULL ) *ret_v    = b_v;
   if (ret_i    != NULL ) *ret_i    = b_i;
   if (ret_j    != NULL ) *ret_j    = b_j;
   if (ret_mode != NULL ) *ret_mode = b_mode;

   /* Free or return score matrices */
   if (ret_alpha == NULL)
   {
	  for (v = r; v <= w2; v++)
	  {
		 if (alpha->J[v] != NULL)
		 {
			deckpool_push(dpool, alpha->J[v]);
			alpha->J[v] = NULL;
		 }
		 if (alpha->L[v] != NULL)
		 {
			deckpool_push(dpool, alpha->L[v]);
			alpha->L[v] = NULL;
		 }
		 if (alpha->R[v] != NULL)
		 {
			deckpool_push(dpool, alpha->R[v]);
			alpha->R[v] = NULL;
		 }
	  }
	  free(alpha->J);
	  free(alpha->L);
	  free(alpha->R);
   }
   else
   {
	  ret_alpha->J = alpha->J;
	  ret_alpha->L = alpha->L;
	  ret_alpha->R = alpha->R;
   }
   free(alpha);

   /* Free or return deck pool */
   if (ret_dpool == NULL)
   {
	  float **foo;
	  while (deckpool_pop(dpool, &foo))
		 free_vji_deck(foo, j1, j0);
	  deckpool_free(dpool);
   }
   else
   {
	  *ret_dpool = dpool;
   }

   free(touch);
   if (ret_shadow != NULL)
   {
	  ret_shadow->J = shadow->J;
	  ret_shadow->L = shadow->L;
	  ret_shadow->R = shadow->R;
	  ret_shadow->Lmode = shadow->Lmode;
	  ret_shadow->Rmode = shadow->Rmode;
   }
   free(shadow);

   return sc;
}

/* Function: tr_voutside()
 * Author:   DLK
 *
 * Purpose:  Outside direction TrCYK for a v-problem
 *           Based closely on voutside() and tr_outside()
 *           Note use of vji instead of vjd coordinates
 *
 * Args:
 *
 * Returns:
 */
void
tr_voutside(CM_t *cm, ESL_DSQ *dsq, int L, int r, int z, int i0, int i1, int j1, int j0,
			int useEL, int do_full, int r_allow_J, int r_allow_L, int r_allow_R,
			int z_allow_J, int z_allow_L, int z_allow_R, BetaMats_t *arg_beta,
			BetaMats_t *ret_beta, struct deckpool_s *dpool, struct deckpool_s **ret_dpool)
{
   int v,y;
   int i,j;
   int ip, jp;
   float sc, esc;
   int voffset;
   int *touch;
   int allow_begin;

   BetaMats_t *beta;

   /* Initialization */
   if (dpool == NULL) dpool = deckpool_create();

   beta = malloc(sizeof(BetaMats_t));
   if (arg_beta == NULL)
   {
	  beta->J = malloc(sizeof(float **) * (cm->M+1));
	  beta->L = malloc(sizeof(float  *) * (cm->M+1));
	  beta->R = malloc(sizeof(float  *) * (cm->M+1));
	  beta->L[0] = malloc(sizeof(float) * (cm->M+1)*(i1-i0+1));
	  beta->R[0] = malloc(sizeof(float) * (cm->M+1)*(j0-j1+1));
	  for (v = 0; v < cm->M+1; v++)
	  {
		 beta->J[v] = NULL;
		 beta->L[v] = beta->L[0] + (v * (i1-i0+1));
		 beta->R[v] = beta->R[0] + (v * (j0-j1+1));
	  }
   }
   else
   {
	  beta->J = arg_beta->J;
	  beta->L = arg_beta->L;
	  beta->R = arg_beta->R;
   }

   /* Initialize root deck */
   /* outside()/tr_outside() also initialize the root's
	  split set, if it has one, while voutside() doesn't
	  I think that this is because in calls to voutside()
	  (and analagously, tr_voutside() ) we've already
	  determined that the root state is actually used in
	  the solution, whereas for the more generic outside
	  that's not necessarily the case.  Not sure, though.
	  outside()/tr_outside() might not even need to worry
	  about the split set, but do it anyway (legacy code?) */
   if (! deckpool_pop(dpool, &(beta->J[r])) )
	  beta->J[r] = alloc_vji_deck(i0,i1,j1,j0);
   for (jp = 0; jp <= j0-j1; jp++)
   {
	  for (ip = 0; ip <= i1-i0; ip++)
		 if (r == 0 && r_allow_J )
			beta->J[r][jp][ip] = 0.0;
		 else
			beta->J[r][jp][ip] = IMPOSSIBLE;
	  if ( r == 0  && r_allow_R )
		 beta->R[r][jp] = 0.0;
	  else
		 beta->R[r][jp] = IMPOSSIBLE;
   }
   for (ip = 0; ip <= i1-i0; ip++)
   {
	  if (r == 0 && r_allow_L )
		 beta->L[r][ip] = 0.0;
	  else
		 beta->L[r][ip] = IMPOSSIBLE;
   }
   if ( r_allow_J )
	  beta->J[r][j0-j1][0] = 0.0;
   if ( r_allow_L )
	  beta->L[r][0] = 0.0;
   if ( r_allow_R )
	  beta->R[r][j0-j1] = 0.0;

   /* Deal with vroot->EL; marginal modes don't use EL */
   if (useEL)
   {
	  if (! deckpool_pop(dpool, &(beta->J[cm->M])) )
		 beta->J[cm->M] = alloc_vji_deck(i0,i1,j1,j0);
	  for (jp = 0; jp <= j0-j1; jp++)
		 for (ip = 0; ip <= i1-i0; ip++)
			beta->J[cm->M][jp][ip] = IMPOSSIBLE;
   }
   if (useEL && NOT_IMPOSSIBLE(cm->endsc[r]))
   {
	  switch(cm->sttype[r])
	  {
		 case MP_st:
			if (i0 == i1 || j1 == j0) break;
			if (dsq[i0] < cm->abc->K && dsq[j0] < cm->abc->K)
			   esc = cm->esc[r][(int) (dsq[i0]*cm->abc->K+dsq[j0])];
			else
			   esc = DegeneratePairScore(cm->abc, cm->esc[r], dsq[i0], dsq[j0]);
			beta->J[cm->M][j0-j1-1][1] = cm->endsc[r] + (cm->el_selfsc * ((j0-1)-(i0+1)+1)) + esc;
			if (beta->J[cm->M][j0-j1-1][1] < IMPOSSIBLE) beta->J[cm->M][j0-j1-1][1] = IMPOSSIBLE;
			break;
		 case ML_st:
		 case IL_st:
			if (i0 == i1) break;
			if (dsq[i0] < cm->abc->K)
			   esc = cm->esc[r][(int) dsq[i0]];
			else
			   esc = esl_abc_FAvgScore(cm->abc, dsq[i0], cm->esc[r]);
			beta->J[cm->M][j0-j1][1] = cm->endsc[r] + (cm->el_selfsc * ((j0)-(i0+1)+1)) + esc;
			if (beta->J[cm->M][j0-j1][1] < IMPOSSIBLE) beta->J[cm->M][j0-j1][1] = IMPOSSIBLE;
			break;
		 case MR_st:
		 case IR_st:
			if (j1 == j0) break;
			if (dsq[j0] < cm->abc->K)
			   esc = cm->esc[r][(int) dsq[j0]];
			else
			   esc = esl_abc_FAvgScore(cm->abc, dsq[j0], cm->esc[r]);
			beta->J[cm->M][j0-j1-1][0] = cm->endsc[r] + (cm->el_selfsc * ((j0-1)-(i0)+1)) + esc;
			if (beta->J[cm->M][j0-j1-1][0] < IMPOSSIBLE) beta->J[cm->M][j0-j1-1][0] = IMPOSSIBLE;
			break;
		 case  S_st:
		 case  D_st:
			beta->J[cm->M][j0-j1][0] = cm->endsc[r] + (cm->el_selfsc * ((j0)-(i0)+1));
			break;
		 default:
			cm_Die("bogus parent state %d\n",cm->sttype[r]);
	  }
   }

   /* Initialize touch vector for controlling deck recycling */
   touch = malloc(sizeof(int) * cm->M);
   for (v =   0; v <     r; v++) touch[v] = 0;
   for (v = z+1; v < cm->M; v++) touch[v] = 0;
   for (v =   r; v <=    z; v++)
   {
	  if (cm->sttype[v] == B_st) touch[v] = 2;
	  else                       touch[v] = cm->cnum[v];
   }

   /* Main loop through decks */
   for (v = r+1; v <= z; v++)
   {
	  allow_begin = TRUE;
	  if (r != 0) allow_begin = FALSE;
	  if ( cm->sttype[v] == IL_st ||
		   cm->sttype[v] == IR_st ||
		   cm->sttype[v] ==  S_st ||
		   cm->sttype[v] ==  D_st ||
		   cm->sttype[v] ==  E_st    ) allow_begin = FALSE;
	  /* Get a deck */
	  if (! deckpool_pop(dpool, &(beta->J[v])) )
		 beta->J[v] = alloc_vji_deck(i0,i1,j1,j0);
	  for (jp = j0-j1; jp >= 0; jp--)
	  {
		 for (ip = 0; ip <= i1-i0; ip++)
		 {
			if (allow_begin && r_allow_J )
			   beta->J[v][jp][ip] = 0.0;
			else
			   beta->J[v][jp][ip] = IMPOSSIBLE;
		 }
		 if (allow_begin && r_allow_R )
			beta->R[v][jp] = 0.0;
		 else
			beta->R[v][jp] = IMPOSSIBLE;
	  }
	  for (ip = 0; ip <= i1-i0; ip++)
	  {
		 if (allow_begin && r_allow_L )
			beta->L[v][ip] = 0.0;
		 else
			beta->L[v][ip] = IMPOSSIBLE;
	  }

	  /* mini-recursion for beta->L */
	  if ( r_allow_L )
	  for (ip = 0; ip <= i1-i0; ip++)
	  {
		 i = i0+ip;
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			if (y < r) continue;
			voffset = v - cm->cfirst[y];

			switch (cm->sttype[y])
			{
			   case MP_st:
				  if (ip > 0)
				  {
					 esc = cm->lmesc[y][(int) dsq[i-1]];
					 if ( (sc = beta->L[y][ip-1] + cm->tsc[y][voffset] + esc) > beta->L[v][ip] )
						beta->L[v][ip] = sc;
				  }
				  break;
			   case ML_st:
			   case IL_st:
				  if (ip > 0)
				  {
					 if (dsq[i-1] < cm->abc->K)
						esc = cm->esc[y][(int) dsq[i-1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);
					 if ( (sc = beta->L[y][ip-1] + cm->tsc[y][voffset] + esc) > beta->L[v][ip] )
						beta->L[v][ip] = sc;
				  }
				  break;
			   case MR_st:
			   case IR_st:
			   case  S_st:
			   case  E_st:
			   case  D_st:
				  if ( (sc = beta->L[y][ip] + cm->tsc[y][voffset]) > beta->L[v][ip] )
					 beta->L[v][ip] = sc;
				  break;
			   default:
				  cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			}
		 }

		 if (beta->L[v][ip] < IMPOSSIBLE) beta->L[v][ip] = IMPOSSIBLE;
	  }

	  /* mini-recursion for beta->R */
	  if ( r_allow_R )
	  for (jp = j0-j1; jp >= 0; jp--)
	  {
		 j = j1+jp;
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			if (y < r) continue;
			voffset = v - cm->cfirst[y];

			switch (cm->sttype[y])
			{
			   case MP_st:
				  if (jp < j0-j1)
				  {
					 esc = cm->rmesc[y][(int) dsq[j+1]];
					 if ( (sc = beta->R[y][jp+1] + cm->tsc[y][voffset] + esc) > beta->R[v][jp] )
						beta->R[v][jp] = sc;
				  }
				  break;
			   case MR_st:
			   case IR_st:
				  if (jp < j0-j1)
				  {
					 if (dsq[j+1] < cm->abc->K)
						esc = cm->esc[y][(int) dsq[j+1]];
					 else
						esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);
					 if ( (sc = beta->R[y][jp+1] + cm->tsc[y][voffset] + esc) > beta->R[v][jp] )
						beta->R[v][jp] = sc;
				  }
				  break;
			   case ML_st:
			   case IL_st:
			   case  S_st:
			   case  E_st:
			   case  D_st:
				  if ( (sc = beta->R[y][jp] + cm->tsc[y][voffset]) > beta->R[v][jp] )
					 beta->R[v][jp] = sc;
				  break;
			   default:
				  cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			}
		 }

		 if (beta->R[v][jp] < IMPOSSIBLE) beta->R[v][jp] = IMPOSSIBLE;
	  }

	  /* Main recursion */
	  if ( z_allow_J )
	  for (jp = j0-j1; jp >= 0; jp--)
	  {
		 j = j1+jp;
		 for (ip = 0; ip <= i1-i0; ip++)
		 {
			i = i0+ip;
			for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
			{
			   if (y < r) continue;
			   voffset = v - cm->cfirst[y];

			   switch(cm->sttype[y])
			   {
				  case MP_st:
					 if (j != j0 && i != i0)
					 {
						if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
						   esc = cm->esc[y][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
						else
						   esc = DegeneratePairScore(cm->abc, cm->esc[y], dsq[i-1], dsq[j+1]);
						if ( (sc = beta->J[y][jp+1][ip-1] + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->L[y][ip-1]       + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->R[y][jp+1]       + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
					 }
					 break;
				  case ML_st:
				  case IL_st:
					 if (i != i0)
					 {
						if (dsq[i-1] < cm->abc->K)
						   esc = cm->esc[y][(int) dsq[i-1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[y]);
						if ( (sc = beta->J[y][jp][ip-1] + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->L[y][ip-1]     + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->R[y][jp]       + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
					 }
					 break;
				  case MR_st:
				  case IR_st:
					 if (j != j0)
					 {
						if (dsq[j+1] < cm->abc->K)
						   esc = cm->esc[y][(int) dsq[j+1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[y]);
						if ( (sc = beta->J[y][jp+1][ip] + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->L[y][ip]       + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
						if ( (sc = beta->R[y][jp+1]     + cm->tsc[y][voffset] + esc) > beta->J[v][jp][ip] )
						   beta->J[v][jp][ip] = sc;
					 }
					 break;
				  case  S_st:
				  case  E_st:
				  case  D_st:
					 if ( (sc = beta->J[y][jp][ip] + cm->tsc[y][voffset]) > beta->J[v][jp][ip] )
						beta->J[v][jp][ip] = sc;
					 break;
				  default:
					 cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			   }
			}

			if (beta->J[v][jp][ip] < IMPOSSIBLE) beta->J[v][jp][ip] = IMPOSSIBLE;
		 }
	  }

	  /* v->EL transitions (beta->J only) */
	  if (useEL && NOT_IMPOSSIBLE(cm->endsc[v]))
	  {
		 for (jp = j0-j1; jp >= 0; jp--)
		 {
			j = j1+jp;
			for (ip = 0; ip <= i1-i0; ip++)
			{
			   i = i0+ip;

			   switch (cm->sttype[v])
			   {
				  case MP_st:
					 if (j != j0 && i != i0)
					 {
						if (dsq[i-1] < cm->abc->K && dsq[j+1] < cm->abc->K)
						   esc = cm->esc[v][(int) (dsq[i-1]*cm->abc->K+dsq[j+1])];
						else
						   esc = DegeneratePairScore(cm->abc, cm->esc[v], dsq[i-1], dsq[j+1]);
						if ( (sc = beta->J[v][jp+1][ip-1] + cm->endsc[v] + (cm->el_selfsc* (j-i+1)) + esc) > beta->J[cm->M][jp][ip] )
						   beta->J[cm->M][jp][ip] = sc;
					 }
					 break;
				  case ML_st:
				  case IL_st:
					 if (i != i0)
					 {
						if (dsq[i-1] < cm->abc->K)
						   esc = cm->esc[v][(int) dsq[i-1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[i-1], cm->esc[v]);
						if ( (sc = beta->J[v][jp][ip-1] + cm->endsc[v] + (cm->el_selfsc* (j-i+1)) + esc) > beta->J[cm->M][jp][ip] )
						   beta->J[cm->M][jp][ip] = sc;
					 }
					 break;
				  case MR_st:
				  case IR_st:
					 if (j != j0)
					 {
						if (dsq[j+1] < cm->abc->K)
						   esc = cm->esc[v][(int) dsq[j+1]];
						else
						   esc = esl_abc_FAvgScore(cm->abc, dsq[j+1], cm->esc[v]);
						if ( (sc = beta->J[v][jp+1][ip] + cm->endsc[v] + (cm->el_selfsc* (j-i+1)) + esc) > beta->J[cm->M][jp][ip] )
						   beta->J[cm->M][jp][ip] = sc;
					 }
					 break;
				  case  S_st:
				  case  E_st:
				  case  D_st:
					 if ( (sc = beta->J[v][jp][ip] + cm->endsc[v]  + (cm->el_selfsc * (j-1+1)) + esc) > beta->J[cm->M][jp][ip] )
						beta->J[cm->M][jp][ip] = sc;
				  default:
					 cm_Die("Bogus parent type %d for y = %d, v = %d\n",cm->sttype[y],y,v);
			   }

			   if (beta->J[cm->M][jp][ip] < IMPOSSIBLE) beta->J[cm->M][jp][ip] = IMPOSSIBLE;
			}
		 }
	  }

	  /* Recycle memory */
	  if (! do_full)
	  {
		 for (y = cm->plast[v]; y > cm->plast[v] - cm->pnum[v]; y--)
		 {
			touch[y]--;
			if (touch[y] == 0) { deckpool_push(dpool, beta->J[y]); beta->J[y] = NULL; }
		 }
	  }
   } /* end loop over decks v */

   /* Clean-up */
   if (ret_beta == NULL)
   {
	  for (v = r; v <= z; v++)
		 if (beta->J[v] != NULL) { deckpool_push(dpool, beta->J[v]); beta->J[v] = NULL; }
	  deckpool_push(dpool, beta->J[cm->M]); beta->J[cm->M] = NULL;
	  free(beta->L[0]); free(beta->L);
	  free(beta->R[0]); free(beta->R);
   }
   else
   {
	  ret_beta->J = beta->J;
	  ret_beta->L = beta->L;
	  ret_beta->R = beta->R;
   }
   free(beta);

   if (ret_dpool == NULL)
   {
	  float **a;
	  while (deckpool_pop(dpool, &a))
	  {
		 if (a == NULL) { fprintf(stderr,"WARNING: We've got issues: popped from deckpool but it's NULL!\n"); continue; }
		 free_vji_deck(a,j1,j0);
	  }
	  deckpool_free(dpool);
   }
   else
   {
	  *ret_dpool = dpool;
   }

   free(touch);

   return;
}

/* Function: tr_insideT()
 * Author:   DLK
 *
 * Purpose:  inside with traceback on truncated sequence
 *           based on insideT()
 *
 * Args:     cm      - the covariance model
 *           dsq     - the sequence, 1..L
 *           L       - length of the sequence
 *           tr      - Parsetree for traceback
 *           r       - root of subgraph to align to target subseq (usually 0, the model's root)
 *           z       - last state of the subgraph
 *           i0      - start of target subsequence (usually 1, beginning of dsq)
 *           j0      - end of target subsequence (usually L, end of dsq)
 *
 * Returns:  score of optimal alignment (float)
 */
float
tr_insideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z,
		  int i0, int j0, int r_allow_J, int r_allow_L, int r_allow_R, int lenCORREX)
{
  int         status;           /* easel status code */
   void    ***shadow;		/* standard shadow matrix with state information */
   void    ***L_shadow;		/* left marginal shadow matrix with state information */
   void    ***R_shadow;		/* right marginal shadow matrix with state information */
   void    ***T_shadow;		/* terminal shadow matrix with state information */
   void    ***Lmode_shadow;	/* left marginal shadow matrix with mode information */
   void    ***Rmode_shadow;	/* right marginal shadow matrix with mode information */
   float      sc;		/* score of the CYK alignment */
   ESL_STACK *pda;		/* stack for storing info of 2nd child at B_st */
   int        v,i,j,d;		/* indices for state, position, & distance */
   int        mode,nxtmode;
   int        k;
   int        y, yoffset;
   int        bifparent;

   ShadowMats_t *all_shadow;
   all_shadow = malloc(sizeof(ShadowMats_t));

/*
   sc = trinside(cm, dsq, L, r, z, i0, j0,
				 BE_EFFICIENT,
				 &shadow,
				 &L_shadow, &R_shadow, &T_shadow,
				 &Lmode_shadow, &Rmode_shadow,
				 &mode, &v, &i, &j );
 */

   sc = tr_inside(cm, dsq, L, r, z, i0, j0, BE_EFFICIENT,
				  (r == 0), r_allow_J, r_allow_L, r_allow_R, lenCORREX,
				  NULL, NULL, NULL, NULL, all_shadow,
				  &mode, &v, &i, &j);
   shadow = all_shadow->J;
   L_shadow = all_shadow->L;
   R_shadow = all_shadow->R;
   T_shadow = all_shadow->T;
   Lmode_shadow = all_shadow->Lmode;
   Rmode_shadow = all_shadow->Rmode;

   if((pda = esl_stack_ICreate()) == NULL) goto ERROR;
   d = j-i+1;

   if (r == 0)
   {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
   }

   while (1)
   {
	  if ( cm->sttype[v] == B_st )
	  {
		 if      ( mode == TRMODE_J )
		 {
			k = ((int **) shadow[v])[j][d];

			if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, mode)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;
		 }
		 else if ( mode == TRMODE_L )
		 {
			k = ((int **) L_shadow[v])[j][d];

			/* In left marginal mode, right child is always left marginal */
			if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, mode)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;

			/* Retrieve mode of left child (should be 3 or 2) */
			mode = ((int **)Lmode_shadow[v])[j][d];
		 }
		 else if ( mode == TRMODE_R )
		 {
			k = ((int **) R_shadow[v])[j][d];

			/* Retrieve mode of right child (should be 3 or 1) */
			mode = ((int **)Rmode_shadow[v])[j][d];
			if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, mode)) != eslOK) goto ERROR;
			if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;

			/* In right marginal mode, left child is always right marginal */
			mode = 1;
		 }
		 else if ( mode == TRMODE_T )
		 {
			k = ((int **) T_shadow[v])[j][d];

			 mode = 2;
			 if((status = esl_stack_IPush(pda, j)) != eslOK) goto ERROR;
			 if((status = esl_stack_IPush(pda, k)) != eslOK) goto ERROR;
			 if((status = esl_stack_IPush(pda, mode)) != eslOK) goto ERROR;
			 if((status = esl_stack_IPush(pda, tr->n-1)) != eslOK) goto ERROR;

			 mode = 1;
		 }
		 else { cm_Die("Unknown mode in traceback!"); }

		 j = j-k;
		 d = d-k;
		 i = j-d+1;
		 v = cm->cfirst[v];
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
	  }
	  else if ( (cm->sttype[v] == E_st) || (cm->sttype[v] == EL_st) )
	  {
		 if (esl_stack_IPop(pda, &bifparent) == eslEOD) break;
		 esl_stack_IPop(pda, &mode);
		 esl_stack_IPop(pda, &d);
		 esl_stack_IPop(pda, &j);
		 v = tr->state[bifparent];
		 y = cm->cnum[v];
		 i = j-d+1;

		 v = y;
		 InsertTraceNodewithMode(tr, bifparent, TRACE_RIGHT_CHILD, i, j, v, mode);
	  }
	  else
	  {
		 if      ( mode == TRMODE_J )
		 {
			yoffset = ((char **)   shadow[v])[j][d];
			nxtmode = 3;
		 }
		 else if ( mode == TRMODE_L )
		 {
			yoffset = ((char **) L_shadow[v])[j][d];
			nxtmode = ((int  **)Lmode_shadow[v])[j][d];
		 }
		 else if ( mode == TRMODE_R )
		 {
			yoffset = ((char **) R_shadow[v])[j][d];
			nxtmode = ((int  **)Rmode_shadow[v])[j][d];
		 }
		 else { cm_Die("Unknown mode in traceback!"); }

		 switch (cm->sttype[v])
		 {
			case  D_st:
			   break;
			case MP_st:
			   if ( mode == TRMODE_J )          i++;
			   if ( mode == TRMODE_L && d > 0 ) i++;
			   if ( mode == TRMODE_J )          j--;
			   if ( mode == TRMODE_R && d > 0 ) j--;
			   break;
			case ML_st:
			   if ( mode == TRMODE_J )          i++;
			   if ( mode == TRMODE_L && d > 0 ) i++;
			   break;
			case MR_st:
			   if ( mode == TRMODE_J )          j--;
			   if ( mode == TRMODE_R && d > 0 ) j--;
			   break;
			case IL_st:
			   if ( mode == TRMODE_J )          i++;
			   if ( mode == TRMODE_L && d > 0 ) i++;
			   break;
			case IR_st:
			   if ( mode == TRMODE_J )          j--;
			   if ( mode == TRMODE_R && d > 0 ) j--;
			   break;
			case  S_st:
			   break;
			default:
			   cm_Die("'Inconceivable!'\n'You keep using that word...'");
		 }
		 d = j-i+1;

		 if ( yoffset == USED_EL )
		 {
			v = cm->M;
			if (mode == TRMODE_J)
			{
			   InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
			}
		 }
		 else if ( yoffset == USED_LOCAL_BEGIN )
		 {  /* local begin, can only happen once, from root */
			/* However, all hits from truncyk() are local hits, and this should have
			   been dealt with immediately after return from the DP function.
			   If we've reached this point, there's a major problem */
			cm_Die("Impossible local begin in traceback\n");
		 }
		 else
		 {
			mode = nxtmode;
			v = cm->cfirst[v] + yoffset;
			InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
		 }
	  }
   }

   esl_stack_Destroy(pda);
   free_vjd_shadow_matrix(shadow, cm, i0, j0);
   free_vjd_shadow_matrix(L_shadow, cm, i0, j0);
   free_vjd_shadow_matrix(R_shadow, cm, i0, j0);
   free_vjd_shadow_matrix(T_shadow, cm, i0, j0);
   free_vjd_shadow_matrix(Lmode_shadow, cm, i0, j0);
   free_vjd_shadow_matrix(Rmode_shadow, cm, i0, j0);

   return sc;

 ERROR:
   cm_Fail("Memory error.");
   return 0.; /* NEVERREACHED */
}

/* Function: tr_vinsideT()
 * Author:   DLK
 *
 * Purpose:  Traceback wrapper for tr_vinside()
 *           Appends trace to a traceback which
 *           already has state r at t->n-1
 * Args:
 *
 * Returns:
 */
float
tr_vinsideT(CM_t *cm, ESL_DSQ *dsq, int L, Parsetree_t *tr, int r, int z,
			int i0, int i1, int j1, int j0, int useEL,
			int r_allow_J, int r_allow_L, int r_allow_R,
			int z_allow_J, int z_allow_L, int z_allow_R)
{
   float sc;
   int v, i, j;
   int ip, jp;
   int mode, nxtmode;
   int yoffset;

   AlphaMats_t *alpha;
   ShadowMats_t *shadow;
   alpha  = malloc(sizeof(AlphaMats_t));
   shadow = malloc(sizeof(ShadowMats_t));

   if (r == z)
   {
	  if      ( r_allow_J ) mode = 3;
	  else if ( r_allow_L ) mode = 2;
	  else                  mode = 1;

	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i0, j0, r, mode);
	  return 0.0;
   }

   sc = tr_vinside(cm, dsq, L, r, z, i0, i1, j1, j0, useEL, BE_EFFICIENT, (r == 0),
				   r_allow_J, r_allow_L, r_allow_R, z_allow_J, z_allow_L, z_allow_R,
				   NULL, alpha, NULL, NULL, shadow, &mode, &v, &i, &j);

   if (r == 0)
   {
	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
   }

   if (r != 0 && r != v)
   {
	  v = r;
	  i = i0;
	  j = j0;
	  ip = 0; jp = j0-j1;
	  mode = 3;
	  if (alpha->L[v][jp][ip] > alpha->J[v][jp][ip])
		 mode = 2;
	  if (alpha->R[v][jp][ip] > alpha->J[v][jp][ip] && alpha->R[v][jp][ip] > alpha->L[v][jp][ip])
		 mode = 1;
   }

   free_vji_matrix(alpha->J, cm->M, j1, j0);
   free_vji_matrix(alpha->L, cm->M, j1, j0);
   free_vji_matrix(alpha->R, cm->M, j1, j0);
   free(alpha);

   /* start traceback */
   while (v != z)
   {
	  jp = j-j1;
	  ip = i-i0;

	  if      ( mode == TRMODE_J )
	  {
		 yoffset = ((char **) shadow->J[v])[jp][ip];
		 nxtmode = 3;
	  }
	  else if ( mode == TRMODE_L )
	  {
		 yoffset = ((char **) shadow->L[v])[jp][ip];
		 nxtmode = ((char **) shadow->Lmode[v])[jp][ip];
	  }
	  else if ( mode == TRMODE_R )
	  {
		 yoffset = ((char **) shadow->R[v])[jp][ip];
		 nxtmode = ((char **) shadow->Rmode[v])[jp][ip];
	  }
	  else
		 cm_Die("Unknown mode in traceback!\n");

	  switch (cm->sttype[v])
	  {
		 case  S_st:
		 case  D_st:
			break;
		 case MP_st:
			if ( mode == TRMODE_J || mode == TRMODE_L ) i++;
			if ( mode == TRMODE_J || mode == TRMODE_R ) j--;
			break;
		 case ML_st:
		 case IL_st:
			if ( mode == TRMODE_J || mode == TRMODE_L ) i++;
			break;
		 case MR_st:
		 case IR_st:
			if ( mode == TRMODE_J || mode == TRMODE_R ) j--;
			break;
		 default:
			cm_Die("'Inconceivable!'\n'Youu keep using that word...'");
	  }
	  mode = nxtmode;

	  if (yoffset == USED_EL)
	  {
		 v = cm->M;
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
		 break;
	  }
	  else if (yoffset == USED_LOCAL_BEGIN)
	  {   /* local begin, can only happen once, from root */
		 if (v != 0)
			cm_Die("Impossible local begin in traceback!\n");
		 else
			cm_Die("DEV: you actually need to deal with this local begin case\n");
	  }
	  else
	  {
		 v = cm->cfirst[v] + yoffset;
		 InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, v, mode);
	  }
   }

   if (useEL)
   {
	  switch (cm->sttype[z])
	  {
		 case MP_st: i++; j--; break;
		 case ML_st:
		 case IL_st: i++;      break;
		 case MR_st:
		 case IR_st:      j--; break;
	  }

	  InsertTraceNodewithMode(tr, tr->n-1, TRACE_LEFT_CHILD, i, j, cm->M, 3);
   }

   free_vji_shadow_matrix((char ***) shadow->J, cm->M, j1, j0);
   free_vji_shadow_matrix((char ***) shadow->L, cm->M, j1, j0);
   free_vji_shadow_matrix((char ***) shadow->R, cm->M, j1, j0);
   free_vji_shadow_matrix((char ***) shadow->Lmode, cm->M, j1, j0);
   free_vji_shadow_matrix((char ***) shadow->Rmode, cm->M, j1, j0);
   free(shadow);

   return sc;
}

/*** End of inlined file: truncyk.c ***/

